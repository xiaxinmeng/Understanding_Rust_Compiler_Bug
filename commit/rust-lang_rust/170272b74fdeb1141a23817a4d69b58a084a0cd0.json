{"sha": "170272b74fdeb1141a23817a4d69b58a084a0cd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3MDI3MmI3NGZkZWIxMTQxYTIzODE3YTRkNjliNThhMDg0YTBjZDA=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-10-28T22:32:56Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-08T22:58:27Z"}, "message": "Add a `PromoteTemps` pass\n\n`remove_storage_dead_and_drop` has been copied to `promote_temps` and\nnow operates on an array of `Candidate`s instead of a bitset.", "tree": {"sha": "84af2cef93c6e4d948a6645b03f08e3055d6ef6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84af2cef93c6e4d948a6645b03f08e3055d6ef6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/170272b74fdeb1141a23817a4d69b58a084a0cd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/170272b74fdeb1141a23817a4d69b58a084a0cd0", "html_url": "https://github.com/rust-lang/rust/commit/170272b74fdeb1141a23817a4d69b58a084a0cd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/170272b74fdeb1141a23817a4d69b58a084a0cd0/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3783ef6dbe5aa1bb322e11ac33bfc599492d3280", "url": "https://api.github.com/repos/rust-lang/rust/commits/3783ef6dbe5aa1bb322e11ac33bfc599492d3280", "html_url": "https://github.com/rust-lang/rust/commit/3783ef6dbe5aa1bb322e11ac33bfc599492d3280"}], "stats": {"total": 172, "additions": 137, "deletions": 35}, "files": [{"sha": "48a58f1d0ee57a9adcfa37ebfdcc248fde334084", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 137, "deletions": 1, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/170272b74fdeb1141a23817a4d69b58a084a0cd0/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/170272b74fdeb1141a23817a4d69b58a084a0cd0/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=170272b74fdeb1141a23817a4d69b58a084a0cd0", "patch": "@@ -17,20 +17,76 @@ use rustc::mir::*;\n use rustc::mir::interpret::ConstValue;\n use rustc::mir::visit::{PlaceContext, MutatingUseContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n-use rustc::ty::{self, List, TyCtxt};\n+use rustc::ty::{self, List, TyCtxt, TypeFoldable};\n use rustc::ty::subst::InternalSubsts;\n use rustc::ty::cast::CastTy;\n use syntax::ast::LitKind;\n use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc_index::vec::{IndexVec, Idx};\n+use rustc_index::bit_set::HybridBitSet;\n use rustc_target::spec::abi::Abi;\n \n+use std::cell::Cell;\n use std::{iter, mem, usize};\n \n+use crate::transform::{MirPass, MirSource};\n use crate::transform::check_consts::{qualifs, Item, ConstKind, is_lang_panic_fn};\n \n+/// A `MirPass` for promotion.\n+///\n+/// In this case, \"promotion\" entails the following:\n+/// - Extract promotable temps in `fn` and `const fn` into their own MIR bodies.\n+/// - Extend lifetimes in `const` and `static` by removing `Drop` and `StorageDead`.\n+/// - Emit errors if the requirements of `#[rustc_args_required_const]` are not met.\n+///\n+/// After this pass is run, `promoted_fragments` will hold the MIR body corresponding to each\n+/// newly created `StaticKind::Promoted`.\n+#[derive(Default)]\n+pub struct PromoteTemps<'tcx> {\n+    pub promoted_fragments: Cell<IndexVec<Promoted, Body<'tcx>>>,\n+}\n+\n+impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        // There's not really any point in promoting errorful MIR.\n+        //\n+        // This does not include MIR that failed const-checking, which we still try to promote.\n+        if body.return_ty().references_error() {\n+            tcx.sess.delay_span_bug(body.span, \"PromoteTemps: MIR had errors\");\n+            return;\n+        }\n+\n+        if src.promoted.is_some() {\n+            return;\n+        }\n+\n+        let def_id = src.def_id();\n+\n+        let item = Item::new(tcx, def_id, body);\n+        let mut rpo = traversal::reverse_postorder(body);\n+        let (temps, all_candidates) = collect_temps_and_candidates(tcx, body, &mut rpo);\n+\n+        let promotable_candidates = validate_candidates(tcx, body, def_id, &temps, &all_candidates);\n+\n+        // For now, lifetime extension is done in `const` and `static`s without creating promoted\n+        // MIR fragments by removing `Drop` and `StorageDead` for each referent. However, this will\n+        // not work inside loops when they are allowed in `const`s.\n+        //\n+        // FIXME: use promoted MIR fragments everywhere?\n+        let promoted_fragments = if should_create_promoted_mir_fragments(item.const_kind) {\n+            promote_candidates(def_id, body, tcx, temps, promotable_candidates)\n+        } else {\n+            // FIXME: promote const array initializers in consts.\n+            remove_drop_and_storage_dead_on_promoted_locals(tcx, body, &promotable_candidates);\n+            IndexVec::new()\n+        };\n+\n+        self.promoted_fragments.set(promoted_fragments);\n+    }\n+}\n+\n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TempState {\n@@ -1154,3 +1210,83 @@ crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n             should_promote={:?} feature_flag={:?}\", mir_def_id, should_promote, feature_flag);\n     should_promote && !feature_flag\n }\n+\n+fn should_create_promoted_mir_fragments(const_kind: Option<ConstKind>) -> bool {\n+    match const_kind {\n+        Some(ConstKind::ConstFn) | None => true,\n+        Some(ConstKind::Const) | Some(ConstKind::Static) | Some(ConstKind::StaticMut) => false,\n+    }\n+}\n+\n+/// In `const` and `static` everything without `StorageDead`\n+/// is `'static`, we don't have to create promoted MIR fragments,\n+/// just remove `Drop` and `StorageDead` on \"promoted\" locals.\n+fn remove_drop_and_storage_dead_on_promoted_locals(\n+    tcx: TyCtxt<'tcx>,\n+    body: &mut Body<'tcx>,\n+    promotable_candidates: &[Candidate],\n+) {\n+    debug!(\"run_pass: promotable_candidates={:?}\", promotable_candidates);\n+\n+    // Removing `StorageDead` will cause errors for temps declared inside a loop body. For now we\n+    // simply skip promotion if a loop exists, since loops are not yet allowed in a `const`.\n+    //\n+    // FIXME: Just create MIR fragments for `const`s instead of using this hackish approach?\n+    if body.is_cfg_cyclic() {\n+        tcx.sess.delay_span_bug(body.span, \"Control-flow cycle detected in `const`\");\n+        return;\n+    }\n+\n+    // The underlying local for promotion contexts like `&temp` and `&(temp.proj)`.\n+    let mut requires_lifetime_extension = HybridBitSet::new_empty(body.local_decls.len());\n+\n+    promotable_candidates\n+        .iter()\n+        .filter_map(|c| {\n+            match c {\n+                Candidate::Ref(loc) => Some(loc),\n+                Candidate::Repeat(_) | Candidate::Argument { .. } => None,\n+            }\n+        })\n+        .map(|&Location { block, statement_index }| {\n+            // FIXME: store the `Local` for each `Candidate` when it is created.\n+            let place = match &body[block].statements[statement_index].kind {\n+                StatementKind::Assign(box ( _, Rvalue::Ref(_, _, place))) => place,\n+                _ => bug!(\"`Candidate::Ref` without corresponding assignment\"),\n+            };\n+\n+            match place.base {\n+                PlaceBase::Local(local) => local,\n+                PlaceBase::Static(_) => bug!(\"`Candidate::Ref` for a non-local\"),\n+            }\n+        })\n+        .for_each(|local| {\n+            requires_lifetime_extension.insert(local);\n+        });\n+\n+    // Remove `Drop` terminators and `StorageDead` statements for all promotable temps that require\n+    // lifetime extension.\n+    for block in body.basic_blocks_mut() {\n+        block.statements.retain(|statement| {\n+            match statement.kind {\n+                StatementKind::StorageDead(index) => !requires_lifetime_extension.contains(index),\n+                _ => true\n+            }\n+        });\n+        let terminator = block.terminator_mut();\n+        match &terminator.kind {\n+            TerminatorKind::Drop {\n+                location,\n+                target,\n+                ..\n+            } => {\n+                if let Some(index) = location.as_local() {\n+                    if requires_lifetime_extension.contains(index) {\n+                        terminator.kind = TerminatorKind::Goto { target: *target };\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "aebc9d23492d72f6ae8037da69dccbf4cab0d0bd", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/170272b74fdeb1141a23817a4d69b58a084a0cd0/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/170272b74fdeb1141a23817a4d69b58a084a0cd0/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=170272b74fdeb1141a23817a4d69b58a084a0cd0", "patch": "@@ -1455,40 +1455,6 @@ fn check_short_circuiting_in_const_local(tcx: TyCtxt<'_>, body: &mut Body<'tcx>,\n     }\n }\n \n-/// In `const` and `static` everything without `StorageDead`\n-/// is `'static`, we don't have to create promoted MIR fragments,\n-/// just remove `Drop` and `StorageDead` on \"promoted\" locals.\n-fn remove_drop_and_storage_dead_on_promoted_locals(\n-    body: &mut Body<'tcx>,\n-    promoted_temps: &BitSet<Local>,\n-) {\n-    debug!(\"run_pass: promoted_temps={:?}\", promoted_temps);\n-\n-    for block in body.basic_blocks_mut() {\n-        block.statements.retain(|statement| {\n-            match statement.kind {\n-                StatementKind::StorageDead(index) => !promoted_temps.contains(index),\n-                _ => true\n-            }\n-        });\n-        let terminator = block.terminator_mut();\n-        match &terminator.kind {\n-            TerminatorKind::Drop {\n-                location,\n-                target,\n-                ..\n-            } => {\n-                if let Some(index) = location.as_local() {\n-                    if promoted_temps.contains(index) {\n-                        terminator.kind = TerminatorKind::Goto { target: *target };\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n fn check_static_is_sync(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, hir_id: HirId) {\n     let ty = body.return_ty();\n     tcx.infer_ctxt().enter(|infcx| {"}]}