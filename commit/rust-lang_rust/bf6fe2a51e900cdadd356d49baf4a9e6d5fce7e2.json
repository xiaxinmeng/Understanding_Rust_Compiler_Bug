{"sha": "bf6fe2a51e900cdadd356d49baf4a9e6d5fce7e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNmZlMmE1MWU5MDBjZGFkZDM1NmQ0OWJhZjRhOWU2ZDVmY2U3ZTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-06T16:38:49Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-09-06T23:58:23Z"}, "message": "region_name: rustfmt", "tree": {"sha": "975174b5cbbf93243e20f6fe7dcebc2ba6a54f97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/975174b5cbbf93243e20f6fe7dcebc2ba6a54f97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf6fe2a51e900cdadd356d49baf4a9e6d5fce7e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf6fe2a51e900cdadd356d49baf4a9e6d5fce7e2", "html_url": "https://github.com/rust-lang/rust/commit/bf6fe2a51e900cdadd356d49baf4a9e6d5fce7e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf6fe2a51e900cdadd356d49baf4a9e6d5fce7e2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2eb76fc8a17cbbbbefe12c6a4413b3d803c03941", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eb76fc8a17cbbbbefe12c6a4413b3d803c03941", "html_url": "https://github.com/rust-lang/rust/commit/2eb76fc8a17cbbbbefe12c6a4413b3d803c03941"}], "stats": {"total": 82, "additions": 42, "deletions": 40}, "files": [{"sha": "5ae123bdc18d16b45f81733cea4a71244af9cf03", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bf6fe2a51e900cdadd356d49baf4a9e6d5fce7e2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6fe2a51e900cdadd356d49baf4a9e6d5fce7e2/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=bf6fe2a51e900cdadd356d49baf4a9e6d5fce7e2", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use borrow_check::nll::region_infer::RegionInferenceContext;\n-use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::universal_regions::DefiningTy;\n+use borrow_check::nll::ToRegionVid;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n@@ -107,23 +107,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 } else {\n                     None\n                 }\n-            },\n+            }\n \n             ty::ReStatic => Some(keywords::StaticLifetime.name().as_interned_str()),\n \n             ty::ReFree(free_region) => match free_region.bound_region {\n                 ty::BoundRegion::BrNamed(_, name) => {\n                     self.highlight_named_span(tcx, error_region, &name, diag);\n                     Some(name)\n-                },\n+                }\n \n                 ty::BoundRegion::BrEnv => {\n                     let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).expect(\"non-local mir\");\n                     let def_ty = self.universal_regions.defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n-                        let args_span = if let hir::ExprKind::Closure(_, _, _, span, _)\n-                            = tcx.hir.expect_expr(mir_node_id).node\n+                        let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n+                            tcx.hir.expect_expr(mir_node_id).node\n                         {\n                             span\n                         } else {\n@@ -201,16 +201,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let node = tcx.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n \n         let mut sp = cm.def_span(tcx.hir.span(node));\n-        if let Some(param) = tcx.hir.get_generics(scope).and_then(|generics| {\n-            generics.get_named(name)\n-        }) {\n+        if let Some(param) = tcx.hir\n+            .get_generics(scope)\n+            .and_then(|generics| generics.get_named(name))\n+        {\n             sp = param.span;\n         }\n \n-        diag.span_label(\n-            sp,\n-            format!(\"lifetime `{}` defined here\", name),\n-        );\n+        diag.span_label(sp, format!(\"lifetime `{}` defined here\", name));\n     }\n \n     /// Find an argument that contains `fr` and label it with a fully\n@@ -248,14 +246,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(\n-            infcx,\n-            mir,\n-            fr,\n-            arg_ty,\n-            counter,\n-            diag,\n-        )\n+        self.give_name_if_we_cannot_match_hir_ty(infcx, mir, fr, arg_ty, counter, diag)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n@@ -320,8 +311,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             infcx.extract_type_name(&argument_ty)\n         });\n \n-        debug!(\"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n-               type_name, needle_fr);\n+        debug!(\n+            \"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n+            type_name, needle_fr\n+        );\n         let assigned_region_name = if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n             let argument_index = self.get_argument_index_for_region(infcx.tcx, needle_fr)?;\n@@ -553,13 +546,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<InternedString> {\n         let upvar_index = self.get_upvar_index_for_region(tcx, fr)?;\n-        let (upvar_name, upvar_span) = self.get_upvar_name_and_span_for_region(tcx, mir,\n-                                                                               upvar_index);\n+        let (upvar_name, upvar_span) =\n+            self.get_upvar_name_and_span_for_region(tcx, mir, upvar_index);\n         let region_name = self.synthesize_region_name(counter);\n \n         diag.span_label(\n             upvar_span,\n-            format!(\"lifetime `{}` appears in the type of `{}`\", region_name, upvar_name),\n+            format!(\n+                \"lifetime `{}` appears in the type of `{}`\",\n+                region_name, upvar_name\n+            ),\n         );\n \n         Some(region_name)\n@@ -585,27 +581,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             \"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\",\n             return_ty\n         );\n-        if !infcx.tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n+        if !infcx\n+            .tcx\n+            .any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr)\n+        {\n             return None;\n         }\n \n-        let type_name = with_highlight_region(fr, *counter, || {\n-            infcx.extract_type_name(&return_ty)\n-        });\n+        let type_name = with_highlight_region(fr, *counter, || infcx.extract_type_name(&return_ty));\n \n         let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).expect(\"non-local mir\");\n \n-        let (return_span, mir_description) = if let hir::ExprKind::Closure(_, _, _, span, gen_move)\n-            = tcx.hir.expect_expr(mir_node_id).node\n-        {\n-            (\n-                tcx.sess.source_map().end_point(span),\n-                if gen_move.is_some() { \" of generator\" } else { \" of closure\" }\n-            )\n-        } else {\n-            // unreachable?\n-            (mir.span, \"\")\n-        };\n+        let (return_span, mir_description) =\n+            if let hir::ExprKind::Closure(_, _, _, span, gen_move) =\n+                tcx.hir.expect_expr(mir_node_id).node\n+            {\n+                (\n+                    tcx.sess.source_map().end_point(span),\n+                    if gen_move.is_some() {\n+                        \" of generator\"\n+                    } else {\n+                        \" of closure\"\n+                    },\n+                )\n+            } else {\n+                // unreachable?\n+                (mir.span, \"\")\n+            };\n \n         diag.span_label(\n             return_span,"}]}