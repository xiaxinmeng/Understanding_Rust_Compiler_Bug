{"sha": "4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkY2MzYTRhYWU0OGQ0Y2U4NTZhMmRiMmExMjM0YWYxOTBmYjJlYjg=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-08-08T12:34:37Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-08-11T10:11:38Z"}, "message": "Use DefIndex instead of NodeId in UpvarId.", "tree": {"sha": "41f637fe4c4611cc7e8c58f72479edae2cb6e197", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41f637fe4c4611cc7e8c58f72479edae2cb6e197"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "html_url": "https://github.com/rust-lang/rust/commit/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8cf6cc6db13efea1057dfefbe9e6b583b23ea4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8cf6cc6db13efea1057dfefbe9e6b583b23ea4f", "html_url": "https://github.com/rust-lang/rust/commit/a8cf6cc6db13efea1057dfefbe9e6b583b23ea4f"}], "stats": {"total": 227, "additions": 142, "deletions": 85}, "files": [{"sha": "279e62c631129d2ca8333d9d73b687a8dfd5fcc2", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -11,6 +11,7 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::ty in no particular order.\n \n+use hir::def_id::DefId;\n use ich::{self, StableHashingContext, NodeIdHashingMode};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n@@ -618,7 +619,7 @@ for ty::TypeckTables<'gcx> {\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TypeckTables {\n-            local_id_root: _,\n+            local_id_root,\n             ref type_dependent_defs,\n             ref node_types,\n             ref node_substs,\n@@ -649,8 +650,14 @@ for ty::TypeckTables<'gcx> {\n                     closure_expr_id\n                 } = *up_var_id;\n \n-                let var_def_id = hcx.tcx().hir.local_def_id(var_id);\n-                let closure_def_id = hcx.tcx().hir.local_def_id(closure_expr_id);\n+                let var_def_id = DefId {\n+                    krate: local_id_root.krate,\n+                    index: var_id,\n+                };\n+                let closure_def_id = DefId {\n+                    krate: local_id_root.krate,\n+                    index: closure_expr_id,\n+                };\n                 (hcx.def_path_hash(var_def_id), hcx.def_path_hash(closure_def_id))\n             });\n "}, {"sha": "b5390da7e852d184158109fae5afb6e16c733529", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -913,7 +913,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 format!(\" for capture of `{}` by closure\",\n-                        self.tcx.local_var_name_str(upvar_id.var_id).to_string())\n+                        self.tcx.local_var_name_str_def_index(upvar_id.var_id))\n             }\n         };\n "}, {"sha": "87047d0df144cca40f03a3f0c83ba835545f8a8d", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -45,8 +45,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.span_note(span,\n                               &format!(\"...so that closure can access `{}`\",\n                                        self.tcx\n-                                           .local_var_name_str(upvar_id.var_id)\n-                                           .to_string()));\n+                                           .local_var_name_str_def_index(upvar_id.var_id)));\n             }\n             infer::InfStackClosure(span) => {\n                 err.span_note(span, \"...so that closure does not outlive its stack frame\");\n@@ -176,18 +175,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0313,\n                                                \"lifetime of borrowed pointer outlives lifetime \\\n                                                 of captured variable `{}`...\",\n-                                               self.tcx.local_var_name_str(upvar_id.var_id));\n+                                               self.tcx\n+                                                   .local_var_name_str_def_index(upvar_id.var_id));\n                 self.tcx.note_and_explain_region(&mut err,\n                                                  \"...the borrowed pointer is valid for \",\n                                                  sub,\n                                                  \"...\");\n                 self.tcx\n-                    .note_and_explain_region(&mut err,\n-                                             &format!(\"...but `{}` is only valid for \",\n-                                                      self.tcx\n-                                                          .local_var_name_str(upvar_id.var_id)),\n-                                             sup,\n-                                             \"\");\n+                    .note_and_explain_region(\n+                      &mut err,\n+                      &format!(\"...but `{}` is only valid for \",\n+                               self.tcx.local_var_name_str_def_index(upvar_id.var_id)),\n+                      sup,\n+                      \"\");\n                 err\n             }\n             infer::InfStackClosure(span) => {"}, {"sha": "73800fe7f081a3bd7e34ef05f8497aa05ff3d1e7", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -890,10 +890,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n-                let def_id = freevar.def.def_id();\n-                let id_var = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-                let upvar_id = ty::UpvarId { var_id: id_var,\n-                                             closure_expr_id: closure_expr.id };\n+                let var_def_id = freevar.def.def_id();\n+                debug_assert!(var_def_id.is_local());\n+                let closure_def_id = self.tcx().hir.local_def_id(closure_expr.id);\n+                let upvar_id = ty::UpvarId {\n+                    var_id: var_def_id.index,\n+                    closure_expr_id: closure_def_id.index\n+                };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                    fn_decl_span,"}, {"sha": "08231a9ba1ba58f02d68deb4903636c3373868c6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -70,7 +70,7 @@ pub use self::Note::*;\n use self::Aliasability::*;\n \n use middle::region::RegionMaps;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, DefIndex};\n use hir::map as hir_map;\n use infer::InferCtxt;\n use hir::def::{Def, CtorKind};\n@@ -190,7 +190,7 @@ pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n pub enum ImmutabilityBlame<'tcx> {\n     ImmLocal(ast::NodeId),\n-    ClosureEnv(ast::NodeId),\n+    ClosureEnv(DefIndex),\n     LocalDeref(ast::NodeId),\n     AdtFieldDeref(&'tcx ty::AdtDef, &'tcx ty::FieldDef)\n }\n@@ -728,8 +728,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             None => span_bug!(span, \"missing closure kind\")\n         };\n \n-        let upvar_id = ty::UpvarId { var_id,\n-                                     closure_expr_id: fn_node_id };\n+        let closure_expr_def_index = self.tcx.hir.local_def_id(fn_node_id).index;\n+        let var_def_index = self.tcx.hir.local_def_id(var_id).index;\n+\n+        let upvar_id = ty::UpvarId {\n+            var_id: var_def_index,\n+            closure_expr_id: closure_expr_def_index\n+        };\n         let var_hir_id = self.tcx.hir.node_to_hir_id(var_id);\n         let var_ty = self.node_ty(var_hir_id)?;\n \n@@ -766,8 +771,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // If this is a by-ref capture, then the upvar we loaded is\n         // actually a reference, so we have to add an implicit deref\n         // for that.\n-        let upvar_id = ty::UpvarId { var_id,\n-                                     closure_expr_id: fn_node_id };\n         let upvar_capture = self.tables.upvar_capture(upvar_id);\n         let cmt_result = match upvar_capture {\n             ty::UpvarCapture::ByValue => {\n@@ -805,7 +808,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: self.tcx.hir.local_def_id(upvar_id.closure_expr_id),\n+            scope: DefId::local(upvar_id.closure_expr_id),\n             bound_region: ty::BrEnv\n         }));\n "}, {"sha": "af322fc72d8995b3cf7bb31865508ec0d2c0f3b4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -572,8 +572,8 @@ impl<T> Slice<T> {\n /// by the upvar) and the id of the closure expression.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UpvarId {\n-    pub var_id: NodeId,\n-    pub closure_expr_id: NodeId,\n+    pub var_id: DefIndex,\n+    pub closure_expr_id: DefIndex,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy)]\n@@ -1983,6 +1983,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn local_var_name_str_def_index(self, def_index: DefIndex) -> InternedString {\n+        let node_id = self.hir.as_local_node_id(DefId::local(def_index)).unwrap();\n+        self.local_var_name_str(node_id)\n+    }\n+\n     pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n          match expr.node {\n             hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {"}, {"sha": "184fd75135e471425084c505ebbe1c26c8345553", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -864,9 +864,9 @@ impl<'tcx> fmt::Display for ty::TyS<'tcx> {\n \n impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"UpvarId({};`{}`;{})\",\n+        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n                self.var_id,\n-               ty::tls::with(|tcx| tcx.local_var_name_str(self.var_id)),\n+               ty::tls::with(|tcx| tcx.local_var_name_str_def_index(self.var_id)),\n                self.closure_expr_id)\n     }\n }"}, {"sha": "bfd883be84876252e9671819c0980948d79dc78a", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -93,11 +93,11 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &Vec<Move\n             }\n         }\n         if let NoteClosureEnv(upvar_id) = error.move_from.note {\n-            err.span_label(bccx.tcx.hir.span(upvar_id.var_id),\n+            let var_node_id = bccx.tcx.hir.def_index_to_node_id(upvar_id.var_id);\n+            err.span_label(bccx.tcx.hir.span(var_node_id),\n                            \"captured outer variable\");\n         }\n         err.emit();\n-\n     }\n }\n "}, {"sha": "07981cc67fc73dec3b788c3907248d65ef58ded7", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -27,7 +27,7 @@ use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n@@ -323,8 +323,9 @@ pub enum LoanPathElem<'tcx> {\n     LpInterior(Option<DefId>, InteriorKind),\n }\n \n-pub fn closure_to_block(closure_id: ast::NodeId,\n-                        tcx: TyCtxt) -> ast::NodeId {\n+fn closure_to_block(closure_id: DefIndex,\n+                    tcx: TyCtxt) -> ast::NodeId {\n+    let closure_id = tcx.hir.def_index_to_node_id(closure_id);\n     match tcx.hir.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n             hir::ExprClosure(.., body_id, _) => {\n@@ -845,7 +846,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 } else {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n-                err.span_help(self.tcx.hir.span(id), help);\n+                let node_id = self.tcx.hir.def_index_to_node_id(id);\n+                err.span_help(self.tcx.hir.span(node_id), help);\n                 err\n             }\n             _ =>  {\n@@ -1181,7 +1183,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     _ => bug!()\n                 };\n                 if kind == ty::ClosureKind::Fn {\n-                    db.span_help(self.tcx.hir.span(upvar_id.closure_expr_id),\n+                    let closure_node_id =\n+                        self.tcx.hir.def_index_to_node_id(upvar_id.closure_expr_id);\n+                    db.span_help(self.tcx.hir.span(closure_node_id),\n                                  \"consider changing this closure to take \\\n                                   self by mutable reference\");\n                 }\n@@ -1214,7 +1218,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                       loan_path: &LoanPath<'tcx>,\n                                       out: &mut String) {\n         match loan_path.kind {\n-            LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }) |\n+            LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }) => {\n+                out.push_str(&self.tcx.local_var_name_str_def_index(id));\n+            }\n             LpVar(id) => {\n                 out.push_str(&self.tcx.local_var_name_str(id));\n             }\n@@ -1352,8 +1358,11 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n-                let s = ty::tls::with(|tcx| tcx.hir.node_to_string(var_id));\n-                write!(f, \"$({} captured by id={})\", s, closure_expr_id)\n+                let s = ty::tls::with(|tcx| {\n+                    let var_node_id = tcx.hir.def_index_to_node_id(var_id);\n+                    tcx.hir.node_to_string(var_node_id)\n+                });\n+                write!(f, \"$({} captured by id={:?})\", s, closure_expr_id)\n             }\n \n             LpDowncast(ref lp, variant_def_id) => {\n@@ -1384,7 +1393,10 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n-                let s = ty::tls::with(|tcx| tcx.hir.node_to_user_string(var_id));\n+                let s = ty::tls::with(|tcx| {\n+                    let var_node_id = tcx.hir.def_index_to_node_id(var_id);\n+                    tcx.hir.node_to_string(var_node_id)\n+                });\n                 write!(f, \"$({} captured by closure)\", s)\n             }\n "}, {"sha": "d029e2f10e8883000413b7a6dc7fca5a8fb4e9cc", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -368,10 +368,12 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     // Gather the upvars of a closure, if any.\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n-            let var_id = tcx.hir.as_local_node_id(fv.def.def_id()).unwrap();\n+            let var_def_id = fv.def.def_id();\n+            let var_node_id = tcx.hir.as_local_node_id(var_def_id).unwrap();\n+            let closure_expr_id = tcx.hir.local_def_id(fn_id).index;\n             let capture = hir.tables().upvar_capture(ty::UpvarId {\n-                var_id: var_id,\n-                closure_expr_id: fn_id\n+                var_id: var_def_id.index,\n+                closure_expr_id,\n             });\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,\n@@ -381,7 +383,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 debug_name: keywords::Invalid.name(),\n                 by_ref: by_ref\n             };\n-            if let Some(hir::map::NodeLocal(pat)) = tcx.hir.find(var_id) {\n+            if let Some(hir::map::NodeLocal(pat)) = tcx.hir.find(var_node_id) {\n                 if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n                     decl.debug_name = ident.node;\n                 }"}, {"sha": "11da73187b3783761eef826b3c3f88b15baa0958", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -684,8 +684,8 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::VarRef { id: node_id }\n         }\n \n-        Def::Upvar(def_id, index, closure_expr_id) => {\n-            let id_var = cx.tcx.hir.as_local_node_id(def_id).unwrap();\n+        Def::Upvar(var_def_id, index, closure_expr_id) => {\n+            let id_var = cx.tcx.hir.as_local_node_id(var_def_id).unwrap();\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\",\n                    id_var,\n                    index,\n@@ -768,8 +768,8 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // ...but the upvar might be an `&T` or `&mut T` capture, at which\n             // point we need an implicit deref\n             let upvar_id = ty::UpvarId {\n-                var_id: id_var,\n-                closure_expr_id: closure_expr_id,\n+                var_id: var_def_id.index,\n+                closure_expr_id: closure_def_id.index,\n             };\n             match cx.tables().upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue => field_kind,\n@@ -880,15 +880,16 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    freevar: &hir::Freevar,\n                                    freevar_ty: Ty<'tcx>)\n                                    -> ExprRef<'tcx> {\n-    let id_var = cx.tcx.hir.as_local_node_id(freevar.def.def_id()).unwrap();\n+    let var_def_id = freevar.def.def_id();\n+    let var_node_id = cx.tcx.hir.as_local_node_id(var_def_id).unwrap();\n     let upvar_id = ty::UpvarId {\n-        var_id: id_var,\n-        closure_expr_id: closure_expr.id,\n+        var_id: var_def_id.index,\n+        closure_expr_id: cx.tcx.hir.local_def_id(closure_expr.id).index,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.id);\n     let var_ty = cx.tables()\n-                   .node_id_to_type(cx.tcx.hir.node_to_hir_id(id_var));\n+                   .node_id_to_type(cx.tcx.hir.node_to_hir_id(var_node_id));\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,\n         ty: var_ty,"}, {"sha": "111f224c3d1f6cfeabce882466df5b5a23a2c5ff", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 50, "deletions": 33, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -50,8 +50,9 @@ use rustc::infer::UpvarRegion;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n+use rustc::hir::def_id::DefIndex;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::util::nodemap::NodeMap;\n+use rustc::util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry;\n \n@@ -90,31 +91,37 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn analyze_closure(&self,\n-                       (id, hir_id): (ast::NodeId, hir::HirId),\n+                       (closure_node_id, closure_hir_id): (ast::NodeId, hir::HirId),\n                        span: Span,\n                        body: &hir::Body,\n                        capture_clause: hir::CaptureClause) {\n         /*!\n          * Analysis starting point.\n          */\n \n-        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id());\n+        debug!(\"analyze_closure(id={:?}, body.id={:?})\", closure_node_id, body.id());\n \n-        let infer_kind = match self.tables.borrow_mut().closure_kinds.entry(hir_id.local_id) {\n+        let infer_kind = match self.tables\n+                                   .borrow_mut()\n+                                   .closure_kinds\n+                                   .entry(closure_hir_id.local_id) {\n             Entry::Occupied(_) => false,\n             Entry::Vacant(entry) => {\n-                debug!(\"check_closure: adding closure {:?} as Fn\", id);\n+                debug!(\"check_closure: adding closure {:?} as Fn\", closure_node_id);\n                 entry.insert((ty::ClosureKind::Fn, None));\n                 true\n             }\n         };\n \n-        self.tcx.with_freevars(id, |freevars| {\n+        let closure_def_id = self.tcx.hir.local_def_id(closure_node_id);\n+\n+        self.tcx.with_freevars(closure_node_id, |freevars| {\n             for freevar in freevars {\n-                let def_id = freevar.def.def_id();\n-                let var_node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                let upvar_id = ty::UpvarId { var_id: var_node_id,\n-                                             closure_expr_id: id };\n+                let var_def_id = freevar.def.def_id();\n+                let upvar_id = ty::UpvarId {\n+                    var_id: var_def_id.index,\n+                    closure_expr_id: closure_def_id.index,\n+                };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n \n                 let capture_kind = match capture_clause {\n@@ -139,7 +146,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let region_maps = &self.tcx.region_maps(body_owner_def_id);\n             let mut delegate = InferBorrowKind {\n                 fcx: self,\n-                adjust_closure_kinds: NodeMap(),\n+                adjust_closure_kinds: FxHashMap(),\n                 adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n             };\n             euv::ExprUseVisitor::with_infer(&mut delegate,\n@@ -151,8 +158,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Write the adjusted values back into the main tables.\n             if infer_kind {\n-                if let Some(kind) = delegate.adjust_closure_kinds.remove(&id) {\n-                    self.tables.borrow_mut().closure_kinds.insert(hir_id.local_id, kind);\n+                if let Some(kind) = delegate.adjust_closure_kinds\n+                                            .remove(&closure_def_id.index) {\n+                    self.tables\n+                        .borrow_mut()\n+                        .closure_kinds\n+                        .insert(closure_hir_id.local_id, kind);\n                 }\n             }\n             self.tables.borrow_mut().upvar_capture_map.extend(\n@@ -172,20 +183,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // inference algorithm will reject it).\n \n         // Extract the type variables UV0...UVn.\n-        let (def_id, closure_substs) = match self.node_ty(hir_id).sty {\n+        let (def_id, closure_substs) = match self.node_ty(closure_hir_id).sty {\n             ty::TyClosure(def_id, substs) => (def_id, substs),\n             ref t => {\n                 span_bug!(\n                     span,\n                     \"type of closure expr {:?} is not a closure {:?}\",\n-                    id, t);\n+                    closure_node_id, t);\n             }\n         };\n \n         // Equate the type variables with the actual types.\n-        let final_upvar_tys = self.final_upvar_tys(id);\n+        let final_upvar_tys = self.final_upvar_tys(closure_node_id);\n         debug!(\"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n-               id, closure_substs, final_upvar_tys);\n+               closure_node_id, closure_substs, final_upvar_tys);\n         for (upvar_ty, final_upvar_ty) in\n             closure_substs.upvar_tys(def_id, self.tcx).zip(final_upvar_tys)\n         {\n@@ -195,7 +206,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If we are also inferred the closure kind here,\n         // process any deferred resolutions.\n         if infer_kind {\n-            let closure_def_id = self.tcx.hir.local_def_id(id);\n             let deferred_call_resolutions =\n                 self.remove_deferred_call_resolutions(closure_def_id);\n             for deferred_call_resolution in deferred_call_resolutions {\n@@ -212,19 +222,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // This may change if abstract return types of some sort are\n         // implemented.\n         let tcx = self.tcx;\n+        let closure_def_index = tcx.hir.local_def_id(closure_id).index;\n+\n         tcx.with_freevars(closure_id, |freevars| {\n             freevars.iter().map(|freevar| {\n-                let def_id = freevar.def.def_id();\n-                let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-                let freevar_ty = self.node_ty(tcx.hir.node_to_hir_id(var_id));\n+                let var_def_id = freevar.def.def_id();\n+                let var_node_id = tcx.hir.as_local_node_id(var_def_id).unwrap();\n+                let freevar_ty = self.node_ty(tcx.hir.node_to_hir_id(var_node_id));\n                 let upvar_id = ty::UpvarId {\n-                    var_id: var_id,\n-                    closure_expr_id: closure_id\n+                    var_id: var_def_id.index,\n+                    closure_expr_id: closure_def_index,\n                 };\n                 let capture = self.tables.borrow().upvar_capture(upvar_id);\n \n                 debug!(\"var_id={:?} freevar_ty={:?} capture={:?}\",\n-                       var_id, freevar_ty, capture);\n+                       var_node_id, freevar_ty, capture);\n \n                 match capture {\n                     ty::UpvarCapture::ByValue => freevar_ty,\n@@ -242,7 +254,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n struct InferBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    adjust_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n+    adjust_closure_kinds: FxHashMap<DefIndex, (ty::ClosureKind, Option<(Span, ast::Name)>)>,\n     adjust_upvar_captures: ty::UpvarCaptureMap<'tcx>,\n }\n \n@@ -281,7 +293,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                         self.adjust_closure_kind(upvar_id.closure_expr_id,\n                                                  ty::ClosureKind::FnOnce,\n                                                  guarantor.span,\n-                                                 tcx.hir.name(upvar_id.var_id));\n+                                                 var_name(tcx, upvar_id.var_id));\n \n                         self.adjust_upvar_captures.insert(upvar_id, ty::UpvarCapture::ByValue);\n                     }\n@@ -295,7 +307,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                         self.adjust_closure_kind(upvar_id.closure_expr_id,\n                                                  ty::ClosureKind::FnOnce,\n                                                  guarantor.span,\n-                                                 tcx.hir.name(upvar_id.var_id));\n+                                                 var_name(tcx, upvar_id.var_id));\n                     }\n                     mc::NoteNone => {\n                     }\n@@ -400,7 +412,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 self.adjust_closure_kind(upvar_id.closure_expr_id,\n                                          ty::ClosureKind::FnMut,\n                                          cmt.span,\n-                                         tcx.hir.name(upvar_id.var_id));\n+                                         var_name(tcx, upvar_id.var_id));\n \n                 true\n             }\n@@ -411,7 +423,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 self.adjust_closure_kind(upvar_id.closure_expr_id,\n                                          ty::ClosureKind::FnMut,\n                                          cmt.span,\n-                                         tcx.hir.name(upvar_id.var_id));\n+                                         var_name(tcx, upvar_id.var_id));\n \n                 true\n             }\n@@ -460,23 +472,23 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     }\n \n     fn adjust_closure_kind(&mut self,\n-                           closure_id: ast::NodeId,\n+                           closure_id: DefIndex,\n                            new_kind: ty::ClosureKind,\n                            upvar_span: Span,\n                            var_name: ast::Name) {\n-        debug!(\"adjust_closure_kind(closure_id={}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n+        debug!(\"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n                closure_id, new_kind, upvar_span, var_name);\n \n         let closure_kind = self.adjust_closure_kinds.get(&closure_id).cloned()\n             .or_else(|| {\n-                let closure_id = self.fcx.tcx.hir.node_to_hir_id(closure_id);\n+                let closure_id = self.fcx.tcx.hir.def_index_to_hir_id(closure_id);\n                 let fcx_tables = self.fcx.tables.borrow();\n                 fcx_tables.validate_hir_id(closure_id);\n                 fcx_tables.closure_kinds.get(&closure_id.local_id).cloned()\n             });\n \n         if let Some((existing_kind, _)) = closure_kind {\n-            debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n+            debug!(\"adjust_closure_kind: closure_id={:?}, existing_kind={:?}, new_kind={:?}\",\n                    closure_id, existing_kind, new_kind);\n \n             match (existing_kind, new_kind) {\n@@ -566,3 +578,8 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);\n     }\n }\n+\n+fn var_name(tcx: ty::TyCtxt, var_def_index: DefIndex) -> ast::Name {\n+    let var_node_id = tcx.hir.def_index_to_node_id(var_def_index);\n+    tcx.hir.name(var_node_id)\n+}"}, {"sha": "515bbe49c39b945e5e1880b271ad9986ee57231e", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4dcc3a4aae48d4ce856a2db2a1234af190fb2eb8", "patch": "@@ -14,7 +14,7 @@\n \n use check::FnCtxt;\n use rustc::hir;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -401,6 +401,13 @@ impl Locatable for ast::NodeId {\n     fn to_span(&self, tcx: &TyCtxt) -> Span { tcx.hir.span(*self) }\n }\n \n+impl Locatable for DefIndex {\n+    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+        let node_id = tcx.hir.def_index_to_node_id(*self);\n+        tcx.hir.span(node_id)\n+    }\n+}\n+\n impl Locatable for hir::HirId {\n     fn to_span(&self, tcx: &TyCtxt) -> Span {\n         let node_id = tcx.hir.definitions().find_node_for_hir_id(*self);"}]}