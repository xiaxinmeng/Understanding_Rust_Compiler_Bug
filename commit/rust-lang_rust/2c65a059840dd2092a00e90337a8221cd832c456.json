{"sha": "2c65a059840dd2092a00e90337a8221cd832c456", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNjVhMDU5ODQwZGQyMDkyYTAwZTkwMzM3YTgyMjFjZDgzMmM0NTY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-12T19:43:57Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-12T19:43:57Z"}, "message": "Merge #1677\n\n1677: Associated types r=flodiebold a=flodiebold\n\nThis implements basic support for (fully qualified) associated type projections:\r\n - handle fully qualified paths like `<T as Trait>::AssocType` (basically desugaring to something like `Trait<Self=T>::AssocType`)\r\n - lower these to a new `Ty::Projection` enum variant\r\n - also introduce `Ty::UnselectedProjection` for cases like `T::AssocType` where the trait from which the type comes isn't specified, but these aren't handled further so far\r\n - in inference, normalize these projections using Chalk: basically, when encountering a type e.g. from a type annotation or signature, we replace these `Ty::Projection`s by type variables and add obligations to normalize the associated type\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "fa1f8c46158271eb859928ed9da3eb389f861c09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa1f8c46158271eb859928ed9da3eb389f861c09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c65a059840dd2092a00e90337a8221cd832c456", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c65a059840dd2092a00e90337a8221cd832c456", "html_url": "https://github.com/rust-lang/rust/commit/2c65a059840dd2092a00e90337a8221cd832c456", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c65a059840dd2092a00e90337a8221cd832c456/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "0cf48e48d75d267bfa38ff1319e7f7c0468fb53f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cf48e48d75d267bfa38ff1319e7f7c0468fb53f", "html_url": "https://github.com/rust-lang/rust/commit/0cf48e48d75d267bfa38ff1319e7f7c0468fb53f"}, {"sha": "5af9691dc9132db61b50c4e90cdeda6fea0c5dd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5af9691dc9132db61b50c4e90cdeda6fea0c5dd9", "html_url": "https://github.com/rust-lang/rust/commit/5af9691dc9132db61b50c4e90cdeda6fea0c5dd9"}], "stats": {"total": 443, "additions": 405, "deletions": 38}, "files": [{"sha": "1158adbbc0f7ef5feffc3e6a258ec9ba77e1c58d", "filename": "crates/ra_assists/src/auto_import.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=2c65a059840dd2092a00e90337a8221cd832c456", "patch": "@@ -71,6 +71,7 @@ fn compare_path_segment(a: &SmolStr, b: &ast::PathSegment) -> bool {\n             ast::PathSegmentKind::SelfKw => a == \"self\",\n             ast::PathSegmentKind::SuperKw => a == \"super\",\n             ast::PathSegmentKind::CrateKw => a == \"crate\",\n+            ast::PathSegmentKind::Type { .. } => false, // not allowed in imports\n         }\n     } else {\n         false"}, {"sha": "89fc1d1a1cec668fe1764d584d569015e7b37cf2", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=2c65a059840dd2092a00e90337a8221cd832c456", "patch": "@@ -838,6 +838,10 @@ impl TypeAlias {\n         self.id.module(db)\n     }\n \n+    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+        self.module(db).krate(db)\n+    }\n+\n     /// The containing impl block, if this is a method.\n     pub fn impl_block(self, db: &impl DefDatabase) -> Option<ImplBlock> {\n         let module_impls = db.impls_in_module(self.module(db));"}, {"sha": "5ee71e421e3add42dbbbc5b25df24e4dc82ea022", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=2c65a059840dd2092a00e90337a8221cd832c456", "patch": "@@ -25,6 +25,12 @@ pub struct PathSegment {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct GenericArgs {\n     pub args: Vec<GenericArg>,\n+    /// This specifies whether the args contain a Self type as the first\n+    /// element. This is the case for path segments like `<T as Trait>`, where\n+    /// `T` is actually a type parameter for the path `Trait` specifying the\n+    /// Self type. Otherwise, when we have a path `Trait<X, Y>`, the Self type\n+    /// is left out.\n+    pub has_self_type: bool,\n     // someday also bindings\n }\n \n@@ -74,6 +80,28 @@ impl Path {\n                     let segment = PathSegment { name: name.as_name(), args_and_bindings: args };\n                     segments.push(segment);\n                 }\n+                ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n+                    assert!(path.qualifier().is_none()); // this can only occur at the first segment\n+\n+                    // FIXME: handle <T> syntax (type segments without trait)\n+\n+                    // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n+                    let path = Path::from_ast(trait_ref?.path()?)?;\n+                    kind = path.kind;\n+                    let mut prefix_segments = path.segments;\n+                    prefix_segments.reverse();\n+                    segments.extend(prefix_segments);\n+                    // Insert the type reference (T in the above example) as Self parameter for the trait\n+                    let self_type = TypeRef::from_ast(type_ref?);\n+                    let mut last_segment = segments.last_mut()?;\n+                    if last_segment.args_and_bindings.is_none() {\n+                        last_segment.args_and_bindings = Some(Arc::new(GenericArgs::empty()));\n+                    };\n+                    let args = last_segment.args_and_bindings.as_mut().unwrap();\n+                    let mut args_inner = Arc::make_mut(args);\n+                    args_inner.has_self_type = true;\n+                    args_inner.args.insert(0, GenericArg::Type(self_type));\n+                }\n                 ast::PathSegmentKind::CrateKw => {\n                     kind = PathKind::Crate;\n                     break;\n@@ -144,11 +172,15 @@ impl GenericArgs {\n         }\n         // lifetimes and assoc type args ignored for now\n         if !args.is_empty() {\n-            Some(GenericArgs { args })\n+            Some(GenericArgs { args, has_self_type: false })\n         } else {\n             None\n         }\n     }\n+\n+    pub(crate) fn empty() -> GenericArgs {\n+        GenericArgs { args: Vec::new(), has_self_type: false }\n+    }\n }\n \n impl From<Name> for Path {\n@@ -236,6 +268,10 @@ fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n             }\n             Path { kind: PathKind::Super, segments: Vec::new() }\n         }\n+        ast::PathSegmentKind::Type { .. } => {\n+            // not allowed in imports\n+            return None;\n+        }\n     };\n     Some(res)\n }"}, {"sha": "642dd02cbe0b481737df6b7ca82c1e4d255eaf49", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=2c65a059840dd2092a00e90337a8221cd832c456", "patch": "@@ -94,6 +94,12 @@ pub enum TypeCtor {\n \n     /// A tuple type.  For example, `(i32, bool)`.\n     Tuple { cardinality: u16 },\n+\n+    /// Represents an associated item like `Iterator::Item`.  This is used\n+    /// when we have tried to normalize a projection like `T::Item` but\n+    /// couldn't find a better representation.  In that case, we generate\n+    /// an **application type** like `(Iterator::Item)<T>`.\n+    AssociatedType(TypeAlias),\n }\n \n /// A nominal type with (maybe 0) type parameters. This might be a primitive\n@@ -114,6 +120,12 @@ pub struct ProjectionTy {\n     pub parameters: Substs,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct UnselectedProjectionTy {\n+    pub type_name: Name,\n+    pub parameters: Substs,\n+}\n+\n /// A type.\n ///\n /// See also the `TyKind` enum in rustc (librustc/ty/sty.rs), which represents\n@@ -127,6 +139,18 @@ pub enum Ty {\n     /// several other things.\n     Apply(ApplicationTy),\n \n+    /// A \"projection\" type corresponds to an (unnormalized)\n+    /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n+    /// trait and all its parameters are fully known.\n+    Projection(ProjectionTy),\n+\n+    /// This is a variant of a projection in which the trait is\n+    /// **not** known.  It corresponds to a case where people write\n+    /// `T::Item` without specifying the trait. We would then try to\n+    /// figure out the trait by looking at all the traits that are in\n+    /// scope.\n+    UnselectedProjection(UnselectedProjectionTy),\n+\n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     Param {\n         /// The index of the parameter (starting with parameters from the\n@@ -352,6 +376,16 @@ impl Ty {\n                     t.walk(f);\n                 }\n             }\n+            Ty::Projection(p_ty) => {\n+                for t in p_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n+            Ty::UnselectedProjection(p_ty) => {\n+                for t in p_ty.parameters.iter() {\n+                    t.walk(f);\n+                }\n+            }\n             Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n@@ -362,6 +396,12 @@ impl Ty {\n             Ty::Apply(a_ty) => {\n                 a_ty.parameters.walk_mut(f);\n             }\n+            Ty::Projection(p_ty) => {\n+                p_ty.parameters.walk_mut(f);\n+            }\n+            Ty::UnselectedProjection(p_ty) => {\n+                p_ty.parameters.walk_mut(f);\n+            }\n             Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n@@ -572,15 +612,61 @@ impl HirDisplay for ApplicationTy {\n                     write!(f, \">\")?;\n                 }\n             }\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let trait_name = type_alias\n+                    .parent_trait(f.db)\n+                    .and_then(|t| t.name(f.db))\n+                    .unwrap_or_else(Name::missing);\n+                let name = type_alias.name(f.db);\n+                write!(f, \"{}::{}\", trait_name, name)?;\n+                if self.parameters.len() > 0 {\n+                    write!(f, \"<\")?;\n+                    f.write_joined(&*self.parameters.0, \", \")?;\n+                    write!(f, \">\")?;\n+                }\n+            }\n         }\n         Ok(())\n     }\n }\n \n+impl HirDisplay for ProjectionTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        let trait_name = self\n+            .associated_ty\n+            .parent_trait(f.db)\n+            .and_then(|t| t.name(f.db))\n+            .unwrap_or_else(Name::missing);\n+        write!(f, \"<{} as {}\", self.parameters[0].display(f.db), trait_name,)?;\n+        if self.parameters.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.parameters[1..], \", \")?;\n+            write!(f, \">\")?;\n+        }\n+        write!(f, \">::{}\", self.associated_ty.name(f.db))?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for UnselectedProjectionTy {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        write!(f, \"{}\", self.parameters[0].display(f.db))?;\n+        if self.parameters.len() > 1 {\n+            write!(f, \"<\")?;\n+            f.write_joined(&self.parameters[1..], \", \")?;\n+            write!(f, \">\")?;\n+        }\n+        write!(f, \"::{}\", self.type_name)?;\n+        Ok(())\n+    }\n+}\n+\n impl HirDisplay for Ty {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n         match self {\n             Ty::Apply(a_ty) => a_ty.hir_fmt(f)?,\n+            Ty::Projection(p_ty) => p_ty.hir_fmt(f)?,\n+            Ty::UnselectedProjection(p_ty) => p_ty.hir_fmt(f)?,\n             Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n             Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n@@ -606,3 +692,17 @@ impl HirDisplay for TraitRef {\n         Ok(())\n     }\n }\n+\n+impl HirDisplay for Obligation {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        match self {\n+            Obligation::Trait(tr) => write!(f, \"Implements({})\", tr.display(f.db)),\n+            Obligation::Projection(proj) => write!(\n+                f,\n+                \"Normalize({} => {})\",\n+                proj.projection_ty.display(f.db),\n+                proj.ty.display(f.db)\n+            ),\n+        }\n+    }\n+}"}, {"sha": "675df4a22f40afe72aeb8a3f7bee2fb66e23ea18", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=2c65a059840dd2092a00e90337a8221cd832c456", "patch": "@@ -245,7 +245,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             &self.resolver,\n             type_ref,\n         );\n-        self.insert_type_vars(ty)\n+        let ty = self.insert_type_vars(ty);\n+        self.normalize_associated_types_in(ty)\n     }\n \n     fn unify_substs(&mut self, substs1: &Substs, substs2: &Substs, depth: usize) -> bool {\n@@ -411,6 +412,32 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ty\n     }\n \n+    /// Recurses through the given type, normalizing associated types mentioned\n+    /// in it by replacing them by type variables and registering obligations to\n+    /// resolve later. This should be done once for every type we get from some\n+    /// type annotation (e.g. from a let type annotation, field type or function\n+    /// call). `make_ty` handles this already, but e.g. for field types we need\n+    /// to do it as well.\n+    fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Projection(proj_ty) => self.normalize_projection_ty(proj_ty),\n+            Ty::UnselectedProjection(proj_ty) => {\n+                // FIXME use Chalk's unselected projection support\n+                Ty::UnselectedProjection(proj_ty)\n+            }\n+            _ => ty,\n+        })\n+    }\n+\n+    fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {\n+        let var = self.new_type_var();\n+        let predicate = ProjectionPredicate { projection_ty: proj_ty.clone(), ty: var.clone() };\n+        let obligation = Obligation::Projection(predicate);\n+        self.obligations.push(obligation);\n+        var\n+    }\n+\n     /// Resolves the type completely; type variables without known type are\n     /// replaced by Ty::Unknown.\n     fn resolve_ty_completely(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n@@ -549,6 +576,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n                 let ty = ty.subst(&substs);\n                 let ty = self.insert_type_vars(ty);\n+                let ty = self.normalize_associated_types_in(ty);\n                 Some(ty)\n             }\n             Resolution::LocalBinding(pat) => {\n@@ -670,6 +698,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .and_then(|d| d.field(self.db, &Name::tuple_field_name(i)))\n                 .map_or(Ty::Unknown, |field| field.ty(self.db))\n                 .subst(&substs);\n+            let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat, &expected_ty, default_bm);\n         }\n \n@@ -697,6 +726,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n             let expected_ty =\n                 matching_field.map_or(Ty::Unknown, |field| field.ty(self.db)).subst(&substs);\n+            let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat.pat, &expected_ty, default_bm);\n         }\n \n@@ -927,9 +957,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.unify(&expected_receiver_ty, &actual_receiver_ty);\n \n         let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n-        for (arg, param) in args.iter().zip(param_iter) {\n-            self.infer_expr(*arg, &Expectation::has_type(param));\n+        for (arg, param_ty) in args.iter().zip(param_iter) {\n+            let param_ty = self.normalize_associated_types_in(param_ty);\n+            self.infer_expr(*arg, &Expectation::has_type(param_ty));\n         }\n+        let ret_ty = self.normalize_associated_types_in(ret_ty);\n         ret_ty\n     }\n \n@@ -1020,9 +1052,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 };\n                 self.register_obligations_for_call(&callee_ty);\n                 let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n-                for (arg, param) in args.iter().zip(param_iter) {\n-                    self.infer_expr(*arg, &Expectation::has_type(param));\n+                for (arg, param_ty) in args.iter().zip(param_iter) {\n+                    let param_ty = self.normalize_associated_types_in(param_ty);\n+                    self.infer_expr(*arg, &Expectation::has_type(param_ty));\n                 }\n+                let ret_ty = self.normalize_associated_types_in(ret_ty);\n                 ret_ty\n             }\n             Expr::MethodCall { receiver, args, method_name, generic_args } => self\n@@ -1120,7 +1154,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     _ => None,\n                 })\n                 .unwrap_or(Ty::Unknown);\n-                self.insert_type_vars(ty)\n+                let ty = self.insert_type_vars(ty);\n+                self.normalize_associated_types_in(ty)\n             }\n             Expr::Await { expr } => {\n                 let inner_ty = self.infer_expr(*expr, &Expectation::none());"}, {"sha": "debedcbb8b194bae283c5cc45296284447fc4feb", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 68, "deletions": 15, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=2c65a059840dd2092a00e90337a8221cd832c456", "patch": "@@ -8,7 +8,7 @@\n use std::iter;\n use std::sync::Arc;\n \n-use super::{FnSig, GenericPredicate, Substs, TraitRef, Ty, TypeCtor};\n+use super::{FnSig, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor};\n use crate::{\n     adt::VariantDef,\n     generics::HasGenericParams,\n@@ -64,7 +64,8 @@ impl Ty {\n \n     pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Self {\n         // Resolve the path (in type namespace)\n-        let resolution = resolver.resolve_path_without_assoc_items(db, path).take_types();\n+        let (resolution, remaining_index) = resolver.resolve_path_segments(db, path).into_inner();\n+        let resolution = resolution.take_types();\n \n         let def = match resolution {\n             Some(Resolution::Def(def)) => def,\n@@ -73,6 +74,10 @@ impl Ty {\n                 panic!(\"path resolved to local binding in type ns\");\n             }\n             Some(Resolution::GenericParam(idx)) => {\n+                if remaining_index.is_some() {\n+                    // e.g. T::Item\n+                    return Ty::Unknown;\n+                }\n                 return Ty::Param {\n                     idx,\n                     // FIXME: maybe return name in resolution?\n@@ -83,18 +88,54 @@ impl Ty {\n                 };\n             }\n             Some(Resolution::SelfType(impl_block)) => {\n+                if remaining_index.is_some() {\n+                    // e.g. Self::Item\n+                    return Ty::Unknown;\n+                }\n                 return impl_block.target_ty(db);\n             }\n-            None => return Ty::Unknown,\n+            None => {\n+                // path did not resolve\n+                return Ty::Unknown;\n+            }\n         };\n \n-        let typable: TypableDef = match def.into() {\n-            None => return Ty::Unknown,\n-            Some(it) => it,\n-        };\n-        let ty = db.type_for_def(typable, Namespace::Types);\n-        let substs = Ty::substs_from_path(db, resolver, path, typable);\n-        ty.subst(&substs)\n+        if let ModuleDef::Trait(trait_) = def {\n+            let segment = match remaining_index {\n+                None => path.segments.last().expect(\"resolved path has at least one element\"),\n+                Some(i) => &path.segments[i - 1],\n+            };\n+            let trait_ref = TraitRef::from_resolved_path(db, resolver, trait_, segment, None);\n+            if let Some(remaining_index) = remaining_index {\n+                if remaining_index == path.segments.len() - 1 {\n+                    let segment = &path.segments[remaining_index];\n+                    let associated_ty =\n+                        match trait_ref.trait_.associated_type_by_name(db, segment.name.clone()) {\n+                            Some(t) => t,\n+                            None => {\n+                                // associated type not found\n+                                return Ty::Unknown;\n+                            }\n+                        };\n+                    // FIXME handle type parameters on the segment\n+                    Ty::Projection(ProjectionTy { associated_ty, parameters: trait_ref.substs })\n+                } else {\n+                    // FIXME more than one segment remaining, is this possible?\n+                    Ty::Unknown\n+                }\n+            } else {\n+                // FIXME dyn Trait without the dyn\n+                Ty::Unknown\n+            }\n+        } else {\n+            let typable: TypableDef = match def.into() {\n+                None => return Ty::Unknown,\n+                Some(it) => it,\n+            };\n+            let ty = db.type_for_def(typable, Namespace::Types);\n+            let substs = Ty::substs_from_path(db, resolver, path, typable);\n+            ty.subst(&substs)\n+        }\n     }\n \n     pub(super) fn substs_from_path_segment(\n@@ -219,14 +260,25 @@ impl TraitRef {\n             Resolution::Def(ModuleDef::Trait(tr)) => tr,\n             _ => return None,\n         };\n-        let mut substs = Self::substs_from_path(db, resolver, path, resolved);\n+        let segment = path.segments.last().expect(\"path should have at least one segment\");\n+        Some(TraitRef::from_resolved_path(db, resolver, resolved, segment, explicit_self_ty))\n+    }\n+\n+    fn from_resolved_path(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        resolved: Trait,\n+        segment: &PathSegment,\n+        explicit_self_ty: Option<Ty>,\n+    ) -> Self {\n+        let mut substs = TraitRef::substs_from_path(db, resolver, segment, resolved);\n         if let Some(self_ty) = explicit_self_ty {\n             // FIXME this could be nicer\n             let mut substs_vec = substs.0.to_vec();\n             substs_vec[0] = self_ty;\n             substs.0 = substs_vec.into();\n         }\n-        Some(TraitRef { trait_: resolved, substs })\n+        TraitRef { trait_: resolved, substs }\n     }\n \n     pub(crate) fn from_hir(\n@@ -245,11 +297,12 @@ impl TraitRef {\n     fn substs_from_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n-        path: &Path,\n+        segment: &PathSegment,\n         resolved: Trait,\n     ) -> Substs {\n-        let segment = path.segments.last().expect(\"path should have at least one segment\");\n-        substs_from_path_segment(db, resolver, segment, Some(resolved.into()), true)\n+        let has_self_param =\n+            segment.args_and_bindings.as_ref().map(|a| a.has_self_type).unwrap_or(false);\n+        substs_from_path_segment(db, resolver, segment, Some(resolved.into()), !has_self_param)\n     }\n \n     pub(crate) fn for_trait(db: &impl HirDatabase, trait_: Trait) -> TraitRef {"}, {"sha": "28727bb181e16bcfd9c82f9266573d6a3f1dc414", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 95, "deletions": 6, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=2c65a059840dd2092a00e90337a8221cd832c456", "patch": "@@ -2508,15 +2508,55 @@ struct S;\n impl Iterable for S { type Item = u32; }\n fn test<T: Iterable>() {\n     let x: <S as Iterable>::Item = 1;\n-    let y: T::Item = no_matter;\n+    let y: <T as Iterable>::Item = no_matter;\n+    let z: T::Item = no_matter;\n }\n \"#),\n         @r###\"\n-[108; 181) '{     ...ter; }': ()\n-[118; 119) 'x': i32\n-[145; 146) '1': i32\n-[156; 157) 'y': {unknown}\n-[169; 178) 'no_matter': {unknown}\"###\n+   \u22ee\n+   \u22ee[108; 227) '{     ...ter; }': ()\n+   \u22ee[118; 119) 'x': u32\n+   \u22ee[145; 146) '1': u32\n+   \u22ee[156; 157) 'y': {unknown}\n+   \u22ee[183; 192) 'no_matter': {unknown}\n+   \u22ee[202; 203) 'z': {unknown}\n+   \u22ee[215; 224) 'no_matter': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn infer_return_associated_type() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+trait Iterable {\n+   type Item;\n+}\n+struct S;\n+impl Iterable for S { type Item = u32; }\n+fn foo1<T: Iterable>(t: T) -> T::Item {}\n+fn foo2<T: Iterable>(t: T) -> <T as Iterable>::Item {}\n+fn test() {\n+    let x = foo1(S);\n+    let y = foo2(S);\n+}\n+\"#),\n+        @r###\"\n+   \u22ee\n+   \u22ee[106; 107) 't': T\n+   \u22ee[123; 125) '{}': ()\n+   \u22ee[147; 148) 't': T\n+   \u22ee[178; 180) '{}': ()\n+   \u22ee[191; 236) '{     ...(S); }': ()\n+   \u22ee[201; 202) 'x': {unknown}\n+   \u22ee[205; 209) 'foo1': fn foo1<S>(T) -> {unknown}\n+   \u22ee[205; 212) 'foo1(S)': {unknown}\n+   \u22ee[210; 211) 'S': S\n+   \u22ee[222; 223) 'y': u32\n+   \u22ee[226; 230) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item\n+   \u22ee[226; 233) 'foo2(S)': u32\n+   \u22ee[231; 232) 'S': S\n+    \"###\n     );\n }\n \n@@ -3141,6 +3181,55 @@ fn test<T: Trait>(t: T) { (*t)<|>; }\n     assert_eq!(t, \"i128\");\n }\n \n+#[test]\n+fn associated_type_placeholder() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+pub trait ApplyL {\n+    type Out;\n+}\n+\n+pub struct RefMutL<T>;\n+\n+impl<T> ApplyL for RefMutL<T> {\n+    type Out = <T as ApplyL>::Out;\n+}\n+\n+fn test<T: ApplyL>() {\n+    let y: <RefMutL<T> as ApplyL>::Out = no_matter;\n+    y<|>;\n+}\n+\"#,\n+    );\n+    // inside the generic function, the associated type gets normalized to a placeholder `ApplL::Out<T>` [https://rust-lang.github.io/rustc-guide/traits/associated-types.html#placeholder-associated-types].\n+    // FIXME: fix type parameter names going missing when going through Chalk\n+    assert_eq!(t, \"ApplyL::Out<[missing name]>\");\n+}\n+\n+#[test]\n+fn associated_type_placeholder_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+pub trait ApplyL {\n+    type Out;\n+}\n+fn foo<T: ApplyL>(t: T) -> <T as ApplyL>::Out;\n+\n+fn test<T: ApplyL>(t: T) {\n+    let y = foo(t);\n+    y<|>;\n+}\n+\"#,\n+    );\n+    // FIXME here Chalk doesn't normalize the type to a placeholder. I think we\n+    // need to add a rule like Normalize(<T as ApplyL>::Out -> ApplyL::Out<T>)\n+    // to the trait env ourselves here; probably Chalk can't do this by itself.\n+    // assert_eq!(t, \"ApplyL::Out<[missing name]>\");\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}, {"sha": "fde5d8a47d1411f7f1f9c8430354a0946fc7831b", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=2c65a059840dd2092a00e90337a8221cd832c456", "patch": "@@ -7,7 +7,7 @@ use parking_lot::Mutex;\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n-use super::{Canonical, GenericPredicate, ProjectionTy, TraitRef, Ty};\n+use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty};\n use crate::{db::HirDatabase, Crate, ImplBlock, Trait};\n \n use self::chalk::{from_chalk, ToChalk};\n@@ -61,7 +61,6 @@ fn solve(\n ) -> Option<chalk_solve::Solution> {\n     let context = ChalkContext { db, krate };\n     let solver = db.trait_solver(krate);\n-    debug!(\"solve goal: {:?}\", goal);\n     let solution = solver.lock().solve(&context, goal);\n     debug!(\"solve({:?}) => {:?}\", goal, solution);\n     solution\n@@ -120,10 +119,11 @@ pub struct ProjectionPredicate {\n pub(crate) fn trait_solve_query(\n     db: &impl HirDatabase,\n     krate: Crate,\n-    trait_ref: Canonical<InEnvironment<Obligation>>,\n+    goal: Canonical<InEnvironment<Obligation>>,\n ) -> Option<Solution> {\n     let _p = profile(\"trait_solve_query\");\n-    let canonical = trait_ref.to_chalk(db).cast();\n+    debug!(\"trait_solve_query({})\", goal.value.value.display(db));\n+    let canonical = goal.to_chalk(db).cast();\n     // We currently don't deal with universes (I think / hope they're not yet\n     // relevant for our use cases?)\n     let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };"}, {"sha": "6df7094c580cb87ea7f0a8a4a9978850cbb461ce", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=2c65a059840dd2092a00e90337a8221cd832c456", "patch": "@@ -45,11 +45,33 @@ impl ToChalk for Ty {\n     fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Ty {\n         match self {\n             Ty::Apply(apply_ty) => {\n-                let struct_id = apply_ty.ctor.to_chalk(db);\n-                let name = TypeName::TypeKindId(struct_id.into());\n+                let name = match apply_ty.ctor {\n+                    TypeCtor::AssociatedType(type_alias) => {\n+                        let type_id = type_alias.to_chalk(db);\n+                        TypeName::AssociatedType(type_id)\n+                    }\n+                    _ => {\n+                        // other TypeCtors get interned and turned into a chalk StructId\n+                        let struct_id = apply_ty.ctor.to_chalk(db);\n+                        TypeName::TypeKindId(struct_id.into())\n+                    }\n+                };\n                 let parameters = apply_ty.parameters.to_chalk(db);\n                 chalk_ir::ApplicationTy { name, parameters }.cast()\n             }\n+            Ty::Projection(proj_ty) => {\n+                let associated_ty_id = proj_ty.associated_ty.to_chalk(db);\n+                let parameters = proj_ty.parameters.to_chalk(db);\n+                chalk_ir::ProjectionTy { associated_ty_id, parameters }.cast()\n+            }\n+            Ty::UnselectedProjection(proj_ty) => {\n+                let type_name = lalrpop_intern::intern(&proj_ty.type_name.to_string());\n+                let parameters = proj_ty.parameters.to_chalk(db);\n+                chalk_ir::Ty::UnselectedProjection(chalk_ir::UnselectedProjectionTy {\n+                    type_name,\n+                    parameters,\n+                })\n+            }\n             Ty::Param { idx, .. } => {\n                 PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }.to_ty()\n             }\n@@ -66,15 +88,21 @@ impl ToChalk for Ty {\n     fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty) -> Self {\n         match chalk {\n             chalk_ir::Ty::Apply(apply_ty) => {\n+                // FIXME this is kind of hacky due to the fact that\n+                // TypeName::Placeholder is a Ty::Param on our side\n                 match apply_ty.name {\n                     TypeName::TypeKindId(TypeKindId::StructId(struct_id)) => {\n                         let ctor = from_chalk(db, struct_id);\n                         let parameters = from_chalk(db, apply_ty.parameters);\n                         Ty::Apply(ApplicationTy { ctor, parameters })\n                     }\n+                    TypeName::AssociatedType(type_id) => {\n+                        let ctor = TypeCtor::AssociatedType(from_chalk(db, type_id));\n+                        let parameters = from_chalk(db, apply_ty.parameters);\n+                        Ty::Apply(ApplicationTy { ctor, parameters })\n+                    }\n                     // FIXME handle TypeKindId::Trait/Type here\n                     TypeName::TypeKindId(_) => unimplemented!(),\n-                    TypeName::AssociatedType(_) => unimplemented!(),\n                     TypeName::Placeholder(idx) => {\n                         assert_eq!(idx.ui, UniverseIndex::ROOT);\n                         Ty::Param { idx: idx.idx as u32, name: crate::Name::missing() }\n@@ -389,11 +417,12 @@ where\n         &self,\n         projection: &'p chalk_ir::ProjectionTy,\n     ) -> (Arc<AssociatedTyDatum>, &'p [Parameter], &'p [Parameter]) {\n-        debug!(\"split_projection {:?}\", projection);\n-        unimplemented!()\n+        let proj_ty: ProjectionTy = from_chalk(self.db, projection.clone());\n+        debug!(\"split_projection {:?} = {}\", projection, proj_ty.display(self.db));\n+        // we don't support GATs, so I think this should always be correct currently\n+        (self.db.associated_ty_data(projection.associated_ty_id), &projection.parameters, &[])\n     }\n     fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause> {\n-        debug!(\"custom_clauses\");\n         vec![]\n     }\n     fn all_structs(&self) -> Vec<chalk_ir::StructId> {\n@@ -529,6 +558,16 @@ pub(crate) fn struct_datum_query(\n                 adt.krate(db) != Some(krate),\n             )\n         }\n+        TypeCtor::AssociatedType(type_alias) => {\n+            let generic_params = type_alias.generic_params(db);\n+            let bound_vars = Substs::bound_vars(&generic_params);\n+            let where_clauses = convert_where_clauses(db, type_alias.into(), &bound_vars);\n+            (\n+                generic_params.count_params_including_parent(),\n+                where_clauses,\n+                type_alias.krate(db) != Some(krate),\n+            )\n+        }\n     };\n     let flags = chalk_rust_ir::StructFlags {\n         upstream,"}, {"sha": "2a59cf653734ff92504b6dd9bacac6bd3d8cb09f", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c65a059840dd2092a00e90337a8221cd832c456/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=2c65a059840dd2092a00e90337a8221cd832c456", "patch": "@@ -91,6 +91,7 @@ impl ast::Attr {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum PathSegmentKind {\n     Name(ast::NameRef),\n+    Type { type_ref: Option<ast::TypeRef>, trait_ref: Option<ast::PathType> },\n     SelfKw,\n     SuperKw,\n     CrateKw,\n@@ -112,6 +113,15 @@ impl ast::PathSegment {\n                 T![self] => PathSegmentKind::SelfKw,\n                 T![super] => PathSegmentKind::SuperKw,\n                 T![crate] => PathSegmentKind::CrateKw,\n+                T![<] => {\n+                    // <T> or <T as Trait>\n+                    // T is any TypeRef, Trait has to be a PathType\n+                    let mut type_refs =\n+                        self.syntax().children().filter(|node| ast::TypeRef::can_cast(node.kind()));\n+                    let type_ref = type_refs.next().and_then(ast::TypeRef::cast);\n+                    let trait_ref = type_refs.next().and_then(ast::PathType::cast);\n+                    PathSegmentKind::Type { type_ref, trait_ref }\n+                }\n                 _ => return None,\n             }\n         };"}]}