{"sha": "7bc092f109d79b7214fb11108bbe38ac322c775c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYzA5MmYxMDlkNzliNzIxNGZiMTExMDhiYmUzOGFjMzIyYzc3NWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-13T19:17:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-13T19:36:13Z"}, "message": "Introduce an io::Buffer trait\n\nThis trait is meant to abstract whether a reader is actually implemented with an\nunderlying buffer. For all readers which are implemented as such, we can\nefficiently implement things like read_char, read_line, read_until, etc. There\nare two required methods for managing the internal buffer, and otherwise\nread_line and friends can all become default methods.\n\nCloses #10334", "tree": {"sha": "7b37f9c7fe08e52458ba2d6cd79b161e999c34ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b37f9c7fe08e52458ba2d6cd79b161e999c34ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bc092f109d79b7214fb11108bbe38ac322c775c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bc092f109d79b7214fb11108bbe38ac322c775c", "html_url": "https://github.com/rust-lang/rust/commit/7bc092f109d79b7214fb11108bbe38ac322c775c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bc092f109d79b7214fb11108bbe38ac322c775c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "825b127d4771ac417572cd783143f0cf7da34e48", "url": "https://api.github.com/repos/rust-lang/rust/commits/825b127d4771ac417572cd783143f0cf7da34e48", "html_url": "https://github.com/rust-lang/rust/commit/825b127d4771ac417572cd783143f0cf7da34e48"}], "stats": {"total": 216, "additions": 114, "deletions": 102}, "files": [{"sha": "2d8f1a721661993684a4a248739693b98a65253d", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 26, "deletions": 81, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/7bc092f109d79b7214fb11108bbe38ac322c775c/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc092f109d79b7214fb11108bbe38ac322c775c/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=7bc092f109d79b7214fb11108bbe38ac322c775c", "patch": "@@ -55,8 +55,7 @@ use prelude::*;\n \n use num;\n use vec;\n-use str;\n-use super::{Reader, Writer, Stream, Decorator};\n+use super::{Stream, Decorator};\n \n // libuv recommends 64k buffers to maximize throughput\n // https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n@@ -93,45 +92,10 @@ impl<R: Reader> BufferedReader<R> {\n     pub fn new(inner: R) -> BufferedReader<R> {\n         BufferedReader::with_capacity(DEFAULT_CAPACITY, inner)\n     }\n+}\n \n-    /// Reads the next line of input, interpreted as a sequence of utf-8\n-    /// encoded unicode codepoints. If a newline is encountered, then the\n-    /// newline is contained in the returned string.\n-    pub fn read_line(&mut self) -> Option<~str> {\n-        self.read_until('\\n' as u8).map(str::from_utf8_owned)\n-    }\n-\n-    /// Reads a sequence of bytes leading up to a specified delimeter. Once the\n-    /// specified byte is encountered, reading ceases and the bytes up to and\n-    /// including the delimiter are returned.\n-    pub fn read_until(&mut self, byte: u8) -> Option<~[u8]> {\n-        let mut res = ~[];\n-        let mut used;\n-        loop {\n-            {\n-                let available = self.fill_buffer();\n-                match available.iter().position(|&b| b == byte) {\n-                    Some(i) => {\n-                        res.push_all(available.slice_to(i + 1));\n-                        used = i + 1;\n-                        break\n-                    }\n-                    None => {\n-                        res.push_all(available);\n-                        used = available.len();\n-                    }\n-                }\n-            }\n-            if used == 0 {\n-                break\n-            }\n-            self.pos += used;\n-        }\n-        self.pos += used;\n-        return if res.len() == 0 {None} else {Some(res)};\n-    }\n-\n-    fn fill_buffer<'a>(&'a mut self) -> &'a [u8] {\n+impl<R: Reader> Buffer for BufferedReader<R> {\n+    fn fill<'a>(&'a mut self) -> &'a [u8] {\n         if self.pos == self.cap {\n             match self.inner.read(self.buf) {\n                 Some(cap) => {\n@@ -143,12 +107,17 @@ impl<R: Reader> BufferedReader<R> {\n         }\n         return self.buf.slice(self.pos, self.cap);\n     }\n+\n+    fn consume(&mut self, amt: uint) {\n+        self.pos += amt;\n+        assert!(self.pos <= self.cap);\n+    }\n }\n \n impl<R: Reader> Reader for BufferedReader<R> {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         let nread = {\n-            let available = self.fill_buffer();\n+            let available = self.fill();\n             if available.len() == 0 {\n                 return None;\n             }\n@@ -166,17 +135,9 @@ impl<R: Reader> Reader for BufferedReader<R> {\n }\n \n impl<R: Reader> Decorator<R> for BufferedReader<R> {\n-    fn inner(self) -> R {\n-        self.inner\n-    }\n-\n-    fn inner_ref<'a>(&'a self) -> &'a R {\n-        &self.inner\n-    }\n-\n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R {\n-        &mut self.inner\n-    }\n+    fn inner(self) -> R { self.inner }\n+    fn inner_ref<'a>(&'a self) -> &'a R { &self.inner }\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut R { &mut self.inner }\n }\n \n /// Wraps a Writer and buffers output to it\n@@ -279,13 +240,8 @@ impl<W: Writer> Decorator<W> for LineBufferedWriter<W> {\n struct InternalBufferedWriter<W>(BufferedWriter<W>);\n \n impl<W: Reader> Reader for InternalBufferedWriter<W> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        self.inner.read(buf)\n-    }\n-\n-    fn eof(&mut self) -> bool {\n-        self.inner.eof()\n-    }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.inner.read(buf) }\n+    fn eof(&mut self) -> bool { self.inner.eof() }\n }\n \n /// Wraps a Stream and buffers input and output to and from it\n@@ -311,35 +267,24 @@ impl<S: Stream> BufferedStream<S> {\n     }\n }\n \n-impl<S: Stream> Reader for BufferedStream<S> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        self.inner.read(buf)\n-    }\n+impl<S: Stream> Buffer for BufferedStream<S> {\n+    fn fill<'a>(&'a mut self) -> &'a [u8] { self.inner.fill() }\n+    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n+}\n \n-    fn eof(&mut self) -> bool {\n-        self.inner.eof()\n-    }\n+impl<S: Stream> Reader for BufferedStream<S> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.inner.read(buf) }\n+    fn eof(&mut self) -> bool { self.inner.eof() }\n }\n \n impl<S: Stream> Writer for BufferedStream<S> {\n-    fn write(&mut self, buf: &[u8]) {\n-        self.inner.inner.write(buf)\n-    }\n-\n-    fn flush(&mut self) {\n-        self.inner.inner.flush()\n-    }\n+    fn write(&mut self, buf: &[u8]) { self.inner.inner.write(buf) }\n+    fn flush(&mut self) { self.inner.inner.flush() }\n }\n \n impl<S: Stream> Decorator<S> for BufferedStream<S> {\n-    fn inner(self) -> S {\n-        self.inner.inner.inner()\n-    }\n-\n-    fn inner_ref<'a>(&'a self) -> &'a S {\n-        self.inner.inner.inner_ref()\n-    }\n-\n+    fn inner(self) -> S { self.inner.inner.inner() }\n+    fn inner_ref<'a>(&'a self) -> &'a S { self.inner.inner.inner_ref() }\n     fn inner_mut_ref<'a>(&'a mut self) -> &'a mut S {\n         self.inner.inner.inner_mut_ref()\n     }"}, {"sha": "541648a534f6ef0558aba08ee866729be630e349", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7bc092f109d79b7214fb11108bbe38ac322c775c/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc092f109d79b7214fb11108bbe38ac322c775c/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=7bc092f109d79b7214fb11108bbe38ac322c775c", "patch": "@@ -119,29 +119,18 @@ impl Reader for MemReader {\n \n impl Seek for MemReader {\n     fn tell(&self) -> u64 { self.pos as u64 }\n-\n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n-impl Decorator<~[u8]> for MemReader {\n-\n-    fn inner(self) -> ~[u8] {\n-        match self {\n-            MemReader { buf: buf, _ } => buf\n-        }\n-    }\n-\n-    fn inner_ref<'a>(&'a self) -> &'a ~[u8] {\n-        match *self {\n-            MemReader { buf: ref buf, _ } => buf\n-        }\n-    }\n+impl Buffer for MemReader {\n+    fn fill<'a>(&'a mut self) -> &'a [u8] { self.buf.slice_from(self.pos) }\n+    fn consume(&mut self, amt: uint) { self.pos += amt; }\n+}\n \n-    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] {\n-        match *self {\n-            MemReader { buf: ref mut buf, _ } => buf\n-        }\n-    }\n+impl Decorator<~[u8]> for MemReader {\n+    fn inner(self) -> ~[u8] { self.buf }\n+    fn inner_ref<'a>(&'a self) -> &'a ~[u8] { &self.buf }\n+    fn inner_mut_ref<'a>(&'a mut self) -> &'a mut ~[u8] { &mut self.buf }\n }\n \n \n@@ -214,6 +203,11 @@ impl<'self> Seek for BufReader<'self> {\n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n+impl<'self> Buffer for BufReader<'self> {\n+    fn fill<'a>(&'a mut self) -> &'a [u8] { self.buf.slice_from(self.pos) }\n+    fn consume(&mut self, amt: uint) { self.pos += amt; }\n+}\n+\n ///Calls a function with a MemWriter and returns\n ///the writer's stored vector.\n pub fn with_mem_writer(writeFn:&fn(&mut MemWriter)) -> ~[u8] {"}, {"sha": "251e60bdbe0a26a732397eb619422d11e1bf9cb5", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7bc092f109d79b7214fb11108bbe38ac322c775c/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc092f109d79b7214fb11108bbe38ac322c775c/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=7bc092f109d79b7214fb11108bbe38ac322c775c", "patch": "@@ -247,11 +247,12 @@ use iter::Iterator;\n use option::{Option, Some, None};\n use path::Path;\n use result::{Ok, Err, Result};\n+use str;\n use str::{StrSlice, OwnedStr};\n use to_str::ToStr;\n use uint;\n use unstable::finally::Finally;\n-use vec::{OwnedVector, MutableVector};\n+use vec::{OwnedVector, MutableVector, ImmutableVector, OwnedCopyableVector};\n use vec;\n \n // Reexports\n@@ -977,6 +978,78 @@ pub trait Stream: Reader + Writer { }\n \n impl<T: Reader + Writer> Stream for T {}\n \n+/// A Buffer is a type of reader which has some form of internal buffering to\n+/// allow certain kinds of reading operations to be more optimized than others.\n+/// This type extends the `Reader` trait with a few methods that are not\n+/// possible to reasonably implement with purely a read interface.\n+pub trait Buffer: Reader {\n+    /// Fills the internal buffer of this object, returning the buffer contents.\n+    /// Note that none of the contents will be \"read\" in the sense that later\n+    /// calling `read` may return the same contents.\n+    ///\n+    /// The `consume` function must be called with the number of bytes that are\n+    /// consumed from this buffer returned to ensure that the bytes are never\n+    /// returned twice.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if a read error is\n+    /// encountered.\n+    fn fill<'a>(&'a mut self) -> &'a [u8];\n+\n+    /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n+    /// so they should no longer be returned in calls to `fill` or `read`.\n+    fn consume(&mut self, amt: uint);\n+\n+    /// Reads the next line of input, interpreted as a sequence of utf-8\n+    /// encoded unicode codepoints. If a newline is encountered, then the\n+    /// newline is contained in the returned string.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if a read error is\n+    /// encountered. The task will also fail if sequence of bytes leading up to\n+    /// the newline character are not valid utf-8.\n+    fn read_line(&mut self) -> Option<~str> {\n+        self.read_until('\\n' as u8).map(str::from_utf8_owned)\n+    }\n+\n+    /// Reads a sequence of bytes leading up to a specified delimeter. Once the\n+    /// specified byte is encountered, reading ceases and the bytes up to and\n+    /// including the delimiter are returned.\n+    ///\n+    /// # Failure\n+    ///\n+    /// This function will raise on the `io_error` condition if a read error is\n+    /// encountered.\n+    fn read_until(&mut self, byte: u8) -> Option<~[u8]> {\n+        let mut res = ~[];\n+        let mut used;\n+        loop {\n+            {\n+                let available = self.fill();\n+                match available.iter().position(|&b| b == byte) {\n+                    Some(i) => {\n+                        res.push_all(available.slice_to(i + 1));\n+                        used = i + 1;\n+                        break\n+                    }\n+                    None => {\n+                        res.push_all(available);\n+                        used = available.len();\n+                    }\n+                }\n+            }\n+            if used == 0 {\n+                break\n+            }\n+            self.consume(used);\n+        }\n+        self.consume(used);\n+        return if res.len() == 0 {None} else {Some(res)};\n+    }\n+}\n+\n pub enum SeekStyle {\n     /// Seek from the beginning of the stream\n     SeekSet,"}, {"sha": "60fe21bb8d2b68a56535ded399c926c585006c44", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bc092f109d79b7214fb11108bbe38ac322c775c/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc092f109d79b7214fb11108bbe38ac322c775c/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=7bc092f109d79b7214fb11108bbe38ac322c775c", "patch": "@@ -67,7 +67,7 @@ pub use num::{Orderable, Signed, Unsigned, Round};\n pub use num::{Primitive, Int, Float, ToStrRadix, ToPrimitive, FromPrimitive};\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;\n-pub use io::{Writer, Reader, Seek};\n+pub use io::{Buffer, Writer, Reader, Seek};\n pub use send_str::{SendStr, SendStrOwned, SendStrStatic, IntoSendStr};\n pub use str::{Str, StrVector, StrSlice, OwnedStr};\n pub use to_bytes::IterBytes;"}]}