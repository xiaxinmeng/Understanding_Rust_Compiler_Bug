{"sha": "de16f94ada933cfd394ddab34c31410cf05268f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMTZmOTRhZGE5MzNjZmQzOTRkZGFiMzRjMzE0MTBjZjA1MjY4ZjE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-10-29T13:48:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-29T13:48:26Z"}, "message": "Merge #2103\n\n2103: Expand signature help r=matklad a=kjeremy\n\nSignature help using call syntax with tuple structs and enum variants\r\n\r\nFixes #2102.\n\nCo-authored-by: Jeremy Kolb <kjeremy@gmail.com>\nCo-authored-by: kjeremy <kjeremy@gmail.com>", "tree": {"sha": "f27b83617f56cb96f91b3a7ba37a5a5f41524606", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f27b83617f56cb96f91b3a7ba37a5a5f41524606"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de16f94ada933cfd394ddab34c31410cf05268f1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJduEMqCRBK7hj4Ov3rIwAAdHIIAI4bEEf22IRCcH0kmTr3H/rK\nv2NcQeFJ017oGXyHRn2AQJGVGyDi6Fs6FJE8JqCcb0ut0hOjgaS2apI1vzJggmrD\n260BACUisi36qk1RQD4fn7h7gcuV63QiTnuMCaDHCDHYP1pq3Kbrfg8R9bIUwxQj\n+Y48DwWpq8wsqLYbJPRJLDtYqVoL0EaS+UMSgkuzB/GPtk101sWZrPfcw7yDTS8A\nB/zWYFfllvLtzoXm39ji5oZ1kk3HtWPnPQir2ukpVJU7DifFzBOCm95vmlougVQe\nTw3Oeskjq+iOAg0DVnlZZOsDIvwq9UrCmJtpeKmzPLQ9Z8+GsjkwglubcLhgUSw=\n=XOev\n-----END PGP SIGNATURE-----\n", "payload": "tree f27b83617f56cb96f91b3a7ba37a5a5f41524606\nparent e38cdf6e56d963525fcc656b80965e7114756496\nparent b915bf2d05e3edf7e23e595b2b95bdcdaa0907fd\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1572356906 +0000\ncommitter GitHub <noreply@github.com> 1572356906 +0000\n\nMerge #2103\n\n2103: Expand signature help r=matklad a=kjeremy\n\nSignature help using call syntax with tuple structs and enum variants\r\n\r\nFixes #2102.\n\nCo-authored-by: Jeremy Kolb <kjeremy@gmail.com>\nCo-authored-by: kjeremy <kjeremy@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de16f94ada933cfd394ddab34c31410cf05268f1", "html_url": "https://github.com/rust-lang/rust/commit/de16f94ada933cfd394ddab34c31410cf05268f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de16f94ada933cfd394ddab34c31410cf05268f1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e38cdf6e56d963525fcc656b80965e7114756496", "url": "https://api.github.com/repos/rust-lang/rust/commits/e38cdf6e56d963525fcc656b80965e7114756496", "html_url": "https://github.com/rust-lang/rust/commit/e38cdf6e56d963525fcc656b80965e7114756496"}, {"sha": "b915bf2d05e3edf7e23e595b2b95bdcdaa0907fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b915bf2d05e3edf7e23e595b2b95bdcdaa0907fd", "html_url": "https://github.com/rust-lang/rust/commit/b915bf2d05e3edf7e23e595b2b95bdcdaa0907fd"}], "stats": {"total": 195, "additions": 184, "deletions": 11}, "files": [{"sha": "d947ac50c2fc170c2c7eda17b366609414eeb275", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 96, "deletions": 9, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/de16f94ada933cfd394ddab34c31410cf05268f1/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de16f94ada933cfd394ddab34c31410cf05268f1/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=de16f94ada933cfd394ddab34c31410cf05268f1", "patch": "@@ -20,24 +20,26 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     let name_ref = calling_node.name_ref()?;\n \n     let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-    let function = match &calling_node {\n+    let (mut call_info, has_self) = match &calling_node {\n         FnCallNode::CallExpr(expr) => {\n             //FIXME: apply subst\n             let (callable_def, _subst) = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n             match callable_def {\n-                hir::CallableDef::Function(it) => it,\n-                //FIXME: handle other callables\n-                _ => return None,\n+                hir::CallableDef::Function(it) => {\n+                    (CallInfo::with_fn(db, it), it.data(db).has_self_param())\n+                }\n+                hir::CallableDef::Struct(it) => (CallInfo::with_struct(db, it)?, false),\n+                hir::CallableDef::EnumVariant(it) => (CallInfo::with_enum_variant(db, it)?, false),\n             }\n         }\n-        FnCallNode::MethodCallExpr(expr) => analyzer.resolve_method_call(&expr)?,\n+        FnCallNode::MethodCallExpr(expr) => {\n+            let function = analyzer.resolve_method_call(&expr)?;\n+            (CallInfo::with_fn(db, function), function.data(db).has_self_param())\n+        }\n     };\n \n-    let mut call_info = CallInfo::new(db, function);\n-\n     // If we have a calling expression let's find which argument we are on\n     let num_params = call_info.parameters().len();\n-    let has_self = function.data(db).has_self_param();\n \n     if num_params == 1 {\n         if !has_self {\n@@ -115,12 +117,24 @@ impl FnCallNode {\n }\n \n impl CallInfo {\n-    fn new(db: &RootDatabase, function: hir::Function) -> Self {\n+    fn with_fn(db: &RootDatabase, function: hir::Function) -> Self {\n         let signature = FunctionSignature::from_hir(db, function);\n \n         CallInfo { signature, active_parameter: None }\n     }\n \n+    fn with_struct(db: &RootDatabase, st: hir::Struct) -> Option<Self> {\n+        let signature = FunctionSignature::from_struct(db, st)?;\n+\n+        Some(CallInfo { signature, active_parameter: None })\n+    }\n+\n+    fn with_enum_variant(db: &RootDatabase, variant: hir::EnumVariant) -> Option<Self> {\n+        let signature = FunctionSignature::from_enum_variant(db, variant)?;\n+\n+        Some(CallInfo { signature, active_parameter: None })\n+    }\n+\n     fn parameters(&self) -> &[String] {\n         &self.signature.parameters\n     }\n@@ -462,4 +476,77 @@ fn main() {\n         assert_eq!(info.active_parameter, Some(1));\n         assert_eq!(info.label(), \"fn bar(&self, _: u32)\");\n     }\n+\n+    #[test]\n+    fn works_for_tuple_structs() {\n+        let info = call_info(\n+            r#\"\n+/// A cool tuple struct\n+struct TS(u32, i32);\n+fn main() {\n+    let s = TS(0, <|>);\n+}\"#,\n+        );\n+\n+        assert_eq!(info.label(), \"struct TS(u32, i32) -> TS\");\n+        assert_eq!(info.doc().map(|it| it.into()), Some(\"A cool tuple struct\".to_string()));\n+        assert_eq!(info.active_parameter, Some(1));\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn cant_call_named_structs() {\n+        let _ = call_info(\n+            r#\"\n+struct TS { x: u32, y: i32 }\n+fn main() {\n+    let s = TS(<|>);\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn works_for_enum_variants() {\n+        let info = call_info(\n+            r#\"\n+enum E {\n+    /// A Variant\n+    A(i32),\n+    /// Another\n+    B,\n+    /// And C\n+    C { a: i32, b: i32 }\n+}\n+\n+fn main() {\n+    let a = E::A(<|>);\n+}\n+            \"#,\n+        );\n+\n+        assert_eq!(info.label(), \"E::A(0: i32)\");\n+        assert_eq!(info.doc().map(|it| it.into()), Some(\"A Variant\".to_string()));\n+        assert_eq!(info.active_parameter, Some(0));\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn cant_call_enum_records() {\n+        let _ = call_info(\n+            r#\"\n+enum E {\n+    /// A Variant\n+    A(i32),\n+    /// Another\n+    B,\n+    /// And C\n+    C { a: i32, b: i32 }\n+}\n+\n+fn main() {\n+    let a = E::C(<|>);\n+}\n+            \"#,\n+        );\n+    }\n }"}, {"sha": "e21f8378d868fd43b7f476c35d15c3bce8be4db2", "filename": "crates/ra_ide_api/src/display/function_signature.rs", "status": "modified", "additions": 88, "deletions": 2, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/de16f94ada933cfd394ddab34c31410cf05268f1/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de16f94ada933cfd394ddab34c31410cf05268f1/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=de16f94ada933cfd394ddab34c31410cf05268f1", "patch": "@@ -2,7 +2,7 @@\n \n use std::fmt::{self, Display};\n \n-use hir::{Docs, Documentation, HasSource};\n+use hir::{Docs, Documentation, HasSource, HirDisplay};\n use join_to_string::join;\n use ra_syntax::ast::{self, AstNode, NameOwner, VisibilityOwner};\n use std::convert::From;\n@@ -12,9 +12,17 @@ use crate::{\n     display::{generic_parameters, where_predicates},\n };\n \n+#[derive(Debug)]\n+pub enum CallableKind {\n+    Function,\n+    StructConstructor,\n+    VariantConstructor,\n+}\n+\n /// Contains information about a function signature\n #[derive(Debug)]\n pub struct FunctionSignature {\n+    pub kind: CallableKind,\n     /// Optional visibility\n     pub visibility: Option<String>,\n     /// Name of the function\n@@ -42,6 +50,79 @@ impl FunctionSignature {\n         let ast_node = function.source(db).ast;\n         FunctionSignature::from(&ast_node).with_doc_opt(doc)\n     }\n+\n+    pub(crate) fn from_struct(db: &db::RootDatabase, st: hir::Struct) -> Option<Self> {\n+        let node: ast::StructDef = st.source(db).ast;\n+        match node.kind() {\n+            ast::StructKind::Named(_) => return None,\n+            _ => (),\n+        };\n+\n+        let params = st\n+            .fields(db)\n+            .into_iter()\n+            .map(|field: hir::StructField| {\n+                let ty = field.ty(db);\n+                format!(\"{}\", ty.display(db))\n+            })\n+            .collect();\n+\n+        Some(\n+            FunctionSignature {\n+                kind: CallableKind::StructConstructor,\n+                visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n+                name: node.name().map(|n| n.text().to_string()),\n+                ret_type: node.name().map(|n| n.text().to_string()),\n+                parameters: params,\n+                generic_parameters: generic_parameters(&node),\n+                where_predicates: where_predicates(&node),\n+                doc: None,\n+            }\n+            .with_doc_opt(st.docs(db)),\n+        )\n+    }\n+\n+    pub(crate) fn from_enum_variant(\n+        db: &db::RootDatabase,\n+        variant: hir::EnumVariant,\n+    ) -> Option<Self> {\n+        let node: ast::EnumVariant = variant.source(db).ast;\n+        match node.kind() {\n+            ast::StructKind::Named(_) | ast::StructKind::Unit => return None,\n+            _ => (),\n+        };\n+\n+        let parent_name = match variant.parent_enum(db).name(db) {\n+            Some(name) => name.to_string(),\n+            None => \"missing\".into(),\n+        };\n+\n+        let name = format!(\"{}::{}\", parent_name, variant.name(db).unwrap());\n+\n+        let params = variant\n+            .fields(db)\n+            .into_iter()\n+            .map(|field: hir::StructField| {\n+                let name = field.name(db);\n+                let ty = field.ty(db);\n+                format!(\"{}: {}\", name, ty.display(db))\n+            })\n+            .collect();\n+\n+        Some(\n+            FunctionSignature {\n+                kind: CallableKind::VariantConstructor,\n+                visibility: None,\n+                name: Some(name),\n+                ret_type: None,\n+                parameters: params,\n+                generic_parameters: vec![],\n+                where_predicates: vec![],\n+                doc: None,\n+            }\n+            .with_doc_opt(variant.docs(db)),\n+        )\n+    }\n }\n \n impl From<&'_ ast::FnDef> for FunctionSignature {\n@@ -59,6 +140,7 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n         }\n \n         FunctionSignature {\n+            kind: CallableKind::Function,\n             visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n             name: node.name().map(|n| n.text().to_string()),\n             ret_type: node\n@@ -81,7 +163,11 @@ impl Display for FunctionSignature {\n         }\n \n         if let Some(name) = &self.name {\n-            write!(f, \"fn {}\", name)?;\n+            match self.kind {\n+                CallableKind::Function => write!(f, \"fn {}\", name)?,\n+                CallableKind::StructConstructor => write!(f, \"struct {}\", name)?,\n+                CallableKind::VariantConstructor => write!(f, \"{}\", name)?,\n+            }\n         }\n \n         if !self.generic_parameters.is_empty() {"}]}