{"sha": "2a016890a0e2ad349423c684f595b71b19572c79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMDE2ODkwYTBlMmFkMzQ5NDIzYzY4NGY1OTViNzFiMTk1NzJjNzk=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-16T08:20:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-07-16T08:20:29Z"}, "message": "Merge pull request #2920 from rust-lang-nursery/rustup\n\nRustup", "tree": {"sha": "bb47437adc5d0ce7a45d3aee96971a705187b43b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb47437adc5d0ce7a45d3aee96971a705187b43b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a016890a0e2ad349423c684f595b71b19572c79", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbTFVNCRBK7hj4Ov3rIwAAdHIIAE2GqKwEWuxuCjGKZNMlVb4m\nNnI0vxLwPE8cfCHfi5HjLodfWeQXYvX8+6nHBAouv3Y6LO1TxbnugeoAl2DYdsj4\n5OxjLx9re44ttjsuWeFA/MjAOnBC3hP/qA702c0fqEuPHjIcyG7Pdh+qLonrMkB+\n4OO0kJzc+RRvyM+s0a+1TqkvCzRMqYrEZk4iaRSHfLMHo+qXWDvawdG5yLgguMW8\nbuK4RB7iL09UArh4XQ9o0VeJJjMQQ+ajrOnU6bpst/EA0matTTJywIL1iGKbvMcW\ng4rBaQr2sm+xpAUJax61BexsZvwdEkdUDdgxdJdKoJFGBxYfNaqpW7xZ6XZo63Q=\n=48V4\n-----END PGP SIGNATURE-----\n", "payload": "tree bb47437adc5d0ce7a45d3aee96971a705187b43b\nparent 06d6710147742892efc17ed307b3397bfe093bc7\nparent 5e085e43104f6748a9717bb78de8b634712638b4\nauthor Oliver Schneider <github35764891676564198441@oli-obk.de> 1531729229 +0200\ncommitter GitHub <noreply@github.com> 1531729229 +0200\n\nMerge pull request #2920 from rust-lang-nursery/rustup\n\nRustup"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a016890a0e2ad349423c684f595b71b19572c79", "html_url": "https://github.com/rust-lang/rust/commit/2a016890a0e2ad349423c684f595b71b19572c79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a016890a0e2ad349423c684f595b71b19572c79/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06d6710147742892efc17ed307b3397bfe093bc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/06d6710147742892efc17ed307b3397bfe093bc7", "html_url": "https://github.com/rust-lang/rust/commit/06d6710147742892efc17ed307b3397bfe093bc7"}, {"sha": "5e085e43104f6748a9717bb78de8b634712638b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e085e43104f6748a9717bb78de8b634712638b4", "html_url": "https://github.com/rust-lang/rust/commit/5e085e43104f6748a9717bb78de8b634712638b4"}], "stats": {"total": 146, "additions": 89, "deletions": 57}, "files": [{"sha": "e90dc6f693a33a2b0a83fe856c67d8032ed44d8b", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n \n impl EnumGlobUse {\n     fn lint_item(&self, cx: &LateContext, item: &Item) {\n-        if item.vis.node == VisibilityKind::Public {\n+        if item.vis.node.is_pub() {\n             return; // re-exports are fine\n         }\n         if let ItemUse(ref path, UseKind::Glob) = item.node {"}, {"sha": "d272cab0a0df941174593b27472ce6e3b939c8a5", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -262,7 +262,7 @@ impl EarlyLintPass for EnumVariantNames {\n                             );\n                         }\n                     }\n-                    if item.vis.node == VisibilityKind::Public {\n+                    if item.vis.node.is_pub() {\n                         let matching = partial_match(mod_camel, &item_camel);\n                         let rmatching = partial_rmatch(mod_camel, &item_camel);\n                         let nchars = mod_camel.chars().count();"}, {"sha": "78b21478d8868d9c07c375de68665bdd4f11a9af", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -48,13 +48,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if let ExprMatch(ref op, ref arms, MatchSource::IfLetDesugar { .. }) = expr.node {\n             if arms[0].pats.len() == 1 {\n                 let good_method = match arms[0].pats[0].node {\n-                    PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 && pats[0].node == PatKind::Wild => {\n-                        if match_qpath(path, &paths::RESULT_OK) {\n-                            \"is_ok()\"\n-                        } else if match_qpath(path, &paths::RESULT_ERR) {\n-                            \"is_err()\"\n-                        } else if match_qpath(path, &paths::OPTION_SOME) {\n-                            \"is_some()\"\n+                    PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 => {\n+                        if let PatKind::Wild = pats[0].node {\n+                            if match_qpath(path, &paths::RESULT_OK) {\n+                                \"is_ok()\"\n+                            } else if match_qpath(path, &paths::RESULT_ERR) {\n+                                \"is_err()\"\n+                            } else if match_qpath(path, &paths::OPTION_SOME) {\n+                                \"is_some()\"\n+                            } else {\n+                                return;\n+                            }\n                         } else {\n                             return;\n                         }"}, {"sha": "c1ec7a16296c719780dfbd876b366a176ba755c8", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -258,11 +258,10 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n \n     let ty = &walk_ptrs_ty(cx.tables.expr_ty(expr));\n     match ty.sty {\n-        ty::TyDynamic(..) => cx.tcx\n-            .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n+        ty::TyDynamic(ref tt, ..) => cx.tcx\n+            .associated_items(tt.principal().expect(\"trait impl not found\").def_id())\n             .any(|item| is_is_empty(cx, &item)),\n-        ty::TyProjection(_) => ty.ty_to_def_id()\n-            .map_or(false, |id| has_is_empty_impl(cx, id)),\n+        ty::TyProjection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n         ty::TyAdt(id, _) => has_is_empty_impl(cx, id.did),\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyStr => true,\n         _ => false,"}, {"sha": "963a8da49cb8a519550980d5ad10dfd8b9271eff", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -23,7 +23,7 @@ use crate::consts::{constant, Constant};\n \n use crate::utils::{get_enclosing_block, get_parent_expr, higher, in_external_macro, is_integer_literal, is_refutable,\n             last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, snippet, snippet_opt,\n-            span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then};\n+            span_help_and_lint, span_lint, span_lint_and_sugg, span_lint_and_then, SpanlessEq};\n use crate::utils::paths;\n \n /// **What it does:** Checks for for-loops that manually copy items between\n@@ -1955,7 +1955,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         if self.state == VarState::DontWarn {\n             return;\n         }\n-        if expr == self.end_expr {\n+        if SpanlessEq::new(self.cx).eq_expr(&expr, self.end_expr) {\n             self.past_loop = true;\n             return;\n         }"}, {"sha": "0d58732f24d1e8d981c47e770838b665ab739494", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::*;\n use rustc::ty;\n use syntax::ast;\n use crate::utils::{get_arg_ident, is_adjusted, iter_input_pats, match_qpath, match_trait_method, match_type,\n-            paths, remove_blocks, snippet, span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+            paths, remove_blocks, snippet, span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq};\n \n /// **What it does:** Checks for mapping `clone()` over an iterator.\n ///\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                     if clone_call.ident.name == \"clone\" &&\n                                         clone_args.len() == 1 &&\n                                         match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n-                                        expr_eq_name(&clone_args[0], arg_ident)\n+                                        expr_eq_name(cx, &clone_args[0], arg_ident)\n                                     {\n                                         span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                             \"you seem to be using .map() to clone the contents of an {}, consider \\\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn expr_eq_name(expr: &Expr, id: ast::Ident) -> bool {\n+fn expr_eq_name(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n         ExprPath(QPath::Resolved(None, ref path)) => {\n             let arg_segment = [\n@@ -108,7 +108,7 @@ fn expr_eq_name(expr: &Expr, id: ast::Ident) -> bool {\n                     infer_types: true,\n                 },\n             ];\n-            !path.is_global() && path.segments[..] == arg_segment\n+            !path.is_global() && SpanlessEq::new(cx).eq_path_segments(&path.segments[..], &arg_segment)\n         },\n         _ => false,\n     }\n@@ -127,7 +127,7 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n fn only_derefs(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n         ExprUnary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n-        _ => expr_eq_name(expr, id),\n+        _ => expr_eq_name(cx, expr, id),\n     }\n }\n "}, {"sha": "a14c6a0d8b9049e98f446223ac84efbbd95e5663", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -221,7 +221,7 @@ fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n }\n \n fn check_single_match_single_pattern(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr, els: Option<&Expr>) {\n-    if arms[1].pats[0].node == PatKind::Wild {\n+    if is_wild(&arms[1].pats[0]) {\n         report_single_match_single_pattern(cx, ex, arms, expr, els);\n     }\n }\n@@ -265,7 +265,7 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n     let path = match arms[1].pats[0].node {\n         PatKind::TupleStruct(ref path, ref inner, _) => {\n             // contains any non wildcard patterns? e.g. Err(err)\n-            if inner.iter().any(|pat| pat.node != PatKind::Wild) {\n+            if !inner.iter().all(is_wild) {\n                 return;\n             }\n             print::to_string(print::NO_ANN, |s| s.print_qpath(path, false))\n@@ -356,6 +356,13 @@ fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr,\n     }\n }\n \n+fn is_wild(pat: &impl std::ops::Deref<Target = Pat>) -> bool {\n+    match pat.node {\n+        PatKind::Wild => true,\n+        _ => false,\n+    }\n+}\n+\n fn check_wild_err_arm(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n     let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n     if match_type(cx, ex_ty, &paths::RESULT) {\n@@ -364,7 +371,7 @@ fn check_wild_err_arm(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n                 let path_str = print::to_string(print::NO_ANN, |s| s.print_qpath(path, false));\n                 if_chain! {\n                     if path_str == \"Err\";\n-                    if inner.iter().any(|pat| pat.node == PatKind::Wild);\n+                    if inner.iter().any(is_wild);\n                     if let ExprBlock(ref block, _) = arm.body.node;\n                     if is_panic_block(block);\n                     then {"}, {"sha": "ca739558e6271b6d2f33cc0ed2a9ae97a5d8fb25", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -10,7 +10,7 @@ use syntax::codemap::{Span, BytePos};\n use crate::utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_expn_of, is_self,\n             is_self_ty, iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n             match_type, method_chain_args, match_var, return_ty, remove_blocks, same_tys, single_segment_path, snippet,\n-            span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+            span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, SpanlessEq};\n use crate::utils::paths;\n use crate::utils::sugg;\n use crate::consts::{constant, Constant};\n@@ -820,8 +820,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n                         if name == method_name &&\n                         sig.decl.inputs.len() == n_args &&\n-                        out_type.matches(&sig.decl.output) &&\n-                        self_kind.matches(first_arg_ty, first_arg, self_ty, false, &implitem.generics) {\n+                        out_type.matches(cx, &sig.decl.output) &&\n+                        self_kind.matches(cx, first_arg_ty, first_arg, self_ty, false, &implitem.generics) {\n                             span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n                                 \"defining a method called `{}` on this type; consider implementing \\\n                                 the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n@@ -838,9 +838,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         if conv.check(&name.as_str());\n                         if !self_kinds\n                             .iter()\n-                            .any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy, &implitem.generics));\n+                            .any(|k| k.matches(cx, first_arg_ty, first_arg, self_ty, is_copy, &implitem.generics));\n                         then {\n-                            let lint = if item.vis.node == hir::VisibilityKind::Public {\n+                            let lint = if item.vis.node.is_pub() {\n                                 WRONG_PUB_SELF_CONVENTION\n                             } else {\n                                 WRONG_SELF_CONVENTION\n@@ -2030,6 +2030,7 @@ enum SelfKind {\n impl SelfKind {\n     fn matches(\n         self,\n+        cx: &LateContext,\n         ty: &hir::Ty,\n         arg: &hir::Arg,\n         self_ty: &hir::Ty,\n@@ -2047,7 +2048,7 @@ impl SelfKind {\n         // `Self`, `&mut Self`,\n         // and `Box<Self>`, including the equivalent types with `Foo`.\n \n-        let is_actually_self = |ty| is_self_ty(ty) || ty == self_ty;\n+        let is_actually_self = |ty| is_self_ty(ty) || SpanlessEq::new(cx).eq_ty(ty, self_ty);\n         if is_self(arg) {\n             match self {\n                 SelfKind::Value => is_actually_self(ty),\n@@ -2173,12 +2174,13 @@ enum OutType {\n }\n \n impl OutType {\n-    fn matches(self, ty: &hir::FunctionRetTy) -> bool {\n+    fn matches(self, cx: &LateContext, ty: &hir::FunctionRetTy) -> bool {\n+        let is_unit = |ty: &hir::Ty| SpanlessEq::new(cx).eq_ty_kind(&ty.node, &hir::TyTup(vec![].into()));\n         match (self, ty) {\n             (OutType::Unit, &hir::DefaultReturn(_)) => true,\n-            (OutType::Unit, &hir::Return(ref ty)) if ty.node == hir::TyTup(vec![].into()) => true,\n+            (OutType::Unit, &hir::Return(ref ty)) if is_unit(ty) => true,\n             (OutType::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n-            (OutType::Any, &hir::Return(ref ty)) if ty.node != hir::TyTup(vec![].into()) => true,\n+            (OutType::Any, &hir::Return(ref ty)) if !is_unit(ty) => true,\n             (OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyRptr(_, _)),\n             _ => false,\n         }"}, {"sha": "4fc65b2f89af73ea9312849e4e3026f4ee7346f7", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -6,7 +6,7 @@ use rustc::ty;\n use syntax::codemap::{ExpnFormat, Span};\n use crate::utils::{get_item_name, get_parent_expr, implements_trait, in_constant, in_macro, is_integer_literal,\n             iter_input_pats, last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint,\n-            span_lint_and_then, walk_ptrs_ty};\n+            span_lint_and_then, walk_ptrs_ty, SpanlessEq};\n use crate::utils::sugg::Sugg;\n use syntax::ast::{LitKind, CRATE_NODE_ID};\n use crate::consts::{constant, Constant};\n@@ -418,7 +418,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n     fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if let PatKind::Binding(_, _, ident, Some(ref right)) = pat.node {\n-            if right.node == PatKind::Wild {\n+            if let PatKind::Wild = right.node {\n                 span_lint(\n                     cx,\n                     REDUNDANT_PATTERN,\n@@ -542,7 +542,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         match parent.node {\n-            ExprAssign(_, ref rhs) | ExprAssignOp(_, _, ref rhs) => **rhs == *expr,\n+            ExprAssign(_, ref rhs) | ExprAssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n             _ => is_used(cx, parent),\n         }\n     } else {"}, {"sha": "e527a05c85185addd950ab3f23be4cbb5f6656cc", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -213,7 +213,7 @@ impl EarlyLintPass for MiscEarly {\n                 .name;\n \n             for field in pfields {\n-                if field.node.pat.node == PatKind::Wild {\n+                if let PatKind::Wild = field.node.pat.node {\n                     wilds += 1;\n                 }\n             }\n@@ -231,14 +231,15 @@ impl EarlyLintPass for MiscEarly {\n                 let mut normal = vec![];\n \n                 for field in pfields {\n-                    if field.node.pat.node != PatKind::Wild {\n-                        if let Ok(n) = cx.sess().codemap().span_to_snippet(field.span) {\n+                    match field.node.pat.node {\n+                        PatKind::Wild => {},\n+                        _ => if let Ok(n) = cx.sess().codemap().span_to_snippet(field.span) {\n                             normal.push(n);\n-                        }\n+                        },\n                     }\n                 }\n                 for field in pfields {\n-                    if field.node.pat.node == PatKind::Wild {\n+                    if let PatKind::Wild = field.node.pat.node {\n                         wilds -= 1;\n                         if wilds > 0 {\n                             span_lint("}, {"sha": "c5b0c97795668c8d872fbbfcca7dd86a4d6d9391", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use crate::utils::span_lint;\n+use crate::utils::{span_lint, SpanlessEq};\n \n /// **What it does:** Detects classic underflow/overflow checks.\n ///\n@@ -31,13 +31,14 @@ impl LintPass for OverflowCheckConditional {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n     // a + b < a, a > a + b, a < a - b, a - b > a\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        let eq = |l, r| SpanlessEq::new(cx).eq_path_segment(l, r);\n         if_chain! {\n             if let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node;\n             if let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node;\n             if let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node;\n             if let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node;\n             if let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = second.node;\n-            if path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0];\n+            if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.tables.expr_ty(ident1).is_integral();\n             if cx.tables.expr_ty(ident2).is_integral();\n             then {\n@@ -62,7 +63,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n             if let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node;\n             if let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node;\n             if let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = first.node;\n-            if path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0];\n+            if eq(&path1.segments[0], &path3.segments[0]) || eq(&path2.segments[0], &path3.segments[0]);\n             if cx.tables.expr_ty(ident1).is_integral();\n             if cx.tables.expr_ty(ident2).is_integral();\n             then {"}, {"sha": "c0fac47b34e82db2209754873e886e50cb7aed82", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -3,7 +3,7 @@ use rustc::hir::*;\n use syntax::ast::RangeLimits;\n use syntax::codemap::Spanned;\n use crate::utils::{is_integer_literal, paths, snippet, span_lint, span_lint_and_then};\n-use crate::utils::{get_trait_def_id, higher, implements_trait};\n+use crate::utils::{get_trait_def_id, higher, implements_trait, SpanlessEq};\n use crate::utils::sugg::Sugg;\n \n /// **What it does:** Checks for calling `.step_by(0)` on iterators,\n@@ -118,7 +118,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     // .iter() and .len() called on same Path\n                     if let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n                     if let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node;\n-                    if iter_path.segments == len_path.segments;\n+                    if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n                      then {\n                          span_lint(cx,\n                                    RANGE_ZIP_WITH_LEN,"}, {"sha": "1f6092789e53161fd07073ad1f32fd58ef591614", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 })\n             },\n             (&ExprMethodCall(ref l_path, _, ref l_args), &ExprMethodCall(ref r_path, _, ref r_args)) => {\n-                !self.ignore_fn && l_path == r_path && self.eq_exprs(l_args, r_args)\n+                !self.ignore_fn && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprRepeat(ref le, ref ll_id), &ExprRepeat(ref re, ref rl_id)) => {\n                 let mut celcx = constant_context(self.cx, self.cx.tcx.body_tables(ll_id.body));\n@@ -225,7 +225,11 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_path_segment(&mut self, left: &PathSegment, right: &PathSegment) -> bool {\n+    pub fn eq_path_segments(&mut self, left: &[PathSegment], right: &[PathSegment]) -> bool {\n+        left.len() == right.len() && left.iter().zip(right).all(|(l, r)| self.eq_path_segment(l, r))\n+    }\n+\n+    pub fn eq_path_segment(&mut self, left: &PathSegment, right: &PathSegment) -> bool {\n         // The == of idents doesn't work with different contexts,\n         // we have to be explicit about hygiene\n         if left.ident.as_str() != right.ident.as_str() {\n@@ -238,8 +242,12 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    fn eq_ty(&mut self, left: &Ty, right: &Ty) -> bool {\n-        match (&left.node, &right.node) {\n+    pub fn eq_ty(&mut self, left: &Ty, right: &Ty) -> bool {\n+        self.eq_ty_kind(&left.node, &right.node)\n+    }\n+\n+    pub fn eq_ty_kind(&mut self, left: &Ty_, right: &Ty_) -> bool {\n+        match (left, right) {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyArray(ref lt, ref ll_id), &TyArray(ref rt, ref rl_id)) => {\n                 let full_table = self.tables;\n@@ -336,7 +344,12 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n             self.hash_expr(e);\n         }\n \n-        b.rules.hash(&mut self.s);\n+        match b.rules {\n+            BlockCheckMode::DefaultBlock => 0,\n+            BlockCheckMode::UnsafeBlock(_) => 1,\n+            BlockCheckMode::PushUnsafeBlock(_) => 2,\n+            BlockCheckMode::PopUnsafeBlock(_) => 3,\n+        }.hash(&mut self.s);\n     }\n \n     #[allow(many_single_char_names)]\n@@ -419,7 +432,10 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n             ExprClosure(cap, _, eid, _, _) => {\n                 let c: fn(_, _, _, _, _) -> _ = ExprClosure;\n                 c.hash(&mut self.s);\n-                cap.hash(&mut self.s);\n+                match cap {\n+                    CaptureClause::CaptureByValue => 0,\n+                    CaptureClause::CaptureByRef => 1,\n+                }.hash(&mut self.s);\n                 self.hash_expr(&self.cx.tcx.hir.body(eid).value);\n             },\n             ExprField(ref e, ref f) => {"}, {"sha": "ef26b77ea1a4fee5ec68ec01a66718cd5303d2e2", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a016890a0e2ad349423c684f595b71b19572c79/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=2a016890a0e2ad349423c684f595b71b19572c79", "patch": "@@ -120,12 +120,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n         if let ItemStatic(ref ty, MutImmutable, body_id) = item.node {\n             if is_lint_ref_type(ty) {\n                 self.declared_lints.insert(item.name, item.span);\n-            } else if is_lint_array_type(ty) && item.vis.node == VisibilityKind::Inherited && item.name == \"ARRAY\" {\n-                let mut collector = LintCollector {\n-                    output: &mut self.registered_lints,\n-                    cx,\n-                };\n-                collector.visit_expr(&cx.tcx.hir.body(body_id).value);\n+            } else if is_lint_array_type(ty) && item.name == \"ARRAY\" {\n+                if let VisibilityKind::Inherited = item.vis.node {\n+                    let mut collector = LintCollector {\n+                        output: &mut self.registered_lints,\n+                        cx,\n+                    };\n+                    collector.visit_expr(&cx.tcx.hir.body(body_id).value);\n+                }\n             }\n         }\n     }"}]}