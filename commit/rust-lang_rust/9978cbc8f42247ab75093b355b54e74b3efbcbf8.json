{"sha": "9978cbc8f42247ab75093b355b54e74b3efbcbf8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NzhjYmM4ZjQyMjQ3YWI3NTA5M2IzNTViNTRlNzRiM2VmYmNiZjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-06T00:12:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-09T12:26:06Z"}, "message": "generalize BitMatrix to be NxM and not just NxN", "tree": {"sha": "3e92b7a45fb0098c3a634f4ea307b503ab0f29a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e92b7a45fb0098c3a634f4ea307b503ab0f29a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9978cbc8f42247ab75093b355b54e74b3efbcbf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9978cbc8f42247ab75093b355b54e74b3efbcbf8", "html_url": "https://github.com/rust-lang/rust/commit/9978cbc8f42247ab75093b355b54e74b3efbcbf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9978cbc8f42247ab75093b355b54e74b3efbcbf8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8150494ac24f430f986cdb093c4018a7c2bff7fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8150494ac24f430f986cdb093c4018a7c2bff7fd", "html_url": "https://github.com/rust-lang/rust/commit/8150494ac24f430f986cdb093c4018a7c2bff7fd"}], "stats": {"total": 86, "additions": 69, "deletions": 17}, "files": [{"sha": "0dab230f47a2d036bac2fc9b520417d592c249ef", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 67, "deletions": 16, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9978cbc8f42247ab75093b355b54e74b3efbcbf8/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9978cbc8f42247ab75093b355b54e74b3efbcbf8/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=9978cbc8f42247ab75093b355b54e74b3efbcbf8", "patch": "@@ -124,32 +124,32 @@ impl FromIterator<bool> for BitVector {\n     }\n }\n \n-/// A \"bit matrix\" is basically a square matrix of booleans\n-/// represented as one gigantic bitvector. In other words, it is as if\n-/// you have N bitvectors, each of length N. Note that `elements` here is `N`/\n+/// A \"bit matrix\" is basically a matrix of booleans represented as\n+/// one gigantic bitvector. In other words, it is as if you have\n+/// `rows` bitvectors, each of length `columns`.\n #[derive(Clone)]\n pub struct BitMatrix {\n-    elements: usize,\n+    columns: usize,\n     vector: Vec<u64>,\n }\n \n impl BitMatrix {\n-    // Create a new `elements x elements` matrix, initially empty.\n-    pub fn new(elements: usize) -> BitMatrix {\n+    // Create a new `rows x columns` matrix, initially empty.\n+    pub fn new(rows: usize, columns: usize) -> BitMatrix {\n         // For every element, we need one bit for every other\n         // element. Round up to an even number of u64s.\n-        let u64s_per_elem = u64s(elements);\n+        let u64s_per_row = u64s(columns);\n         BitMatrix {\n-            elements: elements,\n-            vector: vec![0; elements * u64s_per_elem],\n+            columns: columns,\n+            vector: vec![0; rows * u64s_per_row],\n         }\n     }\n \n-    /// The range of bits for a given element.\n-    fn range(&self, element: usize) -> (usize, usize) {\n-        let u64s_per_elem = u64s(self.elements);\n-        let start = element * u64s_per_elem;\n-        (start, start + u64s_per_elem)\n+    /// The range of bits for a given row.\n+    fn range(&self, row: usize) -> (usize, usize) {\n+        let u64s_per_row = u64s(self.columns);\n+        let start = row * u64s_per_row;\n+        (start, start + u64s_per_row)\n     }\n \n     pub fn add(&mut self, source: usize, target: usize) -> bool {\n@@ -179,7 +179,7 @@ impl BitMatrix {\n     pub fn intersection(&self, a: usize, b: usize) -> Vec<usize> {\n         let (a_start, a_end) = self.range(a);\n         let (b_start, b_end) = self.range(b);\n-        let mut result = Vec::with_capacity(self.elements);\n+        let mut result = Vec::with_capacity(self.columns);\n         for (base, (i, j)) in (a_start..a_end).zip(b_start..b_end).enumerate() {\n             let mut v = self.vector[i] & self.vector[j];\n             for bit in 0..64 {\n@@ -215,6 +215,15 @@ impl BitMatrix {\n         }\n         changed\n     }\n+\n+    pub fn iter<'a>(&'a self, row: usize) -> BitVectorIter<'a> {\n+        let (start, end) = self.range(row);\n+        BitVectorIter {\n+            iter: self.vector[start..end].iter(),\n+            current: 0,\n+            idx: 0,\n+        }\n+    }\n }\n \n fn u64s(elements: usize) -> usize {\n@@ -300,7 +309,7 @@ fn grow() {\n \n #[test]\n fn matrix_intersection() {\n-    let mut vec1 = BitMatrix::new(200);\n+    let mut vec1 = BitMatrix::new(200, 200);\n \n     // (*) Elements reachable from both 2 and 65.\n \n@@ -328,3 +337,45 @@ fn matrix_intersection() {\n     let intersection = vec1.intersection(2, 65);\n     assert_eq!(intersection, &[10, 64, 160]);\n }\n+\n+#[test]\n+fn matrix_iter() {\n+    let mut matrix = BitMatrix::new(64, 100);\n+    matrix.add(3, 22);\n+    matrix.add(3, 75);\n+    matrix.add(2, 99);\n+    matrix.add(4, 0);\n+    matrix.merge(3, 5);\n+\n+    let expected = [99];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(2) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(3) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [0];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(4) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(5) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+}"}, {"sha": "e09e260afc8d99c0e0fddc6d0c3b6a85f26deb49", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9978cbc8f42247ab75093b355b54e74b3efbcbf8/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9978cbc8f42247ab75093b355b54e74b3efbcbf8/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=9978cbc8f42247ab75093b355b54e74b3efbcbf8", "patch": "@@ -252,7 +252,8 @@ impl<T: Debug + PartialEq> TransitiveRelation<T> {\n     }\n \n     fn compute_closure(&self) -> BitMatrix {\n-        let mut matrix = BitMatrix::new(self.elements.len());\n+        let mut matrix = BitMatrix::new(self.elements.len(),\n+                                        self.elements.len());\n         let mut changed = true;\n         while changed {\n             changed = false;"}]}