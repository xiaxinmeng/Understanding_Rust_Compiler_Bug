{"sha": "7d0cc44f873ac338b400b20bcb62618aa5d36b70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMGNjNDRmODczYWMzMzhiNDAwYjIwYmNiNjI2MThhYTVkMzZiNzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-20T16:07:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-20T16:07:43Z"}, "message": "auto merge of #18070 : alexcrichton/rust/spring-cleaning, r=aturon\n\nThis is a large spring-cleaning commit now that the 0.12.0 release has passed removing an amount of deprecated functionality. This removes a number of deprecated crates (all still available as cargo packages in the rust-lang organization) as well as a slew of deprecated functions. All `#[crate_id]` support has also been removed.\r\n\r\nI tried to avoid anything that was recently deprecated, but I may have missed something! The major pain points of this commit is the fact that rustc/syntax have `#[allow(deprecated)]`, but I've removed that annotation so moving forward they should be cleaned up as we go.", "tree": {"sha": "411feaee5e6f1a35f5ddb3167d560b5422b8a473", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/411feaee5e6f1a35f5ddb3167d560b5422b8a473"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d0cc44f873ac338b400b20bcb62618aa5d36b70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d0cc44f873ac338b400b20bcb62618aa5d36b70", "html_url": "https://github.com/rust-lang/rust/commit/7d0cc44f873ac338b400b20bcb62618aa5d36b70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d0cc44f873ac338b400b20bcb62618aa5d36b70/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcbd49ff88d55f703e5a307e34e408d387a8a312", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcbd49ff88d55f703e5a307e34e408d387a8a312", "html_url": "https://github.com/rust-lang/rust/commit/dcbd49ff88d55f703e5a307e34e408d387a8a312"}, {"sha": "96445a533e8ea40701e2a9bbd25347141e63c115", "url": "https://api.github.com/repos/rust-lang/rust/commits/96445a533e8ea40701e2a9bbd25347141e63c115", "html_url": "https://github.com/rust-lang/rust/commit/96445a533e8ea40701e2a9bbd25347141e63c115"}], "stats": {"total": 14185, "additions": 1364, "deletions": 12821}, "files": [{"sha": "00c00b3d3595b87c3d4342769391bf851f9dcb61", "filename": "mk/crates.mk", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -49,11 +49,11 @@\n # automatically generated for all stage/host/target combinations.\n ################################################################################\n \n-TARGET_CRATES := libc std green native flate arena glob term semver \\\n-                 uuid serialize sync getopts collections num test time rand \\\n-                 url log regex graphviz core rbml rlibc alloc rustrt \\\n+TARGET_CRATES := libc std green native flate arena term \\\n+                 serialize sync getopts collections test time rand \\\n+                 log regex graphviz core rbml rlibc alloc rustrt \\\n                  unicode\n-HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros fmt_macros \\\n+HOST_CRATES := syntax rustc rustdoc regex_macros fmt_macros \\\n \t       rustc_llvm rustc_back\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n@@ -83,18 +83,13 @@ DEPS_glob := std\n DEPS_serialize := std log\n DEPS_rbml := std log serialize\n DEPS_term := std log\n-DEPS_semver := std\n-DEPS_uuid := std serialize\n DEPS_sync := core alloc rustrt collections\n DEPS_getopts := std\n DEPS_collections := core alloc unicode\n-DEPS_fourcc := rustc syntax std\n-DEPS_hexfloat := rustc syntax std\n DEPS_num := std\n DEPS_test := std getopts serialize rbml term time regex native:rust_test_helpers\n DEPS_time := std serialize\n DEPS_rand := core\n-DEPS_url := std\n DEPS_log := std regex\n DEPS_regex := std\n DEPS_regex_macros = rustc syntax std regex"}, {"sha": "e751084addd77d72323b52a9c857ec20d934be15", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -475,12 +475,6 @@ impl<T> DList<T> {\n         Items{nelem: self.len(), head: &self.list_head, tail: self.list_tail}\n     }\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> {\n-        self.iter_mut()\n-    }\n-\n     /// Provides a forward iterator with mutable references.\n     #[inline]\n     pub fn iter_mut<'a>(&'a mut self) -> MutItems<'a, T> {\n@@ -496,12 +490,6 @@ impl<T> DList<T> {\n         }\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> MoveItems<T> {\n-        self.into_iter()\n-    }\n-\n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n     pub fn into_iter(self) -> MoveItems<T> {\n@@ -870,7 +858,8 @@ mod tests {\n         let mut m = list_from(v.as_slice());\n         m.append(list_from(u.as_slice()));\n         check_links(&m);\n-        let sum = v.append(u.as_slice());\n+        let mut sum = v;\n+        sum.push_all(u.as_slice());\n         assert_eq!(sum.len(), m.len());\n         for elt in sum.into_iter() {\n             assert_eq!(m.pop_front(), Some(elt))"}, {"sha": "e1806dae31dbe56b7595111a23cf6cea39a32a6e", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -502,40 +502,6 @@ pub trait Deque<T> : MutableSeq<T> {\n     /// ```\n     fn push_front(&mut self, elt: T);\n \n-    /// Inserts an element last in the sequence.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```ignore\n-    /// use std::collections::{DList, Deque};\n-    ///\n-    /// let mut d = DList::new();\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n-    /// assert_eq!(d.front(), Some(&1i));\n-    /// ```\n-    #[deprecated = \"use the `push` method\"]\n-    fn push_back(&mut self, elt: T) { self.push(elt) }\n-\n-    /// Removes the last element and returns it, or `None` if the sequence is\n-    /// empty.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```ignore\n-    /// use std::collections::{RingBuf, Deque};\n-    ///\n-    /// let mut d = RingBuf::new();\n-    /// d.push_back(1i);\n-    /// d.push_back(2i);\n-    ///\n-    /// assert_eq!(d.pop_back(), Some(2i));\n-    /// assert_eq!(d.pop_back(), Some(1i));\n-    /// assert_eq!(d.pop_back(), None);\n-    /// ```\n-    #[deprecated = \"use the `pop` method\"]\n-    fn pop_back(&mut self) -> Option<T> { self.pop() }\n-\n     /// Removes the first element and returns it, or `None` if the sequence is\n     /// empty.\n     ///"}, {"sha": "16e04b93777f293be22eb9fe64b039376fd45d61", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -269,9 +269,6 @@ impl<T: Ord> PriorityQueue<T> {\n         if self.is_empty() { None } else { Some(&self.data[0]) }\n     }\n \n-    #[deprecated=\"renamed to `top`\"]\n-    pub fn maybe_top<'a>(&'a self) -> Option<&'a T> { self.top() }\n-\n     /// Returns the number of elements the queue can hold without reallocating.\n     ///\n     /// # Example\n@@ -341,9 +338,6 @@ impl<T: Ord> PriorityQueue<T> {\n         }\n     }\n \n-    #[deprecated=\"renamed to `pop`\"]\n-    pub fn maybe_pop(&mut self) -> Option<T> { self.pop() }\n-\n     /// Pushes an item onto the queue.\n     ///\n     /// # Example\n@@ -417,14 +411,6 @@ impl<T: Ord> PriorityQueue<T> {\n         }\n     }\n \n-    #[allow(dead_code)]\n-    #[deprecated=\"renamed to `into_vec`\"]\n-    fn to_vec(self) -> Vec<T> { self.into_vec() }\n-\n-    #[allow(dead_code)]\n-    #[deprecated=\"renamed to `into_sorted_vec`\"]\n-    fn to_sorted_vec(self) -> Vec<T> { self.into_sorted_vec() }\n-\n     /// Consumes the `PriorityQueue` and returns the underlying vector\n     /// in arbitrary order.\n     ///"}, {"sha": "e32e8145d172e2087edb08907062510b275da049", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 42, "deletions": 66, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -19,6 +19,7 @@ use core::cmp;\n use core::default::Default;\n use core::fmt;\n use core::iter;\n+use core::slice;\n use std::hash::{Writer, Hash};\n \n use {Deque, Mutable, MutableSeq};\n@@ -132,32 +133,6 @@ impl<T> RingBuf<T> {\n               elts: Vec::from_fn(cmp::max(MINIMUM_CAPACITY, n), |_| None)}\n     }\n \n-    /// Retrieve an element in the `RingBuf` by index.\n-    ///\n-    /// Fails if there is no element with the given index.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::collections::RingBuf;\n-    ///\n-    /// let mut buf = RingBuf::new();\n-    /// buf.push(3i);\n-    /// buf.push(4);\n-    /// buf.push(5);\n-    /// assert_eq!(buf.get(1), &4);\n-    /// ```\n-    #[deprecated = \"prefer using indexing, e.g., ringbuf[0]\"]\n-    pub fn get<'a>(&'a self, i: uint) -> &'a T {\n-        let idx = self.raw_index(i);\n-        match self.elts[idx] {\n-            None => fail!(),\n-            Some(ref v) => v\n-        }\n-    }\n-\n     /// Retrieves an element in the `RingBuf` by index.\n     ///\n     /// Fails if there is no element with the given index.\n@@ -250,12 +225,6 @@ impl<T> RingBuf<T> {\n         Items{index: 0, rindex: self.nelts, lo: self.lo, elts: self.elts.as_slice()}\n     }\n \n-    /// Deprecated: use `iter_mut`\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a, T> {\n-        self.iter_mut()\n-    }\n-\n     /// Returns a front-to-back iterator which returns mutable references.\n     ///\n     /// # Example\n@@ -285,16 +254,20 @@ impl<T> RingBuf<T> {\n             //    0 to end_index\n             let (temp, remaining1) = self.elts.split_at_mut(start_index);\n             let (remaining2, _) = temp.split_at_mut(end_index);\n-            MutItems { remaining1: remaining1,\n-                                 remaining2: remaining2,\n-                                 nelts: self.nelts }\n+            MutItems {\n+                remaining1: remaining1.iter_mut(),\n+                remaining2: remaining2.iter_mut(),\n+                nelts: self.nelts,\n+            }\n         } else {\n             // Items to iterate goes from start_index to end_index:\n             let (empty, elts) = self.elts.split_at_mut(0);\n             let remaining1 = elts[mut start_index..end_index];\n-            MutItems { remaining1: remaining1,\n-                                 remaining2: empty,\n-                                 nelts: self.nelts }\n+            MutItems {\n+                remaining1: remaining1.iter_mut(),\n+                remaining2: empty.iter_mut(),\n+                nelts: self.nelts,\n+            }\n         }\n     }\n }\n@@ -356,26 +329,26 @@ impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n \n /// `RingBuf` mutable iterator.\n pub struct MutItems<'a, T:'a> {\n-    remaining1: &'a mut [Option<T>],\n-    remaining2: &'a mut [Option<T>],\n+    remaining1: slice::MutItems<'a, Option<T>>,\n+    remaining2: slice::MutItems<'a, Option<T>>,\n     nelts: uint,\n }\n \n impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n-    #[allow(deprecated)] // mut_shift_ref\n     fn next(&mut self) -> Option<&'a mut T> {\n         if self.nelts == 0 {\n             return None;\n         }\n-        let r = if self.remaining1.len() > 0 {\n-            &mut self.remaining1\n-        } else {\n-            assert!(self.remaining2.len() > 0);\n-            &mut self.remaining2\n-        };\n         self.nelts -= 1;\n-        Some(r.mut_shift_ref().unwrap().get_mut_ref())\n+        match self.remaining1.next() {\n+            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n+            None => {}\n+        }\n+        match self.remaining2.next() {\n+            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n+            None => unreachable!(),\n+        }\n     }\n \n     #[inline]\n@@ -386,19 +359,19 @@ impl<'a, T> Iterator<&'a mut T> for MutItems<'a, T> {\n \n impl<'a, T> DoubleEndedIterator<&'a mut T> for MutItems<'a, T> {\n     #[inline]\n-    #[allow(deprecated)] // mut_shift_ref\n     fn next_back(&mut self) -> Option<&'a mut T> {\n         if self.nelts == 0 {\n             return None;\n         }\n-        let r = if self.remaining2.len() > 0 {\n-            &mut self.remaining2\n-        } else {\n-            assert!(self.remaining1.len() > 0);\n-            &mut self.remaining1\n-        };\n         self.nelts -= 1;\n-        Some(r.mut_pop_ref().unwrap().get_mut_ref())\n+        match self.remaining2.next_back() {\n+            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n+            None => {}\n+        }\n+        match self.remaining1.next_back() {\n+            Some(ptr) => return Some(ptr.as_mut().unwrap()),\n+            None => unreachable!(),\n+        }\n     }\n }\n \n@@ -484,9 +457,12 @@ impl<S: Writer, A: Hash<S>> Hash<S> for RingBuf<A> {\n \n impl<A> Index<uint, A> for RingBuf<A> {\n     #[inline]\n-    #[allow(deprecated)]\n     fn index<'a>(&'a self, i: &uint) -> &'a A {\n-        self.get(*i)\n+        let idx = self.raw_index(*i);\n+        match self.elts[idx] {\n+            None => fail!(),\n+            Some(ref v) => v,\n+        }\n     }\n }\n \n@@ -576,14 +552,14 @@ mod tests {\n         assert_eq!(d.len(), 3u);\n         d.push_front(1);\n         assert_eq!(d.len(), 4u);\n-        debug!(\"{}\", d.get(0));\n-        debug!(\"{}\", d.get(1));\n-        debug!(\"{}\", d.get(2));\n-        debug!(\"{}\", d.get(3));\n-        assert_eq!(*d.get(0), 1);\n-        assert_eq!(*d.get(1), 2);\n-        assert_eq!(*d.get(2), 3);\n-        assert_eq!(*d.get(3), 4);\n+        debug!(\"{}\", d[0]);\n+        debug!(\"{}\", d[1]);\n+        debug!(\"{}\", d[2]);\n+        debug!(\"{}\", d[3]);\n+        assert_eq!(d[0], 1);\n+        assert_eq!(d[1], 2);\n+        assert_eq!(d[2], 3);\n+        assert_eq!(d[3], 4);\n     }\n \n     #[cfg(test)]"}, {"sha": "d061e60a42265d95f97e298a2c34f377225a8897", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 34, "deletions": 207, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -270,23 +270,6 @@ impl<T: Clone> Iterator<Vec<T>> for Permutations<T> {\n pub trait CloneableVector<T> {\n     /// Copies `self` into a new `Vec`.\n     fn to_vec(&self) -> Vec<T>;\n-\n-    /// Deprecated. Use `to_vec`.\n-    #[deprecated = \"Replaced by `to_vec`\"]\n-    fn to_owned(&self) -> Vec<T> {\n-        self.to_vec()\n-    }\n-\n-    /// Converts `self` into an owned vector, not making a copy if possible.\n-    /// Deprecated. Use 'to_vec'\n-    #[deprecated = \"Replaced by `to_vec`\"]\n-    fn into_vec(self) -> Vec<T>;\n-\n-    /// Deprecated. Use `to_vec`\n-    #[deprecated = \"Replaced by `to_vec`\"]\n-    fn into_owned(self) -> Vec<T> {\n-        self.to_vec()\n-    }\n }\n \n impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n@@ -297,9 +280,6 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n         vector.push_all(*self);\n         vector\n     }\n-\n-    #[inline(always)]\n-    fn into_vec(self) -> Vec<T> { self.to_vec() }\n }\n \n #[experimental]\n@@ -920,25 +900,6 @@ mod tests {\n         a.as_mut_slice().tail_mut();\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_tailn() {\n-        let mut a = vec![11i, 12, 13];\n-        let b: &mut [int] = &mut [11, 12, 13];\n-        assert!(a.tailn(0) == b);\n-        a = vec![11i, 12, 13];\n-        let b: &mut [int] = &mut [13];\n-        assert!(a.tailn(2) == b);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[allow(deprecated)]\n-    fn test_tailn_empty() {\n-        let a: Vec<int> = vec![];\n-        a.tailn(2);\n-    }\n-\n     #[test]\n     fn test_init() {\n         let mut a = vec![11i];\n@@ -973,25 +934,6 @@ mod tests {\n         a.as_mut_slice().init_mut();\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_initn() {\n-        let mut a = vec![11i, 12, 13];\n-        let b: &[int] = &[11, 12, 13];\n-        assert_eq!(a.as_slice().initn(0), b);\n-        a = vec![11i, 12, 13];\n-        let b: &[int] = &[11];\n-        assert_eq!(a.as_slice().initn(2), b);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[allow(deprecated)]\n-    fn test_initn_empty() {\n-        let a: Vec<int> = vec![];\n-        a.as_slice().initn(2);\n-    }\n-\n     #[test]\n     fn test_last() {\n         let mut a = vec![];\n@@ -1156,20 +1098,6 @@ mod tests {\n         assert_eq!(v[2], 4u);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_grow_set() {\n-        let mut v = vec![1i, 2, 3];\n-        v.grow_set(4u, &4, 5);\n-        let v = v.as_slice();\n-        assert_eq!(v.len(), 5u);\n-        assert_eq!(v[0], 1);\n-        assert_eq!(v[1], 2);\n-        assert_eq!(v[2], 3);\n-        assert_eq!(v[3], 4);\n-        assert_eq!(v[4], 5);\n-    }\n-\n     #[test]\n     fn test_truncate() {\n         let mut v = vec![box 6i,box 5,box 4];\n@@ -1385,49 +1313,48 @@ mod tests {\n     }\n \n     #[test]\n-    #[allow(deprecated)]\n-    fn test_bsearch_elem() {\n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&5), Some(4));\n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&4), Some(3));\n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&3), Some(2));\n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&2), Some(1));\n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&1), Some(0));\n+    fn test_binary_search_elem() {\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&5).found(), Some(4));\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&4).found(), Some(3));\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&3).found(), Some(2));\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&2).found(), Some(1));\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&1).found(), Some(0));\n \n-        assert_eq!([2i,4,6,8,10].bsearch_elem(&1), None);\n-        assert_eq!([2i,4,6,8,10].bsearch_elem(&5), None);\n-        assert_eq!([2i,4,6,8,10].bsearch_elem(&4), Some(1));\n-        assert_eq!([2i,4,6,8,10].bsearch_elem(&10), Some(4));\n+        assert_eq!([2i,4,6,8,10].binary_search_elem(&1).found(), None);\n+        assert_eq!([2i,4,6,8,10].binary_search_elem(&5).found(), None);\n+        assert_eq!([2i,4,6,8,10].binary_search_elem(&4).found(), Some(1));\n+        assert_eq!([2i,4,6,8,10].binary_search_elem(&10).found(), Some(4));\n \n-        assert_eq!([2i,4,6,8].bsearch_elem(&1), None);\n-        assert_eq!([2i,4,6,8].bsearch_elem(&5), None);\n-        assert_eq!([2i,4,6,8].bsearch_elem(&4), Some(1));\n-        assert_eq!([2i,4,6,8].bsearch_elem(&8), Some(3));\n+        assert_eq!([2i,4,6,8].binary_search_elem(&1).found(), None);\n+        assert_eq!([2i,4,6,8].binary_search_elem(&5).found(), None);\n+        assert_eq!([2i,4,6,8].binary_search_elem(&4).found(), Some(1));\n+        assert_eq!([2i,4,6,8].binary_search_elem(&8).found(), Some(3));\n \n-        assert_eq!([2i,4,6].bsearch_elem(&1), None);\n-        assert_eq!([2i,4,6].bsearch_elem(&5), None);\n-        assert_eq!([2i,4,6].bsearch_elem(&4), Some(1));\n-        assert_eq!([2i,4,6].bsearch_elem(&6), Some(2));\n+        assert_eq!([2i,4,6].binary_search_elem(&1).found(), None);\n+        assert_eq!([2i,4,6].binary_search_elem(&5).found(), None);\n+        assert_eq!([2i,4,6].binary_search_elem(&4).found(), Some(1));\n+        assert_eq!([2i,4,6].binary_search_elem(&6).found(), Some(2));\n \n-        assert_eq!([2i,4].bsearch_elem(&1), None);\n-        assert_eq!([2i,4].bsearch_elem(&5), None);\n-        assert_eq!([2i,4].bsearch_elem(&2), Some(0));\n-        assert_eq!([2i,4].bsearch_elem(&4), Some(1));\n+        assert_eq!([2i,4].binary_search_elem(&1).found(), None);\n+        assert_eq!([2i,4].binary_search_elem(&5).found(), None);\n+        assert_eq!([2i,4].binary_search_elem(&2).found(), Some(0));\n+        assert_eq!([2i,4].binary_search_elem(&4).found(), Some(1));\n \n-        assert_eq!([2i].bsearch_elem(&1), None);\n-        assert_eq!([2i].bsearch_elem(&5), None);\n-        assert_eq!([2i].bsearch_elem(&2), Some(0));\n+        assert_eq!([2i].binary_search_elem(&1).found(), None);\n+        assert_eq!([2i].binary_search_elem(&5).found(), None);\n+        assert_eq!([2i].binary_search_elem(&2).found(), Some(0));\n \n-        assert_eq!([].bsearch_elem(&1i), None);\n-        assert_eq!([].bsearch_elem(&5i), None);\n+        assert_eq!([].binary_search_elem(&1i).found(), None);\n+        assert_eq!([].binary_search_elem(&5i).found(), None);\n \n-        assert!([1i,1,1,1,1].bsearch_elem(&1) != None);\n-        assert!([1i,1,1,1,2].bsearch_elem(&1) != None);\n-        assert!([1i,1,1,2,2].bsearch_elem(&1) != None);\n-        assert!([1i,1,2,2,2].bsearch_elem(&1) != None);\n-        assert_eq!([1i,2,2,2,2].bsearch_elem(&1), Some(0));\n+        assert!([1i,1,1,1,1].binary_search_elem(&1).found() != None);\n+        assert!([1i,1,1,1,2].binary_search_elem(&1).found() != None);\n+        assert!([1i,1,1,2,2].binary_search_elem(&1).found() != None);\n+        assert!([1i,1,2,2,2].binary_search_elem(&1).found() != None);\n+        assert_eq!([1i,2,2,2,2].binary_search_elem(&1).found(), Some(0));\n \n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&6), None);\n-        assert_eq!([1i,2,3,4,5].bsearch_elem(&0), None);\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&6).found(), None);\n+        assert_eq!([1i,2,3,4,5].binary_search_elem(&0).found(), None);\n     }\n \n     #[test]\n@@ -1544,26 +1471,6 @@ mod tests {\n         assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 0, 3]);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_shift() {\n-        let mut x = vec![1i, 2, 3];\n-        assert_eq!(x.shift(), Some(1));\n-        assert_eq!(&x, &vec![2i, 3]);\n-        assert_eq!(x.shift(), Some(2));\n-        assert_eq!(x.shift(), Some(3));\n-        assert_eq!(x.shift(), None);\n-        assert_eq!(x.len(), 0);\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_unshift() {\n-        let mut x = vec![1i, 2, 3];\n-        x.unshift(0);\n-        assert_eq!(x, vec![0, 1, 2, 3]);\n-    }\n-\n     #[test]\n     fn test_insert() {\n         let mut a = vec![1i, 2, 4];\n@@ -1689,17 +1596,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    #[should_fail]\n-    #[allow(deprecated)]\n-    fn test_copy_memory_oob() {\n-        unsafe {\n-            let mut a = [1i, 2, 3, 4];\n-            let b = [1i, 2, 3, 4, 5];\n-            a.copy_memory(b);\n-        }\n-    }\n-\n     #[test]\n     fn test_total_ord() {\n         let c: &[int] = &[1, 2, 3];\n@@ -2005,19 +1901,6 @@ mod tests {\n         assert!(a == [1i,2,6,7,5]);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_copy_from() {\n-        let mut a = [1i,2,3,4,5];\n-        let b = [6i,7,8];\n-        assert_eq!(a.copy_from(b), 3);\n-        assert!(a == [6i,7,8,4,5]);\n-        let mut c = [7i,2,8,1];\n-        let d = [3i,1,4,1,5,9];\n-        assert_eq!(c.copy_from(d), 4);\n-        assert!(c == [3i,1,4,1]);\n-    }\n-\n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1i,2,3,4,5];\n@@ -2198,34 +2081,6 @@ mod tests {\n         assert!(b\"foobar\".ends_with(empty));\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_shift_ref() {\n-        let mut x: &[int] = [1, 2, 3, 4, 5];\n-        let h = x.shift_ref();\n-        assert_eq!(*h.unwrap(), 1);\n-        assert_eq!(x.len(), 4);\n-        assert_eq!(x[0], 2);\n-        assert_eq!(x[3], 5);\n-\n-        let mut y: &[int] = [];\n-        assert_eq!(y.shift_ref(), None);\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_pop_ref() {\n-        let mut x: &[int] = [1, 2, 3, 4, 5];\n-        let h = x.pop_ref();\n-        assert_eq!(*h.unwrap(), 5);\n-        assert_eq!(x.len(), 4);\n-        assert_eq!(x[0], 1);\n-        assert_eq!(x[3], 4);\n-\n-        let mut y: &[int] = [];\n-        assert!(y.pop_ref().is_none());\n-    }\n-\n     #[test]\n     fn test_mut_splitator() {\n         let mut xs = [0i,1,0,2,3,0,0,4,5,0];\n@@ -2292,34 +2147,6 @@ mod tests {\n         let _it = v.chunks_mut(0);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_mut_shift_ref() {\n-        let mut x: &mut [int] = [1, 2, 3, 4, 5];\n-        let h = x.mut_shift_ref();\n-        assert_eq!(*h.unwrap(), 1);\n-        assert_eq!(x.len(), 4);\n-        assert_eq!(x[0], 2);\n-        assert_eq!(x[3], 5);\n-\n-        let mut y: &mut [int] = [];\n-        assert!(y.mut_shift_ref().is_none());\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_mut_pop_ref() {\n-        let mut x: &mut [int] = [1, 2, 3, 4, 5];\n-        let h = x.mut_pop_ref();\n-        assert_eq!(*h.unwrap(), 5);\n-        assert_eq!(x.len(), 4);\n-        assert_eq!(x[0], 1);\n-        assert_eq!(x[3], 4);\n-\n-        let mut y: &mut [int] = [];\n-        assert!(y.mut_pop_ref().is_none());\n-    }\n-\n     #[test]\n     fn test_mut_last() {\n         let mut x = [1i, 2, 3, 4, 5];"}, {"sha": "498f86a8bf1e41e493c9679ec9d6c42f314c1579", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -199,29 +199,6 @@ impl<V> SmallIntMap<V> {\n         SmallIntMap { v: Vec::with_capacity(capacity) }\n     }\n \n-    /// Retrieves a value for the given key.\n-    /// See [`find`](../trait.Map.html#tymethod.find) for a non-failing alternative.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the key is not present.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::collections::SmallIntMap;\n-    ///\n-    /// let mut map = SmallIntMap::new();\n-    /// map.insert(1, \"a\");\n-    /// assert_eq!(map.get(&1), &\"a\");\n-    /// ```\n-    #[deprecated = \"prefer using indexing, e.g., map[0]\"]\n-    pub fn get<'a>(&'a self, key: &uint) -> &'a V {\n-        self.find(key).expect(\"key not present\")\n-    }\n-\n     /// Returns an iterator visiting all keys in ascending order by the keys.\n     /// The iterator's element type is `uint`.\n     pub fn keys<'r>(&'r self) -> Keys<'r, V> {\n@@ -260,12 +237,6 @@ impl<V> SmallIntMap<V> {\n         }\n     }\n \n-    /// Deprecated: use `iter_mut`\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'r>(&'r mut self) -> MutEntries<'r, V> {\n-        self.iter_mut()\n-    }\n-\n     /// Returns an iterator visiting all key-value pairs in ascending order by the keys,\n     /// with mutable references to the values.\n     /// The iterator's element type is `(uint, &'r mut V)`.\n@@ -296,14 +267,6 @@ impl<V> SmallIntMap<V> {\n         }\n     }\n \n-    /// Deprecated: use `into_iter` instead.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(&mut self)\n-        -> FilterMap<(uint, Option<V>), (uint, V),\n-                Enumerate<vec::MoveItems<Option<V>>>> {\n-        self.into_iter()\n-    }\n-\n     /// Returns an iterator visiting all key-value pairs in ascending order by\n     /// the keys, emptying (but not consuming) the original `SmallIntMap`.\n     /// The iterator's element type is `(uint, &'r V)`.\n@@ -437,9 +400,8 @@ impl<V> Extendable<(uint, V)> for SmallIntMap<V> {\n \n impl<V> Index<uint, V> for SmallIntMap<V> {\n     #[inline]\n-    #[allow(deprecated)]\n     fn index<'a>(&'a self, i: &uint) -> &'a V {\n-        self.get(i)\n+        self.find(i).expect(\"key not present\")\n     }\n }\n "}, {"sha": "901f8add73c1aee5acb6cbe06e2bc370528b3e7e", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -58,7 +58,6 @@ use core::default::Default;\n use core::fmt;\n use core::cmp;\n use core::iter::AdditiveIterator;\n-use core::mem;\n use core::prelude::{Char, Clone, Collection, Eq, Equiv, ImmutableSlice};\n use core::prelude::{Iterator, MutableSlice, None, Option, Ord, Ordering};\n use core::prelude::{PartialEq, PartialOrd, Result, AsSlice, Some, Tuple2};\n@@ -67,7 +66,6 @@ use core::prelude::{range};\n use {Deque, MutableSeq};\n use hash;\n use ringbuf::RingBuf;\n-use slice::CloneableVector;\n use string::String;\n use unicode;\n use vec::Vec;\n@@ -85,31 +83,6 @@ pub use unicode::str::{UnicodeStrSlice, Words, Graphemes, GraphemeIndices};\n Section: Creating a string\n */\n \n-/// Deprecated. Replaced by `String::from_utf8`.\n-#[deprecated = \"Replaced by `String::from_utf8`\"]\n-pub fn from_utf8_owned(vv: Vec<u8>) -> Result<String, Vec<u8>> {\n-    String::from_utf8(vv)\n-}\n-\n-/// Deprecated. Replaced by `String::from_byte`.\n-#[deprecated = \"Replaced by String::from_byte\"]\n-pub fn from_byte(b: u8) -> String {\n-    assert!(b < 128u8);\n-    String::from_char(1, b as char)\n-}\n-\n-/// Deprecated. Use `String::from_char` or `char::to_string()` instead.\n-#[deprecated = \"use String::from_char or char.to_string()\"]\n-pub fn from_char(ch: char) -> String {\n-    String::from_char(1, ch)\n-}\n-\n-/// Deprecated. Replaced by `String::from_chars`.\n-#[deprecated = \"use String::from_chars instead\"]\n-pub fn from_chars(chs: &[char]) -> String {\n-    chs.iter().map(|c| *c).collect()\n-}\n-\n /// Methods for vectors of strings.\n pub trait StrVector {\n     /// Concatenates a vector of strings.\n@@ -427,18 +400,6 @@ pub fn replace(s: &str, from: &str, to: &str) -> String {\n Section: Misc\n */\n \n-/// Deprecated. Use `String::from_utf16`.\n-#[deprecated = \"Replaced by String::from_utf16\"]\n-pub fn from_utf16(v: &[u16]) -> Option<String> {\n-    String::from_utf16(v)\n-}\n-\n-/// Deprecated. Use `String::from_utf16_lossy`.\n-#[deprecated = \"Replaced by String::from_utf16_lossy\"]\n-pub fn from_utf16_lossy(v: &[u16]) -> String {\n-    String::from_utf16_lossy(v)\n-}\n-\n // Return the initial codepoint accumulator for the first byte.\n // The first byte is special, only want bottom 5 bits for width 2, 4 bits\n // for width 3, and 3 bits for width 4\n@@ -451,12 +412,6 @@ macro_rules! utf8_acc_cont_byte(\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n )\n \n-/// Deprecated. Use `String::from_utf8_lossy`.\n-#[deprecated = \"Replaced by String::from_utf8_lossy\"]\n-pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n-    String::from_utf8_lossy(v)\n-}\n-\n /*\n Section: MaybeOwned\n */\n@@ -644,38 +599,8 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n \n /// Unsafe string operations.\n pub mod raw {\n-    use string;\n-    use string::String;\n-    use vec::Vec;\n-\n-    use MutableSeq;\n-\n     pub use core::str::raw::{from_utf8, c_str_to_static_slice, slice_bytes};\n     pub use core::str::raw::{slice_unchecked};\n-\n-    /// Deprecated. Replaced by `string::raw::from_buf_len`\n-    #[deprecated = \"Use string::raw::from_buf_len\"]\n-    pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> String {\n-        string::raw::from_buf_len(buf, len)\n-    }\n-\n-    /// Deprecated. Use `string::raw::from_buf`\n-    #[deprecated = \"Use string::raw::from_buf\"]\n-    pub unsafe fn from_c_str(c_string: *const i8) -> String {\n-        string::raw::from_buf(c_string as *const u8)\n-    }\n-\n-    /// Deprecated. Replaced by `string::raw::from_utf8`\n-    #[deprecated = \"Use string::raw::from_utf8\"]\n-    pub unsafe fn from_utf8_owned(v: Vec<u8>) -> String {\n-        string::raw::from_utf8(v)\n-    }\n-\n-    /// Deprecated. Use `string::raw::from_utf8`\n-    #[deprecated = \"Use string::raw::from_utf8\"]\n-    pub unsafe fn from_byte(u: u8) -> String {\n-        string::raw::from_utf8(vec![u])\n-    }\n }\n \n /*\n@@ -687,12 +612,6 @@ pub trait StrAllocating: Str {\n     /// Converts `self` into a `String`, not making a copy if possible.\n     fn into_string(self) -> String;\n \n-    #[allow(missing_doc)]\n-    #[deprecated = \"replaced by .into_string()\"]\n-    fn into_owned(self) -> String {\n-        self.into_string()\n-    }\n-\n     /// Escapes each char in `s` with `char::escape_default`.\n     fn escape_default(&self) -> String {\n         let me = self.as_slice();\n@@ -750,21 +669,6 @@ pub trait StrAllocating: Str {\n         result\n     }\n \n-    #[allow(missing_doc)]\n-    #[deprecated = \"obsolete, use `to_string`\"]\n-    #[inline]\n-    fn to_owned(&self) -> String {\n-        unsafe {\n-            mem::transmute(self.as_slice().as_bytes().to_vec())\n-        }\n-    }\n-\n-    /// Converts to a vector of `u16` encoded as UTF-16.\n-    #[deprecated = \"use `utf16_units` instead\"]\n-    fn to_utf16(&self) -> Vec<u16> {\n-        self.as_slice().utf16_units().collect::<Vec<u16>>()\n-    }\n-\n     /// Given a string, makes a new string with repeated copies of it.\n     fn repeat(&self, nn: uint) -> String {\n         let me = self.as_slice();"}, {"sha": "fa45dee7cdea7c2756b692add3cf3ef9d5d59ec9", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 218, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -84,20 +84,6 @@ impl String {\n         String { vec: string.as_bytes().to_vec() }\n     }\n \n-    /// Deprecated. Replaced by `string::raw::from_parts`\n-    #[inline]\n-    #[deprecated = \"Replaced by string::raw::from_parts\"]\n-    pub unsafe fn from_raw_parts(length: uint, capacity: uint, ptr: *mut u8) -> String {\n-        raw::from_parts(ptr, length, capacity)\n-    }\n-\n-    /// Deprecated.\n-    #[deprecated = \"obsoleted by the removal of ~str\"]\n-    #[inline]\n-    pub fn from_owned_str(string: String) -> String {\n-        string\n-    }\n-\n     /// Returns the vector as a string buffer, if possible, taking care not to\n     /// copy it.\n     ///\n@@ -327,26 +313,6 @@ impl String {\n         self.vec\n     }\n \n-    /// Pushes the given `String` onto this buffer then returns `self` so that it can be\n-    /// used again.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let s = String::from_str(\"hello\");\n-    /// let big = s.append(\" \").append(\"world\").append(\"!\");\n-    /// // s has now been moved and cannot be used\n-    ///\n-    /// assert_eq!(big.as_slice(), \"hello world!\");\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use .push_str() instead\"]\n-    pub fn append(mut self, second: &str) -> String {\n-        self.push_str(second);\n-        self\n-    }\n-\n     /// Creates a string buffer by repeating a character `length` times.\n     ///\n     /// # Example\n@@ -373,25 +339,6 @@ impl String {\n         buf\n     }\n \n-    /// Converts a byte to a UTF-8 string.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails with invalid UTF-8 (i.e., the byte is greater than 127).\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// # #![allow(deprecated)]\n-    /// let s = String::from_byte(104);\n-    /// assert_eq!(s.as_slice(), \"h\");\n-    /// ```\n-    #[deprecated = \"use str::from_utf8 with a slice of one byte instead\"]\n-    pub fn from_byte(b: u8) -> String {\n-        assert!(b < 128u8);\n-        String::from_char(1, b as char)\n-    }\n-\n     /// Pushes the given string onto this string buffer.\n     ///\n     /// # Example\n@@ -424,21 +371,6 @@ impl String {\n         }\n     }\n \n-    /// Returns the number of bytes that this string buffer can hold without reallocating.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let s = String::with_capacity(10);\n-    /// assert!(s.byte_capacity() >= 10);\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"renamed to .capacity()\"]\n-    pub fn byte_capacity(&self) -> uint {\n-        self.vec.capacity()\n-    }\n-\n     /// Returns the number of bytes that this string buffer can hold without reallocating.\n     ///\n     /// # Example\n@@ -512,13 +444,6 @@ impl String {\n         self.vec.shrink_to_fit()\n     }\n \n-    /// Deprecated, use .push() instead.\n-    #[inline]\n-    #[deprecated = \"renamed to .push()\"]\n-    pub fn push_char(&mut self, ch: char) {\n-        self.push(ch)\n-    }\n-\n     /// Adds the given character to the end of the string.\n     ///\n     /// # Example\n@@ -549,26 +474,6 @@ impl String {\n         }\n     }\n \n-    /// Pushes the given bytes onto this string buffer.\n-    /// This is unsafe because it does not check\n-    /// to ensure that the resulting string will be valid UTF-8.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut s = String::new();\n-    /// unsafe {\n-    ///     s.push_bytes([104, 101, 108, 108, 111]);\n-    /// }\n-    /// assert_eq!(s.as_slice(), \"hello\");\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"call .as_mut_vec() and push onto that\"]\n-    pub unsafe fn push_bytes(&mut self, bytes: &[u8]) {\n-        self.vec.push_all(bytes)\n-    }\n-\n     /// Works with the underlying buffer as a byte slice.\n     ///\n     /// # Example\n@@ -584,31 +489,6 @@ impl String {\n         self.vec.as_slice()\n     }\n \n-    /// Works with the underlying buffer as a mutable byte slice.\n-    ///\n-    /// This is unsafe because it does not check\n-    /// to ensure that the resulting string will be valid UTF-8.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut s = String::from_str(\"hello\");\n-    /// unsafe {\n-    ///     let bytes = s.as_mut_bytes();\n-    ///     bytes[1] = 51;\n-    ///     bytes[4] = 48;\n-    /// }\n-    /// let b: &[_] = &[104, 51, 108, 108, 48];\n-    /// assert_eq!(s.as_bytes(), b);\n-    /// assert_eq!(s.as_slice(), \"h3ll0\")\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"call .as_mut_vec().as_mut_slice() instead\"]\n-    pub unsafe fn as_mut_bytes<'a>(&'a mut self) -> &'a mut [u8] {\n-        self.vec.as_mut_slice()\n-    }\n-\n     /// Shortens a string to the specified length.\n     ///\n     /// # Failure\n@@ -630,63 +510,6 @@ impl String {\n         self.vec.truncate(new_len)\n     }\n \n-    /// Appends a byte to this string buffer.\n-    ///\n-    /// This is unsafe because it does not check\n-    /// to ensure that the resulting string will be valid UTF-8.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut s = String::from_str(\"hell\");\n-    /// unsafe {\n-    ///     s.push_byte(111);\n-    /// }\n-    /// assert_eq!(s.as_slice(), \"hello\");\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"call .as_mut_vec().push() instead\"]\n-    pub unsafe fn push_byte(&mut self, byte: u8) {\n-        self.vec.push(byte)\n-    }\n-\n-    /// Removes the last byte from the string buffer and returns it.\n-    /// Returns `None` if this string buffer is empty.\n-    ///\n-    /// This is unsafe because it does not check\n-    /// to ensure that the resulting string will be valid UTF-8.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut s = String::from_str(\"foo\");\n-    /// unsafe {\n-    ///     assert_eq!(s.pop_byte(), Some(111));\n-    ///     assert_eq!(s.pop_byte(), Some(111));\n-    ///     assert_eq!(s.pop_byte(), Some(102));\n-    ///     assert_eq!(s.pop_byte(), None);\n-    /// }\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"call .as_mut_vec().pop() instead\"]\n-    pub unsafe fn pop_byte(&mut self) -> Option<u8> {\n-        let len = self.len();\n-        if len == 0 {\n-            return None\n-        }\n-\n-        let byte = self.as_bytes()[len - 1];\n-        self.vec.set_len(len - 1);\n-        Some(byte)\n-    }\n-\n-    /// Deprecated. Renamed to `pop`.\n-    #[inline]\n-    #[deprecated = \"renamed to .pop()\"]\n-    pub fn pop_char(&mut self) -> Option<char> { self.pop() }\n-\n     /// Removes the last character from the string buffer and returns it.\n     /// Returns `None` if this string buffer is empty.\n     ///\n@@ -714,35 +537,6 @@ impl String {\n         Some(ch)\n     }\n \n-    /// Removes the first byte from the string buffer and returns it.\n-    /// Returns `None` if this string buffer is empty.\n-    ///\n-    /// This is unsafe because it does not check\n-    /// to ensure that the resulting string will be valid UTF-8.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut s = String::from_str(\"foo\");\n-    /// unsafe {\n-    ///     assert_eq!(s.shift_byte(), Some(102));\n-    ///     assert_eq!(s.shift_byte(), Some(111));\n-    ///     assert_eq!(s.shift_byte(), Some(111));\n-    ///     assert_eq!(s.shift_byte(), None);\n-    /// }\n-    /// ```\n-    #[deprecated = \"call .as_mut_vec().remove(0)\"]\n-    pub unsafe fn shift_byte(&mut self) -> Option<u8> {\n-        self.vec.remove(0)\n-    }\n-\n-    /// Deprecated, call `remove(0)` instead\n-    #[deprecated = \"call .remove(0) instead\"]\n-    pub fn shift_char(&mut self) -> Option<char> {\n-        self.remove(0)\n-    }\n-\n     /// Removes the character from the string buffer at byte position `idx` and\n     /// returns it. Returns `None` if `idx` is out of bounds.\n     ///\n@@ -1251,18 +1045,6 @@ mod tests {\n         assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n     }\n \n-    #[test]\n-    #[allow(deprecated)] // use remove(0) instead\n-    fn test_shift_char() {\n-        let mut data = String::from_str(\"\ud852\udf62\u20ac\u00a2b\u534e\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n-        assert_eq!(data.shift_char().unwrap(), '\ud852\udf62'); // 4 bytes\n-        assert_eq!(data.shift_char().unwrap(), '\u20ac'); // 3 bytes\n-        assert_eq!(data.shift_char().unwrap(), '\u00a2'); // 2 bytes\n-        assert_eq!(data.shift_char().unwrap(), 'b'); // 1 bytes\n-        assert_eq!(data.shift_char().unwrap(), '\u534e');\n-        assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n-    }\n-\n     #[test]\n     fn test_str_truncate() {\n         let mut s = String::from_str(\"12345\");"}, {"sha": "39362bf1fdc0090ef2142277a3b64d3c6fb7532a", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -361,12 +361,6 @@ impl<K: Ord, V> TreeMap<K, V> {\n         RevEntries{iter: self.iter()}\n     }\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n-        self.iter_mut()\n-    }\n-\n     /// Gets a lazy forward iterator over the key-value pairs in the\n     /// map, with the values being mutable.\n     ///\n@@ -398,12 +392,6 @@ impl<K: Ord, V> TreeMap<K, V> {\n         }\n     }\n \n-    /// Deprecated: use `rev_iter_mut`.\n-    #[deprecated = \"use rev_iter_mut\"]\n-    pub fn mut_rev_iter<'a>(&'a mut self) -> RevMutEntries<'a, K, V> {\n-        self.rev_iter_mut()\n-    }\n-\n     /// Gets a lazy reverse iterator over the key-value pairs in the\n     /// map, with the values being mutable.\n     ///\n@@ -430,12 +418,6 @@ impl<K: Ord, V> TreeMap<K, V> {\n         RevMutEntries{iter: self.iter_mut()}\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> MoveEntries<K, V> {\n-        self.into_iter()\n-    }\n-\n     /// Gets a lazy iterator that consumes the treemap.\n     ///\n     /// # Example\n@@ -494,12 +476,6 @@ impl<K, V> TreeMap<K, V> {\n         tree_find_with(&self.root, f)\n     }\n \n-    /// Deprecated: use `find_with_mut`.\n-    #[deprecated = \"use find_with_mut\"]\n-    pub fn find_mut_with<'a>(&'a mut self, f:|&K| -> Ordering) -> Option<&'a mut V> {\n-        self.find_with_mut(f)\n-    }\n-\n     /// Returns the value for which `f(key)` returns `Equal`. `f` is invoked\n     /// with current key and guides tree navigation. That means `f` should\n     /// be aware of natural ordering of the tree.\n@@ -626,12 +602,6 @@ impl<K: Ord, V> TreeMap<K, V> {\n         }\n     }\n \n-    /// Deprecated: use `lower_bound_mut`.\n-    #[deprecated = \"use lower_bound_mut\"]\n-    pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n-        self.lower_bound_mut(k)\n-    }\n-\n     /// Returns a lazy value iterator to the first key-value pair (with\n     /// the value being mutable) whose key is not less than `k`.\n     ///\n@@ -666,12 +636,6 @@ impl<K: Ord, V> TreeMap<K, V> {\n         bound_setup!(self.iter_mut_for_traversal(), k, true)\n     }\n \n-    /// Deprecated: use `upper_bound_mut`.\n-    #[deprecated = \"use upper_bound_mut\"]\n-    pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n-        self.upper_bound_mut(k)\n-    }\n-\n     /// Returns a lazy iterator to the first key-value pair (with the\n     /// value being mutable) whose key is greater than `k`.\n     ///\n@@ -1204,12 +1168,6 @@ impl<T: Ord> TreeSet<T> {\n         RevSetItems{iter: self.map.rev_iter()}\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> MoveSetItems<T> {\n-        self.into_iter()\n-    }\n-\n     /// Creates a consuming iterator, that is, one that moves each value out of the\n     /// set in ascending order. The set cannot be used after calling this.\n     ///"}, {"sha": "1b5c5dbc0a20bab1cc080dd369a8fabbcb4d2361", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -268,12 +268,6 @@ impl<T> TrieMap<T> {\n         iter\n     }\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, T> {\n-        self.iter_mut()\n-    }\n-\n     /// Gets an iterator over the key-value pairs in the map, with the\n     /// ability to mutate the values.\n     ///\n@@ -439,12 +433,6 @@ impl<T> TrieMap<T> {\n                mutability = mut)\n     }\n \n-    /// Deprecated: use `lower_bound_mut`.\n-    #[deprecated = \"use lower_bound_mut\"]\n-    pub fn mut_lower_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n-        self.lower_bound_mut(key)\n-    }\n-\n     /// Gets an iterator pointing to the first key-value pair whose key is not less than `key`.\n     /// If all keys in the map are less than `key` an empty iterator is returned.\n     ///\n@@ -470,12 +458,6 @@ impl<T> TrieMap<T> {\n         self.bound_mut(key, false)\n     }\n \n-    /// Deprecated: use `upper_bound_mut`.\n-    #[deprecated = \"use upper_bound_mut\"]\n-    pub fn mut_upper_bound<'a>(&'a mut self, key: uint) -> MutEntries<'a, T> {\n-        self.upper_bound_mut(key)\n-    }\n-\n     /// Gets an iterator pointing to the first key-value pair whose key is greater than `key`.\n     /// If all keys in the map are not greater than `key` an empty iterator is returned.\n     ///"}, {"sha": "e608a7d22dcf5e8a8fe33bf3fbf969974157ae93", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 9, "deletions": 191, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -275,19 +275,6 @@ impl<T> Vec<T> {\n }\n \n impl<T: Clone> Vec<T> {\n-    /// Deprecated, call `extend` instead.\n-    #[inline]\n-    #[deprecated = \"this function has been deprecated in favor of extend()\"]\n-    pub fn append(mut self, second: &[T]) -> Vec<T> {\n-        self.push_all(second);\n-        self\n-    }\n-\n-    /// Deprecated, call `to_vec()` instead\n-    #[inline]\n-    #[deprecated = \"this function has been deprecated in favor of to_vec()\"]\n-    pub fn from_slice(values: &[T]) -> Vec<T> { values.to_vec() }\n-\n     /// Constructs a `Vec` with copies of a value.\n     ///\n     /// Creates a `Vec` with `length` copies of `value`.\n@@ -366,31 +353,6 @@ impl<T: Clone> Vec<T> {\n         }\n     }\n \n-    /// Sets the value of a vector element at a given index, growing the vector\n-    /// as needed.\n-    ///\n-    /// Sets the element at position `index` to `value`. If `index` is past the\n-    /// end of the vector, expands the vector by replicating `initval` to fill\n-    /// the intervening space.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut vec = vec![\"a\", \"b\", \"c\"];\n-    /// vec.grow_set(1, &(\"fill\"), \"d\");\n-    /// vec.grow_set(4, &(\"fill\"), \"e\");\n-    /// assert_eq!(vec, vec![\"a\", \"d\", \"c\", \"fill\", \"e\"]);\n-    /// ```\n-    #[deprecated = \"call .grow() and .push() manually instead\"]\n-    pub fn grow_set(&mut self, index: uint, initval: &T, value: T) {\n-        let l = self.len();\n-        if index >= l {\n-            self.grow(index - l + 1u, initval.clone());\n-        }\n-        *self.get_mut(index) = value;\n-    }\n-\n     /// Partitions a vector based on a predicate.\n     ///\n     /// Clones the elements of the vector, partitioning them into two `Vec`s\n@@ -447,9 +409,8 @@ impl<T:Clone> Clone for Vec<T> {\n #[experimental = \"waiting on Index stability\"]\n impl<T> Index<uint,T> for Vec<T> {\n     #[inline]\n-    #[allow(deprecated)] // allow use of get\n     fn index<'a>(&'a self, index: &uint) -> &'a T {\n-        self.get(*index)\n+        &self.as_slice()[*index]\n     }\n }\n \n@@ -721,14 +682,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Deprecated, call `push` instead\n-    #[inline]\n-    #[deprecated = \"call .push() instead\"]\n-    pub fn append_one(mut self, x: T) -> Vec<T> {\n-        self.push(x);\n-        self\n-    }\n-\n     /// Shorten a vector, dropping excess elements.\n     ///\n     /// If `len` is greater than the vector's current length, this has no\n@@ -754,6 +707,14 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Deprecated, use `.extend(other.into_iter())`\n+    #[inline]\n+    #[deprecated = \"use .extend(other.into_iter())\"]\n+    #[cfg(stage0)]\n+    pub fn push_all_move(&mut self, other: Vec<T>) {\n+            self.extend(other.into_iter());\n+    }\n+\n     /// Returns a mutable slice of the elements of `self`.\n     ///\n     /// # Example\n@@ -775,12 +736,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> MoveItems<T> {\n-        self.into_iter()\n-    }\n-\n     /// Creates a consuming iterator, that is, one that moves each\n     /// value out of the vector (from start to end). The vector cannot\n     /// be used after calling this.\n@@ -830,26 +785,6 @@ impl<T> Vec<T> {\n         self.len = len;\n     }\n \n-    /// Returns a reference to the value at index `index`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if `index` is out of bounds\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    ///\n-    /// let vec = vec![1i, 2, 3];\n-    /// assert!(vec.get(1) == &2);\n-    /// ```\n-    #[deprecated=\"prefer using indexing, e.g., vec[0]\"]\n-    #[inline]\n-    pub fn get<'a>(&'a self, index: uint) -> &'a T {\n-        &self.as_slice()[index]\n-    }\n-\n     /// Returns a mutable reference to the value at index `index`.\n     ///\n     /// # Failure\n@@ -885,12 +820,6 @@ impl<T> Vec<T> {\n         self.as_slice().iter()\n     }\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'a>(&'a mut self) -> MutItems<'a,T> {\n-        self.iter_mut()\n-    }\n-\n     /// Returns an iterator over mutable references to the elements of the\n     /// vector in order.\n     ///\n@@ -963,25 +892,6 @@ impl<T> Vec<T> {\n         self[].tail()\n     }\n \n-    /// Returns all but the first `n' elements of a vector.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails when there are fewer than `n` elements in the vector.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    /// let vec = vec![1i, 2, 3, 4];\n-    /// assert!(vec.tailn(2) == [3, 4]);\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use slice_from\"]\n-    pub fn tailn<'a>(&'a self, n: uint) -> &'a [T] {\n-        self[n..]\n-    }\n-\n     /// Returns a reference to the last element of a vector, or `None` if it is\n     /// empty.\n     ///\n@@ -996,12 +906,6 @@ impl<T> Vec<T> {\n         self[].last()\n     }\n \n-    /// Deprecated: use `last_mut`.\n-    #[deprecated = \"use last_mut\"]\n-    pub fn mut_last<'a>(&'a mut self) -> Option<&'a mut T> {\n-        self.last_mut()\n-    }\n-\n     /// Returns a mutable reference to the last element of a vector, or `None`\n     /// if it is empty.\n     ///\n@@ -1047,48 +951,6 @@ impl<T> Vec<T> {\n         self.pop()\n     }\n \n-    /// Prepends an element to the vector.\n-    ///\n-    /// # Warning\n-    ///\n-    /// This is an O(n) operation as it requires copying every element in the\n-    /// vector.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```ignore\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// vec.unshift(4);\n-    /// assert_eq!(vec, vec![4, 1, 2, 3]);\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use insert(0, ...)\"]\n-    pub fn unshift(&mut self, element: T) {\n-        self.insert(0, element)\n-    }\n-\n-    /// Removes the first element from a vector and returns it, or `None` if\n-    /// the vector is empty.\n-    ///\n-    /// # Warning\n-    ///\n-    /// This is an O(n) operation as it requires copying every element in the\n-    /// vector.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    /// let mut vec = vec![1i, 2, 3];\n-    /// assert!(vec.shift() == Some(1));\n-    /// assert_eq!(vec, vec![2, 3]);\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use remove(0)\"]\n-    pub fn shift(&mut self) -> Option<T> {\n-        self.remove(0)\n-    }\n-\n     /// Inserts an element at position `index` within the vector, shifting all\n     /// elements after position `i` one position to the right.\n     ///\n@@ -1167,32 +1029,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Takes ownership of the vector `other`, moving all elements into\n-    /// the current vector. This does not copy any elements, and it is\n-    /// illegal to use the `other` vector after calling this method\n-    /// (because it is moved here).\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// let mut vec = vec![box 1i];\n-    /// vec.push_all_move(vec![box 2, box 3, box 4]);\n-    /// assert_eq!(vec, vec![box 1, box 2, box 3, box 4]);\n-    /// ```\n-    #[inline]\n-    #[deprecated = \"use .extend(other.into_iter())\"]\n-    pub fn push_all_move(&mut self, other: Vec<T>) {\n-        self.extend(other.into_iter());\n-    }\n-\n-    /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slice_mut\"]\n-    pub fn mut_slice<'a>(&'a mut self, start: uint, end: uint)\n-                         -> &'a mut [T] {\n-        self[mut start..end]\n-    }\n-\n     /// Returns a mutable slice of `self` between `start` and `end`.\n     ///\n     /// # Failure\n@@ -1212,12 +1048,6 @@ impl<T> Vec<T> {\n         self[mut start..end]\n     }\n \n-    /// Deprecated: use \"slice_from_mut\".\n-    #[deprecated = \"use slice_from_mut\"]\n-    pub fn mut_slice_from<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        self[mut start..]\n-    }\n-\n     /// Returns a mutable slice of `self` from `start` to the end of the `Vec`.\n     ///\n     /// # Failure\n@@ -1235,12 +1065,6 @@ impl<T> Vec<T> {\n         self[mut start..]\n     }\n \n-    /// Deprecated: use `slice_to_mut`.\n-    #[deprecated = \"use slice_to_mut\"]\n-    pub fn mut_slice_to<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        self[mut ..end]\n-    }\n-\n     /// Returns a mutable slice of `self` from the start of the `Vec` to `end`.\n     ///\n     /// # Failure\n@@ -1258,12 +1082,6 @@ impl<T> Vec<T> {\n         self[mut ..end]\n     }\n \n-    /// Deprecated: use `split_at_mut`.\n-    #[deprecated = \"use split_at_mut\"]\n-    pub fn mut_split_at<'a>(&'a mut self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        self.split_at_mut(mid)\n-    }\n-\n     /// Returns a pair of mutable slices that divides the `Vec` at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding"}, {"sha": "021f575b0aceaa4deef2e8c3749ce901a19c0c7b", "filename": "src/libcore/any.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -76,11 +76,6 @@ use option::{Option, Some, None};\n use raw::TraitObject;\n use intrinsics::TypeId;\n \n-/// A type with no inhabitants\n-#[deprecated = \"this type is being removed, define a type locally if \\\n-                necessary\"]\n-pub enum Void { }\n-\n ///////////////////////////////////////////////////////////////////////////////\n // Any trait\n ///////////////////////////////////////////////////////////////////////////////\n@@ -117,13 +112,6 @@ pub trait AnyRefExt<'a> {\n     /// `None` if it isn't.\n     #[unstable = \"naming conventions around acquiring references may change\"]\n     fn downcast_ref<T: 'static>(self) -> Option<&'a T>;\n-\n-    /// Returns some reference to the boxed value if it is of type `T`, or\n-    /// `None` if it isn't.\n-    #[deprecated = \"this function has been renamed to `downcast_ref`\"]\n-    fn as_ref<T: 'static>(self) -> Option<&'a T> {\n-        self.downcast_ref::<T>()\n-    }\n }\n \n #[stable]\n@@ -166,13 +154,6 @@ pub trait AnyMutRefExt<'a> {\n     /// `None` if it isn't.\n     #[unstable = \"naming conventions around acquiring references may change\"]\n     fn downcast_mut<T: 'static>(self) -> Option<&'a mut T>;\n-\n-    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n-    /// `None` if it isn't.\n-    #[deprecated = \"this function has been renamed to `downcast_mut`\"]\n-    fn as_mut<T: 'static>(self) -> Option<&'a mut T> {\n-        self.downcast_mut::<T>()\n-    }\n }\n \n #[stable]"}, {"sha": "505dc18348011c51016752d0477161a4b11ad632", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -178,20 +178,6 @@ impl PartialOrd for Ordering {\n     }\n }\n \n-/// Combine orderings, lexically.\n-///\n-/// For example for a type `(int, int)`, two comparisons could be done.\n-/// If the first ordering is different, the first ordering is all that must be returned.\n-/// If the first ordering is equal, then second ordering is returned.\n-#[inline]\n-#[deprecated = \"Just call .cmp() on a tuple\"]\n-pub fn lexical_ordering(o1: Ordering, o2: Ordering) -> Ordering {\n-    match o1 {\n-        Equal => o2,\n-        _ => o1\n-    }\n-}\n-\n /// Trait for values that can be compared for a sort-order.\n ///\n /// PartialOrd only requires implementation of the `partial_cmp` method,"}, {"sha": "e2a4fdfe79bf171cc2e80c7f6225b688f2e7e691", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -428,27 +428,6 @@ pub trait Iterator<A> {\n         ByRef{iter: self}\n     }\n \n-    /// Apply a function to each element, or stop iterating if the\n-    /// function returns `false`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust,ignore\n-    /// range(0u, 5).advance(|x| {print!(\"{} \", x); true});\n-    /// ```\n-    #[deprecated = \"use the `all` method instead\"]\n-    #[inline]\n-    fn advance(&mut self, f: |A| -> bool) -> bool {\n-        loop {\n-            match self.next() {\n-                Some(x) => {\n-                    if !f(x) { return false; }\n-                }\n-                None => { return true; }\n-            }\n-        }\n-    }\n-\n     /// Loops through the entire iterator, collecting all of the elements into\n     /// a container implementing `FromIterator`.\n     ///"}, {"sha": "677bc91d9dd3b23f40717d87a7fcff3467f115e6", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -20,9 +20,6 @@ by the compiler automatically for the types to which they apply.\n \n */\n \n-#[deprecated = \"This has been renamed to Sync\"]\n-pub use self::Sync as Share;\n-\n /// Types able to be transferred across task boundaries.\n #[lang=\"send\"]\n pub trait Send for Sized? {"}, {"sha": "62a4fbd2e08cdc5a3c1e287b94d0d601bfd19e83", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -104,13 +104,6 @@ pub mod clone;\n pub mod default;\n pub mod collections;\n \n-#[deprecated = \"all functionality now lives in `std::cell`\"]\n-/// Deprecated module in favor of `std::cell`\n-pub mod ty {\n-    #[deprecated = \"this type has been renamed to `UnsafeCell`\"]\n-    pub use cell::UnsafeCell as Unsafe;\n-}\n-\n /* Core types and methods on primitives */\n \n pub mod any;"}, {"sha": "97b3554b1e1ba3455e3ea2cccb9bc89370d04b67", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -14,7 +14,6 @@\n //! types, initializing and manipulating memory.\n \n use intrinsics;\n-use num::Int;\n use ptr;\n \n pub use intrinsics::transmute;\n@@ -43,26 +42,6 @@ pub fn size_of_val<T>(_val: &T) -> uint {\n     size_of::<T>()\n }\n \n-/// Deprecated, this function will be removed soon\n-#[inline]\n-#[deprecated = \"this function will be removed soon\"]\n-pub fn nonzero_size_of<T>() -> uint {\n-    match size_of::<T>() {\n-        0 => 1,\n-        n => n,\n-    }\n-}\n-\n-/// Deprecated, this function will be removed soon\n-#[inline]\n-#[deprecated = \"this function will be removed soon\"]\n-pub fn nonzero_size_of_val<T>(val: &T) -> uint {\n-    match size_of_val::<T>(val) {\n-        0 => 1,\n-        n => n,\n-    }\n-}\n-\n /// Returns the ABI-required minimum alignment of a type\n ///\n /// This is the alignment used for struct fields. It may be smaller\n@@ -107,16 +86,6 @@ pub fn align_of_val<T>(_val: &T) -> uint {\n     align_of::<T>()\n }\n \n-/// Deprecated, this function has been renamed to align_of\n-#[inline]\n-#[deprecated = \"use mem::align_of instead\"]\n-pub fn pref_align_of<T>() -> uint { align_of::<T>() }\n-\n-/// Deprecated, this function has been renamed to align_of_val\n-#[inline]\n-#[deprecated = \"use mem::align_of_val instead\"]\n-pub fn pref_align_of_val<T>(val: &T) -> uint { align_of_val(val) }\n-\n /// Create a value initialized to zero.\n ///\n /// This function is similar to allocating space for a a local variable and\n@@ -134,11 +103,6 @@ pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n \n-/// Deprecated, use zeroed() instead\n-#[inline]\n-#[deprecated = \"this function has been renamed to zeroed()\"]\n-pub unsafe fn init<T>() -> T { zeroed() }\n-\n /// Create an uninitialized value.\n ///\n /// Care must be taken when using this function, if the type `T` has a\n@@ -153,116 +117,6 @@ pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n \n-/// Deprecated, use `uninitialized` instead.\n-#[inline]\n-#[deprecated = \"this function has been renamed to `uninitialized`\"]\n-pub unsafe fn uninit<T>() -> T {\n-    intrinsics::uninit()\n-}\n-\n-/// Unsafely overwrite a memory location with the given value without destroying\n-/// the old value.\n-///\n-/// This operation is unsafe because it does not destroy the previous value\n-/// contained at the location `dst`. This could leak allocations or resources,\n-/// so care must be taken to previously deallocate the value at `dst`.\n-#[inline]\n-#[deprecated = \"use ptr::write\"]\n-pub unsafe fn overwrite<T>(dst: *mut T, src: T) {\n-    intrinsics::move_val_init(&mut *dst, src)\n-}\n-\n-/// Deprecated, use `overwrite` instead\n-#[inline]\n-#[deprecated = \"this function has been renamed to overwrite()\"]\n-pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {\n-    ptr::write(dst, src)\n-}\n-\n-/// Convert an u16 to little endian from the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::to_le` instead\"]\n-pub fn to_le16(x: u16) -> u16 { x.to_le() }\n-\n-/// Convert an u32 to little endian from the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::to_le` instead\"]\n-pub fn to_le32(x: u32) -> u32 { x.to_le() }\n-\n-/// Convert an u64 to little endian from the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::to_le` instead\"]\n-pub fn to_le64(x: u64) -> u64 { x.to_le() }\n-\n-/// Convert an u16 to big endian from the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::to_be` instead\"]\n-pub fn to_be16(x: u16) -> u16 { x.to_be() }\n-\n-/// Convert an u32 to big endian from the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::to_be` instead\"]\n-pub fn to_be32(x: u32) -> u32 { x.to_be() }\n-\n-/// Convert an u64 to big endian from the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::to_be` instead\"]\n-pub fn to_be64(x: u64) -> u64 { x.to_be() }\n-\n-/// Convert an u16 from little endian to the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::from_le` instead\"]\n-pub fn from_le16(x: u16) -> u16 { Int::from_le(x) }\n-\n-/// Convert an u32 from little endian to the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::from_le` instead\"]\n-pub fn from_le32(x: u32) -> u32 { Int::from_le(x) }\n-\n-/// Convert an u64 from little endian to the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::from_le` instead\"]\n-pub fn from_le64(x: u64) -> u64 { Int::from_le(x) }\n-\n-/// Convert an u16 from big endian to the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::from_be` instead\"]\n-pub fn from_be16(x: u16) -> u16 { Int::from_be(x) }\n-\n-/// Convert an u32 from big endian to the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::from_be` instead\"]\n-pub fn from_be32(x: u32) -> u32 { Int::from_be(x) }\n-\n-/// Convert an u64 from big endian to the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[inline]\n-#[deprecated = \"use `Int::from_be` instead\"]\n-pub fn from_be64(x: u64) -> u64 { Int::from_be(x) }\n-\n /// Swap the values at two mutable locations of the same type, without\n /// deinitialising or copying either one.\n #[inline]"}, {"sha": "5b34cab611a56a372cd69a7654a757ef27ac2b34", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -482,33 +482,6 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Deprecated.\n-    ///\n-    /// Applies a function to the contained value or does nothing.\n-    /// Returns true if the contained value was mutated.\n-    #[deprecated = \"removed due to lack of use\"]\n-    pub fn mutate(&mut self, f: |T| -> T) -> bool {\n-        if self.is_some() {\n-            *self = Some(f(self.take().unwrap()));\n-            true\n-        } else { false }\n-    }\n-\n-    /// Deprecated.\n-    ///\n-    /// Applies a function to the contained value or sets it to a default.\n-    /// Returns true if the contained value was mutated, or false if set to the default.\n-    #[deprecated = \"removed due to lack of use\"]\n-    pub fn mutate_or_set(&mut self, def: T, f: |T| -> T) -> bool {\n-        if self.is_some() {\n-            *self = Some(f(self.take().unwrap()));\n-            true\n-        } else {\n-            *self = Some(def);\n-            false\n-        }\n-    }\n-\n     /////////////////////////////////////////////////////////////////////////\n     // Iterator constructors\n     /////////////////////////////////////////////////////////////////////////\n@@ -530,12 +503,6 @@ impl<T> Option<T> {\n         Item{opt: self.as_ref()}\n     }\n \n-    /// Deprecated: use `iter_mut`\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {\n-        self.iter_mut()\n-    }\n-\n     /// Returns a mutable iterator over the possibly contained value.\n     ///\n     /// # Example\n@@ -557,12 +524,6 @@ impl<T> Option<T> {\n         Item{opt: self.as_mut()}\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> Item<T> {\n-        self.into_iter()\n-    }\n-\n     /// Returns a consuming iterator over the possibly contained value.\n     ///\n     /// # Example\n@@ -713,100 +674,6 @@ impl<T> Option<T> {\n     pub fn take(&mut self) -> Option<T> {\n         mem::replace(self, None)\n     }\n-\n-    /// Deprecated.\n-    ///\n-    /// Filters an optional value using a given function.\n-    #[inline(always)]\n-    #[deprecated = \"removed due to lack of use\"]\n-    pub fn filtered(self, f: |t: &T| -> bool) -> Option<T> {\n-        match self {\n-            Some(x) => if f(&x) { Some(x) } else { None },\n-            None => None\n-        }\n-    }\n-\n-    /// Deprecated.\n-    ///\n-    /// Applies a function zero or more times until the result is `None`.\n-    #[inline]\n-    #[deprecated = \"removed due to lack of use\"]\n-    pub fn while_some(self, f: |v: T| -> Option<T>) {\n-        let mut opt = self;\n-        loop {\n-            match opt {\n-                Some(x) => opt = f(x),\n-                None => break\n-            }\n-        }\n-    }\n-\n-    /////////////////////////////////////////////////////////////////////////\n-    // Common special cases\n-    /////////////////////////////////////////////////////////////////////////\n-\n-    /// Deprecated: use `take().unwrap()` instead.\n-    ///\n-    /// The option dance. Moves a value out of an option type and returns it,\n-    /// replacing the original with `None`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value equals `None`.\n-    #[inline]\n-    #[deprecated = \"use take().unwrap() instead\"]\n-    pub fn take_unwrap(&mut self) -> T {\n-        match self.take() {\n-            Some(x) => x,\n-            None => fail!(\"called `Option::take_unwrap()` on a `None` value\")\n-        }\n-    }\n-\n-    /// Deprecated: use `as_ref().unwrap()` instead.\n-    ///\n-    /// Gets an immutable reference to the value inside an option.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value equals `None`\n-    ///\n-    /// # Safety note\n-    ///\n-    /// In general, because this function may fail, its use is discouraged\n-    /// (calling `get` on `None` is akin to dereferencing a null pointer).\n-    /// Instead, prefer to use pattern matching and handle the `None`\n-    /// case explicitly.\n-    #[inline]\n-    #[deprecated = \"use .as_ref().unwrap() instead\"]\n-    pub fn get_ref<'a>(&'a self) -> &'a T {\n-        match *self {\n-            Some(ref x) => x,\n-            None => fail!(\"called `Option::get_ref()` on a `None` value\"),\n-        }\n-    }\n-\n-    /// Deprecated: use `as_mut().unwrap()` instead.\n-    ///\n-    /// Gets a mutable reference to the value inside an option.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the value equals `None`\n-    ///\n-    /// # Safety note\n-    ///\n-    /// In general, because this function may fail, its use is discouraged\n-    /// (calling `get` on `None` is akin to dereferencing a null pointer).\n-    /// Instead, prefer to use pattern matching and handle the `None`\n-    /// case explicitly.\n-    #[inline]\n-    #[deprecated = \"use .as_mut().unwrap() instead\"]\n-    pub fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n-        match *self {\n-            Some(ref mut x) => x,\n-            None => fail!(\"called `Option::get_mut_ref()` on a `None` value\"),\n-        }\n-    }\n }\n \n impl<T: Default> Option<T> {\n@@ -908,13 +775,6 @@ impl<A> ExactSize<A> for Item<A> {}\n // Free functions\n /////////////////////////////////////////////////////////////////////////////\n \n-/// Deprecated: use `Iterator::collect` instead.\n-#[inline]\n-#[deprecated = \"use Iterator::collect instead\"]\n-pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(mut iter: Iter) -> Option<V> {\n-    iter.collect()\n-}\n-\n impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// Takes each element in the `Iterator`: if it is `None`, no further\n     /// elements are taken, and the `None` is returned. Should no `None` occur, a"}, {"sha": "f0cd8402b1424384c46102d37041d8251a65d206", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -90,7 +90,6 @@\n use mem;\n use clone::Clone;\n use intrinsics;\n-use iter::range;\n use option::{Some, None, Option};\n \n use cmp::{PartialEq, Eq, PartialOrd, Equiv, Ordering, Less, Equal, Greater};\n@@ -113,10 +112,6 @@ pub use intrinsics::set_memory;\n #[unstable = \"may need a different name after pending changes to pointer types\"]\n pub fn null<T>() -> *const T { 0 as *const T }\n \n-/// Deprecated: use `null_mut`.\n-#[deprecated = \"use null_mut\"]\n-pub fn mut_null<T>() -> *mut T { null_mut() }\n-\n /// Create an unsafe mutable null pointer.\n ///\n /// # Example\n@@ -203,59 +198,6 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n-/// Given a *const *const T (pointer to an array of pointers),\n-/// iterate through each *const T, up to the provided `len`,\n-/// passing to the provided callback function\n-#[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n-pub unsafe fn array_each_with_len<T>(arr: *const *const T, len: uint,\n-                                     cb: |*const T|) {\n-    if arr.is_null() {\n-        fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n-    }\n-    //let start_ptr = *arr;\n-    for e in range(0, len) {\n-        let n = arr.offset(e as int);\n-        cb(*n);\n-    }\n-}\n-\n-/// Given a null-pointer-terminated *const *const T (pointer to\n-/// an array of pointers), iterate through each *const T,\n-/// passing to the provided callback function\n-///\n-/// # Safety Note\n-///\n-/// This will only work with a null-terminated\n-/// pointer array.\n-#[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n-#[allow(deprecated)]\n-pub unsafe fn array_each<T>(arr: *const  *const T, cb: |*const T|) {\n-    if arr.is_null()  {\n-        fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n-    }\n-    let len = buf_len(arr);\n-    array_each_with_len(arr, len, cb);\n-}\n-\n-/// Return the offset of the first null pointer in `buf`.\n-#[inline]\n-#[deprecated = \"use a loop and RawPtr::offset\"]\n-#[allow(deprecated)]\n-pub unsafe fn buf_len<T>(buf: *const *const T) -> uint {\n-    position(buf, |i| *i == null())\n-}\n-\n-/// Return the first offset `i` such that `f(buf[i]) == true`.\n-#[inline]\n-#[deprecated = \"old-style iteration. use a loop and RawPtr::offset\"]\n-pub unsafe fn position<T>(buf: *const T, f: |&T| -> bool) -> uint {\n-    let mut i = 0;\n-    loop {\n-        if f(&(*buf.offset(i as int))) { return i; }\n-        else { i += 1; }\n-    }\n-}\n-\n /// Methods on raw pointers\n pub trait RawPtr<T> {\n     /// Returns the null pointer.\n@@ -280,12 +222,6 @@ pub trait RawPtr<T> {\n     /// the returned value could be pointing to invalid memory.\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T>;\n \n-    /// A synonym for `as_ref`, except with incorrect lifetime semantics\n-    #[deprecated=\"Use `as_ref` instead\"]\n-    unsafe fn to_option<'a>(&'a self) -> Option<&'a T> {\n-        mem::transmute(self.as_ref())\n-    }\n-\n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end.  `count` is in units of T; e.g. a\n     /// `count` of 3 represents a pointer offset of `3 * sizeof::<T>()` bytes."}, {"sha": "27bb649d1d99bfaa5c43a89675ea1c002d7307cc", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -566,12 +566,6 @@ impl<T, E> Result<T, E> {\n         Item{opt: self.as_ref().ok()}\n     }\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter<'r>(&'r mut self) -> Item<&'r mut T> {\n-        self.iter_mut()\n-    }\n-\n     /// Returns a mutable iterator over the possibly contained value.\n     ///\n     /// # Example\n@@ -593,12 +587,6 @@ impl<T, E> Result<T, E> {\n         Item{opt: self.as_mut().ok()}\n     }\n \n-    /// Deprecated: `use into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> Item<T> {\n-        self.into_iter()\n-    }\n-\n     /// Returns a consuming iterator over the possibly contained value.\n     ///\n     /// # Example\n@@ -771,13 +759,6 @@ impl<T, E> Result<T, E> {\n             Err(e) => op(e)\n         }\n     }\n-\n-    /// Deprecated name for `unwrap_or_else()`.\n-    #[deprecated = \"replaced by .unwrap_or_else()\"]\n-    #[inline]\n-    pub fn unwrap_or_handle(self, op: |E| -> T) -> T {\n-        self.unwrap_or_else(op)\n-    }\n }\n \n impl<T, E: Show> Result<T, E> {\n@@ -902,14 +883,6 @@ impl<A> ExactSize<A> for Item<A> {}\n // Free functions\n /////////////////////////////////////////////////////////////////////////////\n \n-/// Deprecated: use `Iterator::collect`.\n-#[inline]\n-#[deprecated = \"use Iterator::collect instead\"]\n-pub fn collect<T, E, Iter: Iterator<Result<T, E>>, V: FromIterator<T>>(mut iter: Iter)\n-                                                                       -> Result<V, E> {\n-    iter.collect()\n-}\n-\n impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// Takes each element in the `Iterator`: if it is an `Err`, no further\n     /// elements are taken, and the `Err` is returned. Should no `Err` occur, a\n@@ -984,16 +957,3 @@ pub fn fold<T,\n     }\n     Ok(init)\n }\n-\n-/// Deprecated.\n-///\n-/// Perform a trivial fold operation over the result values\n-/// from an iterator.\n-///\n-/// If an `Err` is encountered, it is immediately returned.\n-/// Otherwise, a simple `Ok(())` is returned.\n-#[inline]\n-#[deprecated = \"use fold instead\"]\n-pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n-    fold(iterator, (), |_, _| ())\n-}"}, {"sha": "6b24592b17f43ed6856585d2eec1cb452100770b", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 8, "deletions": 277, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -176,27 +176,14 @@ pub trait ImmutableSlice<'a, T> {\n     #[unstable = \"name may change\"]\n     fn tail(&self) -> &'a [T];\n \n-    /// Returns all but the first `n' elements of a slice.\n-    #[deprecated = \"use slice_from\"]\n-    fn tailn(&self, n: uint) -> &'a [T];\n-\n     /// Returns all but the last element of a slice.\n     #[unstable = \"name may change\"]\n     fn init(&self) -> &'a [T];\n \n-    /// Returns all but the last `n' elements of a slice.\n-    #[deprecated = \"use slice_to but note the arguments are different\"]\n-    fn initn(&self, n: uint) -> &'a [T];\n-\n     /// Returns the last element of a slice, or `None` if it is empty.\n     #[unstable = \"name may change\"]\n     fn last(&self) -> Option<&'a T>;\n \n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    #[deprecated = \"renamed to `unsafe_get`\"]\n-    unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n-\n     /// Returns a pointer to the element at the given index, without doing\n     /// bounds checking.\n     #[unstable]\n@@ -212,10 +199,6 @@ pub trait ImmutableSlice<'a, T> {\n     #[unstable]\n     fn as_ptr(&self) -> *const T;\n \n-    /// Deprecated: use `binary_search`.\n-    #[deprecated = \"use binary_search\"]\n-    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n-\n     /// Binary search a sorted slice with a comparator function.\n     ///\n     /// The comparator function should implement an order consistent\n@@ -251,44 +234,6 @@ pub trait ImmutableSlice<'a, T> {\n     /// ```\n     #[unstable = \"waiting on unboxed closures\"]\n     fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult;\n-\n-    /**\n-     * Returns an immutable reference to the first element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None }\n-     *     let head = &self[0];\n-     *     *self = self[1..];\n-     *     Some(head)\n-     * ```\n-     *\n-     * Returns `None` if vector is empty\n-     */\n-    #[deprecated = \"find some other way. sorry\"]\n-    fn shift_ref(&mut self) -> Option<&'a T>;\n-\n-    /**\n-     * Returns an immutable reference to the last element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let tail = &self[self.len() - 1];\n-     *     *self = self[..self.len() - 1];\n-     *     Some(tail)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty.\n-     */\n-    #[deprecated = \"find some other way. sorry\"]\n-    fn pop_ref(&mut self) -> Option<&'a T>;\n }\n \n #[unstable]\n@@ -388,32 +333,16 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     #[inline]\n     fn tail(&self) -> &'a [T] { (*self)[1..] }\n \n-    #[inline]\n-    #[deprecated = \"use slice_from\"]\n-    fn tailn(&self, n: uint) -> &'a [T] { (*self)[n..] }\n-\n     #[inline]\n     fn init(&self) -> &'a [T] {\n         (*self)[..self.len() - 1]\n     }\n \n-    #[inline]\n-    #[deprecated = \"use slice_to but note the arguments are different\"]\n-    fn initn(&self, n: uint) -> &'a [T] {\n-        (*self)[..self.len() - n]\n-    }\n-\n     #[inline]\n     fn last(&self) -> Option<&'a T> {\n         if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n     }\n \n-    #[inline]\n-    #[deprecated = \"renamed to `unsafe_get`\"]\n-    unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n-        transmute(self.repr().data.offset(index as int))\n-    }\n-\n     #[inline]\n     unsafe fn unsafe_get(self, index: uint) -> &'a T {\n         transmute(self.repr().data.offset(index as int))\n@@ -424,27 +353,6 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n         self.repr().data\n     }\n \n-\n-    #[deprecated = \"use binary_search\"]\n-    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n-        let mut base : uint = 0;\n-        let mut lim : uint = self.len();\n-\n-        while lim != 0 {\n-            let ix = base + (lim >> 1);\n-            match f(&self[ix]) {\n-                Equal => return Some(ix),\n-                Less => {\n-                    base = ix + 1;\n-                    lim -= 1;\n-                }\n-                Greater => ()\n-            }\n-            lim >>= 1;\n-        }\n-        return None;\n-    }\n-\n     #[unstable]\n     fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult {\n         let mut base : uint = 0;\n@@ -464,26 +372,6 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n         }\n         return NotFound(base);\n     }\n-\n-    fn shift_ref(&mut self) -> Option<&'a T> {\n-        unsafe {\n-            let s: &mut RawSlice<T> = transmute(self);\n-            match raw::shift_ptr(s) {\n-                Some(p) => Some(&*p),\n-                None => None\n-            }\n-        }\n-    }\n-\n-    fn pop_ref(&mut self) -> Option<&'a T> {\n-        unsafe {\n-            let s: &mut RawSlice<T> = transmute(self);\n-            match raw::pop_ptr(s) {\n-                Some(p) => Some(&*p),\n-                None => None\n-            }\n-        }\n-    }\n }\n \n \n@@ -557,12 +445,6 @@ pub trait MutableSlice<'a, T> {\n     /// Primarily intended for getting a &mut [T] from a [T, ..N].\n     fn as_mut_slice(self) -> &'a mut [T];\n \n-    /// Deprecated: use `slice_mut`.\n-    #[deprecated = \"use slice_mut\"]\n-    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n-        self.slice_mut(start, end)\n-    }\n-\n     /// Returns a mutable subslice spanning the interval [`start`, `end`).\n     ///\n     /// Fails when the end of the new slice lies beyond the end of the\n@@ -572,12 +454,6 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"waiting on final error conventions\"]\n     fn slice_mut(self, start: uint, end: uint) -> &'a mut [T];\n \n-    /// Deprecated: use `slice_from_mut`.\n-    #[deprecated = \"use slice_from_mut\"]\n-    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n-        self.slice_from_mut(start)\n-    }\n-\n     /// Returns a mutable subslice from `start` to the end of the slice.\n     ///\n     /// Fails when `start` is strictly greater than the length of the original slice.\n@@ -586,12 +462,6 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"waiting on final error conventions\"]\n     fn slice_from_mut(self, start: uint) -> &'a mut [T];\n \n-    /// Deprecated: use `slice_to_mut`.\n-    #[deprecated = \"use slice_to_mut\"]\n-    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n-        self.slice_to_mut(end)\n-    }\n-\n     /// Returns a mutable subslice from the start of the slice to `end`.\n     ///\n     /// Fails when `end` is strictly greater than the length of the original slice.\n@@ -600,12 +470,6 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"waiting on final error conventions\"]\n     fn slice_to_mut(self, end: uint) -> &'a mut [T];\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    fn mut_iter(self) -> MutItems<'a, T> {\n-        self.iter_mut()\n-    }\n-\n     /// Returns an iterator that allows modifying each value\n     #[unstable = \"waiting on iterator type name conventions\"]\n     fn iter_mut(self) -> MutItems<'a, T>;\n@@ -622,22 +486,10 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"name may change\"]\n     fn init_mut(self) -> &'a mut [T];\n \n-    /// Deprecated: use `last_mut`.\n-    #[deprecated = \"use last_mut\"]\n-    fn mut_last(self) -> Option<&'a mut T> {\n-        self.last_mut()\n-    }\n-\n     /// Returns a mutable pointer to the last item in the slice.\n     #[unstable = \"name may change\"]\n     fn last_mut(self) -> Option<&'a mut T>;\n \n-    /// Deprecated: use `split_mut`.\n-    #[deprecated = \"use split_mut\"]\n-    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n-        self.split_mut(pred)\n-    }\n-\n     /// Returns an iterator over mutable subslices separated by elements that\n     /// match `pred`.  The matched element is not contained in the subslices.\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n@@ -656,12 +508,6 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"waiting on unboxed closures, iterator type name conventions\"]\n     fn rsplitn_mut(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<MutSplits<'a, T>>;\n \n-    /// Deprecated: use `chunks_mut`.\n-    #[deprecated = \"use chunks_mut\"]\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {\n-        self.chunks_mut(chunk_size)\n-    }\n-\n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n     /// The chunks are mutable and do not overlap. If `chunk_size` does\n     /// not divide the length of the slice, then the last chunk will not\n@@ -673,44 +519,6 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"waiting on iterator type name conventions\"]\n     fn chunks_mut(self, chunk_size: uint) -> MutChunks<'a, T>;\n \n-    /**\n-     * Returns a mutable reference to the first element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let head = &mut self[0];\n-     *     *self = self[mut 1..];\n-     *     Some(head)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty\n-     */\n-    #[deprecated = \"use iter_mut\"]\n-    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n-\n-    /**\n-     * Returns a mutable reference to the last element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let tail = &mut self[self.len() - 1];\n-     *     *self = self[mut ..self.len() - 1];\n-     *     Some(tail)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty.\n-     */\n-    #[deprecated = \"use iter_mut\"]\n-    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n-\n     /// Swaps two elements in a slice.\n     ///\n     /// Fails if `a` or `b` are out of bounds.\n@@ -730,12 +538,6 @@ pub trait MutableSlice<'a, T> {\n     #[unstable = \"waiting on final error conventions\"]\n     fn swap(self, a: uint, b: uint);\n \n-    /// Deprecated: use `split_at_mut`.\n-    #[deprecated = \"use split_at_mut\"]\n-    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        self.split_at_mut(mid)\n-    }\n-\n     /// Divides one `&mut` into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding\n@@ -783,12 +585,6 @@ pub trait MutableSlice<'a, T> {\n     #[experimental = \"may be moved to iterators instead\"]\n     fn reverse(self);\n \n-    /// Deprecated: use `unsafe_mut`.\n-    #[deprecated = \"use unsafe_mut\"]\n-    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n-        self.unsafe_mut(index)\n-    }\n-\n     /// Returns an unsafe mutable pointer to the element in index\n     #[experimental = \"waiting on unsafe conventions\"]\n     unsafe fn unsafe_mut(self, index: uint) -> &'a mut T;\n@@ -803,18 +599,6 @@ pub trait MutableSlice<'a, T> {\n     #[inline]\n     #[unstable]\n     fn as_mut_ptr(self) -> *mut T;\n-\n-    /// Deprecated: use `*foo.as_mut_ptr().offset(index) = val` instead.\n-    #[deprecated = \"use `*foo.as_mut_ptr().offset(index) = val`\"]\n-    unsafe fn unsafe_set(self, index: uint, val: T);\n-\n-    /// Deprecated: use `ptr::write(foo.as_mut_ptr().offset(i), val)` instead.\n-    #[deprecated = \"use `ptr::write(foo.as_mut_ptr().offset(i), val)`\"]\n-    unsafe fn init_elem(self, i: uint, val: T);\n-\n-    /// Deprecated: use `as_mut_ptr` and `ptr::copy_memory` instead.\n-    #[deprecated = \"use as_mut_ptr and ptr::copy_memory\"]\n-    unsafe fn copy_memory(self, src: &[T]);\n }\n \n #[experimental = \"trait is experimental\"]\n@@ -920,30 +704,6 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n         MutChunks { v: self, chunk_size: chunk_size }\n     }\n \n-    fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n-        unsafe {\n-            let s: &mut RawSlice<T> = transmute(self);\n-            match raw::shift_ptr(s) {\n-                // FIXME #13933: this `&` -> `&mut` cast is a little\n-                // dubious\n-                Some(p) => Some(&mut *(p as *mut _)),\n-                None => None,\n-            }\n-        }\n-    }\n-\n-    fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n-        unsafe {\n-            let s: &mut RawSlice<T> = transmute(self);\n-            match raw::pop_ptr(s) {\n-                // FIXME #13933: this `&` -> `&mut` cast is a little\n-                // dubious\n-                Some(p) => Some(&mut *(p as *mut _)),\n-                None => None,\n-            }\n-        }\n-    }\n-\n     fn swap(self, a: uint, b: uint) {\n         unsafe {\n             // Can't take two mutable loans from one vector, so instead just cast\n@@ -977,23 +737,6 @@ impl<'a,T> MutableSlice<'a, T> for &'a mut [T] {\n     fn as_mut_ptr(self) -> *mut T {\n         self.repr().data as *mut T\n     }\n-\n-    #[inline]\n-    unsafe fn unsafe_set(self, index: uint, val: T) {\n-        *self.unsafe_mut(index) = val;\n-    }\n-\n-    #[inline]\n-    unsafe fn init_elem(self, i: uint, val: T) {\n-        ptr::write(&mut (*self.as_mut_ptr().offset(i as int)), val);\n-    }\n-\n-    #[inline]\n-    unsafe fn copy_memory(self, src: &[T]) {\n-        let len_src = src.len();\n-        assert!(self.len() >= len_src);\n-        ptr::copy_nonoverlapping_memory(self.as_mut_ptr(), src.as_ptr(), len_src)\n-    }\n }\n \n /// Extension methods for slices containing `PartialEq` elements.\n@@ -1048,10 +791,6 @@ impl<'a,T:PartialEq> ImmutablePartialEqSlice<T> for &'a [T] {\n /// Extension methods for slices containing `Ord` elements.\n #[unstable = \"may merge with other traits\"]\n pub trait ImmutableOrdSlice<T: Ord> {\n-    /// Deprecated: use `binary_search_elem`.\n-    #[deprecated = \"use binary_search_elem\"]\n-    fn bsearch_elem(&self, x: &T) -> Option<uint>;\n-\n     /// Binary search a sorted slice for a given element.\n     ///\n     /// If the value is found then `Found` is returned, containing the\n@@ -1082,12 +821,6 @@ pub trait ImmutableOrdSlice<T: Ord> {\n \n #[unstable = \"trait is unstable\"]\n impl<'a, T: Ord> ImmutableOrdSlice<T> for &'a [T] {\n-    #[deprecated = \"use binary_search_elem\"]\n-    #[allow(deprecated)]\n-    fn bsearch_elem(&self, x: &T) -> Option<uint> {\n-        self.bsearch(|p| p.cmp(x))\n-    }\n-\n     #[unstable]\n     fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n         self.binary_search(|p| p.cmp(x))\n@@ -1097,12 +830,6 @@ impl<'a, T: Ord> ImmutableOrdSlice<T> for &'a [T] {\n /// Trait for &[T] where T is Cloneable\n #[unstable = \"may merge with other traits\"]\n pub trait MutableCloneableSlice<T> {\n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    #[deprecated = \"renamed to clone_from_slice\"]\n-    fn copy_from(self, s: &[T]) -> uint { self.clone_from_slice(s) }\n-\n     /// Copies as many elements from `src` as it can into `self` (the\n     /// shorter of `self.len()` and `src.len()`). Returns the number\n     /// of elements copied.\n@@ -1780,7 +1507,7 @@ pub mod raw {\n pub mod bytes {\n     use collections::Collection;\n     use ptr;\n-    use slice::MutableSlice;\n+    use slice::{ImmutableSlice, MutableSlice};\n \n     /// A trait for operations on mutable `[u8]`s.\n     pub trait MutableByteVector {\n@@ -1801,10 +1528,14 @@ pub mod bytes {\n     /// `src` and `dst` must not overlap. Fails if the length of `dst`\n     /// is less than the length of `src`.\n     #[inline]\n-    #[allow(deprecated)]\n     pub fn copy_memory(dst: &mut [u8], src: &[u8]) {\n-        // Bound checks are done at .copy_memory.\n-        unsafe { dst.copy_memory(src) }\n+        let len_src = src.len();\n+        assert!(dst.len() >= len_src);\n+        unsafe {\n+            ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(),\n+                                            src.as_ptr(),\n+                                            len_src);\n+        }\n     }\n }\n "}, {"sha": "59ce73fe40da5c3f13a81f9fd00f9323da6358fd", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::cmp::lexical_ordering;\n use core::cmp::{ partial_min, partial_max };\n \n #[test]\n@@ -42,21 +41,6 @@ fn test_ordering_order() {\n     assert_eq!(Greater.cmp(&Less), Greater);\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_lexical_ordering() {\n-    fn t(o1: Ordering, o2: Ordering, e: Ordering) {\n-        assert_eq!(lexical_ordering(o1, o2), e);\n-    }\n-\n-    let xs = [Less, Equal, Greater];\n-    for &o in xs.iter() {\n-        t(Less, o, Less);\n-        t(Equal, o, o);\n-        t(Greater, o, Greater);\n-     }\n-}\n-\n #[test]\n fn test_partial_min() {\n     use core::f64::NAN;"}, {"sha": "71e9270fe4b0cba6df22453a51f7f3533e51477e", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 6, "deletions": 47, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -130,21 +130,6 @@ fn test_or_else() {\n     assert_eq!(x.or_else(|| None), None);\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_option_while_some() {\n-    let mut i = 0i;\n-    Some(10i).while_some(|j| {\n-        i += 1;\n-        if j > 0 {\n-            Some(j-1)\n-        } else {\n-            None\n-        }\n-    });\n-    assert_eq!(i, 11);\n-}\n-\n #[test]\n fn test_unwrap() {\n     assert_eq!(Some(1i).unwrap(), 1);\n@@ -184,15 +169,6 @@ fn test_unwrap_or_else() {\n     assert_eq!(x.unwrap_or_else(|| 2), 2);\n }\n \n-#[test]\n-#[allow(deprecated)]\n-fn test_filtered() {\n-    let some_stuff = Some(42i);\n-    let modified_stuff = some_stuff.filtered(|&x| {x < 10});\n-    assert_eq!(some_stuff.unwrap(), 42);\n-    assert!(modified_stuff.is_none());\n-}\n-\n #[test]\n fn test_iter() {\n     let val = 5i;\n@@ -244,39 +220,22 @@ fn test_ord() {\n }\n \n #[test]\n-#[allow(deprecated)]\n-fn test_mutate() {\n-    let mut x = Some(3i);\n-    assert!(x.mutate(|i| i+1));\n-    assert_eq!(x, Some(4i));\n-    assert!(x.mutate_or_set(0, |i| i+1));\n-    assert_eq!(x, Some(5i));\n-    x = None;\n-    assert!(!x.mutate(|i| i+1));\n-    assert_eq!(x, None);\n-    assert!(!x.mutate_or_set(0i, |i| i+1));\n-    assert_eq!(x, Some(0i));\n-}\n-\n-#[test]\n-#[allow(deprecated)]\n fn test_collect() {\n-    let v: Option<Vec<int>> = collect(range(0i, 0)\n-                                      .map(|_| Some(0i)));\n+    let v: Option<Vec<int>> = range(0i, 0).map(|_| Some(0i)).collect();\n     assert!(v == Some(vec![]));\n \n-    let v: Option<Vec<int>> = collect(range(0i, 3)\n-                                      .map(|x| Some(x)));\n+    let v: Option<Vec<int>> = range(0i, 3).map(|x| Some(x)).collect();\n     assert!(v == Some(vec![0, 1, 2]));\n \n-    let v: Option<Vec<int>> = collect(range(0i, 3)\n-                                      .map(|x| if x > 1 { None } else { Some(x) }));\n+    let v: Option<Vec<int>> = range(0i, 3).map(|x| {\n+        if x > 1 { None } else { Some(x) }\n+    }).collect();\n     assert!(v == None);\n \n     // test that it does not take more elements than it needs\n     let mut functions = [|| Some(()), || None, || fail!()];\n \n-    let v: Option<Vec<()>> = collect(functions.iter_mut().map(|f| (*f)()));\n+    let v: Option<Vec<()>> = functions.iter_mut().map(|f| (*f)()).collect();\n \n     assert!(v == None);\n }"}, {"sha": "db3580e5d0c4252aff037326eac8f7bd0ad6afd8", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 13, "deletions": 119, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -7,12 +7,9 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![allow(deprecated)]\n+\n use core::ptr::*;\n-use libc::c_char;\n use core::mem;\n-use libc;\n-use std::c_str::CString;\n \n #[test]\n fn test() {\n@@ -39,49 +36,22 @@ fn test() {\n \n         copy_memory(v1.as_mut_ptr().offset(1),\n                     v0.as_ptr().offset(1), 1);\n-        assert!((*v1.get(0) == 0u16 &&\n-                 *v1.get(1) == 32001u16 &&\n-                 *v1.get(2) == 0u16));\n+        assert!((v1[0] == 0u16 &&\n+                 v1[1] == 32001u16 &&\n+                 v1[2] == 0u16));\n         copy_memory(v1.as_mut_ptr(),\n                     v0.as_ptr().offset(2), 1);\n-        assert!((*v1.get(0) == 32002u16 &&\n-                 *v1.get(1) == 32001u16 &&\n-                 *v1.get(2) == 0u16));\n+        assert!((v1[0] == 32002u16 &&\n+                 v1[1] == 32001u16 &&\n+                 v1[2] == 0u16));\n         copy_memory(v1.as_mut_ptr().offset(2),\n                     v0.as_ptr(), 1u);\n-        assert!((*v1.get(0) == 32002u16 &&\n-                 *v1.get(1) == 32001u16 &&\n-                 *v1.get(2) == 32000u16));\n+        assert!((v1[0] == 32002u16 &&\n+                 v1[1] == 32001u16 &&\n+                 v1[2] == 32000u16));\n     }\n }\n \n-#[test]\n-fn test_position() {\n-    use libc::c_char;\n-\n-    \"hello\".with_c_str(|p| {\n-        unsafe {\n-            assert!(2u == position(p, |c| *c == 'l' as c_char));\n-            assert!(4u == position(p, |c| *c == 'o' as c_char));\n-            assert!(5u == position(p, |c| *c == 0 as c_char));\n-        }\n-    })\n-}\n-\n-#[test]\n-fn test_buf_len() {\n-    \"hello\".with_c_str(|p0| {\n-        \"there\".with_c_str(|p1| {\n-            \"thing\".with_c_str(|p2| {\n-                let v = vec![p0, p1, p2, null()];\n-                unsafe {\n-                    assert_eq!(buf_len(v.as_ptr()), 3u);\n-                }\n-            })\n-        })\n-    })\n-}\n-\n #[test]\n fn test_is_null() {\n     let p: *const int = null();\n@@ -92,7 +62,7 @@ fn test_is_null() {\n     assert!(!q.is_null());\n     assert!(q.is_not_null());\n \n-    let mp: *mut int = mut_null();\n+    let mp: *mut int = null_mut();\n     assert!(mp.is_null());\n     assert!(!mp.is_not_null());\n \n@@ -110,7 +80,7 @@ fn test_as_ref() {\n         let q: *const int = &2;\n         assert_eq!(q.as_ref().unwrap(), &2);\n \n-        let p: *mut int = mut_null();\n+        let p: *mut int = null_mut();\n         assert_eq!(p.as_ref(), None);\n \n         let q: *mut int = &mut 2;\n@@ -128,7 +98,7 @@ fn test_as_ref() {\n #[test]\n fn test_as_mut() {\n     unsafe {\n-        let p: *mut int = mut_null();\n+        let p: *mut int = null_mut();\n         assert!(p.as_mut() == None);\n \n         let q: *mut int = &mut 2;\n@@ -193,82 +163,6 @@ fn test_ptr_subtraction() {\n     }\n }\n \n-#[test]\n-fn test_ptr_array_each_with_len() {\n-    unsafe {\n-        let one = \"oneOne\".to_c_str();\n-        let two = \"twoTwo\".to_c_str();\n-        let three = \"threeThree\".to_c_str();\n-        let arr = vec![\n-            one.as_ptr(),\n-            two.as_ptr(),\n-            three.as_ptr()\n-        ];\n-        let expected_arr = [\n-            one, two, three\n-        ];\n-\n-        let mut ctr = 0;\n-        let mut iteration_count = 0;\n-        array_each_with_len(arr.as_ptr(), arr.len(), |e| {\n-                let actual = CString::new(e, false);\n-                assert_eq!(actual.as_str(), expected_arr[ctr].as_str());\n-                ctr += 1;\n-                iteration_count += 1;\n-            });\n-        assert_eq!(iteration_count, 3u);\n-    }\n-}\n-\n-#[test]\n-fn test_ptr_array_each() {\n-    unsafe {\n-        let one = \"oneOne\".to_c_str();\n-        let two = \"twoTwo\".to_c_str();\n-        let three = \"threeThree\".to_c_str();\n-        let arr = vec![\n-            one.as_ptr(),\n-            two.as_ptr(),\n-            three.as_ptr(),\n-            // fake a null terminator\n-            null()\n-        ];\n-        let expected_arr = [\n-            one, two, three\n-        ];\n-\n-        let arr_ptr = arr.as_ptr();\n-        let mut ctr = 0u;\n-        let mut iteration_count = 0u;\n-        array_each(arr_ptr, |e| {\n-                let actual = CString::new(e, false);\n-                assert_eq!(actual.as_str(), expected_arr[ctr].as_str());\n-                ctr += 1;\n-                iteration_count += 1;\n-            });\n-        assert_eq!(iteration_count, 3);\n-    }\n-}\n-\n-#[test]\n-#[should_fail]\n-fn test_ptr_array_each_with_len_null_ptr() {\n-    unsafe {\n-        array_each_with_len(0 as *const *const libc::c_char, 1, |e| {\n-            CString::new(e, false).as_str().unwrap();\n-        });\n-    }\n-}\n-#[test]\n-#[should_fail]\n-fn test_ptr_array_each_null_ptr() {\n-    unsafe {\n-        array_each(0 as *const *const libc::c_char, |e| {\n-            CString::new(e, false).as_str().unwrap();\n-        });\n-    }\n-}\n-\n #[test]\n fn test_set_memory() {\n     let mut xs = [0u8, ..20];"}, {"sha": "1cb72bd9eac78b3cca4d5def36e2602a4fe928e8", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::result::{collect, fold, fold_};\n use core::iter::range;\n \n pub fn op1() -> Result<int, &'static str> { Ok(666) }\n@@ -69,47 +68,25 @@ pub fn test_impl_map_err() {\n }\n \n #[test]\n-#[allow(deprecated)]\n fn test_collect() {\n-    let v: Result<Vec<int>, ()> = collect(range(0i, 0).map(|_| Ok::<int, ()>(0)));\n+    let v: Result<Vec<int>, ()> = range(0i, 0).map(|_| Ok::<int, ()>(0)).collect();\n     assert!(v == Ok(vec![]));\n \n-    let v: Result<Vec<int>, ()> = collect(range(0i, 3).map(|x| Ok::<int, ()>(x)));\n+    let v: Result<Vec<int>, ()> = range(0i, 3).map(|x| Ok::<int, ()>(x)).collect();\n     assert!(v == Ok(vec![0, 1, 2]));\n \n-    let v: Result<Vec<int>, int> = collect(range(0i, 3)\n-                                           .map(|x| if x > 1 { Err(x) } else { Ok(x) }));\n+    let v: Result<Vec<int>, int> = range(0i, 3).map(|x| {\n+        if x > 1 { Err(x) } else { Ok(x) }\n+    }).collect();\n     assert!(v == Err(2));\n \n     // test that it does not take more elements than it needs\n     let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n \n-    let v: Result<Vec<()>, int> = collect(functions.iter_mut().map(|f| (*f)()));\n+    let v: Result<Vec<()>, int> = functions.iter_mut().map(|f| (*f)()).collect();\n     assert!(v == Err(1));\n }\n \n-#[test]\n-#[allow(deprecated)] // we know fold_ is deprecated\n-fn test_fold() {\n-    assert_eq!(fold_(range(0i, 0)\n-                    .map(|_| Ok::<(), ()>(()))),\n-               Ok(()));\n-    assert_eq!(fold(range(0i, 3)\n-                    .map(|x| Ok::<int, ()>(x)),\n-                    0, |a, b| a + b),\n-               Ok(3));\n-    assert_eq!(fold_(range(0i, 3)\n-                    .map(|x| if x > 1 { Err(x) } else { Ok(()) })),\n-               Err(2));\n-\n-    // test that it does not take more elements than it needs\n-    let mut functions = [|| Ok(()), || Err(1i), || fail!()];\n-\n-    assert_eq!(fold_(functions.iter_mut()\n-                    .map(|f| (*f)())),\n-               Err(1));\n-}\n-\n #[test]\n pub fn test_fmt_default() {\n     let ok: Result<int, &'static str> = Ok(100);"}, {"sha": "ffa72e6d7958ea4c17c357bb7c53a1041c78e82f", "filename": "src/libfourcc/lib.rs", "status": "removed", "additions": 0, "deletions": 163, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibfourcc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibfourcc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfourcc%2Flib.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,163 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Syntax extension to generate FourCCs.\n-\n-Once loaded, fourcc!() is called with a single 4-character string,\n-and an optional ident that is either `big`, `little`, or `target`.\n-The ident represents endianness, and specifies in which direction\n-the characters should be read. If the ident is omitted, it is assumed\n-to be `big`, i.e. left-to-right order. It returns a u32.\n-\n-# Examples\n-\n-To load the extension and use it:\n-\n-```rust,ignore\n-#[phase(plugin)]\n-extern crate fourcc;\n-\n-fn main() {\n-    let val = fourcc!(\"\\xC0\\xFF\\xEE!\");\n-    assert_eq!(val, 0xC0FFEE21u32);\n-    let little_val = fourcc!(\"foo \", little);\n-    assert_eq!(little_val, 0x21EEFFC0u32);\n-}\n-```\n-\n-# References\n-\n-* [Wikipedia: FourCC](http://en.wikipedia.org/wiki/FourCC)\n-\n-*/\n-\n-#![crate_name = \"fourcc\"]\n-#![deprecated = \"This is now a cargo package located at: \\\n-                 https://github.com/rust-lang/fourcc\"]\n-#![allow(deprecated)]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-\n-#![feature(plugin_registrar)]\n-\n-extern crate syntax;\n-extern crate rustc;\n-\n-use syntax::ast;\n-use syntax::attr::contains;\n-use syntax::codemap::{Span, mk_sp};\n-use syntax::ext::base;\n-use syntax::ext::base::{ExtCtxt, MacExpr};\n-use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n-use syntax::parse::token::InternedString;\n-use syntax::ptr::P;\n-use rustc::plugin::Registry;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"fourcc\", expand_syntax_ext);\n-}\n-\n-pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n-    let (expr, endian) = parse_tts(cx, tts);\n-\n-    let little = match endian {\n-        None => false,\n-        Some(Ident{ident, span}) => match token::get_ident(ident).get() {\n-            \"little\" => true,\n-            \"big\" => false,\n-            \"target\" => target_endian_little(cx, sp),\n-            _ => {\n-                cx.span_err(span, \"invalid endian directive in fourcc!\");\n-                target_endian_little(cx, sp)\n-            }\n-        }\n-    };\n-\n-    let s = match expr.node {\n-        // expression is a literal\n-        ast::ExprLit(ref lit) => match lit.node {\n-            // string literal\n-            ast::LitStr(ref s, _) => {\n-                if s.get().char_len() != 4 {\n-                    cx.span_err(expr.span, \"string literal with len != 4 in fourcc!\");\n-                }\n-                s\n-            }\n-            _ => {\n-                cx.span_err(expr.span, \"unsupported literal in fourcc!\");\n-                return base::DummyResult::expr(sp)\n-            }\n-        },\n-        _ => {\n-            cx.span_err(expr.span, \"non-literal in fourcc!\");\n-            return base::DummyResult::expr(sp)\n-        }\n-    };\n-\n-    let mut val = 0u32;\n-    for codepoint in s.get().chars().take(4) {\n-        let byte = if codepoint as u32 > 0xFF {\n-            cx.span_err(expr.span, \"fourcc! literal character out of range 0-255\");\n-            0u8\n-        } else {\n-            codepoint as u8\n-        };\n-\n-        val = if little {\n-            (val >> 8) | ((byte as u32) << 24)\n-        } else {\n-            (val << 8) | (byte as u32)\n-        };\n-    }\n-    let e = cx.expr_lit(sp, ast::LitInt(val as u64, ast::UnsignedIntLit(ast::TyU32)));\n-    MacExpr::new(e)\n-}\n-\n-struct Ident {\n-    ident: ast::Ident,\n-    span: Span\n-}\n-\n-fn parse_tts(cx: &ExtCtxt,\n-             tts: &[ast::TokenTree]) -> (P<ast::Expr>, Option<Ident>) {\n-    let p = &mut cx.new_parser_from_tts(tts);\n-    let ex = p.parse_expr();\n-    let id = if p.token == token::EOF {\n-        None\n-    } else {\n-        p.expect(&token::COMMA);\n-        let lo = p.span.lo;\n-        let ident = p.parse_ident();\n-        let hi = p.last_span.hi;\n-        Some(Ident{ident: ident, span: mk_sp(lo, hi)})\n-    };\n-    if p.token != token::EOF {\n-        p.unexpected();\n-    }\n-    (ex, id)\n-}\n-\n-fn target_endian_little(cx: &ExtCtxt, sp: Span) -> bool {\n-    let meta = cx.meta_name_value(sp, InternedString::new(\"target_endian\"),\n-        ast::LitStr(InternedString::new(\"little\"), ast::CookedStr));\n-    contains(cx.cfg().as_slice(), &*meta)\n-}\n-\n-// FIXME (10872): This is required to prevent an LLVM assert on Windows\n-#[test]\n-fn dummy_test() { }"}, {"sha": "0313c22933cfabb0fc8fcbb7ca45a20530df9ac4", "filename": "src/libglob/lib.rs", "status": "removed", "additions": 0, "deletions": 893, "changes": 893, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,893 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * Support for matching file paths against Unix shell style patterns.\n- *\n- * The `glob` and `glob_with` functions, in concert with the `Paths`\n- * type, allow querying the filesystem for all files that match a particular\n- * pattern - just like the libc `glob` function (for an example see the `glob`\n- * documentation). The methods on the `Pattern` type provide functionality\n- * for checking if individual paths match a particular pattern - in a similar\n- * manner to the libc `fnmatch` function\n- *\n- * For consistency across platforms, and for Windows support, this module\n- * is implemented entirely in Rust rather than deferring to the libc\n- * `glob`/`fnmatch` functions.\n- */\n-\n-#![crate_name = \"glob\"]\n-#![deprecated = \"This is now a cargo package located at: \\\n-                 https://github.com/rust-lang/glob\"]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-#![allow(deprecated)]\n-\n-use std::cell::Cell;\n-use std::{cmp, os, path};\n-use std::io::fs::PathExtensions;\n-use std::io::fs;\n-use std::path::is_sep;\n-use std::string::String;\n-\n-/**\n- * An iterator that yields Paths from the filesystem that match a particular\n- * pattern - see the `glob` function for more details.\n- */\n-pub struct Paths {\n-    dir_patterns: Vec<Pattern>,\n-    require_dir: bool,\n-    options: MatchOptions,\n-    todo: Vec<(Path,uint)>,\n-}\n-\n-///\n-/// Return an iterator that produces all the Paths that match the given pattern,\n-/// which may be absolute or relative to the current working directory.\n-///\n-/// This method uses the default match options and is equivalent to calling\n-/// `glob_with(pattern, MatchOptions::new())`. Use `glob_with` directly if you\n-/// want to use non-default match options.\n-///\n-/// # Example\n-///\n-/// Consider a directory `/media/pictures` containing only the files `kittens.jpg`,\n-/// `puppies.jpg` and `hamsters.gif`:\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// use glob::glob;\n-///\n-/// for path in glob(\"/media/pictures/*.jpg\") {\n-///     println!(\"{}\", path.display());\n-/// }\n-/// ```\n-///\n-/// The above code will print:\n-///\n-/// ```ignore\n-/// /media/pictures/kittens.jpg\n-/// /media/pictures/puppies.jpg\n-/// ```\n-///\n-pub fn glob(pattern: &str) -> Paths {\n-    glob_with(pattern, MatchOptions::new())\n-}\n-\n-/**\n- * Return an iterator that produces all the Paths that match the given pattern,\n- * which may be absolute or relative to the current working directory.\n- *\n- * This function accepts Unix shell style patterns as described by `Pattern::new(..)`.\n- * The options given are passed through unchanged to `Pattern::matches_with(..)` with\n- * the exception that `require_literal_separator` is always set to `true` regardless of the\n- * value passed to this function.\n- *\n- * Paths are yielded in alphabetical order, as absolute paths.\n- */\n-pub fn glob_with(pattern: &str, options: MatchOptions) -> Paths {\n-    #[cfg(windows)]\n-    fn check_windows_verbatim(p: &Path) -> bool { path::windows::is_verbatim(p) }\n-    #[cfg(not(windows))]\n-    fn check_windows_verbatim(_: &Path) -> bool { false }\n-\n-    // calculate root this way to handle volume-relative Windows paths correctly\n-    let mut root = os::getcwd();\n-    let pat_root = Path::new(pattern).root_path();\n-    if pat_root.is_some() {\n-        if check_windows_verbatim(pat_root.as_ref().unwrap()) {\n-            // FIXME: How do we want to handle verbatim paths? I'm inclined to return nothing,\n-            // since we can't very well find all UNC shares with a 1-letter server name.\n-            return Paths {\n-                dir_patterns: Vec::new(),\n-                require_dir: false,\n-                options: options,\n-                todo: Vec::new(),\n-            };\n-        }\n-        root.push(pat_root.as_ref().unwrap());\n-    }\n-\n-    let root_len = pat_root.map_or(0u, |p| p.as_vec().len());\n-    let dir_patterns = pattern.slice_from(cmp::min(root_len, pattern.len()))\n-                       .split_terminator(is_sep)\n-                       .map(|s| Pattern::new(s))\n-                       .collect::<Vec<Pattern>>();\n-    let require_dir = pattern.chars().next_back().map(is_sep) == Some(true);\n-\n-    let mut todo = Vec::new();\n-    if dir_patterns.len() > 0 {\n-        // Shouldn't happen, but we're using -1 as a special index.\n-        assert!(dir_patterns.len() < -1 as uint);\n-\n-        fill_todo(&mut todo, dir_patterns.as_slice(), 0, &root, options);\n-    }\n-\n-    Paths {\n-        dir_patterns: dir_patterns,\n-        require_dir: require_dir,\n-        options: options,\n-        todo: todo,\n-    }\n-}\n-\n-impl Iterator<Path> for Paths {\n-\n-    fn next(&mut self) -> Option<Path> {\n-        loop {\n-            if self.dir_patterns.is_empty() || self.todo.is_empty() {\n-                return None;\n-            }\n-\n-            let (path,idx) = self.todo.pop().unwrap();\n-            // idx -1: was already checked by fill_todo, maybe path was '.' or\n-            // '..' that we can't match here because of normalization.\n-            if idx == -1 as uint {\n-                if self.require_dir && !path.is_dir() { continue; }\n-                return Some(path);\n-            }\n-            let ref pattern = self.dir_patterns[idx];\n-\n-            if pattern.matches_with(match path.filename_str() {\n-                // this ugly match needs to go here to avoid a borrowck error\n-                None => {\n-                    // FIXME (#9639): How do we handle non-utf8 filenames? Ignore them for now\n-                    // Ideally we'd still match them against a *\n-                    continue;\n-                }\n-                Some(x) => x\n-            }, self.options) {\n-                if idx == self.dir_patterns.len() - 1 {\n-                    // it is not possible for a pattern to match a directory *AND* its children\n-                    // so we don't need to check the children\n-\n-                    if !self.require_dir || path.is_dir() {\n-                        return Some(path);\n-                    }\n-                } else {\n-                    fill_todo(&mut self.todo, self.dir_patterns.as_slice(),\n-                              idx + 1, &path, self.options);\n-                }\n-            }\n-        }\n-    }\n-\n-}\n-\n-fn list_dir_sorted(path: &Path) -> Option<Vec<Path>> {\n-    match fs::readdir(path) {\n-        Ok(mut children) => {\n-            children.sort_by(|p1, p2| p2.filename().cmp(&p1.filename()));\n-            Some(children.into_iter().collect())\n-        }\n-        Err(..) => None\n-    }\n-}\n-\n-/**\n- * A compiled Unix shell style pattern.\n- */\n-#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]\n-pub struct Pattern {\n-    tokens: Vec<PatternToken>,\n-}\n-\n-#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-enum PatternToken {\n-    Char(char),\n-    AnyChar,\n-    AnySequence,\n-    AnyWithin(Vec<CharSpecifier> ),\n-    AnyExcept(Vec<CharSpecifier> )\n-}\n-\n-#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-enum CharSpecifier {\n-    SingleChar(char),\n-    CharRange(char, char)\n-}\n-\n-#[deriving(PartialEq)]\n-enum MatchResult {\n-    Match,\n-    SubPatternDoesntMatch,\n-    EntirePatternDoesntMatch\n-}\n-\n-impl Pattern {\n-\n-    /**\n-     * This function compiles Unix shell style patterns: `?` matches any single\n-     * character, `*` matches any (possibly empty) sequence of characters and\n-     * `[...]` matches any character inside the brackets, unless the first\n-     * character is `!` in which case it matches any character except those\n-     * between the `!` and the `]`. Character sequences can also specify ranges\n-     * of characters, as ordered by Unicode, so e.g. `[0-9]` specifies any\n-     * character between 0 and 9 inclusive.\n-     *\n-     * The metacharacters `?`, `*`, `[`, `]` can be matched by using brackets\n-     * (e.g. `[?]`).  When a `]` occurs immediately following `[` or `[!` then\n-     * it is interpreted as being part of, rather then ending, the character\n-     * set, so `]` and NOT `]` can be matched by `[]]` and `[!]]` respectively.\n-     * The `-` character can be specified inside a character sequence pattern by\n-     * placing it at the start or the end, e.g. `[abc-]`.\n-     *\n-     * When a `[` does not have a closing `]` before the end of the string then\n-     * the `[` will be treated literally.\n-     */\n-    pub fn new(pattern: &str) -> Pattern {\n-\n-        let chars = pattern.chars().collect::<Vec<_>>();\n-        let mut tokens = Vec::new();\n-        let mut i = 0;\n-\n-        while i < chars.len() {\n-            match chars[i] {\n-                '?' => {\n-                    tokens.push(AnyChar);\n-                    i += 1;\n-                }\n-                '*' => {\n-                    // *, **, ***, ****, ... are all equivalent\n-                    while i < chars.len() && chars[i] == '*' {\n-                        i += 1;\n-                    }\n-                    tokens.push(AnySequence);\n-                }\n-                '[' => {\n-\n-                    if i <= chars.len() - 4 && chars[i + 1] == '!' {\n-                        match chars.slice_from(i + 3).position_elem(&']') {\n-                            None => (),\n-                            Some(j) => {\n-                                let chars = chars.slice(i + 2, i + 3 + j);\n-                                let cs = parse_char_specifiers(chars);\n-                                tokens.push(AnyExcept(cs));\n-                                i += j + 4;\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                    else if i <= chars.len() - 3 && chars[i + 1] != '!' {\n-                        match chars.slice_from(i + 2).position_elem(&']') {\n-                            None => (),\n-                            Some(j) => {\n-                                let cs = parse_char_specifiers(chars.slice(i + 1, i + 2 + j));\n-                                tokens.push(AnyWithin(cs));\n-                                i += j + 3;\n-                                continue;\n-                            }\n-                        }\n-                    }\n-\n-                    // if we get here then this is not a valid range pattern\n-                    tokens.push(Char('['));\n-                    i += 1;\n-                }\n-                c => {\n-                    tokens.push(Char(c));\n-                    i += 1;\n-                }\n-            }\n-        }\n-\n-        Pattern { tokens: tokens }\n-    }\n-\n-    /**\n-     * Escape metacharacters within the given string by surrounding them in\n-     * brackets. The resulting string will, when compiled into a `Pattern`,\n-     * match the input string and nothing else.\n-     */\n-    pub fn escape(s: &str) -> String {\n-        let mut escaped = String::new();\n-        for c in s.chars() {\n-            match c {\n-                // note that ! does not need escaping because it is only special inside brackets\n-                '?' | '*' | '[' | ']' => {\n-                    escaped.push_char('[');\n-                    escaped.push_char(c);\n-                    escaped.push_char(']');\n-                }\n-                c => {\n-                    escaped.push_char(c);\n-                }\n-            }\n-        }\n-        escaped\n-    }\n-\n-    /**\n-     * Return if the given `str` matches this `Pattern` using the default\n-     * match options (i.e. `MatchOptions::new()`).\n-     *\n-     * # Example\n-     *\n-     * ```rust\n-     * #![allow(deprecated)]\n-     * use glob::Pattern;\n-     *\n-     * assert!(Pattern::new(\"c?t\").matches(\"cat\"));\n-     * assert!(Pattern::new(\"k[!e]tteh\").matches(\"kitteh\"));\n-     * assert!(Pattern::new(\"d*g\").matches(\"doog\"));\n-     * ```\n-     */\n-    pub fn matches(&self, str: &str) -> bool {\n-        self.matches_with(str, MatchOptions::new())\n-    }\n-\n-    /**\n-     * Return if the given `Path`, when converted to a `str`, matches this `Pattern`\n-     * using the default match options (i.e. `MatchOptions::new()`).\n-     */\n-    pub fn matches_path(&self, path: &Path) -> bool {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        path.as_str().map_or(false, |s| {\n-            self.matches(s)\n-        })\n-    }\n-\n-    /**\n-     * Return if the given `str` matches this `Pattern` using the specified match options.\n-     */\n-    pub fn matches_with(&self, str: &str, options: MatchOptions) -> bool {\n-        self.matches_from(None, str, 0, options) == Match\n-    }\n-\n-    /**\n-     * Return if the given `Path`, when converted to a `str`, matches this `Pattern`\n-     * using the specified match options.\n-     */\n-    pub fn matches_path_with(&self, path: &Path, options: MatchOptions) -> bool {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        path.as_str().map_or(false, |s| {\n-            self.matches_with(s, options)\n-        })\n-    }\n-\n-    fn matches_from(&self,\n-                    prev_char: Option<char>,\n-                    mut file: &str,\n-                    i: uint,\n-                    options: MatchOptions) -> MatchResult {\n-\n-        let prev_char = Cell::new(prev_char);\n-\n-        let require_literal = |c| {\n-            (options.require_literal_separator && is_sep(c)) ||\n-            (options.require_literal_leading_dot && c == '.'\n-             && is_sep(prev_char.get().unwrap_or('/')))\n-        };\n-\n-        for (ti, token) in self.tokens.slice_from(i).iter().enumerate() {\n-            match *token {\n-                AnySequence => {\n-                    loop {\n-                        match self.matches_from(prev_char.get(), file, i + ti + 1, options) {\n-                            SubPatternDoesntMatch => (), // keep trying\n-                            m => return m,\n-                        }\n-\n-                        if file.is_empty() {\n-                            return EntirePatternDoesntMatch;\n-                        }\n-\n-                        let (some_c, next) = file.slice_shift_char();\n-                        if require_literal(some_c.unwrap()) {\n-                            return SubPatternDoesntMatch;\n-                        }\n-                        prev_char.set(some_c);\n-                        file = next;\n-                    }\n-                }\n-                _ => {\n-                    if file.is_empty() {\n-                        return EntirePatternDoesntMatch;\n-                    }\n-\n-                    let (some_c, next) = file.slice_shift_char();\n-                    let c = some_c.unwrap();\n-                    let matches = match *token {\n-                        AnyChar => {\n-                            !require_literal(c)\n-                        }\n-                        AnyWithin(ref specifiers) => {\n-                            !require_literal(c) &&\n-                                in_char_specifiers(specifiers.as_slice(),\n-                                                   c,\n-                                                   options)\n-                        }\n-                        AnyExcept(ref specifiers) => {\n-                            !require_literal(c) &&\n-                                !in_char_specifiers(specifiers.as_slice(),\n-                                                    c,\n-                                                    options)\n-                        }\n-                        Char(c2) => {\n-                            chars_eq(c, c2, options.case_sensitive)\n-                        }\n-                        AnySequence => {\n-                            unreachable!()\n-                        }\n-                    };\n-                    if !matches {\n-                        return SubPatternDoesntMatch;\n-                    }\n-                    prev_char.set(some_c);\n-                    file = next;\n-                }\n-            }\n-        }\n-\n-        if file.is_empty() {\n-            Match\n-        } else {\n-            SubPatternDoesntMatch\n-        }\n-    }\n-\n-}\n-\n-// Fills `todo` with paths under `path` to be matched by `patterns[idx]`,\n-// special-casing patterns to match `.` and `..`, and avoiding `readdir()`\n-// calls when there are no metacharacters in the pattern.\n-fn fill_todo(todo: &mut Vec<(Path, uint)>, patterns: &[Pattern], idx: uint, path: &Path,\n-             options: MatchOptions) {\n-    // convert a pattern that's just many Char(_) to a string\n-    fn pattern_as_str(pattern: &Pattern) -> Option<String> {\n-        let mut s = String::new();\n-        for token in pattern.tokens.iter() {\n-            match *token {\n-                Char(c) => s.push_char(c),\n-                _ => return None\n-            }\n-        }\n-        return Some(s);\n-    }\n-\n-    let add = |todo: &mut Vec<_>, next_path: Path| {\n-        if idx + 1 == patterns.len() {\n-            // We know it's good, so don't make the iterator match this path\n-            // against the pattern again. In particular, it can't match\n-            // . or .. globs since these never show up as path components.\n-            todo.push((next_path, -1 as uint));\n-        } else {\n-            fill_todo(todo, patterns, idx + 1, &next_path, options);\n-        }\n-    };\n-\n-    let pattern = &patterns[idx];\n-\n-    match pattern_as_str(pattern) {\n-        Some(s) => {\n-            // This pattern component doesn't have any metacharacters, so we\n-            // don't need to read the current directory to know where to\n-            // continue. So instead of passing control back to the iterator,\n-            // we can just check for that one entry and potentially recurse\n-            // right away.\n-            let special = \".\" == s.as_slice() || \"..\" == s.as_slice();\n-            let next_path = path.join(s.as_slice());\n-            if (special && path.is_dir()) || (!special && next_path.exists()) {\n-                add(todo, next_path);\n-            }\n-        },\n-        None => {\n-            match list_dir_sorted(path) {\n-                Some(entries) => {\n-                    todo.extend(entries.into_iter().map(|x|(x, idx)));\n-\n-                    // Matching the special directory entries . and .. that refer to\n-                    // the current and parent directory respectively requires that\n-                    // the pattern has a leading dot, even if the `MatchOptions` field\n-                    // `require_literal_leading_dot` is not set.\n-                    if pattern.tokens.len() > 0 && pattern.tokens[0] == Char('.') {\n-                        for &special in [\".\", \"..\"].iter() {\n-                            if pattern.matches_with(special, options) {\n-                                add(todo, path.join(special));\n-                            }\n-                        }\n-                    }\n-                }\n-                None => {}\n-            }\n-        }\n-    }\n-}\n-\n-fn parse_char_specifiers(s: &[char]) -> Vec<CharSpecifier> {\n-    let mut cs = Vec::new();\n-    let mut i = 0;\n-    while i < s.len() {\n-        if i + 3 <= s.len() && s[i + 1] == '-' {\n-            cs.push(CharRange(s[i], s[i + 2]));\n-            i += 3;\n-        } else {\n-            cs.push(SingleChar(s[i]));\n-            i += 1;\n-        }\n-    }\n-    cs\n-}\n-\n-fn in_char_specifiers(specifiers: &[CharSpecifier], c: char, options: MatchOptions) -> bool {\n-\n-    for &specifier in specifiers.iter() {\n-        match specifier {\n-            SingleChar(sc) => {\n-                if chars_eq(c, sc, options.case_sensitive) {\n-                    return true;\n-                }\n-            }\n-            CharRange(start, end) => {\n-\n-                // FIXME: work with non-ascii chars properly (issue #1347)\n-                if !options.case_sensitive && c.is_ascii() && start.is_ascii() && end.is_ascii() {\n-\n-                    let start = start.to_ascii().to_lowercase();\n-                    let end = end.to_ascii().to_lowercase();\n-\n-                    let start_up = start.to_uppercase();\n-                    let end_up = end.to_uppercase();\n-\n-                    // only allow case insensitive matching when\n-                    // both start and end are within a-z or A-Z\n-                    if start != start_up && end != end_up {\n-                        let start = start.to_char();\n-                        let end = end.to_char();\n-                        let c = c.to_ascii().to_lowercase().to_char();\n-                        if c >= start && c <= end {\n-                            return true;\n-                        }\n-                    }\n-                }\n-\n-                if c >= start && c <= end {\n-                    return true;\n-                }\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n-/// A helper function to determine if two chars are (possibly case-insensitively) equal.\n-fn chars_eq(a: char, b: char, case_sensitive: bool) -> bool {\n-    if cfg!(windows) && path::windows::is_sep(a) && path::windows::is_sep(b) {\n-        true\n-    } else if !case_sensitive && a.is_ascii() && b.is_ascii() {\n-        // FIXME: work with non-ascii chars properly (issue #1347)\n-        a.to_ascii().eq_ignore_case(b.to_ascii())\n-    } else {\n-        a == b\n-    }\n-}\n-\n-/**\n- * Configuration options to modify the behaviour of `Pattern::matches_with(..)`\n- */\n-#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]\n-pub struct MatchOptions {\n-\n-    /**\n-     * Whether or not patterns should be matched in a case-sensitive manner. This\n-     * currently only considers upper/lower case relationships between ASCII characters,\n-     * but in future this might be extended to work with Unicode.\n-     */\n-    pub case_sensitive: bool,\n-\n-    /**\n-     * If this is true then path-component separator characters (e.g. `/` on Posix)\n-     * must be matched by a literal `/`, rather than by `*` or `?` or `[...]`\n-     */\n-    pub require_literal_separator: bool,\n-\n-    /**\n-     * If this is true then paths that contain components that start with a `.` will\n-     * not match unless the `.` appears literally in the pattern: `*`, `?` or `[...]`\n-     * will not match. This is useful because such files are conventionally considered\n-     * hidden on Unix systems and it might be desirable to skip them when listing files.\n-     */\n-    pub require_literal_leading_dot: bool\n-}\n-\n-impl MatchOptions {\n-\n-    /**\n-     * Constructs a new `MatchOptions` with default field values. This is used\n-     * when calling functions that do not take an explicit `MatchOptions` parameter.\n-     *\n-     * This function always returns this value:\n-     *\n-     * ```rust,ignore\n-     * MatchOptions {\n-     *     case_sensitive: true,\n-     *     require_literal_separator: false.\n-     *     require_literal_leading_dot: false\n-     * }\n-     * ```\n-     */\n-    pub fn new() -> MatchOptions {\n-        MatchOptions {\n-            case_sensitive: true,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: false\n-        }\n-    }\n-\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use std::os;\n-    use super::{glob, Pattern, MatchOptions};\n-\n-    #[test]\n-    fn test_absolute_pattern() {\n-        // assume that the filesystem is not empty!\n-        assert!(glob(\"/*\").next().is_some());\n-        assert!(glob(\"//\").next().is_some());\n-\n-        // check windows absolute paths with host/device components\n-        let root_with_device = os::getcwd().root_path().unwrap().join(\"*\");\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        assert!(glob(root_with_device.as_str().unwrap()).next().is_some());\n-    }\n-\n-    #[test]\n-    fn test_wildcard_optimizations() {\n-        assert!(Pattern::new(\"a*b\").matches(\"a___b\"));\n-        assert!(Pattern::new(\"a**b\").matches(\"a___b\"));\n-        assert!(Pattern::new(\"a***b\").matches(\"a___b\"));\n-        assert!(Pattern::new(\"a*b*c\").matches(\"abc\"));\n-        assert!(!Pattern::new(\"a*b*c\").matches(\"abcd\"));\n-        assert!(Pattern::new(\"a*b*c\").matches(\"a_b_c\"));\n-        assert!(Pattern::new(\"a*b*c\").matches(\"a___b___c\"));\n-        assert!(Pattern::new(\"abc*abc*abc\").matches(\"abcabcabcabcabcabcabc\"));\n-        assert!(!Pattern::new(\"abc*abc*abc\").matches(\"abcabcabcabcabcabcabca\"));\n-        assert!(Pattern::new(\"a*a*a*a*a*a*a*a*a\").matches(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"));\n-        assert!(Pattern::new(\"a*b[xyz]c*d\").matches(\"abxcdbxcddd\"));\n-    }\n-\n-    #[test]\n-    #[cfg_attr(windows, ignore)] // FIXME (#9406)\n-    fn test_lots_of_files() {\n-        // this is a good test because it touches lots of differently named files\n-        glob(\"/*/*/*/*\").skip(10000).next();\n-    }\n-\n-    #[test]\n-    fn test_range_pattern() {\n-\n-        let pat = Pattern::new(\"a[0-9]b\");\n-        for i in range(0u, 10) {\n-            assert!(pat.matches(format!(\"a{}b\", i).as_slice()));\n-        }\n-        assert!(!pat.matches(\"a_b\"));\n-\n-        let pat = Pattern::new(\"a[!0-9]b\");\n-        for i in range(0u, 10) {\n-            assert!(!pat.matches(format!(\"a{}b\", i).as_slice()));\n-        }\n-        assert!(pat.matches(\"a_b\"));\n-\n-        let pats = [\"[a-z123]\", \"[1a-z23]\", \"[123a-z]\"];\n-        for &p in pats.iter() {\n-            let pat = Pattern::new(p);\n-            for c in \"abcdefghijklmnopqrstuvwxyz\".chars() {\n-                assert!(pat.matches(c.to_string().as_slice()));\n-            }\n-            for c in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".chars() {\n-                let options = MatchOptions {case_sensitive: false, .. MatchOptions::new()};\n-                assert!(pat.matches_with(c.to_string().as_slice(), options));\n-            }\n-            assert!(pat.matches(\"1\"));\n-            assert!(pat.matches(\"2\"));\n-            assert!(pat.matches(\"3\"));\n-        }\n-\n-        let pats = [\"[abc-]\", \"[-abc]\", \"[a-c-]\"];\n-        for &p in pats.iter() {\n-            let pat = Pattern::new(p);\n-            assert!(pat.matches(\"a\"));\n-            assert!(pat.matches(\"b\"));\n-            assert!(pat.matches(\"c\"));\n-            assert!(pat.matches(\"-\"));\n-            assert!(!pat.matches(\"d\"));\n-        }\n-\n-        let pat = Pattern::new(\"[2-1]\");\n-        assert!(!pat.matches(\"1\"));\n-        assert!(!pat.matches(\"2\"));\n-\n-        assert!(Pattern::new(\"[-]\").matches(\"-\"));\n-        assert!(!Pattern::new(\"[!-]\").matches(\"-\"));\n-    }\n-\n-    #[test]\n-    fn test_unclosed_bracket() {\n-        // unclosed `[` should be treated literally\n-        assert!(Pattern::new(\"abc[def\").matches(\"abc[def\"));\n-        assert!(Pattern::new(\"abc[!def\").matches(\"abc[!def\"));\n-        assert!(Pattern::new(\"abc[\").matches(\"abc[\"));\n-        assert!(Pattern::new(\"abc[!\").matches(\"abc[!\"));\n-        assert!(Pattern::new(\"abc[d\").matches(\"abc[d\"));\n-        assert!(Pattern::new(\"abc[!d\").matches(\"abc[!d\"));\n-        assert!(Pattern::new(\"abc[]\").matches(\"abc[]\"));\n-        assert!(Pattern::new(\"abc[!]\").matches(\"abc[!]\"));\n-    }\n-\n-    #[test]\n-    fn test_pattern_matches() {\n-        let txt_pat = Pattern::new(\"*hello.txt\");\n-        assert!(txt_pat.matches(\"hello.txt\"));\n-        assert!(txt_pat.matches(\"gareth_says_hello.txt\"));\n-        assert!(txt_pat.matches(\"some/path/to/hello.txt\"));\n-        assert!(txt_pat.matches(\"some\\\\path\\\\to\\\\hello.txt\"));\n-        assert!(txt_pat.matches(\"/an/absolute/path/to/hello.txt\"));\n-        assert!(!txt_pat.matches(\"hello.txt-and-then-some\"));\n-        assert!(!txt_pat.matches(\"goodbye.txt\"));\n-\n-        let dir_pat = Pattern::new(\"*some/path/to/hello.txt\");\n-        assert!(dir_pat.matches(\"some/path/to/hello.txt\"));\n-        assert!(dir_pat.matches(\"a/bigger/some/path/to/hello.txt\"));\n-        assert!(!dir_pat.matches(\"some/path/to/hello.txt-and-then-some\"));\n-        assert!(!dir_pat.matches(\"some/other/path/to/hello.txt\"));\n-    }\n-\n-    #[test]\n-    fn test_pattern_escape() {\n-        let s = \"_[_]_?_*_!_\";\n-        assert_eq!(Pattern::escape(s), \"_[[]_[]]_[?]_[*]_!_\".to_string());\n-        assert!(Pattern::new(Pattern::escape(s).as_slice()).matches(s));\n-    }\n-\n-    #[test]\n-    fn test_pattern_matches_case_insensitive() {\n-\n-        let pat = Pattern::new(\"aBcDeFg\");\n-        let options = MatchOptions {\n-            case_sensitive: false,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: false\n-        };\n-\n-        assert!(pat.matches_with(\"aBcDeFg\", options));\n-        assert!(pat.matches_with(\"abcdefg\", options));\n-        assert!(pat.matches_with(\"ABCDEFG\", options));\n-        assert!(pat.matches_with(\"AbCdEfG\", options));\n-    }\n-\n-    #[test]\n-    fn test_pattern_matches_case_insensitive_range() {\n-\n-        let pat_within = Pattern::new(\"[a]\");\n-        let pat_except = Pattern::new(\"[!a]\");\n-\n-        let options_case_insensitive = MatchOptions {\n-            case_sensitive: false,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: false\n-        };\n-        let options_case_sensitive = MatchOptions {\n-            case_sensitive: true,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: false\n-        };\n-\n-        assert!(pat_within.matches_with(\"a\", options_case_insensitive));\n-        assert!(pat_within.matches_with(\"A\", options_case_insensitive));\n-        assert!(!pat_within.matches_with(\"A\", options_case_sensitive));\n-\n-        assert!(!pat_except.matches_with(\"a\", options_case_insensitive));\n-        assert!(!pat_except.matches_with(\"A\", options_case_insensitive));\n-        assert!(pat_except.matches_with(\"A\", options_case_sensitive));\n-    }\n-\n-    #[test]\n-    fn test_pattern_matches_require_literal_separator() {\n-\n-        let options_require_literal = MatchOptions {\n-            case_sensitive: true,\n-            require_literal_separator: true,\n-            require_literal_leading_dot: false\n-        };\n-        let options_not_require_literal = MatchOptions {\n-            case_sensitive: true,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: false\n-        };\n-\n-        assert!(Pattern::new(\"abc/def\").matches_with(\"abc/def\", options_require_literal));\n-        assert!(!Pattern::new(\"abc?def\").matches_with(\"abc/def\", options_require_literal));\n-        assert!(!Pattern::new(\"abc*def\").matches_with(\"abc/def\", options_require_literal));\n-        assert!(!Pattern::new(\"abc[/]def\").matches_with(\"abc/def\", options_require_literal));\n-\n-        assert!(Pattern::new(\"abc/def\").matches_with(\"abc/def\", options_not_require_literal));\n-        assert!(Pattern::new(\"abc?def\").matches_with(\"abc/def\", options_not_require_literal));\n-        assert!(Pattern::new(\"abc*def\").matches_with(\"abc/def\", options_not_require_literal));\n-        assert!(Pattern::new(\"abc[/]def\").matches_with(\"abc/def\", options_not_require_literal));\n-    }\n-\n-    #[test]\n-    fn test_pattern_matches_require_literal_leading_dot() {\n-\n-        let options_require_literal_leading_dot = MatchOptions {\n-            case_sensitive: true,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: true\n-        };\n-        let options_not_require_literal_leading_dot = MatchOptions {\n-            case_sensitive: true,\n-            require_literal_separator: false,\n-            require_literal_leading_dot: false\n-        };\n-\n-        let f = |options| Pattern::new(\"*.txt\").matches_with(\".hello.txt\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(!f(options_require_literal_leading_dot));\n-\n-        let f = |options| Pattern::new(\".*.*\").matches_with(\".hello.txt\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(f(options_require_literal_leading_dot));\n-\n-        let f = |options| Pattern::new(\"aaa/bbb/*\").matches_with(\"aaa/bbb/.ccc\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(!f(options_require_literal_leading_dot));\n-\n-        let f = |options| Pattern::new(\"aaa/bbb/*\").matches_with(\"aaa/bbb/c.c.c.\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(f(options_require_literal_leading_dot));\n-\n-        let f = |options| Pattern::new(\"aaa/bbb/.*\").matches_with(\"aaa/bbb/.ccc\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(f(options_require_literal_leading_dot));\n-\n-        let f = |options| Pattern::new(\"aaa/?bbb\").matches_with(\"aaa/.bbb\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(!f(options_require_literal_leading_dot));\n-\n-        let f = |options| Pattern::new(\"aaa/[.]bbb\").matches_with(\"aaa/.bbb\", options);\n-        assert!(f(options_not_require_literal_leading_dot));\n-        assert!(!f(options_require_literal_leading_dot));\n-    }\n-\n-    #[test]\n-    fn test_matches_path() {\n-        // on windows, (Path::new(\"a/b\").as_str().unwrap() == \"a\\\\b\"), so this\n-        // tests that / and \\ are considered equivalent on windows\n-        assert!(Pattern::new(\"a/b\").matches_path(&Path::new(\"a/b\")));\n-    }\n-}"}, {"sha": "c7659dc1b9fd7f9cee21308cabd9aa37ed45255e", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -127,14 +127,6 @@ impl<'a,T:Clone> CloneableVector<T> for MaybeOwnedVector<'a,T> {\n     fn to_vec(&self) -> Vec<T> {\n         self.as_slice().to_vec()\n     }\n-\n-    /// Convert `self` into an owned slice, not making a copy if possible.\n-    fn into_vec(self) -> Vec<T> {\n-        match self {\n-            Growable(v) => v.as_slice().to_vec(),\n-            Borrowed(v) => v.to_vec(),\n-        }\n-    }\n }\n \n impl<'a, T: Clone> Clone for MaybeOwnedVector<'a, T> {"}, {"sha": "b592ba477c2a16bfcdfafce0246306c305db35e4", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -89,7 +89,7 @@ impl BasicLoop {\n     fn idle(&mut self) {\n         match self.idle {\n             Some(ref mut idle) => {\n-                if self.idle_active.get_ref().load(atomic::SeqCst) {\n+                if self.idle_active.as_ref().unwrap().load(atomic::SeqCst) {\n                     idle.call();\n                 }\n             }\n@@ -98,7 +98,7 @@ impl BasicLoop {\n     }\n \n     fn has_idle(&self) -> bool {\n-        self.idle.is_some() && self.idle_active.get_ref().load(atomic::SeqCst)\n+        self.idle.is_some() && self.idle_active.as_ref().unwrap().load(atomic::SeqCst)\n     }\n }\n "}, {"sha": "6ba29cf5a3d7ef898a6c3e75b0fee722d7a84791", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -193,7 +193,7 @@ impl Scheduler {\n         // Before starting our first task, make sure the idle callback\n         // is active. As we do not start in the sleep state this is\n         // important.\n-        self.idle_callback.get_mut_ref().resume();\n+        self.idle_callback.as_mut().unwrap().resume();\n \n         // Now, as far as all the scheduler state is concerned, we are inside\n         // the \"scheduler\" context. The scheduler immediately hands over control\n@@ -213,10 +213,10 @@ impl Scheduler {\n         // cleaning up the memory it uses. As we didn't actually call\n         // task.run() on the scheduler task we never get through all\n         // the cleanup code it runs.\n-        rtdebug!(\"stopping scheduler {}\", stask.sched.get_ref().sched_id());\n+        rtdebug!(\"stopping scheduler {}\", stask.sched.as_ref().unwrap().sched_id());\n \n         // Should not have any messages\n-        let message = stask.sched.get_mut_ref().message_queue.pop();\n+        let message = stask.sched.as_mut().unwrap().message_queue.pop();\n         rtassert!(match message { msgq::Empty => true, _ => false });\n \n         stask.task.take().unwrap().drop();\n@@ -279,7 +279,7 @@ impl Scheduler {\n \n         // Assume that we need to continue idling unless we reach the\n         // end of this function without performing an action.\n-        self.idle_callback.get_mut_ref().resume();\n+        self.idle_callback.as_mut().unwrap().resume();\n \n         // First we check for scheduler messages, these are higher\n         // priority than regular tasks.\n@@ -333,12 +333,12 @@ impl Scheduler {\n             let handle = sched.make_handle();\n             sched.sleeper_list.push(handle);\n             // Since we are sleeping, deactivate the idle callback.\n-            sched.idle_callback.get_mut_ref().pause();\n+            sched.idle_callback.as_mut().unwrap().pause();\n         } else {\n             rtdebug!(\"not sleeping, already doing so or no_sleep set\");\n             // We may not be sleeping, but we still need to deactivate\n             // the idle callback.\n-            sched.idle_callback.get_mut_ref().pause();\n+            sched.idle_callback.as_mut().unwrap().pause();\n         }\n \n         // Finished a cycle without using the Scheduler. Place it back\n@@ -633,7 +633,7 @@ impl Scheduler {\n         unsafe {\n \n             let sched: &mut Scheduler =\n-                mem::transmute(&**next_task.sched.get_mut_ref());\n+                mem::transmute(&**next_task.sched.as_mut().unwrap());\n \n             let current_task: &mut GreenTask = match sched.cleanup_job {\n                 Some(CleanupJob { task: ref mut task, .. }) => &mut **task,\n@@ -661,7 +661,7 @@ impl Scheduler {\n         let mut current_task: Box<GreenTask> = unsafe {\n             mem::transmute(current_task_dupe)\n         };\n-        current_task.sched.get_mut_ref().run_cleanup_job();\n+        current_task.sched.as_mut().unwrap().run_cleanup_job();\n \n         // See the comments in switch_running_tasks_and_then for why a lock\n         // is acquired here. This is the resumption points and the \"bounce\"\n@@ -682,9 +682,9 @@ impl Scheduler {\n         -> (&'a mut Context, &'a mut Context)\n     {\n         let current_task_context =\n-            &mut current_task.coroutine.get_mut_ref().saved_context;\n+            &mut current_task.coroutine.as_mut().unwrap().saved_context;\n         let next_task_context =\n-                &mut next_task.coroutine.get_mut_ref().saved_context;\n+                &mut next_task.coroutine.as_mut().unwrap().saved_context;\n         unsafe {\n             (mem::transmute(current_task_context),\n              mem::transmute(next_task_context))\n@@ -1050,7 +1050,7 @@ mod test {\n         let mut task = Local::borrow(None::<Task>);\n         match task.maybe_take_runtime::<GreenTask>() {\n             Some(green) => {\n-                let ret = green.sched.get_ref().sched_id();\n+                let ret = green.sched.as_ref().unwrap().sched_id();\n                 task.put_runtime(green);\n                 return ret;\n             }\n@@ -1190,8 +1190,8 @@ mod test {\n             fn on_appropriate_sched() -> bool {\n                 use task::{TypeGreen, TypeSched, HomeSched};\n                 let task = GreenTask::convert(Local::take());\n-                let sched_id = task.sched.get_ref().sched_id();\n-                let run_any = task.sched.get_ref().run_anything;\n+                let sched_id = task.sched.as_ref().unwrap().sched_id();\n+                let run_any = task.sched.as_ref().unwrap().run_anything;\n                 let ret = match task.task_type {\n                     TypeGreen(Some(AnySched)) => {\n                         run_any"}, {"sha": "b6bd8c3cec4a735d315cb425cab6450cb2417956", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -100,7 +100,7 @@ extern fn bootstrap_green_task(task: uint, code: *mut (), env: *mut ()) -> ! {\n \n     // First code after swap to this new context. Run our cleanup job\n     task.pool_id = {\n-        let sched = task.sched.get_mut_ref();\n+        let sched = task.sched.as_mut().unwrap();\n         sched.run_cleanup_job();\n         sched.task_state.increment();\n         sched.pool_id\n@@ -179,7 +179,7 @@ impl GreenTask {\n \n         let mut green = GreenTask::new(pool, stack_size, f);\n         {\n-            let task = green.task.get_mut_ref();\n+            let task = green.task.as_mut().unwrap();\n             task.name = name;\n             task.death.on_exit = on_exit;\n         }\n@@ -314,7 +314,7 @@ impl GreenTask {\n     fn reawaken_remotely(mut self: Box<GreenTask>) {\n         unsafe {\n             let mtx = &mut self.nasty_deschedule_lock as *mut NativeMutex;\n-            let handle = self.handle.get_mut_ref() as *mut SchedHandle;\n+            let handle = self.handle.as_mut().unwrap() as *mut SchedHandle;\n             let _guard = (*mtx).lock();\n             (*handle).send(RunOnce(self));\n         }\n@@ -460,7 +460,7 @@ impl Runtime for GreenTask {\n         //\n         // Upon returning, our task is back in TLS and we're good to return.\n         let sibling = {\n-            let sched = bomb.inner.get_mut_ref().sched.get_mut_ref();\n+            let sched = bomb.inner.as_mut().unwrap().sched.as_mut().unwrap();\n             GreenTask::configure(&mut sched.stack_pool, opts, f)\n         };\n         let mut me = bomb.inner.take().unwrap();\n@@ -470,7 +470,7 @@ impl Runtime for GreenTask {\n \n     // Local I/O is provided by the scheduler's event loop\n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n-        match self.sched.get_mut_ref().event_loop.io() {\n+        match self.sched.as_mut().unwrap().event_loop.io() {\n             Some(io) => Some(rtio::LocalIo::new(io)),\n             None => None,\n         }"}, {"sha": "8335cc16d649f6767ad3a94ebec6433c28fb33d6", "filename": "src/libhexfloat/lib.rs", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,189 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Syntax extension to create floating point literals from hexadecimal strings\n-\n-Once loaded, hexfloat!() is called with a string containing the hexadecimal\n-floating-point literal, and an optional type (f32 or f64).\n-If the type is omitted, the literal is treated the same as a normal unsuffixed\n-literal.\n-\n-# Examples\n-\n-To load the extension and use it:\n-\n-```rust,ignore\n-#[phase(plugin)]\n-extern crate hexfloat;\n-\n-fn main() {\n-    let val = hexfloat!(\"0x1.ffffb4\", f32);\n-}\n-```\n-\n-# References\n-\n-* [ExploringBinary: hexadecimal floating point constants]\n-  (http://www.exploringbinary.com/hexadecimal-floating-point-constants/)\n-\n-*/\n-\n-#![crate_name = \"hexfloat\"]\n-#![deprecated = \"This is now a cargo package located at: \\\n-                 https://github.com/rust-lang/hexfloat\"]\n-#![allow(deprecated)]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(plugin_registrar)]\n-\n-extern crate syntax;\n-extern crate rustc;\n-\n-use syntax::ast;\n-use syntax::codemap::{Span, mk_sp};\n-use syntax::ext::base;\n-use syntax::ext::base::{ExtCtxt, MacExpr};\n-use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n-use syntax::ptr::P;\n-use rustc::plugin::Registry;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"hexfloat\", expand_syntax_ext);\n-}\n-\n-//Check if the literal is valid (as LLVM expects),\n-//and return a descriptive error if not.\n-fn hex_float_lit_err(s: &str) -> Option<(uint, String)> {\n-    let mut chars = s.chars().peekable();\n-    let mut i = 0;\n-    if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n-    if chars.next() != Some('0') {\n-        return Some((i, \"Expected '0'\".to_string()));\n-    } i+=1;\n-    if chars.next() != Some('x') {\n-        return Some((i, \"Expected 'x'\".to_string()));\n-    } i+=1;\n-    let mut d_len = 0i;\n-    for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; d_len += 1;}\n-    if chars.next() != Some('.') {\n-        return Some((i, \"Expected '.'\".to_string()));\n-    } i+=1;\n-    let mut f_len = 0i;\n-    for _ in chars.take_while(|c| c.is_digit_radix(16)) { chars.next(); i+=1; f_len += 1;}\n-    if d_len == 0 && f_len == 0 {\n-        return Some((i, \"Expected digits before or after decimal \\\n-                         point\".to_string()));\n-    }\n-    if chars.next() != Some('p') {\n-        return Some((i, \"Expected 'p'\".to_string()));\n-    } i+=1;\n-    if chars.peek() == Some(&'-') { chars.next(); i+= 1 }\n-    let mut e_len = 0i;\n-    for _ in chars.take_while(|c| c.is_digit()) { chars.next(); i+=1; e_len += 1}\n-    if e_len == 0 {\n-        return Some((i, \"Expected exponent digits\".to_string()));\n-    }\n-    match chars.next() {\n-        None => None,\n-        Some(_) => Some((i, \"Expected end of string\".to_string()))\n-    }\n-}\n-\n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-                         -> Box<base::MacResult+'static> {\n-    let (expr, ty_lit) = parse_tts(cx, tts);\n-\n-    let ty = match ty_lit {\n-        None => None,\n-        Some(Ident{ident, span}) => match token::get_ident(ident).get() {\n-            \"f32\" => Some(ast::TyF32),\n-            \"f64\" => Some(ast::TyF64),\n-            _ => {\n-                cx.span_err(span, \"invalid floating point type in hexfloat!\");\n-                None\n-            }\n-        }\n-    };\n-\n-    let s = match expr.node {\n-        // expression is a literal\n-        ast::ExprLit(ref lit) => match lit.node {\n-            // string literal\n-            ast::LitStr(ref s, _) => {\n-                s.clone()\n-            }\n-            _ => {\n-                cx.span_err(expr.span, \"unsupported literal in hexfloat!\");\n-                return base::DummyResult::expr(sp);\n-            }\n-        },\n-        _ => {\n-            cx.span_err(expr.span, \"non-literal in hexfloat!\");\n-            return base::DummyResult::expr(sp);\n-        }\n-    };\n-\n-    {\n-        let err = hex_float_lit_err(s.get());\n-        match err {\n-            Some((err_pos, err_str)) => {\n-                let pos = expr.span.lo + syntax::codemap::Pos::from_uint(err_pos + 1);\n-                let span = syntax::codemap::mk_sp(pos,pos);\n-                cx.span_err(span,\n-                            format!(\"invalid hex float literal in hexfloat!: \\\n-                                     {}\",\n-                                    err_str).as_slice());\n-                return base::DummyResult::expr(sp);\n-            }\n-            _ => ()\n-        }\n-    }\n-\n-    let lit = match ty {\n-        None => ast::LitFloatUnsuffixed(s),\n-        Some (ty) => ast::LitFloat(s, ty)\n-    };\n-    MacExpr::new(cx.expr_lit(sp, lit))\n-}\n-\n-struct Ident {\n-    ident: ast::Ident,\n-    span: Span\n-}\n-\n-fn parse_tts(cx: &ExtCtxt,\n-             tts: &[ast::TokenTree]) -> (P<ast::Expr>, Option<Ident>) {\n-    let p = &mut cx.new_parser_from_tts(tts);\n-    let ex = p.parse_expr();\n-    let id = if p.token == token::EOF {\n-        None\n-    } else {\n-        p.expect(&token::COMMA);\n-        let lo = p.span.lo;\n-        let ident = p.parse_ident();\n-        let hi = p.last_span.hi;\n-        Some(Ident{ident: ident, span: mk_sp(lo, hi)})\n-    };\n-    if p.token != token::EOF {\n-        p.unexpected();\n-    }\n-    (ex, id)\n-}\n-\n-// FIXME (10872): This is required to prevent an LLVM assert on Windows\n-#[test]\n-fn dummy_test() { }"}, {"sha": "d40438e4272a3bd0f69892b7e8537d3938cb803c", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -11,7 +11,7 @@\n use libc::{c_char, c_int};\n use libc;\n use std::mem;\n-use std::ptr::{null, mut_null};\n+use std::ptr::{null, null_mut};\n use std::rt::rtio;\n use std::rt::rtio::IoError;\n \n@@ -38,16 +38,16 @@ impl GetAddrInfoRequest {\n                 ai_socktype: 0,\n                 ai_protocol: 0,\n                 ai_addrlen: 0,\n-                ai_canonname: mut_null(),\n-                ai_addr: mut_null(),\n-                ai_next: mut_null()\n+                ai_canonname: null_mut(),\n+                ai_addr: null_mut(),\n+                ai_next: null_mut()\n             }\n         });\n \n         let hint_ptr = hint.as_ref().map_or(null(), |x| {\n             x as *const libc::addrinfo\n         });\n-        let mut res = mut_null();\n+        let mut res = null_mut();\n \n         // Make the call\n         let s = unsafe {"}, {"sha": "eed3df28b8f33885e260b2761d1a84dd2519dcf5", "filename": "src/libnative/io/c_windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Fc_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Fc_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_windows.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -141,8 +141,8 @@ pub mod compat {\n     // layer (after it's loaded) shouldn't be any slower than a regular DLL\n     // call.\n     unsafe fn store_func(ptr: *mut uint, module: &str, symbol: &str, fallback: uint) {\n-        let module: Vec<u16> = module.utf16_units().collect();\n-        let module = module.append_one(0);\n+        let mut module: Vec<u16> = module.utf16_units().collect();\n+        module.push(0);\n         symbol.with_c_str(|symbol| {\n             let handle = GetModuleHandleW(module.as_ptr());\n             let func: uint = transmute(GetProcAddress(handle, symbol));"}, {"sha": "eb4d4f22132d08ed2237150d40fe6e4909c960a1", "filename": "src/libnative/io/file_windows.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Ffile_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Ffile_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_windows.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -253,7 +253,11 @@ impl Drop for Inner {\n \n pub fn to_utf16(s: &CString) -> IoResult<Vec<u16>> {\n     match s.as_str() {\n-        Some(s) => Ok(s.utf16_units().collect::<Vec<u16>>().append_one(0)),\n+        Some(s) => Ok({\n+            let mut s = s.utf16_units().collect::<Vec<u16>>();\n+            s.push(0);\n+            s\n+        }),\n         None => Err(IoError {\n             code: libc::ERROR_INVALID_NAME as uint,\n             extra: 0,"}, {"sha": "d1368ad31f475336b27f9c77d246d5e2a19eb2f9", "filename": "src/libnative/io/helper_thread.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fhelper_thread.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -22,13 +22,14 @@\n \n #![macro_escape]\n \n+use std::cell::UnsafeCell;\n use std::mem;\n use std::rt::bookkeeping;\n use std::rt::mutex::StaticNativeMutex;\n use std::rt;\n-use std::cell::UnsafeCell;\n+use std::task::TaskBuilder;\n \n-use task;\n+use NativeTaskBuilder;\n \n /// A structure for management of a helper thread.\n ///\n@@ -86,7 +87,7 @@ impl<M: Send> Helper<M> {\n                 *self.signal.get() = send as uint;\n \n                 let t = f();\n-                task::spawn(proc() {\n+                TaskBuilder::new().native().spawn(proc() {\n                     bookkeeping::decrement();\n                     helper(receive, rx, t);\n                     self.lock.lock().signal()"}, {"sha": "bc08ede39f7695ec80accd63bb11ea6c1a34b397", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -359,7 +359,7 @@ impl rtio::RtioPipe for UnixStream {\n \n         let mut bytes_read = 0;\n         let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n-        overlapped.hEvent = self.read.get_ref().handle();\n+        overlapped.hEvent = self.read.as_ref().unwrap().handle();\n \n         // Pre-flight check to see if the reading half has been closed. This\n         // must be done before issuing the ReadFile request, but after we\n@@ -431,7 +431,7 @@ impl rtio::RtioPipe for UnixStream {\n \n         let mut offset = 0;\n         let mut overlapped: libc::OVERLAPPED = unsafe { mem::zeroed() };\n-        overlapped.hEvent = self.write.get_ref().handle();\n+        overlapped.hEvent = self.write.as_ref().unwrap().handle();\n \n         while offset < buf.len() {\n             let mut bytes_written = 0;"}, {"sha": "d69042175f7ccbecd215edf3d5a58aa6f7c0c346", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -350,8 +350,8 @@ fn spawn_process_os(cfg: ProcessConfig,\n                         lpSecurityDescriptor: ptr::null_mut(),\n                         bInheritHandle: 1,\n                     };\n-                    let filename: Vec<u16> = \"NUL\".utf16_units().collect();\n-                    let filename = filename.append_one(0);\n+                    let mut filename: Vec<u16> = \"NUL\".utf16_units().collect();\n+                    filename.push(0);\n                     *slot = libc::CreateFileW(filename.as_ptr(),\n                                               access,\n                                               libc::FILE_SHARE_READ |\n@@ -396,7 +396,7 @@ fn spawn_process_os(cfg: ProcessConfig,\n         with_envp(cfg.env, |envp| {\n             with_dirp(cfg.cwd, |dirp| {\n                 let mut cmd_str: Vec<u16> = cmd_str.as_slice().utf16_units().collect();\n-                cmd_str = cmd_str.append_one(0);\n+                cmd_str.push(0);\n                 let created = CreateProcessW(ptr::null(),\n                                              cmd_str.as_mut_ptr(),\n                                              ptr::null_mut(),\n@@ -473,7 +473,7 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n     append_arg(&mut cmd, prog.as_str()\n                              .expect(\"expected program name to be utf-8 encoded\"));\n     for arg in args.iter() {\n-        cmd.push_char(' ');\n+        cmd.push(' ');\n         append_arg(&mut cmd, arg.as_str()\n                                 .expect(\"expected argument to be utf-8 encoded\"));\n     }\n@@ -485,19 +485,19 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n         // it will be dropped entirely when parsed on the other end.\n         let quote = arg.chars().any(|c| c == ' ' || c == '\\t') || arg.len() == 0;\n         if quote {\n-            cmd.push_char('\"');\n+            cmd.push('\"');\n         }\n         let argvec: Vec<char> = arg.chars().collect();\n         for i in range(0u, argvec.len()) {\n-            append_char_at(cmd, &argvec, i);\n+            append_char_at(cmd, argvec.as_slice(), i);\n         }\n         if quote {\n-            cmd.push_char('\"');\n+            cmd.push('\"');\n         }\n     }\n \n-    fn append_char_at(cmd: &mut String, arg: &Vec<char>, i: uint) {\n-        match *arg.get(i) {\n+    fn append_char_at(cmd: &mut String, arg: &[char], i: uint) {\n+        match arg[i] {\n             '\"' => {\n                 // Escape quotes.\n                 cmd.push_str(\"\\\\\\\"\");\n@@ -508,20 +508,20 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n                     cmd.push_str(\"\\\\\\\\\");\n                 } else {\n                     // Pass other backslashes through unescaped.\n-                    cmd.push_char('\\\\');\n+                    cmd.push('\\\\');\n                 }\n             }\n             c => {\n-                cmd.push_char(c);\n+                cmd.push(c);\n             }\n         }\n     }\n \n-    fn backslash_run_ends_in_quote(s: &Vec<char>, mut i: uint) -> bool {\n-        while i < s.len() && *s.get(i) == '\\\\' {\n+    fn backslash_run_ends_in_quote(s: &[char], mut i: uint) -> bool {\n+        while i < s.len() && s[i] == '\\\\' {\n             i += 1;\n         }\n-        return i < s.len() && *s.get(i) == '\"';\n+        return i < s.len() && s[i] == '\"';\n     }\n }\n \n@@ -817,9 +817,8 @@ fn with_dirp<T>(d: Option<&CString>, cb: |*const u16| -> T) -> T {\n       Some(dir) => {\n           let dir_str = dir.as_str()\n                            .expect(\"expected workingdirectory to be utf-8 encoded\");\n-          let dir_str: Vec<u16> = dir_str.utf16_units().collect();\n-          let dir_str = dir_str.append_one(0);\n-\n+          let mut dir_str: Vec<u16> = dir_str.utf16_units().collect();\n+          dir_str.push(0);\n           cb(dir_str.as_ptr())\n       },\n       None => cb(ptr::null())"}, {"sha": "6f57a5e88ba14f1c337cd0a9a26417b18d31cdea", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -115,7 +115,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n     // signals the first requests in the queue, possible re-enqueueing it.\n     fn signal(active: &mut Vec<Box<Inner>>,\n               dead: &mut Vec<(uint, Box<Inner>)>) {\n-        let mut timer = match active.shift() {\n+        let mut timer = match active.remove(0) {\n             Some(timer) => timer, None => return\n         };\n         let mut cb = timer.cb.take().unwrap();\n@@ -137,15 +137,15 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n             let now = now();\n             // If this request has already expired, then signal it and go\n             // through another iteration\n-            if active.get(0).target <= now {\n+            if active[0].target <= now {\n                 signal(&mut active, &mut dead);\n                 continue;\n             }\n \n             // The actual timeout listed in the requests array is an\n             // absolute date, so here we translate the absolute time to a\n             // relative time.\n-            let tm = active.get(0).target - now;\n+            let tm = active[0].target - now;\n             timeout.tv_sec = (tm / 1000) as libc::time_t;\n             timeout.tv_usec = ((tm % 1000) * 1000) as libc::suseconds_t;\n             &mut timeout as *mut libc::timeval"}, {"sha": "cf2a0f9dda444d93cf1d4c566113ddcd5f72953e", "filename": "src/libnative/io/tty_windows.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Ftty_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Fio%2Ftty_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftty_windows.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -36,7 +36,7 @@ use libc::types::os::arch::extra::LPCVOID;\n use std::io::MemReader;\n use std::ptr;\n use std::rt::rtio::{IoResult, IoError, RtioTTY};\n-use std::str::{from_utf16, from_utf8};\n+use std::str::from_utf8;\n \n fn invalid_encoding() -> IoError {\n     IoError {\n@@ -103,7 +103,7 @@ impl RtioTTY for WindowsTTY {\n                 _ => (),\n             };\n             utf16.truncate(num as uint);\n-            let utf8 = match from_utf16(utf16.as_slice()) {\n+            let utf8 = match String::from_utf16(utf16.as_slice()) {\n                 Some(utf8) => utf8.into_bytes(),\n                 None => return Err(invalid_encoding()),\n             };\n@@ -115,7 +115,9 @@ impl RtioTTY for WindowsTTY {\n \n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let utf16 = match from_utf8(buf) {\n-            Some(utf8) => utf8.to_utf16(),\n+            Some(utf8) => {\n+                utf8.as_slice().utf16_units().collect::<Vec<u16>>()\n+            }\n             None => return Err(invalid_encoding()),\n         };\n         let mut num: DWORD = 0;"}, {"sha": "656c7e4103c6eb29d0281b3de3625153f3addca8", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -56,7 +56,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![deny(unused_result, unused_must_use)]\n-#![allow(non_camel_case_types, deprecated)]\n+#![allow(non_camel_case_types)]\n #![allow(unknown_features)]\n #![feature(default_type_params, lang_items, slicing_syntax)]\n "}, {"sha": "d90535428dac6cdef2f87269ffdf4c3676530264", "filename": "src/libnative/task.rs", "status": "modified", "additions": 45, "deletions": 57, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -26,7 +26,6 @@ use std::rt::thread::Thread;\n use std::rt;\n \n use io;\n-use task;\n use std::task::{TaskBuilder, Spawner};\n \n /// Creates a new Task which is ready to execute as a 1:1 task.\n@@ -48,61 +47,49 @@ fn ops() -> Box<Ops> {\n     }\n }\n \n-/// Spawns a function with the default configuration\n-#[deprecated = \"use the native method of NativeTaskBuilder instead\"]\n-pub fn spawn(f: proc():Send) {\n-    spawn_opts(TaskOpts { name: None, stack_size: None, on_exit: None }, f)\n-}\n-\n-/// Spawns a new task given the configuration options and a procedure to run\n-/// inside the task.\n-#[deprecated = \"use the native method of NativeTaskBuilder instead\"]\n-pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n-    let TaskOpts { name, stack_size, on_exit } = opts;\n-\n-    let mut task = box Task::new();\n-    task.name = name;\n-    task.death.on_exit = on_exit;\n-\n-    let stack = stack_size.unwrap_or(rt::min_stack());\n-    let task = task;\n-    let ops = ops();\n-\n-    // Note that this increment must happen *before* the spawn in order to\n-    // guarantee that if this task exits it will always end up waiting for the\n-    // spawned task to exit.\n-    let token = bookkeeping::increment();\n-\n-    // Spawning a new OS thread guarantees that __morestack will never get\n-    // triggered, but we must manually set up the actual stack bounds once this\n-    // function starts executing. This raises the lower limit by a bit because\n-    // by the time that this function is executing we've already consumed at\n-    // least a little bit of stack (we don't know the exact byte address at\n-    // which our stack started).\n-    Thread::spawn_stack(stack, proc() {\n-        let something_around_the_top_of_the_stack = 1;\n-        let addr = &something_around_the_top_of_the_stack as *const int;\n-        let my_stack = addr as uint;\n-        unsafe {\n-            stack::record_os_managed_stack_bounds(my_stack - stack + 1024, my_stack);\n-        }\n-        let mut ops = ops;\n-        ops.stack_bounds = (my_stack - stack + 1024, my_stack);\n-\n-        let mut f = Some(f);\n-        let mut task = task;\n-        task.put_runtime(ops);\n-        drop(task.run(|| { f.take().unwrap()() }).destroy());\n-        drop(token);\n-    })\n-}\n-\n /// A spawner for native tasks\n pub struct NativeSpawner;\n \n impl Spawner for NativeSpawner {\n     fn spawn(self, opts: TaskOpts, f: proc():Send) {\n-        spawn_opts(opts, f)\n+        let TaskOpts { name, stack_size, on_exit } = opts;\n+\n+        let mut task = box Task::new();\n+        task.name = name;\n+        task.death.on_exit = on_exit;\n+\n+        let stack = stack_size.unwrap_or(rt::min_stack());\n+        let task = task;\n+        let ops = ops();\n+\n+        // Note that this increment must happen *before* the spawn in order to\n+        // guarantee that if this task exits it will always end up waiting for\n+        // the spawned task to exit.\n+        let token = bookkeeping::increment();\n+\n+        // Spawning a new OS thread guarantees that __morestack will never get\n+        // triggered, but we must manually set up the actual stack bounds once\n+        // this function starts executing. This raises the lower limit by a bit\n+        // because by the time that this function is executing we've already\n+        // consumed at least a little bit of stack (we don't know the exact byte\n+        // address at which our stack started).\n+        Thread::spawn_stack(stack, proc() {\n+            let something_around_the_top_of_the_stack = 1;\n+            let addr = &something_around_the_top_of_the_stack as *const int;\n+            let my_stack = addr as uint;\n+            unsafe {\n+                stack::record_os_managed_stack_bounds(my_stack - stack + 1024,\n+                                                      my_stack);\n+            }\n+            let mut ops = ops;\n+            ops.stack_bounds = (my_stack - stack + 1024, my_stack);\n+\n+            let mut f = Some(f);\n+            let mut task = task;\n+            task.put_runtime(ops);\n+            drop(task.run(|| { f.take().unwrap()() }).destroy());\n+            drop(token);\n+        })\n     }\n }\n \n@@ -270,7 +257,7 @@ impl rt::Runtime for Ops {\n         cur_task.put_runtime(self);\n         Local::put(cur_task);\n \n-        task::spawn_opts(opts, f);\n+        NativeSpawner.spawn(opts, f);\n     }\n \n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {\n@@ -283,8 +270,9 @@ mod tests {\n     use std::rt::local::Local;\n     use std::rt::task::{Task, TaskOpts};\n     use std::task;\n-    use std::task::TaskBuilder;\n-    use super::{spawn, spawn_opts, Ops, NativeTaskBuilder};\n+    use std::task::{TaskBuilder, Spawner};\n+\n+    use super::{Ops, NativeTaskBuilder, NativeSpawner};\n \n     #[test]\n     fn smoke() {\n@@ -312,7 +300,7 @@ mod tests {\n         opts.stack_size = Some(20 * 4096);\n         let (tx, rx) = channel();\n         opts.on_exit = Some(proc(r) tx.send(r));\n-        spawn_opts(opts, proc() {});\n+        NativeSpawner.spawn(opts, proc() {});\n         assert!(rx.recv().is_ok());\n     }\n \n@@ -321,7 +309,7 @@ mod tests {\n         let mut opts = TaskOpts::new();\n         let (tx, rx) = channel();\n         opts.on_exit = Some(proc(r) tx.send(r));\n-        spawn_opts(opts, proc() { fail!() });\n+        NativeSpawner.spawn(opts, proc() { fail!() });\n         assert!(rx.recv().is_err());\n     }\n \n@@ -357,7 +345,7 @@ mod tests {\n     #[test]\n     fn spawn_inherits() {\n         let (tx, rx) = channel();\n-        spawn(proc() {\n+        TaskBuilder::new().spawner(NativeSpawner).spawn(proc() {\n             spawn(proc() {\n                 let mut task: Box<Task> = Local::take();\n                 match task.maybe_take_runtime::<Ops>() {"}, {"sha": "e52d62a040be83dc5fdf5c7ec0f4aac912596606", "filename": "src/libnum/bigint.rs", "status": "removed", "additions": 0, "deletions": 2961, "changes": 2961, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,2961 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A Big integer (signed version: `BigInt`, unsigned version: `BigUint`).\n-//!\n-//! A `BigUint` is represented as an array of `BigDigit`s.\n-//! A `BigInt` is a combination of `BigUint` and `Sign`.\n-//!\n-//! Common numerical operations are overloaded, so we can treat them\n-//! the same way we treat other numbers.\n-//!\n-//! ## Example\n-//!\n-//! ```rust\n-//! # #![allow(deprecated)]\n-//! use num::bigint::BigUint;\n-//! use std::num::{Zero, One};\n-//! use std::mem::replace;\n-//!\n-//! // Calculate large fibonacci numbers.\n-//! fn fib(n: uint) -> BigUint {\n-//!     let mut f0: BigUint = Zero::zero();\n-//!     let mut f1: BigUint = One::one();\n-//!     for _ in range(0, n) {\n-//!         let f2 = f0 + f1;\n-//!         // This is a low cost way of swapping f0 with f1 and f1 with f2.\n-//!         f0 = replace(&mut f1, f2);\n-//!     }\n-//!     f0\n-//! }\n-//!\n-//! // This is a very large number.\n-//! println!(\"fib(1000) = {}\", fib(1000));\n-//! ```\n-//!\n-//! It's easy to generate large random numbers:\n-//!\n-//! ```rust\n-//! # #![allow(deprecated)]\n-//! use num::bigint::{ToBigInt, RandBigInt};\n-//! use std::rand;\n-//!\n-//! let mut rng = rand::task_rng();\n-//! let a = rng.gen_bigint(1000u);\n-//!\n-//! let low = -10000i.to_bigint().unwrap();\n-//! let high = 10000i.to_bigint().unwrap();\n-//! let b = rng.gen_bigint_range(&low, &high);\n-//!\n-//! // Probably an even larger number.\n-//! println!(\"{}\", a * b);\n-//! ```\n-\n-use Integer;\n-use rand::Rng;\n-\n-use std::{cmp, fmt, hash};\n-use std::default::Default;\n-use std::from_str::FromStr;\n-use std::num::CheckedDiv;\n-use std::num::{ToPrimitive, FromPrimitive};\n-use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n-use std::string::String;\n-use std::{uint, i64, u64};\n-\n-/// A `BigDigit` is a `BigUint`'s composing element.\n-pub type BigDigit = u32;\n-\n-/// A `DoubleBigDigit` is the internal type used to do the computations.  Its\n-/// size is the double of the size of `BigDigit`.\n-pub type DoubleBigDigit = u64;\n-\n-pub const ZERO_BIG_DIGIT: BigDigit = 0;\n-static ZERO_VEC: [BigDigit, ..1] = [ZERO_BIG_DIGIT];\n-\n-#[allow(non_snake_case)]\n-pub mod BigDigit {\n-    use super::BigDigit;\n-    use super::DoubleBigDigit;\n-\n-    // `DoubleBigDigit` size dependent\n-    #[allow(non_uppercase_statics)]\n-    pub const bits: uint = 32;\n-\n-    #[allow(non_uppercase_statics)]\n-    pub const base: DoubleBigDigit = 1 << bits;\n-    #[allow(non_uppercase_statics)]\n-    static lo_mask: DoubleBigDigit = (-1 as DoubleBigDigit) >> bits;\n-\n-    #[inline]\n-    fn get_hi(n: DoubleBigDigit) -> BigDigit { (n >> bits) as BigDigit }\n-    #[inline]\n-    fn get_lo(n: DoubleBigDigit) -> BigDigit { (n & lo_mask) as BigDigit }\n-\n-    /// Split one `DoubleBigDigit` into two `BigDigit`s.\n-    #[inline]\n-    pub fn from_doublebigdigit(n: DoubleBigDigit) -> (BigDigit, BigDigit) {\n-        (get_hi(n), get_lo(n))\n-    }\n-\n-    /// Join two `BigDigit`s into one `DoubleBigDigit`\n-    #[inline]\n-    pub fn to_doublebigdigit(hi: BigDigit, lo: BigDigit) -> DoubleBigDigit {\n-        (lo as DoubleBigDigit) | ((hi as DoubleBigDigit) << bits)\n-    }\n-}\n-\n-/// A big unsigned integer type.\n-///\n-/// A `BigUint`-typed value `BigUint { data: vec!(a, b, c) }` represents a number\n-/// `(a + b * BigDigit::base + c * BigDigit::base^2)`.\n-#[deriving(Clone)]\n-pub struct BigUint {\n-    data: Vec<BigDigit>\n-}\n-\n-impl PartialEq for BigUint {\n-    #[inline]\n-    fn eq(&self, other: &BigUint) -> bool {\n-        match self.cmp(other) { Equal => true, _ => false }\n-    }\n-}\n-impl Eq for BigUint {}\n-\n-impl PartialOrd for BigUint {\n-    #[inline]\n-    fn partial_cmp(&self, other: &BigUint) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for BigUint {\n-    #[inline]\n-    fn cmp(&self, other: &BigUint) -> Ordering {\n-        let (s_len, o_len) = (self.data.len(), other.data.len());\n-        if s_len < o_len { return Less; }\n-        if s_len > o_len { return Greater;  }\n-\n-        for (&self_i, &other_i) in self.data.iter().rev().zip(other.data.iter().rev()) {\n-            if self_i < other_i { return Less; }\n-            if self_i > other_i { return Greater; }\n-        }\n-        return Equal;\n-    }\n-}\n-\n-impl Default for BigUint {\n-    #[inline]\n-    fn default() -> BigUint { Zero::zero() }\n-}\n-\n-impl<S: hash::Writer> hash::Hash<S> for BigUint {\n-    fn hash(&self, state: &mut S) {\n-        // hash 0 in case it's all 0's\n-        0u32.hash(state);\n-\n-        let mut found_first_value = false;\n-        for elem in self.data.iter().rev() {\n-            // don't hash any leading 0's, they shouldn't affect the hash\n-            if found_first_value || *elem != 0 {\n-                found_first_value = true;\n-                elem.hash(state);\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Show for BigUint {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.to_str_radix(10))\n-    }\n-}\n-\n-impl FromStr for BigUint {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<BigUint> {\n-        FromStrRadix::from_str_radix(s, 10)\n-    }\n-}\n-\n-impl Num for BigUint {}\n-\n-impl BitAnd<BigUint, BigUint> for BigUint {\n-    fn bitand(&self, other: &BigUint) -> BigUint {\n-        BigUint::new(self.data.iter().zip(other.data.iter()).map(|(ai, bi)| *ai & *bi).collect())\n-    }\n-}\n-\n-impl BitOr<BigUint, BigUint> for BigUint {\n-    fn bitor(&self, other: &BigUint) -> BigUint {\n-        let zeros = ZERO_VEC.iter().cycle();\n-        let (a, b) = if self.data.len() > other.data.len() { (self, other) } else { (other, self) };\n-        let ored = a.data.iter().zip(b.data.iter().chain(zeros)).map(\n-            |(ai, bi)| *ai | *bi\n-        ).collect();\n-        return BigUint::new(ored);\n-    }\n-}\n-\n-impl BitXor<BigUint, BigUint> for BigUint {\n-    fn bitxor(&self, other: &BigUint) -> BigUint {\n-        let zeros = ZERO_VEC.iter().cycle();\n-        let (a, b) = if self.data.len() > other.data.len() { (self, other) } else { (other, self) };\n-        let xored = a.data.iter().zip(b.data.iter().chain(zeros)).map(\n-            |(ai, bi)| *ai ^ *bi\n-        ).collect();\n-        return BigUint::new(xored);\n-    }\n-}\n-\n-impl Shl<uint, BigUint> for BigUint {\n-    #[inline]\n-    fn shl(&self, rhs: &uint) -> BigUint {\n-        let n_unit = *rhs / BigDigit::bits;\n-        let n_bits = *rhs % BigDigit::bits;\n-        return self.shl_unit(n_unit).shl_bits(n_bits);\n-    }\n-}\n-\n-impl Shr<uint, BigUint> for BigUint {\n-    #[inline]\n-    fn shr(&self, rhs: &uint) -> BigUint {\n-        let n_unit = *rhs / BigDigit::bits;\n-        let n_bits = *rhs % BigDigit::bits;\n-        return self.shr_unit(n_unit).shr_bits(n_bits);\n-    }\n-}\n-\n-impl Zero for BigUint {\n-    #[inline]\n-    fn zero() -> BigUint { BigUint::new(Vec::new()) }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool { self.data.is_empty() }\n-}\n-\n-impl One for BigUint {\n-    #[inline]\n-    fn one() -> BigUint { BigUint::new(vec!(1)) }\n-}\n-\n-impl Unsigned for BigUint {}\n-\n-impl Add<BigUint, BigUint> for BigUint {\n-    fn add(&self, other: &BigUint) -> BigUint {\n-        let zeros = ZERO_VEC.iter().cycle();\n-        let (a, b) = if self.data.len() > other.data.len() { (self, other) } else { (other, self) };\n-\n-        let mut carry = 0;\n-        let mut sum: Vec<BigDigit> =  a.data.iter().zip(b.data.iter().chain(zeros)).map(|(ai, bi)| {\n-            let (hi, lo) = BigDigit::from_doublebigdigit(\n-                (*ai as DoubleBigDigit) + (*bi as DoubleBigDigit) + (carry as DoubleBigDigit));\n-            carry = hi;\n-            lo\n-        }).collect();\n-        if carry != 0 { sum.push(carry); }\n-        return BigUint::new(sum);\n-    }\n-}\n-\n-impl Sub<BigUint, BigUint> for BigUint {\n-    fn sub(&self, other: &BigUint) -> BigUint {\n-        let new_len = cmp::max(self.data.len(), other.data.len());\n-        let zeros = ZERO_VEC.iter().cycle();\n-        let (a, b) = (self.data.iter().chain(zeros.clone()), other.data.iter().chain(zeros));\n-\n-        let mut borrow = 0i;\n-        let diff: Vec<BigDigit> =  a.take(new_len).zip(b).map(|(ai, bi)| {\n-            let (hi, lo) = BigDigit::from_doublebigdigit(\n-                BigDigit::base\n-                    + (*ai as DoubleBigDigit)\n-                    - (*bi as DoubleBigDigit)\n-                    - (borrow as DoubleBigDigit)\n-            );\n-            /*\n-            hi * (base) + lo == 1*(base) + ai - bi - borrow\n-            => ai - bi - borrow < 0 <=> hi == 0\n-            */\n-            borrow = if hi == 0 { 1 } else { 0 };\n-            lo\n-        }).collect();\n-\n-        assert!(borrow == 0,\n-                \"Cannot subtract other from self because other is larger than self.\");\n-        return BigUint::new(diff);\n-    }\n-}\n-\n-impl Mul<BigUint, BigUint> for BigUint {\n-    fn mul(&self, other: &BigUint) -> BigUint {\n-        if self.is_zero() || other.is_zero() { return Zero::zero(); }\n-\n-        let (s_len, o_len) = (self.data.len(), other.data.len());\n-        if s_len == 1 { return mul_digit(other, self.data.as_slice()[0]);  }\n-        if o_len == 1 { return mul_digit(self,  other.data.as_slice()[0]); }\n-\n-        // Using Karatsuba multiplication\n-        // (a1 * base + a0) * (b1 * base + b0)\n-        // = a1*b1 * base^2 +\n-        //   (a1*b1 + a0*b0 - (a1-b0)*(b1-a0)) * base +\n-        //   a0*b0\n-        let half_len = cmp::max(s_len, o_len) / 2;\n-        let (s_hi, s_lo) = cut_at(self,  half_len);\n-        let (o_hi, o_lo) = cut_at(other, half_len);\n-\n-        let ll = s_lo * o_lo;\n-        let hh = s_hi * o_hi;\n-        let mm = {\n-            let (s1, n1) = sub_sign(s_hi, s_lo);\n-            let (s2, n2) = sub_sign(o_hi, o_lo);\n-            match (s1, s2) {\n-                (Equal, _) | (_, Equal) => hh + ll,\n-                (Less, Greater) | (Greater, Less) => hh + ll + (n1 * n2),\n-                (Less, Less) | (Greater, Greater) => hh + ll - (n1 * n2)\n-            }\n-        };\n-\n-        return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n-\n-\n-        fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n-            if n == 0 { return Zero::zero(); }\n-            if n == 1 { return (*a).clone(); }\n-\n-            let mut carry = 0;\n-            let mut prod: Vec<BigDigit> = a.data.iter().map(|ai| {\n-                let (hi, lo) = BigDigit::from_doublebigdigit(\n-                    (*ai as DoubleBigDigit) * (n as DoubleBigDigit) + (carry as DoubleBigDigit)\n-                );\n-                carry = hi;\n-                lo\n-            }).collect();\n-            if carry != 0 { prod.push(carry); }\n-            return BigUint::new(prod);\n-        }\n-\n-        #[inline]\n-        fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n-            let mid = cmp::min(a.data.len(), n);\n-            return (BigUint::from_slice(a.data.slice(mid, a.data.len())),\n-                    BigUint::from_slice(a.data.slice(0, mid)));\n-        }\n-\n-        #[inline]\n-        fn sub_sign(a: BigUint, b: BigUint) -> (Ordering, BigUint) {\n-            match a.cmp(&b) {\n-                Less    => (Less,    b - a),\n-                Greater => (Greater, a - b),\n-                _       => (Equal,   Zero::zero())\n-            }\n-        }\n-    }\n-}\n-\n-impl Div<BigUint, BigUint> for BigUint {\n-    #[inline]\n-    fn div(&self, other: &BigUint) -> BigUint {\n-        let (q, _) = self.div_rem(other);\n-        return q;\n-    }\n-}\n-\n-impl Rem<BigUint, BigUint> for BigUint {\n-    #[inline]\n-    fn rem(&self, other: &BigUint) -> BigUint {\n-        let (_, r) = self.div_rem(other);\n-        return r;\n-    }\n-}\n-\n-impl Neg<BigUint> for BigUint {\n-    #[inline]\n-    fn neg(&self) -> BigUint { fail!() }\n-}\n-\n-impl CheckedAdd for BigUint {\n-    #[inline]\n-    fn checked_add(&self, v: &BigUint) -> Option<BigUint> {\n-        return Some(self.add(v));\n-    }\n-}\n-\n-impl CheckedSub for BigUint {\n-    #[inline]\n-    fn checked_sub(&self, v: &BigUint) -> Option<BigUint> {\n-        if *self < *v {\n-            return None;\n-        }\n-        return Some(self.sub(v));\n-    }\n-}\n-\n-impl CheckedMul for BigUint {\n-    #[inline]\n-    fn checked_mul(&self, v: &BigUint) -> Option<BigUint> {\n-        return Some(self.mul(v));\n-    }\n-}\n-\n-impl CheckedDiv for BigUint {\n-    #[inline]\n-    fn checked_div(&self, v: &BigUint) -> Option<BigUint> {\n-        if v.is_zero() {\n-            return None;\n-        }\n-        return Some(self.div(v));\n-    }\n-}\n-\n-impl Integer for BigUint {\n-    #[inline]\n-    fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        self.div_mod_floor(other)\n-    }\n-\n-    #[inline]\n-    fn div_floor(&self, other: &BigUint) -> BigUint {\n-        let (d, _) = self.div_mod_floor(other);\n-        return d;\n-    }\n-\n-    #[inline]\n-    fn mod_floor(&self, other: &BigUint) -> BigUint {\n-        let (_, m) = self.div_mod_floor(other);\n-        return m;\n-    }\n-\n-    fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        if other.is_zero() { fail!() }\n-        if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n-        if *other == One::one() { return ((*self).clone(), Zero::zero()); }\n-\n-        match self.cmp(other) {\n-            Less    => return (Zero::zero(), (*self).clone()),\n-            Equal   => return (One::one(), Zero::zero()),\n-            Greater => {} // Do nothing\n-        }\n-\n-        let mut shift = 0;\n-        let mut n = *other.data.last().unwrap();\n-        while n < (1 << BigDigit::bits - 2) {\n-            n <<= 1;\n-            shift += 1;\n-        }\n-        assert!(shift < BigDigit::bits);\n-        let (d, m) = div_mod_floor_inner(self << shift, other << shift);\n-        return (d, m >> shift);\n-\n-\n-        fn div_mod_floor_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n-            let mut m = a;\n-            let mut d: BigUint = Zero::zero();\n-            let mut n = 1;\n-            while m >= b {\n-                let (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n-                let mut d0 = d0;\n-                let mut prod = b * d0;\n-                while prod > m {\n-                    // FIXME(#5992): assignment operator overloads\n-                    // d0 -= d_unit\n-                    d0   = d0 - d_unit;\n-                    // FIXME(#5992): assignment operator overloads\n-                    // prod -= b_unit;\n-                    prod = prod - b_unit\n-                }\n-                if d0.is_zero() {\n-                    n = 2;\n-                    continue;\n-                }\n-                n = 1;\n-                // FIXME(#5992): assignment operator overloads\n-                // d += d0;\n-                d = d + d0;\n-                // FIXME(#5992): assignment operator overloads\n-                // m -= prod;\n-                m = m - prod;\n-            }\n-            return (d, m);\n-        }\n-\n-\n-        fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n-            -> (BigUint, BigUint, BigUint) {\n-            if a.data.len() < n {\n-                return (Zero::zero(), Zero::zero(), (*a).clone());\n-            }\n-\n-            let an = a.data.tailn(a.data.len() - n);\n-            let bn = *b.data.last().unwrap();\n-            let mut d = Vec::with_capacity(an.len());\n-            let mut carry = 0;\n-            for elt in an.iter().rev() {\n-                let ai = BigDigit::to_doublebigdigit(carry, *elt);\n-                let di = ai / (bn as DoubleBigDigit);\n-                assert!(di < BigDigit::base);\n-                carry = (ai % (bn as DoubleBigDigit)) as BigDigit;\n-                d.push(di as BigDigit)\n-            }\n-            d.reverse();\n-\n-            let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n-            if shift == 0 {\n-                return (BigUint::new(d), One::one(), (*b).clone());\n-            }\n-            let one: BigUint = One::one();\n-            return (BigUint::new(d).shl_unit(shift),\n-                    one.shl_unit(shift),\n-                    b.shl_unit(shift));\n-        }\n-    }\n-\n-    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`.\n-    ///\n-    /// The result is always positive.\n-    #[inline]\n-    fn gcd(&self, other: &BigUint) -> BigUint {\n-        // Use Euclid's algorithm\n-        let mut m = (*self).clone();\n-        let mut n = (*other).clone();\n-        while !m.is_zero() {\n-            let temp = m;\n-            m = n % temp;\n-            n = temp;\n-        }\n-        return n;\n-    }\n-\n-    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n-    #[inline]\n-    fn lcm(&self, other: &BigUint) -> BigUint { ((*self * *other) / self.gcd(other)) }\n-\n-    /// Deprecated, use `is_multiple_of` instead.\n-    #[deprecated = \"function renamed to `is_multiple_of`\"]\n-    #[inline]\n-    fn divides(&self, other: &BigUint) -> bool { return self.is_multiple_of(other); }\n-\n-    /// Returns `true` if the number is a multiple of `other`.\n-    #[inline]\n-    fn is_multiple_of(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }\n-\n-    /// Returns `true` if the number is divisible by `2`.\n-    #[inline]\n-    fn is_even(&self) -> bool {\n-        // Considering only the last digit.\n-        match self.data.as_slice().head() {\n-            Some(x) => x.is_even(),\n-            None => true\n-        }\n-    }\n-\n-    /// Returns `true` if the number is not divisible by `2`.\n-    #[inline]\n-    fn is_odd(&self) -> bool { !self.is_even() }\n-}\n-\n-impl ToPrimitive for BigUint {\n-    #[inline]\n-    fn to_i64(&self) -> Option<i64> {\n-        self.to_u64().and_then(|n| {\n-            // If top bit of u64 is set, it's too large to convert to i64.\n-            if n >> 63 == 0 {\n-                Some(n as i64)\n-            } else {\n-                None\n-            }\n-        })\n-    }\n-\n-    // `DoubleBigDigit` size dependent\n-    #[inline]\n-    fn to_u64(&self) -> Option<u64> {\n-        match self.data.len() {\n-            0 => Some(0),\n-            1 => Some(self.data.as_slice()[0] as u64),\n-            2 => Some(BigDigit::to_doublebigdigit(self.data.as_slice()[1], self.data.as_slice()[0])\n-                      as u64),\n-            _ => None\n-        }\n-    }\n-}\n-\n-impl FromPrimitive for BigUint {\n-    #[inline]\n-    fn from_i64(n: i64) -> Option<BigUint> {\n-        if n > 0 {\n-            FromPrimitive::from_u64(n as u64)\n-        } else if n == 0 {\n-            Some(Zero::zero())\n-        } else {\n-            None\n-        }\n-    }\n-\n-    // `DoubleBigDigit` size dependent\n-    #[inline]\n-    fn from_u64(n: u64) -> Option<BigUint> {\n-        let n = match BigDigit::from_doublebigdigit(n) {\n-            (0,  0)  => Zero::zero(),\n-            (0,  n0) => BigUint::new(vec!(n0)),\n-            (n1, n0) => BigUint::new(vec!(n0, n1))\n-        };\n-        Some(n)\n-    }\n-}\n-\n-/// A generic trait for converting a value to a `BigUint`.\n-pub trait ToBigUint {\n-    /// Converts the value of `self` to a `BigUint`.\n-    fn to_biguint(&self) -> Option<BigUint>;\n-}\n-\n-impl ToBigUint for BigInt {\n-    #[inline]\n-    fn to_biguint(&self) -> Option<BigUint> {\n-        if self.sign == Plus {\n-            Some(self.data.clone())\n-        } else if self.sign == NoSign {\n-            Some(Zero::zero())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl ToBigUint for BigUint {\n-    #[inline]\n-    fn to_biguint(&self) -> Option<BigUint> {\n-        Some(self.clone())\n-    }\n-}\n-\n-macro_rules! impl_to_biguint(\n-    ($T:ty, $from_ty:path) => {\n-        impl ToBigUint for $T {\n-            #[inline]\n-            fn to_biguint(&self) -> Option<BigUint> {\n-                $from_ty(*self)\n-            }\n-        }\n-    }\n-)\n-\n-impl_to_biguint!(int,  FromPrimitive::from_int)\n-impl_to_biguint!(i8,   FromPrimitive::from_i8)\n-impl_to_biguint!(i16,  FromPrimitive::from_i16)\n-impl_to_biguint!(i32,  FromPrimitive::from_i32)\n-impl_to_biguint!(i64,  FromPrimitive::from_i64)\n-impl_to_biguint!(uint, FromPrimitive::from_uint)\n-impl_to_biguint!(u8,   FromPrimitive::from_u8)\n-impl_to_biguint!(u16,  FromPrimitive::from_u16)\n-impl_to_biguint!(u32,  FromPrimitive::from_u32)\n-impl_to_biguint!(u64,  FromPrimitive::from_u64)\n-\n-impl ToStrRadix for BigUint {\n-    fn to_str_radix(&self, radix: uint) -> String {\n-        assert!(1 < radix && radix <= 16, \"The radix must be within (1, 16]\");\n-        let (base, max_len) = get_radix_base(radix);\n-        if base == BigDigit::base {\n-            return fill_concat(self.data.as_slice(), radix, max_len)\n-        }\n-        return fill_concat(convert_base(self, base).as_slice(), radix, max_len);\n-\n-        fn convert_base(n: &BigUint, base: DoubleBigDigit) -> Vec<BigDigit> {\n-            let divider    = base.to_biguint().unwrap();\n-            let mut result = Vec::new();\n-            let mut m      = n.clone();\n-            while m >= divider {\n-                let (d, m0) = m.div_mod_floor(&divider);\n-                result.push(m0.to_uint().unwrap() as BigDigit);\n-                m = d;\n-            }\n-            if !m.is_zero() {\n-                result.push(m.to_uint().unwrap() as BigDigit);\n-            }\n-            return result;\n-        }\n-\n-        fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> String {\n-            if v.is_empty() {\n-                return \"0\".to_string()\n-            }\n-            let mut s = String::with_capacity(v.len() * l);\n-            for n in v.iter().rev() {\n-                let ss = (*n as uint).to_str_radix(radix);\n-                s.push_str(\"0\".repeat(l - ss.len()).as_slice());\n-                s.push_str(ss.as_slice());\n-            }\n-            s.as_slice().trim_left_chars('0').to_string()\n-        }\n-    }\n-}\n-\n-impl FromStrRadix for BigUint {\n-    /// Creates and initializes a `BigUint`.\n-    #[inline]\n-    fn from_str_radix(s: &str, radix: uint) -> Option<BigUint> {\n-        BigUint::parse_bytes(s.as_bytes(), radix)\n-    }\n-}\n-\n-impl BigUint {\n-    /// Creates and initializes a `BigUint`.\n-    ///\n-    /// The digits are be in base 2^32.\n-    #[inline]\n-    pub fn new(mut digits: Vec<BigDigit>) -> BigUint {\n-        // omit trailing zeros\n-        let new_len = digits.iter().rposition(|n| *n != 0).map_or(0, |p| p + 1);\n-        digits.truncate(new_len);\n-        BigUint { data: digits }\n-    }\n-\n-    /// Creates and initializes a `BigUint`.\n-    ///\n-    /// The digits are be in base 2^32.\n-    #[inline]\n-    pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n-        BigUint::new(Vec::from_slice(slice))\n-    }\n-\n-    /// Creates and initializes a `BigUint`.\n-    pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<BigUint> {\n-        let (base, unit_len) = get_radix_base(radix);\n-        let base_num = match base.to_biguint() {\n-            Some(base_num) => base_num,\n-            None => { return None; }\n-        };\n-\n-        let mut end             = buf.len();\n-        let mut n: BigUint      = Zero::zero();\n-        let mut power: BigUint  = One::one();\n-        loop {\n-            let start = cmp::max(end, unit_len) - unit_len;\n-            match uint::parse_bytes(buf[start..end], radix) {\n-                Some(d) => {\n-                    let d: Option<BigUint> = FromPrimitive::from_uint(d);\n-                    match d {\n-                        Some(d) => {\n-                            // FIXME(#5992): assignment operator overloads\n-                            // n += d * power;\n-                            n = n + d * power;\n-                        }\n-                        None => { return None; }\n-                    }\n-                }\n-                None => { return None; }\n-            }\n-            if end <= unit_len {\n-                return Some(n);\n-            }\n-            end -= unit_len;\n-            // FIXME(#5992): assignment operator overloads\n-            // power *= base_num;\n-            power = power * base_num;\n-        }\n-    }\n-\n-    #[inline]\n-    fn shl_unit(&self, n_unit: uint) -> BigUint {\n-        if n_unit == 0 || self.is_zero() { return (*self).clone(); }\n-\n-        BigUint::new(Vec::from_elem(n_unit, ZERO_BIG_DIGIT).append(self.data.as_slice()))\n-    }\n-\n-    #[inline]\n-    fn shl_bits(&self, n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.is_zero() { return (*self).clone(); }\n-\n-        let mut carry = 0;\n-        let mut shifted: Vec<BigDigit> = self.data.iter().map(|elem| {\n-            let (hi, lo) = BigDigit::from_doublebigdigit(\n-                (*elem as DoubleBigDigit) << n_bits | (carry as DoubleBigDigit)\n-            );\n-            carry = hi;\n-            lo\n-        }).collect();\n-        if carry != 0 { shifted.push(carry); }\n-        return BigUint::new(shifted);\n-    }\n-\n-    #[inline]\n-    fn shr_unit(&self, n_unit: uint) -> BigUint {\n-        if n_unit == 0 { return (*self).clone(); }\n-        if self.data.len() < n_unit { return Zero::zero(); }\n-        return BigUint::from_slice(\n-            self.data.slice(n_unit, self.data.len())\n-        );\n-    }\n-\n-    #[inline]\n-    fn shr_bits(&self, n_bits: uint) -> BigUint {\n-        if n_bits == 0 || self.data.is_empty() { return (*self).clone(); }\n-\n-        let mut borrow = 0;\n-        let mut shifted_rev = Vec::with_capacity(self.data.len());\n-        for elem in self.data.iter().rev() {\n-            shifted_rev.push((*elem >> n_bits) | borrow);\n-            borrow = *elem << (BigDigit::bits - n_bits);\n-        }\n-        let shifted = { shifted_rev.reverse(); shifted_rev };\n-        return BigUint::new(shifted);\n-    }\n-\n-    /// Determines the fewest bits necessary to express the `BigUint`.\n-    pub fn bits(&self) -> uint {\n-        if self.is_zero() { return 0; }\n-        let zeros = self.data.last().unwrap().leading_zeros();\n-        return self.data.len()*BigDigit::bits - zeros;\n-    }\n-}\n-\n-// `DoubleBigDigit` size dependent\n-#[inline]\n-fn get_radix_base(radix: uint) -> (DoubleBigDigit, uint) {\n-    match radix {\n-        2  => (4294967296, 32),\n-        3  => (3486784401, 20),\n-        4  => (4294967296, 16),\n-        5  => (1220703125, 13),\n-        6  => (2176782336, 12),\n-        7  => (1977326743, 11),\n-        8  => (1073741824, 10),\n-        9  => (3486784401, 10),\n-        10 => (1000000000, 9),\n-        11 => (2357947691, 9),\n-        12 => (429981696,  8),\n-        13 => (815730721,  8),\n-        14 => (1475789056, 8),\n-        15 => (2562890625, 8),\n-        16 => (4294967296, 8),\n-        _  => fail!(\"The radix must be within (1, 16]\")\n-    }\n-}\n-\n-/// A Sign is a `BigInt`'s composing element.\n-#[deriving(PartialEq, PartialOrd, Eq, Ord, Clone, Show)]\n-pub enum Sign { Minus, NoSign, Plus }\n-\n-impl Neg<Sign> for Sign {\n-    /// Negate Sign value.\n-    #[inline]\n-    fn neg(&self) -> Sign {\n-        match *self {\n-          Minus => Plus,\n-          NoSign  => NoSign,\n-          Plus  => Minus\n-        }\n-    }\n-}\n-\n-/// A big signed integer type.\n-#[deriving(Clone)]\n-pub struct BigInt {\n-    sign: Sign,\n-    data: BigUint\n-}\n-\n-impl PartialEq for BigInt {\n-    #[inline]\n-    fn eq(&self, other: &BigInt) -> bool {\n-        self.cmp(other) == Equal\n-    }\n-}\n-\n-impl Eq for BigInt {}\n-\n-impl PartialOrd for BigInt {\n-    #[inline]\n-    fn partial_cmp(&self, other: &BigInt) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for BigInt {\n-    #[inline]\n-    fn cmp(&self, other: &BigInt) -> Ordering {\n-        let scmp = self.sign.cmp(&other.sign);\n-        if scmp != Equal { return scmp; }\n-\n-        match self.sign {\n-            NoSign  => Equal,\n-            Plus  => self.data.cmp(&other.data),\n-            Minus => other.data.cmp(&self.data),\n-        }\n-    }\n-}\n-\n-impl Default for BigInt {\n-    #[inline]\n-    fn default() -> BigInt { Zero::zero() }\n-}\n-\n-impl fmt::Show for BigInt {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.to_str_radix(10))\n-    }\n-}\n-\n-impl<S: hash::Writer> hash::Hash<S> for BigInt {\n-    fn hash(&self, state: &mut S) {\n-        (self.sign == Plus).hash(state);\n-        self.data.hash(state);\n-    }\n-}\n-\n-impl FromStr for BigInt {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<BigInt> {\n-        FromStrRadix::from_str_radix(s, 10)\n-    }\n-}\n-\n-impl Num for BigInt {}\n-\n-impl Shl<uint, BigInt> for BigInt {\n-    #[inline]\n-    fn shl(&self, rhs: &uint) -> BigInt {\n-        BigInt::from_biguint(self.sign, self.data << *rhs)\n-    }\n-}\n-\n-impl Shr<uint, BigInt> for BigInt {\n-    #[inline]\n-    fn shr(&self, rhs: &uint) -> BigInt {\n-        BigInt::from_biguint(self.sign, self.data >> *rhs)\n-    }\n-}\n-\n-impl Zero for BigInt {\n-    #[inline]\n-    fn zero() -> BigInt {\n-        BigInt::from_biguint(NoSign, Zero::zero())\n-    }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool { self.sign == NoSign }\n-}\n-\n-impl One for BigInt {\n-    #[inline]\n-    fn one() -> BigInt {\n-        BigInt::from_biguint(Plus, One::one())\n-    }\n-}\n-\n-impl Signed for BigInt {\n-    #[inline]\n-    fn abs(&self) -> BigInt {\n-        match self.sign {\n-            Plus | NoSign => self.clone(),\n-            Minus => BigInt::from_biguint(Plus, self.data.clone())\n-        }\n-    }\n-\n-    #[inline]\n-    fn abs_sub(&self, other: &BigInt) -> BigInt {\n-        if *self <= *other { Zero::zero() } else { *self - *other }\n-    }\n-\n-    #[inline]\n-    fn signum(&self) -> BigInt {\n-        match self.sign {\n-            Plus  => BigInt::from_biguint(Plus, One::one()),\n-            Minus => BigInt::from_biguint(Minus, One::one()),\n-            NoSign  => Zero::zero(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_positive(&self) -> bool { self.sign == Plus }\n-\n-    #[inline]\n-    fn is_negative(&self) -> bool { self.sign == Minus }\n-}\n-\n-impl Add<BigInt, BigInt> for BigInt {\n-    #[inline]\n-    fn add(&self, other: &BigInt) -> BigInt {\n-        match (self.sign, other.sign) {\n-            (NoSign, _)      => other.clone(),\n-            (_,    NoSign)   => self.clone(),\n-            (Plus, Plus)   => BigInt::from_biguint(Plus, self.data + other.data),\n-            (Plus, Minus)  => self - (-*other),\n-            (Minus, Plus)  => other - (-*self),\n-            (Minus, Minus) => -((-self) + (-*other))\n-        }\n-    }\n-}\n-\n-impl Sub<BigInt, BigInt> for BigInt {\n-    #[inline]\n-    fn sub(&self, other: &BigInt) -> BigInt {\n-        match (self.sign, other.sign) {\n-            (NoSign, _)    => -other,\n-            (_,    NoSign) => self.clone(),\n-            (Plus, Plus) => match self.data.cmp(&other.data) {\n-                Less    => BigInt::from_biguint(Minus, other.data - self.data),\n-                Greater => BigInt::from_biguint(Plus, self.data - other.data),\n-                Equal   => Zero::zero()\n-            },\n-            (Plus, Minus) => self + (-*other),\n-            (Minus, Plus) => -((-self) + *other),\n-            (Minus, Minus) => (-other) - (-*self)\n-        }\n-    }\n-}\n-\n-impl Mul<BigInt, BigInt> for BigInt {\n-    #[inline]\n-    fn mul(&self, other: &BigInt) -> BigInt {\n-        match (self.sign, other.sign) {\n-            (NoSign, _)     | (_,     NoSign)  => Zero::zero(),\n-            (Plus, Plus)  | (Minus, Minus) => {\n-                BigInt::from_biguint(Plus, self.data * other.data)\n-            },\n-            (Plus, Minus) | (Minus, Plus) => {\n-                BigInt::from_biguint(Minus, self.data * other.data)\n-            }\n-        }\n-    }\n-}\n-\n-impl Div<BigInt, BigInt> for BigInt {\n-    #[inline]\n-    fn div(&self, other: &BigInt) -> BigInt {\n-        let (q, _) = self.div_rem(other);\n-        q\n-    }\n-}\n-\n-impl Rem<BigInt, BigInt> for BigInt {\n-    #[inline]\n-    fn rem(&self, other: &BigInt) -> BigInt {\n-        let (_, r) = self.div_rem(other);\n-        r\n-    }\n-}\n-\n-impl Neg<BigInt> for BigInt {\n-    #[inline]\n-    fn neg(&self) -> BigInt {\n-        BigInt::from_biguint(self.sign.neg(), self.data.clone())\n-    }\n-}\n-\n-impl CheckedAdd for BigInt {\n-    #[inline]\n-    fn checked_add(&self, v: &BigInt) -> Option<BigInt> {\n-        return Some(self.add(v));\n-    }\n-}\n-\n-impl CheckedSub for BigInt {\n-    #[inline]\n-    fn checked_sub(&self, v: &BigInt) -> Option<BigInt> {\n-        return Some(self.sub(v));\n-    }\n-}\n-\n-impl CheckedMul for BigInt {\n-    #[inline]\n-    fn checked_mul(&self, v: &BigInt) -> Option<BigInt> {\n-        return Some(self.mul(v));\n-    }\n-}\n-\n-impl CheckedDiv for BigInt {\n-    #[inline]\n-    fn checked_div(&self, v: &BigInt) -> Option<BigInt> {\n-        if v.is_zero() {\n-            return None;\n-        }\n-        return Some(self.div(v));\n-    }\n-}\n-\n-\n-impl Integer for BigInt {\n-    #[inline]\n-    fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n-        // r.sign == self.sign\n-        let (d_ui, r_ui) = self.data.div_mod_floor(&other.data);\n-        let d = BigInt::from_biguint(Plus, d_ui);\n-        let r = BigInt::from_biguint(Plus, r_ui);\n-        match (self.sign, other.sign) {\n-            (_,    NoSign)   => fail!(),\n-            (Plus, Plus)  | (NoSign, Plus)  => ( d,  r),\n-            (Plus, Minus) | (NoSign, Minus) => (-d,  r),\n-            (Minus, Plus)                 => (-d, -r),\n-            (Minus, Minus)                => ( d, -r)\n-        }\n-    }\n-\n-    #[inline]\n-    fn div_floor(&self, other: &BigInt) -> BigInt {\n-        let (d, _) = self.div_mod_floor(other);\n-        d\n-    }\n-\n-    #[inline]\n-    fn mod_floor(&self, other: &BigInt) -> BigInt {\n-        let (_, m) = self.div_mod_floor(other);\n-        m\n-    }\n-\n-    fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {\n-        // m.sign == other.sign\n-        let (d_ui, m_ui) = self.data.div_rem(&other.data);\n-        let d = BigInt::from_biguint(Plus, d_ui);\n-        let m = BigInt::from_biguint(Plus, m_ui);\n-        match (self.sign, other.sign) {\n-            (_,    NoSign)   => fail!(),\n-            (Plus, Plus)  | (NoSign, Plus)  => (d, m),\n-            (Plus, Minus) | (NoSign, Minus) => if m.is_zero() {\n-                (-d, Zero::zero())\n-            } else {\n-                (-d - One::one(), m + *other)\n-            },\n-            (Minus, Plus) => if m.is_zero() {\n-                (-d, Zero::zero())\n-            } else {\n-                (-d - One::one(), other - m)\n-            },\n-            (Minus, Minus) => (d, -m)\n-        }\n-    }\n-\n-    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`.\n-    ///\n-    /// The result is always positive.\n-    #[inline]\n-    fn gcd(&self, other: &BigInt) -> BigInt {\n-        BigInt::from_biguint(Plus, self.data.gcd(&other.data))\n-    }\n-\n-    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n-    #[inline]\n-    fn lcm(&self, other: &BigInt) -> BigInt {\n-        BigInt::from_biguint(Plus, self.data.lcm(&other.data))\n-    }\n-\n-    /// Deprecated, use `is_multiple_of` instead.\n-    #[deprecated = \"function renamed to `is_multiple_of`\"]\n-    #[inline]\n-    fn divides(&self, other: &BigInt) -> bool { return self.is_multiple_of(other); }\n-\n-    /// Returns `true` if the number is a multiple of `other`.\n-    #[inline]\n-    fn is_multiple_of(&self, other: &BigInt) -> bool { self.data.is_multiple_of(&other.data) }\n-\n-    /// Returns `true` if the number is divisible by `2`.\n-    #[inline]\n-    fn is_even(&self) -> bool { self.data.is_even() }\n-\n-    /// Returns `true` if the number is not divisible by `2`.\n-    #[inline]\n-    fn is_odd(&self) -> bool { self.data.is_odd() }\n-}\n-\n-impl ToPrimitive for BigInt {\n-    #[inline]\n-    fn to_i64(&self) -> Option<i64> {\n-        match self.sign {\n-            Plus  => self.data.to_i64(),\n-            NoSign  => Some(0),\n-            Minus => {\n-                self.data.to_u64().and_then(|n| {\n-                    let m: u64 = 1 << 63;\n-                    if n < m {\n-                        Some(-(n as i64))\n-                    } else if n == m {\n-                        Some(i64::MIN)\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn to_u64(&self) -> Option<u64> {\n-        match self.sign {\n-            Plus => self.data.to_u64(),\n-            NoSign => Some(0),\n-            Minus => None\n-        }\n-    }\n-}\n-\n-impl FromPrimitive for BigInt {\n-    #[inline]\n-    fn from_i64(n: i64) -> Option<BigInt> {\n-        if n > 0 {\n-            FromPrimitive::from_u64(n as u64).and_then(|n| {\n-                Some(BigInt::from_biguint(Plus, n))\n-            })\n-        } else if n < 0 {\n-            FromPrimitive::from_u64(u64::MAX - (n as u64) + 1).and_then(\n-                |n| {\n-                    Some(BigInt::from_biguint(Minus, n))\n-                })\n-        } else {\n-            Some(Zero::zero())\n-        }\n-    }\n-\n-    #[inline]\n-    fn from_u64(n: u64) -> Option<BigInt> {\n-        if n == 0 {\n-            Some(Zero::zero())\n-        } else {\n-            FromPrimitive::from_u64(n).and_then(|n| {\n-                Some(BigInt::from_biguint(Plus, n))\n-            })\n-        }\n-    }\n-}\n-\n-/// A generic trait for converting a value to a `BigInt`.\n-pub trait ToBigInt {\n-    /// Converts the value of `self` to a `BigInt`.\n-    fn to_bigint(&self) -> Option<BigInt>;\n-}\n-\n-impl ToBigInt for BigInt {\n-    #[inline]\n-    fn to_bigint(&self) -> Option<BigInt> {\n-        Some(self.clone())\n-    }\n-}\n-\n-impl ToBigInt for BigUint {\n-    #[inline]\n-    fn to_bigint(&self) -> Option<BigInt> {\n-        if self.is_zero() {\n-            Some(Zero::zero())\n-        } else {\n-            Some(BigInt { sign: Plus, data: self.clone() })\n-        }\n-    }\n-}\n-\n-macro_rules! impl_to_bigint(\n-    ($T:ty, $from_ty:path) => {\n-        impl ToBigInt for $T {\n-            #[inline]\n-            fn to_bigint(&self) -> Option<BigInt> {\n-                $from_ty(*self)\n-            }\n-        }\n-    }\n-)\n-\n-impl_to_bigint!(int,  FromPrimitive::from_int)\n-impl_to_bigint!(i8,   FromPrimitive::from_i8)\n-impl_to_bigint!(i16,  FromPrimitive::from_i16)\n-impl_to_bigint!(i32,  FromPrimitive::from_i32)\n-impl_to_bigint!(i64,  FromPrimitive::from_i64)\n-impl_to_bigint!(uint, FromPrimitive::from_uint)\n-impl_to_bigint!(u8,   FromPrimitive::from_u8)\n-impl_to_bigint!(u16,  FromPrimitive::from_u16)\n-impl_to_bigint!(u32,  FromPrimitive::from_u32)\n-impl_to_bigint!(u64,  FromPrimitive::from_u64)\n-\n-impl ToStrRadix for BigInt {\n-    #[inline]\n-    fn to_str_radix(&self, radix: uint) -> String {\n-        match self.sign {\n-            Plus  => self.data.to_str_radix(radix),\n-            NoSign  => \"0\".to_string(),\n-            Minus => format!(\"-{}\", self.data.to_str_radix(radix)),\n-        }\n-    }\n-}\n-\n-impl FromStrRadix for BigInt {\n-    /// Creates and initializes a BigInt.\n-    #[inline]\n-    fn from_str_radix(s: &str, radix: uint) -> Option<BigInt> {\n-        BigInt::parse_bytes(s.as_bytes(), radix)\n-    }\n-}\n-\n-pub trait RandBigInt {\n-    /// Generate a random `BigUint` of the given bit size.\n-    fn gen_biguint(&mut self, bit_size: uint) -> BigUint;\n-\n-    /// Generate a random BigInt of the given bit size.\n-    fn gen_bigint(&mut self, bit_size: uint) -> BigInt;\n-\n-    /// Generate a random `BigUint` less than the given bound. Fails\n-    /// when the bound is zero.\n-    fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint;\n-\n-    /// Generate a random `BigUint` within the given range. The lower\n-    /// bound is inclusive; the upper bound is exclusive. Fails when\n-    /// the upper bound is not greater than the lower bound.\n-    fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint;\n-\n-    /// Generate a random `BigInt` within the given range. The lower\n-    /// bound is inclusive; the upper bound is exclusive. Fails when\n-    /// the upper bound is not greater than the lower bound.\n-    fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt;\n-}\n-\n-impl<R: Rng> RandBigInt for R {\n-    fn gen_biguint(&mut self, bit_size: uint) -> BigUint {\n-        let (digits, rem) = bit_size.div_rem(&BigDigit::bits);\n-        let mut data = Vec::with_capacity(digits+1);\n-        for _ in range(0, digits) {\n-            data.push(self.gen());\n-        }\n-        if rem > 0 {\n-            let final_digit: BigDigit = self.gen();\n-            data.push(final_digit >> (BigDigit::bits - rem));\n-        }\n-        BigUint::new(data)\n-    }\n-\n-    fn gen_bigint(&mut self, bit_size: uint) -> BigInt {\n-        // Generate a random BigUint...\n-        let biguint = self.gen_biguint(bit_size);\n-        // ...and then randomly assign it a Sign...\n-        let sign = if biguint.is_zero() {\n-            // ...except that if the BigUint is zero, we need to try\n-            // again with probability 0.5. This is because otherwise,\n-            // the probability of generating a zero BigInt would be\n-            // double that of any other number.\n-            if self.gen() {\n-                return self.gen_bigint(bit_size);\n-            } else {\n-                NoSign\n-            }\n-        } else if self.gen() {\n-            Plus\n-        } else {\n-            Minus\n-        };\n-        BigInt::from_biguint(sign, biguint)\n-    }\n-\n-    fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint {\n-        assert!(!bound.is_zero());\n-        let bits = bound.bits();\n-        loop {\n-            let n = self.gen_biguint(bits);\n-            if n < *bound { return n; }\n-        }\n-    }\n-\n-    fn gen_biguint_range(&mut self,\n-                         lbound: &BigUint,\n-                         ubound: &BigUint)\n-                         -> BigUint {\n-        assert!(*lbound < *ubound);\n-        return *lbound + self.gen_biguint_below(&(*ubound - *lbound));\n-    }\n-\n-    fn gen_bigint_range(&mut self,\n-                        lbound: &BigInt,\n-                        ubound: &BigInt)\n-                        -> BigInt {\n-        assert!(*lbound < *ubound);\n-        let delta = (*ubound - *lbound).to_biguint().unwrap();\n-        return *lbound + self.gen_biguint_below(&delta).to_bigint().unwrap();\n-    }\n-}\n-\n-impl BigInt {\n-    /// Creates and initializes a BigInt.\n-    ///\n-    /// The digits are be in base 2^32.\n-    #[inline]\n-    pub fn new(sign: Sign, digits: Vec<BigDigit>) -> BigInt {\n-        BigInt::from_biguint(sign, BigUint::new(digits))\n-    }\n-\n-    /// Creates and initializes a `BigInt`.\n-    ///\n-    /// The digits are be in base 2^32.\n-    #[inline]\n-    pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n-        if sign == NoSign || data.is_zero() {\n-            return BigInt { sign: NoSign, data: Zero::zero() };\n-        }\n-        BigInt { sign: sign, data: data }\n-    }\n-\n-    /// Creates and initializes a `BigInt`.\n-    #[inline]\n-    pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n-        BigInt::from_biguint(sign, BigUint::from_slice(slice))\n-    }\n-\n-    /// Creates and initializes a `BigInt`.\n-    pub fn parse_bytes(buf: &[u8], radix: uint) -> Option<BigInt> {\n-        if buf.is_empty() { return None; }\n-        let mut sign  = Plus;\n-        let mut start = 0;\n-        if buf[0] == b'-' {\n-            sign  = Minus;\n-            start = 1;\n-        }\n-        return BigUint::parse_bytes(buf[start..], radix)\n-            .map(|bu| BigInt::from_biguint(sign, bu));\n-    }\n-\n-    /// Converts this `BigInt` into a `BigUint`, if it's not negative.\n-    #[inline]\n-    pub fn to_biguint(&self) -> Option<BigUint> {\n-        match self.sign {\n-            Plus => Some(self.data.clone()),\n-            NoSign => Some(Zero::zero()),\n-            Minus => None\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod biguint_tests {\n-    use Integer;\n-    use super::{BigDigit, BigUint, ToBigUint};\n-    use super::{Plus, BigInt, RandBigInt, ToBigInt};\n-\n-    use std::cmp::{Less, Equal, Greater};\n-    use std::from_str::FromStr;\n-    use std::i64;\n-    use std::num::{Zero, One, FromStrRadix, ToStrRadix};\n-    use std::num::{ToPrimitive, FromPrimitive};\n-    use std::num::CheckedDiv;\n-    use std::rand::task_rng;\n-    use std::u64;\n-    use std::hash::hash;\n-\n-    #[test]\n-    fn test_from_slice() {\n-        fn check(slice: &[BigDigit], data: &[BigDigit]) {\n-            assert!(data == BigUint::from_slice(slice).data.as_slice());\n-        }\n-        check([1], [1]);\n-        check([0, 0, 0], []);\n-        check([1, 2, 0, 0], [1, 2]);\n-        check([0, 0, 1, 2], [0, 0, 1, 2]);\n-        check([0, 0, 1, 2, 0, 0], [0, 0, 1, 2]);\n-        check([-1], [-1]);\n-    }\n-\n-    #[test]\n-    fn test_cmp() {\n-        let data: [&[_], ..7] = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ];\n-        let data: Vec<BigUint> = data.iter().map(|v| BigUint::from_slice(*v)).collect();\n-        for (i, ni) in data.iter().enumerate() {\n-            for (j0, nj) in data.slice(i, data.len()).iter().enumerate() {\n-                let j = j0 + i;\n-                if i == j {\n-                    assert_eq!(ni.cmp(nj), Equal);\n-                    assert_eq!(nj.cmp(ni), Equal);\n-                    assert_eq!(ni, nj);\n-                    assert!(!(ni != nj));\n-                    assert!(ni <= nj);\n-                    assert!(ni >= nj);\n-                    assert!(!(ni < nj));\n-                    assert!(!(ni > nj));\n-                } else {\n-                    assert_eq!(ni.cmp(nj), Less);\n-                    assert_eq!(nj.cmp(ni), Greater);\n-\n-                    assert!(!(ni == nj));\n-                    assert!(ni != nj);\n-\n-                    assert!(ni <= nj);\n-                    assert!(!(ni >= nj));\n-                    assert!(ni < nj);\n-                    assert!(!(ni > nj));\n-\n-                    assert!(!(nj <= ni));\n-                    assert!(nj >= ni);\n-                    assert!(!(nj < ni));\n-                    assert!(nj > ni);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-        let a = BigUint::new(vec!());\n-        let b = BigUint::new(vec!(0));\n-        let c = BigUint::new(vec!(1));\n-        let d = BigUint::new(vec!(1,0,0,0,0,0));\n-        let e = BigUint::new(vec!(0,0,0,0,0,1));\n-        assert!(hash(&a) == hash(&b));\n-        assert!(hash(&b) != hash(&c));\n-        assert!(hash(&c) == hash(&d));\n-        assert!(hash(&d) != hash(&e));\n-    }\n-\n-    #[test]\n-    fn test_bitand() {\n-        fn check(left: &[BigDigit],\n-                 right: &[BigDigit],\n-                 expected: &[BigDigit]) {\n-            assert_eq!(BigUint::from_slice(left) & BigUint::from_slice(right),\n-                       BigUint::from_slice(expected));\n-        }\n-        check([], [], []);\n-        check([268, 482, 17],\n-              [964, 54],\n-              [260, 34]);\n-    }\n-\n-    #[test]\n-    fn test_bitor() {\n-        fn check(left: &[BigDigit],\n-                 right: &[BigDigit],\n-                 expected: &[BigDigit]) {\n-            assert_eq!(BigUint::from_slice(left) | BigUint::from_slice(right),\n-                       BigUint::from_slice(expected));\n-        }\n-        check([], [], []);\n-        check([268, 482, 17],\n-              [964, 54],\n-              [972, 502, 17]);\n-    }\n-\n-    #[test]\n-    fn test_bitxor() {\n-        fn check(left: &[BigDigit],\n-                 right: &[BigDigit],\n-                 expected: &[BigDigit]) {\n-            assert_eq!(BigUint::from_slice(left) ^ BigUint::from_slice(right),\n-                       BigUint::from_slice(expected));\n-        }\n-        check([], [], []);\n-        check([268, 482, 17],\n-              [964, 54],\n-              [712, 468, 17]);\n-    }\n-\n-    #[test]\n-    fn test_shl() {\n-        fn check(s: &str, shift: uint, ans: &str) {\n-            let opt_biguint: Option<BigUint> = FromStrRadix::from_str_radix(s, 16);\n-            let bu = (opt_biguint.unwrap() << shift).to_str_radix(16);\n-            assert_eq!(bu.as_slice(), ans);\n-        }\n-\n-        check(\"0\", 3, \"0\");\n-        check(\"1\", 3, \"8\");\n-\n-        check(\"1\\\n-               0000\\\n-               0000\\\n-               0000\\\n-               0001\\\n-               0000\\\n-               0000\\\n-               0000\\\n-               0001\",\n-              3,\n-              \"8\\\n-               0000\\\n-               0000\\\n-               0000\\\n-               0008\\\n-               0000\\\n-               0000\\\n-               0000\\\n-               0008\");\n-        check(\"1\\\n-               0000\\\n-               0001\\\n-               0000\\\n-               0001\",\n-              2,\n-              \"4\\\n-               0000\\\n-               0004\\\n-               0000\\\n-               0004\");\n-        check(\"1\\\n-               0001\\\n-               0001\",\n-              1,\n-              \"2\\\n-               0002\\\n-               0002\");\n-\n-        check(\"\\\n-              4000\\\n-              0000\\\n-              0000\\\n-              0000\",\n-              3,\n-              \"2\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\");\n-        check(\"4000\\\n-              0000\",\n-              2,\n-              \"1\\\n-              0000\\\n-              0000\");\n-        check(\"4000\",\n-              2,\n-              \"1\\\n-              0000\");\n-\n-        check(\"4000\\\n-              0000\\\n-              0000\\\n-              0000\",\n-              67,\n-              \"2\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\");\n-        check(\"4000\\\n-              0000\",\n-              35,\n-              \"2\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\");\n-        check(\"4000\",\n-              19,\n-              \"2\\\n-              0000\\\n-              0000\");\n-\n-        check(\"fedc\\\n-              ba98\\\n-              7654\\\n-              3210\\\n-              fedc\\\n-              ba98\\\n-              7654\\\n-              3210\",\n-              4,\n-              \"f\\\n-              edcb\\\n-              a987\\\n-              6543\\\n-              210f\\\n-              edcb\\\n-              a987\\\n-              6543\\\n-              2100\");\n-        check(\"88887777666655554444333322221111\", 16,\n-              \"888877776666555544443333222211110000\");\n-    }\n-\n-    #[test]\n-    fn test_shr() {\n-        fn check(s: &str, shift: uint, ans: &str) {\n-            let opt_biguint: Option<BigUint> =\n-                FromStrRadix::from_str_radix(s, 16);\n-            let bu = (opt_biguint.unwrap() >> shift).to_str_radix(16);\n-            assert_eq!(bu.as_slice(), ans);\n-        }\n-\n-        check(\"0\", 3, \"0\");\n-        check(\"f\", 3, \"1\");\n-\n-        check(\"1\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0001\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0001\",\n-              3,\n-              \"2000\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              2000\\\n-              0000\\\n-              0000\\\n-              0000\");\n-        check(\"1\\\n-              0000\\\n-              0001\\\n-              0000\\\n-              0001\",\n-              2,\n-              \"4000\\\n-              0000\\\n-              4000\\\n-              0000\");\n-        check(\"1\\\n-              0001\\\n-              0001\",\n-              1,\n-              \"8000\\\n-              8000\");\n-\n-        check(\"2\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0001\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0001\",\n-              67,\n-              \"4000\\\n-              0000\\\n-              0000\\\n-              0000\");\n-        check(\"2\\\n-              0000\\\n-              0001\\\n-              0000\\\n-              0001\",\n-              35,\n-              \"4000\\\n-              0000\");\n-        check(\"2\\\n-              0001\\\n-              0001\",\n-              19,\n-              \"4000\");\n-\n-        check(\"1\\\n-              0000\\\n-              0000\\\n-              0000\\\n-              0000\",\n-              1,\n-              \"8000\\\n-              0000\\\n-              0000\\\n-              0000\");\n-        check(\"1\\\n-              0000\\\n-              0000\",\n-              1,\n-              \"8000\\\n-              0000\");\n-        check(\"1\\\n-              0000\",\n-              1,\n-              \"8000\");\n-        check(\"f\\\n-              edcb\\\n-              a987\\\n-              6543\\\n-              210f\\\n-              edcb\\\n-              a987\\\n-              6543\\\n-              2100\",\n-              4,\n-              \"fedc\\\n-              ba98\\\n-              7654\\\n-              3210\\\n-              fedc\\\n-              ba98\\\n-              7654\\\n-              3210\");\n-\n-        check(\"888877776666555544443333222211110000\", 16,\n-              \"88887777666655554444333322221111\");\n-    }\n-\n-    // `DoubleBigDigit` size dependent\n-    #[test]\n-    fn test_convert_i64() {\n-        fn check(b1: BigUint, i: i64) {\n-            let b2: BigUint = FromPrimitive::from_i64(i).unwrap();\n-            assert!(b1 == b2);\n-            assert!(b1.to_i64().unwrap() == i);\n-        }\n-\n-        check(Zero::zero(), 0);\n-        check(One::one(), 1);\n-        check(i64::MAX.to_biguint().unwrap(), i64::MAX);\n-\n-        check(BigUint::new(vec!(           )), 0);\n-        check(BigUint::new(vec!( 1         )), (1 << (0*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1         )), (1 << (1*BigDigit::bits)) - 1);\n-        check(BigUint::new(vec!( 0,  1     )), (1 << (1*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1, -1 >> 1)), i64::MAX);\n-\n-        assert_eq!(i64::MIN.to_biguint(), None);\n-        assert_eq!(BigUint::new(vec!(-1, -1    )).to_i64(), None);\n-        assert_eq!(BigUint::new(vec!( 0,  0,  1)).to_i64(), None);\n-        assert_eq!(BigUint::new(vec!(-1, -1, -1)).to_i64(), None);\n-    }\n-\n-    // `DoubleBigDigit` size dependent\n-    #[test]\n-    fn test_convert_u64() {\n-        fn check(b1: BigUint, u: u64) {\n-            let b2: BigUint = FromPrimitive::from_u64(u).unwrap();\n-            assert!(b1 == b2);\n-            assert!(b1.to_u64().unwrap() == u);\n-        }\n-\n-        check(Zero::zero(), 0);\n-        check(One::one(), 1);\n-        check(u64::MIN.to_biguint().unwrap(), u64::MIN);\n-        check(u64::MAX.to_biguint().unwrap(), u64::MAX);\n-\n-        check(BigUint::new(vec!(      )), 0);\n-        check(BigUint::new(vec!( 1    )), (1 << (0*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1    )), (1 << (1*BigDigit::bits)) - 1);\n-        check(BigUint::new(vec!( 0,  1)), (1 << (1*BigDigit::bits)));\n-        check(BigUint::new(vec!(-1, -1)), u64::MAX);\n-\n-        assert_eq!(BigUint::new(vec!( 0,  0,  1)).to_u64(), None);\n-        assert_eq!(BigUint::new(vec!(-1, -1, -1)).to_u64(), None);\n-    }\n-\n-    #[test]\n-    fn test_convert_to_bigint() {\n-        fn check(n: BigUint, ans: BigInt) {\n-            assert_eq!(n.to_bigint().unwrap(), ans);\n-            assert_eq!(n.to_bigint().unwrap().to_biguint().unwrap(), n);\n-        }\n-        check(Zero::zero(), Zero::zero());\n-        check(BigUint::new(vec!(1,2,3)),\n-              BigInt::from_biguint(Plus, BigUint::new(vec!(1,2,3))));\n-    }\n-\n-    static SUM_TRIPLES: &'static [(&'static [BigDigit],\n-                                   &'static [BigDigit],\n-                                   &'static [BigDigit])] = &[\n-        (&[],          &[],       &[]),\n-        (&[],          &[ 1],     &[ 1]),\n-        (&[ 1],        &[ 1],     &[ 2]),\n-        (&[ 1],        &[ 1,  1], &[ 2,  1]),\n-        (&[ 1],        &[-1],     &[ 0,  1]),\n-        (&[ 1],        &[-1, -1], &[ 0,  0, 1]),\n-        (&[-1, -1],    &[-1, -1], &[-2, -1, 1]),\n-        (&[ 1,  1, 1], &[-1, -1], &[ 0,  1, 2]),\n-        (&[ 2,  2, 1], &[-1, -2], &[ 1,  1, 2])\n-    ];\n-\n-    #[test]\n-    fn test_add() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            assert!(a + b == c);\n-            assert!(b + a == c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_sub() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            assert!(c - a == b);\n-            assert!(c - b == a);\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_sub_fail_on_underflow() {\n-        let (a, b) : (BigUint, BigUint) = (Zero::zero(), One::one());\n-        a - b;\n-    }\n-\n-    static MUL_TRIPLES: &'static [(&'static [BigDigit],\n-                                   &'static [BigDigit],\n-                                   &'static [BigDigit])] = &[\n-        (&[],               &[],               &[]),\n-        (&[],               &[ 1],             &[]),\n-        (&[ 2],             &[],               &[]),\n-        (&[ 1],             &[ 1],             &[1]),\n-        (&[ 2],             &[ 3],             &[ 6]),\n-        (&[ 1],             &[ 1,  1,  1],     &[1, 1,  1]),\n-        (&[ 1,  2,  3],     &[ 3],             &[ 3,  6,  9]),\n-        (&[ 1,  1,  1],     &[-1],             &[-1, -1, -1]),\n-        (&[ 1,  2,  3],     &[-1],             &[-1, -2, -2, 2]),\n-        (&[ 1,  2,  3,  4], &[-1],             &[-1, -2, -2, -2, 3]),\n-        (&[-1],             &[-1],             &[ 1, -2]),\n-        (&[-1, -1],         &[-1],             &[ 1, -1, -2]),\n-        (&[-1, -1, -1],     &[-1],             &[ 1, -1, -1, -2]),\n-        (&[-1, -1, -1, -1], &[-1],             &[ 1, -1, -1, -1, -2]),\n-        (&[-1/2 + 1],       &[ 2],             &[ 0,  1]),\n-        (&[0, -1/2 + 1],    &[ 2],             &[ 0,  0,  1]),\n-        (&[ 1,  2],         &[ 1,  2,  3],     &[1, 4,  7,  6]),\n-        (&[-1, -1],         &[-1, -1, -1],     &[1, 0, -1, -2, -1]),\n-        (&[-1, -1, -1],     &[-1, -1, -1, -1], &[1, 0,  0, -1, -2, -1, -1]),\n-        (&[ 0,  0,  1],     &[ 1,  2,  3],     &[0, 0,  1,  2,  3]),\n-        (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n-    ];\n-\n-    static DIV_REM_QUADRUPLES: &'static [(&'static [BigDigit],\n-                                           &'static [BigDigit],\n-                                           &'static [BigDigit],\n-                                           &'static [BigDigit])]\n-        = &[\n-            (&[ 1],        &[ 2], &[],               &[1]),\n-            (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n-            (&[ 1,  1, 1], &[ 2], &[-1/2+1, -1/2+1], &[1]),\n-            (&[ 0,  1],    &[-1], &[1],              &[1]),\n-            (&[-1, -1],    &[-2], &[2, 1],           &[3])\n-        ];\n-\n-    #[test]\n-    fn test_mul() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            assert!(a * b == c);\n-            assert!(b * a == c);\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-            let d = BigUint::from_slice(d_vec);\n-\n-            assert!(a == b * c + d);\n-            assert!(a == c * b + d);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_div_rem() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            if !a.is_zero() {\n-                assert_eq!(c.div_rem(&a), (b.clone(), Zero::zero()));\n-            }\n-            if !b.is_zero() {\n-                assert_eq!(c.div_rem(&b), (a.clone(), Zero::zero()));\n-            }\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-            let d = BigUint::from_slice(d_vec);\n-\n-            if !b.is_zero() { assert!(a.div_rem(&b) == (c, d)); }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_add() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            assert!(a.checked_add(&b).unwrap() == c);\n-            assert!(b.checked_add(&a).unwrap() == c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_sub() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            assert!(c.checked_sub(&a).unwrap() == b);\n-            assert!(c.checked_sub(&b).unwrap() == a);\n-\n-            if a > c {\n-                assert!(a.checked_sub(&c).is_none());\n-            }\n-            if b > c {\n-                assert!(b.checked_sub(&c).is_none());\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_mul() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            assert!(a.checked_mul(&b).unwrap() == c);\n-            assert!(b.checked_mul(&a).unwrap() == c);\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-            let d = BigUint::from_slice(d_vec);\n-\n-            assert!(a == b.checked_mul(&c).unwrap() + d);\n-            assert!(a == c.checked_mul(&b).unwrap() + d);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_div() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigUint::from_slice(a_vec);\n-            let b = BigUint::from_slice(b_vec);\n-            let c = BigUint::from_slice(c_vec);\n-\n-            if !a.is_zero() {\n-                assert!(c.checked_div(&a).unwrap() == b);\n-            }\n-            if !b.is_zero() {\n-                assert!(c.checked_div(&b).unwrap() == a);\n-            }\n-\n-            assert!(c.checked_div(&Zero::zero()).is_none());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_gcd() {\n-        fn check(a: uint, b: uint, c: uint) {\n-            let big_a: BigUint = FromPrimitive::from_uint(a).unwrap();\n-            let big_b: BigUint = FromPrimitive::from_uint(b).unwrap();\n-            let big_c: BigUint = FromPrimitive::from_uint(c).unwrap();\n-\n-            assert_eq!(big_a.gcd(&big_b), big_c);\n-        }\n-\n-        check(10, 2, 2);\n-        check(10, 3, 1);\n-        check(0, 3, 3);\n-        check(3, 3, 3);\n-        check(56, 42, 14);\n-    }\n-\n-    #[test]\n-    fn test_lcm() {\n-        fn check(a: uint, b: uint, c: uint) {\n-            let big_a: BigUint = FromPrimitive::from_uint(a).unwrap();\n-            let big_b: BigUint = FromPrimitive::from_uint(b).unwrap();\n-            let big_c: BigUint = FromPrimitive::from_uint(c).unwrap();\n-\n-            assert_eq!(big_a.lcm(&big_b), big_c);\n-        }\n-\n-        check(1, 0, 0);\n-        check(0, 1, 0);\n-        check(1, 1, 1);\n-        check(8, 9, 72);\n-        check(11, 5, 55);\n-        check(99, 17, 1683);\n-    }\n-\n-    #[test]\n-    fn test_is_even() {\n-        let one: BigUint = FromStr::from_str(\"1\").unwrap();\n-        let two: BigUint = FromStr::from_str(\"2\").unwrap();\n-        let thousand: BigUint = FromStr::from_str(\"1000\").unwrap();\n-        let big: BigUint = FromStr::from_str(\"1000000000000000000000\").unwrap();\n-        let bigger: BigUint = FromStr::from_str(\"1000000000000000000001\").unwrap();\n-        assert!(one.is_odd());\n-        assert!(two.is_even());\n-        assert!(thousand.is_even());\n-        assert!(big.is_even());\n-        assert!(bigger.is_odd());\n-        assert!((one << 64).is_even());\n-        assert!(((one << 64) + one).is_odd());\n-    }\n-\n-    fn to_str_pairs() -> Vec<(BigUint, Vec<(uint, String)>)> {\n-        let bits = BigDigit::bits;\n-        vec!(( Zero::zero(), vec!(\n-            (2, \"0\".to_string()), (3, \"0\".to_string())\n-        )), ( BigUint::from_slice([ 0xff ]), vec!(\n-            (2,  \"11111111\".to_string()),\n-            (3,  \"100110\".to_string()),\n-            (4,  \"3333\".to_string()),\n-            (5,  \"2010\".to_string()),\n-            (6,  \"1103\".to_string()),\n-            (7,  \"513\".to_string()),\n-            (8,  \"377\".to_string()),\n-            (9,  \"313\".to_string()),\n-            (10, \"255\".to_string()),\n-            (11, \"212\".to_string()),\n-            (12, \"193\".to_string()),\n-            (13, \"168\".to_string()),\n-            (14, \"143\".to_string()),\n-            (15, \"120\".to_string()),\n-            (16, \"ff\".to_string())\n-        )), ( BigUint::from_slice([ 0xfff ]), vec!(\n-            (2,  \"111111111111\".to_string()),\n-            (4,  \"333333\".to_string()),\n-            (16, \"fff\".to_string())\n-        )), ( BigUint::from_slice([ 1, 2 ]), vec!(\n-            (2,\n-             format!(\"10{}1\", \"0\".repeat(bits - 1))),\n-            (4,\n-             format!(\"2{}1\", \"0\".repeat(bits / 2 - 1))),\n-            (10, match bits {\n-                32 => \"8589934593\".to_string(),\n-                16 => \"131073\".to_string(),\n-                _ => fail!()\n-            }),\n-            (16,\n-             format!(\"2{}1\", \"0\".repeat(bits / 4 - 1)))\n-        )), ( BigUint::from_slice([ 1, 2, 3 ]), vec!(\n-            (2,\n-             format!(\"11{}10{}1\",\n-                     \"0\".repeat(bits - 2),\n-                     \"0\".repeat(bits - 1))),\n-            (4,\n-             format!(\"3{}2{}1\",\n-                     \"0\".repeat(bits / 2 - 1),\n-                     \"0\".repeat(bits / 2 - 1))),\n-            (10, match bits {\n-                32 => \"55340232229718589441\".to_string(),\n-                16 => \"12885032961\".to_string(),\n-                _ => fail!()\n-            }),\n-            (16,\n-             format!(\"3{}2{}1\",\n-                     \"0\".repeat(bits / 4 - 1),\n-                     \"0\".repeat(bits / 4 - 1)))\n-        )) )\n-    }\n-\n-    #[test]\n-    fn test_to_str_radix() {\n-        let r = to_str_pairs();\n-        for num_pair in r.iter() {\n-            let &(ref n, ref rs) = num_pair;\n-            for str_pair in rs.iter() {\n-                let &(ref radix, ref str) = str_pair;\n-                assert_eq!(n.to_str_radix(*radix).as_slice(),\n-                           str.as_slice());\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix() {\n-        let r = to_str_pairs();\n-        for num_pair in r.iter() {\n-            let &(ref n, ref rs) = num_pair;\n-            for str_pair in rs.iter() {\n-                let &(ref radix, ref str) = str_pair;\n-                assert_eq!(n,\n-                           &FromStrRadix::from_str_radix(str.as_slice(),\n-                                                         *radix).unwrap());\n-            }\n-        }\n-\n-        let zed: Option<BigUint> = FromStrRadix::from_str_radix(\"Z\", 10);\n-        assert_eq!(zed, None);\n-        let blank: Option<BigUint> = FromStrRadix::from_str_radix(\"_\", 2);\n-        assert_eq!(blank, None);\n-        let minus_one: Option<BigUint> = FromStrRadix::from_str_radix(\"-1\",\n-                                                                      10);\n-        assert_eq!(minus_one, None);\n-    }\n-\n-    #[test]\n-    fn test_factor() {\n-        fn factor(n: uint) -> BigUint {\n-            let mut f: BigUint = One::one();\n-            for i in range(2, n + 1) {\n-                // FIXME(#5992): assignment operator overloads\n-                // f *= FromPrimitive::from_uint(i);\n-                f = f * FromPrimitive::from_uint(i).unwrap();\n-            }\n-            return f;\n-        }\n-\n-        fn check(n: uint, s: &str) {\n-            let n = factor(n);\n-            let ans = match FromStrRadix::from_str_radix(s, 10) {\n-                Some(x) => x, None => fail!()\n-            };\n-            assert_eq!(n, ans);\n-        }\n-\n-        check(3, \"6\");\n-        check(10, \"3628800\");\n-        check(20, \"2432902008176640000\");\n-        check(30, \"265252859812191058636308480000000\");\n-    }\n-\n-    #[test]\n-    fn test_bits() {\n-        assert_eq!(BigUint::new(vec!(0,0,0,0)).bits(), 0);\n-        let n: BigUint = FromPrimitive::from_uint(0).unwrap();\n-        assert_eq!(n.bits(), 0);\n-        let n: BigUint = FromPrimitive::from_uint(1).unwrap();\n-        assert_eq!(n.bits(), 1);\n-        let n: BigUint = FromPrimitive::from_uint(3).unwrap();\n-        assert_eq!(n.bits(), 2);\n-        let n: BigUint = FromStrRadix::from_str_radix(\"4000000000\", 16).unwrap();\n-        assert_eq!(n.bits(), 39);\n-        let one: BigUint = One::one();\n-        assert_eq!((one << 426).bits(), 427);\n-    }\n-\n-    #[test]\n-    fn test_rand() {\n-        let mut rng = task_rng();\n-        let _n: BigUint = rng.gen_biguint(137);\n-        assert!(rng.gen_biguint(0).is_zero());\n-    }\n-\n-    #[test]\n-    fn test_rand_range() {\n-        let mut rng = task_rng();\n-\n-        for _ in range(0u, 10) {\n-            assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n-                                            &FromPrimitive::from_uint(237).unwrap()),\n-                       FromPrimitive::from_uint(236).unwrap());\n-        }\n-\n-        let l = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n-        let u = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n-        for _ in range(0u, 1000) {\n-            let n: BigUint = rng.gen_biguint_below(&u);\n-            assert!(n < u);\n-\n-            let n: BigUint = rng.gen_biguint_range(&l, &u);\n-            assert!(n >= l);\n-            assert!(n < u);\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_zero_rand_range() {\n-        task_rng().gen_biguint_range(&FromPrimitive::from_uint(54).unwrap(),\n-                                     &FromPrimitive::from_uint(54).unwrap());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_negative_rand_range() {\n-        let mut rng = task_rng();\n-        let l = FromPrimitive::from_uint(2352).unwrap();\n-        let u = FromPrimitive::from_uint(3513).unwrap();\n-        // Switching u and l should fail:\n-        let _n: BigUint = rng.gen_biguint_range(&u, &l);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bigint_tests {\n-    use Integer;\n-    use super::{BigDigit, BigUint, ToBigUint};\n-    use super::{Sign, Minus, NoSign, Plus, BigInt, RandBigInt, ToBigInt};\n-\n-    use std::cmp::{Less, Equal, Greater};\n-    use std::i64;\n-    use std::num::CheckedDiv;\n-    use std::num::{Zero, One, FromStrRadix, ToStrRadix};\n-    use std::num::{ToPrimitive, FromPrimitive};\n-    use std::rand::task_rng;\n-    use std::u64;\n-    use std::hash::hash;\n-\n-    #[test]\n-    fn test_from_biguint() {\n-        fn check(inp_s: Sign, inp_n: uint, ans_s: Sign, ans_n: uint) {\n-            let inp = BigInt::from_biguint(inp_s, FromPrimitive::from_uint(inp_n).unwrap());\n-            let ans = BigInt { sign: ans_s, data: FromPrimitive::from_uint(ans_n).unwrap()};\n-            assert_eq!(inp, ans);\n-        }\n-        check(Plus, 1, Plus, 1);\n-        check(Plus, 0, NoSign, 0);\n-        check(Minus, 1, Minus, 1);\n-        check(NoSign, 1, NoSign, 0);\n-    }\n-\n-    #[test]\n-    fn test_cmp() {\n-        let vs: [&[BigDigit], ..4] = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n-        let mut nums = Vec::new();\n-        for s in vs.iter().rev() {\n-            nums.push(BigInt::from_slice(Minus, *s));\n-        }\n-        nums.push(Zero::zero());\n-        nums.extend(vs.iter().map(|s| BigInt::from_slice(Plus, *s)));\n-\n-        for (i, ni) in nums.iter().enumerate() {\n-            for (j0, nj) in nums.slice(i, nums.len()).iter().enumerate() {\n-                let j = i + j0;\n-                if i == j {\n-                    assert_eq!(ni.cmp(nj), Equal);\n-                    assert_eq!(nj.cmp(ni), Equal);\n-                    assert_eq!(ni, nj);\n-                    assert!(!(ni != nj));\n-                    assert!(ni <= nj);\n-                    assert!(ni >= nj);\n-                    assert!(!(ni < nj));\n-                    assert!(!(ni > nj));\n-                } else {\n-                    assert_eq!(ni.cmp(nj), Less);\n-                    assert_eq!(nj.cmp(ni), Greater);\n-\n-                    assert!(!(ni == nj));\n-                    assert!(ni != nj);\n-\n-                    assert!(ni <= nj);\n-                    assert!(!(ni >= nj));\n-                    assert!(ni < nj);\n-                    assert!(!(ni > nj));\n-\n-                    assert!(!(nj <= ni));\n-                    assert!(nj >= ni);\n-                    assert!(!(nj < ni));\n-                    assert!(nj > ni);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-        let a = BigInt::new(NoSign, vec!());\n-        let b = BigInt::new(NoSign, vec!(0));\n-        let c = BigInt::new(Plus, vec!(1));\n-        let d = BigInt::new(Plus, vec!(1,0,0,0,0,0));\n-        let e = BigInt::new(Plus, vec!(0,0,0,0,0,1));\n-        let f = BigInt::new(Minus, vec!(1));\n-        assert!(hash(&a) == hash(&b));\n-        assert!(hash(&b) != hash(&c));\n-        assert!(hash(&c) == hash(&d));\n-        assert!(hash(&d) != hash(&e));\n-        assert!(hash(&c) != hash(&f));\n-    }\n-\n-    #[test]\n-    fn test_convert_i64() {\n-        fn check(b1: BigInt, i: i64) {\n-            let b2: BigInt = FromPrimitive::from_i64(i).unwrap();\n-            assert!(b1 == b2);\n-            assert!(b1.to_i64().unwrap() == i);\n-        }\n-\n-        check(Zero::zero(), 0);\n-        check(One::one(), 1);\n-        check(i64::MIN.to_bigint().unwrap(), i64::MIN);\n-        check(i64::MAX.to_bigint().unwrap(), i64::MAX);\n-\n-        assert_eq!(\n-            (i64::MAX as u64 + 1).to_bigint().unwrap().to_i64(),\n-            None);\n-\n-        assert_eq!(\n-            BigInt::from_biguint(Plus,  BigUint::new(vec!(1, 2, 3, 4, 5))).to_i64(),\n-            None);\n-\n-        assert_eq!(\n-            BigInt::from_biguint(Minus, BigUint::new(vec!(1,0,0,1<<(BigDigit::bits-1)))).to_i64(),\n-            None);\n-\n-        assert_eq!(\n-            BigInt::from_biguint(Minus, BigUint::new(vec!(1, 2, 3, 4, 5))).to_i64(),\n-            None);\n-    }\n-\n-    #[test]\n-    fn test_convert_u64() {\n-        fn check(b1: BigInt, u: u64) {\n-            let b2: BigInt = FromPrimitive::from_u64(u).unwrap();\n-            assert!(b1 == b2);\n-            assert!(b1.to_u64().unwrap() == u);\n-        }\n-\n-        check(Zero::zero(), 0);\n-        check(One::one(), 1);\n-        check(u64::MIN.to_bigint().unwrap(), u64::MIN);\n-        check(u64::MAX.to_bigint().unwrap(), u64::MAX);\n-\n-        assert_eq!(\n-            BigInt::from_biguint(Plus, BigUint::new(vec!(1, 2, 3, 4, 5))).to_u64(),\n-            None);\n-\n-        let max_value: BigUint = FromPrimitive::from_u64(u64::MAX).unwrap();\n-        assert_eq!(BigInt::from_biguint(Minus, max_value).to_u64(), None);\n-        assert_eq!(BigInt::from_biguint(Minus, BigUint::new(vec!(1, 2, 3, 4, 5))).to_u64(), None);\n-    }\n-\n-    #[test]\n-    fn test_convert_to_biguint() {\n-        fn check(n: BigInt, ans_1: BigUint) {\n-            assert_eq!(n.to_biguint().unwrap(), ans_1);\n-            assert_eq!(n.to_biguint().unwrap().to_bigint().unwrap(), n);\n-        }\n-        let zero: BigInt = Zero::zero();\n-        let unsigned_zero: BigUint = Zero::zero();\n-        let positive = BigInt::from_biguint(\n-            Plus, BigUint::new(vec!(1,2,3)));\n-        let negative = -positive;\n-\n-        check(zero, unsigned_zero);\n-        check(positive, BigUint::new(vec!(1,2,3)));\n-\n-        assert_eq!(negative.to_biguint(), None);\n-    }\n-\n-    static SUM_TRIPLES: &'static [(&'static [BigDigit],\n-                                   &'static [BigDigit],\n-                                   &'static [BigDigit])] = &[\n-        (&[],          &[],       &[]),\n-        (&[],          &[ 1],     &[ 1]),\n-        (&[ 1],        &[ 1],     &[ 2]),\n-        (&[ 1],        &[ 1,  1], &[ 2,  1]),\n-        (&[ 1],        &[-1],     &[ 0,  1]),\n-        (&[ 1],        &[-1, -1], &[ 0,  0, 1]),\n-        (&[-1, -1],    &[-1, -1], &[-2, -1, 1]),\n-        (&[ 1,  1, 1], &[-1, -1], &[ 0,  1, 2]),\n-        (&[ 2,  2, 1], &[-1, -2], &[ 1,  1, 2])\n-    ];\n-\n-    #[test]\n-    fn test_add() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            assert!(a + b == c);\n-            assert!(b + a == c);\n-            assert!(c + (-a) == b);\n-            assert!(c + (-b) == a);\n-            assert!(a + (-c) == (-b));\n-            assert!(b + (-c) == (-a));\n-            assert!((-a) + (-b) == (-c))\n-            assert!(a + (-a) == Zero::zero());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_sub() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            assert!(c - a == b);\n-            assert!(c - b == a);\n-            assert!((-b) - a == (-c))\n-            assert!((-a) - b == (-c))\n-            assert!(b - (-a) == c);\n-            assert!(a - (-b) == c);\n-            assert!((-c) - (-a) == (-b));\n-            assert!(a - a == Zero::zero());\n-        }\n-    }\n-\n-    static MUL_TRIPLES: &'static [(&'static [BigDigit],\n-                                   &'static [BigDigit],\n-                                   &'static [BigDigit])] = &[\n-        (&[],               &[],               &[]),\n-        (&[],               &[ 1],             &[]),\n-        (&[ 2],             &[],               &[]),\n-        (&[ 1],             &[ 1],             &[1]),\n-        (&[ 2],             &[ 3],             &[ 6]),\n-        (&[ 1],             &[ 1,  1,  1],     &[1, 1,  1]),\n-        (&[ 1,  2,  3],     &[ 3],             &[ 3,  6,  9]),\n-        (&[ 1,  1,  1],     &[-1],             &[-1, -1, -1]),\n-        (&[ 1,  2,  3],     &[-1],             &[-1, -2, -2, 2]),\n-        (&[ 1,  2,  3,  4], &[-1],             &[-1, -2, -2, -2, 3]),\n-        (&[-1],             &[-1],             &[ 1, -2]),\n-        (&[-1, -1],         &[-1],             &[ 1, -1, -2]),\n-        (&[-1, -1, -1],     &[-1],             &[ 1, -1, -1, -2]),\n-        (&[-1, -1, -1, -1], &[-1],             &[ 1, -1, -1, -1, -2]),\n-        (&[-1/2 + 1],       &[ 2],             &[ 0,  1]),\n-        (&[0, -1/2 + 1],    &[ 2],             &[ 0,  0,  1]),\n-        (&[ 1,  2],         &[ 1,  2,  3],     &[1, 4,  7,  6]),\n-        (&[-1, -1],         &[-1, -1, -1],     &[1, 0, -1, -2, -1]),\n-        (&[-1, -1, -1],     &[-1, -1, -1, -1], &[1, 0,  0, -1, -2, -1, -1]),\n-        (&[ 0,  0,  1],     &[ 1,  2,  3],     &[0, 0,  1,  2,  3]),\n-        (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n-    ];\n-\n-    static DIV_REM_QUADRUPLES: &'static [(&'static [BigDigit],\n-                                          &'static [BigDigit],\n-                                          &'static [BigDigit],\n-                                          &'static [BigDigit])]\n-        = &[\n-            (&[ 1],        &[ 2], &[],               &[1]),\n-            (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n-            (&[ 1,  1, 1], &[ 2], &[-1/2+1, -1/2+1], &[1]),\n-            (&[ 0,  1],    &[-1], &[1],              &[1]),\n-            (&[-1, -1],    &[-2], &[2, 1],           &[3])\n-        ];\n-\n-    #[test]\n-    fn test_mul() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            assert!(a * b == c);\n-            assert!(b * a == c);\n-\n-            assert!((-a) * b == -c);\n-            assert!((-b) * a == -c);\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-            let d = BigInt::from_slice(Plus, d_vec);\n-\n-            assert!(a == b * c + d);\n-            assert!(a == c * b + d);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_div_mod_floor() {\n-        fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) {\n-            let (d, m) = a.div_mod_floor(b);\n-            if !m.is_zero() {\n-                assert_eq!(m.sign, b.sign);\n-            }\n-            assert!(m.abs() <= b.abs());\n-            assert!(*a == b * d + m);\n-            assert!(d == *ans_d);\n-            assert!(m == *ans_m);\n-        }\n-\n-        fn check(a: &BigInt, b: &BigInt, d: &BigInt, m: &BigInt) {\n-            if m.is_zero() {\n-                check_sub(a, b, d, m);\n-                check_sub(a, &b.neg(), &d.neg(), m);\n-                check_sub(&a.neg(), b, &d.neg(), m);\n-                check_sub(&a.neg(), &b.neg(), d, m);\n-            } else {\n-                check_sub(a, b, d, m);\n-                check_sub(a, &b.neg(), &(d.neg() - One::one()), &(m - *b));\n-                check_sub(&a.neg(), b, &(d.neg() - One::one()), &(b - *m));\n-                check_sub(&a.neg(), &b.neg(), d, &m.neg());\n-            }\n-        }\n-\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            if !a.is_zero() { check(&c, &a, &b, &Zero::zero()); }\n-            if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-            let d = BigInt::from_slice(Plus, d_vec);\n-\n-            if !b.is_zero() {\n-                check(&a, &b, &c, &d);\n-            }\n-        }\n-    }\n-\n-\n-    #[test]\n-    fn test_div_rem() {\n-        fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) {\n-            let (q, r) = a.div_rem(b);\n-            if !r.is_zero() {\n-                assert_eq!(r.sign, a.sign);\n-            }\n-            assert!(r.abs() <= b.abs());\n-            assert!(*a == b * q + r);\n-            assert!(q == *ans_q);\n-            assert!(r == *ans_r);\n-        }\n-\n-        fn check(a: &BigInt, b: &BigInt, q: &BigInt, r: &BigInt) {\n-            check_sub(a, b, q, r);\n-            check_sub(a, &b.neg(), &q.neg(), r);\n-            check_sub(&a.neg(), b, &q.neg(), &r.neg());\n-            check_sub(&a.neg(), &b.neg(), q, &r.neg());\n-        }\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            if !a.is_zero() { check(&c, &a, &b, &Zero::zero()); }\n-            if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-            let d = BigInt::from_slice(Plus, d_vec);\n-\n-            if !b.is_zero() {\n-                check(&a, &b, &c, &d);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_add() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            assert!(a.checked_add(&b).unwrap() == c);\n-            assert!(b.checked_add(&a).unwrap() == c);\n-            assert!(c.checked_add(&(-a)).unwrap() == b);\n-            assert!(c.checked_add(&(-b)).unwrap() == a);\n-            assert!(a.checked_add(&(-c)).unwrap() == (-b));\n-            assert!(b.checked_add(&(-c)).unwrap() == (-a));\n-            assert!((-a).checked_add(&(-b)).unwrap() == (-c))\n-            assert!(a.checked_add(&(-a)).unwrap() == Zero::zero());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_sub() {\n-        for elm in SUM_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            assert!(c.checked_sub(&a).unwrap() == b);\n-            assert!(c.checked_sub(&b).unwrap() == a);\n-            assert!((-b).checked_sub(&a).unwrap() == (-c))\n-            assert!((-a).checked_sub(&b).unwrap() == (-c))\n-            assert!(b.checked_sub(&(-a)).unwrap() == c);\n-            assert!(a.checked_sub(&(-b)).unwrap() == c);\n-            assert!((-c).checked_sub(&(-a)).unwrap() == (-b));\n-            assert!(a.checked_sub(&a).unwrap() == Zero::zero());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_checked_mul() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            assert!(a.checked_mul(&b).unwrap() == c);\n-            assert!(b.checked_mul(&a).unwrap() == c);\n-\n-            assert!((-a).checked_mul(&b).unwrap() == -c);\n-            assert!((-b).checked_mul(&a).unwrap() == -c);\n-        }\n-\n-        for elm in DIV_REM_QUADRUPLES.iter() {\n-            let (a_vec, b_vec, c_vec, d_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-            let d = BigInt::from_slice(Plus, d_vec);\n-\n-            assert!(a == b.checked_mul(&c).unwrap() + d);\n-            assert!(a == c.checked_mul(&b).unwrap() + d);\n-        }\n-    }\n-    #[test]\n-    fn test_checked_div() {\n-        for elm in MUL_TRIPLES.iter() {\n-            let (a_vec, b_vec, c_vec) = *elm;\n-            let a = BigInt::from_slice(Plus, a_vec);\n-            let b = BigInt::from_slice(Plus, b_vec);\n-            let c = BigInt::from_slice(Plus, c_vec);\n-\n-            if !a.is_zero() {\n-                assert!(c.checked_div(&a).unwrap() == b);\n-                assert!((-c).checked_div(&(-a)).unwrap() == b);\n-                assert!((-c).checked_div(&a).unwrap() == -b);\n-            }\n-            if !b.is_zero() {\n-                assert!(c.checked_div(&b).unwrap() == a);\n-                assert!((-c).checked_div(&(-b)).unwrap() == a);\n-                assert!((-c).checked_div(&b).unwrap() == -a);\n-            }\n-\n-            assert!(c.checked_div(&Zero::zero()).is_none());\n-            assert!((-c).checked_div(&Zero::zero()).is_none());\n-        }\n-    }\n-\n-    #[test]\n-    fn test_gcd() {\n-        fn check(a: int, b: int, c: int) {\n-            let big_a: BigInt = FromPrimitive::from_int(a).unwrap();\n-            let big_b: BigInt = FromPrimitive::from_int(b).unwrap();\n-            let big_c: BigInt = FromPrimitive::from_int(c).unwrap();\n-\n-            assert_eq!(big_a.gcd(&big_b), big_c);\n-        }\n-\n-        check(10, 2, 2);\n-        check(10, 3, 1);\n-        check(0, 3, 3);\n-        check(3, 3, 3);\n-        check(56, 42, 14);\n-        check(3, -3, 3);\n-        check(-6, 3, 3);\n-        check(-4, -2, 2);\n-    }\n-\n-    #[test]\n-    fn test_lcm() {\n-        fn check(a: int, b: int, c: int) {\n-            let big_a: BigInt = FromPrimitive::from_int(a).unwrap();\n-            let big_b: BigInt = FromPrimitive::from_int(b).unwrap();\n-            let big_c: BigInt = FromPrimitive::from_int(c).unwrap();\n-\n-            assert_eq!(big_a.lcm(&big_b), big_c);\n-        }\n-\n-        check(1, 0, 0);\n-        check(0, 1, 0);\n-        check(1, 1, 1);\n-        check(-1, 1, 1);\n-        check(1, -1, 1);\n-        check(-1, -1, 1);\n-        check(8, 9, 72);\n-        check(11, 5, 55);\n-    }\n-\n-    #[test]\n-    fn test_abs_sub() {\n-        let zero: BigInt = Zero::zero();\n-        let one: BigInt = One::one();\n-        assert_eq!((-one).abs_sub(&one), zero);\n-        let one: BigInt = One::one();\n-        let zero: BigInt = Zero::zero();\n-        assert_eq!(one.abs_sub(&one), zero);\n-        let one: BigInt = One::one();\n-        let zero: BigInt = Zero::zero();\n-        assert_eq!(one.abs_sub(&zero), one);\n-        let one: BigInt = One::one();\n-        let two: BigInt = FromPrimitive::from_int(2).unwrap();\n-        assert_eq!(one.abs_sub(&-one), two);\n-    }\n-\n-    #[test]\n-    fn test_to_str_radix() {\n-        fn check(n: int, ans: &str) {\n-            let n: BigInt = FromPrimitive::from_int(n).unwrap();\n-            assert!(ans == n.to_str_radix(10).as_slice());\n-        }\n-        check(10, \"10\");\n-        check(1, \"1\");\n-        check(0, \"0\");\n-        check(-1, \"-1\");\n-        check(-10, \"-10\");\n-    }\n-\n-\n-    #[test]\n-    fn test_from_str_radix() {\n-        fn check(s: &str, ans: Option<int>) {\n-            let ans = ans.map(|n| {\n-                let x: BigInt = FromPrimitive::from_int(n).unwrap();\n-                x\n-            });\n-            assert_eq!(FromStrRadix::from_str_radix(s, 10), ans);\n-        }\n-        check(\"10\", Some(10));\n-        check(\"1\", Some(1));\n-        check(\"0\", Some(0));\n-        check(\"-1\", Some(-1));\n-        check(\"-10\", Some(-10));\n-        check(\"Z\", None);\n-        check(\"_\", None);\n-\n-        // issue 10522, this hit an edge case that caused it to\n-        // attempt to allocate a vector of size (-1u) == huge.\n-        let x: BigInt =\n-            from_str(format!(\"1{}\", \"0\".repeat(36)).as_slice()).unwrap();\n-        let _y = x.to_string();\n-    }\n-\n-    #[test]\n-    fn test_neg() {\n-        assert!(-BigInt::new(Plus,  vec!(1, 1, 1)) ==\n-            BigInt::new(Minus, vec!(1, 1, 1)));\n-        assert!(-BigInt::new(Minus, vec!(1, 1, 1)) ==\n-            BigInt::new(Plus,  vec!(1, 1, 1)));\n-        let zero: BigInt = Zero::zero();\n-        assert_eq!(-zero, zero);\n-    }\n-\n-    #[test]\n-    fn test_rand() {\n-        let mut rng = task_rng();\n-        let _n: BigInt = rng.gen_bigint(137);\n-        assert!(rng.gen_bigint(0).is_zero());\n-    }\n-\n-    #[test]\n-    fn test_rand_range() {\n-        let mut rng = task_rng();\n-\n-        for _ in range(0u, 10) {\n-            assert_eq!(rng.gen_bigint_range(&FromPrimitive::from_uint(236).unwrap(),\n-                                            &FromPrimitive::from_uint(237).unwrap()),\n-                       FromPrimitive::from_uint(236).unwrap());\n-        }\n-\n-        fn check(l: BigInt, u: BigInt) {\n-            let mut rng = task_rng();\n-            for _ in range(0u, 1000) {\n-                let n: BigInt = rng.gen_bigint_range(&l, &u);\n-                assert!(n >= l);\n-                assert!(n < u);\n-            }\n-        }\n-        let l: BigInt = FromPrimitive::from_uint(403469000 + 2352).unwrap();\n-        let u: BigInt = FromPrimitive::from_uint(403469000 + 3513).unwrap();\n-        check( l.clone(),  u.clone());\n-        check(-l.clone(),  u.clone());\n-        check(-u.clone(), -l.clone());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_zero_rand_range() {\n-        task_rng().gen_bigint_range(&FromPrimitive::from_int(54).unwrap(),\n-                                    &FromPrimitive::from_int(54).unwrap());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_negative_rand_range() {\n-        let mut rng = task_rng();\n-        let l = FromPrimitive::from_uint(2352).unwrap();\n-        let u = FromPrimitive::from_uint(3513).unwrap();\n-        // Switching u and l should fail:\n-        let _n: BigInt = rng.gen_bigint_range(&u, &l);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use super::BigUint;\n-    use std::iter;\n-    use std::mem::replace;\n-    use std::num::{FromPrimitive, Zero, One};\n-\n-    fn factorial(n: uint) -> BigUint {\n-        let mut f: BigUint = One::one();\n-        for i in iter::range_inclusive(1, n) {\n-            f = f * FromPrimitive::from_uint(i).unwrap();\n-        }\n-        f\n-    }\n-\n-    fn fib(n: uint) -> BigUint {\n-        let mut f0: BigUint = Zero::zero();\n-        let mut f1: BigUint = One::one();\n-        for _ in range(0, n) {\n-            let f2 = f0 + f1;\n-            f0 = replace(&mut f1, f2);\n-        }\n-        f0\n-    }\n-\n-    #[bench]\n-    fn factorial_100(b: &mut Bencher) {\n-        b.iter(|| {\n-            factorial(100);\n-        });\n-    }\n-\n-    #[bench]\n-    fn fib_100(b: &mut Bencher) {\n-        b.iter(|| {\n-            fib(100);\n-        });\n-    }\n-\n-    #[bench]\n-    fn to_string(b: &mut Bencher) {\n-        let fac = factorial(100);\n-        let fib = fib(100);\n-        b.iter(|| {\n-            fac.to_string();\n-        });\n-        b.iter(|| {\n-            fib.to_string();\n-        });\n-    }\n-\n-    #[bench]\n-    fn shr(b: &mut Bencher) {\n-        let n = { let one : BigUint = One::one(); one << 1000 };\n-        b.iter(|| {\n-            let mut m = n.clone();\n-            for _ in range(0u, 10) {\n-                m = m >> 1;\n-            }\n-        })\n-    }\n-}"}, {"sha": "6690b1d5ddc7acd3b7c4b6f842e36a6e64b0cdd3", "filename": "src/libnum/complex.rs", "status": "removed", "additions": 0, "deletions": 379, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,379 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-//! Complex numbers.\n-\n-use std::fmt;\n-use std::num::{Zero, One, ToStrRadix};\n-\n-// FIXME #1284: handle complex NaN & infinity etc. This\n-// probably doesn't map to C's _Complex correctly.\n-\n-/// A complex number in Cartesian form.\n-#[deriving(PartialEq, Clone, Hash)]\n-pub struct Complex<T> {\n-    /// Real portion of the complex number\n-    pub re: T,\n-    /// Imaginary portion of the complex number\n-    pub im: T\n-}\n-\n-pub type Complex32 = Complex<f32>;\n-pub type Complex64 = Complex<f64>;\n-\n-impl<T: Clone + Num> Complex<T> {\n-    /// Create a new Complex\n-    #[inline]\n-    pub fn new(re: T, im: T) -> Complex<T> {\n-        Complex { re: re, im: im }\n-    }\n-\n-    /// Returns the square of the norm (since `T` doesn't necessarily\n-    /// have a sqrt function), i.e. `re^2 + im^2`.\n-    #[inline]\n-    pub fn norm_sqr(&self) -> T {\n-        self.re * self.re + self.im * self.im\n-    }\n-\n-\n-    /// Returns the complex conjugate. i.e. `re - i im`\n-    #[inline]\n-    pub fn conj(&self) -> Complex<T> {\n-        Complex::new(self.re.clone(), -self.im)\n-    }\n-\n-\n-    /// Multiplies `self` by the scalar `t`.\n-    #[inline]\n-    pub fn scale(&self, t: T) -> Complex<T> {\n-        Complex::new(self.re * t, self.im * t)\n-    }\n-\n-    /// Divides `self` by the scalar `t`.\n-    #[inline]\n-    pub fn unscale(&self, t: T) -> Complex<T> {\n-        Complex::new(self.re / t, self.im / t)\n-    }\n-\n-    /// Returns `1/self`\n-    #[inline]\n-    pub fn inv(&self) -> Complex<T> {\n-        let norm_sqr = self.norm_sqr();\n-        Complex::new(self.re / norm_sqr,\n-                    -self.im / norm_sqr)\n-    }\n-}\n-\n-impl<T: Clone + FloatMath> Complex<T> {\n-    /// Calculate |self|\n-    #[inline]\n-    pub fn norm(&self) -> T {\n-        self.re.hypot(self.im)\n-    }\n-}\n-\n-impl<T: Clone + FloatMath> Complex<T> {\n-    /// Calculate the principal Arg of self.\n-    #[inline]\n-    pub fn arg(&self) -> T {\n-        self.im.atan2(self.re)\n-    }\n-    /// Convert to polar form (r, theta), such that `self = r * exp(i\n-    /// * theta)`\n-    #[inline]\n-    pub fn to_polar(&self) -> (T, T) {\n-        (self.norm(), self.arg())\n-    }\n-    /// Convert a polar representation into a complex number.\n-    #[inline]\n-    pub fn from_polar(r: &T, theta: &T) -> Complex<T> {\n-        Complex::new(*r * theta.cos(), *r * theta.sin())\n-    }\n-}\n-\n-/* arithmetic */\n-// (a + i b) + (c + i d) == (a + c) + i (b + d)\n-impl<T: Clone + Num> Add<Complex<T>, Complex<T>> for Complex<T> {\n-    #[inline]\n-    fn add(&self, other: &Complex<T>) -> Complex<T> {\n-        Complex::new(self.re + other.re, self.im + other.im)\n-    }\n-}\n-// (a + i b) - (c + i d) == (a - c) + i (b - d)\n-impl<T: Clone + Num> Sub<Complex<T>, Complex<T>> for Complex<T> {\n-    #[inline]\n-    fn sub(&self, other: &Complex<T>) -> Complex<T> {\n-        Complex::new(self.re - other.re, self.im - other.im)\n-    }\n-}\n-// (a + i b) * (c + i d) == (a*c - b*d) + i (a*d + b*c)\n-impl<T: Clone + Num> Mul<Complex<T>, Complex<T>> for Complex<T> {\n-    #[inline]\n-    fn mul(&self, other: &Complex<T>) -> Complex<T> {\n-        Complex::new(self.re*other.re - self.im*other.im,\n-                   self.re*other.im + self.im*other.re)\n-    }\n-}\n-\n-// (a + i b) / (c + i d) == [(a + i b) * (c - i d)] / (c*c + d*d)\n-//   == [(a*c + b*d) / (c*c + d*d)] + i [(b*c - a*d) / (c*c + d*d)]\n-impl<T: Clone + Num> Div<Complex<T>, Complex<T>> for Complex<T> {\n-    #[inline]\n-    fn div(&self, other: &Complex<T>) -> Complex<T> {\n-        let norm_sqr = other.norm_sqr();\n-        Complex::new((self.re*other.re + self.im*other.im) / norm_sqr,\n-                   (self.im*other.re - self.re*other.im) / norm_sqr)\n-    }\n-}\n-\n-impl<T: Clone + Num> Neg<Complex<T>> for Complex<T> {\n-    #[inline]\n-    fn neg(&self) -> Complex<T> {\n-        Complex::new(-self.re, -self.im)\n-    }\n-}\n-\n-/* constants */\n-impl<T: Clone + Num> Zero for Complex<T> {\n-    #[inline]\n-    fn zero() -> Complex<T> {\n-        Complex::new(Zero::zero(), Zero::zero())\n-    }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        self.re.is_zero() && self.im.is_zero()\n-    }\n-}\n-\n-impl<T: Clone + Num> One for Complex<T> {\n-    #[inline]\n-    fn one() -> Complex<T> {\n-        Complex::new(One::one(), Zero::zero())\n-    }\n-}\n-\n-/* string conversions */\n-impl<T: fmt::Show + Num + PartialOrd> fmt::Show for Complex<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.im < Zero::zero() {\n-            write!(f, \"{}-{}i\", self.re, -self.im)\n-        } else {\n-            write!(f, \"{}+{}i\", self.re, self.im)\n-        }\n-    }\n-}\n-\n-impl<T: ToStrRadix + Num + PartialOrd> ToStrRadix for Complex<T> {\n-    fn to_str_radix(&self, radix: uint) -> String {\n-        if self.im < Zero::zero() {\n-            format!(\"{}-{}i\",\n-                    self.re.to_str_radix(radix),\n-                    (-self.im).to_str_radix(radix))\n-        } else {\n-            format!(\"{}+{}i\",\n-                    self.re.to_str_radix(radix),\n-                    self.im.to_str_radix(radix))\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    #![allow(non_uppercase_statics)]\n-\n-    use super::{Complex64, Complex};\n-    use std::num::{Zero, One, Float};\n-    use std::hash::hash;\n-\n-    pub const _0_0i : Complex64 = Complex { re: 0.0, im: 0.0 };\n-    pub const _1_0i : Complex64 = Complex { re: 1.0, im: 0.0 };\n-    pub const _1_1i : Complex64 = Complex { re: 1.0, im: 1.0 };\n-    pub const _0_1i : Complex64 = Complex { re: 0.0, im: 1.0 };\n-    pub const _neg1_1i : Complex64 = Complex { re: -1.0, im: 1.0 };\n-    pub const _05_05i : Complex64 = Complex { re: 0.5, im: 0.5 };\n-    pub const all_consts : [Complex64, .. 5] = [_0_0i, _1_0i, _1_1i, _neg1_1i, _05_05i];\n-\n-    #[test]\n-    fn test_consts() {\n-        // check our constants are what Complex::new creates\n-        fn test(c : Complex64, r : f64, i: f64) {\n-            assert_eq!(c, Complex::new(r,i));\n-        }\n-        test(_0_0i, 0.0, 0.0);\n-        test(_1_0i, 1.0, 0.0);\n-        test(_1_1i, 1.0, 1.0);\n-        test(_neg1_1i, -1.0, 1.0);\n-        test(_05_05i, 0.5, 0.5);\n-\n-        assert_eq!(_0_0i, Zero::zero());\n-        assert_eq!(_1_0i, One::one());\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_arch = \"x86\", ignore)]\n-    // FIXME #7158: (maybe?) currently failing on x86.\n-    fn test_norm() {\n-        fn test(c: Complex64, ns: f64) {\n-            assert_eq!(c.norm_sqr(), ns);\n-            assert_eq!(c.norm(), ns.sqrt())\n-        }\n-        test(_0_0i, 0.0);\n-        test(_1_0i, 1.0);\n-        test(_1_1i, 2.0);\n-        test(_neg1_1i, 2.0);\n-        test(_05_05i, 0.5);\n-    }\n-\n-    #[test]\n-    fn test_scale_unscale() {\n-        assert_eq!(_05_05i.scale(2.0), _1_1i);\n-        assert_eq!(_1_1i.unscale(2.0), _05_05i);\n-        for &c in all_consts.iter() {\n-            assert_eq!(c.scale(2.0).unscale(2.0), c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_conj() {\n-        for &c in all_consts.iter() {\n-            assert_eq!(c.conj(), Complex::new(c.re, -c.im));\n-            assert_eq!(c.conj().conj(), c);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_inv() {\n-        assert_eq!(_1_1i.inv(), _05_05i.conj());\n-        assert_eq!(_1_0i.inv(), _1_0i.inv());\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_divide_by_zero_natural() {\n-        let n = Complex::new(2i, 3i);\n-        let d = Complex::new(0, 0);\n-        let _x = n / d;\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    #[ignore]\n-    fn test_inv_zero() {\n-        // FIXME #5736: should this really fail, or just NaN?\n-        _0_0i.inv();\n-    }\n-\n-    #[test]\n-    fn test_arg() {\n-        fn test(c: Complex64, arg: f64) {\n-            assert!((c.arg() - arg).abs() < 1.0e-6)\n-        }\n-        test(_1_0i, 0.0);\n-        test(_1_1i, 0.25 * Float::pi());\n-        test(_neg1_1i, 0.75 * Float::pi());\n-        test(_05_05i, 0.25 * Float::pi());\n-    }\n-\n-    #[test]\n-    fn test_polar_conv() {\n-        fn test(c: Complex64) {\n-            let (r, theta) = c.to_polar();\n-            assert!((c - Complex::from_polar(&r, &theta)).norm() < 1e-6);\n-        }\n-        for &c in all_consts.iter() { test(c); }\n-    }\n-\n-    mod arith {\n-        use super::{_0_0i, _1_0i, _1_1i, _0_1i, _neg1_1i, _05_05i, all_consts};\n-        use std::num::Zero;\n-\n-        #[test]\n-        fn test_add() {\n-            assert_eq!(_05_05i + _05_05i, _1_1i);\n-            assert_eq!(_0_1i + _1_0i, _1_1i);\n-            assert_eq!(_1_0i + _neg1_1i, _0_1i);\n-\n-            for &c in all_consts.iter() {\n-                assert_eq!(_0_0i + c, c);\n-                assert_eq!(c + _0_0i, c);\n-            }\n-        }\n-\n-        #[test]\n-        fn test_sub() {\n-            assert_eq!(_05_05i - _05_05i, _0_0i);\n-            assert_eq!(_0_1i - _1_0i, _neg1_1i);\n-            assert_eq!(_0_1i - _neg1_1i, _1_0i);\n-\n-            for &c in all_consts.iter() {\n-                assert_eq!(c - _0_0i, c);\n-                assert_eq!(c - c, _0_0i);\n-            }\n-        }\n-\n-        #[test]\n-        fn test_mul() {\n-            assert_eq!(_05_05i * _05_05i, _0_1i.unscale(2.0));\n-            assert_eq!(_1_1i * _0_1i, _neg1_1i);\n-\n-            // i^2 & i^4\n-            assert_eq!(_0_1i * _0_1i, -_1_0i);\n-            assert_eq!(_0_1i * _0_1i * _0_1i * _0_1i, _1_0i);\n-\n-            for &c in all_consts.iter() {\n-                assert_eq!(c * _1_0i, c);\n-                assert_eq!(_1_0i * c, c);\n-            }\n-        }\n-        #[test]\n-        fn test_div() {\n-            assert_eq!(_neg1_1i / _0_1i, _1_1i);\n-            for &c in all_consts.iter() {\n-                if c != Zero::zero() {\n-                    assert_eq!(c / c, _1_0i);\n-                }\n-            }\n-        }\n-        #[test]\n-        fn test_neg() {\n-            assert_eq!(-_1_0i + _0_1i, _neg1_1i);\n-            assert_eq!((-_0_1i) * _0_1i, _1_0i);\n-            for &c in all_consts.iter() {\n-                assert_eq!(-(-c), c);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_to_string() {\n-        fn test(c : Complex64, s: String) {\n-            assert_eq!(c.to_string(), s);\n-        }\n-        test(_0_0i, \"0+0i\".to_string());\n-        test(_1_0i, \"1+0i\".to_string());\n-        test(_0_1i, \"0+1i\".to_string());\n-        test(_1_1i, \"1+1i\".to_string());\n-        test(_neg1_1i, \"-1+1i\".to_string());\n-        test(-_neg1_1i, \"1-1i\".to_string());\n-        test(_05_05i, \"0.5+0.5i\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-        let a = Complex::new(0i32, 0i32);\n-        let b = Complex::new(1i32, 0i32);\n-        let c = Complex::new(0i32, 1i32);\n-        assert!(hash(&a) != hash(&b));\n-        assert!(hash(&b) != hash(&c));\n-        assert!(hash(&c) != hash(&a));\n-    }\n-}"}, {"sha": "c5d076a70b5823985ad153acd12da4b71dfe03e4", "filename": "src/libnum/integer.rs", "status": "removed", "additions": 0, "deletions": 507, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibnum%2Finteger.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibnum%2Finteger.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Finteger.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,507 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Integer trait and functions.\n-\n-pub trait Integer: Num + PartialOrd\n-                 + Div<Self, Self>\n-                 + Rem<Self, Self> {\n-    /// Floored integer division.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert!(( 8i).div_floor(& 3) ==  2);\n-    /// assert!(( 8i).div_floor(&-3) == -3);\n-    /// assert!((-8i).div_floor(& 3) == -3);\n-    /// assert!((-8i).div_floor(&-3) ==  2);\n-    ///\n-    /// assert!(( 1i).div_floor(& 2) ==  0);\n-    /// assert!(( 1i).div_floor(&-2) == -1);\n-    /// assert!((-1i).div_floor(& 2) == -1);\n-    /// assert!((-1i).div_floor(&-2) ==  0);\n-    /// ```\n-    fn div_floor(&self, other: &Self) -> Self;\n-\n-    /// Floored integer modulo, satisfying:\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// # let n = 1i; let d = 1i;\n-    /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)\n-    /// ```\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert!(( 8i).mod_floor(& 3) ==  2);\n-    /// assert!(( 8i).mod_floor(&-3) == -1);\n-    /// assert!((-8i).mod_floor(& 3) ==  1);\n-    /// assert!((-8i).mod_floor(&-3) == -2);\n-    ///\n-    /// assert!(( 1i).mod_floor(& 2) ==  1);\n-    /// assert!(( 1i).mod_floor(&-2) == -1);\n-    /// assert!((-1i).mod_floor(& 2) ==  1);\n-    /// assert!((-1i).mod_floor(&-2) == -1);\n-    /// ```\n-    fn mod_floor(&self, other: &Self) -> Self;\n-\n-    /// Greatest Common Divisor (GCD).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(6i.gcd(&8), 2);\n-    /// assert_eq!(7i.gcd(&3), 1);\n-    /// ```\n-    fn gcd(&self, other: &Self) -> Self;\n-\n-    /// Lowest Common Multiple (LCM).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(7i.lcm(&3), 21);\n-    /// assert_eq!(2i.lcm(&4), 4);\n-    /// ```\n-    fn lcm(&self, other: &Self) -> Self;\n-\n-    /// Deprecated, use `is_multiple_of` instead.\n-    #[deprecated = \"function renamed to `is_multiple_of`\"]\n-    fn divides(&self, other: &Self) -> bool;\n-\n-    /// Returns `true` if `other` is a multiple of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(9i.is_multiple_of(&3), true);\n-    /// assert_eq!(3i.is_multiple_of(&9), false);\n-    /// ```\n-    fn is_multiple_of(&self, other: &Self) -> bool;\n-\n-    /// Returns `true` if the number is even.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(3i.is_even(), false);\n-    /// assert_eq!(4i.is_even(), true);\n-    /// ```\n-    fn is_even(&self) -> bool;\n-\n-    /// Returns `true` if the number is odd.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(3i.is_odd(), true);\n-    /// assert_eq!(4i.is_odd(), false);\n-    /// ```\n-    fn is_odd(&self) -> bool;\n-\n-    /// Simultaneous truncated integer division and modulus.\n-    /// Returns `(quotient, remainder)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(( 8i).div_rem( &3), ( 2,  2));\n-    /// assert_eq!(( 8i).div_rem(&-3), (-2,  2));\n-    /// assert_eq!((-8i).div_rem( &3), (-2, -2));\n-    /// assert_eq!((-8i).div_rem(&-3), ( 2, -2));\n-    ///\n-    /// assert_eq!(( 1i).div_rem( &2), ( 0,  1));\n-    /// assert_eq!(( 1i).div_rem(&-2), ( 0,  1));\n-    /// assert_eq!((-1i).div_rem( &2), ( 0, -1));\n-    /// assert_eq!((-1i).div_rem(&-2), ( 0, -1));\n-    /// ```\n-    #[inline]\n-    fn div_rem(&self, other: &Self) -> (Self, Self) {\n-        (*self / *other, *self % *other)\n-    }\n-\n-    /// Simultaneous floored integer division and modulus.\n-    /// Returns `(quotient, remainder)`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// # use num::Integer;\n-    /// assert_eq!(( 8i).div_mod_floor( &3), ( 2,  2));\n-    /// assert_eq!(( 8i).div_mod_floor(&-3), (-3, -1));\n-    /// assert_eq!((-8i).div_mod_floor( &3), (-3,  1));\n-    /// assert_eq!((-8i).div_mod_floor(&-3), ( 2, -2));\n-    ///\n-    /// assert_eq!(( 1i).div_mod_floor( &2), ( 0,  1));\n-    /// assert_eq!(( 1i).div_mod_floor(&-2), (-1, -1));\n-    /// assert_eq!((-1i).div_mod_floor( &2), (-1,  1));\n-    /// assert_eq!((-1i).div_mod_floor(&-2), ( 0, -1));\n-    /// ```\n-    fn div_mod_floor(&self, other: &Self) -> (Self, Self) {\n-        (self.div_floor(other), self.mod_floor(other))\n-    }\n-}\n-\n-/// Simultaneous integer division and modulus\n-#[inline] pub fn div_rem<T: Integer>(x: T, y: T) -> (T, T) { x.div_rem(&y) }\n-/// Floored integer division\n-#[inline] pub fn div_floor<T: Integer>(x: T, y: T) -> T { x.div_floor(&y) }\n-/// Floored integer modulus\n-#[inline] pub fn mod_floor<T: Integer>(x: T, y: T) -> T { x.mod_floor(&y) }\n-/// Simultaneous floored integer division and modulus\n-#[inline] pub fn div_mod_floor<T: Integer>(x: T, y: T) -> (T, T) { x.div_mod_floor(&y) }\n-\n-/// Calculates the Greatest Common Divisor (GCD) of the number and `other`. The\n-/// result is always positive.\n-#[inline(always)] pub fn gcd<T: Integer>(x: T, y: T) -> T { x.gcd(&y) }\n-/// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n-#[inline(always)] pub fn lcm<T: Integer>(x: T, y: T) -> T { x.lcm(&y) }\n-\n-macro_rules! impl_integer_for_int {\n-    ($T:ty, $test_mod:ident) => (\n-        impl Integer for $T {\n-            /// Floored integer division\n-            #[inline]\n-            fn div_floor(&self, other: &$T) -> $T {\n-                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-                match self.div_rem(other) {\n-                    (d, r) if (r > 0 && *other < 0)\n-                           || (r < 0 && *other > 0) => d - 1,\n-                    (d, _)                          => d,\n-                }\n-            }\n-\n-            /// Floored integer modulo\n-            #[inline]\n-            fn mod_floor(&self, other: &$T) -> $T {\n-                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-                match *self % *other {\n-                    r if (r > 0 && *other < 0)\n-                      || (r < 0 && *other > 0) => r + *other,\n-                    r                          => r,\n-                }\n-            }\n-\n-            /// Calculates `div_floor` and `mod_floor` simultaneously\n-            #[inline]\n-            fn div_mod_floor(&self, other: &$T) -> ($T,$T) {\n-                // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n-                // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-                match self.div_rem(other) {\n-                    (d, r) if (r > 0 && *other < 0)\n-                           || (r < 0 && *other > 0) => (d - 1, r + *other),\n-                    (d, r)                          => (d, r),\n-                }\n-            }\n-\n-            /// Calculates the Greatest Common Divisor (GCD) of the number and\n-            /// `other`. The result is always positive.\n-            #[inline]\n-            fn gcd(&self, other: &$T) -> $T {\n-                // Use Euclid's algorithm\n-                let mut m = *self;\n-                let mut n = *other;\n-                while m != 0 {\n-                    let temp = m;\n-                    m = n % temp;\n-                    n = temp;\n-                }\n-                n.abs()\n-            }\n-\n-            /// Calculates the Lowest Common Multiple (LCM) of the number and\n-            /// `other`.\n-            #[inline]\n-            fn lcm(&self, other: &$T) -> $T {\n-                // should not have to recalculate abs\n-                ((*self * *other) / self.gcd(other)).abs()\n-            }\n-\n-            /// Deprecated, use `is_multiple_of` instead.\n-            #[deprecated = \"function renamed to `is_multiple_of`\"]\n-            #[inline]\n-            fn divides(&self, other: &$T) -> bool { return self.is_multiple_of(other); }\n-\n-            /// Returns `true` if the number is a multiple of `other`.\n-            #[inline]\n-            fn is_multiple_of(&self, other: &$T) -> bool { *self % *other == 0 }\n-\n-            /// Returns `true` if the number is divisible by `2`\n-            #[inline]\n-            fn is_even(&self) -> bool { self & 1 == 0 }\n-\n-            /// Returns `true` if the number is not divisible by `2`\n-            #[inline]\n-            fn is_odd(&self) -> bool { !self.is_even() }\n-        }\n-\n-        #[cfg(test)]\n-        mod $test_mod {\n-            use Integer;\n-\n-            /// Checks that the division rule holds for:\n-            ///\n-            /// - `n`: numerator (dividend)\n-            /// - `d`: denominator (divisor)\n-            /// - `qr`: quotient and remainder\n-            #[cfg(test)]\n-            fn test_division_rule((n,d): ($T,$T), (q,r): ($T,$T)) {\n-                assert_eq!(d * q + r, n);\n-            }\n-\n-            #[test]\n-            fn test_div_rem() {\n-                fn test_nd_dr(nd: ($T,$T), qr: ($T,$T)) {\n-                    let (n,d) = nd;\n-                    let separate_div_rem = (n / d, n % d);\n-                    let combined_div_rem = n.div_rem(&d);\n-\n-                    assert_eq!(separate_div_rem, qr);\n-                    assert_eq!(combined_div_rem, qr);\n-\n-                    test_division_rule(nd, separate_div_rem);\n-                    test_division_rule(nd, combined_div_rem);\n-                }\n-\n-                test_nd_dr(( 8,  3), ( 2,  2));\n-                test_nd_dr(( 8, -3), (-2,  2));\n-                test_nd_dr((-8,  3), (-2, -2));\n-                test_nd_dr((-8, -3), ( 2, -2));\n-\n-                test_nd_dr(( 1,  2), ( 0,  1));\n-                test_nd_dr(( 1, -2), ( 0,  1));\n-                test_nd_dr((-1,  2), ( 0, -1));\n-                test_nd_dr((-1, -2), ( 0, -1));\n-            }\n-\n-            #[test]\n-            fn test_div_mod_floor() {\n-                fn test_nd_dm(nd: ($T,$T), dm: ($T,$T)) {\n-                    let (n,d) = nd;\n-                    let separate_div_mod_floor = (n.div_floor(&d), n.mod_floor(&d));\n-                    let combined_div_mod_floor = n.div_mod_floor(&d);\n-\n-                    assert_eq!(separate_div_mod_floor, dm);\n-                    assert_eq!(combined_div_mod_floor, dm);\n-\n-                    test_division_rule(nd, separate_div_mod_floor);\n-                    test_division_rule(nd, combined_div_mod_floor);\n-                }\n-\n-                test_nd_dm(( 8,  3), ( 2,  2));\n-                test_nd_dm(( 8, -3), (-3, -1));\n-                test_nd_dm((-8,  3), (-3,  1));\n-                test_nd_dm((-8, -3), ( 2, -2));\n-\n-                test_nd_dm(( 1,  2), ( 0,  1));\n-                test_nd_dm(( 1, -2), (-1, -1));\n-                test_nd_dm((-1,  2), (-1,  1));\n-                test_nd_dm((-1, -2), ( 0, -1));\n-            }\n-\n-            #[test]\n-            fn test_gcd() {\n-                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n-                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n-                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n-                assert_eq!((3 as $T).gcd(&-3), 3 as $T);\n-                assert_eq!((-6 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((-4 as $T).gcd(&-2), 2 as $T);\n-            }\n-\n-            #[test]\n-            fn test_lcm() {\n-                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n-                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n-                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n-                assert_eq!((-1 as $T).lcm(&1), 1 as $T);\n-                assert_eq!((1 as $T).lcm(&-1), 1 as $T);\n-                assert_eq!((-1 as $T).lcm(&-1), 1 as $T);\n-                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n-                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n-            }\n-\n-            #[test]\n-            fn test_even() {\n-                assert_eq!((-4 as $T).is_even(), true);\n-                assert_eq!((-3 as $T).is_even(), false);\n-                assert_eq!((-2 as $T).is_even(), true);\n-                assert_eq!((-1 as $T).is_even(), false);\n-                assert_eq!((0 as $T).is_even(), true);\n-                assert_eq!((1 as $T).is_even(), false);\n-                assert_eq!((2 as $T).is_even(), true);\n-                assert_eq!((3 as $T).is_even(), false);\n-                assert_eq!((4 as $T).is_even(), true);\n-            }\n-\n-            #[test]\n-            fn test_odd() {\n-                assert_eq!((-4 as $T).is_odd(), false);\n-                assert_eq!((-3 as $T).is_odd(), true);\n-                assert_eq!((-2 as $T).is_odd(), false);\n-                assert_eq!((-1 as $T).is_odd(), true);\n-                assert_eq!((0 as $T).is_odd(), false);\n-                assert_eq!((1 as $T).is_odd(), true);\n-                assert_eq!((2 as $T).is_odd(), false);\n-                assert_eq!((3 as $T).is_odd(), true);\n-                assert_eq!((4 as $T).is_odd(), false);\n-            }\n-        }\n-    )\n-}\n-\n-impl_integer_for_int!(i8,   test_integer_i8)\n-impl_integer_for_int!(i16,  test_integer_i16)\n-impl_integer_for_int!(i32,  test_integer_i32)\n-impl_integer_for_int!(i64,  test_integer_i64)\n-impl_integer_for_int!(int,  test_integer_int)\n-\n-macro_rules! impl_integer_for_uint {\n-    ($T:ty, $test_mod:ident) => (\n-        impl Integer for $T {\n-            /// Unsigned integer division. Returns the same result as `div` (`/`).\n-            #[inline]\n-            fn div_floor(&self, other: &$T) -> $T { *self / *other }\n-\n-            /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n-            #[inline]\n-            fn mod_floor(&self, other: &$T) -> $T { *self % *other }\n-\n-            /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n-            #[inline]\n-            fn gcd(&self, other: &$T) -> $T {\n-                // Use Euclid's algorithm\n-                let mut m = *self;\n-                let mut n = *other;\n-                while m != 0 {\n-                    let temp = m;\n-                    m = n % temp;\n-                    n = temp;\n-                }\n-                n\n-            }\n-\n-            /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.\n-            #[inline]\n-            fn lcm(&self, other: &$T) -> $T {\n-                (*self * *other) / self.gcd(other)\n-            }\n-\n-            /// Deprecated, use `is_multiple_of` instead.\n-            #[deprecated = \"function renamed to `is_multiple_of`\"]\n-            #[inline]\n-            fn divides(&self, other: &$T) -> bool { return self.is_multiple_of(other); }\n-\n-            /// Returns `true` if the number is a multiple of `other`.\n-            #[inline]\n-            fn is_multiple_of(&self, other: &$T) -> bool { *self % *other == 0 }\n-\n-            /// Returns `true` if the number is divisible by `2`.\n-            #[inline]\n-            fn is_even(&self) -> bool { self & 1 == 0 }\n-\n-            /// Returns `true` if the number is not divisible by `2`.\n-            #[inline]\n-            fn is_odd(&self) -> bool { !self.is_even() }\n-        }\n-\n-        #[cfg(test)]\n-        mod $test_mod {\n-            use Integer;\n-\n-            #[test]\n-            fn test_div_mod_floor() {\n-                assert_eq!((10 as $T).div_floor(&(3 as $T)), 3 as $T);\n-                assert_eq!((10 as $T).mod_floor(&(3 as $T)), 1 as $T);\n-                assert_eq!((10 as $T).div_mod_floor(&(3 as $T)), (3 as $T, 1 as $T));\n-                assert_eq!((5 as $T).div_floor(&(5 as $T)), 1 as $T);\n-                assert_eq!((5 as $T).mod_floor(&(5 as $T)), 0 as $T);\n-                assert_eq!((5 as $T).div_mod_floor(&(5 as $T)), (1 as $T, 0 as $T));\n-                assert_eq!((3 as $T).div_floor(&(7 as $T)), 0 as $T);\n-                assert_eq!((3 as $T).mod_floor(&(7 as $T)), 3 as $T);\n-                assert_eq!((3 as $T).div_mod_floor(&(7 as $T)), (0 as $T, 3 as $T));\n-            }\n-\n-            #[test]\n-            fn test_gcd() {\n-                assert_eq!((10 as $T).gcd(&2), 2 as $T);\n-                assert_eq!((10 as $T).gcd(&3), 1 as $T);\n-                assert_eq!((0 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((3 as $T).gcd(&3), 3 as $T);\n-                assert_eq!((56 as $T).gcd(&42), 14 as $T);\n-            }\n-\n-            #[test]\n-            #[allow(type_overflow)]\n-            fn test_lcm() {\n-                assert_eq!((1 as $T).lcm(&0), 0 as $T);\n-                assert_eq!((0 as $T).lcm(&1), 0 as $T);\n-                assert_eq!((1 as $T).lcm(&1), 1 as $T);\n-                assert_eq!((8 as $T).lcm(&9), 72 as $T);\n-                assert_eq!((11 as $T).lcm(&5), 55 as $T);\n-                assert_eq!((99 as $T).lcm(&17), 1683 as $T);\n-            }\n-\n-            #[test]\n-            fn test_is_multiple_of() {\n-                assert!((6 as $T).is_multiple_of(&(6 as $T)));\n-                assert!((6 as $T).is_multiple_of(&(3 as $T)));\n-                assert!((6 as $T).is_multiple_of(&(1 as $T)));\n-            }\n-\n-            #[test]\n-            fn test_even() {\n-                assert_eq!((0 as $T).is_even(), true);\n-                assert_eq!((1 as $T).is_even(), false);\n-                assert_eq!((2 as $T).is_even(), true);\n-                assert_eq!((3 as $T).is_even(), false);\n-                assert_eq!((4 as $T).is_even(), true);\n-            }\n-\n-            #[test]\n-            fn test_odd() {\n-                assert_eq!((0 as $T).is_odd(), false);\n-                assert_eq!((1 as $T).is_odd(), true);\n-                assert_eq!((2 as $T).is_odd(), false);\n-                assert_eq!((3 as $T).is_odd(), true);\n-                assert_eq!((4 as $T).is_odd(), false);\n-            }\n-        }\n-    )\n-}\n-\n-impl_integer_for_uint!(u8,   test_integer_u8)\n-impl_integer_for_uint!(u16,  test_integer_u16)\n-impl_integer_for_uint!(u32,  test_integer_u32)\n-impl_integer_for_uint!(u64,  test_integer_u64)\n-impl_integer_for_uint!(uint, test_integer_uint)"}, {"sha": "063bb17e09a6d6947e0217d7db9e747d88b8ed35", "filename": "src/libnum/lib.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,73 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Simple numerics.\n-//!\n-//! This crate contains arbitrary-sized integer, rational, and complex types.\n-//!\n-//! ## Example\n-//!\n-//! This example uses the BigRational type and [Newton's method][newt] to\n-//! approximate a square root to arbitrary precision:\n-//!\n-//! ```\n-//! # #![allow(deprecated)]\n-//! extern crate num;\n-//!\n-//! use num::bigint::BigInt;\n-//! use num::rational::{Ratio, BigRational};\n-//!\n-//! fn approx_sqrt(number: u64, iterations: uint) -> BigRational {\n-//!     let start: Ratio<BigInt> = Ratio::from_integer(FromPrimitive::from_u64(number).unwrap());\n-//!     let mut approx = start.clone();\n-//!\n-//!     for _ in range(0, iterations) {\n-//!         approx = (approx + (start / approx)) /\n-//!             Ratio::from_integer(FromPrimitive::from_u64(2).unwrap());\n-//!     }\n-//!\n-//!     approx\n-//! }\n-//!\n-//! fn main() {\n-//!     println!(\"{}\", approx_sqrt(10, 4)); // prints 4057691201/1283082416\n-//! }\n-//! ```\n-//!\n-//! [newt]: https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n-\n-#![allow(unknown_features)]\n-#![feature(macro_rules, slicing_syntax)]\n-#![feature(default_type_params)]\n-\n-#![crate_name = \"num\"]\n-#![deprecated = \"This is now a cargo package located at: \\\n-                 https://github.com/rust-lang/num\"]\n-#![allow(deprecated)]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-#![allow(deprecated)] // from_str_radix\n-\n-extern crate rand;\n-\n-pub use bigint::{BigInt, BigUint};\n-pub use rational::{Rational, BigRational};\n-pub use complex::Complex;\n-pub use integer::Integer;\n-\n-pub mod bigint;\n-pub mod complex;\n-pub mod integer;\n-pub mod rational;"}, {"sha": "ceaf685c19a5154d03b89d1a25def253c3136635", "filename": "src/libnum/rational.rs", "status": "removed", "additions": 0, "deletions": 803, "changes": 803, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,803 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Rational numbers\n-\n-use Integer;\n-\n-use std::cmp;\n-use std::fmt;\n-use std::from_str::FromStr;\n-use std::num;\n-use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n-\n-use bigint::{BigInt, BigUint, Sign, Plus, Minus};\n-\n-/// Represents the ratio between 2 numbers.\n-#[deriving(Clone, Hash)]\n-#[allow(missing_doc)]\n-pub struct Ratio<T> {\n-    numer: T,\n-    denom: T\n-}\n-\n-/// Alias for a `Ratio` of machine-sized integers.\n-pub type Rational = Ratio<int>;\n-pub type Rational32 = Ratio<i32>;\n-pub type Rational64 = Ratio<i64>;\n-\n-/// Alias for arbitrary precision rationals.\n-pub type BigRational = Ratio<BigInt>;\n-\n-impl<T: Clone + Integer + PartialOrd>\n-    Ratio<T> {\n-    /// Creates a ratio representing the integer `t`.\n-    #[inline]\n-    pub fn from_integer(t: T) -> Ratio<T> {\n-        Ratio::new_raw(t, One::one())\n-    }\n-\n-    /// Creates a ratio without checking for `denom == 0` or reducing.\n-    #[inline]\n-    pub fn new_raw(numer: T, denom: T) -> Ratio<T> {\n-        Ratio { numer: numer, denom: denom }\n-    }\n-\n-    /// Create a new Ratio. Fails if `denom == 0`.\n-    #[inline]\n-    pub fn new(numer: T, denom: T) -> Ratio<T> {\n-        if denom == Zero::zero() {\n-            fail!(\"denominator == 0\");\n-        }\n-        let mut ret = Ratio::new_raw(numer, denom);\n-        ret.reduce();\n-        ret\n-    }\n-\n-    /// Converts to an integer.\n-    #[inline]\n-    pub fn to_integer(&self) -> T {\n-        self.trunc().numer\n-    }\n-\n-    /// Gets an immutable reference to the numerator.\n-    #[inline]\n-    pub fn numer<'a>(&'a self) -> &'a T {\n-        &self.numer\n-    }\n-\n-    /// Gets an immutable reference to the denominator.\n-    #[inline]\n-    pub fn denom<'a>(&'a self) -> &'a T {\n-        &self.denom\n-    }\n-\n-    /// Returns true if the rational number is an integer (denominator is 1).\n-    #[inline]\n-    pub fn is_integer(&self) -> bool {\n-        self.denom == One::one()\n-    }\n-\n-    /// Put self into lowest terms, with denom > 0.\n-    fn reduce(&mut self) {\n-        let g : T = self.numer.gcd(&self.denom);\n-\n-        // FIXME(#5992): assignment operator overloads\n-        // self.numer /= g;\n-        self.numer = self.numer / g;\n-        // FIXME(#5992): assignment operator overloads\n-        // self.denom /= g;\n-        self.denom = self.denom / g;\n-\n-        // keep denom positive!\n-        if self.denom < Zero::zero() {\n-            self.numer = -self.numer;\n-            self.denom = -self.denom;\n-        }\n-    }\n-\n-    /// Returns a `reduce`d copy of self.\n-    pub fn reduced(&self) -> Ratio<T> {\n-        let mut ret = self.clone();\n-        ret.reduce();\n-        ret\n-    }\n-\n-    /// Returns the reciprocal.\n-    #[inline]\n-    pub fn recip(&self) -> Ratio<T> {\n-        Ratio::new_raw(self.denom.clone(), self.numer.clone())\n-    }\n-\n-    /// Rounds towards minus infinity.\n-    #[inline]\n-    pub fn floor(&self) -> Ratio<T> {\n-        if *self < Zero::zero() {\n-            Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n-        } else {\n-            Ratio::from_integer(self.numer / self.denom)\n-        }\n-    }\n-\n-    /// Rounds towards plus infinity.\n-    #[inline]\n-    pub fn ceil(&self) -> Ratio<T> {\n-        if *self < Zero::zero() {\n-            Ratio::from_integer(self.numer / self.denom)\n-        } else {\n-            Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n-        }\n-    }\n-\n-    /// Rounds to the nearest integer. Rounds half-way cases away from zero.\n-    #[inline]\n-    pub fn round(&self) -> Ratio<T> {\n-        let one: T = One::one();\n-        let two: T = one + one;\n-\n-        // Find unsigned fractional part of rational number\n-        let fractional = self.fract().abs();\n-\n-        // The algorithm compares the unsigned fractional part with 1/2, that\n-        // is, a/b >= 1/2, or a >= b/2. For odd denominators, we use\n-        // a >= (b/2)+1. This avoids overflow issues.\n-        let half_or_larger = if fractional.denom().is_even() {\n-            *fractional.numer() >= *fractional.denom() / two\n-        } else {\n-            *fractional.numer() >= (*fractional.denom() / two) + one\n-        };\n-\n-        if half_or_larger {\n-            if *self >= Zero::zero() {\n-                self.trunc() + One::one()\n-            } else {\n-                self.trunc() - One::one()\n-            }\n-        } else {\n-            self.trunc()\n-        }\n-    }\n-\n-    /// Rounds towards zero.\n-    #[inline]\n-    pub fn trunc(&self) -> Ratio<T> {\n-        Ratio::from_integer(self.numer / self.denom)\n-    }\n-\n-    /// Returns the fractional part of a number.\n-    #[inline]\n-    pub fn fract(&self) -> Ratio<T> {\n-        Ratio::new_raw(self.numer % self.denom, self.denom.clone())\n-    }\n-}\n-\n-impl Ratio<BigInt> {\n-    /// Converts a float into a rational number.\n-    pub fn from_float<T: Float>(f: T) -> Option<BigRational> {\n-        if !f.is_finite() {\n-            return None;\n-        }\n-        let (mantissa, exponent, sign) = f.integer_decode();\n-        let bigint_sign: Sign = if sign == 1 { Plus } else { Minus };\n-        if exponent < 0 {\n-            let one: BigInt = One::one();\n-            let denom: BigInt = one << ((-exponent) as uint);\n-            let numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();\n-            Some(Ratio::new(BigInt::from_biguint(bigint_sign, numer), denom))\n-        } else {\n-            let mut numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();\n-            numer = numer << (exponent as uint);\n-            Some(Ratio::from_integer(BigInt::from_biguint(bigint_sign, numer)))\n-        }\n-    }\n-}\n-\n-/* Comparisons */\n-\n-// comparing a/b and c/d is the same as comparing a*d and b*c, so we\n-// abstract that pattern. The following macro takes a trait and either\n-// a comma-separated list of \"method name -> return value\" or just\n-// \"method name\" (return value is bool in that case)\n-macro_rules! cmp_impl {\n-    (impl $imp:ident, $($method:ident),+) => {\n-        cmp_impl!(impl $imp, $($method -> bool),+)\n-    };\n-    // return something other than a Ratio<T>\n-    (impl $imp:ident, $($method:ident -> $res:ty),*) => {\n-        impl<T: Mul<T,T> + $imp> $imp for Ratio<T> {\n-            $(\n-                #[inline]\n-                fn $method(&self, other: &Ratio<T>) -> $res {\n-                    (self.numer * other.denom). $method (&(self.denom*other.numer))\n-                }\n-            )*\n-        }\n-    };\n-}\n-cmp_impl!(impl PartialEq, eq, ne)\n-cmp_impl!(impl PartialOrd, lt -> bool, gt -> bool, le -> bool, ge -> bool,\n-          partial_cmp -> Option<cmp::Ordering>)\n-cmp_impl!(impl Eq, )\n-cmp_impl!(impl Ord, cmp -> cmp::Ordering)\n-\n-/* Arithmetic */\n-// a/b * c/d = (a*c)/(b*d)\n-impl<T: Clone + Integer + PartialOrd>\n-    Mul<Ratio<T>,Ratio<T>> for Ratio<T> {\n-    #[inline]\n-    fn mul(&self, rhs: &Ratio<T>) -> Ratio<T> {\n-        Ratio::new(self.numer * rhs.numer, self.denom * rhs.denom)\n-    }\n-}\n-\n-// (a/b) / (c/d) = (a*d)/(b*c)\n-impl<T: Clone + Integer + PartialOrd>\n-    Div<Ratio<T>,Ratio<T>> for Ratio<T> {\n-    #[inline]\n-    fn div(&self, rhs: &Ratio<T>) -> Ratio<T> {\n-        Ratio::new(self.numer * rhs.denom, self.denom * rhs.numer)\n-    }\n-}\n-\n-// Abstracts the a/b `op` c/d = (a*d `op` b*d) / (b*d) pattern\n-macro_rules! arith_impl {\n-    (impl $imp:ident, $method:ident) => {\n-        impl<T: Clone + Integer + PartialOrd>\n-            $imp<Ratio<T>,Ratio<T>> for Ratio<T> {\n-            #[inline]\n-            fn $method(&self, rhs: &Ratio<T>) -> Ratio<T> {\n-                Ratio::new((self.numer * rhs.denom).$method(&(self.denom * rhs.numer)),\n-                           self.denom * rhs.denom)\n-            }\n-        }\n-    }\n-}\n-\n-// a/b + c/d = (a*d + b*c)/(b*d)\n-arith_impl!(impl Add, add)\n-\n-// a/b - c/d = (a*d - b*c)/(b*d)\n-arith_impl!(impl Sub, sub)\n-\n-// a/b % c/d = (a*d % b*c)/(b*d)\n-arith_impl!(impl Rem, rem)\n-\n-impl<T: Clone + Integer + PartialOrd>\n-    Neg<Ratio<T>> for Ratio<T> {\n-    #[inline]\n-    fn neg(&self) -> Ratio<T> {\n-        Ratio::new_raw(-self.numer, self.denom.clone())\n-    }\n-}\n-\n-/* Constants */\n-impl<T: Clone + Integer + PartialOrd>\n-    Zero for Ratio<T> {\n-    #[inline]\n-    fn zero() -> Ratio<T> {\n-        Ratio::new_raw(Zero::zero(), One::one())\n-    }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool {\n-        *self == Zero::zero()\n-    }\n-}\n-\n-impl<T: Clone + Integer + PartialOrd>\n-    One for Ratio<T> {\n-    #[inline]\n-    fn one() -> Ratio<T> {\n-        Ratio::new_raw(One::one(), One::one())\n-    }\n-}\n-\n-impl<T: Clone + Integer + PartialOrd>\n-    Num for Ratio<T> {}\n-\n-impl<T: Clone + Integer + PartialOrd>\n-    num::Signed for Ratio<T> {\n-    #[inline]\n-    fn abs(&self) -> Ratio<T> {\n-        if self.is_negative() { -self.clone() } else { self.clone() }\n-    }\n-\n-    #[inline]\n-    fn abs_sub(&self, other: &Ratio<T>) -> Ratio<T> {\n-        if *self <= *other { Zero::zero() } else { *self - *other }\n-    }\n-\n-    #[inline]\n-    fn signum(&self) -> Ratio<T> {\n-        if *self > Zero::zero() {\n-            num::one()\n-        } else if self.is_zero() {\n-            num::zero()\n-        } else {\n-            - num::one::<Ratio<T>>()\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_positive(&self) -> bool { *self > Zero::zero() }\n-\n-    #[inline]\n-    fn is_negative(&self) -> bool { *self < Zero::zero() }\n-}\n-\n-/* String conversions */\n-impl<T: fmt::Show + Eq + One> fmt::Show for Ratio<T> {\n-    /// Renders as `numer/denom`. If denom=1, renders as numer.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.denom == One::one() {\n-            write!(f, \"{}\", self.numer)\n-        } else {\n-            write!(f, \"{}/{}\", self.numer, self.denom)\n-        }\n-    }\n-}\n-\n-impl<T: ToStrRadix> ToStrRadix for Ratio<T> {\n-    /// Renders as `numer/denom` where the numbers are in base `radix`.\n-    fn to_str_radix(&self, radix: uint) -> String {\n-        format!(\"{}/{}\",\n-                self.numer.to_str_radix(radix),\n-                self.denom.to_str_radix(radix))\n-    }\n-}\n-\n-impl<T: FromStr + Clone + Integer + PartialOrd>\n-    FromStr for Ratio<T> {\n-    /// Parses `numer/denom` or just `numer`.\n-    fn from_str(s: &str) -> Option<Ratio<T>> {\n-        let mut split = s.splitn(1, '/');\n-\n-        let num = split.next().and_then(|n| FromStr::from_str(n));\n-        let den = split.next().or(Some(\"1\")).and_then(|d| FromStr::from_str(d));\n-\n-        match (num, den) {\n-            (Some(n), Some(d)) => Some(Ratio::new(n, d)),\n-            _ => None\n-        }\n-    }\n-}\n-\n-impl<T: FromStrRadix + Clone + Integer + PartialOrd>\n-    FromStrRadix for Ratio<T> {\n-    /// Parses `numer/denom` where the numbers are in base `radix`.\n-    fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n-        let split: Vec<&str> = s.splitn(1, '/').collect();\n-        if split.len() < 2 {\n-            None\n-        } else {\n-            let a_option: Option<T> = FromStrRadix::from_str_radix(\n-                *split.get(0),\n-                radix);\n-            a_option.and_then(|a| {\n-                let b_option: Option<T> =\n-                    FromStrRadix::from_str_radix(*split.get(1), radix);\n-                b_option.and_then(|b| {\n-                    Some(Ratio::new(a.clone(), b.clone()))\n-                })\n-            })\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-\n-    use super::{Ratio, Rational, BigRational};\n-    use std::num::{Zero, One, FromStrRadix, FromPrimitive, ToStrRadix};\n-    use std::from_str::FromStr;\n-    use std::hash::hash;\n-    use std::num;\n-    use std::i32;\n-\n-    pub static _0 : Rational = Ratio { numer: 0, denom: 1};\n-    pub static _1 : Rational = Ratio { numer: 1, denom: 1};\n-    pub static _2: Rational = Ratio { numer: 2, denom: 1};\n-    pub static _1_2: Rational = Ratio { numer: 1, denom: 2};\n-    pub static _3_2: Rational = Ratio { numer: 3, denom: 2};\n-    #[allow(non_uppercase_statics)]\n-    pub static _neg1_2: Rational = Ratio { numer: -1, denom: 2};\n-    pub static _1_3: Rational = Ratio { numer: 1, denom: 3};\n-    #[allow(non_uppercase_statics)]\n-    pub static _neg1_3: Rational = Ratio { numer: -1, denom: 3};\n-    pub static _2_3: Rational = Ratio { numer: 2, denom: 3};\n-    #[allow(non_uppercase_statics)]\n-    pub static _neg2_3: Rational = Ratio { numer: -2, denom: 3};\n-\n-    pub fn to_big(n: Rational) -> BigRational {\n-        Ratio::new(\n-            FromPrimitive::from_int(n.numer).unwrap(),\n-            FromPrimitive::from_int(n.denom).unwrap()\n-        )\n-    }\n-\n-    #[test]\n-    fn test_test_constants() {\n-        // check our constants are what Ratio::new etc. would make.\n-        assert_eq!(_0, Zero::zero());\n-        assert_eq!(_1, One::one());\n-        assert_eq!(_2, Ratio::from_integer(2i));\n-        assert_eq!(_1_2, Ratio::new(1i,2i));\n-        assert_eq!(_3_2, Ratio::new(3i,2i));\n-        assert_eq!(_neg1_2, Ratio::new(-1i,2i));\n-    }\n-\n-    #[test]\n-    fn test_new_reduce() {\n-        let one22 = Ratio::new(2i,2);\n-\n-        assert_eq!(one22, One::one());\n-    }\n-    #[test]\n-    #[should_fail]\n-    fn test_new_zero() {\n-        let _a = Ratio::new(1i,0);\n-    }\n-\n-\n-    #[test]\n-    fn test_cmp() {\n-        assert!(_0 == _0 && _1 == _1);\n-        assert!(_0 != _1 && _1 != _0);\n-        assert!(_0 < _1 && !(_1 < _0));\n-        assert!(_1 > _0 && !(_0 > _1));\n-\n-        assert!(_0 <= _0 && _1 <= _1);\n-        assert!(_0 <= _1 && !(_1 <= _0));\n-\n-        assert!(_0 >= _0 && _1 >= _1);\n-        assert!(_1 >= _0 && !(_0 >= _1));\n-    }\n-\n-\n-    #[test]\n-    fn test_to_integer() {\n-        assert_eq!(_0.to_integer(), 0);\n-        assert_eq!(_1.to_integer(), 1);\n-        assert_eq!(_2.to_integer(), 2);\n-        assert_eq!(_1_2.to_integer(), 0);\n-        assert_eq!(_3_2.to_integer(), 1);\n-        assert_eq!(_neg1_2.to_integer(), 0);\n-    }\n-\n-\n-    #[test]\n-    fn test_numer() {\n-        assert_eq!(_0.numer(), &0);\n-        assert_eq!(_1.numer(), &1);\n-        assert_eq!(_2.numer(), &2);\n-        assert_eq!(_1_2.numer(), &1);\n-        assert_eq!(_3_2.numer(), &3);\n-        assert_eq!(_neg1_2.numer(), &(-1));\n-    }\n-    #[test]\n-    fn test_denom() {\n-        assert_eq!(_0.denom(), &1);\n-        assert_eq!(_1.denom(), &1);\n-        assert_eq!(_2.denom(), &1);\n-        assert_eq!(_1_2.denom(), &2);\n-        assert_eq!(_3_2.denom(), &2);\n-        assert_eq!(_neg1_2.denom(), &2);\n-    }\n-\n-\n-    #[test]\n-    fn test_is_integer() {\n-        assert!(_0.is_integer());\n-        assert!(_1.is_integer());\n-        assert!(_2.is_integer());\n-        assert!(!_1_2.is_integer());\n-        assert!(!_3_2.is_integer());\n-        assert!(!_neg1_2.is_integer());\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        assert_eq!(format!(\"{}\", _2), \"2\".to_string());\n-        assert_eq!(format!(\"{}\", _1_2), \"1/2\".to_string());\n-        assert_eq!(format!(\"{}\", _0), \"0\".to_string());\n-        assert_eq!(format!(\"{}\", Ratio::from_integer(-2i)), \"-2\".to_string());\n-    }\n-\n-    mod arith {\n-        use super::{_0, _1, _2, _1_2, _3_2, _neg1_2, to_big};\n-        use super::super::{Ratio, Rational};\n-\n-        #[test]\n-        fn test_add() {\n-            fn test(a: Rational, b: Rational, c: Rational) {\n-                assert_eq!(a + b, c);\n-                assert_eq!(to_big(a) + to_big(b), to_big(c));\n-            }\n-\n-            test(_1, _1_2, _3_2);\n-            test(_1, _1, _2);\n-            test(_1_2, _3_2, _2);\n-            test(_1_2, _neg1_2, _0);\n-        }\n-\n-        #[test]\n-        fn test_sub() {\n-            fn test(a: Rational, b: Rational, c: Rational) {\n-                assert_eq!(a - b, c);\n-                assert_eq!(to_big(a) - to_big(b), to_big(c))\n-            }\n-\n-            test(_1, _1_2, _1_2);\n-            test(_3_2, _1_2, _1);\n-            test(_1, _neg1_2, _3_2);\n-        }\n-\n-        #[test]\n-        fn test_mul() {\n-            fn test(a: Rational, b: Rational, c: Rational) {\n-                assert_eq!(a * b, c);\n-                assert_eq!(to_big(a) * to_big(b), to_big(c))\n-            }\n-\n-            test(_1, _1_2, _1_2);\n-            test(_1_2, _3_2, Ratio::new(3i,4i));\n-            test(_1_2, _neg1_2, Ratio::new(-1i, 4i));\n-        }\n-\n-        #[test]\n-        fn test_div() {\n-            fn test(a: Rational, b: Rational, c: Rational) {\n-                assert_eq!(a / b, c);\n-                assert_eq!(to_big(a) / to_big(b), to_big(c))\n-            }\n-\n-            test(_1, _1_2, _2);\n-            test(_3_2, _1_2, _1 + _2);\n-            test(_1, _neg1_2, _neg1_2 + _neg1_2 + _neg1_2 + _neg1_2);\n-        }\n-\n-        #[test]\n-        fn test_rem() {\n-            fn test(a: Rational, b: Rational, c: Rational) {\n-                assert_eq!(a % b, c);\n-                assert_eq!(to_big(a) % to_big(b), to_big(c))\n-            }\n-\n-            test(_3_2, _1, _1_2);\n-            test(_2, _neg1_2, _0);\n-            test(_1_2, _2,  _1_2);\n-        }\n-\n-        #[test]\n-        fn test_neg() {\n-            fn test(a: Rational, b: Rational) {\n-                assert_eq!(-a, b);\n-                assert_eq!(-to_big(a), to_big(b))\n-            }\n-\n-            test(_0, _0);\n-            test(_1_2, _neg1_2);\n-            test(-_1, _1);\n-        }\n-        #[test]\n-        fn test_zero() {\n-            assert_eq!(_0 + _0, _0);\n-            assert_eq!(_0 * _0, _0);\n-            assert_eq!(_0 * _1, _0);\n-            assert_eq!(_0 / _neg1_2, _0);\n-            assert_eq!(_0 - _0, _0);\n-        }\n-        #[test]\n-        #[should_fail]\n-        fn test_div_0() {\n-            let _a =  _1 / _0;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_round() {\n-        assert_eq!(_1_3.ceil(), _1);\n-        assert_eq!(_1_3.floor(), _0);\n-        assert_eq!(_1_3.round(), _0);\n-        assert_eq!(_1_3.trunc(), _0);\n-\n-        assert_eq!(_neg1_3.ceil(), _0);\n-        assert_eq!(_neg1_3.floor(), -_1);\n-        assert_eq!(_neg1_3.round(), _0);\n-        assert_eq!(_neg1_3.trunc(), _0);\n-\n-        assert_eq!(_2_3.ceil(), _1);\n-        assert_eq!(_2_3.floor(), _0);\n-        assert_eq!(_2_3.round(), _1);\n-        assert_eq!(_2_3.trunc(), _0);\n-\n-        assert_eq!(_neg2_3.ceil(), _0);\n-        assert_eq!(_neg2_3.floor(), -_1);\n-        assert_eq!(_neg2_3.round(), -_1);\n-        assert_eq!(_neg2_3.trunc(), _0);\n-\n-        assert_eq!(_1_2.ceil(), _1);\n-        assert_eq!(_1_2.floor(), _0);\n-        assert_eq!(_1_2.round(), _1);\n-        assert_eq!(_1_2.trunc(), _0);\n-\n-        assert_eq!(_neg1_2.ceil(), _0);\n-        assert_eq!(_neg1_2.floor(), -_1);\n-        assert_eq!(_neg1_2.round(), -_1);\n-        assert_eq!(_neg1_2.trunc(), _0);\n-\n-        assert_eq!(_1.ceil(), _1);\n-        assert_eq!(_1.floor(), _1);\n-        assert_eq!(_1.round(), _1);\n-        assert_eq!(_1.trunc(), _1);\n-\n-        // Overflow checks\n-\n-        let _neg1 = Ratio::from_integer(-1);\n-        let _large_rat1 = Ratio::new(i32::MAX, i32::MAX-1);\n-        let _large_rat2 = Ratio::new(i32::MAX-1, i32::MAX);\n-        let _large_rat3 = Ratio::new(i32::MIN+2, i32::MIN+1);\n-        let _large_rat4 = Ratio::new(i32::MIN+1, i32::MIN+2);\n-        let _large_rat5 = Ratio::new(i32::MIN+2, i32::MAX);\n-        let _large_rat6 = Ratio::new(i32::MAX, i32::MIN+2);\n-        let _large_rat7 = Ratio::new(1, i32::MIN+1);\n-        let _large_rat8 = Ratio::new(1, i32::MAX);\n-\n-        assert_eq!(_large_rat1.round(), One::one());\n-        assert_eq!(_large_rat2.round(), One::one());\n-        assert_eq!(_large_rat3.round(), One::one());\n-        assert_eq!(_large_rat4.round(), One::one());\n-        assert_eq!(_large_rat5.round(), _neg1);\n-        assert_eq!(_large_rat6.round(), _neg1);\n-        assert_eq!(_large_rat7.round(), Zero::zero());\n-        assert_eq!(_large_rat8.round(), Zero::zero());\n-    }\n-\n-    #[test]\n-    fn test_fract() {\n-        assert_eq!(_1.fract(), _0);\n-        assert_eq!(_neg1_2.fract(), _neg1_2);\n-        assert_eq!(_1_2.fract(), _1_2);\n-        assert_eq!(_3_2.fract(), _1_2);\n-    }\n-\n-    #[test]\n-    fn test_recip() {\n-        assert_eq!(_1 * _1.recip(), _1);\n-        assert_eq!(_2 * _2.recip(), _1);\n-        assert_eq!(_1_2 * _1_2.recip(), _1);\n-        assert_eq!(_3_2 * _3_2.recip(), _1);\n-        assert_eq!(_neg1_2 * _neg1_2.recip(), _1);\n-    }\n-\n-    #[test]\n-    fn test_to_from_str() {\n-        fn test(r: Rational, s: String) {\n-            assert_eq!(FromStr::from_str(s.as_slice()), Some(r));\n-            assert_eq!(r.to_string(), s);\n-        }\n-        test(_1, \"1\".to_string());\n-        test(_0, \"0\".to_string());\n-        test(_1_2, \"1/2\".to_string());\n-        test(_3_2, \"3/2\".to_string());\n-        test(_2, \"2\".to_string());\n-        test(_neg1_2, \"-1/2\".to_string());\n-    }\n-    #[test]\n-    fn test_from_str_fail() {\n-        fn test(s: &str) {\n-            let rational: Option<Rational> = FromStr::from_str(s);\n-            assert_eq!(rational, None);\n-        }\n-\n-        let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\"];\n-        for &s in xs.iter() {\n-            test(s);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_to_from_str_radix() {\n-        fn test(r: Rational, s: String, n: uint) {\n-            assert_eq!(FromStrRadix::from_str_radix(s.as_slice(), n),\n-                       Some(r));\n-            assert_eq!(r.to_str_radix(n).to_string(), s);\n-        }\n-        fn test3(r: Rational, s: String) { test(r, s, 3) }\n-        fn test16(r: Rational, s: String) { test(r, s, 16) }\n-\n-        test3(_1, \"1/1\".to_string());\n-        test3(_0, \"0/1\".to_string());\n-        test3(_1_2, \"1/2\".to_string());\n-        test3(_3_2, \"10/2\".to_string());\n-        test3(_2, \"2/1\".to_string());\n-        test3(_neg1_2, \"-1/2\".to_string());\n-        test3(_neg1_2 / _2, \"-1/11\".to_string());\n-\n-        test16(_1, \"1/1\".to_string());\n-        test16(_0, \"0/1\".to_string());\n-        test16(_1_2, \"1/2\".to_string());\n-        test16(_3_2, \"3/2\".to_string());\n-        test16(_2, \"2/1\".to_string());\n-        test16(_neg1_2, \"-1/2\".to_string());\n-        test16(_neg1_2 / _2, \"-1/4\".to_string());\n-        test16(Ratio::new(13i,15i), \"d/f\".to_string());\n-        test16(_1_2*_1_2*_1_2*_1_2, \"1/10\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_from_str_radix_fail() {\n-        fn test(s: &str) {\n-            let radix: Option<Rational> = FromStrRadix::from_str_radix(s, 3);\n-            assert_eq!(radix, None);\n-        }\n-\n-        let xs = [\"0 /1\", \"abc\", \"\", \"1/\", \"--1/2\",\"3/2/1\", \"3/2\"];\n-        for &s in xs.iter() {\n-            test(s);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_float() {\n-        fn test<T: Float>(given: T, (numer, denom): (&str, &str)) {\n-            let ratio: BigRational = Ratio::from_float(given).unwrap();\n-            assert_eq!(ratio, Ratio::new(\n-                FromStr::from_str(numer).unwrap(),\n-                FromStr::from_str(denom).unwrap()));\n-        }\n-\n-        // f32\n-        test(3.14159265359f32, (\"13176795\", \"4194304\"));\n-        test(2f32.powf(100.), (\"1267650600228229401496703205376\", \"1\"));\n-        test(-2f32.powf(100.), (\"-1267650600228229401496703205376\", \"1\"));\n-        test(1.0 / 2f32.powf(100.), (\"1\", \"1267650600228229401496703205376\"));\n-        test(684729.48391f32, (\"1369459\", \"2\"));\n-        test(-8573.5918555f32, (\"-4389679\", \"512\"));\n-\n-        // f64\n-        test(3.14159265359f64, (\"3537118876014453\", \"1125899906842624\"));\n-        test(2f64.powf(100.), (\"1267650600228229401496703205376\", \"1\"));\n-        test(-2f64.powf(100.), (\"-1267650600228229401496703205376\", \"1\"));\n-        test(684729.48391f64, (\"367611342500051\", \"536870912\"));\n-        test(-8573.5918555f64, (\"-4713381968463931\", \"549755813888\"));\n-        test(1.0 / 2f64.powf(100.), (\"1\", \"1267650600228229401496703205376\"));\n-    }\n-\n-    #[test]\n-    fn test_from_float_fail() {\n-        use std::{f32, f64};\n-\n-        assert_eq!(Ratio::from_float(f32::NAN), None);\n-        assert_eq!(Ratio::from_float(f32::INFINITY), None);\n-        assert_eq!(Ratio::from_float(f32::NEG_INFINITY), None);\n-        assert_eq!(Ratio::from_float(f64::NAN), None);\n-        assert_eq!(Ratio::from_float(f64::INFINITY), None);\n-        assert_eq!(Ratio::from_float(f64::NEG_INFINITY), None);\n-    }\n-\n-    #[test]\n-    fn test_signed() {\n-        assert_eq!(_neg1_2.abs(), _1_2);\n-        assert_eq!(_3_2.abs_sub(&_1_2), _1);\n-        assert_eq!(_1_2.abs_sub(&_3_2), Zero::zero());\n-        assert_eq!(_1_2.signum(), One::one());\n-        assert_eq!(_neg1_2.signum(), - num::one::<Ratio<int>>());\n-        assert!(_neg1_2.is_negative());\n-        assert!(! _neg1_2.is_positive());\n-        assert!(! _1_2.is_negative());\n-    }\n-\n-    #[test]\n-    fn test_hash() {\n-        assert!(hash(&_0) != hash(&_1));\n-        assert!(hash(&_0) != hash(&_3_2));\n-    }\n-}"}, {"sha": "3d83012cecbf09e0257a0bcf223285f7e9b538b5", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -377,10 +377,10 @@ impl Isaac64Rng {\n                                 let x = *self.mem.unsafe_get(base + mr_offset);\n                                 a = mix + *self.mem.unsafe_get(base + m2_offset);\n                                 let y = ind!(x) + a + b;\n-                                self.mem.unsafe_set(base + mr_offset, y);\n+                                *self.mem.unsafe_mut(base + mr_offset) = y;\n \n                                 b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                self.rsl.unsafe_set(base + mr_offset, b);\n+                                *self.rsl.unsafe_mut(base + mr_offset) = b;\n                             }\n                         }}\n                     );\n@@ -394,10 +394,10 @@ impl Isaac64Rng {\n                                 let x = *self.mem.unsafe_get(base + mr_offset);\n                                 a = mix + *self.mem.unsafe_get(base + m2_offset);\n                                 let y = ind!(x) + a + b;\n-                                self.mem.unsafe_set(base + mr_offset, y);\n+                                *self.mem.unsafe_mut(base + mr_offset) = y;\n \n                                 b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                self.rsl.unsafe_set(base + mr_offset, b);\n+                                *self.rsl.unsafe_mut(base + mr_offset) = b;\n                             }\n                         }}\n                     );"}, {"sha": "ebaa0349f5b72a221823a8b092aecc2117224ffa", "filename": "src/librand/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -239,12 +239,6 @@ pub trait Rng {\n         }\n     }\n \n-    /// Deprecated name for `choose()`.\n-    #[deprecated = \"replaced by .choose()\"]\n-    fn choose_option<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n-        self.choose(values)\n-    }\n-\n     /// Shuffle a mutable slice in place.\n     ///\n     /// # Example"}, {"sha": "d47ca892b13b1ec22378a8ccff0790b30aff5cc5", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 16, "deletions": 37, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -129,8 +129,6 @@ pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: uint =\n pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n-    use syntax::crateid::CrateId;\n-\n     let validate = |s: String, span: Option<Span>| {\n         creader::validate_crate_name(sess, s.as_slice(), span);\n         s\n@@ -168,25 +166,6 @@ pub fn find_crate_name(sess: Option<&Session>,\n         Some((attr, s)) => return validate(s.get().to_string(), Some(attr.span)),\n         None => {}\n     }\n-    let crate_id = attrs.iter().find(|at| at.check_name(\"crate_id\"))\n-                        .and_then(|at| at.value_str().map(|s| (at, s)))\n-                        .and_then(|(at, s)| {\n-                            from_str::<CrateId>(s.get()).map(|id| (at, id))\n-                        });\n-    match crate_id {\n-        Some((attr, id)) => {\n-            match sess {\n-                Some(sess) => {\n-                    sess.span_warn(attr.span, \"the #[crate_id] attribute is \\\n-                                               deprecated for the \\\n-                                               #[crate_name] attribute\");\n-                }\n-                None => {}\n-            }\n-            return validate(id.name, Some(attr.span))\n-        }\n-        None => {}\n-    }\n     match *input {\n         FileInput(ref path) => {\n             match path.filestem_str() {\n@@ -274,18 +253,18 @@ pub fn sanitize(s: &str) -> String {\n \n             // '.' doesn't occur in types and functions, so reuse it\n             // for ':' and '-'\n-            '-' | ':' => result.push_char('.'),\n+            '-' | ':' => result.push('.'),\n \n             // These are legal symbols\n             'a' ... 'z'\n             | 'A' ... 'Z'\n             | '0' ... '9'\n-            | '_' | '.' | '$' => result.push_char(c),\n+            | '_' | '.' | '$' => result.push(c),\n \n             _ => {\n                 let mut tstr = String::new();\n-                char::escape_unicode(c, |c| tstr.push_char(c));\n-                result.push_char('$');\n+                char::escape_unicode(c, |c| tstr.push(c));\n+                result.push('$');\n                 result.push_str(tstr.as_slice().slice_from(1));\n             }\n         }\n@@ -334,7 +313,7 @@ pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n         None => {}\n     }\n \n-    n.push_char('E'); // End name-sequence.\n+    n.push('E'); // End name-sequence.\n     n\n }\n \n@@ -360,9 +339,9 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n     let extra2 = id % EXTRA_CHARS.len();\n     let id = id / EXTRA_CHARS.len();\n     let extra3 = id % EXTRA_CHARS.len();\n-    hash.push_char(EXTRA_CHARS.as_bytes()[extra1] as char);\n-    hash.push_char(EXTRA_CHARS.as_bytes()[extra2] as char);\n-    hash.push_char(EXTRA_CHARS.as_bytes()[extra3] as char);\n+    hash.push(EXTRA_CHARS.as_bytes()[extra1] as char);\n+    hash.push(EXTRA_CHARS.as_bytes()[extra2] as char);\n+    hash.push(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n     exported_name(path, hash.as_slice())\n }\n@@ -838,8 +817,8 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n                 sess.note(str::from_utf8(output.as_slice()).unwrap());\n                 sess.abort_if_errors();\n             }\n-            debug!(\"linker stderr:\\n{}\", str::from_utf8_owned(prog.error).unwrap());\n-            debug!(\"linker stdout:\\n{}\", str::from_utf8_owned(prog.output).unwrap());\n+            debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n+            debug!(\"linker stdout:\\n{}\", String::from_utf8(prog.output).unwrap());\n         },\n         Err(e) => {\n             sess.err(format!(\"could not exec the linker `{}`: {}\",\n@@ -1088,7 +1067,7 @@ fn link_args(cmd: &mut Command,\n             cmd.args([\"-dynamiclib\", \"-Wl,-dylib\"]);\n \n             if sess.opts.cg.rpath {\n-                let mut v = Vec::from_slice(\"-Wl,-install_name,@rpath/\".as_bytes());\n+                let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();\n                 v.push_all(out_filename.filename().unwrap());\n                 cmd.arg(v.as_slice());\n             }\n@@ -1247,9 +1226,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // involves just passing the right -l flag.\n \n     let data = if dylib {\n-        trans.crate_formats.get(&config::CrateTypeDylib)\n+        &trans.crate_formats[config::CrateTypeDylib]\n     } else {\n-        trans.crate_formats.get(&config::CrateTypeExecutable)\n+        &trans.crate_formats[config::CrateTypeExecutable]\n     };\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n@@ -1260,7 +1239,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n-        let kind = match *data.get(cnum as uint - 1) {\n+        let kind = match data[cnum as uint - 1] {\n             Some(t) => t,\n             None => continue\n         };\n@@ -1279,7 +1258,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // Converts a library file-stem into a cc -l argument\n     fn unlib<'a>(config: &config::Config, stem: &'a [u8]) -> &'a [u8] {\n         if stem.starts_with(\"lib\".as_bytes()) && config.os != abi::OsWindows {\n-            stem.tailn(3)\n+            stem[3..]\n         } else {\n             stem\n         }\n@@ -1362,7 +1341,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         let dir = cratepath.dirname();\n         if !dir.is_empty() { cmd.arg(\"-L\").arg(dir); }\n \n-        let mut v = Vec::from_slice(\"-l\".as_bytes());\n+        let mut v = \"-l\".as_bytes().to_vec();\n         v.push_all(unlib(&sess.targ_cfg, cratepath.filestem().unwrap()));\n         cmd.arg(v.as_slice());\n     }"}, {"sha": "1f44808275f6cf961913060b9978dd79f75b87c7", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -487,7 +487,9 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n     if sess.opts.test {\n         append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n     }\n-    user_cfg.into_iter().collect::<Vec<_>>().append(default_cfg.as_slice())\n+    let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n+    v.push_all(default_cfg.as_slice());\n+    v\n }\n \n pub fn get_os(triple: &str) -> Option<abi::Os> {"}, {"sha": "f6aab6ef4777765817f9dbd02ecc140504153cd5", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -284,7 +284,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             if cfg!(windows) {\n                 _old_path = os::getenv(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch().get_dylib_search_paths();\n-                new_path.push_all_move(os::split_paths(_old_path.as_slice()));\n+                new_path.extend(os::split_paths(_old_path.as_slice()).into_iter());\n                 os::setenv(\"PATH\", os::join_paths(new_path.as_slice()).unwrap());\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n@@ -569,7 +569,7 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     let old_path = os::getenv(\"PATH\").unwrap_or_else(||String::new());\n     let mut new_path = os::split_paths(old_path.as_slice());\n-    new_path.push_all_move(sess.host_filesearch().get_tools_search_paths());\n+    new_path.extend(sess.host_filesearch().get_tools_search_paths().into_iter());\n     os::setenv(\"PATH\", os::join_paths(new_path.as_slice()).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|\n@@ -818,17 +818,6 @@ pub fn build_output_filenames(input: &Input,\n             // If a crate name is present, we use it as the link name\n             let stem = sess.opts.crate_name.clone().or_else(|| {\n                 attr::find_crate_name(attrs).map(|n| n.get().to_string())\n-            }).or_else(|| {\n-                // NB: this clause can be removed once #[crate_id] is no longer\n-                // deprecated.\n-                //\n-                // Also note that this will be warned about later so we don't\n-                // warn about it here.\n-                use syntax::crateid::CrateId;\n-                attrs.iter().find(|at| at.check_name(\"crate_id\"))\n-                     .and_then(|at| at.value_str())\n-                     .and_then(|s| from_str::<CrateId>(s.get()))\n-                     .map(|id| id.name)\n             }).unwrap_or(input.filestem());\n \n             OutputFilenames {"}, {"sha": "4a2e209f56282a26fc2929a6fd404612cd002175", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -43,7 +43,7 @@ static BUG_REPORT_URL: &'static str =\n     \"http://doc.rust-lang.org/complement-bugreport.html\";\n \n fn run_compiler(args: &[String]) {\n-    let matches = match handle_options(Vec::from_slice(args)) {\n+    let matches = match handle_options(args.to_vec()) {\n         Some(matches) => matches,\n         None => return\n     };\n@@ -76,7 +76,7 @@ fn run_compiler(args: &[String]) {\n             early_error(\"no input filename given\");\n         }\n         1u => {\n-            let ifile = matches.free.get(0).as_slice();\n+            let ifile = matches.free[0].as_slice();\n             if ifile == \"-\" {\n                 let contents = io::stdin().read_to_end().unwrap();\n                 let src = String::from_utf8(contents).unwrap();\n@@ -216,7 +216,9 @@ Available lint options:\n         .map(|&s| s.name.width(true))\n         .max().unwrap_or(0);\n     let padded = |x: &str| {\n-        \" \".repeat(max_name_len - x.char_len()).append(x)\n+        let mut s = \" \".repeat(max_name_len - x.char_len());\n+        s.push_str(x);\n+        s\n     };\n \n     println!(\"Lint checks provided by rustc:\\n\");\n@@ -240,7 +242,9 @@ Available lint options:\n         .map(|&(s, _)| s.width(true))\n         .max().unwrap_or(0);\n     let padded = |x: &str| {\n-        \" \".repeat(max_name_len - x.char_len()).append(x)\n+        let mut s = \" \".repeat(max_name_len - x.char_len());\n+        s.push_str(x);\n+        s\n     };\n \n     println!(\"Lint groups provided by rustc:\\n\");\n@@ -313,7 +317,7 @@ fn describe_codegen_flags() {\n /// returns None.\n pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     // Throw away the first argument, the name of the binary\n-    let _binary = args.shift().unwrap();\n+    let _binary = args.remove(0).unwrap();\n \n     if args.is_empty() {\n         usage();"}, {"sha": "19cd03f10a781738859532c4e84d1bd39e861f34", "filename": "src/librustc/driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fdriver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fdriver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fpretty.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -434,10 +434,8 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = driver::source_name(input);\n-    let src = Vec::from_slice(sess.codemap()\n-                                  .get_filemap(src_name.as_slice())\n-                                  .src\n-                                  .as_bytes());\n+    let src = sess.codemap().get_filemap(src_name.as_slice())\n+                            .src.as_bytes().to_vec();\n     let mut rdr = MemReader::new(src);\n \n     let out = match ofile {"}, {"sha": "390648eab2e54985a730d3e0702c2bc579ae838f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -28,7 +28,6 @@ This API is completely unstable and subject to change.\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![allow(deprecated)]\n #![feature(default_type_params, globs, if_let, import_shadowing, macro_rules, phase, quote)]\n #![feature(slicing_syntax, struct_variant, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "2205dc42d47d63be81bafae1746996aaf7e1776d", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -883,7 +883,7 @@ impl NonSnakeCase {\n                         buf = String::new();\n                     }\n                     last_upper = ch.is_uppercase();\n-                    buf.push_char(ch.to_lowercase());\n+                    buf.push(ch.to_lowercase());\n                 }\n                 words.push(buf);\n             }\n@@ -1062,7 +1062,7 @@ impl UnusedParens {\n \n                 ast::ExprMethodCall(_, _, ref exprs) => {\n                     // X { y: 1 }.bar(...)\n-                    contains_exterior_struct_lit(&**exprs.get(0))\n+                    contains_exterior_struct_lit(&*exprs[0])\n                 }\n \n                 _ => false\n@@ -1220,7 +1220,7 @@ impl UnusedMut {\n         let used_mutables = cx.tcx.used_mut_nodes.borrow();\n         for (_, v) in mutables.iter() {\n             if !v.iter().any(|e| used_mutables.contains(e)) {\n-                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(*v.get(0)),\n+                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(v[0]),\n                              \"variable does not need to be mutable\");\n             }\n         }"}, {"sha": "1107e44be3b03d1d89706a51ebee0773a7fdeee4", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -141,7 +141,7 @@ impl LintStore {\n                 self.levels.insert(id, (lint.default_level, Default));\n             }\n         }\n-        self.passes.get_mut_ref().push(pass);\n+        self.passes.as_mut().unwrap().push(pass);\n     }\n \n     pub fn register_group(&mut self, sess: Option<&Session>,"}, {"sha": "7ec74eb1c3faf2977c9cb5ae588c0ee61cd0e4b4", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -93,8 +93,9 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    (vec!(ast_map::PathMod(token::intern(cdata.name.as_slice())))).append(\n-        path.as_slice())\n+    let mut r = vec![ast_map::PathMod(token::intern(cdata.name.as_slice()))];\n+    r.push_all(path.as_slice());\n+    r\n }\n \n pub enum found_ast<'ast> {"}, {"sha": "1d1012d9e4f04e037c3c4ef4d740bca17d879e40", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -95,7 +95,7 @@ impl CStore {\n     }\n \n     pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<crate_metadata> {\n-        self.metas.borrow().get(&cnum).clone()\n+        (*self.metas.borrow())[cnum].clone()\n     }\n \n     pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> Svh {"}, {"sha": "456cf93d9b5c50363ec52da3eacb3b4a6b042fa0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -643,7 +643,7 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n                                 -> csearch::found_ast<'tcx> {\n     debug!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data());\n-    let path = Vec::from_slice(item_path(item_doc).init());\n+    let path = item_path(item_doc).init().to_vec();\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n         Ok(ii) => csearch::found(ii),\n         Err(path) => {"}, {"sha": "9106adcd3ef38c39f530385bea02484af5e298bf", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -347,9 +347,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n-        if vi.get(i).disr_val != disr_val {\n-            encode_disr_val(ecx, rbml_w, vi.get(i).disr_val);\n-            disr_val = vi.get(i).disr_val;\n+        if (*vi)[i].disr_val != disr_val {\n+            encode_disr_val(ecx, rbml_w, (*vi)[i].disr_val);\n+            disr_val = (*vi)[i].disr_val;\n         }\n         encode_bounds_and_type(rbml_w, ecx,\n                                &lookup_item_type(ecx.tcx, def_id));\n@@ -401,7 +401,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n     match ecx.tcx.inherent_impls.borrow().find(&exp.def_id) {\n         Some(implementations) => {\n             for base_impl_did in implementations.iter() {\n-                for &method_did in impl_items.get(base_impl_did).iter() {\n+                for &method_did in (*impl_items)[*base_impl_did].iter() {\n                     let impl_item = ty::impl_or_trait_item(\n                         ecx.tcx,\n                         method_did.def_id());\n@@ -515,7 +515,7 @@ fn each_auxiliary_node_id(item: &Item, callback: |NodeId| -> bool) -> bool {\n             // If this is a newtype struct, return the constructor.\n             match struct_def.ctor_id {\n                 Some(ctor_id) if struct_def.fields.len() > 0 &&\n-                        struct_def.fields.get(0).node.kind.is_unnamed() => {\n+                        struct_def.fields[0].node.kind.is_unnamed() => {\n                     continue_ = callback(ctor_id);\n                 }\n                 _ => {}\n@@ -912,7 +912,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     encode_stability(rbml_w, stab);\n \n     let elem = ast_map::PathName(associated_type.ident.name);\n-    encode_path(rbml_w, impl_path.chain(Some(elem).move_iter()));\n+    encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n \n     match typedef_opt {\n         None => {}\n@@ -1229,7 +1229,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n-        let items = impl_items.get(&def_id);\n+        let items = &(*impl_items)[def_id];\n \n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n@@ -1277,7 +1277,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let num_implemented_methods = ast_items.len();\n         for (i, &trait_item_def_id) in items.iter().enumerate() {\n             let ast_item = if i < num_implemented_methods {\n-                Some(ast_items.get(i))\n+                Some(&ast_items[i])\n             } else {\n                 None\n             };\n@@ -1421,7 +1421,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 ty::TypeTraitItem(associated_type) => {\n                     let elem = ast_map::PathName(associated_type.ident.name);\n                     encode_path(rbml_w,\n-                                path.clone().chain(Some(elem).move_iter()));\n+                                path.clone().chain(Some(elem).into_iter()));\n \n                     encode_family(rbml_w, 'y');\n \n@@ -1431,8 +1431,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             encode_parent_sort(rbml_w, 't');\n \n-            let trait_item = ms.get(i);\n-            match ms.get(i) {\n+            let trait_item = &ms[i];\n+            match &ms[i] {\n                 &RequiredMethod(ref tm) => {\n                     encode_attributes(rbml_w, tm.attrs.as_slice());\n                     encode_item_sort(rbml_w, 'r');"}, {"sha": "36e04d84aa9d620656ca29945f8ea6074e5e2809", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -418,11 +418,11 @@ impl<'a> Context<'a> {\n                 (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n                  true)\n             } else if dypair.map_or(false, |(_, suffix)| {\n-                file.starts_with(dylib_prefix.get_ref().as_slice()) &&\n+                file.starts_with(dylib_prefix.as_ref().unwrap().as_slice()) &&\n                 file.ends_with(suffix)\n             }) {\n                 let (_, suffix) = dypair.unwrap();\n-                let dylib_prefix = dylib_prefix.get_ref().as_slice();\n+                let dylib_prefix = dylib_prefix.as_ref().unwrap().as_slice();\n                 (file.slice(dylib_prefix.len(), file.len() - suffix.len()),\n                  false)\n             } else {\n@@ -553,7 +553,7 @@ impl<'a> Context<'a> {\n                                            self.crate_name).as_slice());\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate #1: {}\",\n-                                            ret.get_ref()\n+                                            ret.as_ref().unwrap()\n                                                .display()).as_slice());\n                 error = 1;\n                 ret = None;"}, {"sha": "6fbdceea37f9dd55fe75c8775b17bfc38bcd8add", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -123,9 +123,9 @@ fn data_log_string(data: &[u8], pos: uint) -> String {\n     for i in range(pos, data.len()) {\n         let c = data[i];\n         if c > 0x20 && c <= 0x7F {\n-            buf.push_char(c as char);\n+            buf.push(c as char);\n         } else {\n-            buf.push_char('.');\n+            buf.push('.');\n         }\n     }\n     buf.push_str(\">>\");\n@@ -339,7 +339,7 @@ fn parse_str(st: &mut PState, term: char) -> String {\n     let mut result = String::new();\n     while peek(st) != term {\n         unsafe {\n-            result.push_bytes([next_byte(st)])\n+            result.as_mut_vec().push_all([next_byte(st)])\n         }\n     }\n     next(st);"}, {"sha": "f72d14ba68aae2c07e03f65f1d279c453c13957e", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -1517,7 +1517,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n         fn type_string(doc: rbml::Doc) -> String {\n             let mut str = String::new();\n             for i in range(doc.start, doc.end) {\n-                str.push_char(doc.data[i] as char);\n+                str.push(doc.data[i] as char);\n             }\n             str\n         }"}, {"sha": "887c6bc3e3fdfb48c34e3424fe5bb43c4f368b84", "filename": "src/librustc/middle/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -98,7 +98,7 @@ fn group_errors_with_same_origin(errors: &Vec<MoveError>)\n         for ge in grouped_errors.iter_mut() {\n             if move_from_id == ge.move_from.id && error.move_to.is_some() {\n                 debug!(\"appending move_to to list\");\n-                ge.move_to_places.push_all_move(move_to);\n+                ge.move_to_places.extend(move_to.into_iter());\n                 return\n             }\n         }"}, {"sha": "aab7fe8f31edc38e214e91a2eb94d8405133d980", "filename": "src/librustc/middle/borrowck/graphviz.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgraphviz.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -91,14 +91,15 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n             saw_some = true;\n             true\n         });\n-        set.append(\"}\")\n+        set.push_str(\"}\");\n+        set\n     }\n \n     fn dataflow_loans_for(&self, e: EntryOrExit, cfgidx: CFGIndex) -> String {\n         let dfcx = &self.analysis_data.loans;\n         let loan_index_to_path = |loan_index| {\n             let all_loans = &self.analysis_data.all_loans;\n-            all_loans.get(loan_index).loan_path()\n+            all_loans[loan_index].loan_path()\n         };\n         self.build_set(e, cfgidx, dfcx, loan_index_to_path)\n     }\n@@ -108,7 +109,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         let move_index_to_path = |move_index| {\n             let move_data = &self.analysis_data.move_data.move_data;\n             let moves = move_data.moves.borrow();\n-            let the_move = moves.get(move_index);\n+            let the_move = &(*moves)[move_index];\n             move_data.path_loan_path(the_move.path)\n         };\n         self.build_set(e, cfgidx, dfcx, move_index_to_path)\n@@ -119,7 +120,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         let assign_index_to_path = |assign_index| {\n             let move_data = &self.analysis_data.move_data.move_data;\n             let assignments = move_data.var_assignments.borrow();\n-            let assignment = assignments.get(assign_index);\n+            let assignment = &(*assignments)[assign_index];\n             move_data.path_loan_path(assignment.path)\n         };\n         self.build_set(e, cfgidx, dfcx, assign_index_to_path)"}, {"sha": "850c6008706c88eee2226ab2d031ca11c2abbe5e", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -825,11 +825,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 match fname {\n                     mc::NamedField(fname) => {\n-                        out.push_char('.');\n+                        out.push('.');\n                         out.push_str(token::get_name(fname).get());\n                     }\n                     mc::PositionalField(idx) => {\n-                        out.push_char('.');\n+                        out.push('.');\n                         out.push_str(idx.to_string().as_slice());\n                     }\n                 }\n@@ -841,7 +841,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n-                out.push_char('*');\n+                out.push('*');\n                 self.append_loan_path_to_string(&**lp_base, out);\n             }\n         }"}, {"sha": "5f3c46fcf4cd5f8287a5668c5181e97d899225db", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -192,23 +192,23 @@ impl MoveData {\n     }\n \n     pub fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath> {\n-        self.paths.borrow().get(index.get()).loan_path.clone()\n+        (*self.paths.borrow())[index.get()].loan_path.clone()\n     }\n \n     fn path_parent(&self, index: MovePathIndex) -> MovePathIndex {\n-        self.paths.borrow().get(index.get()).parent\n+        (*self.paths.borrow())[index.get()].parent\n     }\n \n     fn path_first_move(&self, index: MovePathIndex) -> MoveIndex {\n-        self.paths.borrow().get(index.get()).first_move\n+        (*self.paths.borrow())[index.get()].first_move\n     }\n \n     fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {\n-        self.paths.borrow().get(index.get()).first_child\n+        (*self.paths.borrow())[index.get()].first_child\n     }\n \n     fn path_next_sibling(&self, index: MovePathIndex) -> MovePathIndex {\n-        self.paths.borrow().get(index.get()).next_sibling\n+        (*self.paths.borrow())[index.get()].next_sibling\n     }\n \n     fn set_path_first_move(&self,\n@@ -225,7 +225,7 @@ impl MoveData {\n \n     fn move_next_move(&self, index: MoveIndex) -> MoveIndex {\n         //! Type safe indexing operator\n-        self.moves.borrow().get(index.get()).next_move\n+        (*self.moves.borrow())[index.get()].next_move\n     }\n \n     fn is_var_path(&self, index: MovePathIndex) -> bool {\n@@ -434,12 +434,12 @@ impl MoveData {\n             match *path.loan_path {\n                 LpVar(id) => {\n                     let kill_id = tcx.region_maps.var_scope(id);\n-                    let path = *self.path_map.borrow().get(&path.loan_path);\n+                    let path = (*self.path_map.borrow())[path.loan_path];\n                     self.kill_moves(path, kill_id, dfcx_moves);\n                 }\n                 LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {\n                     let kill_id = closure_to_block(closure_expr_id, tcx);\n-                    let path = *self.path_map.borrow().get(&path.loan_path);\n+                    let path = (*self.path_map.borrow())[path.loan_path];\n                     self.kill_moves(path, kill_id, dfcx_moves);\n                 }\n                 LpExtend(..) => {}\n@@ -580,7 +580,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n         for loan_path_index in self.move_data.path_map.borrow().find(&*loan_path).iter() {\n             self.dfcx_moves.each_gen_bit(id, |move_index| {\n                 let the_move = self.move_data.moves.borrow();\n-                let the_move = the_move.get(move_index);\n+                let the_move = (*the_move)[move_index];\n                 if the_move.path == **loan_path_index {\n                     ret = Some(the_move.kind);\n                     false\n@@ -625,7 +625,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n         self.dfcx_moves.each_bit_on_entry(id, |index| {\n             let the_move = self.move_data.moves.borrow();\n-            let the_move = the_move.get(index);\n+            let the_move = &(*the_move)[index];\n             let moved_path = the_move.path;\n             if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n@@ -675,7 +675,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n         self.dfcx_assign.each_bit_on_entry(id, |index| {\n             let assignment = self.move_data.var_assignments.borrow();\n-            let assignment = assignment.get(index);\n+            let assignment = &(*assignment)[index];\n             if assignment.path == loan_path_index && !f(assignment) {\n                 false\n             } else {"}, {"sha": "4b55a0b26098bafecd3bcd75c46c02d55588e7ec", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -424,7 +424,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                self.call(expr, pred, &**args.get(0), args.slice_from(1).iter().map(|e| &**e))\n+                self.call(expr, pred, &*args[0], args.slice_from(1).iter().map(|e| &**e))\n             }\n \n             ast::ExprIndex(ref l, ref r) |"}, {"sha": "bc48e476aec071a6fd1e439e040780831e382876", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -41,9 +41,9 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n             s.as_slice().chars().rev().take(2).collect();\n         last_two.reverse();\n         if last_two.as_slice() != ['\\\\', 'l'] {\n-            s = s.append(\"\\\\l\");\n+            s.push_str(\"\\\\l\");\n         }\n-        s.to_string()\n+        s\n     } else {\n         s\n     }\n@@ -76,16 +76,15 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n         let mut put_one = false;\n         for (i, &node_id) in e.data.exiting_scopes.iter().enumerate() {\n             if put_one {\n-                label = label.append(\",\\\\l\");\n+                label.push_str(\",\\\\l\");\n             } else {\n                 put_one = true;\n             }\n             let s = self.ast_map.node_to_string(node_id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n-            label = label.append(format!(\"exiting scope_{} {}\",\n-                                         i,\n-                                         s.as_slice()).as_slice());\n+            label.push_str(format!(\"exiting scope_{} {}\", i,\n+                                   s.as_slice()).as_slice());\n         }\n         dot::EscStr(label.into_maybe_owned())\n     }"}, {"sha": "7ffe5f42a5cce15fe1c1e8bd9b96f7f14941fb2b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -66,7 +66,7 @@ impl<'a> fmt::Show for Matrix<'a> {\n         let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0u);\n         assert!(m.iter().all(|row| row.len() == column_count));\n         let column_widths: Vec<uint> = range(0, column_count).map(|col| {\n-            pretty_printed_matrix.iter().map(|row| row.get(col).len()).max().unwrap_or(0u)\n+            pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0u)\n         }).collect();\n \n         let total_width = column_widths.iter().map(|n| *n).sum() + column_count * 3 + 1;\n@@ -76,7 +76,7 @@ impl<'a> fmt::Show for Matrix<'a> {\n             try!(write!(f, \"+\"));\n             for (column, pat_str) in row.into_iter().enumerate() {\n                 try!(write!(f, \" \"));\n-                f.width = Some(*column_widths.get(column));\n+                f.width = Some(column_widths[column]);\n                 try!(f.pad(pat_str.as_slice()));\n                 try!(write!(f, \" +\"));\n             }\n@@ -269,7 +269,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source\n                             } else {\n                                 // find the first arm pattern so we can use its span\n                                 let &(ref first_arm_pats, _) = &arms[0];\n-                                let first_pat = first_arm_pats.get(0);\n+                                let first_pat = &first_arm_pats[0];\n                                 let span = first_pat.span;\n                                 span_err!(cx.tcx.sess, span, E0162, \"irrefutable if-let pattern\");\n                                 printed_if_let_err = true;\n@@ -279,7 +279,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source\n                         MatchWhileLetDesugar => {\n                             // find the first arm pattern so we can use its span\n                             let &(ref first_arm_pats, _) = &arms[0];\n-                            let first_pat = first_arm_pats.get(0);\n+                            let first_pat = &first_arm_pats[0];\n                             let span = first_pat.span;\n                             span_err!(cx.tcx.sess, span, E0165, \"irrefutable while-let pattern\");\n                         },\n@@ -475,7 +475,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n                        left_ty: ty::t, max_slice_length: uint) -> Option<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n-        .flat_map(|row| pat_constructors(cx, *row.get(0), left_ty, max_slice_length).into_iter())\n+        .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length).into_iter())\n         .collect();\n     all_constructors(cx, left_ty, max_slice_length)\n         .into_iter()\n@@ -538,11 +538,11 @@ fn is_useful(cx: &MatchCheckCtxt,\n             LeaveOutWitness => Useful\n         };\n     }\n-    if rows.get(0).len() == 0u {\n+    if rows[0].len() == 0u {\n         return NotUseful;\n     }\n-    let real_pat = match rows.iter().find(|r| r.get(0).id != DUMMY_NODE_ID) {\n-        Some(r) => raw_pat(*r.get(0)),\n+    let real_pat = match rows.iter().find(|r| (*r)[0].id != DUMMY_NODE_ID) {\n+        Some(r) => raw_pat(r[0]),\n         None if v.len() == 0 => return NotUseful,\n         None => v[0]\n     };\n@@ -552,7 +552,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n         ty::pat_ty(cx.tcx, &*real_pat)\n     };\n \n-    let max_slice_length = rows.iter().filter_map(|row| match row.get(0).node {\n+    let max_slice_length = rows.iter().filter_map(|row| match row[0].node {\n         PatVec(ref before, _, ref after) => Some(before.len() + after.len()),\n         _ => None\n     }).max().map_or(0, |v| v + 1);\n@@ -583,7 +583,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n             Some(constructor) => {\n                 let matrix = rows.iter().filter_map(|r| {\n                     if pat_is_binding_or_wild(&cx.tcx.def_map, raw_pat(r[0])) {\n-                        Some(Vec::from_slice(r.tail()))\n+                        Some(r.tail().to_vec())\n                     } else {\n                         None\n                     }\n@@ -883,7 +883,11 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             None\n         }\n     };\n-    head.map(|head| head.append(r[..col]).append(r[col + 1..]))\n+    head.map(|mut head| {\n+        head.push_all(r[..col]);\n+        head.push_all(r[col + 1..]);\n+        head\n+    })\n }\n \n fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {"}, {"sha": "d5557dfeeff1a37463ab675f9e504a53dcc3f6b2", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -418,7 +418,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let bits = self.kills.slice_mut(start, end);\n                 debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-                bits.copy_from(orig_kills.as_slice());\n+                bits.clone_from_slice(orig_kills.as_slice());\n                 debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [after]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }\n@@ -484,7 +484,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n             let (start, end) = self.dfcx.compute_id_range(node_index);\n \n             // Initialize local bitvector with state on-entry.\n-            in_out.copy_from(self.dfcx.on_entry.slice(start, end));\n+            in_out.clone_from_slice(self.dfcx.on_entry.slice(start, end));\n \n             // Compute state on-exit by applying transfer function to\n             // state on-entry.\n@@ -550,13 +550,13 @@ fn bits_to_string(words: &[uint]) -> String {\n     for &word in words.iter() {\n         let mut v = word;\n         for _ in range(0u, uint::BYTES) {\n-            result.push_char(sep);\n+            result.push(sep);\n             result.push_str(format!(\"{:02x}\", v & 0xFF).as_slice());\n             v >>= 8;\n             sep = '-';\n         }\n     }\n-    result.push_char(']');\n+    result.push(']');\n     return result\n }\n "}, {"sha": "513d65c335d0f9c0b57c91fc27dc5e8cdf6181be", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -157,8 +157,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_pattern_match(&mut self, lhs: &ast::Pat, pats: &[ast::FieldPat]) {\n-        let id = match self.tcx.def_map.borrow().get(&lhs.id) {\n-            &def::DefVariant(_, id, _) => id,\n+        let id = match (*self.tcx.def_map.borrow())[lhs.id] {\n+            def::DefVariant(_, id, _) => id,\n             _ => {\n                 match ty::ty_to_def_id(ty::node_id_to_type(self.tcx,\n                                                            lhs.id)) {\n@@ -494,7 +494,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             None => (),\n             Some(impl_list) => {\n                 for impl_did in impl_list.iter() {\n-                    for item_did in impl_items.get(impl_did).iter() {\n+                    for item_did in (*impl_items)[*impl_did].iter() {\n                         if self.live_symbols.contains(&item_did.def_id()\n                                                                .node) {\n                             return true;"}, {"sha": "d4c8335d8e55f5cb2057259cb6e4903100a2ac40", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = self.tcx.method_map.borrow().get(&method_call).ty;\n+                let base_type = (*self.tcx.method_map.borrow())[method_call].ty;\n                 debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_string(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "c413eb67a73ac05ba34641f3e5ef0ed276c003ed", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -738,7 +738,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 None => {}\n                 Some(method_ty) => {\n                     let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n-                    let self_ty = *ty::ty_fn_args(method_ty).get(0);\n+                    let self_ty = ty::ty_fn_args(method_ty)[0];\n                     let (m, r) = match ty::get(self_ty).sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,"}, {"sha": "4775f945f5c1f7f0952175e53547a818359db9af", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -146,11 +146,11 @@ impl<N,E> Graph<N,E> {\n     }\n \n     pub fn node_data<'a>(&'a self, idx: NodeIndex) -> &'a N {\n-        &self.nodes.get(idx.get()).data\n+        &self.nodes[idx.get()].data\n     }\n \n     pub fn node<'a>(&'a self, idx: NodeIndex) -> &'a Node<N> {\n-        self.nodes.get(idx.get())\n+        &self.nodes[idx.get()]\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -167,9 +167,9 @@ impl<N,E> Graph<N,E> {\n         let idx = self.next_edge_index();\n \n         // read current first of the list of edges from each node\n-        let source_first = self.nodes.get(source.get())\n+        let source_first = self.nodes[source.get()]\n                                      .first_edge[Outgoing.repr];\n-        let target_first = self.nodes.get(target.get())\n+        let target_first = self.nodes[target.get()]\n                                      .first_edge[Incoming.repr];\n \n         // create the new edge, with the previous firsts from each node\n@@ -193,27 +193,27 @@ impl<N,E> Graph<N,E> {\n     }\n \n     pub fn edge_data<'a>(&'a self, idx: EdgeIndex) -> &'a E {\n-        &self.edges.get(idx.get()).data\n+        &self.edges[idx.get()].data\n     }\n \n     pub fn edge<'a>(&'a self, idx: EdgeIndex) -> &'a Edge<E> {\n-        self.edges.get(idx.get())\n+        &self.edges[idx.get()]\n     }\n \n     pub fn first_adjacent(&self, node: NodeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the index of the first edge adjacent to `node`.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.nodes.get(node.get()).first_edge[dir.repr]\n+        self.nodes[node.get()].first_edge[dir.repr]\n     }\n \n     pub fn next_adjacent(&self, edge: EdgeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the next edge in a given direction.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.edges.get(edge.get()).next_edge[dir.repr]\n+        self.edges[edge.get()].next_edge[dir.repr]\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -257,7 +257,7 @@ impl<N,E> Graph<N,E> {\n \n         let mut edge_idx = self.first_adjacent(node, dir);\n         while edge_idx != InvalidEdgeIndex {\n-            let edge = self.edges.get(edge_idx.get());\n+            let edge = &self.edges[edge_idx.get()];\n             if !f(edge_idx, edge) {\n                 return false;\n             }"}, {"sha": "d7707be58bb58b5aa93388f48a4d247f64f0608b", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                         match ty::get(typ).sty {\n                             ty_bare_fn(ref bare_fn_ty)\n                                     if bare_fn_ty.abi == RustIntrinsic => {\n-                                let from = *bare_fn_ty.sig.inputs.get(0);\n+                                let from = bare_fn_ty.sig.inputs[0];\n                                 let to = bare_fn_ty.sig.output;\n                                 self.check_transmute(expr.span, from, to, expr.id);\n                             }"}, {"sha": "f2d1a5e1d927243d17a099a802286afc97ee7b21", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -76,9 +76,9 @@ impl LanguageItems {\n     }\n \n     pub fn require(&self, it: LangItem) -> Result<ast::DefId, String> {\n-        match self.items.get(it as uint) {\n-            &Some(id) => Ok(id),\n-            &None => {\n+        match self.items[it as uint] {\n+            Some(id) => Ok(id),\n+            None => {\n                 Err(format!(\"requires `{}` lang_item\",\n                             LanguageItems::item_name(it as uint)))\n             }\n@@ -113,7 +113,7 @@ impl LanguageItems {\n     $(\n         #[allow(dead_code)]\n         pub fn $method(&self) -> Option<ast::DefId> {\n-            *self.items.get($variant as uint)\n+            self.items[$variant as uint]\n         }\n     )*\n }\n@@ -162,12 +162,12 @@ impl<'a> LanguageItemCollector<'a> {\n     pub fn collect_item(&mut self, item_index: uint,\n                         item_def_id: ast::DefId, span: Span) {\n         // Check for duplicates.\n-        match self.items.items.get(item_index) {\n-            &Some(original_def_id) if original_def_id != item_def_id => {\n+        match self.items.items[item_index] {\n+            Some(original_def_id) if original_def_id != item_def_id => {\n                 span_err!(self.session, span, E0152,\n                     \"duplicate entry for `{}`\", LanguageItems::item_name(item_index));\n             }\n-            &Some(_) | &None => {\n+            Some(_) | None => {\n                 // OK.\n             }\n         }"}, {"sha": "63e9a80adc61aa3aad273224ad662c84a01e8a65", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -327,11 +327,11 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n \n     fn variable_name(&self, var: Variable) -> String {\n-        match self.var_kinds.get(var.get()) {\n-            &Local(LocalInfo { ident: nm, .. }) | &Arg(_, nm) => {\n+        match self.var_kinds[var.get()] {\n+            Local(LocalInfo { ident: nm, .. }) | Arg(_, nm) => {\n                 token::get_ident(nm).get().to_string()\n             },\n-            &ImplicitRet => \"<implicit-ret>\".to_string()\n+            ImplicitRet => \"<implicit-ret>\".to_string()\n         }\n     }\n \n@@ -340,7 +340,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n \n     fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n-        *self.lnks.get(ln.get())\n+        self.lnks[ln.get()]\n     }\n }\n \n@@ -647,7 +647,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn live_on_entry(&self, ln: LiveNode, var: Variable)\n                       -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let reader = self.users.get(self.idx(ln, var)).reader;\n+        let reader = self.users[self.idx(ln, var)].reader;\n         if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n     }\n \n@@ -656,25 +656,25 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     */\n     fn live_on_exit(&self, ln: LiveNode, var: Variable)\n                     -> Option<LiveNodeKind> {\n-        let successor = *self.successors.get(ln.get());\n+        let successor = self.successors[ln.get()];\n         self.live_on_entry(successor, var)\n     }\n \n     fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n         assert!(ln.is_valid());\n-        self.users.get(self.idx(ln, var)).used\n+        self.users[self.idx(ln, var)].used\n     }\n \n     fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n                          -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n-        let writer = self.users.get(self.idx(ln, var)).writer;\n+        let writer = self.users[self.idx(ln, var)].writer;\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n \n     fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n                         -> Option<LiveNodeKind> {\n-        let successor = *self.successors.get(ln.get());\n+        let successor = self.successors[ln.get()];\n         self.assigned_on_entry(successor, var)\n     }\n \n@@ -736,10 +736,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         {\n             let wr = &mut wr as &mut io::Writer;\n             write!(wr, \"[ln({}) of kind {} reads\", ln.get(), self.ir.lnk(ln));\n-            self.write_vars(wr, ln, |idx| self.users.get(idx).reader);\n+            self.write_vars(wr, ln, |idx| self.users[idx].reader);\n             write!(wr, \"  writes\");\n-            self.write_vars(wr, ln, |idx| self.users.get(idx).writer);\n-            write!(wr, \"  precedes {}]\", self.successors.get(ln.get()).to_string());\n+            self.write_vars(wr, ln, |idx| self.users[idx].writer);\n+            write!(wr, \"  precedes {}]\", self.successors[ln.get()].to_string());\n         }\n         str::from_utf8(wr.unwrap().as_slice()).unwrap().to_string()\n     }\n@@ -762,7 +762,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         *self.successors.get_mut(ln.get()) = succ_ln;\n \n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            *this.users.get_mut(idx) = *this.users.get(succ_idx)\n+            *this.users.get_mut(idx) = this.users[succ_idx]\n         });\n         debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n@@ -777,11 +777,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let mut changed = false;\n         self.indices2(ln, succ_ln, |this, idx, succ_idx| {\n-            changed |= copy_if_invalid(this.users.get(succ_idx).reader,\n+            changed |= copy_if_invalid(this.users[succ_idx].reader,\n                                        &mut this.users.get_mut(idx).reader);\n-            changed |= copy_if_invalid(this.users.get(succ_idx).writer,\n+            changed |= copy_if_invalid(this.users[succ_idx].writer,\n                                        &mut this.users.get_mut(idx).writer);\n-            if this.users.get(succ_idx).used && !this.users.get(idx).used {\n+            if this.users[succ_idx].used && !this.users[idx].used {\n                 this.users.get_mut(idx).used = true;\n                 changed = true;\n             }"}, {"sha": "9bd3f49eea6ba6c1372dd84374b243ff5bb19f9c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -500,7 +500,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::ExprPath(_) => {\n-            let def = *self.tcx().def_map.borrow().get(&expr.id);\n+            let def = (*self.tcx().def_map.borrow())[expr.id];\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -597,7 +597,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                   }\n                   ty::ty_unboxed_closure(closure_id, _) => {\n                       let unboxed_closures = self.typer.unboxed_closures().borrow();\n-                      let kind = unboxed_closures.get(&closure_id).kind;\n+                      let kind = (*unboxed_closures)[closure_id].kind;\n                       let mode = self.typer.capture_mode(fn_node_id);\n                       self.cat_upvar(id, span, var_id, fn_node_id, kind, mode, true)\n                   }\n@@ -953,7 +953,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             Some(method_ty) => {\n                 let ref_ty = ty::ty_fn_ret(method_ty);\n                 base_cmt = self.cat_rvalue_node(elt.id(), elt.span(), ref_ty);\n-                *ty::ty_fn_args(method_ty).get(0)\n+                ty::ty_fn_args(method_ty)[0]\n             }\n             None => {\n                 match ty::array_element_ty(base_cmt.ty) {"}, {"sha": "138c671ceb66bf06333436b9878eb3137a2108c4", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -348,7 +348,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // crate module gets processed as well.\n         if self.prev_exported {\n             assert!(self.exp_map2.contains_key(&id), \"wut {}\", id);\n-            for export in self.exp_map2.get(&id).iter() {\n+            for export in self.exp_map2[id].iter() {\n                 if is_local(export.def_id) {\n                     self.reexports.insert(export.def_id.node);\n                 }\n@@ -524,7 +524,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             // if we've reached the root, then everything was allowable and this\n             // access is public.\n             if closest_private_id == ast::CRATE_NODE_ID { return Allowable }\n-            closest_private_id = *self.parents.get(&closest_private_id);\n+            closest_private_id = self.parents[closest_private_id];\n \n             // If we reached the top, then we were public all the way down and\n             // we can allow this access.\n@@ -542,7 +542,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     /// whether the node is accessible by the current module that iteration is\n     /// inside.\n     fn private_accessible(&self, id: ast::NodeId) -> bool {\n-        let parent = *self.parents.get(&id);\n+        let parent = self.parents[id];\n         debug!(\"privacy - accessible parent {}\", self.nodestr(parent));\n \n         // After finding `did`'s closest private member, we roll ourselves back\n@@ -566,7 +566,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 _ => {}\n             }\n \n-            cur = *self.parents.get(&cur);\n+            cur = self.parents[cur];\n         }\n     }\n \n@@ -658,7 +658,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 debug!(\"privacy - check named field {} in struct {}\", ident.name, id);\n                 fields.iter().find(|f| f.name == ident.name).unwrap()\n             }\n-            UnnamedField(idx) => fields.get(idx)\n+            UnnamedField(idx) => &fields[idx]\n         };\n         if field.vis == ast::Public ||\n             (is_local(field.id) && self.private_accessible(field.id.node)) {\n@@ -734,7 +734,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                            name).as_slice())\n             };\n \n-            match *self.last_private_map.get(&path_id) {\n+            match self.last_private_map[path_id] {\n                 resolve::LastMod(resolve::AllPublic) => {},\n                 resolve::LastMod(resolve::DependsOn(def)) => {\n                     self.report_error(ck_public(def));"}, {"sha": "4506cd7e463497c6e414b382bc4f62b138570ac0", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(..) => {\n                 let method_call = typeck::MethodCall::expr(expr.id);\n-                match self.tcx.method_map.borrow().get(&method_call).origin {\n+                match (*self.tcx.method_map.borrow())[method_call].origin {\n                     typeck::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {"}, {"sha": "7c16196f5c2168d927ee7d18d7e9b54c5134fad7", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -334,7 +334,7 @@ impl RegionMaps {\n         // where they diverge.  If one vector is a suffix of the other,\n         // then the corresponding scope is a superscope of the other.\n \n-        if *a_ancestors.get(a_index) != *b_ancestors.get(b_index) {\n+        if a_ancestors[a_index] != b_ancestors[b_index] {\n             return None;\n         }\n \n@@ -345,8 +345,8 @@ impl RegionMaps {\n             if b_index == 0u { return Some(scope_b); }\n             a_index -= 1u;\n             b_index -= 1u;\n-            if *a_ancestors.get(a_index) != *b_ancestors.get(b_index) {\n-                return Some(*a_ancestors.get(a_index + 1u));\n+            if a_ancestors[a_index] != b_ancestors[b_index] {\n+                return Some(a_ancestors[a_index + 1]);\n             }\n         }\n "}, {"sha": "eaec715a6a7e4015caa18fe1d9ae6e05ae54d529", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -1307,11 +1307,13 @@ impl<'a> Resolver<'a> {\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n-                ctor_id.while_some(|cid| {\n-                    name_bindings.define_value(DefStruct(local_def(cid)), sp,\n-                                               is_public);\n-                    None\n-                });\n+                match ctor_id {\n+                    Some(cid) => {\n+                        name_bindings.define_value(DefStruct(local_def(cid)),\n+                                                   sp, is_public);\n+                    }\n+                    None => {}\n+                }\n \n                 // Record the def ID and fields of this struct.\n                 let named_fields = struct_def.fields.iter().filter_map(|f| {\n@@ -1644,7 +1646,7 @@ impl<'a> Resolver<'a> {\n                                         }\n                                     };\n                                     let module_path = module_path.as_slice().init();\n-                                    (Vec::from_slice(module_path), name)\n+                                    (module_path.to_vec(), name)\n                                 }\n                             };\n                             self.build_import_directive(\n@@ -2232,7 +2234,7 @@ impl<'a> Resolver<'a> {\n         let import_count = imports.len();\n         while module.resolved_import_count.get() < import_count {\n             let import_index = module.resolved_import_count.get();\n-            let import_directive = imports.get(import_index);\n+            let import_directive = &(*imports)[import_index];\n             match self.resolve_import_for_module(module.clone(),\n                                                  import_directive) {\n                 Failed(err) => {\n@@ -3669,15 +3671,15 @@ impl<'a> Resolver<'a> {\n         if index != import_count {\n             let sn = self.session\n                          .codemap()\n-                         .span_to_snippet(imports.get(index).span)\n+                         .span_to_snippet((*imports)[index].span)\n                          .unwrap();\n             if sn.as_slice().contains(\"::\") {\n-                self.resolve_error(imports.get(index).span,\n+                self.resolve_error((*imports)[index].span,\n                                    \"unresolved import\");\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                   sn.as_slice().slice(0, sn.len()));\n-                self.resolve_error(imports.get(index).span, err.as_slice());\n+                self.resolve_error((*imports)[index].span, err.as_slice());\n             }\n         }\n \n@@ -3905,12 +3907,17 @@ impl<'a> Resolver<'a> {\n                             def = DefUpvar(node_id, function_id, last_proc_body_id);\n \n                             let mut seen = self.freevars_seen.borrow_mut();\n-                            let seen = seen.find_or_insert(function_id, NodeSet::new());\n+                            let seen = match seen.entry(function_id) {\n+                                Occupied(v) => v.into_mut(),\n+                                Vacant(v) => v.set(NodeSet::new()),\n+                            };\n                             if seen.contains(&node_id) {\n                                 continue;\n                             }\n-                            self.freevars.borrow_mut().find_or_insert(function_id, vec![])\n-                                         .push(Freevar { def: prev_def, span: span });\n+                            match self.freevars.borrow_mut().entry(function_id) {\n+                                Occupied(v) => v.into_mut(),\n+                                Vacant(v) => v.set(vec![]),\n+                            }.push(Freevar { def: prev_def, span: span });\n                             seen.insert(node_id);\n                         }\n                         MethodRibKind(item_id, _) => {\n@@ -4714,7 +4721,7 @@ impl<'a> Resolver<'a> {\n         if arm.pats.len() == 0 {\n             return\n         }\n-        let map_0 = self.binding_mode_map(&**arm.pats.get(0));\n+        let map_0 = self.binding_mode_map(&*arm.pats[0]);\n         for (i, p) in arm.pats.iter().enumerate() {\n             let map_i = self.binding_mode_map(&**p);\n \n@@ -5695,18 +5702,18 @@ impl<'a> Resolver<'a> {\n         for (i, other) in maybes.iter().enumerate() {\n             *values.get_mut(i) = name.lev_distance(other.get());\n \n-            if *values.get(i) <= *values.get(smallest) {\n+            if values[i] <= values[smallest] {\n                 smallest = i;\n             }\n         }\n \n         if values.len() > 0 &&\n-            *values.get(smallest) != uint::MAX &&\n-            *values.get(smallest) < name.len() + 2 &&\n-            *values.get(smallest) <= max_distance &&\n-            name != maybes.get(smallest).get() {\n+            values[smallest] != uint::MAX &&\n+            values[smallest] < name.len() + 2 &&\n+            values[smallest] <= max_distance &&\n+            name != maybes[smallest].get() {\n \n-            Some(maybes.get(smallest).get().to_string())\n+            Some(maybes[smallest].get().to_string())\n \n         } else {\n             None"}, {"sha": "eda4c241f86cf4211a0f40f9fb44c91c7869e5c7", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -399,7 +399,7 @@ impl<'a> LifetimeContext<'a> {\n \n     fn check_lifetime_defs(&mut self, lifetimes: &Vec<ast::LifetimeDef>) {\n         for i in range(0, lifetimes.len()) {\n-            let lifetime_i = lifetimes.get(i);\n+            let lifetime_i = &lifetimes[i];\n \n             let special_idents = [special_idents::static_lifetime];\n             for lifetime in lifetimes.iter() {\n@@ -413,7 +413,7 @@ impl<'a> LifetimeContext<'a> {\n             }\n \n             for j in range(i + 1, lifetimes.len()) {\n-                let lifetime_j = lifetimes.get(j);\n+                let lifetime_j = &lifetimes[j];\n \n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n                     self.sess.span_err("}, {"sha": "dd9601f1c3cfab28f074b011a70c0bfdce86465f", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -208,7 +208,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.bug(format!(\"def_map has no key for {} in lookup_type_ref\",\n                                   ref_id).as_slice());\n         }\n-        let def = *self.analysis.ty_cx.def_map.borrow().get(&ref_id);\n+        let def = (*self.analysis.ty_cx.def_map.borrow())[ref_id];\n         match def {\n             def::DefPrimTy(_) => None,\n             _ => Some(def.def_id()),\n@@ -221,7 +221,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.span_bug(span, format!(\"def_map has no key for {} in lookup_def_kind\",\n                                              ref_id).as_slice());\n         }\n-        let def = *def_map.get(&ref_id);\n+        let def = (*def_map)[ref_id];\n         match def {\n             def::DefMod(_) |\n             def::DefForeignMod(_) => Some(recorder::ModRef),\n@@ -261,7 +261,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             let span_utils = self.span;\n             for &(id, ref p, _, _) in self.collected_paths.iter() {\n                 let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                    *self.analysis.ty_cx.node_types.borrow().get(&(id as uint)));\n+                    (*self.analysis.ty_cx.node_types.borrow())[id as uint]);\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n@@ -302,7 +302,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                 },\n                                 None => {}\n                             }\n-                            result.append(\">::\")\n+                            result.push_str(\">::\");\n+                            result\n                         }\n                         _ => {\n                             self.sess.span_bug(method.span,\n@@ -326,8 +327,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     scope_id = def_id.node;\n                     match self.analysis.ty_cx.map.get(def_id.node) {\n                         NodeItem(_) => {\n-                            let result = ty::item_path_str(&self.analysis.ty_cx, def_id);\n-                            result.append(\"::\")\n+                            let mut result = ty::item_path_str(&self.analysis.ty_cx, def_id);\n+                            result.push_str(\"::\");\n+                            result\n                         }\n                         _ => {\n                             self.sess.span_bug(method.span,\n@@ -350,12 +352,16 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n                                              ast_util::local_def(method.id))\n-            .filtered(|def_id| {\n-                match *def_id {\n+            .and_then(|def_id| {\n+                if match def_id {\n                     ty::MethodTraitItemId(def_id) => {\n                         method.id != 0 && def_id.node == 0\n                     }\n                     ty::TypeTraitItemId(_) => false,\n+                } {\n+                    Some(def_id)\n+                } else {\n+                    None\n                 }\n             });\n         let decl_id = match decl_id {\n@@ -421,7 +427,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 let name = get_ident(ident);\n                 let qualname = format!(\"{}::{}\", qualname, name);\n                 let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                    *self.analysis.ty_cx.node_types.borrow().get(&(field.node.id as uint)));\n+                    (*self.analysis.ty_cx.node_types.borrow())[field.node.id as uint]);\n                 match self.span.sub_span_before_token(field.span, token::COLON) {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n@@ -590,7 +596,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for variant in enum_definition.variants.iter() {\n             let name = get_ident(variant.node.name);\n             let name = name.get();\n-            let qualname = qualname.clone().append(\"::\").append(name);\n+            let mut qualname = qualname.clone();\n+            qualname.push_str(\"::\");\n+            qualname.push_str(name);\n             let val = self.span.snippet(variant.span);\n             match variant.node.kind {\n                 ast::TupleVariantKind(ref args) => {\n@@ -758,7 +766,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                format!(\"def_map has no key for {} in visit_expr\",\n                                        ex.id).as_slice());\n         }\n-        let def = def_map.get(&ex.id);\n+        let def = &(*def_map)[ex.id];\n         let sub_span = self.span.span_for_last_ident(ex.span);\n         match *def {\n             def::DefUpvar(..) |\n@@ -796,7 +804,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                  .ty_cx\n                                                  .impl_items\n                                                  .borrow();\n-                            Some(impl_items.get(&def_id)\n+                            Some((*impl_items)[def_id]\n                                            .iter()\n                                            .find(|mr| {\n                                             ty::impl_or_trait_item(\n@@ -897,7 +905,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                            ex: &ast::Expr,\n                            args: &Vec<P<ast::Expr>>) {\n         let method_map = self.analysis.ty_cx.method_map.borrow();\n-        let method_callee = method_map.get(&typeck::MethodCall::expr(ex.id));\n+        let method_callee = &(*method_map)[typeck::MethodCall::expr(ex.id)];\n         let (def_id, decl_id) = match method_callee.origin {\n             typeck::MethodStatic(def_id) |\n             typeck::MethodStaticUnboxedClosure(def_id) => {\n@@ -1116,7 +1124,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                            ast_util::local_def(method_type.id)) {\n                     Some(def_id) => {\n                         scope_id = def_id.node;\n-                        ty::item_path_str(&self.analysis.ty_cx, def_id).append(\"::\")\n+                        let mut s = ty::item_path_str(&self.analysis.ty_cx, def_id);\n+                        s.push_str(\"::\");\n+                        s\n                     },\n                     None => {\n                         self.sess.span_bug(method_type.span,\n@@ -1347,7 +1357,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     return\n                 }\n \n-                let id = String::from_str(\"$\").append(ex.id.to_string().as_slice());\n+                let mut id = String::from_str(\"$\");\n+                id.push_str(ex.id.to_string().as_slice());\n                 self.process_formals(&decl.inputs, id.as_slice());\n \n                 // walk arg and return types\n@@ -1399,7 +1410,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                    format!(\"def_map has no key for {} in visit_arm\",\n                                            id).as_slice());\n             }\n-            let def = def_map.get(&id);\n+            let def = &(*def_map)[id];\n             match *def {\n                 def::DefLocal(id)  => self.fmt.variable_str(p.span,\n                                                             sub_span,\n@@ -1449,7 +1460,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         for &(id, ref p, ref immut, _) in self.collected_paths.iter() {\n             let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n             let types = self.analysis.ty_cx.node_types.borrow();\n-            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&(id as uint)));\n+            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, (*types)[id as uint]);\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);"}, {"sha": "9dd2e8d143770514ee3fb078674e68d379dee9ed", "filename": "src/librustc/middle/save/recorder.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Frecorder.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -165,12 +165,18 @@ impl<'a> FmtStrs<'a> {\n         let pairs = fields.iter().zip(values);\n         let mut strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(\n             if *f == \"qualname\" {\n-                self.krate.clone().append(\"::\").append(v)\n+                let mut n = self.krate.clone();\n+                n.push_str(\"::\");\n+                n.push_str(v);\n+                n\n             } else {\n                 String::from_str(v)\n             }\n         )));\n-        Some(strs.fold(String::new(), |s, ss| s.append(ss.as_slice())))\n+        Some(strs.fold(String::new(), |mut s, ss| {\n+            s.push_str(ss.as_slice());\n+            s\n+        }))\n     }\n \n     pub fn record_without_span(&mut self,\n@@ -195,8 +201,10 @@ impl<'a> FmtStrs<'a> {\n             None => return,\n         };\n \n-        let result = String::from_str(label);\n-        self.recorder.record(result.append(values_str.as_slice()).append(\"\\n\").as_slice());\n+        let mut result = String::from_str(label);\n+        result.push_str(values_str.as_slice());\n+        result.push_str(\"\\n\");\n+        self.recorder.record(result.as_slice());\n     }\n \n     pub fn record_with_span(&mut self,\n@@ -252,7 +260,9 @@ impl<'a> FmtStrs<'a> {\n         // the local case they can be overridden in one block and there is no nice way\n         // to refer to such a scope in english, so we just hack it by appending the\n         // variable def's node id\n-        let qualname = String::from_str(name).append(\"$\").append(id.to_string().as_slice());\n+        let mut qualname = String::from_str(name);\n+        qualname.push_str(\"$\");\n+        qualname.push_str(id.to_string().as_slice());\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,\n@@ -267,7 +277,9 @@ impl<'a> FmtStrs<'a> {\n                       fn_name: &str,\n                       name: &str,\n                       typ: &str) {\n-        let qualname = String::from_str(fn_name).append(\"::\").append(name);\n+        let mut qualname = String::from_str(fn_name);\n+        qualname.push_str(\"::\");\n+        qualname.push_str(name);\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,"}, {"sha": "54ae4d124f61f3c8c951e24572179da7a534b7de", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -315,8 +315,8 @@ impl<T> VecPerParamSpace<T> {\n         let type_limit = t.len();\n         let self_limit = t.len() + s.len();\n         let mut content = t;\n-        content.push_all_move(s);\n-        content.push_all_move(f);\n+        content.extend(s.into_iter());\n+        content.extend(f.into_iter());\n         VecPerParamSpace {\n             type_limit: type_limit,\n             self_limit: self_limit,"}, {"sha": "aca7054018dc6e1f2a7ca217107416114896401f", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -31,7 +31,6 @@ use middle::ty_fold::TypeFoldable;\n use std::cell::RefCell;\n use std::collections::hashmap::HashMap;\n use std::rc::Rc;\n-use std::result;\n use syntax::ast;\n use util::ppaux::Repr;\n \n@@ -1221,18 +1220,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            nested: Vec<ty::t>)\n                            -> VtableBuiltinData<Obligation>\n     {\n-        let obligations =\n-            result::collect(\n-                nested\n-                    .iter()\n-                    .map(|&t| {\n-                        util::obligation_for_builtin_bound(\n-                            self.tcx(),\n-                            obligation.cause,\n-                            bound,\n-                            obligation.recursion_depth + 1,\n-                            t)\n-                    }));\n+        let obligations = nested.iter().map(|&t| {\n+            util::obligation_for_builtin_bound(\n+                self.tcx(),\n+                obligation.cause,\n+                bound,\n+                obligation.recursion_depth + 1,\n+                t)\n+        }).collect::<Result<_, _>>();\n         let obligations = match obligations {\n             Ok(o) => o,\n             Err(ErrorReported) => Vec::new()\n@@ -1302,7 +1297,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 |br| self.infcx.next_region_var(\n                          infer::LateBoundRegion(obligation.cause.span, br)));\n \n-        let arguments_tuple = *new_signature.inputs.get(0);\n+        let arguments_tuple = new_signature.inputs[0];\n         let trait_ref = Rc::new(ty::TraitRef {\n             def_id: obligation.trait_ref.def_id,\n             substs: Substs::new_trait("}, {"sha": "9ee2c3aa14907a62af334d681632ecedd18a6c54", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -110,7 +110,7 @@ impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef>> for Supertraits<'cx, 'tcx> {\n     fn next(&mut self) -> Option<Rc<ty::TraitRef>> {\n         loop {\n             // Extract next item from top-most stack frame, if any.\n-            let next_trait = match self.stack.mut_last() {\n+            let next_trait = match self.stack.last_mut() {\n                 None => {\n                     // No more stack frames. Done.\n                     return None;\n@@ -121,8 +121,7 @@ impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef>> for Supertraits<'cx, 'tcx> {\n                         // Still more supertraits left in the top stack frame.\n                         entry.position += 1;\n \n-                        let next_trait =\n-                            (*entry.supertraits.get(p)).clone();\n+                        let next_trait = entry.supertraits[p].clone();\n                         Some(next_trait)\n                     } else {\n                         None"}, {"sha": "be02b6a1c81fee592c8b294dbfb7a7b00a58f028", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -369,7 +369,7 @@ impl<'a, 'p, 'blk, 'tcx> Repr for Match<'a, 'p, 'blk, 'tcx> {\n \n fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     for br in m.iter() {\n-        match br.pats.get(col).node {\n+        match br.pats[col].node {\n             ast::PatIdent(_, _, Some(_)) => return true,\n             _ => ()\n         }\n@@ -391,7 +391,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     m.iter().map(|br| {\n         let mut bound_ptrs = br.bound_ptrs.clone();\n-        let mut pat = *br.pats.get(col);\n+        let mut pat = br.pats[col];\n         loop {\n             pat = match pat.node {\n                 ast::PatIdent(_, ref path, Some(ref inner)) => {\n@@ -430,7 +430,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     m.iter().filter_map(|br| {\n         e(br.pats.as_slice()).map(|pats| {\n-            let this = *br.pats.get(col);\n+            let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n                 ast::PatIdent(_, ref path, None) => {\n@@ -476,7 +476,9 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n-            Some(Vec::from_slice(pats[..col]).append(pats[col + 1..]))\n+            let mut r = pats[..col].to_vec();\n+            r.push_all(pats[col + 1..]);\n+            Some(r)\n         } else {\n             None\n         }\n@@ -561,7 +563,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let mut found: Vec<Opt> = vec![];\n     for br in m.iter() {\n-        let cur = *br.pats.get(col);\n+        let cur = br.pats[col];\n         let opt = match cur.node {\n             ast::PatLit(ref l) => ConstantValue(ConstantExpr(&**l)),\n             ast::PatIdent(..) | ast::PatEnum(..) | ast::PatStruct(..) => {\n@@ -672,7 +674,7 @@ fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n macro_rules! any_pat (\n     ($m:expr, $col:expr, $pattern:pat) => (\n         ($m).iter().any(|br| {\n-            match br.pats.get($col).node {\n+            match br.pats[$col].node {\n                 $pattern => true,\n                 _ => false\n             }\n@@ -690,7 +692,7 @@ fn any_region_pat(m: &[Match], col: uint) -> bool {\n \n fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n-        let pat = *br.pats.get(col);\n+        let pat = br.pats[col];\n         match pat.node {\n             ast::PatTup(_) => true,\n             ast::PatStruct(..) => {\n@@ -967,7 +969,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         None => {\n             let data = &m[0].data;\n             for &(ref ident, ref value_ptr) in m[0].bound_ptrs.iter() {\n-                let llmatch = data.bindings_map.get(ident).llmatch;\n+                let llmatch = data.bindings_map[*ident].llmatch;\n                 call_lifetime_start(bcx, llmatch);\n                 Store(bcx, *value_ptr, llmatch);\n             }\n@@ -999,12 +1001,13 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n \n-    let vals_left = Vec::from_slice(vals[0u..col]).append(vals[col + 1u..vals.len()]);\n+    let mut vals_left = vals[0u..col].to_vec();\n+    vals_left.push_all(vals[col + 1u..]);\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but\n     // each column is guaranteed to have at least one real pattern)\n-    let pat_id = m.iter().map(|br| br.pats.get(col).id)\n+    let pat_id = m.iter().map(|br| br.pats[col].id)\n                          .find(|&id| id != DUMMY_NODE_ID)\n                          .unwrap_or(DUMMY_NODE_ID);\n \n@@ -1041,7 +1044,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                         &check_match::Single, col,\n                                         field_vals.len())\n             );\n-            let vals = field_vals.append(vals_left.as_slice());\n+            let mut vals = field_vals;\n+            vals.push_all(vals_left.as_slice());\n             compile_submatch(bcx, pats.as_slice(), vals.as_slice(), chk, has_genuine_default);\n             return;\n         }\n@@ -1055,7 +1059,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let mut test_val = val;\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));\n     if opts.len() > 0u {\n-        match *opts.get(0) {\n+        match opts[0] {\n             ConstantValue(_) | ConstantRange(_, _) => {\n                 test_val = load_if_immediate(bcx, val, left_ty);\n                 kind = if ty::type_is_integral(left_ty) {\n@@ -1194,7 +1198,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             ConstantValue(_) | ConstantRange(_, _) => ()\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n-        let opt_vals = unpacked.append(vals_left.as_slice());\n+        let mut opt_vals = unpacked;\n+        opt_vals.push_all(vals_left.as_slice());\n         compile_submatch(opt_cx,\n                          opt_ms.as_slice(),\n                          opt_vals.as_slice(),\n@@ -1358,7 +1363,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     let arm_datas: Vec<ArmData> = arms.iter().map(|arm| ArmData {\n         bodycx: fcx.new_id_block(\"case_body\", arm.body.id),\n         arm: arm,\n-        bindings_map: create_bindings_map(bcx, &**arm.pats.get(0), discr_expr, &*arm.body)\n+        bindings_map: create_bindings_map(bcx, &*arm.pats[0], discr_expr, &*arm.body)\n     }).collect();\n \n     let mut static_inliner = StaticInliner::new(scope_cx.tcx());\n@@ -1654,7 +1659,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                     val);\n                     for sub_pat in sub_pats.iter() {\n                         for (i, &argval) in args.vals.iter().enumerate() {\n-                            bcx = bind_irrefutable_pat(bcx, &**sub_pat.get(i),\n+                            bcx = bind_irrefutable_pat(bcx, &*sub_pat[i],\n                                                        argval, cleanup_scope);\n                         }\n                     }"}, {"sha": "802ca56fd3bf651126eb8fb6d557a4f60d6ad072", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -224,7 +224,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 // Equivalent to a struct/tuple/newtype.\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                let mut ftys = cases.get(0).tys.clone();\n+                let mut ftys = cases[0].tys.clone();\n                 if dtor { ftys.push(ty::mk_bool()); }\n                 return Univariant(mk_struct(cx, ftys.as_slice(), false, t),\n                                   dtor);\n@@ -234,23 +234,23 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 // Nullable pointer optimization\n                 let mut discr = 0;\n                 while discr < 2 {\n-                    if cases.get(1 - discr).is_zerolen(cx, t) {\n-                        let st = mk_struct(cx, cases.get(discr).tys.as_slice(),\n+                    if cases[1 - discr].is_zerolen(cx, t) {\n+                        let st = mk_struct(cx, cases[discr].tys.as_slice(),\n                                            false, t);\n-                        match cases.get(discr).find_ptr() {\n+                        match cases[discr].find_ptr() {\n                             Some(ThinPointer(_)) if st.fields.len() == 1 => {\n                                 return RawNullablePointer {\n                                     nndiscr: discr as Disr,\n-                                    nnty: *st.fields.get(0),\n-                                    nullfields: cases.get(1 - discr).tys.clone()\n+                                    nnty: st.fields[0],\n+                                    nullfields: cases[1 - discr].tys.clone()\n                                 };\n                             }\n                             Some(ptrfield) => {\n                                 return StructWrappedNullablePointer {\n                                     nndiscr: discr as Disr,\n                                     nonnull: st,\n                                     ptrfield: ptrfield,\n-                                    nullfields: cases.get(1 - discr).tys.clone()\n+                                    nullfields: cases[1 - discr].tys.clone()\n                                 };\n                             }\n                             None => { }\n@@ -267,7 +267,8 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let ity = range_to_inttype(cx, hint, &bounds);\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n-                let mut ftys = vec!(ty_of_inttype(ity)).append(c.tys.as_slice());\n+                let mut ftys = vec!(ty_of_inttype(ity));\n+                ftys.push_all(c.tys.as_slice());\n                 if dtor { ftys.push(ty::mk_bool()); }\n                 mk_struct(cx, ftys.as_slice(), false, t)\n             }).collect();\n@@ -369,7 +370,7 @@ fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool, scapegoat: ty::t) -\n         align: machine::llalign_of_min(cx, llty_rec),\n         sized: sized,\n         packed: packed,\n-        fields: Vec::from_slice(tys),\n+        fields: tys.to_vec(),\n     }\n }\n \n@@ -745,7 +746,7 @@ pub fn trans_set_discr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr) {\n         General(ity, ref cases, dtor) => {\n             if dtor {\n                 let ptr = trans_field_ptr(bcx, r, val, discr,\n-                                          cases.get(discr as uint).fields.len() - 2);\n+                                          cases[discr as uint].fields.len() - 2);\n                 Store(bcx, C_u8(bcx.ccx(), 1), ptr);\n             }\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n@@ -769,7 +770,7 @@ pub fn trans_set_discr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr) {\n                 let (llptrptr, llptrty) = match ptrfield {\n                     ThinPointer(field) =>\n                         (GEPi(bcx, val, [0, field]),\n-                         type_of::type_of(bcx.ccx(), *nonnull.fields.get(field))),\n+                         type_of::type_of(bcx.ccx(), nonnull.fields[field])),\n                     FatPointer(field, pair) => {\n                         let v = GEPi(bcx, val, [0, field, pair]);\n                         (v, val_ty(v).element_type())\n@@ -800,7 +801,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n         General(_, ref cases, dtor) => {\n-            cases.get(discr as uint).fields.len() - 1 - (if dtor { 1 } else { 0 })\n+            cases[discr as uint].fields.len() - 1 - (if dtor { 1 } else { 0 })\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } => {\n             if discr == nndiscr { 1 } else { nullfields.len() }\n@@ -827,13 +828,13 @@ pub fn trans_field_ptr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr,\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(_, ref cases, _) => {\n-            struct_field_ptr(bcx, cases.get(discr as uint), val, ix + 1, true)\n+            struct_field_ptr(bcx, &cases[discr as uint], val, ix + 1, true)\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } |\n         StructWrappedNullablePointer { nndiscr, ref nullfields, .. } if discr != nndiscr => {\n             // The unit-like case might have a nonzero number of unit-like fields.\n             // (e.d., Result of Either with (), as one side.)\n-            let ty = type_of::type_of(bcx.ccx(), *nullfields.get(ix));\n+            let ty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n             assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n             // The contents of memory at this pointer can't matter, but use\n             // the value that's \"reasonable\" in case of pointer comparison.\n@@ -965,14 +966,14 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n             C_integral(ll_inttype(ccx, ity), discr as u64, true)\n         }\n         General(ity, ref cases, _) => {\n-            let case = cases.get(discr as uint);\n+            let case = &cases[discr as uint];\n             let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n-            let contents = build_const_struct(ccx,\n-                                              case,\n-                                              (vec!(lldiscr)).append(vals).as_slice());\n-            C_struct(ccx, contents.append([padding(ccx, max_sz - case.size)]).as_slice(),\n-                     false)\n+            let mut f = vec![lldiscr];\n+            f.push_all(vals);\n+            let mut contents = build_const_struct(ccx, case, f.as_slice());\n+            contents.push_all([padding(ccx, max_sz - case.size)]);\n+            C_struct(ccx, contents.as_slice(), false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);"}, {"sha": "04237a2d44925d6f4a6fd70aca43e64639d96939", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -62,7 +62,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     }).collect::<Vec<_>>();\n \n     // Now the input operands\n-    let inputs = ia.inputs.iter().map(|&(ref c, ref input)| {\n+    let mut inputs = ia.inputs.iter().map(|&(ref c, ref input)| {\n         constraints.push((*c).clone());\n \n         let in_datum = unpack_datum!(bcx, expr::trans(bcx, &**input));\n@@ -73,7 +73,8 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                     cleanup::CustomScope(temp_scope),\n                                     callee::DontAutorefArg)\n         })\n-    }).collect::<Vec<_>>().append(ext_inputs.as_slice());\n+    }).collect::<Vec<_>>();\n+    inputs.push_all(ext_inputs.as_slice());\n \n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n@@ -95,7 +96,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n \n     // Add the clobbers to our constraints list\n     if clobbers.len() != 0 && constraints.len() != 0 {\n-        constraints.push_char(',');\n+        constraints.push(',');\n         constraints.push_str(clobbers.as_slice());\n     } else {\n         constraints.push_str(clobbers.as_slice());\n@@ -109,7 +110,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     let output_type = if num_outputs == 0 {\n         Type::void(bcx.ccx())\n     } else if num_outputs == 1 {\n-        *output_types.get(0)\n+        output_types[0]\n     } else {\n         Type::struct_(bcx.ccx(), output_types.as_slice(), false)\n     };\n@@ -134,7 +135,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n \n     // Again, based on how many outputs we have\n     if num_outputs == 1 {\n-        Store(bcx, r, *outputs.get(0));\n+        Store(bcx, r, outputs[0]);\n     } else {\n         for (i, o) in outputs.iter().enumerate() {\n             let v = ExtractValue(bcx, r, i);"}, {"sha": "239193ab79a93d99a6bd2c15dab20dfbb3ad3f74", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -259,7 +259,7 @@ pub fn self_type_for_unboxed_closure(ccx: &CrateContext,\n                                                       closure_id,\n                                                       ty::ReStatic);\n     let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-    let unboxed_closure = unboxed_closures.get(&closure_id);\n+    let unboxed_closure = &(*unboxed_closures)[closure_id];\n     match unboxed_closure.kind {\n         ty::FnUnboxedClosureKind => {\n             ty::mk_imm_rptr(ccx.tcx(), ty::ReStatic, unboxed_closure_type)\n@@ -274,7 +274,7 @@ pub fn self_type_for_unboxed_closure(ccx: &CrateContext,\n pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n                                 -> ty::UnboxedClosureKind {\n     let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-    unboxed_closures.get(&closure_id).kind\n+    (*unboxed_closures)[closure_id].kind\n }\n \n pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n@@ -287,7 +287,7 @@ pub fn decl_rust_fn(ccx: &CrateContext, fn_ty: ty::t, name: &str) -> ValueRef {\n         }\n         ty::ty_unboxed_closure(closure_did, _) => {\n             let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-            let unboxed_closure = unboxed_closures.get(&closure_did);\n+            let unboxed_closure = &(*unboxed_closures)[closure_did];\n             let function_type = unboxed_closure.closure_type.clone();\n             let self_type = self_type_for_unboxed_closure(ccx, closure_did);\n             let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n@@ -771,7 +771,7 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n           match adt::trans_switch(cx, &*repr, av) {\n               (_match::Single, None) => {\n-                  cx = iter_variant(cx, &*repr, av, &**variants.get(0),\n+                  cx = iter_variant(cx, &*repr, av, &*(*variants)[0],\n                                     substs, f);\n               }\n               (_match::Switch, Some(lldiscrim_a)) => {\n@@ -2121,7 +2121,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n                                      ({} bytes) than the next largest (ignoring padding)\",\n                                     largest).as_slice());\n \n-        ccx.sess().span_note(enum_def.variants.get(largest_index).span,\n+        ccx.sess().span_note(enum_def.variants[largest_index].span,\n                              \"this variant is the largest\");\n     }\n }\n@@ -2353,7 +2353,7 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n         ty::ty_bare_fn(ref f) => (f.sig.clone(), f.abi, false),\n         ty::ty_unboxed_closure(closure_did, _) => {\n             let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n-            let ref function_type = unboxed_closures.get(&closure_did)\n+            let ref function_type = (*unboxed_closures)[closure_did]\n                                                     .closure_type;\n \n             (function_type.sig.clone(), RustCall, true)\n@@ -2381,11 +2381,14 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n             }\n         },\n         ty::ty_bare_fn(_) if abi == RustCall => {\n-            let inputs = vec![fn_sig.inputs[0]];\n+            let mut inputs = vec![fn_sig.inputs[0]];\n \n             match ty::get(fn_sig.inputs[1]).sty {\n                 ty::ty_nil => inputs,\n-                ty::ty_tup(ref t_in) => inputs.append(t_in.as_slice()),\n+                ty::ty_tup(ref t_in) => {\n+                    inputs.push_all(t_in.as_slice());\n+                    inputs\n+                }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         }\n@@ -2904,13 +2907,11 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n \n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n-    let compressed = Vec::from_slice(encoder::metadata_encoding_version)\n-                     .append(match flate::deflate_bytes(metadata.as_slice()) {\n-                         Some(compressed) => compressed,\n-                         None => {\n-                             cx.sess().fatal(\"failed to compress metadata\")\n-                         }\n-                     }.as_slice());\n+    let mut compressed = encoder::metadata_encoding_version.to_vec();\n+    compressed.push_all(match flate::deflate_bytes(metadata.as_slice()) {\n+        Some(compressed) => compressed,\n+        None => cx.sess().fatal(\"failed to compress metadata\"),\n+    }.as_slice());\n     let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed.as_slice());\n     let llconst = C_struct_in_context(cx.metadata_llcx(), [llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\","}, {"sha": "81428937e4b1f3d179ccc1fe5dcb3625d26f11ac", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -72,13 +72,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let mut s = String::from_str(\".\");\n                 i = 0u;\n                 while i < len {\n-                    i = *mm.get(&v[i]);\n-                    s.push_char('/');\n+                    i = mm[v[i]];\n+                    s.push('/');\n                     s.push_str(v[i]);\n                     i += 1u;\n                 }\n \n-                s.push_char('/');\n+                s.push('/');\n                 s.push_str(category);\n \n                 let n = match h.find(&s) {"}, {"sha": "1b8a354259ad785977df301be29db8335658ca6b", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -316,7 +316,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n                 tys.push(Type::i64(ccx));\n             }\n             SSEFv => {\n-                let vec_len = llvec_len(cls.tailn(i + 1u));\n+                let vec_len = llvec_len(cls[i + 1u..]);\n                 let vec_ty = Type::vector(&Type::f32(ccx), (vec_len * 2u) as u64);\n                 tys.push(vec_ty);\n                 i += vec_len;"}, {"sha": "d610a80347baffa8d6ac5aeff1c57cd8dbbece43", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -260,7 +260,7 @@ pub fn trans_unboxing_shim(bcx: Block,\n     let tcx = bcx.tcx();\n \n     // Transform the self type to `Box<self_type>`.\n-    let self_type = *fty.sig.inputs.get(0);\n+    let self_type = fty.sig.inputs[0];\n     let boxed_self_type = ty::mk_uniq(tcx, self_type);\n     let boxed_function_type = ty::FnSig {\n         binder_id: fty.sig.binder_id,\n@@ -332,9 +332,9 @@ pub fn trans_unboxing_shim(bcx: Block,\n     let arg_scope = fcx.push_custom_cleanup_scope();\n     let arg_scope_id = cleanup::CustomScope(arg_scope);\n     let boxed_arg_types = ty::ty_fn_args(boxed_function_type);\n-    let boxed_self_type = *boxed_arg_types.get(0);\n+    let boxed_self_type = boxed_arg_types[0];\n     let arg_types = ty::ty_fn_args(function_type);\n-    let self_type = *arg_types.get(0);\n+    let self_type = arg_types[0];\n     let boxed_self_kind = arg_kind(&fcx, boxed_self_type);\n \n     // Create a datum for self.\n@@ -541,7 +541,7 @@ pub fn trans_fn_ref_with_substs(\n             let ref_ty = match node {\n                 ExprId(id) => node_id_type(bcx, id),\n                 MethodCall(method_call) => {\n-                    let t = bcx.tcx().method_map.borrow().get(&method_call).ty;\n+                    let t = (*bcx.tcx().method_map.borrow())[method_call].ty;\n                     monomorphize_type(bcx, t)\n                 }\n             };\n@@ -628,7 +628,7 @@ pub fn trans_method_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex={})\", call_ex.repr(bcx.tcx()));\n     let method_call = MethodCall::expr(call_ex.id);\n-    let method_ty = bcx.tcx().method_map.borrow().get(&method_call).ty;\n+    let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n     trans_call_inner(\n         bcx,\n         Some(common::expr_info(call_ex)),\n@@ -915,7 +915,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n             trans_arg_datum(bcx,\n-                            *arg_tys.get(0),\n+                            arg_tys[0],\n                             arg_datum,\n                             arg_cleanup_scope,\n                             DontAutorefArg)\n@@ -940,7 +940,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n             for i in range(0, field_types.len()) {\n                 let arg_datum = tuple_lvalue_datum.get_element(\n                     bcx,\n-                    *field_types.get(i),\n+                    field_types[i],\n                     |srcval| {\n                         adt::trans_field_ptr(bcx, repr_ptr, srcval, 0, i)\n                     });\n@@ -976,15 +976,15 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n         let arg_datum = unpack_datum!(bcx, expr::trans(bcx, arg_exprs[0]));\n         llargs.push(unpack_result!(bcx, {\n             trans_arg_datum(bcx,\n-                            *arg_tys.get(0),\n+                            arg_tys[0],\n                             arg_datum,\n                             arg_cleanup_scope,\n                             DontAutorefArg)\n         }))\n     }\n \n     // Now untuple the rest of the arguments.\n-    let tuple_type = *arg_tys.get(1);\n+    let tuple_type = arg_tys[1];\n     match ty::get(tuple_type).sty {\n         ty::ty_tup(ref field_types) => {\n             for (i, &field_type) in field_types.iter().enumerate() {\n@@ -1050,7 +1050,7 @@ pub fn trans_args<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                     assert!(variadic);\n                     expr_ty_adjusted(cx, &**arg_expr)\n                 } else {\n-                    *arg_tys.get(i)\n+                    arg_tys[i]\n                 };\n \n                 let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &**arg_expr));\n@@ -1073,15 +1073,15 @@ pub fn trans_args<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n             assert!(!variadic);\n \n             llargs.push(unpack_result!(bcx, {\n-                trans_arg_datum(bcx, *arg_tys.get(0), lhs,\n+                trans_arg_datum(bcx, arg_tys[0], lhs,\n                                 arg_cleanup_scope,\n                                 DontAutorefArg)\n             }));\n \n             assert_eq!(arg_tys.len(), 1 + rhs.len());\n-            for (rhs, rhs_id) in rhs.move_iter() {\n+            for (rhs, rhs_id) in rhs.into_iter() {\n                 llargs.push(unpack_result!(bcx, {\n-                    trans_arg_datum(bcx, *arg_tys.get(1), rhs,\n+                    trans_arg_datum(bcx, arg_tys[1], rhs,\n                                     arg_cleanup_scope,\n                                     DoAutorefArg(rhs_id))\n                 }));"}, {"sha": "827df48071af9221da0309ad38bed8b90d62e80d", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -549,7 +549,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n     fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n         let scopes = self.scopes.borrow();\n         custom_scope.index < scopes.len() &&\n-            scopes.get(custom_scope.index).kind.is_temp()\n+            (*scopes)[custom_scope.index].kind.is_temp()\n     }\n \n     fn trans_scope_cleanups(&self, // cannot borrow self, will recurse"}, {"sha": "d620b037549430b33a95cdd9cc9afd4f9b70579c", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -473,7 +473,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n         closure_id).unwrap();\n \n     let unboxed_closures = bcx.tcx().unboxed_closures.borrow();\n-    let function_type = unboxed_closures.get(&closure_id)\n+    let function_type = (*unboxed_closures)[closure_id]\n                                         .closure_type\n                                         .clone();\n     let function_type = ty::mk_closure(bcx.tcx(), function_type);"}, {"sha": "945345425b3911759299669b356d701f13683c59", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -59,9 +59,9 @@ fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::struct_fields(ccx.tcx(), def_id, substs);\n             fields.len() == 1 &&\n-                fields.get(0).ident.name ==\n+                fields[0].ident.name ==\n                     token::special_idents::unnamed_field.name &&\n-                type_is_immediate(ccx, fields.get(0).mt.ty)\n+                type_is_immediate(ccx, fields[0].mt.ty)\n         }\n         _ => false\n     }\n@@ -914,7 +914,7 @@ pub fn node_id_substs(bcx: Block,\n             ty::node_id_item_substs(tcx, id).substs\n         }\n         MethodCall(method_call) => {\n-            tcx.method_map.borrow().get(&method_call).substs.clone()\n+            (*tcx.method_map.borrow())[method_call].substs.clone()\n         }\n     };\n "}, {"sha": "399d2a0ec28059387840019c90e58478411d4f95", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -311,7 +311,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n     let map_list = |exprs: &[P<ast::Expr>]| {\n         exprs.iter().map(|e| const_expr(cx, &**e).val0())\n-             .fold(Vec::new(), |l, val| l.append_one(val))\n+             .fold(Vec::new(), |mut l, val| { l.push(val); l })\n     };\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");"}, {"sha": "b2611987f04ea3f9c50bc512e90aa74be4fa2cbd", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -291,10 +291,9 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     // Set up the method call (to `.next()`).\n     let method_call = MethodCall::expr(loop_info.id);\n-    let method_type = loopback_bcx_in.tcx()\n+    let method_type = (*loopback_bcx_in.tcx()\n                                      .method_map\n-                                     .borrow()\n-                                     .get(&method_call)\n+                                     .borrow())[method_call]\n                                      .ty;\n     let method_type = monomorphize_type(loopback_bcx_in, method_type);\n     let method_result_type = ty::ty_fn_ret(method_type);"}, {"sha": "f2c965924cd191b44c434ea70b2789e076bb4841", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 52, "deletions": 54, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -348,7 +348,7 @@ impl TypeMap {\n         };\n \n         let mut unique_type_id = String::with_capacity(256);\n-        unique_type_id.push_char('{');\n+        unique_type_id.push('{');\n \n         match ty::get(type_).sty {\n             ty::ty_nil      |\n@@ -380,13 +380,13 @@ impl TypeMap {\n                 }\n             },\n             ty::ty_uniq(inner_type) => {\n-                unique_type_id.push_char('~');\n+                unique_type_id.push('~');\n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(inner_type_id.as_slice());\n             },\n             ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n-                unique_type_id.push_char('*');\n+                unique_type_id.push('*');\n                 if mutbl == ast::MutMutable {\n                     unique_type_id.push_str(\"mut\");\n                 }\n@@ -396,7 +396,7 @@ impl TypeMap {\n                 unique_type_id.push_str(inner_type_id.as_slice());\n             },\n             ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n-                unique_type_id.push_char('&');\n+                unique_type_id.push('&');\n                 if mutbl == ast::MutMutable {\n                     unique_type_id.push_str(\"mut\");\n                 }\n@@ -443,7 +443,7 @@ impl TypeMap {\n                     let parameter_type_id =\n                         self.get_unique_type_id_as_string(parameter_type_id);\n                     unique_type_id.push_str(parameter_type_id.as_slice());\n-                    unique_type_id.push_char(',');\n+                    unique_type_id.push(',');\n                 }\n \n                 if sig.variadic {\n@@ -474,7 +474,7 @@ impl TypeMap {\n             }\n         };\n \n-        unique_type_id.push_char('}');\n+        unique_type_id.push('}');\n \n         // Trim to size before storing permanently\n         unique_type_id.shrink_to_fit();\n@@ -489,8 +489,6 @@ impl TypeMap {\n                                   def_id: ast::DefId,\n                                   substs: &subst::Substs,\n                                   output: &mut String) {\n-            use std::num::ToStrRadix;\n-\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n             let source_def_id = if def_id.krate == ast::LOCAL_CRATE {\n@@ -515,24 +513,24 @@ impl TypeMap {\n \n             output.push_str(crate_hash.as_str());\n             output.push_str(\"/\");\n-            output.push_str(def_id.node.to_str_radix(16).as_slice());\n+            output.push_str(format!(\"{:x}\", def_id.node).as_slice());\n \n             // Maybe check that there is no self type here.\n \n             let tps = substs.types.get_slice(subst::TypeSpace);\n             if tps.len() > 0 {\n-                output.push_char('<');\n+                output.push('<');\n \n                 for &type_parameter in tps.iter() {\n                     let param_type_id =\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id =\n                         type_map.get_unique_type_id_as_string(param_type_id);\n                     output.push_str(param_type_id.as_slice());\n-                    output.push_char(',');\n+                    output.push(',');\n                 }\n \n-                output.push_char('>');\n+                output.push('>');\n             }\n         }\n     }\n@@ -571,7 +569,7 @@ impl TypeMap {\n             let parameter_type_id =\n                 self.get_unique_type_id_as_string(parameter_type_id);\n             unique_type_id.push_str(parameter_type_id.as_slice());\n-            unique_type_id.push_char(',');\n+            unique_type_id.push(',');\n         }\n \n         if sig.variadic {\n@@ -584,7 +582,7 @@ impl TypeMap {\n         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n         unique_type_id.push_str(return_type_id.as_slice());\n \n-        unique_type_id.push_char(':');\n+        unique_type_id.push(':');\n \n         for bound in bounds.builtin_bounds.iter() {\n             match bound {\n@@ -593,7 +591,7 @@ impl TypeMap {\n                 ty::BoundCopy => unique_type_id.push_str(\"Copy\"),\n                 ty::BoundSync => unique_type_id.push_str(\"Sync\"),\n             };\n-            unique_type_id.push_char('+');\n+            unique_type_id.push('+');\n         }\n     }\n \n@@ -1402,7 +1400,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             return create_DIArray(DIB(cx), []);\n         }\n \n-        name_to_append_suffix_to.push_char('<');\n+        name_to_append_suffix_to.push('<');\n \n         // The list to be filled with template parameters:\n         let mut template_params: Vec<DIDescriptor> =\n@@ -1483,7 +1481,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             }\n         }\n \n-        name_to_append_suffix_to.push_char('>');\n+        name_to_append_suffix_to.push('>');\n \n         return create_DIArray(DIB(cx), template_params.as_slice());\n     }\n@@ -1526,7 +1524,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                             // prepend \"./\" if necessary\n                             let dotdot = b\"..\";\n                             let prefix = &[dotdot[0], ::std::path::SEP_BYTE];\n-                            let mut path_bytes = Vec::from_slice(p.as_vec());\n+                            let mut path_bytes = p.as_vec().to_vec();\n \n                             if path_bytes.slice_to(2) != prefix &&\n                                path_bytes.slice_to(2) != dotdot {\n@@ -1927,7 +1925,7 @@ impl StructMemberDescriptionFactory {\n         }\n \n         let field_size = if self.is_simd {\n-            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields.get(0).mt.ty)) as uint\n+            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields[0].mt.ty)) as uint\n         } else {\n             0xdeadbeef\n         };\n@@ -2038,7 +2036,7 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n                            UNKNOWN_SCOPE_METADATA),\n         tuple_llvm_type,\n         TupleMDF(TupleMemberDescriptionFactory {\n-            component_types: Vec::from_slice(component_types),\n+            component_types: component_types.to_vec(),\n             span: span,\n         })\n     )\n@@ -2081,7 +2079,7 @@ impl EnumMemberDescriptionFactory {\n                             describe_enum_variant(cx,\n                                                   self.enum_type,\n                                                   struct_def,\n-                                                  &**self.variants.get(i),\n+                                                  &*(*self.variants)[i],\n                                                   discriminant_info,\n                                                   self.containing_scope,\n                                                   self.span);\n@@ -2114,7 +2112,7 @@ impl EnumMemberDescriptionFactory {\n                         describe_enum_variant(cx,\n                                               self.enum_type,\n                                               struct_def,\n-                                              &**self.variants.get(0),\n+                                              &*(*self.variants)[0],\n                                               NoDiscriminant,\n                                               self.containing_scope,\n                                               self.span);\n@@ -2143,7 +2141,7 @@ impl EnumMemberDescriptionFactory {\n                 // DWARF representation of enums uniform.\n \n                 // First create a description of the artificial wrapper struct:\n-                let non_null_variant = self.variants.get(non_null_variant_index as uint);\n+                let non_null_variant = &(*self.variants)[non_null_variant_index as uint];\n                 let non_null_variant_ident = non_null_variant.name;\n                 let non_null_variant_name = token::get_ident(non_null_variant_ident);\n \n@@ -2160,7 +2158,7 @@ impl EnumMemberDescriptionFactory {\n                 // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n                     name: match non_null_variant.arg_names {\n-                        Some(ref names) => token::get_ident(*names.get(0)).get().to_string(),\n+                        Some(ref names) => token::get_ident(names[0]).get().to_string(),\n                         None => \"\".to_string()\n                     },\n                     llvm_type: non_null_llvm_type,\n@@ -2190,7 +2188,7 @@ impl EnumMemberDescriptionFactory {\n                 // Encode the information about the null variant in the union\n                 // member's name.\n                 let null_variant_index = (1 - non_null_variant_index) as uint;\n-                let null_variant_ident = self.variants.get(null_variant_index).name;\n+                let null_variant_ident = (*self.variants)[null_variant_index].name;\n                 let null_variant_name = token::get_ident(null_variant_ident);\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 0u,\n@@ -2216,7 +2214,7 @@ impl EnumMemberDescriptionFactory {\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n-                                          &**self.variants.get(nndiscr as uint),\n+                                          &*(*self.variants)[nndiscr as uint],\n                                           OptimizedDiscriminant(ptrfield),\n                                           self.containing_scope,\n                                           self.span);\n@@ -2232,7 +2230,7 @@ impl EnumMemberDescriptionFactory {\n                 // Encode the information about the null variant in the union\n                 // member's name.\n                 let null_variant_index = (1 - nndiscr) as uint;\n-                let null_variant_ident = self.variants.get(null_variant_index).name;\n+                let null_variant_ident = (*self.variants)[null_variant_index].name;\n                 let null_variant_name = token::get_ident(null_variant_ident);\n                 let discrfield = match ptrfield {\n                     adt::ThinPointer(field) => format!(\"{}\", field),\n@@ -2706,14 +2704,14 @@ fn vec_slice_metadata(cx: &CrateContext,\n     let member_descriptions = [\n         MemberDescription {\n             name: \"data_ptr\".to_string(),\n-            llvm_type: *member_llvm_types.get(0),\n+            llvm_type: member_llvm_types[0],\n             type_metadata: element_type_metadata,\n             offset: ComputedMemberOffset,\n             flags: FLAGS_NONE\n         },\n         MemberDescription {\n             name: \"length\".to_string(),\n-            llvm_type: *member_llvm_types.get(1),\n+            llvm_type: member_llvm_types[1],\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n             offset: ComputedMemberOffset,\n             flags: FLAGS_NONE\n@@ -3081,14 +3079,14 @@ fn bytes_to_bits(bytes: u64) -> u64 {\n \n #[inline]\n fn debug_context<'a>(cx: &'a CrateContext) -> &'a CrateDebugContext {\n-    let debug_context: &'a CrateDebugContext = cx.dbg_cx().get_ref();\n+    let debug_context: &'a CrateDebugContext = cx.dbg_cx().as_ref().unwrap();\n     debug_context\n }\n \n #[inline]\n #[allow(non_snake_case)]\n fn DIB(cx: &CrateContext) -> DIBuilderRef {\n-    cx.dbg_cx().get_ref().builder\n+    cx.dbg_cx().as_ref().unwrap().builder\n }\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n@@ -3576,7 +3574,7 @@ fn populate_scope_map(cx: &CrateContext,\n                 // same binding names.\n \n                 for arm_ref in arms.iter() {\n-                    let arm_span = arm_ref.pats.get(0).span;\n+                    let arm_span = arm_ref.pats[0].span;\n \n                     with_new_scope(cx,\n                                    arm_span,\n@@ -3671,22 +3669,22 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n             push_type_params(cx, substs, output);\n         },\n         ty::ty_tup(ref component_types) => {\n-            output.push_char('(');\n+            output.push('(');\n             for &component_type in component_types.iter() {\n                 push_debuginfo_type_name(cx, component_type, true, output);\n                 output.push_str(\", \");\n             }\n-            output.pop_char();\n-            output.pop_char();\n-            output.push_char(')');\n+            output.pop();\n+            output.pop();\n+            output.push(')');\n         },\n         ty::ty_uniq(inner_type) => {\n             output.push_str(\"Box<\");\n             push_debuginfo_type_name(cx, inner_type, true, output);\n-            output.push_char('>');\n+            output.push('>');\n         },\n         ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n-            output.push_char('*');\n+            output.push('*');\n             match mutbl {\n                 ast::MutImmutable => output.push_str(\"const \"),\n                 ast::MutMutable => output.push_str(\"mut \"),\n@@ -3695,15 +3693,15 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n             push_debuginfo_type_name(cx, inner_type, true, output);\n         },\n         ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n-            output.push_char('&');\n+            output.push('&');\n             if mutbl == ast::MutMutable {\n                 output.push_str(\"mut \");\n             }\n \n             push_debuginfo_type_name(cx, inner_type, true, output);\n         },\n         ty::ty_vec(inner_type, optional_length) => {\n-            output.push_char('[');\n+            output.push('[');\n             push_debuginfo_type_name(cx, inner_type, true, output);\n \n             match optional_length {\n@@ -3713,7 +3711,7 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                 None => { /* nothing to do */ }\n             };\n \n-            output.push_char(']');\n+            output.push(']');\n         },\n         ty::ty_trait(ref trait_data) => {\n             push_item_name(cx, trait_data.def_id, false, output);\n@@ -3737,8 +3735,8 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n-                output.pop_char();\n-                output.pop_char();\n+                output.pop();\n+                output.pop();\n             }\n \n             if sig.variadic {\n@@ -3749,7 +3747,7 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                 }\n             }\n \n-            output.push_char(')');\n+            output.push(')');\n \n             if !ty::type_is_nil(sig.output) {\n                 output.push_str(\" -> \");\n@@ -3791,8 +3789,8 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n-                output.pop_char();\n-                output.pop_char();\n+                output.pop();\n+                output.pop();\n             }\n \n             if sig.variadic {\n@@ -3803,7 +3801,7 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                 }\n             }\n \n-            output.push_char(param_list_closing_char);\n+            output.push(param_list_closing_char);\n \n             if !ty::type_is_nil(sig.output) {\n                 output.push_str(\" -> \");\n@@ -3845,8 +3843,8 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                     cx.sess().bug(\"debuginfo: Encountered empty item path!\");\n                 }\n \n-                output.pop_char();\n-                output.pop_char();\n+                output.pop();\n+                output.pop();\n             } else {\n                 let name = token::get_name(path.last()\n                                                .expect(\"debuginfo: Empty item path?\")\n@@ -3868,17 +3866,17 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n             return;\n         }\n \n-        output.push_char('<');\n+        output.push('<');\n \n         for &type_parameter in substs.types.iter() {\n             push_debuginfo_type_name(cx, type_parameter, true, output);\n             output.push_str(\", \");\n         }\n \n-        output.pop_char();\n-        output.pop_char();\n+        output.pop();\n+        output.pop();\n \n-        output.push_char('>');\n+        output.push('>');\n     }\n }\n \n@@ -3909,7 +3907,7 @@ impl NamespaceTreeNode {\n         fill_nested(self, &mut name);\n         name.push_str(format!(\"{}\", item_name.len()).as_slice());\n         name.push_str(item_name);\n-        name.push_char('E');\n+        name.push('E');\n         name\n     }\n }"}, {"sha": "d638286a9c5bd9244db04f8bcfcc5bb04c7d6d8d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -1079,7 +1079,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n-                                      &**args.get(0),\n+                                      &*args[0],\n                                       callee::ArgExprs(args.as_slice()),\n                                       dest)\n         }\n@@ -1787,7 +1787,7 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    rhs: Vec<(Datum<Expr>, ast::NodeId)>,\n                                    dest: Option<Dest>)\n                                    -> Result<'blk, 'tcx> {\n-    let method_ty = bcx.tcx().method_map.borrow().get(&method_call).ty;\n+    let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n     callee::trans_call_inner(bcx,\n                              Some(expr_info(expr)),\n                              monomorphize_type(bcx, method_ty),\n@@ -1808,11 +1808,10 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                          dest: Option<Dest>)\n                                          -> Block<'blk, 'tcx> {\n     let method_call = MethodCall::expr(expr.id);\n-    let method_type = bcx.tcx()\n-                         .method_map\n-                         .borrow()\n-                         .get(&method_call)\n-                         .ty;\n+    let method_type = (*bcx.tcx()\n+                           .method_map\n+                           .borrow())[method_call]\n+                           .ty;\n     let mut all_args = vec!(callee);\n     all_args.extend(args.iter().map(|e| &**e));\n     unpack_result!(bcx,"}, {"sha": "406ccc56a62389c017d62b609db73812d299940a", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -321,8 +321,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         // Does Rust pass this argument by pointer?\n-        let rust_indirect = type_of::arg_is_indirect(ccx,\n-                                                     *passed_arg_tys.get(i));\n+        let rust_indirect = type_of::arg_is_indirect(ccx, passed_arg_tys[i]);\n \n         debug!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n                i,\n@@ -335,9 +334,9 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         if !rust_indirect {\n             let scratch =\n                 base::alloca(bcx,\n-                             type_of::type_of(ccx, *passed_arg_tys.get(i)),\n+                             type_of::type_of(ccx, passed_arg_tys[i]),\n                              \"__arg\");\n-            base::store_ty(bcx, llarg_rust, scratch, *passed_arg_tys.get(i));\n+            base::store_ty(bcx, llarg_rust, scratch, passed_arg_tys[i]);\n             llarg_rust = scratch;\n         }\n \n@@ -358,7 +357,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let llarg_foreign = if foreign_indirect {\n             llarg_rust\n         } else {\n-            if ty::type_is_bool(*passed_arg_tys.get(i)) {\n+            if ty::type_is_bool(passed_arg_tys[i]) {\n                 let val = LoadRangeAssert(bcx, llarg_rust, 0, 2, llvm::False);\n                 Trunc(bcx, val, Type::i1(bcx.ccx()))\n             } else {\n@@ -746,10 +745,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         // Careful to adapt for cases where the native convention uses\n         // a pointer and Rust does not or vice versa.\n         for i in range(0, tys.fn_sig.inputs.len()) {\n-            let rust_ty = *tys.fn_sig.inputs.get(i);\n-            let llrust_ty = *tys.llsig.llarg_tys.get(i);\n+            let rust_ty = tys.fn_sig.inputs[i];\n+            let llrust_ty = tys.llsig.llarg_tys[i];\n             let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n-            let llforeign_arg_ty = *tys.fn_ty.arg_tys.get(i);\n+            let llforeign_arg_ty = tys.fn_ty.arg_tys[i];\n             let foreign_indirect = llforeign_arg_ty.is_indirect();\n \n             if llforeign_arg_ty.is_ignore() {"}, {"sha": "8fc3426e372996d48105a81a171dd9a650ef2f02", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -262,9 +262,9 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   // use the fake info.\n                   info.unwrap_or(C_null(Type::i8p(bcx.ccx()))),\n                   GEPi(bcx, scratch.val, [0, abi::slice_elt_len]));\n-            PointerCast(variant_cx, scratch.val, *params.get(0))\n+            PointerCast(variant_cx, scratch.val, params[0])\n         } else {\n-            PointerCast(variant_cx, value, *params.get(0))\n+            PointerCast(variant_cx, value, params[0])\n         };\n         let args = vec!(self_arg);\n "}, {"sha": "e81844efad30ccac238046637ac3df8c3fe0b60e", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -259,11 +259,11 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let mode = appropriate_rvalue_mode(ccx, tp_ty);\n             let src = Datum {\n-                val: *llargs.get(1),\n+                val: llargs[1],\n                 ty: tp_ty,\n                 kind: Rvalue::new(mode)\n             };\n-            bcx = src.store_to(bcx, *llargs.get(0));\n+            bcx = src.store_to(bcx, llargs[0]);\n             C_nil(ccx)\n         }\n         (_, \"get_tydesc\") => {\n@@ -307,130 +307,130 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n             C_bool(ccx, ty::type_contents(ccx.tcx(), tp_ty).owns_managed())\n         }\n         (_, \"offset\") => {\n-            let ptr = *llargs.get(0);\n-            let offset = *llargs.get(1);\n+            let ptr = llargs[0];\n+            let offset = llargs[1];\n             InBoundsGEP(bcx, ptr, [offset])\n         }\n \n         (_, \"copy_nonoverlapping_memory\") => {\n             copy_intrinsic(bcx, false, false, *substs.types.get(FnSpace, 0),\n-                           *llargs.get(0), *llargs.get(1), *llargs.get(2))\n+                           llargs[0], llargs[1], llargs[2])\n         }\n         (_, \"copy_memory\") => {\n             copy_intrinsic(bcx, true, false, *substs.types.get(FnSpace, 0),\n-                           *llargs.get(0), *llargs.get(1), *llargs.get(2))\n+                           llargs[0], llargs[1], llargs[2])\n         }\n         (_, \"set_memory\") => {\n             memset_intrinsic(bcx, false, *substs.types.get(FnSpace, 0),\n-                             *llargs.get(0), *llargs.get(1), *llargs.get(2))\n+                             llargs[0], llargs[1], llargs[2])\n         }\n \n         (_, \"volatile_copy_nonoverlapping_memory\") => {\n             copy_intrinsic(bcx, false, true, *substs.types.get(FnSpace, 0),\n-                           *llargs.get(0), *llargs.get(1), *llargs.get(2))\n+                           llargs[0], llargs[1], llargs[2])\n         }\n         (_, \"volatile_copy_memory\") => {\n             copy_intrinsic(bcx, true, true, *substs.types.get(FnSpace, 0),\n-                           *llargs.get(0), *llargs.get(1), *llargs.get(2))\n+                           llargs[0], llargs[1], llargs[2])\n         }\n         (_, \"volatile_set_memory\") => {\n             memset_intrinsic(bcx, true, *substs.types.get(FnSpace, 0),\n-                             *llargs.get(0), *llargs.get(1), *llargs.get(2))\n+                             llargs[0], llargs[1], llargs[2])\n         }\n         (_, \"volatile_load\") => {\n-            VolatileLoad(bcx, *llargs.get(0))\n+            VolatileLoad(bcx, llargs[0])\n         },\n         (_, \"volatile_store\") => {\n-            VolatileStore(bcx, *llargs.get(1), *llargs.get(0));\n+            VolatileStore(bcx, llargs[1], llargs[0]);\n             C_nil(ccx)\n         },\n \n-        (_, \"ctlz8\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\", *llargs.get(0)),\n-        (_, \"ctlz16\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\", *llargs.get(0)),\n-        (_, \"ctlz32\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\", *llargs.get(0)),\n-        (_, \"ctlz64\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\", *llargs.get(0)),\n-        (_, \"cttz8\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\", *llargs.get(0)),\n-        (_, \"cttz16\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\", *llargs.get(0)),\n-        (_, \"cttz32\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\", *llargs.get(0)),\n-        (_, \"cttz64\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\", *llargs.get(0)),\n+        (_, \"ctlz8\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\", llargs[0]),\n+        (_, \"ctlz16\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\", llargs[0]),\n+        (_, \"ctlz32\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\", llargs[0]),\n+        (_, \"ctlz64\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\", llargs[0]),\n+        (_, \"cttz8\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\", llargs[0]),\n+        (_, \"cttz16\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\", llargs[0]),\n+        (_, \"cttz32\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\", llargs[0]),\n+        (_, \"cttz64\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\", llargs[0]),\n \n         (_, \"i8_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i8\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i16_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i16\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i32_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i32\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i64_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i64\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n \n         (_, \"u8_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i8\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"u16_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i16\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"u32_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i32\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"u64_add_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i64\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n \n         (_, \"i8_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i8\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i16_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i16\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i32_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i32\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i64_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i64\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n \n         (_, \"u8_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i8\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"u16_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i16\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"u32_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i32\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"u64_sub_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i64\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n \n         (_, \"i8_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i8\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i16_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i16\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i32_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i32\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n         (_, \"i64_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i64\", ret_ty,\n-                                   *llargs.get(0), *llargs.get(1)),\n+                                   llargs[0], llargs[1]),\n \n         (_, \"u8_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i8\", ret_ty,\n-                                    *llargs.get(0), *llargs.get(1)),\n+                                    llargs[0], llargs[1]),\n         (_, \"u16_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i16\", ret_ty,\n-                                    *llargs.get(0), *llargs.get(1)),\n+                                    llargs[0], llargs[1]),\n         (_, \"u32_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i32\", ret_ty,\n-                                    *llargs.get(0), *llargs.get(1)),\n+                                    llargs[0], llargs[1]),\n         (_, \"u64_mul_with_overflow\") =>\n             with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i64\", ret_ty,\n-                                    *llargs.get(0), *llargs.get(1)),\n+                                    llargs[0], llargs[1]),\n \n         (_, \"return_address\") => {\n             if !fcx.caller_expects_out_pointer {\n@@ -452,7 +452,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n             let order = if split.len() == 2 {\n                 llvm::SequentiallyConsistent\n             } else {\n-                match *split.get(2) {\n+                match split[2] {\n                     \"relaxed\" => llvm::Monotonic,\n                     \"acq\"     => llvm::Acquire,\n                     \"rel\"     => llvm::Release,\n@@ -461,7 +461,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n                 }\n             };\n \n-            match *split.get(1) {\n+            match split[1] {\n                 \"cxchg\" => {\n                     // See include/llvm/IR/Instructions.h for their implementation\n                     // of this, I assume that it's good enough for us to use for\n@@ -480,8 +480,8 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n                             llvm::SequentiallyConsistent\n                     };\n \n-                    let res = AtomicCmpXchg(bcx, *llargs.get(0), *llargs.get(1),\n-                                            *llargs.get(2), order,\n+                    let res = AtomicCmpXchg(bcx, llargs[0], llargs[1],\n+                                            llargs[2], order,\n                                             strongest_failure_ordering);\n                     if unsafe { llvm::LLVMVersionMinor() >= 5 } {\n                         ExtractValue(bcx, res, 0)\n@@ -491,10 +491,10 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n                 }\n \n                 \"load\" => {\n-                    AtomicLoad(bcx, *llargs.get(0), order)\n+                    AtomicLoad(bcx, llargs[0], order)\n                 }\n                 \"store\" => {\n-                    AtomicStore(bcx, *llargs.get(1), *llargs.get(0), order);\n+                    AtomicStore(bcx, llargs[1], llargs[0], order);\n                     C_nil(ccx)\n                 }\n \n@@ -520,7 +520,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    AtomicRMW(bcx, atom_op, *llargs.get(0), *llargs.get(1), order)\n+                    AtomicRMW(bcx, atom_op, llargs[0], llargs[1], order)\n                 }\n             }\n "}, {"sha": "fef2ead9883d135dcef457d1b80f544a0ea7627c", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -718,7 +718,7 @@ fn emit_vtable_methods(bcx: Block,\n                     debug!(\"(making impl vtable) method has self or type \\\n                             params: {}\",\n                            token::get_ident(ident));\n-                    Some(C_null(Type::nil(ccx).ptr_to())).move_iter()\n+                    Some(C_null(Type::nil(ccx).ptr_to())).into_iter()\n                 } else {\n                     let mut fn_ref = trans_fn_ref_with_substs(\n                         bcx,\n@@ -732,11 +732,11 @@ fn emit_vtable_methods(bcx: Block,\n                                                      m_id,\n                                                      substs.clone());\n                     }\n-                    Some(fn_ref).move_iter()\n+                    Some(fn_ref).into_iter()\n                 }\n             }\n             ty::TypeTraitItem(_) => {\n-                None.move_iter()\n+                None.into_iter()\n             }\n         }\n     }).collect()"}, {"sha": "dbaebd07b0220ffc05f25398129f791ddfdece2b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -2042,7 +2042,7 @@ pub fn simd_type(cx: &ctxt, ty: t) -> t {\n     match get(ty).sty {\n         ty_struct(did, ref substs) => {\n             let fields = lookup_struct_fields(cx, did);\n-            lookup_field_type(cx, did, fields.get(0).id, substs)\n+            lookup_field_type(cx, did, fields[0].id, substs)\n         }\n         _ => fail!(\"simd_type called on invalid type\")\n     }\n@@ -2501,12 +2501,12 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                             if variants.len() == 2 {\n                                 let mut data_idx = 0;\n \n-                                if variants.get(0).args.len() == 0 {\n+                                if variants[0].args.len() == 0 {\n                                     data_idx = 1;\n                                 }\n \n-                                if variants.get(data_idx).args.len() == 1 {\n-                                    match get(*variants.get(data_idx).args.get(0)).sty {\n+                                if variants[data_idx].args.len() == 1 {\n+                                    match get(variants[data_idx].args[0]).sty {\n                                         ty_bare_fn(..) => { res = res - TC::ReachesFfiUnsafe; }\n                                         _ => { }\n                                     }\n@@ -2530,7 +2530,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 assert_eq!(p.def_id.krate, ast::LOCAL_CRATE);\n \n                 let ty_param_defs = cx.ty_param_defs.borrow();\n-                let tp_def = ty_param_defs.get(&p.def_id.node);\n+                let tp_def = &(*ty_param_defs)[p.def_id.node];\n                 kind_bounds_to_contents(\n                     cx,\n                     tp_def.bounds.builtin_bounds,\n@@ -4032,8 +4032,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n \n pub fn trait_item(cx: &ctxt, trait_did: ast::DefId, idx: uint)\n                   -> ImplOrTraitItem {\n-    let method_def_id = ty::trait_item_def_ids(cx, trait_did).get(idx)\n-                                                             .def_id();\n+    let method_def_id = (*ty::trait_item_def_ids(cx, trait_did))[idx].def_id();\n     impl_or_trait_item(cx, method_def_id)\n }\n "}, {"sha": "d29720e1a1a95553278348f64f2a7079402095a9", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -156,7 +156,7 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                         Some(v) => {\n                             let mut m = String::new();\n                             let len = v.len();\n-                            for (i, (name, n)) in v.move_iter().enumerate() {\n+                            for (i, (name, n)) in v.into_iter().enumerate() {\n                                 m.push_str(if n == 1 {\n                                     format!(\"`{}`\", name)\n                                 } else {\n@@ -194,9 +194,7 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     ty::ReStatic\n                 }\n \n-                Ok(rs) => {\n-                    *rs.get(0)\n-                }\n+                Ok(rs) => rs[0],\n             }\n         }\n     };\n@@ -1251,7 +1249,7 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n                         self_info.explicit_self.span,\n                         self_info.untransformed_self_ty,\n                         tm.ty,\n-                        || \"not a valid type for `self`\".to_owned());\n+                        || \"not a valid type for `self`\".to_string());\n                     return ty::ByReferenceExplicitSelfCategory(region,\n                                                                tm.mutbl)\n                 }\n@@ -1263,7 +1261,7 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n                         self_info.explicit_self.span,\n                         self_info.untransformed_self_ty,\n                         typ,\n-                        || \"not a valid type for `self`\".to_owned());\n+                        || \"not a valid type for `self`\".to_string());\n                     return ty::ByBoxExplicitSelfCategory\n                 }\n                 _ => {\n@@ -1301,7 +1299,7 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n             // no guarantee that the correct number of expected args\n             // were supplied\n             if i < e.inputs.len() {\n-                Some(*e.inputs.get(i))\n+                Some(e.inputs[i])\n             } else {\n                 None\n             }\n@@ -1357,7 +1355,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n         partition_bounds(this.tcx(), span, ast_bound_refs.as_slice());\n \n     if !trait_bounds.is_empty() {\n-        let b = trait_bounds.get(0);\n+        let b = &trait_bounds[0];\n         this.tcx().sess.span_err(\n             b.path.span,\n             format!(\"only the builtin traits can be used \\\n@@ -1453,7 +1451,7 @@ pub fn compute_opt_region_bound(tcx: &ty::ctxt,\n     // Determine whether there is exactly one unique region in the set\n     // of derived region bounds. If so, use that. Otherwise, report an\n     // error.\n-    let r = *derived_region_bounds.get(0);\n+    let r = derived_region_bounds[0];\n     if derived_region_bounds.slice_from(1).iter().any(|r1| r != *r1) {\n         tcx.sess.span_err(\n             span,"}, {"sha": "455300ecd3bad5fcdfa7d4c5607f5184ee1ed263", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -45,7 +45,7 @@ pub fn check_match(fcx: &FnCtxt,\n     for arm in arms.iter() {\n         let mut pcx = pat_ctxt {\n             fcx: fcx,\n-            map: pat_id_map(&tcx.def_map, &**arm.pats.get(0)),\n+            map: pat_id_map(&tcx.def_map, &*arm.pats[0]),\n         };\n \n         for p in arm.pats.iter() { check_pat(&mut pcx, &**p, discrim_ty);}\n@@ -322,7 +322,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n             }\n             Some(&(index, ref mut used)) => {\n                 *used = true;\n-                let class_field = class_fields.get(index).clone();\n+                let class_field = class_fields[index].clone();\n                 let field_type = ty::lookup_field_type(tcx,\n                                                        class_id,\n                                                        class_field.id,\n@@ -496,7 +496,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n           }\n         }\n \n-        let canon_id = *pcx.map.get(&path1.node);\n+        let canon_id = pcx.map[path1.node];\n         if canon_id != pat.id {\n             let ct = fcx.local_ty(pat.span, canon_id);\n             demand::eqtype(fcx, pat.span, ct, typ);\n@@ -528,7 +528,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         match *structure {\n             ty::ty_struct(cid, ref substs) => {\n                 // Verify that the pattern named the right structure.\n-                let item_did = tcx.def_map.borrow().get(&pat.id).def_id();\n+                let item_did = (*tcx.def_map.borrow())[pat.id].def_id();\n                 match ty::ty_to_def_id(ty::lookup_item_type(tcx, item_did).ty) {\n                     Some(struct_did) if struct_did != cid => {\n                         span_err!(tcx.sess, path.span, E0032,\n@@ -599,7 +599,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         match *s {\n             ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n                 for (i, elt) in elts.iter().enumerate() {\n-                    check_pat(pcx, &**elt, *ex_elts.get(i));\n+                    check_pat(pcx, &**elt, ex_elts[i]);\n                 }\n                 fcx.write_ty(pat.id, expected);\n             }"}, {"sha": "798e4acd2910ec0fa5d79c49a3fe7bf426f9e951", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -276,7 +276,7 @@ fn construct_transformed_self_ty_for_object(\n             ty::mk_uniq(tcx, tr)\n         }\n         ByReferenceExplicitSelfCategory(..) | ByBoxExplicitSelfCategory => {\n-            let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n+            let transformed_self_ty = method_ty.fty.sig.inputs[0];\n             match ty::get(transformed_self_ty).sty {\n                 ty::ty_rptr(r, mt) => { // must be SelfRegion\n                     let r = r.subst(tcx, rcvr_substs); // handle Early-Bound lifetime\n@@ -490,7 +490,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         let impl_items = self.tcx().impl_items.borrow();\n         for impl_infos in self.tcx().trait_impls.borrow().find(&trait_did).iter() {\n             for impl_did in impl_infos.borrow().iter() {\n-                let items = impl_items.get(impl_did);\n+                let items = &(*impl_items)[*impl_did];\n                 self.push_candidates_from_impl(*impl_did,\n                                                items.as_slice(),\n                                                true);\n@@ -521,7 +521,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             trait_did: DefId,\n             closure_did: DefId,\n             closure_function_type: &ClosureTy) {\n-        let trait_item = ty::trait_items(self.tcx(), trait_did).get(0)\n+        let trait_item = (*ty::trait_items(self.tcx(), trait_did))[0]\n                                                                .clone();\n         let method = match trait_item {\n             ty::MethodTraitItem(method) => method,\n@@ -538,7 +538,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n \n         // Get the tupled type of the arguments.\n-        let arguments_type = *closure_function_type.sig.inputs.get(0);\n+        let arguments_type = closure_function_type.sig.inputs[0];\n         let return_type = closure_function_type.sig.output;\n \n         let closure_region =\n@@ -552,7 +552,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             rcvr_substs: subst::Substs::new_trait(\n                 vec![arguments_type, return_type],\n                 vec![],\n-                *self.fcx.infcx().next_ty_vars(1).get(0)),\n+                self.fcx.infcx().next_ty_vars(1)[0]),\n             method_ty: method,\n             origin: MethodStaticUnboxedClosure(closure_did),\n         });\n@@ -733,7 +733,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 }\n             }) {\n                 Some(pos) => {\n-                    let method = match *trait_items.get(pos) {\n+                    let method = match (*trait_items)[pos] {\n                         ty::MethodTraitItem(ref method) => (*method).clone(),\n                         ty::TypeTraitItem(_) => {\n                             tcx.sess.bug(\"typechecking associated type as \\\n@@ -771,7 +771,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         let impl_items = self.tcx().impl_items.borrow();\n         for impl_infos in self.tcx().inherent_impls.borrow().find(&did).iter() {\n             for impl_did in impl_infos.iter() {\n-                let items = impl_items.get(impl_did);\n+                let items = &(*impl_items)[*impl_did];\n                 self.push_candidates_from_impl(*impl_did,\n                                                items.as_slice(),\n                                                false);\n@@ -1211,7 +1211,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n             // return something so we don't get errors for every mutability\n             return Some(MethodCallee {\n-                origin: relevant_candidates.get(0).origin.clone(),\n+                origin: relevant_candidates[0].origin.clone(),\n                 ty: ty::mk_err(),\n                 substs: subst::Substs::empty()\n             });\n@@ -1225,7 +1225,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             }\n         }\n \n-        Some(self.confirm_candidate(rcvr_ty, relevant_candidates.get(0)))\n+        Some(self.confirm_candidate(rcvr_ty, &relevant_candidates[0]))\n     }\n \n     fn filter_candidates(&self, rcvr_ty: ty::t, candidates: &[Candidate]) -> Vec<Candidate> {\n@@ -1299,7 +1299,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     \"incorrect number of type parameters given for this method\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else {\n-                Vec::from_slice(self.supplied_tps)\n+                self.supplied_tps.to_vec()\n             }\n         };\n \n@@ -1329,7 +1329,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 let args = fn_sig.inputs.slice_from(1).iter().map(|t| {\n                     t.subst(tcx, &all_substs)\n                 });\n-                Some(*fn_sig.inputs.get(0)).into_iter().chain(args).collect()\n+                Some(fn_sig.inputs[0]).into_iter().chain(args).collect()\n             }\n             _ => fn_sig.inputs.subst(tcx, &all_substs)\n         };\n@@ -1348,7 +1348,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             tcx, &fn_sig,\n             |br| self.fcx.infcx().next_region_var(\n                 infer::LateBoundRegion(self.span, br)));\n-        let transformed_self_ty = *fn_sig.inputs.get(0);\n+        let transformed_self_ty = fn_sig.inputs[0];\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n             fn_style: bare_fn_ty.fn_style,\n@@ -1394,7 +1394,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             _ => return,\n         };\n \n-        match ty::get(*sig.inputs.get(0)).sty {\n+        match ty::get(sig.inputs[0]).sty {\n             ty::ty_rptr(_, ty::mt {\n                 ty: _,\n                 mutbl: ast::MutMutable,"}, {"sha": "4aea9cfa293d3755cb41d773b45a800f8f0e6df6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -1056,8 +1056,8 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     let trait_to_skol_substs =\n         trait_to_impl_substs\n         .subst(tcx, &impl_to_skol_substs)\n-        .with_method(Vec::from_slice(skol_tps.get_slice(subst::FnSpace)),\n-                     Vec::from_slice(skol_regions.get_slice(subst::FnSpace)));\n+        .with_method(skol_tps.get_slice(subst::FnSpace).to_vec(),\n+                     skol_regions.get_slice(subst::FnSpace).to_vec());\n \n     // Check region bounds.\n     if !check_region_bounds_on_impl_method(tcx,\n@@ -2598,7 +2598,7 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n \n             if is_block == check_blocks {\n                 debug!(\"checking the argument\");\n-                let mut formal_ty = *formal_tys.get(i);\n+                let mut formal_ty = formal_tys[i];\n \n                 match deref_args {\n                     DoDerefArgs => {\n@@ -3301,7 +3301,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 fcx.ccx.tcx.sess.span_bug(expr.span,\n                                           \"can't make anon regions here?!\")\n             }\n-            Ok(regions) => *regions.get(0),\n+            Ok(regions) => regions[0],\n         };\n         let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n                                                   local_def(expr.id),\n@@ -3643,7 +3643,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 let mut missing_fields = Vec::new();\n                 for class_field in field_types.iter() {\n                     let name = class_field.name;\n-                    let (_, seen) = *class_field_map.get(&name);\n+                    let (_, seen) = class_field_map[name];\n                     if !seen {\n                         missing_fields.push(\n                             format!(\"`{}`\", token::get_name(name).get()))\n@@ -3871,7 +3871,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                     ty::ty_struct(did, ref substs) => {\n                                         let fields = ty::struct_fields(fcx.tcx(), did, substs);\n                                         fields.len() == 1\n-                                        && fields.get(0).ident ==\n+                                        && fields[0].ident ==\n                                         token::special_idents::unnamed_field\n                                     }\n                                     _ => false\n@@ -4258,7 +4258,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let elt_ts = elts.iter().enumerate().map(|(i, e)| {\n             let t = match flds {\n                 Some(ref fs) if i < fs.len() => {\n-                    let ety = *fs.get(i);\n+                    let ety = fs[i];\n                     check_expr_coercable_to_type(fcx, &**e, ety);\n                     ety\n                 }\n@@ -4763,7 +4763,7 @@ pub fn check_const(ccx: &CrateCtxt,\n     let inh = static_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, &inh, rty, e.id);\n-    let declty = fcx.ccx.tcx.tcache.borrow().get(&local_def(id)).ty;\n+    let declty = (*fcx.ccx.tcx.tcache.borrow())[local_def(id)].ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n \n@@ -4853,7 +4853,7 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n                 return;\n             }\n-            let e = ty::lookup_field_type(tcx, did, fields.get(0).id, substs);\n+            let e = ty::lookup_field_type(tcx, did, fields[0].id, substs);\n             if !fields.iter().all(\n                          |f| ty::lookup_field_type(tcx, did, f.id, substs) == e) {\n                 span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\");\n@@ -5514,7 +5514,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n         //We only care about the operation here\n-        match *split.get(1) {\n+        match split[1] {\n             \"cxchg\" => (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)),\n                                 param(ccx, 0),\n                                 param(ccx, 0)),"}, {"sha": "76074120c0edb27d0cba7141e08926a419f19f7e", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -641,7 +641,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMethodCall(_, _, ref args) => {\n-            constrain_call(rcx, expr, Some(&**args.get(0)),\n+            constrain_call(rcx, expr, Some(&*args[0]),\n                            args.slice_from(1).iter().map(|e| &**e), false);\n \n             visit::walk_expr(rcx, expr);\n@@ -1200,7 +1200,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = ty::ty_fn_sig(method.ty);\n-                let self_ty = *fn_sig.inputs.get(0);\n+                let self_ty = fn_sig.inputs[0];\n                 let (m, r) = match ty::get(self_ty).sty {\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                     _ => rcx.tcx().sess.span_bug(deref_expr.span,"}, {"sha": "7906e0101ee16d1acb3804f31248571fc1f7d4f7", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -434,12 +434,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         };\n \n         for &impl_did in trait_impls.borrow().iter() {\n-            let items = impl_items.get(&impl_did);\n+            let items = &(*impl_items)[impl_did];\n             if items.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;\n             }\n-            let method_def_id = *items.get(0);\n+            let method_def_id = items[0];\n \n             let self_type = self.get_self_type_for_implementation(impl_did);\n             match ty::get(self_type.ty).sty {\n@@ -524,10 +524,10 @@ fn subst_receiver_types_in_method_ty(tcx: &ty::ctxt,\n     for &space in [subst::TypeSpace, subst::SelfSpace].iter() {\n         method_generics.types.replace(\n             space,\n-            Vec::from_slice(impl_poly_type.generics.types.get_slice(space)));\n+            impl_poly_type.generics.types.get_slice(space).to_vec());\n         method_generics.regions.replace(\n             space,\n-            Vec::from_slice(impl_poly_type.generics.regions.get_slice(space)));\n+            impl_poly_type.generics.regions.get_slice(space).to_vec());\n     }\n \n     debug!(\"subst_receiver_types_in_method_ty: method_generics={}\","}, {"sha": "2ffb90861bf3381b4d99078f149bcb7527d350f5", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -1298,11 +1298,11 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                 write_ty_to_tcx(tcx, ctor_id, selfty);\n \n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id), pty);\n-            } else if struct_def.fields.get(0).node.kind.is_unnamed() {\n+            } else if struct_def.fields[0].node.kind.is_unnamed() {\n                 // Tuple-like.\n                 let inputs: Vec<_> = struct_def.fields.iter().map(\n-                        |field| tcx.tcache.borrow().get(\n-                            &local_def(field.node.id)).ty).collect();\n+                        |field| (*tcx.tcache.borrow())[\n+                            local_def(field.node.id)].ty).collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n                                                 ctor_id,\n                                                 inputs.as_slice(),\n@@ -2124,8 +2124,8 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n                                      unboxed_fn_ty_bounds } =\n         astconv::partition_bounds(this.tcx(), span, all_bounds.as_slice());\n \n-    let unboxed_fn_ty_bounds = unboxed_fn_ty_bounds.move_iter().map(|b| {\n-        let trait_id = this.tcx().def_map.borrow().get(&b.ref_id).def_id();\n+    let unboxed_fn_ty_bounds = unboxed_fn_ty_bounds.into_iter().map(|b| {\n+        let trait_id = (*this.tcx().def_map.borrow())[b.ref_id].def_id();\n         let mut kind = None;\n         for &(lang_item, this_kind) in [\n             (this.tcx().lang_items.fn_trait(), ast::FnUnboxedClosureKind),\n@@ -2170,7 +2170,7 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n         .chain(unboxed_fn_ty_bounds)\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n-        region_bounds.move_iter()\n+        region_bounds.into_iter()\n         .map(|r| ast_region_to_region(this.tcx(), r))\n         .collect();\n     ty::ParamBounds {"}, {"sha": "15c4830646d593f440d954faf96794616e55086d", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -52,7 +52,6 @@ use middle::typeck::infer::type_variable::{RelationDir, EqTo,\n use middle::ty_fold::{TypeFoldable};\n use util::ppaux::Repr;\n \n-use std::result;\n \n use syntax::ast::{Onceness, FnStyle};\n use syntax::ast;\n@@ -89,11 +88,10 @@ pub trait Combine<'tcx> {\n                                                              bs.len())));\n         }\n \n-        try!(result::fold_(as_\n-                          .iter()\n-                          .zip(bs.iter())\n-                          .map(|(a, b)| self.equate().tys(*a, *b))));\n-        Ok(Vec::from_slice(as_))\n+        try!(as_.iter().zip(bs.iter())\n+                .map(|(a, b)| self.equate().tys(*a, *b))\n+                .collect::<cres<Vec<ty::t>>>());\n+        Ok(as_.to_vec())\n     }\n \n     fn substs(&self,\n@@ -342,8 +340,8 @@ pub fn super_fn_sigs<'tcx, C: Combine<'tcx>>(this: &C,\n                                        b_args: &[ty::t])\n                                        -> cres<Vec<ty::t>> {\n         if a_args.len() == b_args.len() {\n-            result::collect(a_args.iter().zip(b_args.iter())\n-                            .map(|(a, b)| this.args(*a, *b)))\n+            a_args.iter().zip(b_args.iter())\n+                  .map(|(a, b)| this.args(*a, *b)).collect()\n         } else {\n             Err(ty::terr_arg_count)\n         }\n@@ -537,9 +535,10 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n \n       (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {\n         if as_.len() == bs.len() {\n-            result::collect(as_.iter().zip(bs.iter())\n-                            .map(|(a, b)| this.tys(*a, *b)))\n-                    .and_then(|ts| Ok(ty::mk_tup(tcx, ts)) )\n+            as_.iter().zip(bs.iter())\n+               .map(|(a, b)| this.tys(*a, *b))\n+               .collect::<Result<_, _>>()\n+               .map(|ts| ty::mk_tup(tcx, ts))\n         } else {\n             Err(ty::terr_tuple_size(\n                 expected_found(this, as_.len(), bs.len())))"}, {"sha": "c3ed70f4cb7b1b357f09a313f6e38d3e0fdca533", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n             }\n         }\n         if !same_regions.is_empty() {\n-            let common_scope_id = same_regions.get(0).scope_id;\n+            let common_scope_id = same_regions[0].scope_id;\n             for sr in same_regions.iter() {\n                 // Since ProcessedErrors is used to reconstruct the function\n                 // declaration, we want to make sure that they are, in fact,\n@@ -1003,7 +1003,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::str_to_ident(names.get(0).as_slice()).name;\n+            let name = token::str_to_ident(names[0].as_slice()).name;\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1209,7 +1209,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         let mut new_ty = P(ty.clone());\n         let mut ty_queue = vec!(ty);\n         while !ty_queue.is_empty() {\n-            let cur_ty = ty_queue.shift().unwrap();\n+            let cur_ty = ty_queue.remove(0).unwrap();\n             match cur_ty.node {\n                 ast::TyRptr(lt_opt, ref mut_ty) => {\n                     let rebuild = match lt_opt {\n@@ -1768,7 +1768,7 @@ impl LifeGiver {\n             let (n, r) = (counter/26 + 1, counter % 26);\n             let letter: char = from_u32((r+97) as u32).unwrap();\n             for _ in range(0, n) {\n-                s.push_char(letter);\n+                s.push(letter);\n             }\n             s\n         }"}, {"sha": "b4704b2a27c97f5d959d16a6173b4e92399fd5e9", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -255,7 +255,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     pub fn commit(&self, snapshot: RegionSnapshot) {\n         debug!(\"RegionVarBindings: commit({})\", snapshot.length);\n         assert!(self.undo_log.borrow().len() > snapshot.length);\n-        assert!(*self.undo_log.borrow().get(snapshot.length) == OpenSnapshot);\n+        assert!((*self.undo_log.borrow())[snapshot.length] == OpenSnapshot);\n \n         let mut undo_log = self.undo_log.borrow_mut();\n         if snapshot.length == 0 {\n@@ -269,7 +269,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         debug!(\"RegionVarBindings: rollback_to({})\", snapshot);\n         let mut undo_log = self.undo_log.borrow_mut();\n         assert!(undo_log.len() > snapshot.length);\n-        assert!(*undo_log.get(snapshot.length) == OpenSnapshot);\n+        assert!((*undo_log)[snapshot.length] == OpenSnapshot);\n         while undo_log.len() > snapshot.length + 1 {\n             match undo_log.pop().unwrap() {\n                 OpenSnapshot => {\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         match *self.values.borrow() {\n             None => {\n                 self.tcx.sess.span_bug(\n-                    self.var_origins.borrow().get(rid.index).span(),\n+                    (*self.var_origins.borrow())[rid.index].span(),\n                     \"attempt to resolve region variable before values have \\\n                      been computed!\")\n             }\n@@ -608,7 +608,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let mut result_index = 0;\n         while result_index < result_set.len() {\n             // nb: can't use uint::range() here because result_set grows\n-            let r = *result_set.get(result_index);\n+            let r = result_set[result_index];\n             debug!(\"result_index={}, r={}\", result_index, r);\n \n             for undo_entry in\n@@ -636,13 +636,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                             ReFree(a), ReInfer(ReVar(b)));\n                     }\n                     &AddVerify(i) => {\n-                        match self.verifys.borrow().get(i) {\n-                            &VerifyRegSubReg(_, a, b) => {\n+                        match (*self.verifys.borrow())[i] {\n+                            VerifyRegSubReg(_, a, b) => {\n                                 consider_adding_bidirectional_edges(\n                                     &mut result_set, r,\n                                     a, b);\n                             }\n-                            &VerifyParamBound(_, _, a, ref bs) => {\n+                            VerifyParamBound(_, _, a, ref bs) => {\n                                 for &b in bs.iter() {\n                                     consider_adding_bidirectional_edges(\n                                         &mut result_set, r,\n@@ -727,7 +727,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n-                self.var_origins.borrow().get(v_id.index).span(),\n+                (*self.var_origins.borrow())[v_id.index].span(),\n                 format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {}, {}\",\n                         a,\n@@ -834,7 +834,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (ReInfer(ReVar(v_id)), _) |\n             (_, ReInfer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n-                    self.var_origins.borrow().get(v_id.index).span(),\n+                    (*self.var_origins.borrow())[v_id.index].span(),\n                     format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {}, {}\",\n                             a,\n@@ -1269,7 +1269,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     if opt_graph.is_none() {\n                         opt_graph = Some(self.construct_graph());\n                     }\n-                    let graph = opt_graph.get_ref();\n+                    let graph = opt_graph.as_ref().unwrap();\n \n                     let node_vid = RegionVid { index: idx };\n                     match var_data[idx].classification {\n@@ -1370,7 +1370,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n                     errors.push(SubSupConflict(\n-                        self.var_origins.borrow().get(node_idx.index).clone(),\n+                        (*self.var_origins.borrow())[node_idx.index].clone(),\n                         lower_bound.origin.clone(),\n                         lower_bound.region,\n                         upper_bound.origin.clone(),\n@@ -1381,7 +1381,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         self.tcx.sess.span_bug(\n-            self.var_origins.borrow().get(node_idx.index).span(),\n+            (*self.var_origins.borrow())[node_idx.index].span(),\n             format!(\"collect_error_for_expanding_node() could not find error \\\n                     for var {}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n@@ -1414,7 +1414,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                   Ok(_) => {}\n                   Err(_) => {\n                     errors.push(SupSupConflict(\n-                        self.var_origins.borrow().get(node_idx.index).clone(),\n+                        (*self.var_origins.borrow())[node_idx.index].clone(),\n                         upper_bound_1.origin.clone(),\n                         upper_bound_1.region,\n                         upper_bound_2.origin.clone(),\n@@ -1426,7 +1426,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         self.tcx.sess.span_bug(\n-            self.var_origins.borrow().get(node_idx.index).span(),\n+            (*self.var_origins.borrow())[node_idx.index].span(),\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {}, upper_bounds={}\",\n                     node_idx,\n@@ -1578,7 +1578,7 @@ fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n }\n \n fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n-    match *values.get(rid.index) {\n+    match values[rid.index] {\n         Value(r) => r,\n         NoValue => ReEmpty, // No constraints, return ty::ReEmpty\n         ErrorValue => ReStatic, // Previously reported error."}, {"sha": "20e550f3f306c62b82da10d7d0195d9b180ec9ba", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -657,7 +657,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             // variance not yet inferred, so return a symbolic\n             // variance.\n             let InferredIndex(index) = self.inferred_index(param_def_id.node);\n-            self.terms_cx.inferred_infos.get(index).term\n+            self.terms_cx.inferred_infos[index].term\n         } else {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n@@ -980,15 +980,14 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 let Constraint { inferred, variance: term } = *constraint;\n                 let InferredIndex(inferred) = inferred;\n                 let variance = self.evaluate(term);\n-                let old_value = *self.solutions.get(inferred);\n+                let old_value = self.solutions[inferred];\n                 let new_value = glb(variance, old_value);\n                 if old_value != new_value {\n                     debug!(\"Updating inferred {} (node {}) \\\n                             from {} to {} due to {}\",\n                             inferred,\n                             self.terms_cx\n-                                .inferred_infos\n-                                .get(inferred)\n+                                .inferred_infos[inferred]\n                                 .param_id,\n                             old_value,\n                             new_value,\n@@ -1017,14 +1016,14 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n         let mut index = 0;\n         let num_inferred = self.terms_cx.num_inferred();\n         while index < num_inferred {\n-            let item_id = inferred_infos.get(index).item_id;\n+            let item_id = inferred_infos[index].item_id;\n             let mut types = VecPerParamSpace::empty();\n             let mut regions = VecPerParamSpace::empty();\n \n             while index < num_inferred &&\n-                  inferred_infos.get(index).item_id == item_id {\n-                let info = inferred_infos.get(index);\n-                let variance = *solutions.get(index);\n+                  inferred_infos[index].item_id == item_id {\n+                let info = inferred_infos[index];\n+                let variance = solutions[index];\n                 debug!(\"Index {} Info {} / {} / {} Variance {}\",\n                        index, info.index, info.kind, info.space, variance);\n                 match info.kind {\n@@ -1074,7 +1073,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             }\n \n             InferredTerm(InferredIndex(index)) => {\n-                *self.solutions.get(index)\n+                self.solutions[index]\n             }\n         }\n     }"}, {"sha": "921cd7a4107c91bb0da52e07c7292e8fcc5c084d", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -77,8 +77,8 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n         Some(addl_plugins) => {\n             // Add in the additional plugins requested by the frontend\n             let Plugins { macros: addl_macros, registrars: addl_registrars } = addl_plugins;\n-            plugins.macros.push_all_move(addl_macros);\n-            plugins.registrars.push_all_move(addl_registrars);\n+            plugins.macros.extend(addl_macros.into_iter());\n+            plugins.registrars.extend(addl_registrars.into_iter());\n         }\n         None => ()\n     }"}, {"sha": "ed38f6f871d792792056d71a236690daa391f830", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -139,7 +139,7 @@ pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n     let mut queue = vec!(source);\n     let mut i = 0;\n     while i < queue.len() {\n-        match edges_map.find(queue.get(i)) {\n+        match edges_map.find(&queue[i]) {\n             Some(edges) => {\n                 for target in edges.iter() {\n                     if *target == destination {"}, {"sha": "a20a988c881dd3798f00c76a319c84ad30e4e188", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -270,7 +270,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n             ast::NormalFn => {}\n             _ => {\n                 s.push_str(fn_style.to_string().as_slice());\n-                s.push_char(' ');\n+                s.push(' ');\n             }\n         };\n \n@@ -282,7 +282,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n \n         match ident {\n             Some(i) => {\n-                s.push_char(' ');\n+                s.push(' ');\n                 s.push_str(token::get_ident(i).get());\n             }\n             _ => { }\n@@ -307,7 +307,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n             ast::NormalFn => {}\n             _ => {\n                 s.push_str(cty.fn_style.to_string().as_slice());\n-                s.push_char(' ');\n+                s.push(' ');\n             }\n         };\n \n@@ -330,7 +330,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n             }\n         }\n \n-        s.into_owned()\n+        s\n     }\n \n     fn push_sig_to_string(cx: &ctxt,\n@@ -339,13 +339,13 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n                        ket: char,\n                        sig: &ty::FnSig,\n                        bounds: &str) {\n-        s.push_char(bra);\n+        s.push(bra);\n         let strs: Vec<String> = sig.inputs.iter().map(|a| fn_input_to_string(cx, *a)).collect();\n         s.push_str(strs.connect(\", \").as_slice());\n         if sig.variadic {\n             s.push_str(\", ...\");\n         }\n-        s.push_char(ket);\n+        s.push(ket);\n \n         if !bounds.is_empty() {\n             s.push_str(\":\");\n@@ -355,7 +355,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n         if ty::get(sig.output).sty != ty_nil {\n             s.push_str(\" -> \");\n             if ty::type_is_bot(sig.output) {\n-                s.push_char('!');\n+                s.push('!');\n             } else {\n                 s.push_str(ty_to_string(cx, sig.output).as_slice());\n             }\n@@ -670,10 +670,10 @@ impl Repr for ty::BuiltinBounds {\n         let mut res = Vec::new();\n         for b in self.iter() {\n             res.push(match b {\n-                ty::BoundSend => \"Send\".to_owned(),\n-                ty::BoundSized => \"Sized\".to_owned(),\n-                ty::BoundCopy => \"Copy\".to_owned(),\n-                ty::BoundSync => \"Sync\".to_owned(),\n+                ty::BoundSend => \"Send\".to_string(),\n+                ty::BoundSized => \"Sized\".to_string(),\n+                ty::BoundCopy => \"Copy\".to_string(),\n+                ty::BoundSync => \"Sync\".to_string(),\n             });\n         }\n         res.connect(\"+\")\n@@ -1007,10 +1007,10 @@ impl Repr for ty::BuiltinBound {\n impl UserString for ty::BuiltinBound {\n     fn user_string(&self, _tcx: &ctxt) -> String {\n         match *self {\n-            ty::BoundSend => \"Send\".to_owned(),\n-            ty::BoundSized => \"Sized\".to_owned(),\n-            ty::BoundCopy => \"Copy\".to_owned(),\n-            ty::BoundSync => \"Sync\".to_owned(),\n+            ty::BoundSend => \"Send\".to_string(),\n+            ty::BoundSized => \"Sized\".to_string(),\n+            ty::BoundCopy => \"Copy\".to_string(),\n+            ty::BoundSync => \"Sync\".to_string(),\n         }\n     }\n }"}, {"sha": "7a7c8f8d94f72da590b5e53f2b9a19253e42c90f", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -94,7 +94,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n     }\n \n     pub fn get<'a>(&'a self, index: uint) -> &'a T {\n-        self.values.get(index)\n+        &self.values[index]\n     }\n \n     pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n@@ -133,7 +133,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n \n         // Invariant established by start_snapshot():\n         assert!(\n-            match *self.undo_log.get(snapshot.length) {\n+            match self.undo_log[snapshot.length] {\n                 OpenSnapshot => true,\n                 _ => false\n             });"}, {"sha": "ca8a6cd0c401073993e21f3f6ceed63269feea42", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -708,9 +708,11 @@ impl fmt::Show for ModuleSummary {\n             let path = context.connect(\"::\");\n \n             try!(write!(f, \"<tr>\"));\n-            try!(write!(f, \"<td><a href='{}'>{}</a></td>\",\n-                        Vec::from_slice(context.slice_from(1))\n-                            .append_one(\"index.html\").connect(\"/\"),\n+            try!(write!(f, \"<td><a href='{}'>{}</a></td>\", {\n+                            let mut url = context.slice_from(1).to_vec();\n+                            url.push(\"index.html\");\n+                            url.connect(\"/\")\n+                        },\n                         path));\n             try!(write!(f, \"<td class='summary-column'>\"));\n             try!(write!(f, \"<span class='summary Stable' \\"}, {"sha": "6e515f611986e70ad8a9ac59b37bc95a0a64eb35", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -1147,7 +1147,7 @@ impl Context {\n                         cx.layout.krate)\n             } else {\n                 format!(\"API documentation for the Rust `{}` {} in crate `{}`.\",\n-                        it.name.get_ref(), tyname, cx.layout.krate)\n+                        it.name.as_ref().unwrap(), tyname, cx.layout.krate)\n             };\n             let keywords = make_item_keywords(it);\n             let page = layout::Page {\n@@ -1332,7 +1332,7 @@ impl<'a> fmt::Show for Item<'a> {\n             }\n         }\n         try!(write!(fmt, \"<a class='{}' href=''>{}</a>\",\n-                    shortty(self.item), self.item.name.get_ref().as_slice()));\n+                    shortty(self.item), self.item.name.as_ref().unwrap().as_slice()));\n \n         // Write stability level\n         try!(write!(fmt, \"<wbr>{}\", Stability(&self.item.stability)));\n@@ -1395,12 +1395,12 @@ impl<'a> fmt::Show for Item<'a> {\n fn item_path(item: &clean::Item) -> String {\n     match item.inner {\n         clean::ModuleItem(..) => {\n-            format!(\"{}/index.html\", item.name.get_ref())\n+            format!(\"{}/index.html\", item.name.as_ref().unwrap())\n         }\n         _ => {\n             format!(\"{}.{}.html\",\n                     shortty(item).to_static_str(),\n-                    *item.name.get_ref())\n+                    *item.name.as_ref().unwrap())\n         }\n     }\n }\n@@ -1560,7 +1560,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 ConciseStability(&myitem.stability),\n                 VisSpace(myitem.visibility),\n                 MutableSpace(s.mutability),\n-                *myitem.name.get_ref(),\n+                *myitem.name.as_ref().unwrap(),\n                 s.type_,\n                 Initializer(s.expr.as_slice(), Item { cx: cx, item: myitem }),\n                 Markdown(blank(myitem.doc_value()))));\n@@ -1574,7 +1574,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 \",\n                 ConciseStability(&myitem.stability),\n                 VisSpace(myitem.visibility),\n-                *myitem.name.get_ref(),\n+                *myitem.name.as_ref().unwrap(),\n                 s.type_,\n                 Initializer(s.expr.as_slice(), Item { cx: cx, item: myitem }),\n                 Markdown(blank(myitem.doc_value()))));\n@@ -1611,7 +1611,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                         <td class='docblock short'>{}</td>\n                     </tr>\n                 \",\n-                *myitem.name.get_ref(),\n+                *myitem.name.as_ref().unwrap(),\n                 Markdown(shorter(myitem.doc_value())),\n                 class = shortty(myitem),\n                 href = item_path(myitem),\n@@ -1630,7 +1630,7 @@ fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n                     {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(it.visibility),\n            fn_style = FnStyleSpace(f.fn_style),\n-           name = it.name.get_ref().as_slice(),\n+           name = it.name.as_ref().unwrap().as_slice(),\n            generics = f.generics,\n            where_clause = WhereClause(&f.generics),\n            decl = f.decl));\n@@ -1651,7 +1651,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     // Output the trait definition\n     try!(write!(w, \"<pre class='rust trait'>{}trait {}{}{}{} \",\n                   VisSpace(it.visibility),\n-                  it.name.get_ref().as_slice(),\n+                  it.name.as_ref().unwrap().as_slice(),\n                   t.generics,\n                   bounds,\n                   WhereClause(&t.generics)));\n@@ -1700,7 +1700,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                   -> fmt::Result {\n         try!(write!(w, \"<h3 id='{}.{}' class='method'>{}<code>\",\n                     shortty(m.item()),\n-                    *m.item().name.get_ref(),\n+                    *m.item().name.as_ref().unwrap(),\n                     ConciseStability(&m.item().stability)));\n         try!(render_method(w, m.item()));\n         try!(write!(w, \"</code></h3>\"));\n@@ -1753,11 +1753,11 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 path = if ast_util::is_local(it.def_id) {\n                     cx.current.connect(\"/\")\n                 } else {\n-                    let path = cache.external_paths.get(&it.def_id);\n+                    let path = &cache.external_paths[it.def_id];\n                     path.slice_to(path.len() - 1).connect(\"/\")\n                 },\n                 ty = shortty(it).to_static_str(),\n-                name = *it.name.get_ref()));\n+                name = *it.name.as_ref().unwrap()));\n     Ok(())\n }\n \n@@ -1772,7 +1772,7 @@ fn render_method(w: &mut fmt::Formatter, meth: &clean::Item) -> fmt::Result {\n                    _ => \"\",\n                },\n                ty = shortty(it),\n-               name = it.name.get_ref().as_slice(),\n+               name = it.name.as_ref().unwrap().as_slice(),\n                generics = *g,\n                decl = Method(selfty, d),\n                where_clause = WhereClause(g))\n@@ -1816,7 +1816,7 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                     try!(write!(w, \"<tr><td id='structfield.{name}'>\\\n                                       {stab}<code>{name}</code></td><td>\",\n                                   stab = ConciseStability(&field.stability),\n-                                  name = field.name.get_ref().as_slice()));\n+                                  name = field.name.as_ref().unwrap().as_slice()));\n                     try!(document(w, field));\n                     try!(write!(w, \"</td></tr>\"));\n                 }\n@@ -1832,7 +1832,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust enum'>{}enum {}{}{}\",\n                   VisSpace(it.visibility),\n-                  it.name.get_ref().as_slice(),\n+                  it.name.as_ref().unwrap().as_slice(),\n                   e.generics,\n                   WhereClause(&e.generics)));\n     if e.variants.len() == 0 && !e.variants_stripped {\n@@ -1885,7 +1885,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         for variant in e.variants.iter() {\n             try!(write!(w, \"<tr><td id='variant.{name}'>{stab}<code>{name}</code></td><td>\",\n                           stab = ConciseStability(&variant.stability),\n-                          name = variant.name.get_ref().as_slice()));\n+                          name = variant.name.as_ref().unwrap().as_slice()));\n             try!(document(w, variant));\n             match variant.inner {\n                 clean::VariantItem(ref var) => {\n@@ -1906,8 +1906,8 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n                                 try!(write!(w, \"<tr><td \\\n                                                   id='variant.{v}.field.{f}'>\\\n                                                   <code>{f}</code></td><td>\",\n-                                              v = variant.name.get_ref().as_slice(),\n-                                              f = field.name.get_ref().as_slice()));\n+                                              v = variant.name.as_ref().unwrap().as_slice(),\n+                                              f = field.name.as_ref().unwrap().as_slice()));\n                                 try!(document(w, field));\n                                 try!(write!(w, \"</td></tr>\"));\n                             }\n@@ -1936,7 +1936,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n     try!(write!(w, \"{}{}{}\",\n                   VisSpace(it.visibility),\n                   if structhead {\"struct \"} else {\"\"},\n-                  it.name.get_ref().as_slice()));\n+                  it.name.as_ref().unwrap().as_slice()));\n     match g {\n         Some(g) => try!(write!(w, \"{}{}\", *g, WhereClause(g))),\n         None => {}\n@@ -1953,7 +1953,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                     clean::StructFieldItem(clean::TypedStructField(ref ty)) => {\n                         try!(write!(w, \"    {}{}: {},\\n{}\",\n                                       VisSpace(field.visibility),\n-                                      field.name.get_ref().as_slice(),\n+                                      field.name.as_ref().unwrap().as_slice(),\n                                       *ty,\n                                       tab));\n                     }\n@@ -2042,7 +2042,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n     fn doctraititem(w: &mut fmt::Formatter, item: &clean::Item, dox: bool)\n                     -> fmt::Result {\n         try!(write!(w, \"<h4 id='method.{}' class='method'>{}<code>\",\n-                    *item.name.get_ref(),\n+                    *item.name.as_ref().unwrap(),\n                     ConciseStability(&item.stability)));\n         try!(render_method(w, item));\n         try!(write!(w, \"</code></h4>\\n\"));\n@@ -2096,7 +2096,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n fn item_typedef(w: &mut fmt::Formatter, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n     try!(write!(w, \"<pre class='rust typedef'>type {}{} = {};</pre>\",\n-                  it.name.get_ref().as_slice(),\n+                  it.name.as_ref().unwrap().as_slice(),\n                   t.generics,\n                   t.type_));\n \n@@ -2231,5 +2231,5 @@ fn get_basic_keywords() -> &'static str {\n }\n \n fn make_item_keywords(it: &clean::Item) -> String {\n-    format!(\"{}, {}\", get_basic_keywords(), it.name.get_ref())\n+    format!(\"{}, {}\", get_basic_keywords(), it.name.as_ref().unwrap())\n }"}, {"sha": "3138c9be99247ab5fb88e1ccd75f5ddd394ead9d", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -125,8 +125,8 @@ mod imp {\n             let saved_value = take();\n \n             let expected = vec![\n-                Vec::from_slice(b\"happy\"),\n-                Vec::from_slice(b\"today?\"),\n+                b\"happy\".to_vec(),\n+                b\"today?\".to_vec(),\n             ];\n \n             put(expected.clone());"}, {"sha": "a4129fe35067a46c92106089ba6e12cb1f4ac423", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -204,30 +204,6 @@ impl CString {\n         self.buf as *mut _\n     }\n \n-    /// Calls a closure with a reference to the underlying `*libc::c_char`.\n-    #[deprecated=\"use `.as_ptr()`\"]\n-    pub fn with_ref<T>(&self, f: |*const libc::c_char| -> T) -> T {\n-        f(self.buf)\n-    }\n-\n-    /// Calls a closure with a mutable reference to the underlying `*libc::c_char`.\n-    #[deprecated=\"use `.as_mut_ptr()`\"]\n-    pub fn with_mut_ref<T>(&mut self, f: |*mut libc::c_char| -> T) -> T {\n-        f(self.buf as *mut libc::c_char)\n-    }\n-\n-    /// Returns true if the CString is a null.\n-    #[deprecated=\"a CString cannot be null\"]\n-    pub fn is_null(&self) -> bool {\n-        self.buf.is_null()\n-    }\n-\n-    /// Returns true if the CString is not null.\n-    #[deprecated=\"a CString cannot be null\"]\n-    pub fn is_not_null(&self) -> bool {\n-        self.buf.is_not_null()\n-    }\n-\n     /// Returns whether or not the `CString` owns the buffer.\n     pub fn owns_buffer(&self) -> bool {\n         self.owns_buffer_"}, {"sha": "cc0e7d9ba2d98f78e40d253aa227e2684a9a3845", "filename": "src/libsemver/lib.rs", "status": "removed", "additions": 0, "deletions": 462, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,462 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Semantic version parsing and comparison.\n-//!\n-//! Semantic versioning (see http://semver.org/) is a set of rules for\n-//! assigning version numbers intended to convey meaning about what has\n-//! changed, and how much. A version number has five parts:\n-//!\n-//!  * Major number, updated for incompatible API changes\n-//!  * Minor number, updated for backwards-compatible API additions\n-//!  * Patch number, updated for backwards-compatible bugfixes\n-//!  * Pre-release information (optional), preceded by a hyphen (`-`)\n-//!  * Build metadata (optional), preceded by a plus sign (`+`)\n-//!\n-//! The three mandatory components are required to be decimal numbers. The\n-//! pre-release information and build metadata are required to be a\n-//! period-separated list of identifiers containing only alphanumeric\n-//! characters and hyphens.\n-//!\n-//! An example version number with all five components is\n-//! `0.8.1-rc.3.0+20130922.linux`.\n-\n-#![crate_name = \"semver\"]\n-#![deprecated = \"This is now a cargo package located at: \\\n-                 https://github.com/rust-lang/semver\"]\n-#![allow(deprecated)]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(default_type_params)]\n-\n-use std::char;\n-use std::cmp;\n-use std::fmt::Show;\n-use std::fmt;\n-use std::hash;\n-\n-/// An identifier in the pre-release or build metadata. If the identifier can\n-/// be parsed as a decimal value, it will be represented with `Numeric`.\n-#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[allow(missing_doc)]\n-pub enum Identifier {\n-    Numeric(uint),\n-    AlphaNumeric(String)\n-}\n-\n-impl fmt::Show for Identifier {\n-    #[inline]\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Numeric(ref n) => n.fmt(f),\n-            AlphaNumeric(ref s) => s.fmt(f)\n-        }\n-    }\n-}\n-\n-\n-/// Represents a version number conforming to the semantic versioning scheme.\n-#[deriving(Clone, Eq)]\n-pub struct Version {\n-    /// The major version, to be incremented on incompatible changes.\n-    pub major: uint,\n-    /// The minor version, to be incremented when functionality is added in a\n-    /// backwards-compatible manner.\n-    pub minor: uint,\n-    /// The patch version, to be incremented when backwards-compatible bug\n-    /// fixes are made.\n-    pub patch: uint,\n-    /// The pre-release version identifier, if one exists.\n-    pub pre: Vec<Identifier>,\n-    /// The build metadata, ignored when determining version precedence.\n-    pub build: Vec<Identifier>,\n-}\n-\n-impl fmt::Show for Version {\n-    #[inline]\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}.{}.{}\", self.major, self.minor, self.patch))\n-        if !self.pre.is_empty() {\n-            try!(write!(f, \"-\"));\n-            for (i, x) in self.pre.iter().enumerate() {\n-                if i != 0 { try!(write!(f, \".\")) };\n-                try!(x.fmt(f));\n-            }\n-        }\n-        if !self.build.is_empty() {\n-            try!(write!(f, \"+\"));\n-            for (i, x) in self.build.iter().enumerate() {\n-                if i != 0 { try!(write!(f, \".\")) };\n-                try!(x.fmt(f));\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl cmp::PartialEq for Version {\n-    #[inline]\n-    fn eq(&self, other: &Version) -> bool {\n-        // We should ignore build metadata here, otherwise versions v1 and v2\n-        // can exist such that !(v1 < v2) && !(v1 > v2) && v1 != v2, which\n-        // violate strict total ordering rules.\n-        self.major == other.major &&\n-            self.minor == other.minor &&\n-            self.patch == other.patch &&\n-            self.pre == other.pre\n-    }\n-}\n-\n-impl cmp::PartialOrd for Version {\n-    fn partial_cmp(&self, other: &Version) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl cmp::Ord for Version {\n-    fn cmp(&self, other: &Version) -> Ordering {\n-        match self.major.cmp(&other.major) {\n-            Equal => {}\n-            r => return r,\n-        }\n-\n-        match self.minor.cmp(&other.minor) {\n-            Equal => {}\n-            r => return r,\n-        }\n-\n-        match self.patch.cmp(&other.patch) {\n-            Equal => {}\n-            r => return r,\n-        }\n-\n-        // NB: semver spec says 0.0.0-pre < 0.0.0\n-        // but the version of ord defined for vec\n-        // says that [] < [pre] so we alter it here\n-        match (self.pre.len(), other.pre.len()) {\n-            (0, 0) => Equal,\n-            (0, _) => Greater,\n-            (_, 0) => Less,\n-            (_, _) => self.pre.cmp(&other.pre)\n-        }\n-    }\n-}\n-\n-impl<S: hash::Writer> hash::Hash<S> for Version {\n-    fn hash(&self, into: &mut S) {\n-        self.major.hash(into);\n-        self.minor.hash(into);\n-        self.patch.hash(into);\n-        self.pre.hash(into);\n-    }\n-}\n-\n-fn take_nonempty_prefix<T:Iterator<char>>(rdr: &mut T, pred: |char| -> bool)\n-                        -> (String, Option<char>) {\n-    let mut buf = String::new();\n-    let mut ch = rdr.next();\n-    loop {\n-        match ch {\n-            None => break,\n-            Some(c) if !pred(c) => break,\n-            Some(c) => {\n-                buf.push_char(c);\n-                ch = rdr.next();\n-            }\n-        }\n-    }\n-    (buf, ch)\n-}\n-\n-fn take_num<T: Iterator<char>>(rdr: &mut T) -> Option<(uint, Option<char>)> {\n-    let (s, ch) = take_nonempty_prefix(rdr, char::is_digit);\n-    match from_str::<uint>(s.as_slice()) {\n-        None => None,\n-        Some(i) => Some((i, ch))\n-    }\n-}\n-\n-fn take_ident<T: Iterator<char>>(rdr: &mut T) -> Option<(Identifier, Option<char>)> {\n-    let (s,ch) = take_nonempty_prefix(rdr, char::is_alphanumeric);\n-    if s.as_slice().chars().all(char::is_digit) {\n-        match from_str::<uint>(s.as_slice()) {\n-            None => None,\n-            Some(i) => Some((Numeric(i), ch))\n-        }\n-    } else {\n-        Some((AlphaNumeric(s), ch))\n-    }\n-}\n-\n-fn expect(ch: Option<char>, c: char) -> Option<()> {\n-    if ch != Some(c) {\n-        None\n-    } else {\n-        Some(())\n-    }\n-}\n-\n-fn parse_iter<T: Iterator<char>>(rdr: &mut T) -> Option<Version> {\n-    let maybe_vers = take_num(rdr).and_then(|(major, ch)| {\n-        expect(ch, '.').and_then(|_| Some(major))\n-    }).and_then(|major| {\n-        take_num(rdr).and_then(|(minor, ch)| {\n-            expect(ch, '.').and_then(|_| Some((major, minor)))\n-        })\n-    }).and_then(|(major, minor)| {\n-        take_num(rdr).and_then(|(patch, ch)| {\n-           Some((major, minor, patch, ch))\n-        })\n-    });\n-\n-    let (major, minor, patch, ch) = match maybe_vers {\n-        Some((a, b, c, d)) => (a, b, c, d),\n-        None => return None\n-    };\n-\n-    let mut pre = vec!();\n-    let mut build = vec!();\n-\n-    let mut ch = ch;\n-    if ch == Some('-') {\n-        loop {\n-            let (id, c) = match take_ident(rdr) {\n-                Some((id, c)) => (id, c),\n-                None => return None\n-            };\n-            pre.push(id);\n-            ch = c;\n-            if ch != Some('.') { break; }\n-        }\n-    }\n-\n-    if ch == Some('+') {\n-        loop {\n-            let (id, c) = match take_ident(rdr) {\n-                Some((id, c)) => (id, c),\n-                None => return None\n-            };\n-            build.push(id);\n-            ch = c;\n-            if ch != Some('.') { break; }\n-        }\n-    }\n-\n-    Some(Version {\n-        major: major,\n-        minor: minor,\n-        patch: patch,\n-        pre: pre,\n-        build: build,\n-    })\n-}\n-\n-\n-/// Parse a string into a semver object.\n-pub fn parse(s: &str) -> Option<Version> {\n-    if !s.is_ascii() {\n-        return None;\n-    }\n-    let s = s.trim();\n-    let v = parse_iter(&mut s.chars());\n-    match v {\n-        Some(v) => {\n-            if v.to_string().equiv(&s) {\n-                Some(v)\n-            } else {\n-                None\n-            }\n-        }\n-        None => None\n-    }\n-}\n-\n-#[test]\n-fn test_parse() {\n-    assert_eq!(parse(\"\"), None);\n-    assert_eq!(parse(\"  \"), None);\n-    assert_eq!(parse(\"1\"), None);\n-    assert_eq!(parse(\"1.2\"), None);\n-    assert_eq!(parse(\"1.2\"), None);\n-    assert_eq!(parse(\"1\"), None);\n-    assert_eq!(parse(\"1.2\"), None);\n-    assert_eq!(parse(\"1.2.3-\"), None);\n-    assert_eq!(parse(\"a.b.c\"), None);\n-    assert_eq!(parse(\"1.2.3 abc\"), None);\n-\n-    assert!(parse(\"1.2.3\") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(),\n-        build: vec!(),\n-    }));\n-    assert!(parse(\"  1.2.3  \") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(),\n-        build: vec!(),\n-    }));\n-    assert!(parse(\"1.2.3-alpha1\") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_string())),\n-        build: vec!(),\n-    }));\n-    assert!(parse(\"  1.2.3-alpha1  \") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_string())),\n-        build: vec!()\n-    }));\n-    assert!(parse(\"1.2.3+build5\") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(),\n-        build: vec!(AlphaNumeric(\"build5\".to_string()))\n-    }));\n-    assert!(parse(\"  1.2.3+build5  \") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(),\n-        build: vec!(AlphaNumeric(\"build5\".to_string()))\n-    }));\n-    assert!(parse(\"1.2.3-alpha1+build5\") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_string())),\n-        build: vec!(AlphaNumeric(\"build5\".to_string()))\n-    }));\n-    assert!(parse(\"  1.2.3-alpha1+build5  \") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(AlphaNumeric(\"alpha1\".to_string())),\n-        build: vec!(AlphaNumeric(\"build5\".to_string()))\n-    }));\n-    assert!(parse(\"1.2.3-1.alpha1.9+build5.7.3aedf  \") == Some(Version {\n-        major: 1u,\n-        minor: 2u,\n-        patch: 3u,\n-        pre: vec!(Numeric(1),AlphaNumeric(\"alpha1\".to_string()),Numeric(9)),\n-        build: vec!(AlphaNumeric(\"build5\".to_string()),\n-                 Numeric(7),\n-                 AlphaNumeric(\"3aedf\".to_string()))\n-    }));\n-\n-}\n-\n-#[test]\n-fn test_eq() {\n-    assert_eq!(parse(\"1.2.3\"), parse(\"1.2.3\"));\n-    assert_eq!(parse(\"1.2.3-alpha1\"), parse(\"1.2.3-alpha1\"));\n-    assert_eq!(parse(\"1.2.3+build.42\"), parse(\"1.2.3+build.42\"));\n-    assert_eq!(parse(\"1.2.3-alpha1+42\"), parse(\"1.2.3-alpha1+42\"));\n-    assert_eq!(parse(\"1.2.3+23\"), parse(\"1.2.3+42\"));\n-}\n-\n-#[test]\n-fn test_ne() {\n-    assert!(parse(\"0.0.0\")       != parse(\"0.0.1\"));\n-    assert!(parse(\"0.0.0\")       != parse(\"0.1.0\"));\n-    assert!(parse(\"0.0.0\")       != parse(\"1.0.0\"));\n-    assert!(parse(\"1.2.3-alpha\") != parse(\"1.2.3-beta\"));\n-}\n-\n-#[test]\n-fn test_show() {\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3\").unwrap()),\n-               \"1.2.3\".to_string());\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3-alpha1\").unwrap()),\n-               \"1.2.3-alpha1\".to_string());\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3+build.42\").unwrap()),\n-               \"1.2.3+build.42\".to_string());\n-    assert_eq!(format!(\"{}\", parse(\"1.2.3-alpha1+42\").unwrap()),\n-               \"1.2.3-alpha1+42\".to_string());\n-}\n-\n-#[test]\n-fn test_to_string() {\n-    assert_eq!(parse(\"1.2.3\").unwrap().to_string(), \"1.2.3\".to_string());\n-    assert_eq!(parse(\"1.2.3-alpha1\").unwrap().to_string(), \"1.2.3-alpha1\".to_string());\n-    assert_eq!(parse(\"1.2.3+build.42\").unwrap().to_string(), \"1.2.3+build.42\".to_string());\n-    assert_eq!(parse(\"1.2.3-alpha1+42\").unwrap().to_string(), \"1.2.3-alpha1+42\".to_string());\n-}\n-\n-#[test]\n-fn test_lt() {\n-    assert!(parse(\"0.0.0\")          < parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.0.0\")          < parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.0\")          < parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.3-alpha1\")   < parse(\"1.2.3\"));\n-    assert!(parse(\"1.2.3-alpha1\")   < parse(\"1.2.3-alpha2\"));\n-    assert!(!(parse(\"1.2.3-alpha2\") < parse(\"1.2.3-alpha2\")));\n-    assert!(!(parse(\"1.2.3+23\")     < parse(\"1.2.3+42\")));\n-}\n-\n-#[test]\n-fn test_le() {\n-    assert!(parse(\"0.0.0\")        <= parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.0.0\")        <= parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.0\")        <= parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.3-alpha1\") <= parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.3-alpha2\") <= parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.3+23\")     <= parse(\"1.2.3+42\"));\n-}\n-\n-#[test]\n-fn test_gt() {\n-    assert!(parse(\"1.2.3-alpha2\")   > parse(\"0.0.0\"));\n-    assert!(parse(\"1.2.3-alpha2\")   > parse(\"1.0.0\"));\n-    assert!(parse(\"1.2.3-alpha2\")   > parse(\"1.2.0\"));\n-    assert!(parse(\"1.2.3-alpha2\")   > parse(\"1.2.3-alpha1\"));\n-    assert!(parse(\"1.2.3\")          > parse(\"1.2.3-alpha2\"));\n-    assert!(!(parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha2\")));\n-    assert!(!(parse(\"1.2.3+23\")     > parse(\"1.2.3+42\")));\n-}\n-\n-#[test]\n-fn test_ge() {\n-    assert!(parse(\"1.2.3-alpha2\") >= parse(\"0.0.0\"));\n-    assert!(parse(\"1.2.3-alpha2\") >= parse(\"1.0.0\"));\n-    assert!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.0\"));\n-    assert!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha1\"));\n-    assert!(parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha2\"));\n-    assert!(parse(\"1.2.3+23\")     >= parse(\"1.2.3+42\"));\n-}\n-\n-#[test]\n-fn test_spec_order() {\n-    let vs = [\"1.0.0-alpha\",\n-              \"1.0.0-alpha.1\",\n-              \"1.0.0-alpha.beta\",\n-              \"1.0.0-beta\",\n-              \"1.0.0-beta.2\",\n-              \"1.0.0-beta.11\",\n-              \"1.0.0-rc.1\",\n-              \"1.0.0\"];\n-    let mut i = 1;\n-    while i < vs.len() {\n-        let a = parse(vs[i-1]).unwrap();\n-        let b = parse(vs[i]).unwrap();\n-        assert!(a < b);\n-        i += 1;\n-    }\n-}"}, {"sha": "73b4773fb3ff948f129da4229e9ef840b75f2c8e", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -406,14 +406,6 @@ impl<'a> Encoder<'a> {\n         }\n         m.unwrap()\n     }\n-\n-    /// Encode the specified struct into a json str\n-    ///\n-    /// Note: this function is deprecated. Consider using `json::encode` instead.\n-    #[deprecated = \"Replaced by `json::encode`\"]\n-    pub fn str_encode<T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> string::String {\n-        encode(object)\n-    }\n }\n \n impl<'a> ::Encoder<io::IoError> for Encoder<'a> {"}, {"sha": "07be15486fdbc0355f5c945b7897be9e0298cfc5", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 51, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -25,13 +25,6 @@ use string::{mod, String};\n use to_string::IntoStr;\n use vec::Vec;\n \n-#[deprecated=\"this trait has been renamed to `AsciiExt`\"]\n-pub use self::AsciiExt as StrAsciiExt;\n-\n-#[deprecated=\"this trait has been renamed to `OwnedAsciiExt`\"]\n-pub use self::OwnedAsciiExt as OwnedStrAsciiExt;\n-\n-\n /// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n #[deriving(Clone, PartialEq, PartialOrd, Ord, Eq, Hash)]\n pub struct Ascii { chr: u8 }\n@@ -49,26 +42,12 @@ impl Ascii {\n         self.chr as char\n     }\n \n-    #[inline]\n-    #[allow(missing_doc)]\n-    #[deprecated=\"renamed to `to_lowercase`\"]\n-    pub fn to_lower(self) -> Ascii {\n-        self.to_lowercase()\n-    }\n-\n     /// Convert to lowercase.\n     #[inline]\n     pub fn to_lowercase(self) -> Ascii {\n         Ascii{chr: ASCII_LOWER_MAP[self.chr as uint]}\n     }\n \n-    /// Deprecated: use `to_uppercase`\n-    #[inline]\n-    #[deprecated=\"renamed to `to_uppercase`\"]\n-    pub fn to_upper(self) -> Ascii {\n-        self.to_uppercase()\n-    }\n-\n     /// Convert to uppercase.\n     #[inline]\n     pub fn to_uppercase(self) -> Ascii {\n@@ -83,13 +62,6 @@ impl Ascii {\n \n     // the following methods are like ctype, and the implementation is inspired by musl\n \n-    #[inline]\n-    #[allow(missing_doc)]\n-    #[deprecated=\"renamed to `is_alphabetic`\"]\n-    pub fn is_alpha(&self) -> bool {\n-        self.is_alphabetic()\n-    }\n-\n     /// Check if the character is a letter (a-z, A-Z)\n     #[inline]\n     pub fn is_alphabetic(&self) -> bool {\n@@ -102,13 +74,6 @@ impl Ascii {\n         self.chr >= 0x30 && self.chr <= 0x39\n     }\n \n-    #[inline]\n-    #[allow(missing_doc)]\n-    #[deprecated=\"renamed to `is_alphanumeric`\"]\n-    pub fn is_alnum(&self) -> bool {\n-        self.is_alphanumeric()\n-    }\n-\n     /// Check if the character is a letter or number\n     #[inline]\n     pub fn is_alphanumeric(&self) -> bool {\n@@ -139,26 +104,12 @@ impl Ascii {\n         (self.chr - 0x20) < 0x5F\n     }\n \n-    /// Deprecated: use `to_lowercase`\n-    #[inline]\n-    #[deprecated=\"renamed to `is_lowercase`\"]\n-    pub fn is_lower(&self) -> bool {\n-        self.is_lowercase()\n-    }\n-\n     /// Checks if the character is lowercase\n     #[inline]\n     pub fn is_lowercase(&self) -> bool {\n         (self.chr - b'a') < 26\n     }\n \n-    #[inline]\n-    #[allow(missing_doc)]\n-    #[deprecated=\"renamed to `is_uppercase`\"]\n-    pub fn is_upper(&self) -> bool {\n-        self.is_uppercase()\n-    }\n-\n     /// Checks if the character is uppercase\n     #[inline]\n     pub fn is_uppercase(&self) -> bool {\n@@ -581,7 +532,6 @@ mod tests {\n     use prelude::*;\n     use super::*;\n     use char::from_u32;\n-    use vec::Vec;\n     use str::StrSlice;\n \n     macro_rules! v2ascii (\n@@ -590,7 +540,7 @@ mod tests {\n     )\n \n     macro_rules! vec2ascii (\n-        ($($e:expr),*) => (Vec::from_slice([$(Ascii{chr:$e}),*]));\n+        ($($e:expr),*) => ([$(Ascii{chr:$e}),*].to_vec());\n     )\n \n     #[test]"}, {"sha": "ac0d117e02a114d732ebd7633dab0136b315ac4f", "filename": "src/libstd/collections/hashmap/map.rs", "status": "modified", "additions": 2, "deletions": 304, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -22,7 +22,7 @@ use iter;\n use mem::replace;\n use mem;\n use num;\n-use ops::{Deref, DerefMut};\n+use ops::Deref;\n use option::{Some, None, Option};\n use result::{Ok, Err};\n use ops::Index;\n@@ -425,25 +425,6 @@ impl<K, V, M> SearchResult<K, V, M> {\n     }\n }\n \n-/// A newtyped mutable reference to the hashmap that allows e.g. Deref to be\n-/// implemented without making changes to the visible interface of HashMap.\n-/// Used internally because it's accepted by the search functions above.\n-struct MapMutRef<'a, K: 'a, V: 'a, H: 'a> {\n-    map_ref: &'a mut HashMap<K, V, H>\n-}\n-\n-impl<'a, K, V, H> Deref<RawTable<K, V>> for MapMutRef<'a, K, V, H> {\n-    fn deref(&self) -> &RawTable<K, V> {\n-        &self.map_ref.table\n-    }\n-}\n-\n-impl<'a, K, V, H> DerefMut<RawTable<K, V>> for MapMutRef<'a, K, V, H> {\n-    fn deref_mut(&mut self) -> &mut RawTable<K, V> {\n-        &mut self.map_ref.table\n-    }\n-}\n-\n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     fn make_hash<X: Hash<S>>(&self, x: &X) -> SafeHash {\n         table::make_hash(&self.hasher, x)\n@@ -847,253 +828,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Inserts an element which has already been hashed, returning a reference\n-    /// to that element inside the hashtable. This is more efficient that using\n-    /// `insert`, since the key will not be rehashed.\n-    fn insert_hashed(&mut self, hash: SafeHash, k: K, v: V) -> &mut V {\n-        let potential_new_size = self.table.size() + 1;\n-        self.make_some_room(potential_new_size);\n-        self.insert_hashed_nocheck(hash, k, v)\n-    }\n-\n-    /// Deprecated: use `entry` as follows instead:\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hashmap::{Occupied, Vacant};\n-    ///\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// let result = match map.entry(\"a\") {\n-    ///     Vacant(entry) => entry.set(1i),\n-    ///     Occupied(entry) => entry.into_mut(),\n-    /// };\n-    /// assert_eq!(*result, 1);\n-    /// ```\n-    ///\n-    /// Return the value corresponding to the key in the map, or insert\n-    /// and return the value if it doesn't exist.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    /// use std::collections::HashMap;\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// // Insert 1i with key \"a\"\n-    /// assert_eq!(*map.find_or_insert(\"a\", 1i), 1);\n-    ///\n-    /// // Find the existing key\n-    /// assert_eq!(*map.find_or_insert(\"a\", -2), 1);\n-    /// ```\n-    #[deprecated = \"use entry instead\"]\n-    #[allow(deprecated)]\n-    pub fn find_or_insert(&mut self, k: K, v: V) -> &mut V {\n-        self.find_with_or_insert_with(k, v, |_k, _v, _a| (), |_k, a| a)\n-    }\n-\n-    /// Deprecated: use `entry` as follows instead:\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hashmap::{Occupied, Vacant};\n-    ///\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// let result = match map.entry(\"a\") {\n-    ///     Vacant(entry) => entry.set(1i),\n-    ///     Occupied(entry) => entry.into_mut(),\n-    /// };\n-    /// assert_eq!(*result, 1);\n-    /// ```\n-    ///\n-    /// Return the value corresponding to the key in the map, or create,\n-    /// insert, and return a new value if it doesn't exist.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    /// use std::collections::HashMap;\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// // Insert 10 with key 2\n-    /// assert_eq!(*map.find_or_insert_with(2i, |&key| 5 * key as uint), 10u);\n-    ///\n-    /// // Find the existing key\n-    /// assert_eq!(*map.find_or_insert_with(2, |&key| key as uint), 10);\n-    /// ```\n-    #[deprecated = \"use entry instead\"]\n-    #[allow(deprecated)]\n-    pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n-                               -> &'a mut V {\n-        self.find_with_or_insert_with(k, (), |_k, _v, _a| (), |k, _a| f(k))\n-    }\n-\n-    /// Deprecated: use `entry` as follows instead:\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hashmap::{Occupied, Vacant};\n-    ///\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// let result = match map.entry(\"a\") {\n-    ///     Vacant(entry) => entry.set(1u),\n-    ///     Occupied(mut entry) => {\n-    ///         *entry.get_mut() += 1;\n-    ///         entry.into_mut()\n-    ///     }\n-    /// };\n-    /// assert_eq!(*result, 1);\n-    /// ```\n-    ///\n-    /// Insert a key-value pair into the map if the key is not already present.\n-    /// Otherwise, modify the existing value for the key.\n-    /// Returns the new or modified value for the key.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    /// use std::collections::HashMap;\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// // Insert 2 with key \"a\"\n-    /// assert_eq!(*map.insert_or_update_with(\"a\", 2u, |_key, val| *val = 3), 2);\n-    ///\n-    /// // Update and return the existing value\n-    /// assert_eq!(*map.insert_or_update_with(\"a\", 9, |_key, val| *val = 7), 7);\n-    /// assert_eq!(map[\"a\"], 7);\n-    /// ```\n-    #[deprecated = \"use entry instead\"]\n-    pub fn insert_or_update_with<'a>(\n-                                 &'a mut self,\n-                                 k: K,\n-                                 v: V,\n-                                 f: |&K, &mut V|)\n-                                 -> &'a mut V {\n-        let potential_new_size = self.table.size() + 1;\n-        self.make_some_room(potential_new_size);\n-\n-        let hash = self.make_hash(&k);\n-        self.insert_or_replace_with(hash, k, v, |kref, vref, _v| f(kref, vref))\n-    }\n-\n-    /// Deprecated: use `entry` as follows instead:\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hashmap::{Occupied, Vacant};\n-    ///\n-    /// let mut map = HashMap::new();\n-    ///\n-    /// let result = match map.entry(\"a\") {\n-    ///     Vacant(entry) => entry.set(1u),\n-    ///     Occupied(mut entry) => {\n-    ///         *entry.get_mut() += 1;\n-    ///         entry.into_mut()\n-    ///     }\n-    /// };\n-    /// assert_eq!(*result, 1);\n-    /// ```\n-    ///\n-    /// Modify and return the value corresponding to the key in the map, or\n-    /// insert and return a new value if it doesn't exist.\n-    ///\n-    /// This method allows for all insertion behaviours of a hashmap;\n-    /// see methods like\n-    /// [`insert`](../trait.MutableMap.html#tymethod.insert),\n-    /// [`find_or_insert`](#method.find_or_insert) and\n-    /// [`insert_or_update_with`](#method.insert_or_update_with)\n-    /// for less general and more friendly variations of this.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    /// use std::collections::HashMap;\n-    ///\n-    /// // map some strings to vectors of strings\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a key\", vec![\"value\"]);\n-    /// map.insert(\"z key\", vec![\"value\"]);\n-    ///\n-    /// let new = vec![\"a key\", \"b key\", \"z key\"];\n-    ///\n-    /// for k in new.into_iter() {\n-    ///     map.find_with_or_insert_with(\n-    ///         k, \"new value\",\n-    ///         // if the key does exist either prepend or append this\n-    ///         // new value based on the first letter of the key.\n-    ///         |key, already, new| {\n-    ///             if key.as_slice().starts_with(\"z\") {\n-    ///                 already.insert(0, new);\n-    ///             } else {\n-    ///                 already.push(new);\n-    ///             }\n-    ///         },\n-    ///         // if the key doesn't exist in the map yet, add it in\n-    ///         // the obvious way.\n-    ///         |_k, v| vec![v]);\n-    /// }\n-    ///\n-    /// assert_eq!(map.len(), 3);\n-    /// assert_eq!(map[\"a key\"], vec![\"value\", \"new value\"]);\n-    /// assert_eq!(map[\"b key\"], vec![\"new value\"]);\n-    /// assert_eq!(map[\"z key\"], vec![\"new value\", \"value\"]);\n-    /// ```\n-    #[deprecated = \"use entry instead\"]\n-    pub fn find_with_or_insert_with<'a, A>(&'a mut self,\n-                                           k: K,\n-                                           a: A,\n-                                           found: |&K, &mut V, A|,\n-                                           not_found: |&K, A| -> V)\n-                                          -> &'a mut V\n-    {\n-        let hash = self.make_hash(&k);\n-        let this = MapMutRef { map_ref: self };\n-\n-        match search_hashed(this, &hash, &k) {\n-            FoundExisting(bucket) => {\n-                let (_, v_ref) = bucket.into_mut_refs();\n-                found(&k, v_ref, a);\n-                v_ref\n-            }\n-            TableRef(this) => {\n-                let v = not_found(&k, a);\n-                this.map_ref.insert_hashed(hash, k, v)\n-            }\n-        }\n-    }\n-\n-    /// Retrieves a value for the given key.\n-    /// See [`find`](../trait.Map.html#tymethod.find) for a non-failing alternative.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if the key is not present.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map = HashMap::new();\n-    /// map.insert(\"a\", 1i);\n-    /// assert_eq!(map.get(&\"a\"), &1);\n-    /// ```\n-    #[deprecated = \"prefer indexing instead, e.g., map[key]\"]\n-    pub fn get<'a>(&'a self, k: &K) -> &'a V {\n-        match self.find(k) {\n-            Some(v) => v,\n-            None => fail!(\"no entry found for key\")\n-        }\n-    }\n-\n     /// Retrieves a mutable value for the given key.\n     /// See [`find_mut`](../trait.MutableMap.html#tymethod.find_mut) for a non-failing alternative.\n     ///\n@@ -1274,12 +1008,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         Entries { inner: self.table.iter() }\n     }\n \n-    /// Deprecated: use `iter_mut`.\n-    #[deprecated = \"use iter_mut\"]\n-    pub fn mut_iter(&mut self) -> MutEntries<K, V> {\n-        self.iter_mut()\n-    }\n-\n     /// An iterator visiting all key-value pairs in arbitrary order,\n     /// with mutable references to the values.\n     /// Iterator element type is `(&'a K, &'a mut V)`.\n@@ -1307,12 +1035,6 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         MutEntries { inner: self.table.iter_mut() }\n     }\n \n-    /// Deprecated: use `into_iter`.\n-    #[deprecated = \"use into_iter\"]\n-    pub fn move_iter(self) -> MoveEntries<K, V> {\n-        self.into_iter()\n-    }\n-\n     /// Creates a consuming iterator, that is, one that moves each key-value\n     /// pair out of the map in arbitrary order. The map cannot be used after\n     /// calling this.\n@@ -1468,9 +1190,8 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H>\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Index<K, V> for HashMap<K, V, H> {\n     #[inline]\n-    #[allow(deprecated)]\n     fn index<'a>(&'a self, index: &K) -> &'a V {\n-        self.get(index)\n+        self.find(index).expect(\"no entry found for key\")\n     }\n }\n \n@@ -1929,29 +1650,6 @@ mod test_map {\n         assert_eq!(*m.find(&1).unwrap(), 2);\n     }\n \n-    #[test]\n-    #[allow(deprecated)] // insert_or_update_with\n-    fn test_update_with() {\n-        let mut m = HashMap::with_capacity(4);\n-        assert!(m.insert(1i, 2i));\n-\n-        for i in range(1i, 1000) {\n-            assert_eq!(\n-                i + 2,\n-                *m.insert_or_update_with(i + 1, i + 2, |_k, _v| {\n-                    fail!(\"Key not yet present\");\n-                })\n-            );\n-            assert_eq!(\n-                i + 1,\n-                *m.insert_or_update_with(i, i + 3, |k, v| {\n-                    assert_eq!(*k, i);\n-                    assert_eq!(*v, i + 1);\n-                })\n-            );\n-        }\n-    }\n-\n     #[test]\n     fn test_conflict_remove() {\n         let mut m = HashMap::with_capacity(4);"}, {"sha": "53e60d553be5f6ce0ba3297b25dcefcf00cabab9", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -85,13 +85,6 @@ impl UdpSocket {\n         }\n     }\n \n-    #[allow(missing_doc)]\n-    #[deprecated = \"renamed to `recv_from`\"]\n-    pub fn recvfrom(&mut self, buf: &mut [u8])\n-                    -> IoResult<(uint, SocketAddr)> {\n-        self.recv_from(buf)\n-    }\n-\n     /// Sends data on the socket to the given address. Returns nothing on\n     /// success.\n     pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n@@ -101,12 +94,6 @@ impl UdpSocket {\n         }).map_err(IoError::from_rtio_error)\n     }\n \n-    #[allow(missing_doc)]\n-    #[deprecated = \"renamed to `send_to`\"]\n-    pub fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n-        self.send_to(buf, dst)\n-    }\n-\n     /// Creates a `UdpStream`, which allows use of the `Reader` and `Writer`\n     /// traits to receive and send data from the same address. This transfers\n     /// ownership of the socket to the stream.\n@@ -176,12 +163,6 @@ impl UdpSocket {\n         }.map_err(IoError::from_rtio_error)\n     }\n \n-    /// Sets the broadcast flag on or off\n-    #[deprecated=\"renamed to `set_broadcast`\"]\n-    pub fn set_broadast(&mut self, broadcast: bool) -> IoResult<()> {\n-        self.set_broadcast(broadcast)\n-    }\n-\n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`"}, {"sha": "c47cd02599485ff5b40ba14c6def549fa4a518af", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -134,7 +134,6 @@ extern crate rustrt;\n #[cfg(test)] pub use realstd::kinds;\n #[cfg(test)] pub use realstd::ops;\n #[cfg(test)] pub use realstd::cmp;\n-#[cfg(test)] pub use realstd::ty;\n #[cfg(test)] pub use realstd::boxed;\n \n \n@@ -159,13 +158,10 @@ pub use core::tuple;\n // FIXME #15320: primitive documentation needs top-level modules, this\n // should be `std::tuple::unit`.\n pub use core::unit;\n-#[cfg(not(test))] pub use core::ty;\n pub use core::result;\n pub use core::option;\n \n pub use alloc::boxed;\n-#[deprecated = \"use boxed instead\"]\n-pub use boxed as owned;\n \n pub use alloc::rc;\n "}, {"sha": "3fa181b84787dd505d75eedcc31f7d808a61a4db", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -333,29 +333,6 @@ pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     r\n }\n \n-impl num::ToStrRadix for f32 {\n-    /// Converts a float to a string in a given radix\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * num - The float value\n-    /// * radix - The base to use\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n-    /// possible misinterpretation of the result at higher bases. If those values\n-    /// are expected, use `to_str_radix_special()` instead.\n-    #[inline]\n-    fn to_str_radix(&self, rdx: uint) -> String {\n-        let (r, special) = strconv::float_to_str_common(\n-            *self, rdx, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n-        if special { fail!(\"number has a special value, \\\n-                            try to_str_radix_special() if those are expected\") }\n-        r\n-    }\n-}\n-\n /// Convert a string in base 16 to a float.\n /// Accepts an optional binary exponent.\n ///"}, {"sha": "b9d54ba182b072cfc1bb84722db14111b7ca3f44", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -341,29 +341,6 @@ pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     r\n }\n \n-impl num::ToStrRadix for f64 {\n-    /// Converts a float to a string in a given radix\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * num - The float value\n-    /// * radix - The base to use\n-    ///\n-    /// # Failure\n-    ///\n-    /// Fails if called on a special value like `inf`, `-inf` or `NAN` due to\n-    /// possible misinterpretation of the result at higher bases. If those values\n-    /// are expected, use `to_str_radix_special()` instead.\n-    #[inline]\n-    fn to_str_radix(&self, rdx: uint) -> String {\n-        let (r, special) = strconv::float_to_str_common(\n-            *self, rdx, true, strconv::SignNeg, strconv::DigAll, strconv::ExpNone, false);\n-        if special { fail!(\"number has a special value, \\\n-                             try to_str_radix_special() if those are expected\") }\n-        r\n-    }\n-}\n-\n /// Convert a string in base 16 to a float.\n /// Accepts an optional binary exponent.\n ///"}, {"sha": "d7732b474dba808277a11ecf78a4b66b9faf5098", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"i16\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "778f1c6748c262a4a56c4139ddd6ee0055a6721c", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"i32\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "ae3d57eeac65db2e9616b70bda76879a0df5f749", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"i64\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "8a3f379893c24d3a278f0c18d8b76b5968e7e65c", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"i8\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "51af04b32d4fbf0e0411ff907e29b8facb3766fd", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"int\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::int::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "ca45b40e687a1d07bdb88dbe045ac6732441cfd6", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -51,52 +51,12 @@ impl FromStrRadix for $T {\n     }\n }\n \n-// String conversion functions and impl num -> str\n-\n-/// Convert to a string as a byte slice in a given base.\n-///\n-/// Use in place of x.to_string() when you do not need to store the string permanently\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![allow(deprecated)]\n-///\n-/// std::int::to_str_bytes(123, 10, |v| {\n-///     assert!(v == \"123\".as_bytes());\n-/// });\n-/// ```\n-#[inline]\n-#[deprecated = \"just use .to_string(), or a BufWriter with write! if you mustn't allocate\"]\n-pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n-    use io::{Writer, Seek};\n-    // The radix can be as low as 2, so we need at least 64 characters for a\n-    // base 2 number, and then we need another for a possible '-' character.\n-    let mut buf = [0u8, ..65];\n-    let amt = {\n-        let mut wr = ::io::BufWriter::new(buf);\n-        (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n-        wr.tell().unwrap() as uint\n-    };\n-    f(buf[..amt])\n-}\n-\n-#[deprecated = \"use fmt::radix\"]\n-impl ToStrRadix for $T {\n-    /// Convert to a string in a given base.\n-    #[inline]\n-    fn to_str_radix(&self, radix: uint) -> String {\n-        format!(\"{}\", ::fmt::radix(*self, radix as u8))\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n     use super::*;\n \n     use i32;\n-    use num::ToStrRadix;\n     use str::StrSlice;\n \n     #[test]\n@@ -142,16 +102,6 @@ mod tests {\n         assert!(parse_bytes(\"-9\".as_bytes(), 2u).is_none());\n     }\n \n-    #[test]\n-    fn test_to_string() {\n-        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_string());\n-        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_string());\n-        assert_eq!((-1 as $T).to_str_radix(10u), \"-1\".to_string());\n-        assert_eq!((127 as $T).to_str_radix(16u), \"7f\".to_string());\n-        assert_eq!((100 as $T).to_str_radix(10u), \"100\".to_string());\n-\n-    }\n-\n     #[test]\n     fn test_int_to_str_overflow() {\n         let mut i8_val: i8 = 127_i8;"}, {"sha": "564b6a25f7faf0d44b75cadebe81d15f68ccd2f8", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -17,7 +17,6 @@\n #![allow(missing_doc)]\n \n use option::Option;\n-use string::String;\n \n #[cfg(test)] use fmt::Show;\n \n@@ -111,12 +110,6 @@ pub trait FloatMath: Float {\n     fn atanh(self) -> Self;\n }\n \n-/// A generic trait for converting a value to a string with a radix (base)\n-#[deprecated = \"use fmt::radix\"]\n-pub trait ToStrRadix {\n-    fn to_str_radix(&self, radix: uint) -> String;\n-}\n-\n /// A generic trait for converting a string with a radix (base) to a value\n #[experimental = \"might need to return Result\"]\n pub trait FromStrRadix {"}, {"sha": "af66e6ca9349003891635ece3de9f761ec614592", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -20,7 +20,7 @@ use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n-use slice::{ImmutableSlice, MutableSlice};\n+use slice::{ImmutableSlice, MutableSlice, CloneableVector};\n use std::cmp::{PartialOrd, PartialEq};\n use str::StrSlice;\n use string::String;\n@@ -168,8 +168,7 @@ static NAN_BUF:     [u8, ..3] = [b'N', b'a', b'N'];\n  * # Failure\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n-#[deprecated = \"format!() and friends should be favored instead\"]\n-pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n+fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f: |u8|) {\n     assert!(2 <= radix && radix <= 36);\n \n     let _0: T = Zero::zero();\n@@ -257,7 +256,6 @@ pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f:\n  * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n  *   between digit and exponent sign `'p'`.\n  */\n-#[allow(deprecated)]\n pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n                                   Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n@@ -278,17 +276,17 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n     let _1: T = One::one();\n \n     match num.classify() {\n-        FPNaN => { return (Vec::from_slice(\"NaN\".as_bytes()), true); }\n+        FPNaN => { return (b\"NaN\".to_vec(), true); }\n         FPInfinite if num > _0 => {\n             return match sign {\n-                SignAll => (Vec::from_slice(\"+inf\".as_bytes()), true),\n-                _       => (Vec::from_slice(\"inf\".as_bytes()), true)\n+                SignAll => (b\"+inf\".to_vec(), true),\n+                _       => (b\"inf\".to_vec(), true)\n             };\n         }\n         FPInfinite if num < _0 => {\n             return match sign {\n-                SignNone => (Vec::from_slice(\"inf\".as_bytes()), true),\n-                _        => (Vec::from_slice(\"-inf\".as_bytes()), true),\n+                SignNone => (b\"inf\".to_vec(), true),\n+                _        => (b\"-inf\".to_vec(), true),\n             };\n         }\n         _ => {}\n@@ -413,18 +411,18 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || *buf.get(i as uint) == b'-'\n-                    || *buf.get(i as uint) == b'+' {\n+                    || buf[i as uint] == b'-'\n+                    || buf[i as uint] == b'+' {\n                         buf.insert((i + 1) as uint, value2ascii(1));\n                         break;\n                     }\n \n                     // Skip the '.'\n-                    if *buf.get(i as uint) == b'.' { i -= 1; continue; }\n+                    if buf[i as uint] == b'.' { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(*buf.get(i as uint));\n+                    let current_digit = ascii2value(buf[i as uint]);\n                     if current_digit < (radix - 1) {\n                         *buf.get_mut(i as uint) = value2ascii(current_digit+1);\n                         break;\n@@ -446,25 +444,25 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+PartialEq+PartialOrd+Float+\n         let mut i = buf_max_i;\n \n         // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && *buf.get(i) == b'0' {\n+        while i > start_fractional_digits && buf[i] == b'0' {\n             i -= 1;\n         }\n \n         // Only attempt to truncate digits if buf has fractional digits\n         if i >= start_fractional_digits {\n             // If buf ends with '.', cut that too.\n-            if *buf.get(i) == b'.' { i -= 1 }\n+            if buf[i] == b'.' { i -= 1 }\n \n             // only resize buf if we actually remove digits\n             if i < buf_max_i {\n-                buf = Vec::from_slice(buf.slice(0, i + 1));\n+                buf = buf.slice(0, i + 1).to_vec();\n             }\n         }\n     } // If exact and trailing '.', just cut that\n     else {\n         let max_i = buf.len() - 1;\n-        if *buf.get(max_i) == b'.' {\n-            buf = Vec::from_slice(buf.slice(0, max_i));\n+        if buf[max_i] == b'.' {\n+            buf = buf.slice(0, max_i).to_vec();\n         }\n     }\n "}, {"sha": "bb619b5b2f59542cc65134bc8f58315039f202aa", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"u16\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::u16::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "754103ba5dab214375613fd6d7566e6bdd293433", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"u32\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::u32::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "da497d2cbe470e6b98684159f2f1739aaa73cc3c", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"u64\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::u64::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "bdfcdb2c5a5bceaa15d8d4ae5f5a4d4c6dbb48ec", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"u8\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::u8::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "5090219d3de65ce4a2bd1011e0601246c7a214b5", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -14,10 +14,9 @@\n #![doc(primitive = \"uint\")]\n \n use from_str::FromStr;\n-use num::{ToStrRadix, FromStrRadix};\n+use num::FromStrRadix;\n use num::strconv;\n use option::Option;\n-use string::String;\n \n pub use core::uint::{BITS, BYTES, MIN, MAX};\n "}, {"sha": "f9bc9eb539a13fed59f7ca0693b314a25dd1b505", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -82,35 +82,14 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n     f(buf[..amt])\n }\n \n-#[deprecated = \"use fmt::radix\"]\n-impl ToStrRadix for $T {\n-    /// Convert to a string in a given base.\n-    #[inline]\n-    fn to_str_radix(&self, radix: uint) -> String {\n-        format!(\"{}\", ::fmt::radix(*self, radix as u8))\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n     use super::*;\n \n-    use num::ToStrRadix;\n     use str::StrSlice;\n     use u16;\n \n-    #[test]\n-    pub fn test_to_string() {\n-        assert_eq!((0 as $T).to_str_radix(10u), \"0\".to_string());\n-        assert_eq!((1 as $T).to_str_radix(10u), \"1\".to_string());\n-        assert_eq!((2 as $T).to_str_radix(10u), \"2\".to_string());\n-        assert_eq!((11 as $T).to_str_radix(10u), \"11\".to_string());\n-        assert_eq!((11 as $T).to_str_radix(16u), \"b\".to_string());\n-        assert_eq!((255 as $T).to_str_radix(16u), \"ff\".to_string());\n-        assert_eq!((0xff as $T).to_str_radix(10u), \"255\".to_string());\n-    }\n-\n     #[test]\n     pub fn test_from_str() {\n         assert_eq!(from_str::<$T>(\"0\"), Some(0u as $T));\n@@ -199,18 +178,6 @@ mod tests {\n         assert_eq!(from_str::<u64>(\"0\"), Some(u64_val));\n         assert!(from_str::<u64>(\"-1\").is_none());\n     }\n-\n-    #[test]\n-    #[should_fail]\n-    pub fn to_str_radix1() {\n-        100u.to_str_radix(1u);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    pub fn to_str_radix37() {\n-        100u.to_str_radix(37u);\n-    }\n }\n \n ))"}, {"sha": "38e1e952f77e275bf7505c269dc4100e13c403c3", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -26,9 +26,6 @@ pub use core_sync::{RWLock, RWLockReadGuard, RWLockWriteGuard};\n pub use core_sync::{Semaphore, SemaphoreGuard};\n pub use core_sync::one::{Once, ONCE_INIT};\n \n-#[deprecated = \"use atomic instead\"]\n-pub use core_sync::atomic as atomics;\n-\n pub use self::future::Future;\n pub use self::task_pool::TaskPool;\n "}, {"sha": "1d1e6ae4febfdc8f8ffb514c41a8ca83b8d8bc62", "filename": "src/libstd/task.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -225,26 +225,6 @@ impl<S: Spawner> TaskBuilder<S> {\n         }\n     }\n \n-    /// Add a wrapper to the body of the spawned task.\n-    ///\n-    /// Before the task is spawned it is passed through a 'body generator'\n-    /// function that may perform local setup operations as well as wrap\n-    /// the task body in remote setup operations. With this the behavior\n-    /// of tasks can be extended in simple ways.\n-    ///\n-    /// This function augments the current body generator with a new body\n-    /// generator by applying the task body which results from the\n-    /// existing body generator to the new body generator.\n-    #[deprecated = \"this function will be removed soon\"]\n-    pub fn with_wrapper(mut self, wrapper: proc(v: proc():Send):Send -> proc():Send)\n-                        -> TaskBuilder<S> {\n-        self.gen_body = match self.gen_body.take() {\n-            Some(prev) => Some(proc(body) { wrapper(prev(body)) }),\n-            None => Some(wrapper)\n-        };\n-        self\n-    }\n-\n     // Where spawning actually happens (whether yielding a future or not)\n     fn spawn_internal(self, f: proc():Send,\n                       on_exit: Option<proc(Result<(), Box<Any + Send>>):Send>) {\n@@ -353,18 +333,6 @@ pub fn try_future<T:Send>(f: proc():Send -> T) -> Future<Result<T, Box<Any + Sen\n \n /* Lifecycle functions */\n \n-/// Read the name of the current task.\n-#[deprecated = \"Use `task::name()`.\"]\n-pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n-    use rt::task::Task;\n-\n-    let task = Local::borrow(None::<Task>);\n-    match task.name {\n-        Some(ref name) => blk(Some(name.as_slice())),\n-        None => blk(None)\n-    }\n-}\n-\n /// Read the name of the current task.\n #[stable]\n pub fn name() -> Option<String> {\n@@ -446,20 +414,6 @@ mod test {\n         rx.recv();\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_with_wrapper() {\n-        let (tx, rx) = channel();\n-        TaskBuilder::new().with_wrapper(proc(body) {\n-            let result: proc():Send = proc() {\n-                body();\n-                tx.send(());\n-            };\n-            result\n-        }).spawn(proc() { });\n-        rx.recv();\n-    }\n-\n     #[test]\n     fn test_try_future() {\n         let result = TaskBuilder::new().try_future(proc() {});"}, {"sha": "1dc1f4b87f27cbdf2f2babfb810ac90f43072789", "filename": "src/libsync/comm/duplex.rs", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibsync%2Fcomm%2Fduplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibsync%2Fcomm%2Fduplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fduplex.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,78 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Higher level communication abstractions.\n-\n-*/\n-\n-#![allow(missing_doc)]\n-#![allow(deprecated)]\n-#![deprecated = \"This type is replaced by having a pair of channels. This type \\\n-                 is not fully composable with other channels in terms of \\\n-                 or possible semantics on a duplex stream. It will be removed \\\n-                 soon\"]\n-\n-use core::prelude::*;\n-\n-use comm;\n-use comm::{Sender, Receiver, channel};\n-\n-/// An extension of `pipes::stream` that allows both sending and receiving.\n-pub struct DuplexStream<S, R> {\n-    tx: Sender<S>,\n-    rx: Receiver<R>,\n-}\n-\n-/// Creates a bidirectional stream.\n-pub fn duplex<S: Send, R: Send>() -> (DuplexStream<S, R>, DuplexStream<R, S>) {\n-    let (tx1, rx1) = channel();\n-    let (tx2, rx2) = channel();\n-    (DuplexStream { tx: tx1, rx: rx2 },\n-     DuplexStream { tx: tx2, rx: rx1 })\n-}\n-\n-// Allow these methods to be used without import:\n-impl<S:Send,R:Send> DuplexStream<S, R> {\n-    pub fn send(&self, x: S) {\n-        self.tx.send(x)\n-    }\n-    pub fn send_opt(&self, x: S) -> Result<(), S> {\n-        self.tx.send_opt(x)\n-    }\n-    pub fn recv(&self) -> R {\n-        self.rx.recv()\n-    }\n-    pub fn try_recv(&self) -> Result<R, comm::TryRecvError> {\n-        self.rx.try_recv()\n-    }\n-    pub fn recv_opt(&self) -> Result<R, ()> {\n-        self.rx.recv_opt()\n-    }\n-}\n-\n-#[allow(deprecated)]\n-#[cfg(test)]\n-mod test {\n-    use std::prelude::*;\n-    use comm::duplex;\n-\n-    #[test]\n-    pub fn duplex_stream_1() {\n-        let (left, right) = duplex();\n-\n-        left.send(\"abc\".to_string());\n-        right.send(123i);\n-\n-        assert!(left.recv() == 123);\n-        assert!(right.recv() == \"abc\".to_string());\n-    }\n-}"}, {"sha": "ddfd1088a41a844e8537b8074f8811796dc8c9e7", "filename": "src/libsync/comm/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsync%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsync%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -333,7 +333,6 @@ use rustrt::local::Local;\n use rustrt::task::{Task, BlockedTask};\n \n pub use comm::select::{Select, Handle};\n-pub use comm::duplex::{DuplexStream, duplex};\n \n macro_rules! test (\n     { fn $name:ident() $b:block $(#[$a:meta])*} => (\n@@ -354,14 +353,13 @@ macro_rules! test (\n             $(#[$a])* #[test] fn native() {\n                 use native;\n                 let (tx, rx) = channel();\n-                native::task::spawn(proc() { tx.send(f()) });\n+                spawn(proc() { tx.send(f()) });\n                 rx.recv();\n             }\n         }\n     )\n )\n \n-mod duplex;\n mod oneshot;\n mod select;\n mod shared;\n@@ -1064,7 +1062,6 @@ impl<T: Send> Drop for Receiver<T> {\n mod test {\n     use std::prelude::*;\n \n-    use native;\n     use std::os;\n     use super::*;\n \n@@ -1224,7 +1221,7 @@ mod test {\n             tx3.send(());\n         });\n         rx1.recv();\n-        native::task::spawn(proc() {\n+        spawn(proc() {\n             for _ in range(0i, 40) {\n                 tx2.send(1);\n             }\n@@ -1238,7 +1235,7 @@ mod test {\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<int>();\n         let (dtx, drx) = channel();\n-        native::task::spawn(proc() {\n+        spawn(proc() {\n             for _ in range(0i, 40) {\n                 assert_eq!(rx.recv(), 1);\n             }\n@@ -1256,12 +1253,12 @@ mod test {\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n         let tx4 = tx3.clone();\n-        native::task::spawn(proc() {\n+        spawn(proc() {\n             assert_eq!(rx1.recv(), 1);\n             tx2.send(2);\n             tx4.send(());\n         });\n-        native::task::spawn(proc() {\n+        spawn(proc() {\n             tx1.send(1);\n             assert_eq!(rx2.recv(), 2);\n             tx3.send(());"}, {"sha": "b3b504f49ca3a84680da298c1cf0cdf3315e6beb", "filename": "src/libsync/mpmc_bounded_queue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpmc_bounded_queue.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -167,7 +167,6 @@ impl<T: Send> Clone for Queue<T> {\n mod tests {\n     use std::prelude::*;\n     use super::Queue;\n-    use native;\n \n     #[test]\n     fn test() {\n@@ -180,7 +179,7 @@ mod tests {\n         for _ in range(0, nthreads) {\n             let q = q.clone();\n             let tx = tx.clone();\n-            native::task::spawn(proc() {\n+            spawn(proc() {\n                 let q = q;\n                 for i in range(0, nmsgs) {\n                     assert!(q.push(i));\n@@ -194,7 +193,7 @@ mod tests {\n             let (tx, rx) = channel();\n             completion_rxs.push(rx);\n             let q = q.clone();\n-            native::task::spawn(proc() {\n+            spawn(proc() {\n                 let q = q;\n                 let mut i = 0u;\n                 loop {"}, {"sha": "ac2acf3d7d4d2f0770f749e7814347e4ddda5291", "filename": "src/libsync/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmpsc_queue.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -161,7 +161,6 @@ mod tests {\n \n     use alloc::arc::Arc;\n \n-    use native;\n     use super::{Queue, Data, Empty, Inconsistent};\n \n     #[test]\n@@ -186,7 +185,7 @@ mod tests {\n         for _ in range(0, nthreads) {\n             let tx = tx.clone();\n             let q = q.clone();\n-            native::task::spawn(proc() {\n+            spawn(proc() {\n                 for i in range(0, nmsgs) {\n                     q.push(i);\n                 }"}, {"sha": "7d191eab2d1578b5ef441b3596ad37a082676f0b", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -525,7 +525,6 @@ impl Drop for Mutex {\n mod test {\n     use std::prelude::*;\n     use super::{Mutex, StaticMutex, MUTEX_INIT};\n-    use native;\n \n     #[test]\n     fn smoke() {\n@@ -563,7 +562,7 @@ mod test {\n         let (tx, rx) = channel();\n         for _ in range(0, K) {\n             let tx2 = tx.clone();\n-            native::task::spawn(proc() { inc(); tx2.send(()); });\n+            spawn(proc() { inc(); tx2.send(()); });\n             let tx2 = tx.clone();\n             spawn(proc() { inc(); tx2.send(()); });\n         }"}, {"sha": "9cd64d46bad85e5175ffa37a17dd0ab3d59150f9", "filename": "src/libsync/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fspsc_queue.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -296,8 +296,6 @@ impl<T: Send> Drop for Queue<T> {\n mod test {\n     use std::prelude::*;\n \n-    use native;\n-\n     use super::{queue};\n \n     #[test]\n@@ -364,7 +362,7 @@ mod test {\n             let (consumer, mut producer) = queue(bound);\n \n             let (tx, rx) = channel();\n-            native::task::spawn(proc() {\n+            spawn(proc() {\n                 // Move the consumer to a local mutable slot\n                 let mut consumer = consumer;\n                 for _ in range(0u, 100000) {"}, {"sha": "60e4db405d7663507e88fb1a79b9f911d2d717a0", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -699,8 +699,12 @@ struct NodeCollector<'ast> {\n \n impl<'ast> NodeCollector<'ast> {\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n-        self.map.grow_set(id as uint, &NotPresent, entry);\n         debug!(\"ast_map: {} => {}\", id, entry);\n+        let len = self.map.len();\n+        if id as uint >= len {\n+            self.map.grow(id as uint - len + 1, NotPresent);\n+        }\n+        *self.map.get_mut(id as uint) = entry;\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {"}, {"sha": "5626f0a8ad962ccc6588d13588f24df2b5d7a7be", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -202,7 +202,7 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     let mut pretty = pprust::ty_to_string(ty);\n     match *trait_ref {\n         Some(ref trait_ref) => {\n-            pretty.push_char('.');\n+            pretty.push('.');\n             pretty.push_str(pprust::path_to_string(&trait_ref.path).as_slice());\n         }\n         None => {}"}, {"sha": "4df334a3f2c70cbee997387aba9f67c6f053466e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -283,17 +283,17 @@ impl FileMap {\n     /// filemap.start_pos + newline_offset_relative_to_the_start_of_filemap.\n     pub fn next_line(&self, pos: BytePos) {\n         // the new charpos must be > the last one (or it's the first one).\n-        let mut lines = self.lines.borrow_mut();;\n+        let mut lines = self.lines.borrow_mut();\n         let line_len = lines.len();\n-        assert!(line_len == 0 || (*lines.get(line_len - 1) < pos))\n+        assert!(line_len == 0 || ((*lines)[line_len - 1] < pos))\n         lines.push(pos);\n     }\n \n     /// get a line from the list of pre-computed line-beginnings\n     ///\n     pub fn get_line(&self, line: int) -> String {\n         let lines = self.lines.borrow();\n-        let begin: BytePos = *lines.get(line as uint) - self.start_pos;\n+        let begin: BytePos = (*lines)[line as uint] - self.start_pos;\n         let begin = begin.to_uint();\n         let slice = self.src.as_slice().slice_from(begin);\n         match slice.find('\\n') {\n@@ -351,7 +351,7 @@ impl CodeMap {\n         // overflowing into the next filemap in case the last byte of span is also the last\n         // byte of filemap, which leads to incorrect results from CodeMap.span_to_*.\n         if src.len() > 0 && !src.as_slice().ends_with(\"\\n\") {\n-            src.push_char('\\n');\n+            src.push('\\n');\n         }\n \n         let filemap = Rc::new(FileMap {\n@@ -446,7 +446,7 @@ impl CodeMap {\n \n     pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n-        let fm = self.files.borrow().get(idx).clone();\n+        let fm = (*self.files.borrow())[idx].clone();\n         let offset = bpos - fm.start_pos;\n         FileMapAndBytePos {fm: fm, pos: offset}\n     }\n@@ -455,7 +455,7 @@ impl CodeMap {\n     pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let files = self.files.borrow();\n-        let map = files.get(idx);\n+        let map = &(*files)[idx];\n \n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n@@ -480,34 +480,37 @@ impl CodeMap {\n \n     fn lookup_filemap_idx(&self, pos: BytePos) -> uint {\n         let files = self.files.borrow();\n-        let files = files;\n+        let files = &*files;\n         let len = files.len();\n         let mut a = 0u;\n         let mut b = len;\n         while b - a > 1u {\n             let m = (a + b) / 2u;\n-            if files.get(m).start_pos > pos {\n+            if files[m].start_pos > pos {\n                 b = m;\n             } else {\n                 a = m;\n             }\n         }\n-        // There can be filemaps with length 0. These have the same start_pos as the previous\n-        // filemap, but are not the filemaps we want (because they are length 0, they cannot\n-        // contain what we are looking for). So, rewind until we find a useful filemap.\n+        // There can be filemaps with length 0. These have the same start_pos as\n+        // the previous filemap, but are not the filemaps we want (because they\n+        // are length 0, they cannot contain what we are looking for). So,\n+        // rewind until we find a useful filemap.\n         loop {\n-            let lines = files.get(a).lines.borrow();\n+            let lines = files[a].lines.borrow();\n             let lines = lines;\n             if lines.len() > 0 {\n                 break;\n             }\n             if a == 0 {\n-                fail!(\"position {} does not resolve to a source location\", pos.to_uint());\n+                fail!(\"position {} does not resolve to a source location\",\n+                      pos.to_uint());\n             }\n             a -= 1;\n         }\n         if a >= len {\n-            fail!(\"position {} does not resolve to a source location\", pos.to_uint())\n+            fail!(\"position {} does not resolve to a source location\",\n+                  pos.to_uint())\n         }\n \n         return a;\n@@ -517,14 +520,14 @@ impl CodeMap {\n         let idx = self.lookup_filemap_idx(pos);\n \n         let files = self.files.borrow();\n-        let f = files.get(idx).clone();\n+        let f = (*files)[idx].clone();\n         let mut a = 0u;\n         {\n             let lines = f.lines.borrow();\n             let mut b = lines.len();\n             while b - a > 1u {\n                 let m = (a + b) / 2u;\n-                if *lines.get(m) > pos { b = m; } else { a = m; }\n+                if (*lines)[m] > pos { b = m; } else { a = m; }\n             }\n         }\n         FileMapAndLine {fm: f, line: a}\n@@ -534,7 +537,7 @@ impl CodeMap {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n         let chpos = self.bytepos_to_file_charpos(pos);\n-        let linebpos = *f.lines.borrow().get(a);\n+        let linebpos = (*f.lines.borrow())[a];\n         let linechpos = self.bytepos_to_file_charpos(linebpos);\n         debug!(\"byte pos {} is on the line at byte pos {}\",\n                pos, linebpos);\n@@ -704,7 +707,7 @@ mod test {\n \n         assert_eq!(file_lines.file.name, \"blork.rs\".to_string());\n         assert_eq!(file_lines.lines.len(), 1);\n-        assert_eq!(*file_lines.lines.get(0), 1u);\n+        assert_eq!(file_lines.lines[0], 1u);\n     }\n \n     #[test]"}, {"sha": "67605360a48cb665d1b4621aca5650012f4b174f", "filename": "src/libsyntax/crateid.rs", "status": "removed", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibsyntax%2Fcrateid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibsyntax%2Fcrateid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcrateid.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,216 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::fmt;\n-\n-/// CrateIds identify crates and include the crate name and optionally a path\n-/// and version. In the full form, they look like relative URLs. Example:\n-/// `github.com/rust-lang/rust#std:1.0` would be a package ID with a path of\n-/// `github.com/rust-lang/rust` and a crate name of `std` with a version of\n-/// `1.0`. If no crate name is given after the hash, the name is inferred to\n-/// be the last component of the path. If no version is given, it is inferred\n-/// to be `0.0`.\n-\n-use std::from_str::FromStr;\n-\n-#[deriving(Clone, PartialEq)]\n-pub struct CrateId {\n-    /// A path which represents the codes origin. By convention this is the\n-    /// URL, without `http://` or `https://` prefix, to the crate's repository\n-    pub path: String,\n-    /// The name of the crate.\n-    pub name: String,\n-    /// The version of the crate.\n-    pub version: Option<String>,\n-}\n-\n-impl fmt::Show for CrateId {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}\", self.path));\n-        let version = match self.version {\n-            None => \"0.0\",\n-            Some(ref version) => version.as_slice(),\n-        };\n-        if self.path == self.name ||\n-                self.path\n-                    .as_slice()\n-                    .ends_with(format!(\"/{}\", self.name).as_slice()) {\n-            write!(f, \"#{}\", version)\n-        } else {\n-            write!(f, \"#{}:{}\", self.name, version)\n-        }\n-    }\n-}\n-\n-impl FromStr for CrateId {\n-    fn from_str(s: &str) -> Option<CrateId> {\n-        let pieces: Vec<&str> = s.splitn(1, '#').collect();\n-        let path = pieces.get(0).to_string();\n-\n-        if path.as_slice().starts_with(\"/\") || path.as_slice().ends_with(\"/\") ||\n-            path.as_slice().starts_with(\".\") || path.is_empty() {\n-            return None;\n-        }\n-\n-        let path_pieces: Vec<&str> = path.as_slice()\n-                                         .rsplitn(1, '/')\n-                                         .collect();\n-        let inferred_name = *path_pieces.get(0);\n-\n-        let (name, version) = if pieces.len() == 1 {\n-            (inferred_name.to_string(), None)\n-        } else {\n-            let hash_pieces: Vec<&str> = pieces.get(1)\n-                                               .splitn(1, ':')\n-                                               .collect();\n-            let (hash_name, hash_version) = if hash_pieces.len() == 1 {\n-                (\"\", *hash_pieces.get(0))\n-            } else {\n-                (*hash_pieces.get(0), *hash_pieces.get(1))\n-            };\n-\n-            let name = if !hash_name.is_empty() {\n-                hash_name.to_string()\n-            } else {\n-                inferred_name.to_string()\n-            };\n-\n-            let version = if !hash_version.is_empty() {\n-                if hash_version == \"0.0\" {\n-                    None\n-                } else {\n-                    Some(hash_version.to_string())\n-                }\n-            } else {\n-                None\n-            };\n-\n-            (name, version)\n-        };\n-\n-        Some(CrateId {\n-            path: path.to_string(),\n-            name: name,\n-            version: version,\n-        })\n-    }\n-}\n-\n-impl CrateId {\n-    pub fn version_or_default<'a>(&'a self) -> &'a str {\n-        match self.version {\n-            None => \"0.0\",\n-            Some(ref version) => version.as_slice(),\n-        }\n-    }\n-\n-    pub fn short_name_with_version(&self) -> String {\n-        format!(\"{}-{}\", self.name, self.version_or_default())\n-    }\n-\n-    pub fn matches(&self, other: &CrateId) -> bool {\n-        // FIXME: why does this not match on `path`?\n-        if self.name != other.name { return false }\n-        match (&self.version, &other.version) {\n-            (&Some(ref v1), &Some(ref v2)) => v1 == v2,\n-            _ => true,\n-        }\n-    }\n-}\n-\n-#[test]\n-fn bare_name() {\n-    let crateid: CrateId = from_str(\"foo\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"foo\".to_string());\n-    assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, \"foo\".to_string());\n-}\n-\n-#[test]\n-fn bare_name_single_char() {\n-    let crateid: CrateId = from_str(\"f\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"f\".to_string());\n-    assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, \"f\".to_string());\n-}\n-\n-#[test]\n-fn empty_crateid() {\n-    let crateid: Option<CrateId> = from_str(\"\");\n-    assert!(crateid.is_none());\n-}\n-\n-#[test]\n-fn simple_path() {\n-    let crateid: CrateId = from_str(\"example.com/foo/bar\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"bar\".to_string());\n-    assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, \"example.com/foo/bar\".to_string());\n-}\n-\n-#[test]\n-fn simple_version() {\n-    let crateid: CrateId = from_str(\"foo#1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"foo\".to_string());\n-    assert_eq!(crateid.version, Some(\"1.0\".to_string()));\n-    assert_eq!(crateid.path, \"foo\".to_string());\n-}\n-\n-#[test]\n-fn absolute_path() {\n-    let crateid: Option<CrateId> = from_str(\"/foo/bar\");\n-    assert!(crateid.is_none());\n-}\n-\n-#[test]\n-fn path_ends_with_slash() {\n-    let crateid: Option<CrateId> = from_str(\"foo/bar/\");\n-    assert!(crateid.is_none());\n-}\n-\n-#[test]\n-fn path_and_version() {\n-    let crateid: CrateId = from_str(\"example.com/foo/bar#1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"bar\".to_string());\n-    assert_eq!(crateid.version, Some(\"1.0\".to_string()));\n-    assert_eq!(crateid.path, \"example.com/foo/bar\".to_string());\n-}\n-\n-#[test]\n-fn single_chars() {\n-    let crateid: CrateId = from_str(\"a/b#1\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"b\".to_string());\n-    assert_eq!(crateid.version, Some(\"1\".to_string()));\n-    assert_eq!(crateid.path, \"a/b\".to_string());\n-}\n-\n-#[test]\n-fn missing_version() {\n-    let crateid: CrateId = from_str(\"foo#\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"foo\".to_string());\n-    assert_eq!(crateid.version, None);\n-    assert_eq!(crateid.path, \"foo\".to_string());\n-}\n-\n-#[test]\n-fn path_and_name() {\n-    let crateid: CrateId = from_str(\"foo/rust-bar#bar:1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"bar\".to_string());\n-    assert_eq!(crateid.version, Some(\"1.0\".to_string()));\n-    assert_eq!(crateid.path, \"foo/rust-bar\".to_string());\n-}\n-\n-#[test]\n-fn empty_name() {\n-    let crateid: CrateId = from_str(\"foo/bar#:1.0\").expect(\"valid crateid\");\n-    assert_eq!(crateid.name, \"bar\".to_string());\n-    assert_eq!(crateid.version, Some(\"1.0\".to_string()));\n-    assert_eq!(crateid.path, \"foo/bar\".to_string());\n-}"}, {"sha": "3da1b1f3175f273bda78c6c4d6ec84246ace6d70", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -446,7 +446,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     if lines.lines.len() == 1u {\n         let lo = cm.lookup_char_pos(sp.lo);\n         let mut digits = 0u;\n-        let mut num = (*lines.lines.get(0) + 1u) / 10u;\n+        let mut num = (lines.lines[0] + 1u) / 10u;\n \n         // how many digits must be indent past?\n         while num > 0u { num /= 10u; digits += 1u; }\n@@ -458,18 +458,18 @@ fn highlight_lines(err: &mut EmitterWriter,\n         // part of the 'filename:line ' part of the previous line.\n         let skip = fm.name.len() + digits + 3u;\n         for _ in range(0, skip) {\n-            s.push_char(' ');\n+            s.push(' ');\n         }\n-        let orig = fm.get_line(*lines.lines.get(0) as int);\n+        let orig = fm.get_line(lines.lines[0] as int);\n         for pos in range(0u, left-skip) {\n             let cur_char = orig.as_bytes()[pos] as char;\n             // Whenever a tab occurs on the previous line, we insert one on\n             // the error-point-squiggly-line as well (instead of a space).\n             // That way the squiggly line will usually appear in the correct\n             // position.\n             match cur_char {\n-                '\\t' => s.push_char('\\t'),\n-                _ => s.push_char(' '),\n+                '\\t' => s.push('\\t'),\n+                _ => s.push(' '),\n             };\n         }\n         try!(write!(&mut err.dst, \"{}\", s));\n@@ -479,7 +479,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n             // the ^ already takes up one space\n             let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n             for _ in range(0, num_squigglies) {\n-                s.push_char('~');\n+                s.push('~');\n             }\n         }\n         try!(print_maybe_styled(err,\n@@ -523,10 +523,10 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n     let skip = last_line_start.len() + hi.col.to_uint() - 1;\n     let mut s = String::new();\n     for _ in range(0, skip) {\n-        s.push_char(' ');\n+        s.push(' ');\n     }\n-    s.push_char('^');\n-    s.push_char('\\n');\n+    s.push('^');\n+    s.push('\\n');\n     print_maybe_styled(w,\n                        s.as_slice(),\n                        term::attr::ForegroundColor(lvl.color()))"}, {"sha": "5cc2fe03618c46b25df24d5b333d26340f2771fe", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -495,7 +495,7 @@ impl<'a> ExtCtxt<'a> {\n \n     pub fn new_parser_from_tts(&self, tts: &[ast::TokenTree])\n         -> parser::Parser<'a> {\n-        parse::tts_to_parser(self.parse_sess, Vec::from_slice(tts), self.cfg())\n+        parse::tts_to_parser(self.parse_sess, tts.to_vec(), self.cfg())\n     }\n \n     pub fn codemap(&self) -> &'a CodeMap { &self.parse_sess.span_diagnostic.cm }"}, {"sha": "437efbf96f8589f49d0d0a1f2f86b10709420e40", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -618,7 +618,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                         ident: ast::Ident,\n                         mut args: Vec<P<ast::Expr>> ) -> P<ast::Expr> {\n         let id = Spanned { node: ident, span: span };\n-        args.unshift(expr);\n+        args.insert(0, expr);\n         self.expr(span, ast::ExprMethodCall(id, Vec::new(), args))\n     }\n     fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {"}, {"sha": "af7cd4157ecbc75fe67a037a182cdc916a8bfba2", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -35,7 +35,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                         accumulator.push_str(s.get());\n                     }\n                     ast::LitChar(c) => {\n-                        accumulator.push_char(c);\n+                        accumulator.push(c);\n                     }\n                     ast::LitInt(i, ast::UnsignedIntLit(_)) |\n                     ast::LitInt(i, ast::SignedIntLit(_, ast::Plus)) |"}, {"sha": "9748b5313457706587a0aee27f16e59415c6f652", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -80,7 +80,7 @@ fn cs_clone(\n         }\n     }\n \n-    if all_fields.len() >= 1 && all_fields.get(0).name.is_none() {\n+    if all_fields.len() >= 1 && all_fields[0].name.is_none() {\n         // enum-like\n         let subcalls = all_fields.iter().map(subcall).collect();\n         cx.expr_call_ident(trait_span, ctor_ident, subcalls)"}, {"sha": "2310a4460e26883882ffabfc273a480d37545dd3", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -447,10 +447,12 @@ impl<'a> TraitDef<'a> {\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n         let ident = ast_util::impl_pretty_name(&opt_trait_ref, &*self_type);\n+        let mut a = vec![attr];\n+        a.extend(self.attributes.iter().map(|a| a.clone()));\n         cx.item(\n             self.span,\n             ident,\n-            (vec!(attr)).append(self.attributes.as_slice()),\n+            a,\n             ast::ItemImpl(trait_generics,\n                           opt_trait_ref,\n                           self_type,\n@@ -943,8 +945,8 @@ impl<'a> MethodDef<'a> {\n                         // of them (using `field_index` tracked above).\n                         // That is the heart of the transposition.\n                         let others = self_pats_idents.iter().map(|fields| {\n-                            let &(_, _opt_ident, ref other_getter_expr) =\n-                                fields.get(field_index);\n+                            let (_, _opt_ident, ref other_getter_expr) =\n+                                fields[field_index];\n \n                             // All Self args have same variant, so\n                             // opt_idents are the same.  (Assert"}, {"sha": "322a84eaa2be0daa3c15f507f3a240aca92226f0", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -80,7 +80,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         EnumMatching(_, _, ref fields) if fields.len() == 0 => {}\n \n         Struct(ref fields) | EnumMatching(_, _, ref fields) => {\n-            if fields.get(0).name.is_none() {\n+            if fields[0].name.is_none() {\n                 // tuple struct/\"normal\" variant\n \n                 format_string.push_str(\"(\");"}, {"sha": "39b710e0d5725779a8ce1348d5bc1769b730e7c7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -165,7 +165,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n             arms.push(pat_arm);\n-            arms.push_all_move(else_if_arms);\n+            arms.extend(else_if_arms.into_iter());\n             arms.push(else_arm);\n \n             let match_expr = fld.cx.expr(span, ast::ExprMatch(expr, arms, ast::MatchIfLetDesugar));\n@@ -257,7 +257,7 @@ fn expand_mac_invoc<T>(mac: ast::Mac, span: codemap::Span,\n                 // let compilation continue\n                 return None;\n             }\n-            let extname = pth.segments.get(0).identifier;\n+            let extname = pth.segments[0].identifier;\n             let extnamestr = token::get_ident(extname);\n             match fld.cx.syntax_env.find(&extname.name) {\n                 None => {\n@@ -505,7 +505,7 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n             node: MacInvocTT(ref pth, ref tts, _),\n             ..\n         }) => {\n-            (pth.segments.get(0).identifier, pth.span, (*tts).clone())\n+            (pth.segments[0].identifier, pth.span, (*tts).clone())\n         }\n         _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n@@ -695,7 +695,8 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                         rename_fld.fold_pat(expanded_pat)\n                     };\n                     // add them to the existing pending renames:\n-                    fld.cx.syntax_env.info().pending_renames.push_all_move(new_pending_renames);\n+                    fld.cx.syntax_env.info().pending_renames\n+                          .extend(new_pending_renames.into_iter());\n                     Local {\n                         id: id,\n                         ty: expanded_ty,\n@@ -744,7 +745,7 @@ fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     }\n     // all of the pats must have the same set of bindings, so use the\n     // first one to extract them and generate new names:\n-    let idents = pattern_bindings(&**expanded_pats.get(0));\n+    let idents = pattern_bindings(&*expanded_pats[0]);\n     let new_renames = idents.into_iter().map(|id| (id, fresh_name(&id))).collect();\n     // apply the renaming, but only to the PatIdents:\n     let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n@@ -860,7 +861,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n             return DummyResult::raw_pat(span);\n         }\n-        let extname = pth.segments.get(0).identifier;\n+        let extname = pth.segments[0].identifier;\n         let extnamestr = token::get_ident(extname);\n         let marked_after = match fld.cx.syntax_env.find(&extname.name) {\n             None => {\n@@ -1022,7 +1023,7 @@ fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<as\n             };\n \n             // expand again if necessary\n-            let new_methods = new_methods.move_iter()\n+            let new_methods = new_methods.into_iter()\n                                   .flat_map(|m| fld.fold_method(m).into_iter()).collect();\n             fld.cx.bt_pop();\n             new_methods\n@@ -1610,8 +1611,8 @@ mod test {\n         // must be one check clause for each binding:\n         assert_eq!(bindings.len(),bound_connections.len());\n         for (binding_idx,shouldmatch) in bound_connections.iter().enumerate() {\n-            let binding_name = mtwt::resolve(*bindings.get(binding_idx));\n-            let binding_marks = mtwt::marksof(bindings.get(binding_idx).ctxt, invalid_name);\n+            let binding_name = mtwt::resolve(bindings[binding_idx]);\n+            let binding_marks = mtwt::marksof(bindings[binding_idx].ctxt, invalid_name);\n             // shouldmatch can't name varrefs that don't exist:\n             assert!((shouldmatch.len() == 0) ||\n                     (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n@@ -1630,16 +1631,15 @@ mod test {\n                     let string = token::get_ident(final_varref_ident);\n                     println!(\"varref's first segment's string: \\\"{}\\\"\", string.get());\n                     println!(\"binding #{}: {}, resolves to {}\",\n-                             binding_idx, *bindings.get(binding_idx), binding_name);\n+                             binding_idx, bindings[binding_idx], binding_name);\n                     mtwt::with_sctable(|x| mtwt::display_sctable(x));\n                 };\n                 if shouldmatch.contains(&idx) {\n                     // it should be a path of length 1, and it should\n                     // be free-identifier=? or bound-identifier=? to the given binding\n                     assert_eq!(varref.segments.len(),1);\n-                    let varref_name = mtwt::resolve(varref.segments.get(0).identifier);\n-                    let varref_marks = mtwt::marksof(varref.segments\n-                                                           .get(0)\n+                    let varref_name = mtwt::resolve(varref.segments[0].identifier);\n+                    let varref_marks = mtwt::marksof(varref.segments[0]\n                                                            .identifier\n                                                            .ctxt,\n                                                      invalid_name);\n@@ -1654,7 +1654,7 @@ mod test {\n                         assert_eq!(varref_marks,binding_marks.clone());\n                     }\n                 } else {\n-                    let varref_name = mtwt::resolve(varref.segments.get(0).identifier);\n+                    let varref_name = mtwt::resolve(varref.segments[0].identifier);\n                     let fail = (varref.segments.len() == 1)\n                         && (varref_name == binding_name);\n                     // temp debugging:\n@@ -1696,19 +1696,19 @@ foo_module!()\n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p| {\n             p.segments.len() == 1\n-            && \"xx\" == token::get_ident(p.segments.get(0).identifier).get()\n+            && \"xx\" == token::get_ident(p.segments[0].identifier).get()\n         }).enumerate() {\n-            if mtwt::resolve(v.segments.get(0).identifier) != resolved_binding {\n+            if mtwt::resolve(v.segments[0].identifier) != resolved_binding {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");\n                 println!(\"this is xx varref \\\\# {}\", idx);\n                 println!(\"binding: {}\", cxbind);\n                 println!(\"resolves to: {}\", resolved_binding);\n-                println!(\"varref: {}\", v.segments.get(0).identifier);\n+                println!(\"varref: {}\", v.segments[0].identifier);\n                 println!(\"resolves to: {}\",\n-                         mtwt::resolve(v.segments.get(0).identifier));\n+                         mtwt::resolve(v.segments[0].identifier));\n                 mtwt::with_sctable(|x| mtwt::display_sctable(x));\n             }\n-            assert_eq!(mtwt::resolve(v.segments.get(0).identifier),\n+            assert_eq!(mtwt::resolve(v.segments[0].identifier),\n                        resolved_binding);\n         };\n     }"}, {"sha": "87cd61c9b223718a9b9c418a1456ea4aeb1c75db", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -241,13 +241,13 @@ impl<'a, 'b> Context<'a, 'b> {\n                     return;\n                 }\n                 {\n-                    let arg_type = match self.arg_types.get(arg) {\n-                        &None => None,\n-                        &Some(ref x) => Some(x)\n+                    let arg_type = match self.arg_types[arg] {\n+                        None => None,\n+                        Some(ref x) => Some(x)\n                     };\n-                    self.verify_same(self.args.get(arg).span, &ty, arg_type);\n+                    self.verify_same(self.args[arg].span, &ty, arg_type);\n                 }\n-                if self.arg_types.get(arg).is_none() {\n+                if self.arg_types[arg].is_none() {\n                     *self.arg_types.get_mut(arg) = Some(ty);\n                 }\n             }\n@@ -544,7 +544,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         // of each variable because we don't want to move out of the arguments\n         // passed to this function.\n         for (i, e) in self.args.into_iter().enumerate() {\n-            let arg_ty = match self.arg_types.get(i).as_ref() {\n+            let arg_ty = match self.arg_types[i].as_ref() {\n                 Some(ty) => ty,\n                 None => continue // error already generated\n             };\n@@ -568,7 +568,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             let lname = self.ecx.ident_of(format!(\"__arg{}\",\n                                                   *name).as_slice());\n             pats.push(self.ecx.pat_ident(e.span, lname));\n-            *names.get_mut(*self.name_positions.get(name)) =\n+            *names.get_mut(self.name_positions[*name]) =\n                 Some(Context::format_arg(self.ecx, e.span, arg_ty,\n                                          self.ecx.expr_ident(e.span, lname)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n@@ -787,7 +787,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n             None => break\n         }\n     }\n-    match parser.errors.shift() {\n+    match parser.errors.remove(0) {\n         Some(error) => {\n             cx.ecx.span_err(cx.fmtsp,\n                             format!(\"invalid format string: {}\",\n@@ -804,7 +804,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     // Make sure that all arguments were used and all arguments have types.\n     for (i, ty) in cx.arg_types.iter().enumerate() {\n         if ty.is_none() {\n-            cx.ecx.span_err(cx.args.get(i).span, \"argument never used\");\n+            cx.ecx.span_err(cx.args[i].span, \"argument never used\");\n         }\n     }\n     for (name, e) in cx.names.iter() {"}, {"sha": "b4f8b9f82284980335fca8de2552bb61e951eac0", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -188,7 +188,7 @@ fn resolve_internal(id: Ident,\n     }\n \n     let resolved = {\n-        let result = *table.table.borrow().get(id.ctxt as uint);\n+        let result = (*table.table.borrow())[id.ctxt as uint];\n         match result {\n             EmptyCtxt => id.name,\n             // ignore marks here:\n@@ -232,7 +232,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n     let mut result = Vec::new();\n     let mut loopvar = ctxt;\n     loop {\n-        let table_entry = *table.table.borrow().get(loopvar as uint);\n+        let table_entry = (*table.table.borrow())[loopvar as uint];\n         match table_entry {\n             EmptyCtxt => {\n                 return result;\n@@ -259,7 +259,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n /// FAILS when outside is not a mark.\n pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     with_sctable(|sctable| {\n-        match *sctable.table.borrow().get(ctxt as uint) {\n+        match (*sctable.table.borrow())[ctxt as uint] {\n             Mark(mrk, _) => mrk,\n             _ => fail!(\"can't retrieve outer mark when outside is not a mark\")\n         }\n@@ -330,7 +330,7 @@ mod tests {\n         let mut result = Vec::new();\n         loop {\n             let table = table.table.borrow();\n-            match *table.get(sc as uint) {\n+            match (*table)[sc as uint] {\n                 EmptyCtxt => {return result;},\n                 Mark(mrk,tail) => {\n                     result.push(M(mrk));\n@@ -355,9 +355,9 @@ mod tests {\n         assert_eq!(unfold_test_sc(test_sc.clone(),EMPTY_CTXT,&mut t),4);\n         {\n             let table = t.table.borrow();\n-            assert!(*table.get(2) == Mark(9,0));\n-            assert!(*table.get(3) == Rename(id(101,0),Name(14),2));\n-            assert!(*table.get(4) == Mark(3,3));\n+            assert!((*table)[2] == Mark(9,0));\n+            assert!((*table)[3] == Rename(id(101,0),Name(14),2));\n+            assert!((*table)[4] == Mark(3,3));\n         }\n         assert_eq!(refold_test_sc(4,&t),test_sc);\n     }\n@@ -376,8 +376,8 @@ mod tests {\n         assert_eq!(unfold_marks(vec!(3,7),EMPTY_CTXT,&mut t),3);\n         {\n             let table = t.table.borrow();\n-            assert!(*table.get(2) == Mark(7,0));\n-            assert!(*table.get(3) == Mark(3,2));\n+            assert!((*table)[2] == Mark(7,0));\n+            assert!((*table)[3] == Mark(3,2));\n         }\n     }\n "}, {"sha": "84775c12d641f7570ea422534afa7d76930a6f68", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -657,18 +657,20 @@ fn mk_tt(cx: &ExtCtxt, sp: Span, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n \n         ast::TTNonterminal(sp, ident) => {\n \n-            // tt.push_all_move($ident.to_tokens(ext_cx))\n+            // tt.extend($ident.to_tokens(ext_cx).into_iter())\n \n             let e_to_toks =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, ident),\n                                     id_ext(\"to_tokens\"),\n                                     vec!(cx.expr_ident(sp, id_ext(\"ext_cx\"))));\n+            let e_to_toks =\n+                cx.expr_method_call(sp, e_to_toks, id_ext(\"into_iter\"), vec![]);\n \n             let e_push =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, id_ext(\"tt\")),\n-                                    id_ext(\"push_all_move\"),\n+                                    id_ext(\"extend\"),\n                                     vec!(e_to_toks));\n \n             vec!(cx.stmt_expr(e_push))\n@@ -680,7 +682,7 @@ fn mk_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> Vec<P<ast::Stmt>> {\n     let mut ss = Vec::new();\n     for tt in tts.iter() {\n-        ss.push_all_move(mk_tt(cx, sp, tt));\n+        ss.extend(mk_tt(cx, sp, tt).into_iter());\n     }\n     ss\n }\n@@ -742,7 +744,7 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n \n     let mut vector = vec!(stmt_let_sp, stmt_let_tt);\n-    vector.push_all_move(mk_tts(cx, sp, tts.as_slice()));\n+    vector.extend(mk_tts(cx, sp, tts.as_slice()).into_iter());\n     let block = cx.expr_block(\n         cx.block_all(sp,\n                      Vec::new(),"}, {"sha": "78fcd729aae1008223b17c4471a4e2b54d982723", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -286,7 +286,7 @@ pub fn parse(sess: &ParseSess,\n \n                         // Only touch the binders we have actually bound\n                         for idx in range(ei.match_lo, ei.match_hi) {\n-                            let sub = (*ei.matches.get(idx)).clone();\n+                            let sub = (ei.matches[idx]).clone();\n                             new_pos.matches\n                                    .get_mut(idx)\n                                    .push(Rc::new(MatchedSeq(sub, mk_sp(ei.sp_lo,\n@@ -321,7 +321,7 @@ pub fn parse(sess: &ParseSess,\n                     eof_eis.push(ei);\n                 }\n             } else {\n-                match ei.elts.get(idx).node.clone() {\n+                match ei.elts[idx].node.clone() {\n                   /* need to descend into sequence */\n                   MatchSeq(ref matchers, ref sep, zero_ok,\n                            match_idx_lo, match_idx_hi) => {\n@@ -388,7 +388,7 @@ pub fn parse(sess: &ParseSess,\n             if (bb_eis.len() > 0u && next_eis.len() > 0u)\n                 || bb_eis.len() > 1u {\n                 let nts = bb_eis.iter().map(|ei| {\n-                    match ei.elts.get(ei.idx).node {\n+                    match ei.elts[ei.idx].node {\n                       MatchNonterminal(bind, name, _) => {\n                         (format!(\"{} ('{}')\",\n                                 token::get_ident(name),\n@@ -413,7 +413,7 @@ pub fn parse(sess: &ParseSess,\n                 let mut rust_parser = Parser::new(sess, cfg.clone(), box rdr.clone());\n \n                 let mut ei = bb_eis.pop().unwrap();\n-                match ei.elts.get(ei.idx).node {\n+                match ei.elts[ei.idx].node {\n                   MatchNonterminal(_, name, idx) => {\n                     let name_string = token::get_ident(name);\n                     ei.matches.get_mut(idx).push(Rc::new(MatchedNonterminal("}, {"sha": "91db3a9d8df50a6b6200a16fb49b894fbb812a6b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -255,12 +255,12 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n                                      argument_gram);\n \n     // Extract the arguments:\n-    let lhses = match **argument_map.get(&lhs_nm) {\n+    let lhses = match *argument_map[lhs_nm] {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(sp, \"wrong-structured lhs\")\n     };\n \n-    let rhses = match **argument_map.get(&rhs_nm) {\n+    let rhses = match *argument_map[rhs_nm] {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(sp, \"wrong-structured rhs\")\n     };"}, {"sha": "35ec37d842af1c6e56aeb703a249bdd96c505590", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -79,7 +79,7 @@ fn lookup_cur_matched_by_matched(r: &TtReader, start: Rc<NamedMatch>) -> Rc<Name\n                 // end of the line; duplicate henceforth\n                 ad.clone()\n             }\n-            MatchedSeq(ref ads, _) => ads.get(*idx).clone()\n+            MatchedSeq(ref ads, _) => ads[*idx].clone()\n         }\n     })\n }\n@@ -194,7 +194,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         let t = {\n             let frame = r.stack.last().unwrap();\n             // FIXME(pcwalton): Bad copy.\n-            (*frame.forest.get(frame.idx)).clone()\n+            (*frame.forest)[frame.idx].clone()\n         };\n         match t {\n             TTDelim(tts) => {"}, {"sha": "5e29167bf1a293ecbe1b988970a23c838b5eac08", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -22,9 +22,10 @@ use ast::*;\n use ast;\n use ast_util;\n use codemap::{respan, Span, Spanned};\n+use owned_slice::OwnedSlice;\n use parse::token;\n use ptr::P;\n-use owned_slice::OwnedSlice;\n+use std::ptr;\n use util::small_vector::SmallVector;\n \n use std::rc::Rc;\n@@ -36,11 +37,10 @@ pub trait MoveMap<T> {\n \n impl<T> MoveMap<T> for Vec<T> {\n     fn move_map(mut self, f: |T| -> T) -> Vec<T> {\n-        use std::{mem, ptr};\n         for p in self.iter_mut() {\n             unsafe {\n                 // FIXME(#5016) this shouldn't need to zero to be safe.\n-                mem::move_val_init(p, f(ptr::read_and_zero(p)));\n+                ptr::write(p, f(ptr::read_and_zero(p)));\n             }\n         }\n         self\n@@ -935,7 +935,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n                 match *impl_item {\n                     MethodImplItem(ref x) => {\n                         for method in folder.fold_method((*x).clone())\n-                                            .move_iter() {\n+                                            .into_iter() {\n                             new_impl_items.push(MethodImplItem(method))\n                         }\n                     }\n@@ -963,23 +963,23 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n                     RequiredMethod(m) => {\n                             SmallVector::one(RequiredMethod(\n                                     folder.fold_type_method(m)))\n-                                .move_iter()\n+                                .into_iter()\n                     }\n                     ProvidedMethod(method) => {\n                         // the awkward collect/iter idiom here is because\n                         // even though an iter and a map satisfy the same\n                         // trait bound, they're not actually the same type, so\n                         // the method arms don't unify.\n                         let methods: SmallVector<ast::TraitItem> =\n-                            folder.fold_method(method).move_iter()\n+                            folder.fold_method(method).into_iter()\n                             .map(|m| ProvidedMethod(m)).collect();\n-                        methods.move_iter()\n+                        methods.into_iter()\n                     }\n                     TypeTraitItem(at) => {\n                         SmallVector::one(TypeTraitItem(P(\n                                     folder.fold_associated_type(\n                                         (*at).clone()))))\n-                            .move_iter()\n+                            .into_iter()\n                     }\n                 };\n                 r"}, {"sha": "4881be8996a8b5b8c892c465c48c3802c36d068b", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -26,7 +26,6 @@\n #![allow(unknown_features)]\n #![feature(macro_rules, globs, default_type_params, phase, slicing_syntax)]\n #![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n-#![allow(deprecated)]\n \n extern crate arena;\n extern crate fmt_macros;\n@@ -61,7 +60,6 @@ pub mod ast_util;\n pub mod attr;\n pub mod codemap;\n pub mod config;\n-pub mod crateid;\n pub mod diagnostic;\n pub mod feature_gate;\n pub mod fold;"}, {"sha": "e5c37e5041abf43a984c2716fdc56d8c5bcdfe25", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -122,7 +122,7 @@ impl<T> Default for OwnedSlice<T> {\n \n impl<T: Clone> Clone for OwnedSlice<T> {\n     fn clone(&self) -> OwnedSlice<T> {\n-        OwnedSlice::from_vec(Vec::from_slice(self.as_slice()))\n+        OwnedSlice::from_vec(self.as_slice().to_vec())\n     }\n }\n "}, {"sha": "551d15048f10940aad35a62d3b68d10b62dd2695", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -64,21 +64,21 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n         if lines.len() > 0 &&\n-                lines.get(0).as_slice().chars().all(|c| c == '*') {\n+                lines[0].as_slice().chars().all(|c| c == '*') {\n             i += 1;\n         }\n-        while i < j && lines.get(i).as_slice().trim().is_empty() {\n+        while i < j && lines[i].as_slice().trim().is_empty() {\n             i += 1;\n         }\n         // like the first, a last line of all stars should be omitted\n-        if j > i && lines.get(j - 1)\n+        if j > i && lines[j - 1]\n                          .as_slice()\n                          .chars()\n                          .skip(1)\n                          .all(|c| c == '*') {\n             j -= 1;\n         }\n-        while j > i && lines.get(j - 1).as_slice().trim().is_empty() {\n+        while j > i && lines[j - 1].as_slice().trim().is_empty() {\n             j -= 1;\n         }\n         return lines.slice(i, j).iter().map(|x| (*x).clone()).collect();\n@@ -252,7 +252,7 @@ fn read_block_comment(rdr: &mut StringReader,\n     // doc-comments are not really comments, they are attributes\n     if (rdr.curr_is('*') && !rdr.nextch_is('*')) || rdr.curr_is('!') {\n         while !(rdr.curr_is('*') && rdr.nextch_is('/')) && !rdr.is_eof() {\n-            curr_line.push_char(rdr.curr.unwrap());\n+            curr_line.push(rdr.curr.unwrap());\n             rdr.bump();\n         }\n         if !rdr.is_eof() {\n@@ -279,17 +279,17 @@ fn read_block_comment(rdr: &mut StringReader,\n                 curr_line = String::new();\n                 rdr.bump();\n             } else {\n-                curr_line.push_char(rdr.curr.unwrap());\n+                curr_line.push(rdr.curr.unwrap());\n                 if rdr.curr_is('/') && rdr.nextch_is('*') {\n                     rdr.bump();\n                     rdr.bump();\n-                    curr_line.push_char('*');\n+                    curr_line.push('*');\n                     level += 1;\n                 } else {\n                     if rdr.curr_is('*') && rdr.nextch_is('/') {\n                         rdr.bump();\n                         rdr.bump();\n-                        curr_line.push_char('/');\n+                        curr_line.push('/');\n                         level -= 1;\n                     } else { rdr.bump(); }\n                 }"}, {"sha": "55d071b8d6005151707bf60e461ca0ea64763cef", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -180,7 +180,7 @@ impl<'a> StringReader<'a> {\n     fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> ! {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n-        char::escape_default(c, |c| m.push_char(c));\n+        char::escape_default(c, |c| m.push(c));\n         self.fatal_span_(from_pos, to_pos, m.as_slice());\n     }\n \n@@ -189,7 +189,7 @@ impl<'a> StringReader<'a> {\n     fn err_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n-        char::escape_default(c, |c| m.push_char(c));\n+        char::escape_default(c, |c| m.push(c));\n         self.err_span_(from_pos, to_pos, m.as_slice());\n     }\n \n@@ -1227,7 +1227,7 @@ impl<'a> StringReader<'a> {\n     fn read_to_eol(&mut self) -> String {\n         let mut val = String::new();\n         while !self.curr_is('\\n') && !self.is_eof() {\n-            val.push_char(self.curr.unwrap());\n+            val.push(self.curr.unwrap());\n             self.bump();\n         }\n         if self.curr_is('\\n') { self.bump(); }"}, {"sha": "f1baccfcd80204af2edc87c849e4e20a3f0e5c6c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -455,7 +455,7 @@ pub fn str_lit(lit: &str) -> String {\n                             for _ in range(0, n - 1) { // we don't need to move past the first \\\n                                 chars.next();\n                             }\n-                            res.push_char(c);\n+                            res.push(c);\n                         }\n                     },\n                     '\\r' => {\n@@ -467,9 +467,9 @@ pub fn str_lit(lit: &str) -> String {\n                             fail!(\"lexer accepted bare CR\");\n                         }\n                         chars.next();\n-                        res.push_char('\\n');\n+                        res.push('\\n');\n                     }\n-                    c => res.push_char(c),\n+                    c => res.push(c),\n                 }\n             },\n             None => break\n@@ -497,9 +497,9 @@ pub fn raw_str_lit(lit: &str) -> String {\n                         fail!(\"lexer accepted bare CR\");\n                     }\n                     chars.next();\n-                    res.push_char('\\n');\n+                    res.push('\\n');\n                 } else {\n-                    res.push_char(c);\n+                    res.push(c);\n                 }\n             },\n             None => break"}, {"sha": "abab816bfeb96036c50a893f9236733a64e60d5b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -281,12 +281,13 @@ macro_rules! maybe_whole (\n )\n \n \n-fn maybe_append(lhs: Vec<Attribute> , rhs: Option<Vec<Attribute> >)\n-             -> Vec<Attribute> {\n+fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n+                -> Vec<Attribute> {\n     match rhs {\n-        None => lhs,\n-        Some(ref attrs) => lhs.append(attrs.as_slice())\n+        Some(ref attrs) => lhs.extend(attrs.iter().map(|a| a.clone())),\n+        None => {}\n     }\n+    lhs\n }\n \n \n@@ -452,7 +453,8 @@ impl<'a> Parser<'a> {\n         } else if inedible.contains(&self.token) {\n             // leave it in the input\n         } else {\n-            let expected = edible.iter().map(|x| (*x).clone()).collect::<Vec<_>>().append(inedible);\n+            let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n+            expected.push_all(inedible);\n             let expect = tokens_to_string(expected.as_slice());\n             let actual = self.this_token_to_string();\n             self.fatal(\n@@ -496,8 +498,8 @@ impl<'a> Parser<'a> {\n         match e.node {\n             ExprPath(..) => {\n                 // might be unit-struct construction; check for recoverableinput error.\n-                let expected = edible.iter().map(|x| (*x).clone()).collect::<Vec<_>>()\n-                              .append(inedible);\n+                let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n+                expected.push_all(inedible);\n                 self.check_for_erroneous_unit_struct_expecting(\n                     expected.as_slice());\n             }\n@@ -517,8 +519,8 @@ impl<'a> Parser<'a> {\n         if self.last_token\n                .as_ref()\n                .map_or(false, |t| is_ident_or_path(&**t)) {\n-            let expected = edible.iter().map(|x| (*x).clone()).collect::<Vec<_>>()\n-                           .append(inedible.as_slice());\n+            let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n+            expected.push_all(inedible.as_slice());\n             self.check_for_erroneous_unit_struct_expecting(\n                 expected.as_slice());\n         }\n@@ -1335,7 +1337,8 @@ impl<'a> Parser<'a> {\n                     debug!(\"parse_trait_methods(): parsing provided method\");\n                     let (inner_attrs, body) =\n                         p.parse_inner_attrs_and_block();\n-                    let attrs = attrs.append(inner_attrs.as_slice());\n+                    let mut attrs = attrs;\n+                    attrs.push_all(inner_attrs.as_slice());\n                     ProvidedMethod(P(ast::Method {\n                         attrs: attrs,\n                         id: ast::DUMMY_NODE_ID,\n@@ -2119,7 +2122,7 @@ impl<'a> Parser<'a> {\n                             |p| p.parse_expr()\n                                 );\n                         let mut exprs = vec!(first_expr);\n-                        exprs.push_all_move(remaining_exprs);\n+                        exprs.extend(remaining_exprs.into_iter());\n                         ex = ExprVec(exprs);\n                     } else {\n                         // Vector with one element.\n@@ -2337,7 +2340,7 @@ impl<'a> Parser<'a> {\n                             );\n                             hi = self.last_span.hi;\n \n-                            es.unshift(e);\n+                            es.insert(0, e);\n                             let id = spanned(dot, hi, i);\n                             let nd = self.mk_method_call(id, tys, es);\n                             e = self.mk_expr(lo, hi, nd);\n@@ -2600,7 +2603,7 @@ impl<'a> Parser<'a> {\n                     self.parse_seq_to_before_end(&close_delim,\n                                                  seq_sep_none(),\n                                                  |p| p.parse_token_tree());\n-                result.push_all_move(trees);\n+                result.extend(trees.into_iter());\n \n                 // Parse the close delimiter.\n                 result.push(parse_any_tt_tok(self));\n@@ -3380,12 +3383,10 @@ impl<'a> Parser<'a> {\n                           _ => {\n                               if !enum_path.global &&\n                                     enum_path.segments.len() == 1 &&\n-                                    enum_path.segments\n-                                             .get(0)\n+                                    enum_path.segments[0]\n                                              .lifetimes\n                                              .len() == 0 &&\n-                                    enum_path.segments\n-                                             .get(0)\n+                                    enum_path.segments[0]\n                                              .types\n                                              .len() == 0 {\n                                   // it could still be either an enum\n@@ -3394,7 +3395,7 @@ impl<'a> Parser<'a> {\n                                   pat = PatIdent(BindByValue(MutImmutable),\n                                                  codemap::Spanned{\n                                                     span: enum_path.span,\n-                                                    node: enum_path.segments.get(0)\n+                                                    node: enum_path.segments[0]\n                                                            .identifier},\n                                                  None);\n                               } else {\n@@ -4256,7 +4257,7 @@ impl<'a> Parser<'a> {\n                         sep,\n                         parse_arg_fn\n                     );\n-                    fn_inputs.unshift(Arg::new_self(explicit_self_sp, mutbl_self, $self_id));\n+                    fn_inputs.insert(0, Arg::new_self(explicit_self_sp, mutbl_self, $self_id));\n                     fn_inputs\n                 }\n                 token::RPAREN => {\n@@ -4449,7 +4450,8 @@ impl<'a> Parser<'a> {\n                 self.parse_where_clause(&mut generics);\n                 let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n                 let body_span = body.span;\n-                let new_attrs = attrs.append(inner_attrs.as_slice());\n+                let mut new_attrs = attrs;\n+                new_attrs.push_all(inner_attrs.as_slice());\n                 (ast::MethDecl(ident,\n                                generics,\n                                abi,\n@@ -4490,7 +4492,7 @@ impl<'a> Parser<'a> {\n         let (inner_attrs, mut method_attrs) =\n             self.parse_inner_attrs_and_next();\n         while !self.eat(&token::RBRACE) {\n-            method_attrs.push_all_move(self.parse_outer_attributes());\n+            method_attrs.extend(self.parse_outer_attributes().into_iter());\n             let vis = self.parse_visibility();\n             if self.eat_keyword(keywords::Type) {\n                 impl_items.push(TypeImplItem(P(self.parse_typedef(\n@@ -4711,7 +4713,9 @@ impl<'a> Parser<'a> {\n         while self.token != term {\n             let mut attrs = self.parse_outer_attributes();\n             if first {\n-                attrs = attrs_remaining.clone().append(attrs.as_slice());\n+                let mut tmp = attrs_remaining.clone();\n+                tmp.push_all(attrs.as_slice());\n+                attrs = tmp;\n                 first = false;\n             }\n             debug!(\"parse_mod_items: parse_item_or_view_item(attrs={})\",\n@@ -4826,7 +4830,7 @@ impl<'a> Parser<'a> {\n                                   \"cannot declare a new module at this location\");\n                     let this_module = match self.mod_path_stack.last() {\n                         Some(name) => name.get().to_string(),\n-                        None => self.root_module_name.get_ref().clone(),\n+                        None => self.root_module_name.as_ref().unwrap().clone(),\n                     };\n                     self.span_note(id_sp,\n                                    format!(\"maybe move this module `{0}` \\\n@@ -5536,7 +5540,7 @@ impl<'a> Parser<'a> {\n             } else {\n                 s.push_str(\"priv\")\n             }\n-            s.push_char('`');\n+            s.push('`');\n             let last_span = self.last_span;\n             self.span_fatal(last_span, s.as_slice());\n         }\n@@ -5677,7 +5681,7 @@ impl<'a> Parser<'a> {\n           }\n           _ => ()\n         }\n-        let mut rename_to = *path.get(path.len() - 1u);\n+        let mut rename_to = path[path.len() - 1u];\n         let path = ast::Path {\n             span: mk_sp(lo, self.span.hi),\n             global: false,\n@@ -5705,7 +5709,8 @@ impl<'a> Parser<'a> {\n                                   mut extern_mod_allowed: bool,\n                                   macros_allowed: bool)\n                                   -> ParsedItemsAndViewItems {\n-        let mut attrs = first_item_attrs.append(self.parse_outer_attributes().as_slice());\n+        let mut attrs = first_item_attrs;\n+        attrs.push_all(self.parse_outer_attributes().as_slice());\n         // First, parse view items.\n         let mut view_items : Vec<ast::ViewItem> = Vec::new();\n         let mut items = Vec::new();\n@@ -5786,7 +5791,8 @@ impl<'a> Parser<'a> {\n     fn parse_foreign_items(&mut self, first_item_attrs: Vec<Attribute> ,\n                            macros_allowed: bool)\n         -> ParsedItemsAndViewItems {\n-        let mut attrs = first_item_attrs.append(self.parse_outer_attributes().as_slice());\n+        let mut attrs = first_item_attrs;\n+        attrs.push_all(self.parse_outer_attributes().as_slice());\n         let mut foreign_items = Vec::new();\n         loop {\n             match self.parse_foreign_item(attrs, macros_allowed) {"}, {"sha": "65efd4f00425b744f43ea8dc47226ee545aee653", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -134,12 +134,12 @@ pub fn buf_str(toks: Vec<Token>,\n             s.push_str(\", \");\n         }\n         s.push_str(format!(\"{}={}\",\n-                           szs.get(i),\n-                           tok_str(toks.get(i).clone())).as_slice());\n+                           szs[i],\n+                           tok_str(toks[i].clone())).as_slice());\n         i += 1u;\n         i %= n;\n     }\n-    s.push_char(']');\n+    s.push(']');\n     return s.into_string();\n }\n \n@@ -299,7 +299,7 @@ pub struct Printer {\n \n impl Printer {\n     pub fn last_token(&mut self) -> Token {\n-        (*self.token.get(self.right)).clone()\n+        self.token[self.right].clone()\n     }\n     // be very careful with this!\n     pub fn replace_last_token(&mut self, t: Token) {\n@@ -311,8 +311,8 @@ impl Printer {\n           Eof => {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n-                let left = (*self.token.get(self.left)).clone();\n-                let left_size = *self.size.get(self.left);\n+                let left = self.token[self.left].clone();\n+                let left_size = self.size[self.left];\n                 try!(self.advance_left(left, left_size));\n             }\n             self.indent(0);\n@@ -388,14 +388,14 @@ impl Printer {\n             debug!(\"scan window is {}, longer than space on line ({})\",\n                    self.right_total - self.left_total, self.space);\n             if !self.scan_stack_empty {\n-                if self.left == *self.scan_stack.get(self.bottom) {\n+                if self.left == self.scan_stack[self.bottom] {\n                     debug!(\"setting {} to infinity and popping\", self.left);\n                     let scanned = self.scan_pop_bottom();\n                     *self.size.get_mut(scanned) = SIZE_INFINITY;\n                 }\n             }\n-            let left = (*self.token.get(self.left)).clone();\n-            let left_size = *self.size.get(self.left);\n+            let left = self.token[self.left].clone();\n+            let left_size = self.size[self.left];\n             try!(self.advance_left(left, left_size));\n             if self.left != self.right {\n                 try!(self.check_stream());\n@@ -416,7 +416,7 @@ impl Printer {\n     }\n     pub fn scan_pop(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n-        let x = *self.scan_stack.get(self.top);\n+        let x = self.scan_stack[self.top];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else {\n@@ -426,11 +426,11 @@ impl Printer {\n     }\n     pub fn scan_top(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n-        return *self.scan_stack.get(self.top);\n+        return self.scan_stack[self.top];\n     }\n     pub fn scan_pop_bottom(&mut self) -> uint {\n         assert!((!self.scan_stack_empty));\n-        let x = *self.scan_stack.get(self.bottom);\n+        let x = self.scan_stack[self.bottom];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else {\n@@ -458,8 +458,8 @@ impl Printer {\n             if self.left != self.right {\n                 self.left += 1u;\n                 self.left %= self.buf_len;\n-                let left = (*self.token.get(self.left)).clone();\n-                let left_size = *self.size.get(self.left);\n+                let left = self.token[self.left].clone();\n+                let left_size = self.size[self.left];\n                 try!(self.advance_left(left, left_size));\n             }\n             ret\n@@ -470,29 +470,28 @@ impl Printer {\n     pub fn check_stack(&mut self, k: int) {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n-            match self.token.get(x) {\n-              &Begin(_) => {\n-                if k > 0 {\n+            match self.token[x] {\n+                Begin(_) => {\n+                    if k > 0 {\n+                        let popped = self.scan_pop();\n+                        *self.size.get_mut(popped) = self.size[x] +\n+                            self.right_total;\n+                        self.check_stack(k - 1);\n+                    }\n+                }\n+                End => {\n+                    // paper says + not =, but that makes no sense.\n                     let popped = self.scan_pop();\n-                    *self.size.get_mut(popped) = *self.size.get(x) +\n-                        self.right_total;\n-                    self.check_stack(k - 1);\n+                    *self.size.get_mut(popped) = 1;\n+                    self.check_stack(k + 1);\n                 }\n-              }\n-              &End => {\n-                // paper says + not =, but that makes no sense.\n-                let popped = self.scan_pop();\n-                *self.size.get_mut(popped) = 1;\n-                self.check_stack(k + 1);\n-              }\n-              _ => {\n-                let popped = self.scan_pop();\n-                *self.size.get_mut(popped) = *self.size.get(x) +\n-                    self.right_total;\n-                if k > 0 {\n-                    self.check_stack(k);\n+                _ => {\n+                    let popped = self.scan_pop();\n+                    *self.size.get_mut(popped) = self.size[x] + self.right_total;\n+                    if k > 0 {\n+                        self.check_stack(k);\n+                    }\n                 }\n-              }\n             }\n         }\n     }\n@@ -511,7 +510,7 @@ impl Printer {\n         let print_stack = &mut self.print_stack;\n         let n = print_stack.len();\n         if n != 0u {\n-            *print_stack.get(n - 1u)\n+            (*print_stack)[n - 1]\n         } else {\n             PrintStackElem {\n                 offset: 0,"}, {"sha": "cdcbeedddb2393528371574f51826e6904f8ad74", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -175,7 +175,7 @@ pub fn to_string(f: |&mut State| -> IoResult<()>) -> String {\n         let obj: TraitObject = mem::transmute_copy(&s.s.out);\n         let wr: Box<MemWriter> = mem::transmute(obj.data);\n         let result =\n-            String::from_utf8(Vec::from_slice(wr.get_ref().as_slice())).unwrap();\n+            String::from_utf8(wr.get_ref().as_slice().to_vec()).unwrap();\n         mem::forget(wr);\n         result.to_string()\n     }\n@@ -1466,7 +1466,7 @@ impl<'a> State<'a> {\n             }\n             ast::ExprMethodCall(ident, ref tys, ref args) => {\n                 let base_args = args.slice_from(1);\n-                try!(self.print_expr(&**args.get(0)));\n+                try!(self.print_expr(&*args[0]));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_ident(ident.node));\n                 if tys.len() > 0u {\n@@ -2144,7 +2144,7 @@ impl<'a> State<'a> {\n         for &explicit_self in opt_explicit_self.iter() {\n             let m = match explicit_self {\n                 &ast::SelfStatic => ast::MutImmutable,\n-                _ => match decl.inputs.get(0).pat.node {\n+                _ => match decl.inputs[0].pat.node {\n                     ast::PatIdent(ast::BindByValue(m), _, _) => m,\n                     _ => ast::MutImmutable\n                 }\n@@ -2319,7 +2319,7 @@ impl<'a> State<'a> {\n \n         try!(self.commasep(Inconsistent, ints.as_slice(), |s, &idx| {\n             if idx < generics.lifetimes.len() {\n-                let lifetime = generics.lifetimes.get(idx);\n+                let lifetime = &generics.lifetimes[idx];\n                 s.print_lifetime_def(lifetime)\n             } else {\n                 let idx = idx - generics.lifetimes.len();\n@@ -2663,14 +2663,14 @@ impl<'a> State<'a> {\n             ast::LitStr(ref st, style) => self.print_string(st.get(), style),\n             ast::LitByte(byte) => {\n                 let mut res = String::from_str(\"b'\");\n-                (byte as char).escape_default(|c| res.push_char(c));\n-                res.push_char('\\'');\n+                (byte as char).escape_default(|c| res.push(c));\n+                res.push('\\'');\n                 word(&mut self.s, res.as_slice())\n             }\n             ast::LitChar(ch) => {\n                 let mut res = String::from_str(\"'\");\n-                ch.escape_default(|c| res.push_char(c));\n-                res.push_char('\\'');\n+                ch.escape_default(|c| res.push(c));\n+                res.push('\\'');\n                 word(&mut self.s, res.as_slice())\n             }\n             ast::LitInt(i, t) => {\n@@ -2718,7 +2718,7 @@ impl<'a> State<'a> {\n         match self.literals {\n             Some(ref lits) => {\n                 while self.cur_cmnt_and_lit.cur_lit < lits.len() {\n-                    let ltrl = (*(*lits).get(self.cur_cmnt_and_lit.cur_lit)).clone();\n+                    let ltrl = (*lits)[self.cur_cmnt_and_lit.cur_lit].clone();\n                     if ltrl.pos > pos { return None; }\n                     self.cur_cmnt_and_lit.cur_lit += 1u;\n                     if ltrl.pos == pos { return Some(ltrl); }\n@@ -2750,7 +2750,7 @@ impl<'a> State<'a> {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1u);\n                 try!(zerobreak(&mut self.s));\n-                try!(word(&mut self.s, cmnt.lines.get(0).as_slice()));\n+                try!(word(&mut self.s, cmnt.lines[0].as_slice()));\n                 zerobreak(&mut self.s)\n             }\n             comments::Isolated => {\n@@ -2768,7 +2768,7 @@ impl<'a> State<'a> {\n             comments::Trailing => {\n                 try!(word(&mut self.s, \" \"));\n                 if cmnt.lines.len() == 1u {\n-                    try!(word(&mut self.s, cmnt.lines.get(0).as_slice()));\n+                    try!(word(&mut self.s, cmnt.lines[0].as_slice()));\n                     hardbreak(&mut self.s)\n                 } else {\n                     try!(self.ibox(0u));\n@@ -2814,7 +2814,7 @@ impl<'a> State<'a> {\n         match self.comments {\n             Some(ref cmnts) => {\n                 if self.cur_cmnt_and_lit.cur_cmnt < cmnts.len() {\n-                    Some((*cmnts.get(self.cur_cmnt_and_lit.cur_cmnt)).clone())\n+                    Some(cmnts[self.cur_cmnt_and_lit.cur_cmnt].clone())\n                 } else {\n                     None\n                 }"}, {"sha": "1b231ed861b893cce1b04b05a436a5c3ece7f91a", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -37,6 +37,7 @@\n use std::fmt;\n use std::fmt::Show;\n use std::hash::Hash;\n+use std::ptr;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n /// An owned smart pointer.\n@@ -61,11 +62,10 @@ impl<T: 'static> P<T> {\n \n     /// Transform the inner value, consuming `self` and producing a new `P<T>`.\n     pub fn map(mut self, f: |T| -> T) -> P<T> {\n-        use std::{mem, ptr};\n         unsafe {\n             let p = &mut *self.ptr;\n             // FIXME(#5016) this shouldn't need to zero to be safe.\n-            mem::move_val_init(p, f(ptr::read_and_zero(p)));\n+            ptr::write(p, f(ptr::read_and_zero(p)));\n         }\n         self\n     }"}, {"sha": "0f86fb751dae45771bd7394340065db8e8a2f3e3", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -100,7 +100,7 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n \n         // `extern crate` must be precede `use` items\n         mem::swap(&mut vis, &mut krate.module.view_items);\n-        krate.module.view_items.push_all_move(vis);\n+        krate.module.view_items.extend(vis.into_iter());\n \n         // don't add #![no_std] here, that will block the prelude injection later.\n         // Add it during the prelude injection instead.\n@@ -219,7 +219,7 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n             vis: ast::Inherited,\n             span: DUMMY_SP,\n         });\n-        view_items.push_all_move(uses);\n+        view_items.extend(uses.into_iter());\n \n         fold::noop_fold_mod(ast::Mod {\n             inner: inner,"}, {"sha": "ed2455d0a30680ebe1377dba46d2860c3a663d2b", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -67,7 +67,7 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n \n     pub fn get(&self, idx: Name) -> T {\n         let vect = self.vect.borrow();\n-        (*(*vect).get(idx.uint())).clone()\n+        (*vect)[idx.uint()].clone()\n     }\n \n     pub fn len(&self) -> uint {\n@@ -182,13 +182,13 @@ impl StrInterner {\n         let new_idx = Name(self.len() as u32);\n         // leave out of map to avoid colliding\n         let mut vect = self.vect.borrow_mut();\n-        let existing = (*vect.get(idx.uint())).clone();\n+        let existing = (*vect)[idx.uint()].clone();\n         vect.push(existing);\n         new_idx\n     }\n \n     pub fn get(&self, idx: Name) -> RcStr {\n-        (*self.vect.borrow().get(idx.uint())).clone()\n+        (*self.vect.borrow())[idx.uint()].clone()\n     }\n \n     pub fn len(&self) -> uint {"}, {"sha": "60ba5f6615b92e22dacdf67743b6748960d69f80", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -98,7 +98,7 @@ impl<T> SmallVector<T> {\n     pub fn get<'a>(&'a self, idx: uint) -> &'a T {\n         match self.repr {\n             One(ref v) if idx == 0 => v,\n-            Many(ref vs) => vs.get(idx),\n+            Many(ref vs) => &vs[idx],\n             _ => fail!(\"out of bounds access\")\n         }\n     }"}, {"sha": "bf9a959afffbda4d2380d20b2b7d6f93da9c11d6", "filename": "src/liburl/lib.rs", "status": "removed", "additions": 0, "deletions": 1243, "changes": 1243, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,1243 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Types/fns concerning URLs (see RFC 3986)\n-\n-#![crate_name = \"url\"]\n-#![deprecated=\"This is being removed. Use rust-url instead. http://servo.github.io/rust-url/\"]\n-#![allow(deprecated)]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(default_type_params)]\n-\n-use std::collections::HashMap;\n-use std::collections::hashmap::{Occupied, Vacant};\n-use std::fmt;\n-use std::from_str::FromStr;\n-use std::hash;\n-use std::uint;\n-use std::path::BytesContainer;\n-\n-/// A Uniform Resource Locator (URL).  A URL is a form of URI (Uniform Resource\n-/// Identifier) that includes network location information, such as hostname or\n-/// port number.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// use url::Url;\n-///\n-/// let raw = \"https://username@example.com:8080/foo/bar?baz=qux#quz\";\n-/// match Url::parse(raw) {\n-///     Ok(u) => println!(\"Parsed '{}'\", u),\n-///     Err(e) => println!(\"Couldn't parse '{}': {}\", raw, e),\n-/// }\n-/// ```\n-#[deriving(Clone, PartialEq, Eq)]\n-pub struct Url {\n-    /// The scheme part of a URL, such as `https` in the above example.\n-    pub scheme: String,\n-    /// A URL subcomponent for user authentication.  `username` in the above example.\n-    pub user: Option<UserInfo>,\n-    /// A domain name or IP address.  For example, `example.com`.\n-    pub host: String,\n-    /// A TCP port number, for example `8080`.\n-    pub port: Option<u16>,\n-    /// The path component of a URL, for example `/foo/bar?baz=qux#quz`.\n-    pub path: Path,\n-}\n-\n-#[deriving(Clone, PartialEq, Eq)]\n-pub struct Path {\n-    /// The path component of a URL, for example `/foo/bar`.\n-    pub path: String,\n-    /// The query component of a URL.\n-    /// `vec![(\"baz\".to_string(), \"qux\".to_string())]` represents the fragment\n-    /// `baz=qux` in the above example.\n-    pub query: Query,\n-    /// The fragment component, such as `quz`. Not including the leading `#` character.\n-    pub fragment: Option<String>\n-}\n-\n-/// An optional subcomponent of a URI authority component.\n-#[deriving(Clone, PartialEq, Eq)]\n-pub struct UserInfo {\n-    /// The user name.\n-    pub user: String,\n-    /// Password or other scheme-specific authentication information.\n-    pub pass: Option<String>\n-}\n-\n-/// Represents the query component of a URI.\n-pub type Query = Vec<(String, String)>;\n-\n-impl Url {\n-    pub fn new(scheme: String,\n-               user: Option<UserInfo>,\n-               host: String,\n-               port: Option<u16>,\n-               path: String,\n-               query: Query,\n-               fragment: Option<String>)\n-               -> Url {\n-        Url {\n-            scheme: scheme,\n-            user: user,\n-            host: host,\n-            port: port,\n-            path: Path::new(path, query, fragment)\n-        }\n-    }\n-\n-    /// Parses a URL, converting it from a string to a `Url` representation.\n-    ///\n-    /// # Arguments\n-    /// * rawurl - a string representing the full URL, including scheme.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Err(e)` if the string did not represent a valid URL, where `e` is a\n-    /// `String` error message. Otherwise, `Ok(u)` where `u` is a `Url` struct\n-    /// representing the URL.\n-    pub fn parse(rawurl: &str) -> DecodeResult<Url> {\n-        // scheme\n-        let (scheme, rest) = try!(get_scheme(rawurl));\n-\n-        // authority\n-        let (userinfo, host, port, rest) = try!(get_authority(rest));\n-\n-        // path\n-        let has_authority = host.len() > 0;\n-        let (path, rest) = try!(get_path(rest, has_authority));\n-\n-        // query and fragment\n-        let (query, fragment) = try!(get_query_fragment(rest));\n-\n-        let url = Url::new(scheme.to_string(),\n-                            userinfo,\n-                            host.to_string(),\n-                            port,\n-                            path,\n-                            query,\n-                            fragment);\n-        Ok(url)\n-    }\n-}\n-\n-#[deprecated=\"use `Url::parse`\"]\n-pub fn from_str(s: &str) -> Result<Url, String> {\n-    Url::parse(s)\n-}\n-\n-impl Path {\n-    pub fn new(path: String,\n-               query: Query,\n-               fragment: Option<String>)\n-               -> Path {\n-        Path {\n-            path: path,\n-            query: query,\n-            fragment: fragment,\n-        }\n-    }\n-\n-    /// Parses a URL path, converting it from a string to a `Path` representation.\n-    ///\n-    /// # Arguments\n-    /// * rawpath - a string representing the path component of a URL.\n-    ///\n-    /// # Return value\n-    ///\n-    /// `Err(e)` if the string did not represent a valid URL path, where `e` is a\n-    /// `String` error message. Otherwise, `Ok(p)` where `p` is a `Path` struct\n-    /// representing the URL path.\n-    pub fn parse(rawpath: &str) -> DecodeResult<Path> {\n-        let (path, rest) = try!(get_path(rawpath, false));\n-\n-        // query and fragment\n-        let (query, fragment) = try!(get_query_fragment(rest.as_slice()));\n-\n-        Ok(Path{ path: path, query: query, fragment: fragment })\n-    }\n-}\n-\n-#[deprecated=\"use `Path::parse`\"]\n-pub fn path_from_str(s: &str) -> Result<Path, String> {\n-    Path::parse(s)\n-}\n-\n-impl UserInfo {\n-    #[inline]\n-    pub fn new(user: String, pass: Option<String>) -> UserInfo {\n-        UserInfo { user: user, pass: pass }\n-    }\n-}\n-\n-fn encode_inner<T: BytesContainer>(c: T, full_url: bool) -> String {\n-    c.container_as_bytes().iter().fold(String::new(), |mut out, &b| {\n-        match b as char {\n-            // unreserved:\n-            'A' ... 'Z'\n-            | 'a' ... 'z'\n-            | '0' ... '9'\n-            | '-' | '.' | '_' | '~' => out.push_char(b as char),\n-\n-            // gen-delims:\n-            ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n-            // sub-delims:\n-            '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-            '+' | ',' | ';' | '='\n-                if full_url => out.push_char(b as char),\n-\n-            ch => out.push_str(format!(\"%{:02X}\", ch as uint).as_slice()),\n-        };\n-\n-        out\n-    })\n-}\n-\n-/// Encodes a URI by replacing reserved characters with percent-encoded\n-/// character sequences.\n-///\n-/// This function is compliant with RFC 3986.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// use url::encode;\n-///\n-/// let url = encode(\"https://example.com/Rust (programming language)\");\n-/// println!(\"{}\", url); // https://example.com/Rust%20(programming%20language)\n-/// ```\n-pub fn encode<T: BytesContainer>(container: T) -> String {\n-    encode_inner(container, true)\n-}\n-\n-\n-/// Encodes a URI component by replacing reserved characters with percent-\n-/// encoded character sequences.\n-///\n-/// This function is compliant with RFC 3986.\n-pub fn encode_component<T: BytesContainer>(container: T) -> String {\n-    encode_inner(container, false)\n-}\n-\n-pub type DecodeResult<T> = Result<T, String>;\n-\n-/// Decodes a percent-encoded string representing a URI.\n-///\n-/// This will only decode escape sequences generated by `encode`.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// use url::decode;\n-///\n-/// let url = decode(\"https://example.com/Rust%20(programming%20language)\");\n-/// println!(\"{}\", url); // https://example.com/Rust (programming language)\n-/// ```\n-pub fn decode<T: BytesContainer>(container: T) -> DecodeResult<String> {\n-    decode_inner(container, true)\n-}\n-\n-/// Decode a string encoded with percent encoding.\n-pub fn decode_component<T: BytesContainer>(container: T) -> DecodeResult<String> {\n-    decode_inner(container, false)\n-}\n-\n-fn decode_inner<T: BytesContainer>(c: T, full_url: bool) -> DecodeResult<String> {\n-    let mut out = String::new();\n-    let mut iter = c.container_as_bytes().iter().map(|&b| b);\n-\n-    loop {\n-        match iter.next() {\n-            Some(b) => match b as char {\n-                '%' => {\n-                    let bytes = match (iter.next(), iter.next()) {\n-                        (Some(one), Some(two)) => [one as u8, two as u8],\n-                        _ => return Err(format!(\"Malformed input: found '%' \\\n-                                                without two trailing bytes\")),\n-                    };\n-\n-                    // Only decode some characters if full_url:\n-                    match uint::parse_bytes(bytes, 16u).unwrap() as u8 as char {\n-                        // gen-delims:\n-                        ':' | '/' | '?' | '#' | '[' | ']' | '@' |\n-\n-                        // sub-delims:\n-                        '!' | '$' | '&' | '\"' | '(' | ')' | '*' |\n-                        '+' | ',' | ';' | '='\n-                            if full_url => {\n-                            out.push_char('%');\n-                            out.push_char(bytes[0u] as char);\n-                            out.push_char(bytes[1u] as char);\n-                        }\n-\n-                        ch => out.push_char(ch)\n-                    }\n-                }\n-                ch => out.push_char(ch)\n-            },\n-            None => return Ok(out),\n-        }\n-    }\n-}\n-\n-/// Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n-pub fn encode_form_urlencoded(m: &HashMap<String, Vec<String>>) -> String {\n-    fn encode_plus<T: Str>(s: &T) -> String {\n-        s.as_slice().bytes().fold(String::new(), |mut out, b| {\n-            match b as char {\n-              'A' ... 'Z'\n-              | 'a' ... 'z'\n-              | '0' ... '9'\n-              | '_' | '.' | '-' => out.push_char(b as char),\n-              ' ' => out.push_char('+'),\n-              ch => out.push_str(format!(\"%{:X}\", ch as uint).as_slice())\n-            }\n-\n-            out\n-        })\n-    }\n-\n-    let mut first = true;\n-    m.iter().fold(String::new(), |mut out, (key, values)| {\n-        let key = encode_plus(key);\n-\n-        for value in values.iter() {\n-            if first {\n-                first = false;\n-            } else {\n-                out.push_char('&');\n-            }\n-\n-            out.push_str(key.as_slice());\n-            out.push_char('=');\n-            out.push_str(encode_plus(value).as_slice());\n-        }\n-\n-        out\n-    })\n-}\n-\n-/// Decode a string encoded with the 'application/x-www-form-urlencoded' media\n-/// type into a hashmap.\n-pub fn decode_form_urlencoded(s: &[u8])\n-                            -> DecodeResult<HashMap<String, Vec<String>>> {\n-    fn maybe_push_value(map: &mut HashMap<String, Vec<String>>,\n-                        key: String,\n-                        value: String) {\n-        if key.len() > 0 && value.len() > 0 {\n-            match map.entry(key) {\n-                Vacant(entry) => { entry.set(vec![value]); },\n-                Occupied(mut entry) => { entry.get_mut().push(value); },\n-            }\n-        }\n-    }\n-\n-    let mut out = HashMap::new();\n-    let mut iter = s.iter().map(|&x| x);\n-\n-    let mut key = String::new();\n-    let mut value = String::new();\n-    let mut parsing_key = true;\n-\n-    loop {\n-        match iter.next() {\n-            Some(b) => match b as char {\n-                '&' | ';' => {\n-                    maybe_push_value(&mut out, key, value);\n-\n-                    parsing_key = true;\n-                    key = String::new();\n-                    value = String::new();\n-                }\n-                '=' => parsing_key = false,\n-                ch => {\n-                    let ch = match ch {\n-                        '%' => {\n-                            let bytes = match (iter.next(), iter.next()) {\n-                                (Some(one), Some(two)) => [one as u8, two as u8],\n-                                _ => return Err(format!(\"Malformed input: found \\\n-                                                '%' without two trailing bytes\"))\n-                            };\n-\n-                            uint::parse_bytes(bytes, 16u).unwrap() as u8 as char\n-                        }\n-                        '+' => ' ',\n-                        ch => ch\n-                    };\n-\n-                    if parsing_key {\n-                        key.push_char(ch)\n-                    } else {\n-                        value.push_char(ch)\n-                    }\n-                }\n-            },\n-            None => {\n-                maybe_push_value(&mut out, key, value);\n-                return Ok(out)\n-            }\n-        }\n-    }\n-}\n-\n-fn split_char_first(s: &str, c: char) -> (&str, &str) {\n-    let mut iter = s.splitn(1, c);\n-\n-    match (iter.next(), iter.next()) {\n-        (Some(a), Some(b)) => (a, b),\n-        (Some(a), None) => (a, \"\"),\n-        (None, _) => unreachable!(),\n-    }\n-}\n-\n-impl fmt::Show for UserInfo {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.pass {\n-            Some(ref pass) => write!(f, \"{}:{}@\", self.user, *pass),\n-            None => write!(f, \"{}@\", self.user),\n-        }\n-    }\n-}\n-\n-fn query_from_str(rawquery: &str) -> DecodeResult<Query> {\n-    let mut query: Query = vec!();\n-    if !rawquery.is_empty() {\n-        for p in rawquery.split('&') {\n-            let (k, v) = split_char_first(p, '=');\n-            query.push((try!(decode_component(k)),\n-                        try!(decode_component(v))));\n-        }\n-    }\n-\n-    Ok(query)\n-}\n-\n-/// Converts an instance of a URI `Query` type to a string.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// let query = vec![(\"title\".to_string(), \"The Village\".to_string()),\n-///                  (\"north\".to_string(), \"52.91\".to_string()),\n-///                  (\"west\".to_string(), \"4.10\".to_string())];\n-/// println!(\"{}\", url::query_to_str(&query));  // title=The%20Village&north=52.91&west=4.10\n-/// ```\n-pub fn query_to_str(query: &Query) -> String {\n-    query.iter().enumerate().fold(String::new(), |mut out, (i, &(ref k, ref v))| {\n-        if i != 0 {\n-            out.push_char('&');\n-        }\n-\n-        out.push_str(encode_component(k.as_slice()).as_slice());\n-        out.push_char('=');\n-        out.push_str(encode_component(v.as_slice()).as_slice());\n-        out\n-    })\n-}\n-\n-/// Returns a tuple of the URI scheme and the rest of the URI, or a parsing error.\n-///\n-/// Does not include the separating `:` character.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// # #![allow(deprecated)]\n-/// use url::get_scheme;\n-///\n-/// let scheme = match get_scheme(\"https://example.com/\") {\n-///     Ok((sch, _)) => sch,\n-///     Err(_) => \"(None)\",\n-/// };\n-/// println!(\"Scheme in use: {}.\", scheme); // Scheme in use: https.\n-/// ```\n-pub fn get_scheme(rawurl: &str) -> DecodeResult<(&str, &str)> {\n-    for (i,c) in rawurl.chars().enumerate() {\n-        let result = match c {\n-            'A' ... 'Z'\n-            | 'a' ... 'z' => continue,\n-            '0' ... '9' | '+' | '-' | '.' => {\n-                if i != 0 { continue }\n-\n-                Err(\"url: Scheme must begin with a letter.\".to_string())\n-            }\n-            ':' => {\n-                if i == 0 {\n-                    Err(\"url: Scheme cannot be empty.\".to_string())\n-                } else {\n-                    Ok((rawurl.slice(0,i), rawurl.slice(i+1,rawurl.len())))\n-                }\n-            }\n-            _ => Err(\"url: Invalid character in scheme.\".to_string()),\n-        };\n-\n-        return result;\n-    }\n-\n-    Err(\"url: Scheme must be terminated with a colon.\".to_string())\n-}\n-\n-// returns userinfo, host, port, and unparsed part, or an error\n-fn get_authority(rawurl: &str) ->\n-    DecodeResult<(Option<UserInfo>, &str, Option<u16>, &str)> {\n-    enum State {\n-        Start, // starting state\n-        PassHostPort, // could be in user or port\n-        Ip6Port, // either in ipv6 host or port\n-        Ip6Host, // are in an ipv6 host\n-        InHost, // are in a host - may be ipv6, but don't know yet\n-        InPort // are in port\n-    }\n-\n-    #[deriving(Clone, PartialEq)]\n-    enum Input {\n-        Digit, // all digits\n-        Hex, // digits and letters a-f\n-        Unreserved // all other legal characters\n-    }\n-\n-    if !rawurl.starts_with(\"//\") {\n-        // there is no authority.\n-        return Ok((None, \"\", None, rawurl));\n-    }\n-\n-    let len = rawurl.len();\n-    let mut st = Start;\n-    let mut input = Digit; // most restricted, start here.\n-\n-    let mut userinfo = None;\n-    let mut host = \"\";\n-    let mut port = None;\n-\n-    let mut colon_count = 0u;\n-    let mut pos = 0;\n-    let mut begin = 2;\n-    let mut end = len;\n-\n-    for (i,c) in rawurl.chars().enumerate()\n-                               // ignore the leading '//' handled by early return\n-                               .skip(2) {\n-        // deal with input class first\n-        match c {\n-            '0' ... '9' => (),\n-            'A' ... 'F'\n-            | 'a' ... 'f' => {\n-                if input == Digit {\n-                    input = Hex;\n-                }\n-            }\n-            'G' ... 'Z'\n-            | 'g' ... 'z'\n-            | '-' | '.' | '_' | '~' | '%'\n-            | '&' |'\\'' | '(' | ')' | '+'\n-            | '!' | '*' | ',' | ';' | '=' => input = Unreserved,\n-            ':' | '@' | '?' | '#' | '/' => {\n-                // separators, don't change anything\n-            }\n-            _ => return Err(\"Illegal character in authority\".to_string()),\n-        }\n-\n-        // now process states\n-        match c {\n-          ':' => {\n-            colon_count += 1;\n-            match st {\n-              Start => {\n-                pos = i;\n-                st = PassHostPort;\n-              }\n-              PassHostPort => {\n-                // multiple colons means ipv6 address.\n-                if input == Unreserved {\n-                    return Err(\n-                        \"Illegal characters in IPv6 address.\".to_string());\n-                }\n-                st = Ip6Host;\n-              }\n-              InHost => {\n-                pos = i;\n-                if input == Unreserved {\n-                    // must be port\n-                    host = rawurl.slice(begin, i);\n-                    st = InPort;\n-                } else {\n-                    // can't be sure whether this is an ipv6 address or a port\n-                    st = Ip6Port;\n-                }\n-              }\n-              Ip6Port => {\n-                if input == Unreserved {\n-                    return Err(\"Illegal characters in authority.\".to_string());\n-                }\n-                st = Ip6Host;\n-              }\n-              Ip6Host => {\n-                if colon_count > 7 {\n-                    host = rawurl.slice(begin, i);\n-                    pos = i;\n-                    st = InPort;\n-                }\n-              }\n-              _ => return Err(\"Invalid ':' in authority.\".to_string()),\n-            }\n-            input = Digit; // reset input class\n-          }\n-\n-          '@' => {\n-            input = Digit; // reset input class\n-            colon_count = 0; // reset count\n-            match st {\n-              Start => {\n-                let user = rawurl.slice(begin, i).to_string();\n-                userinfo = Some(UserInfo::new(user, None));\n-                st = InHost;\n-              }\n-              PassHostPort => {\n-                let user = rawurl.slice(begin, pos).to_string();\n-                let pass = rawurl.slice(pos+1, i).to_string();\n-                userinfo = Some(UserInfo::new(user, Some(pass)));\n-                st = InHost;\n-              }\n-              _ => return Err(\"Invalid '@' in authority.\".to_string()),\n-            }\n-            begin = i+1;\n-          }\n-\n-          '?' | '#' | '/' => {\n-            end = i;\n-            break;\n-          }\n-          _ => ()\n-        }\n-    }\n-\n-    // finish up\n-    match st {\n-      Start => host = rawurl.slice(begin, end),\n-      PassHostPort\n-      | Ip6Port => {\n-        if input != Digit {\n-            return Err(\"Non-digit characters in port.\".to_string());\n-        }\n-        host = rawurl.slice(begin, pos);\n-        port = Some(rawurl.slice(pos+1, end));\n-      }\n-      Ip6Host\n-      | InHost => host = rawurl.slice(begin, end),\n-      InPort => {\n-        if input != Digit {\n-            return Err(\"Non-digit characters in port.\".to_string());\n-        }\n-        port = Some(rawurl.slice(pos+1, end));\n-      }\n-    }\n-\n-    let rest = rawurl.slice(end, len);\n-    // If we have a port string, ensure it parses to u16.\n-    let port = match port {\n-        None => None,\n-        opt => match opt.and_then(|p| FromStr::from_str(p)) {\n-            None => return Err(format!(\"Failed to parse port: {}\", port)),\n-            opt => opt\n-        }\n-    };\n-\n-    Ok((userinfo, host, port, rest))\n-}\n-\n-\n-// returns the path and unparsed part of url, or an error\n-fn get_path(rawurl: &str, is_authority: bool) -> DecodeResult<(String, &str)> {\n-    let len = rawurl.len();\n-    let mut end = len;\n-    for (i,c) in rawurl.chars().enumerate() {\n-        match c {\n-          'A' ... 'Z'\n-          | 'a' ... 'z'\n-          | '0' ... '9'\n-          | '&' |'\\'' | '(' | ')' | '.'\n-          | '@' | ':' | '%' | '/' | '+'\n-          | '!' | '*' | ',' | ';' | '='\n-          | '_' | '-' | '~' => continue,\n-          '?' | '#' => {\n-            end = i;\n-            break;\n-          }\n-          _ => return Err(\"Invalid character in path.\".to_string())\n-        }\n-    }\n-\n-    if is_authority && end != 0 && !rawurl.starts_with(\"/\") {\n-        Err(\"Non-empty path must begin with \\\n-            '/' in presence of authority.\".to_string())\n-    } else {\n-        Ok((try!(decode_component(rawurl.slice(0, end))),\n-            rawurl.slice(end, len)))\n-    }\n-}\n-\n-// returns the parsed query and the fragment, if present\n-fn get_query_fragment(rawurl: &str) -> DecodeResult<(Query, Option<String>)> {\n-    let (before_fragment, raw_fragment) = split_char_first(rawurl, '#');\n-\n-    // Parse the fragment if available\n-    let fragment = match raw_fragment {\n-        \"\" => None,\n-        raw => Some(try!(decode_component(raw)))\n-    };\n-\n-    match before_fragment.slice_shift_char() {\n-        (Some('?'), rest) => Ok((try!(query_from_str(rest)), fragment)),\n-        (None, \"\") => Ok((vec!(), fragment)),\n-        _ => Err(format!(\"Query didn't start with '?': '{}..'\", before_fragment)),\n-    }\n-}\n-\n-impl FromStr for Url {\n-    fn from_str(s: &str) -> Option<Url> {\n-        Url::parse(s).ok()\n-    }\n-}\n-\n-impl FromStr for Path {\n-    fn from_str(s: &str) -> Option<Path> {\n-        Path::parse(s).ok()\n-    }\n-}\n-\n-impl fmt::Show for Url {\n-    /// Converts a URL from `Url` to string representation.\n-    ///\n-    /// # Returns\n-    ///\n-    /// A string that contains the formatted URL. Note that this will usually\n-    /// be an inverse of `from_str` but might strip out unneeded separators;\n-    /// for example, \"http://somehost.com?\", when parsed and formatted, will\n-    /// result in just \"http://somehost.com\".\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}:\", self.scheme));\n-\n-        if !self.host.is_empty() {\n-            try!(write!(f, \"//\"));\n-            match self.user {\n-                Some(ref user) => try!(write!(f, \"{}\", *user)),\n-                None => {}\n-            }\n-            match self.port {\n-                Some(ref port) => try!(write!(f, \"{}:{}\", self.host,\n-                                                *port)),\n-                None => try!(write!(f, \"{}\", self.host)),\n-            }\n-        }\n-\n-        write!(f, \"{}\", self.path)\n-    }\n-}\n-\n-impl fmt::Show for Path {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{}\", self.path));\n-        if !self.query.is_empty() {\n-            try!(write!(f, \"?{}\", query_to_str(&self.query)))\n-        }\n-\n-        match self.fragment {\n-            Some(ref fragment) => {\n-                write!(f, \"#{}\", encode_component(fragment.as_slice()))\n-            }\n-            None => Ok(())\n-        }\n-    }\n-}\n-\n-impl<S: hash::Writer> hash::Hash<S> for Url {\n-    fn hash(&self, state: &mut S) {\n-        self.to_string().hash(state)\n-    }\n-}\n-\n-impl<S: hash::Writer> hash::Hash<S> for Path {\n-    fn hash(&self, state: &mut S) {\n-        self.to_string().hash(state)\n-    }\n-}\n-\n-// Put a few tests outside of the 'test' module so they can test the internal\n-// functions and those functions don't need 'pub'\n-\n-#[test]\n-fn test_split_char_first() {\n-    let (u,v) = split_char_first(\"hello, sweet world\", ',');\n-    assert_eq!(u, \"hello\");\n-    assert_eq!(v, \" sweet world\");\n-\n-    let (u,v) = split_char_first(\"hello sweet world\", ',');\n-    assert_eq!(u, \"hello sweet world\");\n-    assert_eq!(v, \"\");\n-}\n-\n-#[test]\n-fn test_get_authority() {\n-    let (u, h, p, r) = get_authority(\n-        \"//user:pass@rust-lang.org/something\").unwrap();\n-    assert_eq!(u, Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n-    assert_eq!(h, \"rust-lang.org\");\n-    assert!(p.is_none());\n-    assert_eq!(r, \"/something\");\n-\n-    let (u, h, p, r) = get_authority(\n-        \"//rust-lang.org:8000?something\").unwrap();\n-    assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\");\n-    assert_eq!(p, Some(8000));\n-    assert_eq!(r, \"?something\");\n-\n-    let (u, h, p, r) = get_authority(\"//rust-lang.org#blah\").unwrap();\n-    assert!(u.is_none());\n-    assert_eq!(h, \"rust-lang.org\");\n-    assert!(p.is_none());\n-    assert_eq!(r, \"#blah\");\n-\n-    // ipv6 tests\n-    let (_, h, _, _) = get_authority(\n-        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n-\n-    let (_, h, p, _) = get_authority(\n-        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\").unwrap();\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n-    assert_eq!(p, Some(8000));\n-\n-    let (u, h, p, _) = get_authority(\n-        \"//us:p@2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000#blah\"\n-    ).unwrap();\n-    assert_eq!(u, Some(UserInfo::new(\"us\".to_string(), Some(\"p\".to_string()))));\n-    assert_eq!(h, \"2001:0db8:85a3:0042:0000:8a2e:0370:7334\");\n-    assert_eq!(p, Some(8000));\n-\n-    // invalid authorities;\n-    assert!(get_authority(\"//user:pass@rust-lang:something\").is_err());\n-    assert!(get_authority(\"//user@rust-lang:something:/path\").is_err());\n-    assert!(get_authority(\n-        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:800a\").is_err());\n-    assert!(get_authority(\n-        \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err());\n-    // outside u16 range\n-    assert!(get_authority(\"//user:pass@rust-lang:65536\").is_err());\n-\n-    // these parse as empty, because they don't start with '//'\n-    let (_, h, _, _) = get_authority(\"user:pass@rust-lang\").unwrap();\n-    assert_eq!(h, \"\");\n-    let (_, h, _, _) = get_authority(\"rust-lang.org\").unwrap();\n-    assert_eq!(h, \"\");\n-}\n-\n-#[test]\n-fn test_get_path() {\n-    let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n-    assert_eq!(p, \"/something+ orother\".to_string());\n-    assert_eq!(r, \"\");\n-    let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n-    assert_eq!(p, \"test@email.com\".to_string());\n-    assert_eq!(r, \"#fragment\");\n-    let (p, r) = get_path(\"/gen/:addr=?q=v\", false).unwrap();\n-    assert_eq!(p, \"/gen/:addr=\".to_string());\n-    assert_eq!(r, \"?q=v\");\n-\n-    //failure cases\n-    assert!(get_path(\"something?q\", true).is_err());\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use {encode_form_urlencoded, decode_form_urlencoded, decode, encode,\n-        encode_component, decode_component, UserInfo, get_scheme, Url, Path};\n-\n-    use std::collections::HashMap;\n-    use std::path::BytesContainer;\n-\n-    #[test]\n-    fn test_url_parse() {\n-        let url = \"http://user:pass@rust-lang.org:8080/doc/~u?s=v#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-\n-        assert_eq!(u.scheme, \"http\".to_string());\n-        assert_eq!(u.user, Some(UserInfo::new(\"user\".to_string(), Some(\"pass\".to_string()))));\n-        assert_eq!(u.host, \"rust-lang.org\".to_string());\n-        assert_eq!(u.port, Some(8080));\n-        assert_eq!(u.path.path, \"/doc/~u\".to_string());\n-        assert_eq!(u.path.query, vec!((\"s\".to_string(), \"v\".to_string())));\n-        assert_eq!(u.path.fragment, Some(\"something\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_path_parse() {\n-        let path = \"/doc/~u?s=v#something\";\n-        let u = from_str::<Path>(path).unwrap();\n-\n-        assert_eq!(u.path, \"/doc/~u\".to_string());\n-        assert_eq!(u.query, vec!((\"s\".to_string(), \"v\".to_string())));\n-        assert_eq!(u.fragment, Some(\"something\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_url_parse_host_slash() {\n-        let urlstr = \"http://0.42.42.42/\";\n-        let url = from_str::<Url>(urlstr).unwrap();\n-        assert_eq!(url.host, \"0.42.42.42\".to_string());\n-        assert_eq!(url.path.path, \"/\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_path_parse_host_slash() {\n-        let pathstr = \"/\";\n-        let path = from_str::<Path>(pathstr).unwrap();\n-        assert_eq!(path.path, \"/\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_url_host_with_port() {\n-        let urlstr = \"scheme://host:1234\";\n-        let url = from_str::<Url>(urlstr).unwrap();\n-        assert_eq!(url.scheme, \"scheme\".to_string());\n-        assert_eq!(url.host, \"host\".to_string());\n-        assert_eq!(url.port, Some(1234));\n-        // is empty path really correct? Other tests think so\n-        assert_eq!(url.path.path, \"\".to_string());\n-\n-        let urlstr = \"scheme://host:1234/\";\n-        let url = from_str::<Url>(urlstr).unwrap();\n-        assert_eq!(url.scheme, \"scheme\".to_string());\n-        assert_eq!(url.host, \"host\".to_string());\n-        assert_eq!(url.port, Some(1234));\n-        assert_eq!(url.path.path, \"/\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_url_with_underscores() {\n-        let urlstr = \"http://dotcom.com/file_name.html\";\n-        let url = from_str::<Url>(urlstr).unwrap();\n-        assert_eq!(url.path.path, \"/file_name.html\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_path_with_underscores() {\n-        let pathstr = \"/file_name.html\";\n-        let path = from_str::<Path>(pathstr).unwrap();\n-        assert_eq!(path.path, \"/file_name.html\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_url_with_dashes() {\n-        let urlstr = \"http://dotcom.com/file-name.html\";\n-        let url = from_str::<Url>(urlstr).unwrap();\n-        assert_eq!(url.path.path, \"/file-name.html\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_path_with_dashes() {\n-        let pathstr = \"/file-name.html\";\n-        let path = from_str::<Path>(pathstr).unwrap();\n-        assert_eq!(path.path, \"/file-name.html\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_no_scheme() {\n-        assert!(get_scheme(\"noschemehere.html\").is_err());\n-    }\n-\n-    #[test]\n-    fn test_invalid_scheme_errors() {\n-        assert!(Url::parse(\"99://something\").is_err());\n-        assert!(Url::parse(\"://something\").is_err());\n-    }\n-\n-    #[test]\n-    fn test_full_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc?s=v#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_userless_url_parse_and_format() {\n-        let url = \"http://rust-lang.org/doc?s=v#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_queryless_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_empty_query_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc?#something\";\n-        let should_be = \"http://user:pass@rust-lang.org/doc#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), should_be);\n-    }\n-\n-    #[test]\n-    fn test_fragmentless_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org/doc?q=v\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_minimal_url_parse_and_format() {\n-        let url = \"http://rust-lang.org/doc\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_url_with_port_parse_and_format() {\n-        let url = \"http://rust-lang.org:80/doc\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_scheme_host_only_url_parse_and_format() {\n-        let url = \"http://rust-lang.org\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_pathless_url_parse_and_format() {\n-        let url = \"http://user:pass@rust-lang.org?q=v#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_scheme_host_fragment_only_url_parse_and_format() {\n-        let url = \"http://rust-lang.org#something\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_url_component_encoding() {\n-        let url = \"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert!(u.path.path == \"/doc uments\".to_string());\n-        assert!(u.path.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n-    }\n-\n-    #[test]\n-    fn test_path_component_encoding() {\n-        let path = \"/doc%20uments?ba%25d%20=%23%26%2B\";\n-        let p = from_str::<Path>(path).unwrap();\n-        assert!(p.path == \"/doc uments\".to_string());\n-        assert!(p.query == vec!((\"ba%d \".to_string(), \"#&+\".to_string())));\n-    }\n-\n-    #[test]\n-    fn test_url_without_authority() {\n-        let url = \"mailto:test@email.com\";\n-        let u = from_str::<Url>(url).unwrap();\n-        assert_eq!(format!(\"{}\", u).as_slice(), url);\n-    }\n-\n-    #[test]\n-    fn test_encode() {\n-        fn t<T: BytesContainer>(input: T, expected: &str) {\n-            assert_eq!(encode(input), expected.to_string())\n-        }\n-\n-        t(\"\", \"\");\n-        t(\"http://example.com\", \"http://example.com\");\n-        t(\"foo bar% baz\", \"foo%20bar%25%20baz\");\n-        t(\" \", \"%20\");\n-        t(\"!\", \"!\");\n-        t(\"\\\"\", \"\\\"\");\n-        t(\"#\", \"#\");\n-        t(\"$\", \"$\");\n-        t(\"%\", \"%25\");\n-        t(\"&\", \"&\");\n-        t(\"'\", \"%27\");\n-        t(\"(\", \"(\");\n-        t(\")\", \")\");\n-        t(\"*\", \"*\");\n-        t(\"+\", \"+\");\n-        t(\",\", \",\");\n-        t(\"/\", \"/\");\n-        t(\":\", \":\");\n-        t(\";\", \";\");\n-        t(\"=\", \"=\");\n-        t(\"?\", \"?\");\n-        t(\"@\", \"@\");\n-        t(\"[\", \"[\");\n-        t(\"]\", \"]\");\n-        t(\"\\0\", \"%00\");\n-        t(\"\\n\", \"%0A\");\n-\n-        let a: &[_] = &[0u8, 10, 37];\n-        t(a, \"%00%0A%25\");\n-    }\n-\n-    #[test]\n-    fn test_encode_component() {\n-        fn t<T: BytesContainer>(input: T, expected: &str) {\n-            assert_eq!(encode_component(input), expected.to_string())\n-        }\n-\n-        t(\"\", \"\");\n-        t(\"http://example.com\", \"http%3A%2F%2Fexample.com\");\n-        t(\"foo bar% baz\", \"foo%20bar%25%20baz\");\n-        t(\" \", \"%20\");\n-        t(\"!\", \"%21\");\n-        t(\"#\", \"%23\");\n-        t(\"$\", \"%24\");\n-        t(\"%\", \"%25\");\n-        t(\"&\", \"%26\");\n-        t(\"'\", \"%27\");\n-        t(\"(\", \"%28\");\n-        t(\")\", \"%29\");\n-        t(\"*\", \"%2A\");\n-        t(\"+\", \"%2B\");\n-        t(\",\", \"%2C\");\n-        t(\"/\", \"%2F\");\n-        t(\":\", \"%3A\");\n-        t(\";\", \"%3B\");\n-        t(\"=\", \"%3D\");\n-        t(\"?\", \"%3F\");\n-        t(\"@\", \"%40\");\n-        t(\"[\", \"%5B\");\n-        t(\"]\", \"%5D\");\n-        t(\"\\0\", \"%00\");\n-        t(\"\\n\", \"%0A\");\n-\n-        let a: &[_] = &[0u8, 10, 37];\n-        t(a, \"%00%0A%25\");\n-    }\n-\n-    #[test]\n-    fn test_decode() {\n-        fn t<T: BytesContainer>(input: T, expected: &str) {\n-            assert_eq!(decode(input), Ok(expected.to_string()))\n-        }\n-\n-        assert!(decode(\"sadsadsda%\").is_err());\n-        assert!(decode(\"waeasd%4\").is_err());\n-        t(\"\", \"\");\n-        t(\"abc/def 123\", \"abc/def 123\");\n-        t(\"abc%2Fdef%20123\", \"abc%2Fdef 123\");\n-        t(\"%20\", \" \");\n-        t(\"%21\", \"%21\");\n-        t(\"%22\", \"%22\");\n-        t(\"%23\", \"%23\");\n-        t(\"%24\", \"%24\");\n-        t(\"%25\", \"%\");\n-        t(\"%26\", \"%26\");\n-        t(\"%27\", \"'\");\n-        t(\"%28\", \"%28\");\n-        t(\"%29\", \"%29\");\n-        t(\"%2A\", \"%2A\");\n-        t(\"%2B\", \"%2B\");\n-        t(\"%2C\", \"%2C\");\n-        t(\"%2F\", \"%2F\");\n-        t(\"%3A\", \"%3A\");\n-        t(\"%3B\", \"%3B\");\n-        t(\"%3D\", \"%3D\");\n-        t(\"%3F\", \"%3F\");\n-        t(\"%40\", \"%40\");\n-        t(\"%5B\", \"%5B\");\n-        t(\"%5D\", \"%5D\");\n-\n-        t(\"%00%0A%25\".as_bytes(), \"\\0\\n%\");\n-    }\n-\n-    #[test]\n-    fn test_decode_component() {\n-        fn t<T: BytesContainer>(input: T, expected: &str) {\n-            assert_eq!(decode_component(input), Ok(expected.to_string()))\n-        }\n-\n-        assert!(decode_component(\"asacsa%\").is_err());\n-        assert!(decode_component(\"acsas%4\").is_err());\n-        t(\"\", \"\");\n-        t(\"abc/def 123\", \"abc/def 123\");\n-        t(\"abc%2Fdef%20123\", \"abc/def 123\");\n-        t(\"%20\", \" \");\n-        t(\"%21\", \"!\");\n-        t(\"%22\", \"\\\"\");\n-        t(\"%23\", \"#\");\n-        t(\"%24\", \"$\");\n-        t(\"%25\", \"%\");\n-        t(\"%26\", \"&\");\n-        t(\"%27\", \"'\");\n-        t(\"%28\", \"(\");\n-        t(\"%29\", \")\");\n-        t(\"%2A\", \"*\");\n-        t(\"%2B\", \"+\");\n-        t(\"%2C\", \",\");\n-        t(\"%2F\", \"/\");\n-        t(\"%3A\", \":\");\n-        t(\"%3B\", \";\");\n-        t(\"%3D\", \"=\");\n-        t(\"%3F\", \"?\");\n-        t(\"%40\", \"@\");\n-        t(\"%5B\", \"[\");\n-        t(\"%5D\", \"]\");\n-\n-        t(\"%00%0A%25\".as_bytes(), \"\\0\\n%\");\n-    }\n-\n-    #[test]\n-    fn test_encode_form_urlencoded() {\n-        let mut m = HashMap::new();\n-        assert_eq!(encode_form_urlencoded(&m), \"\".to_string());\n-\n-        m.insert(\"\".to_string(), vec!());\n-        m.insert(\"foo\".to_string(), vec!());\n-        assert_eq!(encode_form_urlencoded(&m), \"\".to_string());\n-\n-        let mut m = HashMap::new();\n-        m.insert(\"foo\".to_string(), vec!(\"bar\".to_string(), \"123\".to_string()));\n-        assert_eq!(encode_form_urlencoded(&m), \"foo=bar&foo=123\".to_string());\n-\n-        let mut m = HashMap::new();\n-        m.insert(\"foo bar\".to_string(), vec!(\"abc\".to_string(), \"12 = 34\".to_string()));\n-        assert_eq!(encode_form_urlencoded(&m),\n-                    \"foo+bar=abc&foo+bar=12+%3D+34\".to_string());\n-    }\n-\n-    #[test]\n-    fn test_decode_form_urlencoded() {\n-        assert_eq!(decode_form_urlencoded([]).unwrap().len(), 0);\n-\n-        let s = \"a=1&foo+bar=abc&foo+bar=12+%3D+34\".as_bytes();\n-        let form = decode_form_urlencoded(s).unwrap();\n-        assert_eq!(form.len(), 2);\n-        assert_eq!(form.get(&\"a\".to_string()), &vec!(\"1\".to_string()));\n-        assert_eq!(form.get(&\"foo bar\".to_string()),\n-                   &vec!(\"abc\".to_string(), \"12 = 34\".to_string()));\n-    }\n-}"}, {"sha": "c041ca3799dc4891f154d85a20cc773b4996bbcf", "filename": "src/libuuid/lib.rs", "status": "removed", "additions": 0, "deletions": 865, "changes": 865, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,865 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-Generate and parse UUIDs\n-\n-Provides support for Universally Unique Identifiers (UUIDs). A UUID is a\n-unique 128-bit number, stored as 16 octets.  UUIDs are used to  assign unique\n-identifiers to entities without requiring a central allocating authority.\n-\n-They are particularly useful in distributed systems, though can be used in\n-disparate areas, such as databases and network protocols.  Typically a UUID is\n-displayed in a readable string form as a sequence of hexadecimal digits,\n-separated into groups by hyphens.\n-\n-The uniqueness property is not strictly guaranteed, however for all practical\n-purposes, it can be assumed that an unintentional collision would be extremely\n-unlikely.\n-\n-# Examples\n-\n-To create a new random (V4) UUID and print it out in hexadecimal form:\n-\n-```rust\n-# #![allow(deprecated)]\n-# extern crate uuid;\n-use uuid::Uuid;\n-\n-fn main() {\n-    let uuid1 = Uuid::new_v4();\n-    println!(\"{}\", uuid1.to_string());\n-}\n-```\n-\n-# Strings\n-\n-Examples of string representations:\n-\n-* simple: `936DA01F9ABD4d9d80C702AF85C822A8`\n-* hyphenated: `550e8400-e29b-41d4-a716-446655440000`\n-* urn: `urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4`\n-\n-# References\n-\n-* [Wikipedia: Universally Unique Identifier](\n-    http://en.wikipedia.org/wiki/Universally_unique_identifier)\n-* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](\n-    http://tools.ietf.org/html/rfc4122)\n-\n-*/\n-\n-#![crate_name = \"uuid\"]\n-#![deprecated = \"This is now a cargo package located at: \\\n-                 https://github.com/rust-lang/uuid\"]\n-#![allow(deprecated)]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![license = \"MIT/ASL2\"]\n-#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n-\n-#![feature(default_type_params)]\n-\n-// test harness access\n-#[cfg(test)]\n-extern crate test;\n-extern crate serialize;\n-\n-use std::char::Char;\n-use std::default::Default;\n-use std::fmt;\n-use std::from_str::FromStr;\n-use std::hash;\n-use std::mem::{transmute,transmute_copy};\n-use std::num::FromStrRadix;\n-use std::rand;\n-use std::rand::Rng;\n-use std::slice;\n-\n-use serialize::{Encoder, Encodable, Decoder, Decodable};\n-\n-/// A 128-bit (16 byte) buffer containing the ID\n-pub type UuidBytes = [u8, ..16];\n-\n-/// The version of the UUID, denoting the generating algorithm\n-#[deriving(PartialEq)]\n-pub enum UuidVersion {\n-    /// Version 1: MAC address\n-    Version1Mac    = 1,\n-    /// Version 2: DCE Security\n-    Version2Dce    = 2,\n-    /// Version 3: MD5 hash\n-    Version3Md5    = 3,\n-    /// Version 4: Random\n-    Version4Random = 4,\n-    /// Version 5: SHA-1 hash\n-    Version5Sha1   = 5,\n-}\n-\n-/// The reserved variants of UUIDs\n-#[deriving(PartialEq)]\n-pub enum UuidVariant {\n-    /// Reserved by the NCS for backward compatibility\n-    VariantNCS,\n-    /// As described in the RFC4122 Specification (default)\n-    VariantRFC4122,\n-    /// Reserved by Microsoft for backward compatibility\n-    VariantMicrosoft,\n-    /// Reserved for future expansion\n-    VariantFuture,\n-}\n-\n-/// A Universally Unique Identifier (UUID)\n-pub struct Uuid {\n-    /// The 128-bit number stored in 16 bytes\n-    bytes: UuidBytes\n-}\n-\n-impl<S: hash::Writer> hash::Hash<S> for Uuid {\n-    fn hash(&self, state: &mut S) {\n-        self.bytes.hash(state)\n-    }\n-}\n-\n-/// A UUID stored as fields (identical to UUID, used only for conversions)\n-struct UuidFields {\n-    /// First field, 32-bit word\n-    data1: u32,\n-    /// Second field, 16-bit short\n-    data2: u16,\n-    /// Third field, 16-bit short\n-    data3: u16,\n-    /// Fourth field, 8 bytes\n-    data4: [u8, ..8]\n-}\n-\n-/// Error details for string parsing failures\n-#[allow(missing_doc)]\n-pub enum ParseError {\n-    ErrorInvalidLength(uint),\n-    ErrorInvalidCharacter(char, uint),\n-    ErrorInvalidGroups(uint),\n-    ErrorInvalidGroupLength(uint, uint, uint),\n-}\n-\n-/// Converts a ParseError to a string\n-impl fmt::Show for ParseError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ErrorInvalidLength(found) =>\n-                write!(f, \"Invalid length; expecting 32, 36 or 45 chars, \\\n-                           found {}\", found),\n-            ErrorInvalidCharacter(found, pos) =>\n-                write!(f, \"Invalid character; found `{}` (0x{:02x}) at \\\n-                           offset {}\", found, found as uint, pos),\n-            ErrorInvalidGroups(found) =>\n-                write!(f, \"Malformed; wrong number of groups: expected 1 \\\n-                           or 5, found {}\", found),\n-            ErrorInvalidGroupLength(group, found, expecting) =>\n-                write!(f, \"Malformed; length of group {} was {}, \\\n-                           expecting {}\", group, found, expecting),\n-        }\n-    }\n-}\n-\n-// Length of each hyphenated group in hex digits\n-#[allow(non_uppercase_statics)]\n-static UuidGroupLens: [uint, ..5] = [8u, 4u, 4u, 4u, 12u];\n-\n-/// UUID support\n-impl Uuid {\n-    /// Returns a nil or empty UUID (containing all zeroes)\n-    pub fn nil() -> Uuid {\n-        let uuid = Uuid{ bytes: [0, .. 16] };\n-        uuid\n-    }\n-\n-    /// Create a new UUID of the specified version\n-    pub fn new(v: UuidVersion) -> Option<Uuid> {\n-        match v {\n-            Version4Random => Some(Uuid::new_v4()),\n-            _ => None\n-        }\n-    }\n-\n-    /// Creates a new random UUID\n-    ///\n-    /// Uses the `rand` module's default RNG task as the source\n-    /// of random numbers. Use the rand::Rand trait to supply\n-    /// a custom generator if required.\n-    pub fn new_v4() -> Uuid {\n-        let ub = rand::task_rng().gen_iter::<u8>().take(16).collect::<Vec<_>>();\n-        let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        slice::bytes::copy_memory(uuid.bytes, ub.as_slice());\n-        uuid.set_variant(VariantRFC4122);\n-        uuid.set_version(Version4Random);\n-        uuid\n-    }\n-\n-    /// Creates a UUID using the supplied field values\n-    ///\n-    /// # Arguments\n-    /// * `d1` A 32-bit word\n-    /// * `d2` A 16-bit word\n-    /// * `d3` A 16-bit word\n-    /// * `d4` Array of 8 octets\n-    pub fn from_fields(d1: u32, d2: u16, d3: u16, d4: &[u8]) -> Uuid {\n-        // First construct a temporary field-based struct\n-        let mut fields = UuidFields {\n-                data1: 0,\n-                data2: 0,\n-                data3: 0,\n-                data4: [0, ..8]\n-        };\n-\n-        fields.data1 = d1.to_be();\n-        fields.data2 = d2.to_be();\n-        fields.data3 = d3.to_be();\n-        slice::bytes::copy_memory(fields.data4, d4);\n-\n-        unsafe {\n-            transmute(fields)\n-        }\n-    }\n-\n-    /// Creates a UUID using the supplied bytes\n-    ///\n-    /// # Arguments\n-    /// * `b` An array or slice of 16 bytes\n-    pub fn from_bytes(b: &[u8]) -> Option<Uuid> {\n-        if b.len() != 16 {\n-            return None\n-        }\n-\n-        let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        slice::bytes::copy_memory(uuid.bytes, b);\n-        Some(uuid)\n-    }\n-\n-    /// Specifies the variant of the UUID structure\n-    fn set_variant(&mut self, v: UuidVariant) {\n-        // Octet 8 contains the variant in the most significant 3 bits\n-        match v {\n-            VariantNCS =>        // b0xx...\n-                self.bytes[8] =  self.bytes[8] & 0x7f,\n-            VariantRFC4122 =>    // b10x...\n-                self.bytes[8] = (self.bytes[8] & 0x3f) | 0x80,\n-            VariantMicrosoft =>  // b110...\n-                self.bytes[8] = (self.bytes[8] & 0x1f) | 0xc0,\n-            VariantFuture =>     // b111...\n-                self.bytes[8] = (self.bytes[8] & 0x1f) | 0xe0,\n-        }\n-    }\n-\n-    /// Returns the variant of the UUID structure\n-    ///\n-    /// This determines the interpretation of the structure of the UUID.\n-    /// Currently only the RFC4122 variant is generated by this module.\n-    ///\n-    /// * [Variant Reference](http://tools.ietf.org/html/rfc4122#section-4.1.1)\n-    pub fn get_variant(&self) -> Option<UuidVariant> {\n-        if self.bytes[8] & 0x80 == 0x00 {\n-            Some(VariantNCS)\n-        } else if self.bytes[8] & 0xc0 == 0x80 {\n-            Some(VariantRFC4122)\n-        } else if self.bytes[8] & 0xe0 == 0xc0  {\n-            Some(VariantMicrosoft)\n-        } else if self.bytes[8] & 0xe0 == 0xe0 {\n-            Some(VariantFuture)\n-        } else  {\n-            None\n-        }\n-    }\n-\n-    /// Specifies the version number of the UUID\n-    fn set_version(&mut self, v: UuidVersion) {\n-        self.bytes[6] = (self.bytes[6] & 0xF) | ((v as u8) << 4);\n-    }\n-\n-    /// Returns the version number of the UUID\n-    ///\n-    /// This represents the algorithm used to generate the contents.\n-    ///\n-    /// Currently only the Random (V4) algorithm is supported by this\n-    /// module.  There are security and privacy implications for using\n-    /// older versions - see [Wikipedia: Universally Unique Identifier](\n-    /// http://en.wikipedia.org/wiki/Universally_unique_identifier) for\n-    /// details.\n-    ///\n-    /// * [Version Reference](http://tools.ietf.org/html/rfc4122#section-4.1.3)\n-    pub fn get_version_num(&self) -> uint {\n-        (self.bytes[6] >> 4) as uint\n-    }\n-\n-    /// Returns the version of the UUID\n-    ///\n-    /// This represents the algorithm used to generate the contents\n-    pub fn get_version(&self) -> Option<UuidVersion> {\n-        let v = self.bytes[6] >> 4;\n-        match v {\n-            1 => Some(Version1Mac),\n-            2 => Some(Version2Dce),\n-            3 => Some(Version3Md5),\n-            4 => Some(Version4Random),\n-            5 => Some(Version5Sha1),\n-            _ => None\n-        }\n-    }\n-\n-    /// Return an array of 16 octets containing the UUID data\n-    pub fn as_bytes(&self) -> &[u8] {\n-        self.bytes.as_slice()\n-    }\n-\n-    /// Returns the UUID as a string of 16 hexadecimal digits\n-    ///\n-    /// Example: `936DA01F9ABD4d9d80C702AF85C822A8`\n-    pub fn to_simple_str(&self) -> String {\n-        let mut s: Vec<u8> = Vec::from_elem(32, 0u8);\n-        for i in range(0u, 16u) {\n-            let digit = format!(\"{:02x}\", self.bytes[i] as uint);\n-            *s.get_mut(i*2+0) = digit.as_bytes()[0];\n-            *s.get_mut(i*2+1) = digit.as_bytes()[1];\n-        }\n-        String::from_utf8(s).unwrap()\n-    }\n-\n-    /// Returns a string of hexadecimal digits, separated into groups with a hyphen.\n-    ///\n-    /// Example: `550e8400-e29b-41d4-a716-446655440000`\n-    pub fn to_hyphenated_str(&self) -> String {\n-        // Convert to field-based struct as it matches groups in output.\n-        // Ensure fields are in network byte order, as per RFC.\n-        let mut uf: UuidFields;\n-        unsafe {\n-            uf = transmute_copy(&self.bytes);\n-        }\n-        uf.data1 = uf.data1.to_be();\n-        uf.data2 = uf.data2.to_be();\n-        uf.data3 = uf.data3.to_be();\n-        let s = format!(\"{:08x}-{:04x}-{:04x}-{:02x}{:02x}-\\\n-                         {:02x}{:02x}{:02x}{:02x}{:02x}{:02x}\",\n-            uf.data1,\n-            uf.data2, uf.data3,\n-            uf.data4[0], uf.data4[1],\n-            uf.data4[2], uf.data4[3], uf.data4[4],\n-            uf.data4[5], uf.data4[6], uf.data4[7]);\n-        s\n-    }\n-\n-    /// Returns the UUID formatted as a full URN string\n-    ///\n-    /// This is the same as the hyphenated format, but with the \"urn:uuid:\" prefix.\n-    ///\n-    /// Example: `urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4`\n-    pub fn to_urn_str(&self) -> String {\n-        format!(\"urn:uuid:{}\", self.to_hyphenated_str())\n-    }\n-\n-    /// Parses a UUID from a string of hexadecimal digits with optional hyphens\n-    ///\n-    /// Any of the formats generated by this module (simple, hyphenated, urn) are\n-    /// supported by this parsing function.\n-    pub fn parse_string(us: &str) -> Result<Uuid, ParseError> {\n-\n-        let mut us = us.clone();\n-        let orig_len = us.len();\n-\n-        // Ensure length is valid for any of the supported formats\n-        if orig_len != 32 && orig_len != 36 && orig_len != 45 {\n-            return Err(ErrorInvalidLength(orig_len));\n-        }\n-\n-        // Strip off URN prefix if present\n-        if us.starts_with(\"urn:uuid:\") {\n-            us = us.slice(9, orig_len);\n-        }\n-\n-        // Make sure all chars are either hex digits or hyphen\n-        for (i, c) in us.chars().enumerate() {\n-            match c {\n-                '0'...'9' | 'A'...'F' | 'a'...'f' | '-' => {},\n-                _ => return Err(ErrorInvalidCharacter(c, i)),\n-            }\n-        }\n-\n-        // Split string up by hyphens into groups\n-        let hex_groups: Vec<&str> = us.split_str(\"-\").collect();\n-\n-        // Get the length of each group\n-        let group_lens: Vec<uint> = hex_groups.iter().map(|&v| v.len()).collect();\n-\n-        // Ensure the group lengths are valid\n-        match group_lens.len() {\n-            // Single group, no hyphens\n-            1 => {\n-                if group_lens[0] != 32 {\n-                    return Err(ErrorInvalidLength(group_lens[0]));\n-                }\n-            },\n-            // Five groups, hyphens in between each\n-            5 => {\n-                // Ensure each group length matches the expected\n-                for (i, (&gl, &expected)) in\n-                    group_lens.iter().zip(UuidGroupLens.iter()).enumerate() {\n-                    if gl != expected {\n-                        return Err(ErrorInvalidGroupLength(i, gl, expected))\n-                    }\n-                }\n-            },\n-            _ => {\n-                return Err(ErrorInvalidGroups(group_lens.len()));\n-            }\n-        }\n-\n-        // Normalise into one long hex string\n-        let vs = hex_groups.concat();\n-\n-        // At this point, we know we have a valid hex string, without hyphens\n-        assert!(vs.len() == 32);\n-        assert!(vs.as_slice().chars().all(|c| c.is_digit_radix(16)));\n-\n-        // Allocate output UUID buffer\n-        let mut ub = [0u8, ..16];\n-\n-        // Extract each hex digit from the string\n-        for i in range(0u, 16u) {\n-            ub[i] = FromStrRadix::from_str_radix(vs.as_slice()\n-                                                   .slice(i*2, (i+1)*2),\n-                                                 16).unwrap();\n-        }\n-\n-        Ok(Uuid::from_bytes(ub).unwrap())\n-    }\n-\n-    /// Tests if the UUID is nil\n-    pub fn is_nil(&self) -> bool {\n-        return self.bytes.iter().all(|&b| b == 0);\n-    }\n-}\n-\n-impl Default for Uuid {\n-    /// Returns the nil UUID, which is all zeroes\n-    fn default() -> Uuid {\n-        Uuid::nil()\n-    }\n-}\n-\n-impl Clone for Uuid {\n-    /// Returns a copy of the UUID\n-    fn clone(&self) -> Uuid { *self }\n-}\n-\n-impl FromStr for Uuid {\n-    /// Parse a hex string and interpret as a UUID\n-    ///\n-    /// Accepted formats are a sequence of 32 hexadecimal characters,\n-    /// with or without hyphens (grouped as 8, 4, 4, 4, 12).\n-    fn from_str(us: &str) -> Option<Uuid> {\n-        let result = Uuid::parse_string(us);\n-        match result {\n-            Ok(u) => Some(u),\n-            Err(_) => None\n-        }\n-    }\n-}\n-\n-/// Convert the UUID to a hexadecimal-based string representation\n-impl fmt::Show for Uuid {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.to_simple_str())\n-    }\n-}\n-\n-/// Test two UUIDs for equality\n-///\n-/// UUIDs are equal only when they are byte-for-byte identical\n-impl PartialEq for Uuid {\n-    fn eq(&self, other: &Uuid) -> bool {\n-        self.bytes == other.bytes\n-    }\n-}\n-\n-impl Eq for Uuid {}\n-\n-// FIXME #9845: Test these more thoroughly\n-impl<T: Encoder<E>, E> Encodable<T, E> for Uuid {\n-    /// Encode a UUID as a hyphenated string\n-    fn encode(&self, e: &mut T) -> Result<(), E> {\n-        e.emit_str(self.to_hyphenated_str().as_slice())\n-    }\n-}\n-\n-impl<T: Decoder<E>, E> Decodable<T, E> for Uuid {\n-    /// Decode a UUID from a string\n-    fn decode(d: &mut T) -> Result<Uuid, E> {\n-        match from_str(try!(d.read_str()).as_slice()) {\n-            Some(decode) => Ok(decode),\n-            None => Err(d.error(\"Unable to decode UUID\"))\n-        }\n-    }\n-}\n-\n-/// Generates a random instance of UUID (V4 conformant)\n-impl rand::Rand for Uuid {\n-    #[inline]\n-    fn rand<R: rand::Rng>(rng: &mut R) -> Uuid {\n-        let ub = rng.gen_iter::<u8>().take(16).collect::<Vec<_>>();\n-        let mut uuid = Uuid{ bytes: [0, .. 16] };\n-        slice::bytes::copy_memory(uuid.bytes, ub.as_slice());\n-        uuid.set_variant(VariantRFC4122);\n-        uuid.set_version(Version4Random);\n-        uuid\n-    }\n-}\n-\n-#[cfg(test)]\n-mod uuidtest {\n-    use super::{Uuid, VariantMicrosoft, VariantNCS, VariantRFC4122,\n-                Version1Mac, Version2Dce, Version3Md5, Version4Random,\n-                Version5Sha1};\n-    use std::rand;\n-\n-    #[test]\n-    fn test_nil() {\n-        let nil = Uuid::nil();\n-        let not_nil = Uuid::new_v4();\n-\n-        assert!(nil.is_nil());\n-        assert!(!not_nil.is_nil());\n-    }\n-\n-    #[test]\n-    fn test_new() {\n-        // Supported\n-        let uuid1 = Uuid::new(Version4Random).unwrap();\n-        let s = uuid1.to_simple_str();\n-\n-        assert!(s.len() == 32);\n-        assert!(uuid1.get_version().unwrap() == Version4Random);\n-\n-        // Test unsupported versions\n-        assert!(Uuid::new(Version1Mac) == None);\n-        assert!(Uuid::new(Version2Dce) == None);\n-        assert!(Uuid::new(Version3Md5) == None);\n-        assert!(Uuid::new(Version5Sha1) == None);\n-    }\n-\n-    #[test]\n-    fn test_new_v4() {\n-        let uuid1 = Uuid::new_v4();\n-\n-        assert!(uuid1.get_version().unwrap() == Version4Random);\n-        assert!(uuid1.get_variant().unwrap() == VariantRFC4122);\n-    }\n-\n-    #[test]\n-    fn test_get_version() {\n-        let uuid1 = Uuid::new_v4();\n-\n-        assert!(uuid1.get_version().unwrap() == Version4Random);\n-        assert!(uuid1.get_version_num() == 4);\n-    }\n-\n-    #[test]\n-    fn test_get_variant() {\n-        let uuid1 = Uuid::new_v4();\n-        let uuid2 = Uuid::parse_string(\"550e8400-e29b-41d4-a716-446655440000\").unwrap();\n-        let uuid3 = Uuid::parse_string(\"67e55044-10b1-426f-9247-bb680e5fe0c8\").unwrap();\n-        let uuid4 = Uuid::parse_string(\"936DA01F9ABD4d9dC0C702AF85C822A8\").unwrap();\n-        let uuid5 = Uuid::parse_string(\"F9168C5E-CEB2-4faa-D6BF-329BF39FA1E4\").unwrap();\n-        let uuid6 = Uuid::parse_string(\"f81d4fae-7dec-11d0-7765-00a0c91e6bf6\").unwrap();\n-\n-        assert!(uuid1.get_variant().unwrap() == VariantRFC4122);\n-        assert!(uuid2.get_variant().unwrap() == VariantRFC4122);\n-        assert!(uuid3.get_variant().unwrap() == VariantRFC4122);\n-        assert!(uuid4.get_variant().unwrap() == VariantMicrosoft);\n-        assert!(uuid5.get_variant().unwrap() == VariantMicrosoft);\n-        assert!(uuid6.get_variant().unwrap() == VariantNCS);\n-    }\n-\n-    #[test]\n-    fn test_parse_uuid_v4() {\n-        use super::{ErrorInvalidCharacter, ErrorInvalidGroups,\n-                    ErrorInvalidGroupLength, ErrorInvalidLength};\n-\n-        // Invalid\n-        assert!(Uuid::parse_string(\"\").is_err());\n-        assert!(Uuid::parse_string(\"!\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-B6BF-329BF39FA1E45\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-BBF-329BF39FA1E4\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-BGBF-329BF39FA1E4\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-B6BFF329BF39FA1E4\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faaXB6BFF329BF39FA1E4\").is_err());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB-24fa-eB6BFF32-BF39FA1E4\").is_err());\n-        assert!(Uuid::parse_string(\"01020304-1112-2122-3132-41424344\").is_err());\n-        assert!(Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0c\").is_err());\n-        assert!(Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0c88\").is_err());\n-        assert!(Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0cg8\").is_err());\n-        assert!(Uuid::parse_string(\"67e5504410b1426%9247bb680e5fe0c8\").is_err());\n-\n-        // Valid\n-        assert!(Uuid::parse_string(\"00000000000000000000000000000000\").is_ok());\n-        assert!(Uuid::parse_string(\"67e55044-10b1-426f-9247-bb680e5fe0c8\").is_ok());\n-        assert!(Uuid::parse_string(\"67e55044-10b1-426f-9247-bb680e5fe0c8\").is_ok());\n-        assert!(Uuid::parse_string(\"F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4\").is_ok());\n-        assert!(Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0c8\").is_ok());\n-        assert!(Uuid::parse_string(\"01020304-1112-2122-3132-414243444546\").is_ok());\n-        assert!(Uuid::parse_string(\"urn:uuid:67e55044-10b1-426f-9247-bb680e5fe0c8\").is_ok());\n-\n-        // Nil\n-        let nil = Uuid::nil();\n-        assert!(Uuid::parse_string(\"00000000000000000000000000000000\").unwrap()  == nil);\n-        assert!(Uuid::parse_string(\"00000000-0000-0000-0000-000000000000\").unwrap() == nil);\n-\n-        // Round-trip\n-        let uuid_orig = Uuid::new_v4();\n-        let orig_str = uuid_orig.to_string();\n-        let uuid_out = Uuid::parse_string(orig_str.as_slice()).unwrap();\n-        assert!(uuid_orig == uuid_out);\n-\n-        // Test error reporting\n-        let e = Uuid::parse_string(\"67e5504410b1426f9247bb680e5fe0c\").unwrap_err();\n-        assert!(match e { ErrorInvalidLength(n) => n==31, _ => false });\n-\n-        let e = Uuid::parse_string(\"67e550X410b1426f9247bb680e5fe0cd\").unwrap_err();\n-        assert!(match e { ErrorInvalidCharacter(c, n) => c=='X' && n==6, _ => false });\n-\n-        let e = Uuid::parse_string(\"67e550-4105b1426f9247bb680e5fe0c\").unwrap_err();\n-        assert!(match e { ErrorInvalidGroups(n) => n==2, _ => false });\n-\n-        let e = Uuid::parse_string(\"F9168C5E-CEB2-4faa-B6BF1-02BF39FA1E4\").unwrap_err();\n-        assert!(match e { ErrorInvalidGroupLength(g, n, e) => g==3 && n==5 && e==4, _ => false });\n-    }\n-\n-    #[test]\n-    fn test_to_simple_str() {\n-        let uuid1 = Uuid::new_v4();\n-        let s = uuid1.to_simple_str();\n-\n-        assert!(s.len() == 32);\n-        assert!(s.as_slice().chars().all(|c| c.is_digit_radix(16)));\n-    }\n-\n-    #[test]\n-    fn test_to_string() {\n-        let uuid1 = Uuid::new_v4();\n-        let s = uuid1.to_string();\n-\n-        assert!(s.len() == 32);\n-        assert!(s.as_slice().chars().all(|c| c.is_digit_radix(16)));\n-    }\n-\n-    #[test]\n-    fn test_to_hyphenated_str() {\n-        let uuid1 = Uuid::new_v4();\n-        let s = uuid1.to_hyphenated_str();\n-\n-        assert!(s.len() == 36);\n-        assert!(s.as_slice().chars().all(|c| c.is_digit_radix(16) || c == '-'));\n-    }\n-\n-    #[test]\n-    fn test_to_urn_str() {\n-        let uuid1 = Uuid::new_v4();\n-        let ss = uuid1.to_urn_str();\n-        let s = ss.as_slice().slice(9, ss.len());\n-\n-        assert!(ss.as_slice().starts_with(\"urn:uuid:\"));\n-        assert!(s.len() == 36);\n-        assert!(s.as_slice()\n-                 .chars()\n-                 .all(|c| c.is_digit_radix(16) || c == '-'));\n-    }\n-\n-    #[test]\n-    fn test_to_str_matching() {\n-        let uuid1 = Uuid::new_v4();\n-\n-        let hs = uuid1.to_hyphenated_str();\n-        let ss = uuid1.to_string();\n-\n-        let hsn = String::from_chars(hs.as_slice()\n-                                    .chars()\n-                                    .filter(|&c| c != '-')\n-                                    .collect::<Vec<char>>()\n-                                    .as_slice());\n-\n-        assert!(hsn == ss);\n-    }\n-\n-    #[test]\n-    fn test_string_roundtrip() {\n-        let uuid = Uuid::new_v4();\n-\n-        let hs = uuid.to_hyphenated_str();\n-        let uuid_hs = Uuid::parse_string(hs.as_slice()).unwrap();\n-        assert!(uuid_hs == uuid);\n-\n-        let ss = uuid.to_string();\n-        let uuid_ss = Uuid::parse_string(ss.as_slice()).unwrap();\n-        assert!(uuid_ss == uuid);\n-    }\n-\n-    #[test]\n-    fn test_compare() {\n-        let uuid1 = Uuid::new_v4();\n-        let uuid2 = Uuid::new_v4();\n-\n-        assert!(uuid1 == uuid1);\n-        assert!(uuid2 == uuid2);\n-        assert!(uuid1 != uuid2);\n-        assert!(uuid2 != uuid1);\n-    }\n-\n-    #[test]\n-    fn test_from_fields() {\n-        let d1: u32 = 0xa1a2a3a4;\n-        let d2: u16 = 0xb1b2;\n-        let d3: u16 = 0xc1c2;\n-        let d4: Vec<u8> = vec!(0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8);\n-\n-        let u = Uuid::from_fields(d1, d2, d3, d4.as_slice());\n-\n-        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_string();\n-        let result = u.to_simple_str();\n-        assert!(result == expected);\n-    }\n-\n-    #[test]\n-    fn test_from_bytes() {\n-        let b = vec!( 0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2,\n-                   0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8 );\n-\n-        let u = Uuid::from_bytes(b.as_slice()).unwrap();\n-        let expected = \"a1a2a3a4b1b2c1c2d1d2d3d4d5d6d7d8\".to_string();\n-\n-        assert!(u.to_simple_str() == expected);\n-    }\n-\n-    #[test]\n-    fn test_as_bytes() {\n-        let u = Uuid::new_v4();\n-        let ub = u.as_bytes();\n-\n-        assert!(ub.len() == 16);\n-        assert!(! ub.iter().all(|&b| b == 0));\n-    }\n-\n-    #[test]\n-    fn test_bytes_roundtrip() {\n-        let b_in: [u8, ..16] = [ 0xa1, 0xa2, 0xa3, 0xa4, 0xb1, 0xb2, 0xc1, 0xc2,\n-                                 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8 ];\n-\n-        let u = Uuid::from_bytes(b_in.clone()).unwrap();\n-\n-        let b_out = u.as_bytes();\n-\n-        assert!(b_in == b_out);\n-    }\n-\n-    #[test]\n-    fn test_operator_eq() {\n-        let u1 = Uuid::new_v4();\n-        let u2 = u1.clone();\n-        let u3 = Uuid::new_v4();\n-\n-        assert!(u1 == u1);\n-        assert!(u1 == u2);\n-        assert!(u2 == u1);\n-\n-        assert!(u1 != u3);\n-        assert!(u3 != u1);\n-        assert!(u2 != u3);\n-        assert!(u3 != u2);\n-    }\n-\n-    #[test]\n-    fn test_rand_rand() {\n-        let mut rng = rand::task_rng();\n-        let u: Uuid = rand::Rand::rand(&mut rng);\n-        let ub = u.as_bytes();\n-\n-        assert!(ub.len() == 16);\n-        assert!(! ub.iter().all(|&b| b == 0));\n-    }\n-\n-    #[test]\n-    fn test_serialize_round_trip() {\n-        use serialize::json;\n-\n-        let u = Uuid::new_v4();\n-        let s = json::encode(&u);\n-        let u2 = json::decode(s.as_slice()).unwrap();\n-        assert_eq!(u, u2);\n-    }\n-\n-    #[test]\n-    fn test_bad_decode() {\n-        use serialize::json;\n-        use serialize::{Decodable};\n-\n-        let js_good = json::String(\"a1a2a3a4a5a6a7a8a1a2a3a4a5a6a7a8\".to_string());\n-        let js_bad1 = json::String(\"a1a2a3a4a5a6a7a8a1a2a3a4a5a6a7ah\".to_string());\n-        let js_bad2 = json::String(\"a1a2a3a4a5a6a7a8a1a2a3a4a5a6a7a\".to_string());\n-\n-        let u_good: Result<Uuid, _> = Decodable::decode(&mut json::Decoder::new(js_good));\n-        let u_bad1: Result<Uuid, _> = Decodable::decode(&mut json::Decoder::new(js_bad1));\n-        let u_bad2: Result<Uuid, _> = Decodable::decode(&mut json::Decoder::new(js_bad2));\n-        assert!(u_good.is_ok());\n-        assert!(u_bad1.is_err());\n-        assert!(u_bad2.is_err());\n-    }\n-\n-    #[test]\n-    fn test_iterbytes_impl_for_uuid() {\n-        use std::collections::HashSet;\n-        let mut set = HashSet::new();\n-        let id1 = Uuid::new_v4();\n-        let id2 = Uuid::new_v4();\n-        set.insert(id1);\n-        assert!(set.contains(&id1));\n-        assert!(!set.contains(&id2));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use super::Uuid;\n-\n-    #[bench]\n-    pub fn create_uuids(b: &mut Bencher) {\n-        b.iter(|| {\n-            Uuid::new_v4();\n-        })\n-    }\n-\n-    #[bench]\n-    pub fn uuid_to_string(b: &mut Bencher) {\n-        let u = Uuid::new_v4();\n-        b.iter(|| {\n-            u.to_string();\n-        })\n-    }\n-\n-    #[bench]\n-    pub fn parse_str(b: &mut Bencher) {\n-        let s = \"urn:uuid:F9168C5E-CEB2-4faa-B6BF-329BF39FA1E4\";\n-        b.iter(|| {\n-            Uuid::parse_string(s).unwrap();\n-        })\n-    }\n-}"}, {"sha": "12ab62267a363c1a5d4ff88ef7d0afdbe66d6d6f", "filename": "src/test/auxiliary/anon-extern-mod-cross-crate-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"anonexternmod#0.1\"]\n+#![crate_name=\"anonexternmod\"]\n \n extern crate libc;\n "}, {"sha": "40a9a52061fe5a97066ce9f293e03bca142c7523", "filename": "src/test/auxiliary/cci_impl_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"cci_impl_lib\"]\n+#![crate_name=\"cci_impl_lib\"]\n \n pub trait uint_helpers {\n     fn to(&self, v: uint, f: |uint|);"}, {"sha": "84ade3572f95c158256735b2e897b3e7b3dda011", "filename": "src/test/auxiliary/cci_iter_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"cci_iter_lib\"]\n+#![crate_name=\"cci_iter_lib\"]\n \n #[inline]\n pub fn iter<T>(v: &[T], f: |&T|) {"}, {"sha": "67f55cca1e16b78b688cb35c84421306733a0982", "filename": "src/test/auxiliary/cci_no_inline_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"cci_no_inline_lib\"]\n+#![crate_name=\"cci_no_inline_lib\"]\n \n \n // same as cci_iter_lib, more-or-less, but not marked inline\n pub fn iter(v: Vec<uint> , f: |uint|) {\n     let mut i = 0u;\n     let n = v.len();\n     while i < n {\n-        f(*v.get(i));\n+        f(v[i]);\n         i += 1u;\n     }\n }"}, {"sha": "18162c5f756b8ed3644b742c22726d7eebf95973", "filename": "src/test/auxiliary/changing-crates-a1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fchanging-crates-a1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fchanging-crates-a1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-a1.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n pub fn foo<T>() {}"}, {"sha": "a54dcbbbfc24538eadf991054b8794c708601e47", "filename": "src/test/auxiliary/changing-crates-a2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-a2.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n pub fn foo<T>() { println!(\"hello!\"); }\n "}, {"sha": "81f924e29daa73f29bece01f2100224249b69714", "filename": "src/test/auxiliary/changing-crates-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id = \"b\"]\n+#![crate_name = \"b\"]\n \n extern crate a;\n "}, {"sha": "f3d5bf2d65eeea578bc6b75980c963570f96c84f", "filename": "src/test/auxiliary/crate-method-reexport-grrrrrrr2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrate-method-reexport-grrrrrrr2.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crate_method_reexport_grrrrrrr2\"]\n+#![crate_name=\"crate_method_reexport_grrrrrrr2\"]\n \n pub use name_pool::add;\n "}, {"sha": "473528c681e7fb9eda5cc1530c130c56ece3cef1", "filename": "src/test/auxiliary/crateresolve3-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve3-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve3-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve3-1.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve3#0.1\"]\n+#![crate_name=\"crateresolve3#0.1\"]\n \n #![crate_type = \"lib\"]\n "}, {"sha": "1e95fa6b63903fcdcb7390d61670a468f303ce7d", "filename": "src/test/auxiliary/crateresolve3-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve3-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve3-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve3-2.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve3#0.2\"]\n+#![crate_name=\"crateresolve3#0.2\"]\n \n #![crate_type = \"lib\"]\n "}, {"sha": "68a69f6dc9073c90c397b65be42581faa0bfa000", "filename": "src/test/auxiliary/crateresolve4a-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-1.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve4a#0.1\"]\n+#![crate_name=\"crateresolve4a#0.1\"]\n #![crate_type = \"lib\"]\n \n pub fn f() -> int { 10 }"}, {"sha": "6e23fddbce7dffbe10a209840647f234ced818f0", "filename": "src/test/auxiliary/crateresolve4a-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-2.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve4a#0.2\"]\n+#![crate_name=\"crateresolve4a#0.2\"]\n #![crate_type = \"lib\"]\n \n pub fn g() -> int { 20 }"}, {"sha": "843fd57ee40d745641e39eed9b50173e63e37d57", "filename": "src/test/auxiliary/crateresolve4b-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-1.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:crateresolve4a-1.rs\n // aux-build:crateresolve4a-2.rs\n-#![crate_id=\"crateresolve4b#0.1\"]\n+#![crate_name=\"crateresolve4b#0.1\"]\n #![crate_type = \"lib\"]\n \n extern crate \"crateresolve4a#0.2\" as crateresolve4a;"}, {"sha": "28c89c79316e2a31f395c6703ed27a3cd0f0c92a", "filename": "src/test/auxiliary/crateresolve4b-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-2.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -10,7 +10,7 @@\n \n // aux-build:crateresolve4a-1.rs\n // aux-build:crateresolve4a-2.rs\n-#![crate_id=\"crateresolve4b#0.2\"]\n+#![crate_name=\"crateresolve4b#0.2\"]\n #![crate_type = \"lib\"]\n \n extern crate \"crateresolve4a#0.1\" as crateresolve4a;"}, {"sha": "223e4f50ae8acb03ccc8ad15df9d37d5e88d3bd3", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve5#0.1\"]\n+#![crate_name=\"crateresolve5#0.1\"]\n \n #![crate_type = \"lib\"]\n "}, {"sha": "38740886b37ea18edb985fb03bc1eca85787be67", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve5#0.2\"]\n+#![crate_name=\"crateresolve5#0.2\"]\n \n #![crate_type = \"lib\"]\n "}, {"sha": "5262d662971a43c82f573d45a57cd97e5ecfe9ba", "filename": "src/test/auxiliary/crateresolve8-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve8-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve8-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve8-1.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // default link meta for 'package_id' will be equal to filestem\n-#![crate_id=\"crateresolve8#0.1\"]\n+#![crate_name=\"crateresolve8#0.1\"]\n \n #![crate_type = \"lib\"]\n "}, {"sha": "4dba722971e3cd7e4cee8964147e841ab7c112ed", "filename": "src/test/auxiliary/crateresolve_calories-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve_calories#0.1\"]\n+#![crate_name=\"crateresolve_calories#0.1\"]\n #![crate_type = \"lib\"]\n \n pub fn f() -> int { 100 }"}, {"sha": "c7e26c8f506d43f1ef5c466176266cefb727c474", "filename": "src/test/auxiliary/crateresolve_calories-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"crateresolve_calories#0.1\"]\n+#![crate_name=\"crateresolve_calories#0.1\"]\n #![crate_type = \"lib\"]\n \n pub fn f() -> int { 200 }"}, {"sha": "a5d672e3c0cf90d004d64151620c056751cb1c6a", "filename": "src/test/auxiliary/foreign_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fforeign_lib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"foreign_lib\"]\n+#![crate_name=\"foreign_lib\"]\n \n pub mod rustrt {\n     extern crate libc;"}, {"sha": "4016a76206be4e51aca898cf97bf3599bdb18ab3", "filename": "src/test/auxiliary/inherited_stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finherited_stability.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![crate_id=\"inherited_stability#0.1\"]\n+#![crate_name=\"inherited_stability\"]\n #![crate_type = \"lib\"]\n #![experimental]\n "}, {"sha": "dd1fdc2e4981f8903def8db742b4f9be0df56452", "filename": "src/test/auxiliary/inline_dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Finline_dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Finline_dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finline_dtor.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"inline_dtor#0.1\"]\n+#![crate_name=\"inline_dtor\"]\n \n pub struct Foo;\n "}, {"sha": "37edcdf7628988b6e7419de9a548723ae32be76e", "filename": "src/test/auxiliary/iss.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fiss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fiss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fiss.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"issue6919_3#0.1\"]\n+#![crate_name=\"issue6919_3\"]\n \n // part of issue-6919.rs\n "}, {"sha": "af6bb050ef5a0c9ece93c664d3cd91b0c4529040", "filename": "src/test/auxiliary/issue-2380.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-2380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2380.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"a\"]\n+#![crate_name=\"a\"]\n #![crate_type = \"lib\"]\n \n "}, {"sha": "fe1ef549d06acc107b6125e1a8e57ab31483f991", "filename": "src/test/auxiliary/issue-2414-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"a#0.1\"]\n+#![crate_name=\"a\"]\n #![crate_type = \"lib\"]\n \n type t1 = uint;"}, {"sha": "b1c95bcb4300fc1e23b97d9dffa6a5c381b99c66", "filename": "src/test/auxiliary/issue-2414-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-2414-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-2414-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2414-b.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-#![crate_id=\"b#0.1\"]\n+#![crate_name=\"b\"]\n #![crate_type = \"lib\"]\n \n extern crate a;"}, {"sha": "e3ce4e8f6565a942f1d6ab4239cb4aa508d01dfa", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"issue_2526#0.2\"]\n+#![crate_name=\"issue_2526\"]\n #![crate_type = \"lib\"]\n \n #![feature(unsafe_destructor)]"}, {"sha": "e340331dbfd11206b5598f9680b942e1c4c77add", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"req\"]\n+#![crate_name=\"req\"]\n #![crate_type = \"lib\"]\n \n use std::cell::RefCell;\n@@ -19,7 +19,5 @@ pub type header_map = HashMap<String, Rc<RefCell<Vec<Rc<String>>>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let _x = (**((**req.get(&\"METHOD\".to_string())).clone()).borrow()\n-                                                          .clone()\n-                                                          .get(0)).clone();\n+  let _x = req[\"METHOD\".to_string()].clone().borrow().clone()[0].clone();\n }"}, {"sha": "25eb67e0423005cc14f825f02faa287206604b48", "filename": "src/test/auxiliary/issue-3012-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-3012-1.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"socketlib\"]\n+#![crate_name=\"socketlib\"]\n #![crate_type = \"lib\"]\n \n pub mod socket {"}, {"sha": "a7c1633784d81cf813ff762534a03304ebed7368", "filename": "src/test/auxiliary/issue-4208-cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-4208-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue-4208-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-4208-cc.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"numeric#0.1\"]\n+#![crate_name=\"numeric\"]\n #![crate_type = \"lib\"]\n \n pub trait Trig<T> {"}, {"sha": "33b6d116c8a2d54926472a615d491e0581d289ec", "filename": "src/test/auxiliary/issue_2242_a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_a.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"a#0.1\"]\n+#![crate_name=\"a#0.1\"]\n #![crate_type = \"lib\"]\n \n trait to_strz {"}, {"sha": "31d119b20beaabf8d29dc7d05e524ad963cba00d", "filename": "src/test/auxiliary/issue_2242_c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"c#0.1\"]\n+#![crate_name=\"c#0.1\"]\n #![crate_type = \"lib\"]\n \n extern crate a;"}, {"sha": "91faace7a3f4d6b93064c4e3ab539a3b64ef74a0", "filename": "src/test/auxiliary/issue_3979_traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"issue_3979_traits#0.1\"]\n+#![crate_name=\"issue_3979_traits\"]\n \n #![crate_type = \"lib\"]\n "}, {"sha": "181b651ef521c8cc5c700407593a1d5e603be308", "filename": "src/test/auxiliary/lint_output_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_output_format.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"lint_output_format#0.1\"]\n+#![crate_name=\"lint_output_format\"]\n #![crate_type = \"lib\"]\n \n #[deprecated]"}, {"sha": "06031eb6c6ccfee9b141a76604d947f607fd540c", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![crate_id=\"lint_stability#0.1\"]\n+#![crate_name=\"lint_stability\"]\n #![crate_type = \"lib\"]\n \n #![feature(macro_rules)]"}, {"sha": "1c26ac26d7cf3de07f223124ca8afeef3d30c1b6", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -51,7 +51,7 @@ fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree])\n                    -> Box<MacResult+'static> {\n     // Parse an expression and emit it unchanged.\n     let mut parser = parse::new_parser_from_tts(cx.parse_sess(),\n-        cx.cfg(), Vec::from_slice(tts));\n+        cx.cfg(), tts.to_vec());\n     let expr = parser.parse_expr();\n     MacExpr::new(quote_expr!(&mut *cx, $expr))\n }"}, {"sha": "27befee6f07f5cea2b7efbf4722460668c1cc7eb", "filename": "src/test/auxiliary/static-function-pointer-aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fstatic-function-pointer-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fstatic-function-pointer-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-function-pointer-aux.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"static-function-pointer-aux\"]\n+#![crate_name=\"static-function-pointer-aux\"]\n \n pub fn f(x: int) -> int { -x }\n "}, {"sha": "eef2fdbfea9d9114a1168b51e3b4bb6093d8f220", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"static_methods_crate#0.1\"]\n+#![crate_name=\"static_methods_crate\"]\n #![crate_type = \"lib\"]\n \n use std::int;"}, {"sha": "4ef8701030f47d1767e7f924f6cf3c94c741b2e2", "filename": "src/test/auxiliary/struct_variant_xc_aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"struct_variant_xc_aux#0.1\"]\n+#![crate_name=\"struct_variant_xc_aux\"]\n #![crate_type = \"lib\"]\n \n #![feature(struct_variant)]"}, {"sha": "c035f1203f8e3927e27a4c6d5c9cd436fb434509", "filename": "src/test/auxiliary/svh-a-base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "614487c98171342a8cb4881f9ffc60139ad1be01", "filename": "src/test/auxiliary/svh-a-change-lit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "99506309a592e31a6aab080ac6db998636c7acd1", "filename": "src/test/auxiliary/svh-a-change-significant-cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "8ec4eaebbe8df974ced8614f2a46863bde7bc4b2", "filename": "src/test/auxiliary/svh-a-change-trait-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "ad120e12f86fb92d2381a8ba3eec42c36e1a22b0", "filename": "src/test/auxiliary/svh-a-change-type-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "c68c13c0991f2e7995a45c86d7ff806057ff677e", "filename": "src/test/auxiliary/svh-a-change-type-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "6c13e84a7febe933265e2448dee6c8e26b48f453", "filename": "src/test/auxiliary/svh-a-change-type-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "3d0973cb7ba1391d7f944656f5166d6feeb378b2", "filename": "src/test/auxiliary/svh-a-comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "1ad9e5e1c0e3a9186eafc2dd7796620a385db97c", "filename": "src/test/auxiliary/svh-a-doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "6bd36b5a9b1c47839879bdc413c3746cc009e029", "filename": "src/test/auxiliary/svh-a-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "c035f1203f8e3927e27a4c6d5c9cd436fb434509", "filename": "src/test/auxiliary/svh-a-no-change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "d67c8f4c181798ef84fa217709a2380a4f6ddef7", "filename": "src/test/auxiliary/svh-a-redundant-cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "73798f3787558ccef82259d69fd01f9a68d22243", "filename": "src/test/auxiliary/svh-a-whitespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(macro_rules)]\n \n-#![crate_id = \"a\"]\n+#![crate_name = \"a\"]\n \n macro_rules! three {\n     () => { 3 }"}, {"sha": "b8946fdc99553bbfbfa4fdc908e25a16cbd67dd2", "filename": "src/test/auxiliary/svh-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-b.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -16,7 +16,7 @@\n //! the change could affect the downstream crate content or not\n //! (#14132).\n \n-#![crate_id = \"b\"]\n+#![crate_name = \"b\"]\n \n extern crate a;\n "}, {"sha": "67fdac5df0330d38259a81a7087be887ce943327", "filename": "src/test/auxiliary/svh-uta-base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-uta-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-uta-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-uta-base.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n //!\n //! This is the upstream crate.\n \n-#![crate_id = \"uta\"]\n+#![crate_name = \"uta\"]\n \n mod traits {\n     pub trait TraitA { fn val(&self) -> int { 2 } }"}, {"sha": "dfcf02c0ff500ab4327fae00f279cc174d818d8e", "filename": "src/test/auxiliary/svh-uta-change-use-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-uta-change-use-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-uta-change-use-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-uta-change-use-trait.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n //!\n //! This is the upstream crate.\n \n-#![crate_id = \"uta\"]\n+#![crate_name = \"uta\"]\n \n mod traits {\n     pub trait TraitA { fn val(&self) -> int { 2 } }"}, {"sha": "eb3da985242be45b8b7ac34a7505b6da878a4c57", "filename": "src/test/auxiliary/svh-utb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-utb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Fsvh-utb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-utb.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -15,7 +15,7 @@\n //!\n //! This is the downstream crate.\n \n-#![crate_id = \"utb\"]\n+#![crate_name = \"utb\"]\n \n extern crate uta;\n "}, {"sha": "7424c21be3da0c6b05fd5f6b4091951002dc68c7", "filename": "src/test/auxiliary/trait_default_method_xc_aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_default_method_xc_aux.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_id=\"trait_default_method_xc_aux\"]\n+#![crate_name=\"trait_default_method_xc_aux\"]\n \n pub struct Something { pub x: int }\n "}, {"sha": "404e2e31b05770560b83b9c657d3545f54a4cbaf", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -68,7 +68,7 @@ fn shift_push() {\n     let mut v2 = Vec::new();\n \n     while v1.len() > 0 {\n-        v2.push(v1.shift().unwrap());\n+        v2.push(v1.remove(0).unwrap());\n     }\n }\n \n@@ -93,9 +93,11 @@ fn vec_plus() {\n     while i < 1500 {\n         let rv = Vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n-            v.push_all_move(rv);\n+            v.extend(rv.into_iter());\n         } else {\n-            v = rv.clone().append(v.as_slice());\n+            let mut rv = rv.clone();\n+            rv.push_all(v.as_slice());\n+            v = rv;\n         }\n         i += 1;\n     }\n@@ -109,10 +111,14 @@ fn vec_append() {\n     while i < 1500 {\n         let rv = Vec::from_elem(r.gen_range(0u, i + 1), i);\n         if r.gen() {\n-            v = v.clone().append(rv.as_slice());\n+            let mut t = v.clone();\n+            t.push_all(rv.as_slice());\n+            v = t;\n         }\n         else {\n-            v = rv.clone().append(v.as_slice());\n+            let mut t = rv.clone();\n+            t.push_all(v.as_slice());\n+            v = t;\n         }\n         i += 1;\n     }"}, {"sha": "98113cb834767a61dc0d04403cbea148c95bff44", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -21,7 +21,7 @@ fn main() {\n         args.into_iter().collect()\n     };\n \n-    let n = from_str::<uint>(args.get(1).as_slice()).unwrap();\n+    let n = from_str::<uint>(args[1].as_slice()).unwrap();\n \n     for i in range(0u, n) {\n         let x = i.to_string();"}, {"sha": "1a9ffd68284868e967385b5c4822e2e4f92e11b5", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -72,8 +72,8 @@ fn main() {\n         args.clone().into_iter().collect()\n     };\n \n-    let num_tasks = from_str::<uint>(args.get(1).as_slice()).unwrap();\n-    let msg_per_task = from_str::<uint>(args.get(2).as_slice()).unwrap();\n+    let num_tasks = from_str::<uint>(args[1].as_slice()).unwrap();\n+    let msg_per_task = from_str::<uint>(args[2].as_slice()).unwrap();\n \n     let (mut num_chan, num_port) = init();\n "}, {"sha": "5e192a1479346e2eefc4830e0e0d7a322cb1b6ae", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -72,8 +72,8 @@ fn main() {\n         args.clone().into_iter().collect()\n     };\n \n-    let num_tasks = from_str::<uint>(args.get(1).as_slice()).unwrap();\n-    let msg_per_task = from_str::<uint>(args.get(2).as_slice()).unwrap();\n+    let num_tasks = from_str::<uint>(args[1].as_slice()).unwrap();\n+    let msg_per_task = from_str::<uint>(args[2].as_slice()).unwrap();\n \n     let (mut num_chan, num_port) = init();\n "}, {"sha": "e7a50382c9469a262dfbe09b373cb066831dcca0", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -31,6 +31,6 @@ fn main() {\n     } else {\n         args.into_iter().collect()\n     };\n-    let n = from_str::<int>(args.get(1).as_slice()).unwrap();\n+    let n = from_str::<int>(args[1].as_slice()).unwrap();\n     println!(\"Ack(3,{}): {}\\n\", n, ack(3, n));\n }"}, {"sha": "10c0d0a8044cb62a0de70b5518ee9f9f34b0ca94", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -27,6 +27,6 @@ fn main() {\n     } else {\n         args.into_iter().collect()\n     };\n-    let n = from_str::<int>(args.get(1).as_slice()).unwrap();\n+    let n = from_str::<int>(args[1].as_slice()).unwrap();\n     println!(\"{}\\n\", fib(n));\n }"}, {"sha": "5d77e27f948a1dc25abb51f5b66d1e31b5bf95a2", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -83,7 +83,7 @@ fn find(mm: &HashMap<Vec<u8> , uint>, key: String) -> uint {\n \n // given a map, increment the counter for a key\n fn update_freq(mm: &mut HashMap<Vec<u8> , uint>, key: &[u8]) {\n-    let key = Vec::from_slice(key);\n+    let key = key.to_vec();\n     let newval = match mm.pop(&key) {\n         Some(v) => v + 1,\n         None => 1\n@@ -103,7 +103,7 @@ fn windows_with_carry(bb: &[u8], nn: uint, it: |window: &[u8]|) -> Vec<u8> {\n       ii += 1u;\n    }\n \n-   return Vec::from_slice(bb[len - (nn - 1u)..len]);\n+   return bb[len - (nn - 1u)..len].to_vec();\n }\n \n fn make_sequence_processor(sz: uint,\n@@ -117,15 +117,14 @@ fn make_sequence_processor(sz: uint,\n \n    loop {\n \n-      line = from_parent.recv();\n-      if line == Vec::new() { break; }\n+       line = from_parent.recv();\n+       if line == Vec::new() { break; }\n \n-       carry = windows_with_carry(carry.append(line.as_slice()).as_slice(),\n-                                  sz,\n-                                  |window| {\n-         update_freq(&mut freqs, window);\n-         total += 1u;\n-      });\n+       carry.push_all(line.as_slice());\n+       carry = windows_with_carry(carry.as_slice(), sz, |window| {\n+           update_freq(&mut freqs, window);\n+           total += 1u;\n+       });\n    }\n \n    let buffer = match sz {\n@@ -149,7 +148,7 @@ fn main() {\n \n     let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n         let foo = include_bin!(\"shootout-k-nucleotide.data\");\n-        box MemReader::new(Vec::from_slice(foo)) as Box<Reader>\n+        box MemReader::new(foo.to_vec()) as Box<Reader>\n     } else {\n         box stdio::stdin() as Box<Reader>\n     };\n@@ -203,8 +202,8 @@ fn main() {\n                let line_bytes = line.as_bytes();\n \n                for (ii, _sz) in sizes.iter().enumerate() {\n-                   let lb = Vec::from_slice(line_bytes);\n-                   to_child.get(ii).send(lb);\n+                   let lb = line_bytes.to_vec();\n+                   to_child[ii].send(lb);\n                }\n            }\n \n@@ -215,11 +214,11 @@ fn main() {\n \n    // finish...\n    for (ii, _sz) in sizes.iter().enumerate() {\n-       to_child.get(ii).send(Vec::new());\n+       to_child[ii].send(Vec::new());\n    }\n \n    // now fetch and print result messages\n    for (ii, _sz) in sizes.iter().enumerate() {\n-       println!(\"{}\", from_child.get(ii).recv());\n+       println!(\"{}\", from_child[ii].recv());\n    }\n }"}, {"sha": "8486fa5b034d666003826d5adef95842fef96256", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -102,7 +102,7 @@ fn advance(bodies: &mut [Planet, ..N_BODIES], dt: f64, steps: int) {\n     for _ in range(0, steps) {\n         let mut b_slice = bodies.as_mut_slice();\n         loop {\n-            let bi = match b_slice.mut_shift_ref() {\n+            let bi = match shift_mut_ref(&mut b_slice) {\n                 Some(bi) => bi,\n                 None => break\n             };\n@@ -183,3 +183,21 @@ fn main() {\n \n     println!(\"{:.9f}\", energy(&bodies));\n }\n+\n+/// Pop a mutable reference off the head of a slice, mutating the slice to no\n+/// longer contain the mutable reference. This is a safe operation because the\n+/// two mutable borrows are entirely disjoint.\n+fn shift_mut_ref<'a, T>(r: &mut &'a mut [T]) -> Option<&'a mut T> {\n+    use std::mem;\n+    use std::raw::Repr;\n+\n+    if r.len() == 0 { return None }\n+    unsafe {\n+        let mut raw = r.repr();\n+        let ret = raw.data as *mut T;\n+        raw.data = raw.data.offset(1);\n+        raw.len -= 1;\n+        *r = mem::transmute(raw);\n+        Some(unsafe { &mut *ret })\n+    }\n+}"}, {"sha": "91b9e058e8feacee390c12f2963103fe8e698986", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -102,7 +102,7 @@ fn main() {\n     if opts.stress {\n         stress(2);\n     } else {\n-        let max = uint::parse_bytes(args.get(1).as_bytes(), 10u).unwrap() as\n+        let max = uint::parse_bytes(args[1].as_bytes(), 10u).unwrap() as\n             int;\n \n         let num_trials = 10;"}, {"sha": "2086980b016fcdbffee1287727937d86145b2ed1", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -25,7 +25,7 @@ fn append_sequential(min: uint, max: uint, map: &mut SmallIntMap<uint>) {\n \n fn check_sequential(min: uint, max: uint, map: &SmallIntMap<uint>) {\n     for i in range(min, max) {\n-        assert_eq!(*map.get(&i), i + 22u);\n+        assert_eq!(map[i], i + 22u);\n     }\n }\n \n@@ -38,8 +38,8 @@ fn main() {\n     } else {\n         args.into_iter().collect()\n     };\n-    let max = from_str::<uint>(args.get(1).as_slice()).unwrap();\n-    let rep = from_str::<uint>(args.get(2).as_slice()).unwrap();\n+    let max = from_str::<uint>(args[1].as_slice()).unwrap();\n+    let rep = from_str::<uint>(args[2].as_slice()).unwrap();\n \n     let mut checkf = 0.0;\n     let mut appendf = 0.0;"}, {"sha": "01c412c6d3195420ecb903608f56d782e34415bf", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -55,8 +55,8 @@ impl Sudoku {\n     pub fn equal(&self, other: &Sudoku) -> bool {\n         for row in range(0u8, 9u8) {\n             for col in range(0u8, 9u8) {\n-                if *self.grid.get(row as uint).get(col as uint) !=\n-                        *other.grid.get(row as uint).get(col as uint) {\n+                if self.grid[row as uint][col as uint] !=\n+                        other.grid[row as uint][col as uint] {\n                     return false;\n                 }\n             }\n@@ -77,10 +77,10 @@ impl Sudoku {\n                                        .collect();\n \n             if comps.len() == 3u {\n-                let row     = from_str::<uint>(*comps.get(0)).unwrap() as u8;\n-                let col     = from_str::<uint>(*comps.get(1)).unwrap() as u8;\n+                let row     = from_str::<uint>(comps[0]).unwrap() as u8;\n+                let col     = from_str::<uint>(comps[1]).unwrap() as u8;\n                 *g.get_mut(row as uint).get_mut(col as uint) =\n-                    from_str::<uint>(*comps.get(2)).unwrap() as u8;\n+                    from_str::<uint>(comps[2]).unwrap() as u8;\n             }\n             else {\n                 fail!(\"Invalid sudoku file\");\n@@ -91,11 +91,9 @@ impl Sudoku {\n \n     pub fn write(&self, writer: &mut io::Writer) {\n         for row in range(0u8, 9u8) {\n-            write!(writer, \"{}\", *self.grid.get(row as uint).get(0));\n+            write!(writer, \"{}\", self.grid[row as uint][0]);\n             for col in range(1u8, 9u8) {\n-                write!(writer, \" {}\", *self.grid\n-                                           .get(row as uint)\n-                                           .get(col as uint));\n+                write!(writer, \" {}\", self.grid[row as uint][col as uint]);\n             }\n             write!(writer, \"\\n\");\n          }\n@@ -106,7 +104,7 @@ impl Sudoku {\n         let mut work: Vec<(u8, u8)> = Vec::new(); /* queue of uncolored fields */\n         for row in range(0u8, 9u8) {\n             for col in range(0u8, 9u8) {\n-                let color = *self.grid.get(row as uint).get(col as uint);\n+                let color = self.grid[row as uint][col as uint];\n                 if color == 0u8 {\n                     work.push((row, col));\n                 }\n@@ -116,9 +114,9 @@ impl Sudoku {\n         let mut ptr = 0u;\n         let end = work.len();\n         while ptr < end {\n-            let (row, col) = *work.get(ptr);\n+            let (row, col) = work[ptr];\n             // is there another color to try?\n-            let the_color = *self.grid.get(row as uint).get(col as uint) +\n+            let the_color = self.grid[row as uint][col as uint] +\n                                 (1 as u8);\n             if self.next_color(row, col, the_color) {\n                 //  yes: advance work list\n@@ -151,22 +149,18 @@ impl Sudoku {\n     // find colors available in neighbourhood of (row, col)\n     fn drop_colors(&mut self, avail: &mut Colors, row: u8, col: u8) {\n         for idx in range(0u8, 9u8) {\n-            avail.remove(*self.grid\n-                              .get(idx as uint)\n-                              .get(col as uint)); /* check same column fields */\n-            avail.remove(*self.grid\n-                              .get(row as uint)\n-                              .get(idx as uint)); /* check same row fields */\n+            /* check same column fields */\n+            avail.remove(self.grid[idx as uint][col as uint]);\n+            /* check same row fields */\n+            avail.remove(self.grid[row as uint][idx as uint]);\n         }\n \n         // check same block fields\n         let row0 = (row / 3u8) * 3u8;\n         let col0 = (col / 3u8) * 3u8;\n         for alt_row in range(row0, row0 + 3u8) {\n             for alt_col in range(col0, col0 + 3u8) {\n-                avail.remove(*self.grid\n-                                  .get(alt_row as uint)\n-                                  .get(alt_col as uint));\n+                avail.remove(self.grid[alt_row as uint][alt_col as uint]);\n             }\n         }\n     }"}, {"sha": "bdeee5fb6e0bf6b6ca47968d72d630e5189ed6d7", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -78,21 +78,22 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n         let depth = depth - 1;\n \n         let st = match st {\n-          None => {\n-            State {\n-                unique: box Nil,\n-                vec: vec!(box Nil),\n-                res: r(box Nil)\n+            None => {\n+                State {\n+                    unique: box Nil,\n+                    vec: vec!(box Nil),\n+                    res: r(box Nil)\n+                }\n             }\n-          }\n-          Some(st) => {\n-            State {\n-                unique: box Cons((), box *st.unique),\n-                vec: st.vec.clone().append(\n-                        &[box Cons((), st.vec.last().unwrap().clone())]),\n-                res: r(box Cons((), st.res._l.clone()))\n+            Some(st) => {\n+                let mut v = st.vec.clone();\n+                v.push_all(&[box Cons((), st.vec.last().unwrap().clone())]);\n+                State {\n+                    unique: box Cons((), box *st.unique),\n+                    vec: v,\n+                    res: r(box Cons((), st.res._l.clone())),\n+                }\n             }\n-          }\n         };\n \n         recurse_or_fail(depth, Some(st));"}, {"sha": "9ebdbf0682d79d5e6e374e4bc54a80b413bf9da9", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -49,7 +49,7 @@ fn main() {\n     };\n \n     let (tx, rx) = channel();\n-    child_generation(from_str::<uint>(args.get(1).as_slice()).unwrap(), tx);\n+    child_generation(from_str::<uint>(args[1].as_slice()).unwrap(), tx);\n     if rx.recv_opt().is_err() {\n         fail!(\"it happened when we slumbered\");\n     }"}, {"sha": "533005b1fb38c0c98d31943e36868a8a1c690bc7", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70", "patch": "@@ -31,7 +31,7 @@ fn main() {\n     } else {\n         args.into_iter().collect()\n     };\n-    let n = from_str::<uint>(args.get(1).as_slice()).unwrap();\n+    let n = from_str::<uint>(args[1].as_slice()).unwrap();\n     let mut i = 0u;\n     while i < n { task::spawn(proc() f(n) ); i += 1u; }\n }"}, {"sha": "3ad17618fc0b31e33830f5ced682c7e7e69ff4e0", "filename": "src/test/compile-fail-fulldeps/syntax-extension-fourcc-bad-len.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-bad-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-bad-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-bad-len.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-pretty\n-\n-#![feature(phase)]\n-\n-#[phase(plugin)]\n-extern crate fourcc;\n-\n-fn main() {\n-    let val = fourcc!(\"foo\"); //~ ERROR string literal with len != 4 in fourcc!\n-    let val2 = fourcc!(\"fooba\"); //~ ERROR string literal with len != 4 in fourcc!\n-}"}, {"sha": "4d425d9a2056a62f8e7cbf3b019d4a3bd7592e73", "filename": "src/test/compile-fail-fulldeps/syntax-extension-fourcc-invalid-endian.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-invalid-endian.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-invalid-endian.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-invalid-endian.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-pretty\n-\n-#![feature(phase)]\n-\n-#[phase(plugin)]\n-extern crate fourcc;\n-\n-fn main() {\n-    let val = fourcc!(\"foo \", bork); //~ ERROR invalid endian directive in fourcc!\n-}"}, {"sha": "1a6d747c1e8368ee7c84ddec51a33e154c1ba00f", "filename": "src/test/compile-fail-fulldeps/syntax-extension-fourcc-non-ascii-str.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-non-ascii-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-non-ascii-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-non-ascii-str.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-stage1\n-// ignore-pretty\n-\n-#![feature(phase)]\n-\n-#[phase(plugin)]\n-extern crate fourcc;\n-\n-fn main() {\n-    let v = fourcc!(\"foo\u03bb\"); //~ ERROR fourcc! literal character out of range 0-255\n-}"}, {"sha": "885d8dd1ec326fcd76ca10634498807e6debb13f", "filename": "src/test/compile-fail-fulldeps/syntax-extension-fourcc-non-literal.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-non-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-non-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-non-literal.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312"}, {"sha": "da1c0070715686c13e14238171bd70a9ed047019", "filename": "src/test/compile-fail-fulldeps/syntax-extension-fourcc-unsupported-literal.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-unsupported-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-unsupported-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-fourcc-unsupported-literal.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312"}, {"sha": "191042f5f5639f6876b2c66e2e2cf664916a6417", "filename": "src/test/compile-fail-fulldeps/syntax-extension-hexfloat-bad-lits.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-hexfloat-bad-lits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-hexfloat-bad-lits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-hexfloat-bad-lits.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312"}, {"sha": "f0ace43ec9e8d34ad66d8b35c601feca8646d0b0", "filename": "src/test/compile-fail-fulldeps/syntax-extension-hexfloat-bad-types.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-hexfloat-bad-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-hexfloat-bad-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fsyntax-extension-hexfloat-bad-types.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312"}, {"sha": "5bc2edba301342704c21b84a208811d1823d1290", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "31b5c44df66637a2206d76bc9a3dfe6181c76e79", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "d9d7a43d46c41e60a275763c7ef16d943b6a6805", "filename": "src/test/compile-fail/borrowck-overloaded-index-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-2.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "9f1c1fdd7c79e5cd68a750a951adcfe417918d69", "filename": "src/test/compile-fail/deprecated-url.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail%2Fdeprecated-url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Fcompile-fail%2Fdeprecated-url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecated-url.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312"}, {"sha": "6dcf1fdee83028c5a4ceec06c42b6b51ec1b2622", "filename": "src/test/compile-fail/lub-if.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-if.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "c9efce0d68478009a4122987357c97d44ec6de4a", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "1d6dc504ab43b7baaea5f1e4310a4660fd98a890", "filename": "src/test/compile-fail/moves-based-on-type-exprs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-exprs.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "a07317176e410e48df90a758147dd5339999c90c", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "9f33f35838e2794de43214b27caa748e406d1602", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "b639af617574cc8d874d570658f7c9e183fc5614", "filename": "src/test/compile-fail/ufcs-explicit-self-bad.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "33d3deb8733d506112ca306c0369cd42402741d0", "filename": "src/test/compile-fail/unresolved-extern-mod-suggestion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Funresolved-extern-mod-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Funresolved-extern-mod-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funresolved-extern-mod-suggestion.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "4e9f1545f3adde7d0be91258ca717e16e127412f", "filename": "src/test/compile-fail/writing-to-immutable-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-to-immutable-vec.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "9123342f09a5c07edcc7e47f52a2fcb2563898d2", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "bf04789bbc7738ddbb8ee4e8e3012f8feaa3f8d6", "filename": "src/test/run-fail/glob-use-std.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-fail%2Fglob-use-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-fail%2Fglob-use-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fglob-use-std.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "539d2adc7d45caebecf69f46893ac8648a6225db", "filename": "src/test/run-fail/issue-3029.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-3029.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "281523a807ef8a368090ea951c329f7214bbadfb", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "99dd473344a2bae9ba222c8e440f11bd56c39e54", "filename": "src/test/run-make/bootstrap-from-c-with-native/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "14baa8ca55a3978dccbdf65fcf6dcc43098a3957", "filename": "src/test/run-make/dep-info-custom/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Fdep-info-custom%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Fdep-info-custom%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fdep-info-custom%2Flib.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "dd818cf87986da2bc2f558aa47597ce4bc0b5541", "filename": "src/test/run-make/libs-through-symlinks/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Flibs-through-symlinks%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Flibs-through-symlinks%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibs-through-symlinks%2Ffoo.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "0f6bd10b15d3fe57310f73745dcd7a138ef4e1f3", "filename": "src/test/run-make/lto-syntax-extension/main.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Flto-syntax-extension%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Flto-syntax-extension%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-syntax-extension%2Fmain.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "dbfe920c85ba399fe11c78db684778359accfe9f", "filename": "src/test/run-make/many-crates-but-no-match/crateA1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA1.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "857c36aee602585e9ccf06b0ddfc554b4a6c7ccb", "filename": "src/test/run-make/many-crates-but-no-match/crateA2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA2.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "8b8dac5e862a17f5bd8debd0c5dfe9ff7dd667f6", "filename": "src/test/run-make/many-crates-but-no-match/crateA3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FcrateA3.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "c402da7987d5ad4433cf252580ce27d6c3773381", "filename": "src/test/run-make/rustdoc-hidden-line/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-hidden-line%2Ffoo.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "d57a7164cdbcea135ea7d41436f5d9909a8d9bc6", "filename": "src/test/run-make/rustdoc-json/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-json%2Ffoo.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "499bcaff4d1845ed499d3e04f355608ea1c98bf8", "filename": "src/test/run-make/rustdoc-smoke/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-smoke%2Ffoo.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "2aa4264225c965b4c9f49f443cc07f4e2002af63", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "7b096d7d583a5e6f5126b7dd3c7d28c39daebb6e", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d0cc44f873ac338b400b20bcb62618aa5d36b70/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=7d0cc44f873ac338b400b20bcb62618aa5d36b70"}, {"sha": "b16975fe6eea7068f74f1ab4b702b1f7123663d5", "filename": "src/test/run-pass-fulldeps/syntax-extension-fourcc.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-fourcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-fourcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-fourcc.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312"}, {"sha": "820606179bc1ecbc9684871b24383d74450210d2", "filename": "src/test/run-pass-fulldeps/syntax-extension-hexfloat.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-hexfloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcbd49ff88d55f703e5a307e34e408d387a8a312/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-hexfloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-hexfloat.rs?ref=dcbd49ff88d55f703e5a307e34e408d387a8a312"}]}