{"sha": "1173c3dab5f77a1afd367d547790dd82c558fe0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNzNjM2RhYjVmNzdhMWFmZDM2N2Q1NDc3OTBkZDgyYzU1OGZlMGQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-10-31T18:28:33Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-11-01T18:57:08Z"}, "message": "Refactor to unify with method resolution", "tree": {"sha": "50d39c98ad4ac7deae11800d20c0a5dbeb9ed8bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50d39c98ad4ac7deae11800d20c0a5dbeb9ed8bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1173c3dab5f77a1afd367d547790dd82c558fe0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1173c3dab5f77a1afd367d547790dd82c558fe0d", "html_url": "https://github.com/rust-lang/rust/commit/1173c3dab5f77a1afd367d547790dd82c558fe0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1173c3dab5f77a1afd367d547790dd82c558fe0d/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7cedea270c492e9a2c8b81c1312fda44fd8217e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7cedea270c492e9a2c8b81c1312fda44fd8217e", "html_url": "https://github.com/rust-lang/rust/commit/c7cedea270c492e9a2c8b81c1312fda44fd8217e"}], "stats": {"total": 258, "additions": 117, "deletions": 141}, "files": [{"sha": "c97ea18a24ea0f6e45373716c60090f278f048ae", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=1173c3dab5f77a1afd367d547790dd82c558fe0d", "patch": "@@ -1053,4 +1053,13 @@ impl AssocItem {\n             AssocItem::TypeAlias(t) => t.module(db),\n         }\n     }\n+\n+    pub fn container(self, db: &impl DefDatabase) -> Container {\n+        match self {\n+            AssocItem::Function(f) => f.container(db),\n+            AssocItem::Const(c) => c.container(db),\n+            AssocItem::TypeAlias(t) => t.container(db),\n+        }\n+        .expect(\"AssocItem without container\")\n+    }\n }"}, {"sha": "9c261eda9f01ad5d97a532d2de63ffbaefb010c7", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=1173c3dab5f77a1afd367d547790dd82c558fe0d", "patch": "@@ -77,9 +77,10 @@ impl GenericParams {\n         let parent = match def {\n             GenericDef::Function(it) => it.container(db).map(GenericDef::from),\n             GenericDef::TypeAlias(it) => it.container(db).map(GenericDef::from),\n+            GenericDef::Const(it) => it.container(db).map(GenericDef::from),\n             GenericDef::EnumVariant(it) => Some(it.parent_enum(db).into()),\n             GenericDef::Adt(_) | GenericDef::Trait(_) => None,\n-            GenericDef::ImplBlock(_) | GenericDef::Const(_) => None,\n+            GenericDef::ImplBlock(_) => None,\n         };\n         let mut generics = GenericParams {\n             def,"}, {"sha": "0398806fd18db5b2cde1f54854e20835fb474c82", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=1173c3dab5f77a1afd367d547790dd82c558fe0d", "patch": "@@ -28,8 +28,8 @@ use crate::{\n     ids::LocationCtx,\n     resolve::{ScopeDef, TypeNs, ValueNs},\n     ty::method_resolution::implements_trait,\n-    Const, DefWithBody, Either, Enum, FromSource, Function, HasBody, HirFileId, MacroDef, Module,\n-    Name, Path, Resolver, Static, Struct, Ty,\n+    AssocItem, Const, DefWithBody, Either, Enum, FromSource, Function, HasBody, HirFileId,\n+    MacroDef, Module, Name, Path, Resolver, Static, Struct, Ty,\n };\n \n fn try_get_resolver_for_node(\n@@ -327,7 +327,7 @@ impl SourceAnalyzer {\n         db: &impl HirDatabase,\n         ty: Ty,\n         name: Option<&Name>,\n-        callback: impl FnMut(&Ty, Function) -> Option<T>,\n+        callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n     ) -> Option<T> {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n@@ -337,6 +337,7 @@ impl SourceAnalyzer {\n             db,\n             &self.resolver,\n             name,\n+            crate::ty::method_resolution::LookupMode::MethodCall,\n             callback,\n         )\n     }"}, {"sha": "1946bf608418dbe1c5f72c7decec327526a5e9ba", "filename": "crates/ra_hir/src/ty/infer/path.rs", "status": "modified", "additions": 27, "deletions": 108, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs?ref=1173c3dab5f77a1afd367d547790dd82c558fe0d", "patch": "@@ -6,11 +6,9 @@ use super::{ExprOrPatId, InferenceContext, TraitRef};\n use crate::{\n     db::HirDatabase,\n     resolve::{ResolveValueResult, Resolver, TypeNs, ValueNs},\n-    ty::{lower, traits::TraitEnvironment, Canonical},\n-    ty::{Substs, Ty, TypableDef, TypeWalk},\n-    AssocItem, HasGenericParams, Name, Namespace, Path, Trait,\n+    ty::{method_resolution, Substs, Ty, TypableDef, TypeWalk},\n+    AssocItem, Container, HasGenericParams, Name, Namespace, Path,\n };\n-use std::sync::Arc;\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn infer_path(\n@@ -184,91 +182,34 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             return None;\n         }\n \n-        self.find_inherent_assoc_candidate(ty.clone(), name, id)\n-            .or_else(|| self.find_trait_assoc_candidate(ty.clone(), name, id))\n-    }\n-\n-    fn find_inherent_assoc_candidate(\n-        &mut self,\n-        ty: Ty,\n-        name: &Name,\n-        id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substs>)> {\n-        let krate = self.resolver.krate()?;\n-\n-        // Find impl\n-        let item = ty.clone().iterate_impl_items(self.db, krate, |item| match item {\n-            AssocItem::Function(func) => {\n-                if *name == func.name(self.db) {\n-                    Some(AssocItem::Function(func))\n-                } else {\n-                    None\n-                }\n-            }\n-\n-            AssocItem::Const(konst) => {\n-                if konst.name(self.db).map_or(false, |n| n == *name) {\n-                    Some(AssocItem::Const(konst))\n-                } else {\n-                    None\n-                }\n-            }\n-            AssocItem::TypeAlias(_) => None,\n-        })?;\n-        let def = match item {\n-            AssocItem::Function(f) => ValueNs::Function(f),\n-            AssocItem::Const(c) => ValueNs::Const(c),\n-            AssocItem::TypeAlias(_) => unreachable!(),\n-        };\n-        let substs = self.find_self_types(&def, ty);\n-\n-        self.write_assoc_resolution(id, item);\n-        Some((def, substs))\n-    }\n-\n-    fn find_trait_assoc_candidate(\n-        &mut self,\n-        ty: Ty,\n-        name: &Name,\n-        id: ExprOrPatId,\n-    ) -> Option<(ValueNs, Option<Substs>)> {\n-        let krate = self.resolver.krate()?;\n-\n         let canonical_ty = self.canonicalizer().canonicalize_ty(ty.clone());\n \n-        let env = lower::trait_env(self.db, &self.resolver);\n-        // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n-        let traits_from_env = env\n-            .trait_predicates_for_self_ty(&ty)\n-            .map(|tr| tr.trait_)\n-            .flat_map(|t| t.all_super_traits(self.db));\n-        let traits = traits_from_env.chain(self.resolver.traits_in_scope(self.db));\n-\n-        'traits: for t in traits {\n-            let data = t.trait_data(self.db);\n-            let mut known_implemented = false;\n-            for item in data.items() {\n-                if let AssocItem::Function(f) = *item {\n-                    if f.name(self.db) == *name {\n-                        if !known_implemented {\n-                            let goal = generic_implements_goal(\n-                                self.db,\n-                                env.clone(),\n-                                t,\n-                                canonical_ty.value.clone(),\n-                            );\n-                            if self.db.trait_solve(krate, goal).is_none() {\n-                                continue 'traits;\n-                            }\n-                        }\n-                        known_implemented = true;\n-\n+        method_resolution::iterate_method_candidates(\n+            &canonical_ty.value,\n+            self.db,\n+            &self.resolver.clone(),\n+            Some(name),\n+            method_resolution::LookupMode::Path,\n+            move |_ty, item| {\n+                let def = match item {\n+                    AssocItem::Function(f) => ValueNs::Function(f),\n+                    AssocItem::Const(c) => ValueNs::Const(c),\n+                    AssocItem::TypeAlias(_) => unreachable!(),\n+                };\n+                match item.container(self.db) {\n+                    Container::ImplBlock(_) => {\n+                        let substs = self.find_self_types(&def, ty.clone());\n+\n+                        self.write_assoc_resolution(id, item);\n+                        Some((def, substs))\n+                    }\n+                    Container::Trait(t) => {\n                         // we're picking this method\n                         let trait_substs = Substs::build_for_def(self.db, t)\n                             .push(ty.clone())\n                             .fill(std::iter::repeat_with(|| self.new_type_var()))\n                             .build();\n-                        let substs = Substs::build_for_def(self.db, f)\n+                        let substs = Substs::build_for_def(self.db, item)\n                             .use_parent_substs(&trait_substs)\n                             .fill_with_params()\n                             .build();\n@@ -277,14 +218,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             substs: trait_substs,\n                         }));\n \n-                        self.write_assoc_resolution(id, *item);\n-                        return Some((ValueNs::Function(f), Some(substs)));\n+                        self.write_assoc_resolution(id, item);\n+                        Some((def, Some(substs)))\n                     }\n                 }\n-            }\n-        }\n-\n-        None\n+            },\n+        )\n     }\n \n     fn find_self_types(&self, def: &ValueNs, actual_def_ty: Ty) -> Option<Substs> {\n@@ -317,23 +256,3 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         }\n     }\n }\n-\n-// TODO remove duplication\n-/// This creates Substs for a trait with the given Self type and type variables\n-/// for all other parameters, to query Chalk with it.\n-fn generic_implements_goal(\n-    db: &impl HirDatabase,\n-    env: Arc<TraitEnvironment>,\n-    trait_: Trait,\n-    self_ty: Canonical<Ty>,\n-) -> Canonical<super::InEnvironment<super::Obligation>> {\n-    let num_vars = self_ty.num_vars;\n-    let substs = super::Substs::build_for_def(db, trait_)\n-        .push(self_ty.value)\n-        .fill_with_bound_vars(num_vars as u32)\n-        .build();\n-    let num_vars = substs.len() - 1 + self_ty.num_vars;\n-    let trait_ref = TraitRef { trait_, substs };\n-    let obligation = super::Obligation::Trait(trait_ref);\n-    Canonical { num_vars, value: super::InEnvironment::new(env, obligation) }\n-}"}, {"sha": "ee0c7b00f3bc7100981303d32ce33be2c2eb378c", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 67, "deletions": 23, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=1173c3dab5f77a1afd367d547790dd82c558fe0d", "patch": "@@ -166,7 +166,19 @@ pub(crate) fn lookup_method(\n     name: &Name,\n     resolver: &Resolver,\n ) -> Option<(Ty, Function)> {\n-    iterate_method_candidates(ty, db, resolver, Some(name), |ty, f| Some((ty.clone(), f)))\n+    iterate_method_candidates(ty, db, resolver, Some(name), LookupMode::MethodCall, |ty, f| {\n+        if let AssocItem::Function(f) = f {\n+            Some((ty.clone(), f))\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum LookupMode {\n+    MethodCall,\n+    Path,\n }\n \n // This would be nicer if it just returned an iterator, but that runs into\n@@ -176,7 +188,8 @@ pub(crate) fn iterate_method_candidates<T>(\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     name: Option<&Name>,\n-    mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+    mode: LookupMode,\n+    mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n ) -> Option<T> {\n     // For method calls, rust first does any number of autoderef, and then one\n     // autoref (i.e. when the method takes &self or &mut self). We just ignore\n@@ -188,13 +201,15 @@ pub(crate) fn iterate_method_candidates<T>(\n     // rustc does an autoderef and then autoref again).\n \n     let krate = resolver.krate()?;\n+    // TODO no autoderef in LookupMode::Path\n     for derefed_ty in autoderef::autoderef(db, resolver, ty.clone()) {\n-        if let Some(result) = iterate_inherent_methods(&derefed_ty, db, name, krate, &mut callback)\n+        if let Some(result) =\n+            iterate_inherent_methods(&derefed_ty, db, name, mode, krate, &mut callback)\n         {\n             return Some(result);\n         }\n         if let Some(result) =\n-            iterate_trait_method_candidates(&derefed_ty, db, resolver, name, &mut callback)\n+            iterate_trait_method_candidates(&derefed_ty, db, resolver, name, mode, &mut callback)\n         {\n             return Some(result);\n         }\n@@ -207,7 +222,8 @@ fn iterate_trait_method_candidates<T>(\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     name: Option<&Name>,\n-    mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+    mode: LookupMode,\n+    mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n ) -> Option<T> {\n     let krate = resolver.krate()?;\n     // FIXME: maybe put the trait_env behind a query (need to figure out good input parameters for that)\n@@ -231,21 +247,35 @@ fn iterate_trait_method_candidates<T>(\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n         // iteration\n         let mut known_implemented = inherently_implemented;\n-        for item in data.items() {\n-            if let AssocItem::Function(m) = *item {\n-                let data = m.data(db);\n-                if name.map_or(true, |name| data.name() == name) && data.has_self_param() {\n-                    if !known_implemented {\n-                        let goal = generic_implements_goal(db, env.clone(), t, ty.clone());\n-                        if db.trait_solve(krate, goal).is_none() {\n-                            continue 'traits;\n-                        }\n+        for &item in data.items() {\n+            // TODO unify with the impl case\n+            match item {\n+                AssocItem::Function(m) => {\n+                    let data = m.data(db);\n+                    if !name.map_or(true, |name| data.name() == name)\n+                        || (!data.has_self_param() && mode != LookupMode::Path)\n+                    {\n+                        continue;\n                     }\n-                    known_implemented = true;\n-                    if let Some(result) = callback(&ty.value, m) {\n-                        return Some(result);\n+                }\n+                AssocItem::Const(c) => {\n+                    if !name.map_or(true, |name| Some(name) == c.name(db).as_ref())\n+                        || (mode != LookupMode::Path)\n+                    {\n+                        continue;\n                     }\n                 }\n+                _ => {}\n+            };\n+            if !known_implemented {\n+                let goal = generic_implements_goal(db, env.clone(), t, ty.clone());\n+                if db.trait_solve(krate, goal).is_none() {\n+                    continue 'traits;\n+                }\n+            }\n+            known_implemented = true;\n+            if let Some(result) = callback(&ty.value, item) {\n+                return Some(result);\n             }\n         }\n     }\n@@ -256,21 +286,35 @@ fn iterate_inherent_methods<T>(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n     name: Option<&Name>,\n+    mode: LookupMode,\n     krate: Crate,\n-    mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n+    mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n ) -> Option<T> {\n     for krate in def_crates(db, krate, &ty.value)? {\n         let impls = db.impls_in_crate(krate);\n \n         for impl_block in impls.lookup_impl_blocks(&ty.value) {\n             for item in impl_block.items(db) {\n-                if let AssocItem::Function(f) = item {\n-                    let data = f.data(db);\n-                    if name.map_or(true, |name| data.name() == name) && data.has_self_param() {\n-                        if let Some(result) = callback(&ty.value, f) {\n-                            return Some(result);\n+                match item {\n+                    AssocItem::Function(f) => {\n+                        let data = f.data(db);\n+                        if !name.map_or(true, |name| data.name() == name)\n+                            || (!data.has_self_param() && mode != LookupMode::Path)\n+                        {\n+                            continue;\n                         }\n                     }\n+                    AssocItem::Const(c) => {\n+                        if !name.map_or(true, |name| Some(name) == c.name(db).as_ref())\n+                            || (mode != LookupMode::Path)\n+                        {\n+                            continue;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                if let Some(result) = callback(&ty.value, item) {\n+                    return Some(result);\n                 }\n             }\n         }"}, {"sha": "bfef48b1613a5a29c3a1ebaa043a52098e487337", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=1173c3dab5f77a1afd367d547790dd82c558fe0d", "patch": "@@ -1841,8 +1841,8 @@ fn test() {\n     [243; 254) 'Struct::FOO': u32\n     [264; 265) 'y': u32\n     [268; 277) 'Enum::BAR': u32\n-    [287; 288) 'z': {unknown}\n-    [291; 304) 'TraitTest::ID': {unknown}\n+    [287; 288) 'z': u32\n+    [291; 304) 'TraitTest::ID': u32\n     \"###\n     );\n }"}, {"sha": "7135f481d04d5b51198076aa8452dae4ac17ea65", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1173c3dab5f77a1afd367d547790dd82c558fe0d/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=1173c3dab5f77a1afd367d547790dd82c558fe0d", "patch": "@@ -58,10 +58,12 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty)\n \n fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n     let mut seen_methods = FxHashSet::default();\n-    ctx.analyzer.iterate_method_candidates(ctx.db, receiver, None, |_ty, func| {\n-        let data = func.data(ctx.db);\n-        if data.has_self_param() && seen_methods.insert(data.name().clone()) {\n-            acc.add_function(ctx, func);\n+    ctx.analyzer.iterate_method_candidates(ctx.db, receiver, None, |_ty, item| {\n+        if let hir::AssocItem::Function(func) = item {\n+            let data = func.data(ctx.db);\n+            if data.has_self_param() && seen_methods.insert(data.name().clone()) {\n+                acc.add_function(ctx, func);\n+            }\n         }\n         None::<()>\n     });"}]}