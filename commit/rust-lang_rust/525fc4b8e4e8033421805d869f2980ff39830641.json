{"sha": "525fc4b8e4e8033421805d869f2980ff39830641", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyNWZjNGI4ZTRlODAzMzQyMTgwNWQ4NjlmMjk4MGZmMzk4MzA2NDE=", "commit": {"author": {"name": "Skgland", "email": "bb-github@t-online.de", "date": "2021-01-26T14:05:11Z"}, "committer": {"name": "Skgland", "email": "bb-github@t-online.de", "date": "2021-02-09T12:42:36Z"}, "message": "use ufcs in derive(RustEncodable)", "tree": {"sha": "ab40caa108d752784e44eda8dc821c79bde04aa6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab40caa108d752784e44eda8dc821c79bde04aa6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/525fc4b8e4e8033421805d869f2980ff39830641", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEExK/X7hjj1qyNARZpO+Gho8vDz5kFAmAigzwACgkQO+Gho8vD\nz5nhngf6A7j/HdrQJcDhoPRwWzhEWvK1gQ1AF00I0Cbmdi0hDHABR6VusHyxLHnr\nB9hVuqAQoLBbDs6gkehGvyI5hF9UOO46jBsIq0cS2TEDvpsfRZEQWBfyrSGVLVDN\n6pfFl5gOMDAgwq0UAk70w2VEtMieCO8MX74VV1ZNKLW31M2Md7gBLgVQZtby8zNk\ncgoquvg0nJmd5WIo/S9iDK/OzzxmFb0aKht8Ne3aH4FraT2QEj5kji6BkQjaGIXb\n5aHyDJDJqY8qOxp1Pu+DBaT62bpVhK9mYoShy6NKf42s7D+i8G1uIbTUMfVl3VrK\n3iBqR0e+elS4oPEI0Sm20jdC+18WQg==\n=s4l+\n-----END PGP SIGNATURE-----", "payload": "tree ab40caa108d752784e44eda8dc821c79bde04aa6\nparent e1010424dccf684dcf4225b3c6574bb1a9bacf6a\nauthor Skgland <bb-github@t-online.de> 1611669911 +0100\ncommitter Skgland <bb-github@t-online.de> 1612874556 +0100\n\nuse ufcs in derive(RustEncodable)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/525fc4b8e4e8033421805d869f2980ff39830641", "html_url": "https://github.com/rust-lang/rust/commit/525fc4b8e4e8033421805d869f2980ff39830641", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/525fc4b8e4e8033421805d869f2980ff39830641/comments", "author": {"login": "Skgland", "id": 3877590, "node_id": "MDQ6VXNlcjM4Nzc1OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/3877590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Skgland", "html_url": "https://github.com/Skgland", "followers_url": "https://api.github.com/users/Skgland/followers", "following_url": "https://api.github.com/users/Skgland/following{/other_user}", "gists_url": "https://api.github.com/users/Skgland/gists{/gist_id}", "starred_url": "https://api.github.com/users/Skgland/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Skgland/subscriptions", "organizations_url": "https://api.github.com/users/Skgland/orgs", "repos_url": "https://api.github.com/users/Skgland/repos", "events_url": "https://api.github.com/users/Skgland/events{/privacy}", "received_events_url": "https://api.github.com/users/Skgland/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Skgland", "id": 3877590, "node_id": "MDQ6VXNlcjM4Nzc1OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/3877590?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Skgland", "html_url": "https://github.com/Skgland", "followers_url": "https://api.github.com/users/Skgland/followers", "following_url": "https://api.github.com/users/Skgland/following{/other_user}", "gists_url": "https://api.github.com/users/Skgland/gists{/gist_id}", "starred_url": "https://api.github.com/users/Skgland/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Skgland/subscriptions", "organizations_url": "https://api.github.com/users/Skgland/orgs", "repos_url": "https://api.github.com/users/Skgland/repos", "events_url": "https://api.github.com/users/Skgland/events{/privacy}", "received_events_url": "https://api.github.com/users/Skgland/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1010424dccf684dcf4225b3c6574bb1a9bacf6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1010424dccf684dcf4225b3c6574bb1a9bacf6a", "html_url": "https://github.com/rust-lang/rust/commit/e1010424dccf684dcf4225b3c6574bb1a9bacf6a"}], "stats": {"total": 60, "additions": 40, "deletions": 20}, "files": [{"sha": "8aa805416ffa400e66a5f57701f47a168d4190b4", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/525fc4b8e4e8033421805d869f2980ff39830641/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/525fc4b8e4e8033421805d869f2980ff39830641/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=525fc4b8e4e8033421805d869f2980ff39830641", "patch": "@@ -179,7 +179,8 @@ fn encodable_substructure(\n \n     match *substr.fields {\n         Struct(_, ref fields) => {\n-            let emit_struct_field = Ident::new(sym::emit_struct_field, trait_span);\n+            let fn_emit_struct_field_path =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Encodable, sym::emit_struct_field]);\n             let mut stmts = Vec::new();\n             for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n@@ -189,11 +190,15 @@ fn encodable_substructure(\n                 let self_ref = cx.expr_addr_of(span, self_.clone());\n                 let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n                 let lambda = cx.lambda1(span, enc, blkarg);\n-                let call = cx.expr_method_call(\n+                let call = cx.expr_call_global(\n                     span,\n-                    blkencoder.clone(),\n-                    emit_struct_field,\n-                    vec![cx.expr_str(span, name), cx.expr_usize(span, i), lambda],\n+                    fn_emit_struct_field_path.clone(),\n+                    vec![\n+                        blkencoder.clone(),\n+                        cx.expr_str(span, name),\n+                        cx.expr_usize(span, i),\n+                        lambda,\n+                    ],\n                 );\n \n                 // last call doesn't need a try!\n@@ -216,11 +221,14 @@ fn encodable_substructure(\n                 cx.lambda_stmts_1(trait_span, stmts, blkarg)\n             };\n \n-            cx.expr_method_call(\n+            let fn_emit_struct_path =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Encodable, sym::emit_struct]);\n+\n+            cx.expr_call_global(\n                 trait_span,\n-                encoder,\n-                Ident::new(sym::emit_struct, trait_span),\n+                fn_emit_struct_path,\n                 vec![\n+                    encoder,\n                     cx.expr_str(trait_span, substr.type_ident.name),\n                     cx.expr_usize(trait_span, fields.len()),\n                     blk,\n@@ -235,7 +243,13 @@ fn encodable_substructure(\n             // actually exist.\n             let me = cx.stmt_let(trait_span, false, blkarg, encoder);\n             let encoder = cx.expr_ident(trait_span, blkarg);\n-            let emit_variant_arg = Ident::new(sym::emit_enum_variant_arg, trait_span);\n+\n+            let fn_emit_enum_variant_arg_path: Vec<_> = cx.def_site_path(&[\n+                sym::rustc_serialize,\n+                sym::Encodable,\n+                sym::emit_enum_variant_arg,\n+            ]);\n+\n             let mut stmts = Vec::new();\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n@@ -244,11 +258,11 @@ fn encodable_substructure(\n                     let enc =\n                         cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n                     let lambda = cx.lambda1(span, enc, blkarg);\n-                    let call = cx.expr_method_call(\n+\n+                    let call = cx.expr_call_global(\n                         span,\n-                        blkencoder.clone(),\n-                        emit_variant_arg,\n-                        vec![cx.expr_usize(span, i), lambda],\n+                        fn_emit_enum_variant_arg_path.clone(),\n+                        vec![blkencoder.clone(), cx.expr_usize(span, i), lambda],\n                     );\n                     let call = if i != last {\n                         cx.expr_try(span, call)\n@@ -265,23 +279,29 @@ fn encodable_substructure(\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n             let name = cx.expr_str(trait_span, variant.ident.name);\n-            let call = cx.expr_method_call(\n+\n+            let fn_emit_enum_variant_path: Vec<_> =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Encodable, sym::emit_enum_variant]);\n+\n+            let call = cx.expr_call_global(\n                 trait_span,\n-                blkencoder,\n-                Ident::new(sym::emit_enum_variant, trait_span),\n+                fn_emit_enum_variant_path,\n                 vec![\n+                    blkencoder,\n                     name,\n                     cx.expr_usize(trait_span, idx),\n                     cx.expr_usize(trait_span, fields.len()),\n                     blk,\n                 ],\n             );\n+\n             let blk = cx.lambda1(trait_span, call, blkarg);\n-            let ret = cx.expr_method_call(\n+            let fn_emit_enum_path: Vec<_> =\n+                cx.def_site_path(&[sym::rustc_serialize, sym::Encodable, sym::emit_enum]);\n+            let ret = cx.expr_call_global(\n                 trait_span,\n-                encoder,\n-                Ident::new(sym::emit_enum, trait_span),\n-                vec![cx.expr_str(trait_span, substr.type_ident.name), blk],\n+                fn_emit_enum_path,\n+                vec![encoder, cx.expr_str(trait_span, substr.type_ident.name), blk],\n             );\n             cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))\n         }"}]}