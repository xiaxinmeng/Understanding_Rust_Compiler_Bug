{"sha": "530909f2d8595447ef95e15326549ab7a51874e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMDkwOWYyZDg1OTU0NDdlZjk1ZTE1MzI2NTQ5YWI3YTUxODc0ZTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-30T17:36:26Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-22T23:15:28Z"}, "message": "Implement std::rt::at_exit\n\nThis routine is currently only used to clean up the timer helper thread in the\nlibnative implementation, but there are possibly other uses for this.\n\nThe documentation is clear that the procedures are *not* run with any task\ncontext and hence have very little available to them. I also opted to disallow\nat_exit inside of at_exit and just abort the process at that point.", "tree": {"sha": "70a99eb7fbfecc8893586827bb15c3f3c75237e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70a99eb7fbfecc8893586827bb15c3f3c75237e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/530909f2d8595447ef95e15326549ab7a51874e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/530909f2d8595447ef95e15326549ab7a51874e7", "html_url": "https://github.com/rust-lang/rust/commit/530909f2d8595447ef95e15326549ab7a51874e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/530909f2d8595447ef95e15326549ab7a51874e7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fce792249e72a181f2ad52413b25b1db643c371f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fce792249e72a181f2ad52413b25b1db643c371f", "html_url": "https://github.com/rust-lang/rust/commit/fce792249e72a181f2ad52413b25b1db643c371f"}], "stats": {"total": 87, "additions": 87, "deletions": 0}, "files": [{"sha": "df507de8bcfcb2bce36030679d786cb9eb734558", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/530909f2d8595447ef95e15326549ab7a51874e7/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/530909f2d8595447ef95e15326549ab7a51874e7/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=530909f2d8595447ef95e15326549ab7a51874e7", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of running at_exit routines\n+//!\n+//! Documentation can be found on the `rt::at_exit` function.\n+\n+use cast;\n+use option::{Some, None};\n+use ptr::RawPtr;\n+use unstable::sync::Exclusive;\n+use util;\n+\n+type Queue = Exclusive<~[proc()]>;\n+\n+static mut QUEUE: *mut Queue = 0 as *mut Queue;\n+static mut RUNNING: bool = false;\n+\n+pub fn init() {\n+    unsafe {\n+        rtassert!(!RUNNING);\n+        rtassert!(QUEUE.is_null());\n+        let state: ~Queue = ~Exclusive::new(~[]);\n+        QUEUE = cast::transmute(state);\n+    }\n+}\n+\n+pub fn push(f: proc()) {\n+    unsafe {\n+        rtassert!(!RUNNING);\n+        rtassert!(!QUEUE.is_null());\n+        let state: &mut Queue = cast::transmute(QUEUE);\n+        let mut f = Some(f);\n+        state.with(|arr|  {\n+            arr.push(f.take_unwrap());\n+        });\n+    }\n+}\n+\n+pub fn run() {\n+    let vec = unsafe {\n+        rtassert!(!RUNNING);\n+        rtassert!(!QUEUE.is_null());\n+        RUNNING = true;\n+        let state: ~Queue = cast::transmute(QUEUE);\n+        QUEUE = 0 as *mut Queue;\n+        let mut vec = None;\n+        state.with(|arr| {\n+            vec = Some(util::replace(arr, ~[]));\n+        });\n+        vec.take_unwrap()\n+    };\n+\n+\n+    for f in vec.move_iter() {\n+        f();\n+    }\n+}"}, {"sha": "7aa966802f2f5ec8fa5a2202853f72e100951754", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/530909f2d8595447ef95e15326549ab7a51874e7/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/530909f2d8595447ef95e15326549ab7a51874e7/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=530909f2d8595447ef95e15326549ab7a51874e7", "patch": "@@ -127,6 +127,9 @@ mod util;\n // Global command line argument storage\n pub mod args;\n \n+// Support for running procedures when a program has exited.\n+mod at_exit_imp;\n+\n /// The default error code of the rust runtime if the main task fails instead\n /// of exiting cleanly.\n pub static DEFAULT_ERROR_CODE: int = 101;\n@@ -171,9 +174,27 @@ pub fn init(argc: int, argv: **u8) {\n         env::init();\n         logging::init();\n         local_ptr::init();\n+        at_exit_imp::init();\n     }\n }\n \n+/// Enqueues a procedure to run when the runtime is cleaned up\n+///\n+/// The procedure passed to this function will be executed as part of the\n+/// runtime cleanup phase. For normal rust programs, this means that it will run\n+/// after all other tasks have exited.\n+///\n+/// The procedure is *not* executed with a local `Task` available to it, so\n+/// primitives like logging, I/O, channels, spawning, etc, are *not* available.\n+/// This is meant for \"bare bones\" usage to clean up runtime details, this is\n+/// not meant as a general-purpose \"let's clean everything up\" function.\n+///\n+/// It is forbidden for procedures to register more `at_exit` handlers when they\n+/// are running, and doing so will lead to a process abort.\n+pub fn at_exit(f: proc()) {\n+    at_exit_imp::push(f);\n+}\n+\n /// One-time runtime cleanup.\n ///\n /// This function is unsafe because it performs no checks to ensure that the\n@@ -184,6 +205,7 @@ pub fn init(argc: int, argv: **u8) {\n /// Invoking cleanup while portions of the runtime are still in use may cause\n /// undefined behavior.\n pub unsafe fn cleanup() {\n+    at_exit_imp::run();\n     args::cleanup();\n     local_ptr::cleanup();\n }"}]}