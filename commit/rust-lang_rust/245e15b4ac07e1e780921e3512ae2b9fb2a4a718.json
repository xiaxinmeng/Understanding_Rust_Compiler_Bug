{"sha": "245e15b4ac07e1e780921e3512ae2b9fb2a4a718", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NWUxNWI0YWMwN2UxZTc4MDkyMWUzNTEyYWUyYjlmYjJhNGE3MTg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-23T12:49:19Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-24T20:53:23Z"}, "message": "parse: extract `parse_stmt_item` & `parse_stmt_path_start`.", "tree": {"sha": "3df58a05538d6860392e9331bd1d39fb0ad9cf19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3df58a05538d6860392e9331bd1d39fb0ad9cf19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/245e15b4ac07e1e780921e3512ae2b9fb2a4a718", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/245e15b4ac07e1e780921e3512ae2b9fb2a4a718", "html_url": "https://github.com/rust-lang/rust/commit/245e15b4ac07e1e780921e3512ae2b9fb2a4a718", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/245e15b4ac07e1e780921e3512ae2b9fb2a4a718/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "834bc5650acf7019a53b409db68986857822812c", "url": "https://api.github.com/repos/rust-lang/rust/commits/834bc5650acf7019a53b409db68986857822812c", "html_url": "https://github.com/rust-lang/rust/commit/834bc5650acf7019a53b409db68986857822812c"}], "stats": {"total": 65, "additions": 33, "deletions": 32}, "files": [{"sha": "4d86836ff900a7fb257c77526e089adc7805a65e", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/245e15b4ac07e1e780921e3512ae2b9fb2a4a718/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/245e15b4ac07e1e780921e3512ae2b9fb2a4a718/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=245e15b4ac07e1e780921e3512ae2b9fb2a4a718", "patch": "@@ -58,33 +58,11 @@ impl<'a> Parser<'a> {\n         // (1 token), but it fact not a path. Also, we avoid stealing syntax from `parse_item_`.\n         if self.token.is_path_start() && !self.token.is_qpath_start() && !self.is_path_start_item()\n         {\n-            let path = self.parse_path(PathStyle::Expr)?;\n-\n-            if self.eat(&token::Not) {\n-                return self.parse_stmt_mac(lo, attrs.into(), path);\n-            }\n-\n-            let expr = if self.check(&token::OpenDelim(token::Brace)) {\n-                self.parse_struct_expr(lo, path, AttrVec::new())?\n-            } else {\n-                let hi = self.prev_span;\n-                self.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())\n-            };\n-\n-            let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n-                let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n-                this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n-            })?;\n-            return Ok(Some(self.mk_stmt(lo.to(self.prev_span), StmtKind::Expr(expr))));\n+            return self.parse_stmt_path_start(lo, attrs).map(Some);\n         }\n \n-        // FIXME: Bad copy of attrs\n-        let old_directory_ownership =\n-            mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n-        let item = self.parse_item_common(attrs.clone(), false, true, |_| true)?;\n-        self.directory.ownership = old_directory_ownership;\n-\n-        if let Some(item) = item {\n+        if let Some(item) = self.parse_stmt_item(attrs.clone())? {\n+            // FIXME: Bad copy of attrs\n             return Ok(Some(self.mk_stmt(lo.to(item.span), StmtKind::Item(P(item)))));\n         }\n \n@@ -117,14 +95,37 @@ impl<'a> Parser<'a> {\n         Ok(Some(self.mk_stmt(lo.to(e.span), StmtKind::Expr(e))))\n     }\n \n+    fn parse_stmt_item(&mut self, attrs: Vec<Attribute>) -> PResult<'a, Option<ast::Item>> {\n+        let old = mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n+        let item = self.parse_item_common(attrs.clone(), false, true, |_| true)?;\n+        self.directory.ownership = old;\n+        Ok(item)\n+    }\n+\n+    fn parse_stmt_path_start(&mut self, lo: Span, attrs: Vec<Attribute>) -> PResult<'a, Stmt> {\n+        let path = self.parse_path(PathStyle::Expr)?;\n+\n+        if self.eat(&token::Not) {\n+            return self.parse_stmt_mac(lo, attrs.into(), path);\n+        }\n+\n+        let expr = if self.check(&token::OpenDelim(token::Brace)) {\n+            self.parse_struct_expr(lo, path, AttrVec::new())?\n+        } else {\n+            let hi = self.prev_span;\n+            self.mk_expr(lo.to(hi), ExprKind::Path(None, path), AttrVec::new())\n+        };\n+\n+        let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n+            let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n+            this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n+        })?;\n+        Ok(self.mk_stmt(lo.to(self.prev_span), StmtKind::Expr(expr)))\n+    }\n+\n     /// Parses a statement macro `mac!(args)` provided a `path` representing `mac`.\n     /// At this point, the `!` token after the path has already been eaten.\n-    fn parse_stmt_mac(\n-        &mut self,\n-        lo: Span,\n-        attrs: AttrVec,\n-        path: ast::Path,\n-    ) -> PResult<'a, Option<Stmt>> {\n+    fn parse_stmt_mac(&mut self, lo: Span, attrs: AttrVec, path: ast::Path) -> PResult<'a, Stmt> {\n         let args = self.parse_mac_args()?;\n         let delim = args.delim();\n         let hi = self.prev_span;\n@@ -145,7 +146,7 @@ impl<'a> Parser<'a> {\n             let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n             StmtKind::Expr(e)\n         };\n-        Ok(Some(self.mk_stmt(lo.to(hi), kind)))\n+        Ok(self.mk_stmt(lo.to(hi), kind))\n     }\n \n     /// Error on outer attributes in this context."}]}