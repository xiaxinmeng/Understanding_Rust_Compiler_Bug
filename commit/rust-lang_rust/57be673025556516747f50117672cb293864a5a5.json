{"sha": "57be673025556516747f50117672cb293864a5a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YmU2NzMwMjU1NTY1MTY3NDdmNTAxMTc2NzJjYjI5Mzg2NGE1YTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-21T00:10:54Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-21T00:39:35Z"}, "message": "rustdoc: Document reexports", "tree": {"sha": "0449066d86d5ec28c792398e8fe3eb725443f1fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0449066d86d5ec28c792398e8fe3eb725443f1fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57be673025556516747f50117672cb293864a5a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57be673025556516747f50117672cb293864a5a5", "html_url": "https://github.com/rust-lang/rust/commit/57be673025556516747f50117672cb293864a5a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57be673025556516747f50117672cb293864a5a5/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "102896897067960341c17dae75958e955c6d7cb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/102896897067960341c17dae75958e955c6d7cb2", "html_url": "https://github.com/rust-lang/rust/commit/102896897067960341c17dae75958e955c6d7cb2"}], "stats": {"total": 303, "additions": 302, "deletions": 1}, "files": [{"sha": "21074cc46f87a4706782d5a248a8f0264642be0d", "filename": "src/rustdoc/reexport_pass.rs", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/57be673025556516747f50117672cb293864a5a5/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57be673025556516747f50117672cb293864a5a5/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=57be673025556516747f50117672cb293864a5a5", "patch": "@@ -0,0 +1,299 @@\n+#[doc = \"Finds docs for reexported items and duplicates them\"];\n+\n+import std::map;\n+import rustc::syntax::ast;\n+import rustc::syntax::ast_util;\n+import rustc::util::common;\n+\n+export mk_pass;\n+\n+fn mk_pass() -> pass {\n+    run\n+}\n+\n+type def_set = map::set<ast::def_id>;\n+type def_map = map::hashmap<ast::def_id, doc::itemtag>;\n+type path_map = map::hashmap<str, [(str, doc::itemtag)]>;\n+\n+fn run(srv: astsrv::srv, doc: doc::cratedoc) -> doc::cratedoc {\n+\n+    // First gather the set of defs that are used as reexports\n+    let def_set = build_reexport_def_set(srv);\n+\n+    // Now find the docs that go with those defs\n+    let def_map = build_reexport_def_map(srv, doc, def_set);\n+\n+    // Now create a map that tells us where to insert the duplicated\n+    // docs into the existing doc tree\n+    let path_map = build_reexport_path_map(srv, def_map);\n+\n+    // Finally update the doc tree\n+    merge_reexports(doc, path_map)\n+}\n+\n+fn build_reexport_def_set(srv: astsrv::srv) -> def_set {\n+    astsrv::exec(srv) {|ctxt|\n+        let def_set = common::new_def_hash();\n+        ctxt.exp_map.items {|_path, defs|\n+            for def in *defs {\n+                let def_id = ast_util::def_id_of_def(def);\n+                def_set.insert(def_id, ());\n+            }\n+        }\n+        def_set\n+    }\n+}\n+\n+fn build_reexport_def_map(\n+    srv: astsrv::srv,\n+    doc: doc::cratedoc,\n+    def_set: def_set\n+) -> def_map {\n+\n+    type ctxt = {\n+        srv: astsrv::srv,\n+        def_set: def_set,\n+        def_map: def_map\n+    };\n+\n+    let ctxt = {\n+        srv: srv,\n+        def_set: def_set,\n+        def_map: common::new_def_hash()\n+    };\n+\n+    let fold = fold::fold({\n+        fold_mod: fold_mod\n+        with *fold::default_seq_fold(ctxt)\n+    });\n+\n+    fold.fold_crate(fold, doc);\n+\n+    ret ctxt.def_map;\n+\n+    fn fold_mod(fold: fold::fold<ctxt>, doc: doc::moddoc) -> doc::moddoc {\n+        let doc = fold::default_seq_fold_mod(fold, doc);\n+\n+        for item in *doc.items {\n+            let def_id = ast_util::local_def(item.id());\n+            if fold.ctxt.def_set.contains_key(def_id) {\n+                fold.ctxt.def_map.insert(def_id, item);\n+            }\n+        }\n+\n+        ret doc;\n+    }\n+}\n+\n+fn to_assoc_list<V:copy>(\n+    map: map::hashmap<ast::def_id, V>\n+) -> [(ast::def_id, V)] {\n+\n+    let vec = [];\n+    map.items {|k, v|\n+        vec += [(k, v)];\n+    }\n+    ret vec;\n+}\n+\n+fn from_assoc_list<V:copy>(\n+    list: [(ast::def_id, V)]\n+) -> map::hashmap<ast::def_id, V> {\n+\n+    let map = common::new_def_hash();\n+    vec::iter(list) {|elt|\n+        let (k, v) = elt;\n+        map.insert(k, v);\n+    }\n+    ret map;\n+}\n+\n+fn build_reexport_path_map(srv: astsrv::srv, -def_map: def_map) -> path_map {\n+\n+    // This is real unfortunate. Lots of copying going on here\n+    let def_assoc_list = to_assoc_list(def_map);\n+    #debug(\"def_map: %?\", def_assoc_list);\n+\n+    astsrv::exec(srv) {|ctxt|\n+\n+        let def_map = from_assoc_list(def_assoc_list);\n+        let path_map = map::new_str_hash();\n+\n+        ctxt.exp_map.items {|path, defs|\n+\n+            let path = str::split_str(path, \"::\");\n+            let modpath = str::connect(vec::init(path), \"::\");\n+            let name = option::get(vec::last(path));\n+\n+            let reexportdocs = [];\n+\n+            for def in *defs {\n+                let def_id = ast_util::def_id_of_def(def);\n+                alt def_map.find(def_id) {\n+                  some(itemtag) {\n+                    reexportdocs += [(name, itemtag)];\n+                  }\n+                  none { }\n+                }\n+            }\n+\n+            if vec::is_not_empty(reexportdocs) {\n+                let prevdocs = alt path_map.find(modpath) {\n+                  some(docs) { docs }\n+                  none { [] }\n+                };\n+                let reexportdocs = prevdocs + reexportdocs;\n+                path_map.insert(modpath, reexportdocs);\n+                #debug(\"path_map entry: %? - %?\",\n+                       modpath, (name, reexportdocs));\n+            }\n+        }\n+\n+        path_map\n+    }\n+}\n+\n+fn merge_reexports(\n+    doc: doc::cratedoc,\n+    path_map: path_map\n+) -> doc::cratedoc {\n+\n+    let fold = fold::fold({\n+        fold_mod: fold_mod\n+        with *fold::default_seq_fold(path_map)\n+    });\n+\n+    ret fold.fold_crate(fold, doc);\n+\n+    fn fold_mod(fold: fold::fold<path_map>, doc: doc::moddoc) -> doc::moddoc {\n+        let doc = fold::default_seq_fold_mod(fold, doc);\n+\n+        let path = doc.path() + [doc.name()];\n+        let new_items = get_new_items(path, fold.ctxt);\n+        #debug(\"merging into %?: %?\", path, new_items);\n+\n+        {\n+            items: ~(*doc.items + new_items)\n+            with doc\n+        }\n+    }\n+\n+    fn get_new_items(path: [str], path_map: path_map) -> [doc::itemtag] {\n+        #debug(\"looking for reexports in path %?\", path);\n+        alt path_map.find(str::connect(path, \"::\")) {\n+          some(name_docs) {\n+            vec::foldl([], name_docs) {|v, name_doc|\n+                let (name, doc) = name_doc;\n+                v + [rename_doc(doc, name)]\n+            }\n+          }\n+          none { [] }\n+        }\n+    }\n+\n+    fn rename_doc(doc: doc::itemtag, name: str) -> doc::itemtag {\n+        alt doc {\n+          doc::modtag(doc @ {item, _}) {\n+            doc::modtag({\n+                item: rename(item, name)\n+                with doc\n+            })\n+          }\n+          doc::consttag(doc @ {item, _}) {\n+            doc::consttag({\n+                item: rename(item, name)\n+                with doc\n+            })\n+          }\n+          doc::fntag(doc @ {item, _}) {\n+            doc::fntag({\n+                item: rename(item, name)\n+                with doc\n+            })\n+          }\n+          doc::enumtag(doc @ {item, _}) {\n+            doc::enumtag({\n+                item: rename(item, name)\n+                with doc\n+            })\n+          }\n+          doc::restag(doc @ {item, _}) {\n+            doc::restag({\n+                item: rename(item, name)\n+                with doc\n+            })\n+          }\n+          doc::ifacetag(doc @ {item, _}) {\n+            doc::ifacetag({\n+                item: rename(item, name)\n+                with doc\n+            })\n+          }\n+          doc::impltag(doc @ {item, _}) {\n+            doc::impltag({\n+                item: rename(item, name)\n+                with doc\n+            })\n+          }\n+          doc::tytag(doc @ {item, _}) {\n+            doc::tytag({\n+                item: rename(item, name)\n+                with doc\n+            })\n+          }\n+        }\n+    }\n+\n+    fn rename(doc: doc::itemdoc, name: str) -> doc::itemdoc {\n+        {\n+            name: name\n+            with doc\n+        }\n+    }\n+}\n+\n+#[test]\n+fn should_duplicate_reexported_items() {\n+    let source = \"mod a { export b; fn b() { } } \\\n+                  mod c { import a::b; export b; }\";\n+    let doc = test::mk_doc(source);\n+    assert doc.topmod.mods()[1].fns()[0].name() == \"b\";\n+}\n+\n+#[test]\n+fn should_duplicate_multiple_reexported_items() {\n+    let source = \"mod a { \\\n+                  export b; export c; \\\n+                  fn b() { } fn c() { } \\\n+                  } \\\n+                  mod d { \\\n+                  import a::b; import a::c; \\\n+                  export b; export c; \\\n+                  }\";\n+    let srv = astsrv::mk_srv_from_str(source);\n+    let doc = extract::from_srv(srv, \"\");\n+    let doc = path_pass::mk_pass()(srv, doc);\n+    let doc = run(srv, doc);\n+    // Reexports may not be in any specific order\n+    let doc = sort_item_name_pass::mk_pass()(srv, doc);\n+    assert doc.topmod.mods()[1].fns()[0].name() == \"b\";\n+    assert doc.topmod.mods()[1].fns()[1].name() == \"c\";\n+}\n+\n+#[test]\n+fn should_rename_items_reexported_with_different_names() {\n+    let source = \"mod a { export b; fn b() { } } \\\n+                  mod c { import x = a::b; export x; }\";\n+    let doc = test::mk_doc(source);\n+    assert doc.topmod.mods()[1].fns()[0].name() == \"x\";\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    fn mk_doc(source: str) -> doc::cratedoc {\n+        let srv = astsrv::mk_srv_from_str(source);\n+        let doc = extract::from_srv(srv, \"\");\n+        let doc = path_pass::mk_pass()(srv, doc);\n+        run(srv, doc)\n+    }\n+}"}, {"sha": "0e1e5e684528a0884ad0b30350f691a71c38e030", "filename": "src/rustdoc/rustdoc.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57be673025556516747f50117672cb293864a5a5/src%2Frustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/57be673025556516747f50117672cb293864a5a5/src%2Frustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rc?ref=57be673025556516747f50117672cb293864a5a5", "patch": "@@ -32,4 +32,5 @@ mod astsrv;\n mod demo;\n mod sort_pass;\n mod sort_item_name_pass;\n-mod sort_item_type_pass;\n\\ No newline at end of file\n+mod sort_item_type_pass;\n+mod reexport_pass;"}, {"sha": "f9a63b87389da63fa1a8e292d16817eb14c95faa", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57be673025556516747f50117672cb293864a5a5/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57be673025556516747f50117672cb293864a5a5/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=57be673025556516747f50117672cb293864a5a5", "patch": "@@ -106,6 +106,7 @@ fn run(source_file: str) {\n         desc_to_brief_pass::mk_pass(),\n         trim_pass::mk_pass(),\n         unindent_pass::mk_pass(),\n+        reexport_pass::mk_pass(),\n         sort_item_name_pass::mk_pass(),\n         sort_item_type_pass::mk_pass(),\n         markdown_pass::mk_pass {|f| f(std::io:: stdout()) }"}]}