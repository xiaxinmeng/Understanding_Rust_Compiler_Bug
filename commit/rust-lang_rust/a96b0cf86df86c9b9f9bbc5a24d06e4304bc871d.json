{"sha": "a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NmIwY2Y4NmRmODZjOWI5ZjliYmM1YTI0ZDA2ZTQzMDRiYzg3MWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-10T11:04:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T13:25:21Z"}, "message": "replace constant regions with a post-inference check\n\nRather than declaring some region variables to be constant, and\nreporting errors when they would have to change, we instead populate\neach free region X with a minimal set of points (the CFG plus end(X)),\nand then we let inference do its thing. This may add other `end(Y)`\npoints into X; we can then check after the fact that indeed `X: Y`\nholds.\n\nThis requires a bit of \"blame\" detection to find where the bad\nconstraint came from: we are currently using a pretty dumb\nalgorithm. Good place for later expansion.", "tree": {"sha": "bdb627f26f36e7f59705b3420c9f7e8f4fcfc187", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdb627f26f36e7f59705b3420c9f7e8f4fcfc187"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d", "html_url": "https://github.com/rust-lang/rust/commit/a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "932452ecc7f0a8ab8ad678a343d828385de80e1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/932452ecc7f0a8ab8ad678a343d828385de80e1a", "html_url": "https://github.com/rust-lang/rust/commit/932452ecc7f0a8ab8ad678a343d828385de80e1a"}], "stats": {"total": 263, "additions": 163, "deletions": 100}, "files": [{"sha": "3f0e6e2c28dd0dd446f506c748d005f8816a39d6", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d", "patch": "@@ -63,28 +63,28 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n                            -> bool {\n         let result = sub_region == super_region || {\n             match (sub_region, super_region) {\n-                (&ty::ReEmpty, _) |\n-                (_, &ty::ReStatic) =>\n+                (ty::ReEmpty, _) |\n+                (_, ty::ReStatic) =>\n                     true,\n \n-                (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n-                    self.region_scope_tree.is_subscope_of(sub_scope, super_scope),\n+                (ty::ReScope(sub_scope), ty::ReScope(super_scope)) =>\n+                    self.region_scope_tree.is_subscope_of(*sub_scope, *super_scope),\n \n-                (&ty::ReScope(sub_scope), &ty::ReEarlyBound(ref br)) => {\n+                (ty::ReScope(sub_scope), ty::ReEarlyBound(ref br)) => {\n                     let fr_scope = self.region_scope_tree.early_free_scope(self.tcx, br);\n-                    self.region_scope_tree.is_subscope_of(sub_scope, fr_scope)\n+                    self.region_scope_tree.is_subscope_of(*sub_scope, fr_scope)\n                 }\n \n-                (&ty::ReScope(sub_scope), &ty::ReFree(ref fr)) => {\n+                (ty::ReScope(sub_scope), ty::ReFree(fr)) => {\n                     let fr_scope = self.region_scope_tree.free_scope(self.tcx, fr);\n-                    self.region_scope_tree.is_subscope_of(sub_scope, fr_scope)\n+                    self.region_scope_tree.is_subscope_of(*sub_scope, fr_scope)\n                 }\n \n-                (&ty::ReEarlyBound(_), &ty::ReEarlyBound(_)) |\n-                (&ty::ReFree(_), &ty::ReEarlyBound(_)) |\n-                (&ty::ReEarlyBound(_), &ty::ReFree(_)) |\n-                (&ty::ReFree(_), &ty::ReFree(_)) =>\n-                    self.free_regions.sub_free_regions(&sub_region, &super_region),\n+                (ty::ReEarlyBound(_), ty::ReEarlyBound(_)) |\n+                (ty::ReFree(_), ty::ReEarlyBound(_)) |\n+                (ty::ReEarlyBound(_), ty::ReFree(_)) |\n+                (ty::ReFree(_), ty::ReFree(_)) =>\n+                    self.free_regions.sub_free_regions(sub_region, super_region),\n \n                 _ =>\n                     false,\n@@ -162,23 +162,23 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     /// (with the exception that `'static: 'x` is not notable)\n     pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n         debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n-        if (is_free(sub) || *sub == ty::ReStatic) && is_free(sup) {\n+        if is_free_or_static(sub) && is_free(sup) {\n             self.relation.add(sub, sup)\n         }\n     }\n \n-    /// True if `r_a <= r_b` is known to hold. Both `r_a` and `r_b`\n-    /// must be free regions from the function header.\n+    /// Tests whether `r_a <= sup`. Both must be free regions or\n+    /// `'static`.\n     pub fn sub_free_regions<'a, 'gcx>(&self,\n                                       r_a: Region<'tcx>,\n                                       r_b: Region<'tcx>)\n                                       -> bool {\n-        debug!(\"sub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n-        assert!(is_free(r_a));\n-        assert!(is_free(r_b));\n-        let result = r_a == r_b || self.relation.contains(&r_a, &r_b);\n-        debug!(\"sub_free_regions: result={}\", result);\n-        result\n+        assert!(is_free_or_static(r_a) && is_free_or_static(r_b));\n+        if let ty::ReStatic = r_b {\n+            true // `'a <= 'static` is just always true, and not stored in the relation explicitly\n+        } else {\n+            r_a == r_b || self.relation.contains(&r_a, &r_b)\n+        }\n     }\n \n     /// Compute the least-upper-bound of two free regions. In some\n@@ -224,6 +224,13 @@ fn is_free(r: Region) -> bool {\n     }\n }\n \n+fn is_free_or_static(r: Region) -> bool {\n+    match *r {\n+        ty::ReStatic => true,\n+        _ => is_free(r),\n+    }\n+}\n+\n impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n     relation\n });"}, {"sha": "f60bd3c6ecec5a89345de26bf97230bdbeab093c", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "modified", "additions": 132, "deletions": 76, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d", "patch": "@@ -13,6 +13,7 @@ use rustc::infer::InferCtxt;\n use rustc::infer::RegionVariableOrigin;\n use rustc::infer::NLLRegionVariableOrigin;\n use rustc::infer::region_constraints::VarOrigins;\n+use rustc::middle::free_region::FreeRegionMap;\n use rustc::mir::{Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -40,6 +41,8 @@ pub struct RegionInferenceContext<'tcx> {\n \n     /// The constraints we have accumulated and used during solving.\n     constraints: Vec<Constraint>,\n+\n+    free_region_map: &'tcx FreeRegionMap<'tcx>,\n }\n \n struct RegionDefinition<'tcx> {\n@@ -52,10 +55,6 @@ struct RegionDefinition<'tcx> {\n     /// If this is a free-region, then this is `Some(X)` where `X` is\n     /// the name of the region.\n     name: Option<ty::Region<'tcx>>,\n-\n-    /// If true, this is a constant region which cannot grow larger.\n-    /// This is used for named regions as well as `'static`.\n-    constant: bool,\n }\n \n /// The value of an individual region variable. Region variables\n@@ -100,7 +99,6 @@ pub struct Constraint {\n     // it is for convenience. Before we dump the constraints in the\n     // debugging logs, we sort them, and we'd like the \"super region\"\n     // to be first, etc. (In particular, span should remain last.)\n-\n     /// The region SUP must outlive SUB...\n     sup: RegionVid,\n \n@@ -114,7 +112,7 @@ pub struct Constraint {\n     span: Span,\n }\n \n-impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n+impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n     /// of those will be constant regions representing the free\n@@ -133,6 +131,7 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n             liveness_constraints: IndexVec::from_elem_n(Region::default(), num_region_variables),\n             inferred_values: None,\n             constraints: Vec::new(),\n+            free_region_map: free_regions.free_region_map,\n         };\n \n         result.init_free_regions(free_regions, mir);\n@@ -162,7 +161,7 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     fn init_free_regions(&mut self, free_regions: &FreeRegions<'tcx>, mir: &Mir<'tcx>) {\n         let FreeRegions {\n             indices,\n-            free_region_map,\n+            free_region_map: _,\n         } = free_regions;\n \n         // For each free region X:\n@@ -175,7 +174,6 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n \n             // Initialize the name and a few other details.\n             self.definitions[variable].name = Some(free_region);\n-            self.definitions[variable].constant = true;\n \n             // Add all nodes in the CFG to `definition.value`.\n             for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n@@ -192,21 +190,6 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n             // Add `end(X)` into the set for X.\n             self.liveness_constraints[variable].add_free_region(variable);\n \n-            // `'static` outlives all other free regions as well.\n-            if let ty::ReStatic = free_region {\n-                for &other_variable in indices.values() {\n-                    self.liveness_constraints[variable]\n-                        .add_free_region(other_variable);\n-                }\n-            }\n-\n-            // Go through each region Y that outlives X (i.e., where\n-            // Y: X is true). Add `end(X)` into the set for `Y`.\n-            for superregion in free_region_map.regions_that_outlive(&free_region) {\n-                let superregion_index = indices[superregion];\n-                self.liveness_constraints[superregion_index].add_free_region(variable);\n-            }\n-\n             debug!(\n                 \"init_free_regions: region variable for `{:?}` is `{:?}` with value `{:?}`\",\n                 free_region,\n@@ -265,32 +248,82 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Perform region inference.\n-    pub(super) fn solve(&mut self, infcx: &InferCtxt<'a, 'gcx, 'tcx>, mir: &Mir<'tcx>) {\n+    pub(super) fn solve(&mut self, infcx: &InferCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        let errors = self.propagate_constraints(mir);\n-\n-        // worst error msg ever\n-        for (fr1, span, fr2) in errors {\n-            infcx.tcx.sess.span_err(\n-                span,\n-                &format!(\n-                    \"free region `{}` does not outlive `{}`\",\n-                    self.definitions[fr1].name.unwrap(),\n-                    self.definitions[fr2].name.unwrap()\n-                ),\n-            );\n+\n+        // Find the minimal regions that can solve the constraints. This is infallible.\n+        self.propagate_constraints(mir);\n+\n+        // Now, see whether any of the constraints were too strong. In particular,\n+        // we want to check for a case where a free region exceeded its bounds.\n+        // Consider:\n+        //\n+        //     fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+        //\n+        // In this case, returning `x` requires `&'a u32 <: &'b u32`\n+        // and hence we establish (transitively) a constraint that\n+        // `'a: 'b`. The `propagate_constraints` code above will\n+        // therefore add `end('a)` into the region for `'b` -- but we\n+        // have no evidence that `'b` outlives `'a`, so we want to report\n+        // an error.\n+\n+        // The free regions are always found in a prefix of the full list.\n+        let free_region_definitions = self.definitions\n+            .iter_enumerated()\n+            .take_while(|(_, fr_definition)| fr_definition.name.is_some());\n+\n+        for (fr, fr_definition) in free_region_definitions {\n+            self.check_free_region(infcx, fr, fr_definition);\n+        }\n+    }\n+\n+    fn check_free_region(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        fr: RegionVid,\n+        fr_definition: &RegionDefinition<'tcx>,\n+    ) {\n+        let inferred_values = self.inferred_values.as_ref().unwrap();\n+        let fr_name = fr_definition.name.unwrap();\n+        let fr_value = &inferred_values[fr];\n+\n+        // Find every region `o` such that `fr: o`\n+        // (because `fr` includes `end(o)`).\n+        for &outlived_fr in &fr_value.free_regions {\n+            // `fr` includes `end(fr)`, that's not especially\n+            // interesting.\n+            if fr == outlived_fr {\n+                continue;\n+            }\n+\n+            let outlived_fr_definition = &self.definitions[outlived_fr];\n+            let outlived_fr_name = outlived_fr_definition.name.unwrap();\n+\n+            // Check that `o <= fr`. If not, report an error.\n+            if !self.free_region_map\n+                .sub_free_regions(outlived_fr_name, fr_name)\n+            {\n+                // worst error msg ever\n+                let blame_span = self.blame_span(fr, outlived_fr);\n+                infcx.tcx.sess.span_err(\n+                    blame_span,\n+                    &format!(\n+                        \"free region `{}` does not outlive `{}`\",\n+                        fr_name,\n+                        outlived_fr_name\n+                    ),\n+                );\n+            }\n         }\n     }\n \n     /// Propagate the region constraints: this will grow the values\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) -> Vec<(RegionVid, Span, RegionVid)> {\n+    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n         let mut changed = true;\n         let mut dfs = Dfs::new(mir);\n-        let mut error_regions = FxHashSet();\n-        let mut errors = vec![];\n \n         debug!(\"propagate_constraints()\");\n         debug!(\"propagate_constraints: constraints={:#?}\", {\n@@ -305,51 +338,78 @@ impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n \n         while changed {\n             changed = false;\n+            debug!(\"propagate_constraints: --------------------\");\n             for constraint in &self.constraints {\n                 debug!(\"propagate_constraints: constraint={:?}\", constraint);\n+\n                 let sub = &inferred_values[constraint.sub].clone();\n                 let sup_value = &mut inferred_values[constraint.sup];\n \n-                debug!(\"propagate_constraints:    sub (before): {:?}\", sub);\n-                debug!(\"propagate_constraints:    sup (before): {:?}\", sup_value);\n+                // Grow the value as needed to accommodate the\n+                // outlives constraint.\n \n-                if !self.definitions[constraint.sup].constant {\n-                    // If this is not a constant, then grow the value as needed to\n-                    // accommodate the outlives constraint.\n+                if dfs.copy(sub, sup_value, constraint.point) {\n+                    debug!(\"propagate_constraints:   sub={:?}\", sub);\n+                    debug!(\"propagate_constraints:   sup={:?}\", sup_value);\n+                    changed = true;\n+                }\n+            }\n+            debug!(\"\\n\");\n+        }\n \n-                    if dfs.copy(sub, sup_value, constraint.point) {\n-                        changed = true;\n-                    }\n+        self.inferred_values = Some(inferred_values);\n+    }\n \n-                    debug!(\"propagate_constraints:    sup (after) : {:?}\", sup_value);\n-                    debug!(\"propagate_constraints:    changed     : {:?}\", changed);\n-                } else {\n-                    // If this is a constant, check whether it *would\n-                    // have* to grow in order for the constraint to be\n-                    // satisfied. If so, create an error.\n-\n-                    let sup_value = &mut sup_value.clone();\n-                    if dfs.copy(sub, sup_value, constraint.point) {\n-                        // Constant values start out with the entire\n-                        // CFG, so it must be some new free region\n-                        // that was added. Find one.\n-                        let &new_region = sup_value\n-                            .free_regions\n-                            .difference(&sup_value.free_regions)\n-                            .next()\n-                            .unwrap();\n-                        debug!(\"propagate_constraints:    new_region : {:?}\", new_region);\n-                        if error_regions.insert(constraint.sup) {\n-                            errors.push((constraint.sup, constraint.span, new_region));\n-                        }\n+    /// Tries to finds a good span to blame for the fact that `fr1`\n+    /// contains `fr2`.\n+    fn blame_span(&self, fr1: RegionVid, fr2: RegionVid) -> Span {\n+        // Find everything that influenced final value of `fr`.\n+        let influenced_fr1 = self.dependencies(fr1);\n+\n+        // Try to find some outlives constraint `'X: fr2` where `'X`\n+        // influenced `fr1`. Blame that.\n+        //\n+        // NB, this is a pretty bad choice most of the time. In\n+        // particular, the connection between `'X` and `fr1` may not\n+        // be obvious to the user -- not to mention the naive notion\n+        // of dependencies, which doesn't account for the locations of\n+        // contraints at all. But it will do for now.\n+        for constraint in &self.constraints {\n+            if constraint.sub == fr2 && influenced_fr1[constraint.sup] {\n+                return constraint.span;\n+            }\n+        }\n+\n+        bug!(\n+            \"could not find any constraint to blame for {:?}: {:?}\",\n+            fr1,\n+            fr2\n+        );\n+    }\n+\n+    /// Finds all regions whose values `'a` may depend on in some way.\n+    /// Basically if there exists a constraint `'a: 'b @ P`, then `'b`\n+    /// and `dependencies('b)` will be in the final set.\n+    ///\n+    /// Used during error reporting, extremely naive and inefficient.\n+    fn dependencies(&self, r0: RegionVid) -> IndexVec<RegionVid, bool> {\n+        let mut result_set = IndexVec::from_elem(false, &self.definitions);\n+        let mut changed = true;\n+        result_set[r0] = true;\n+\n+        while changed {\n+            changed = false;\n+            for constraint in &self.constraints {\n+                if result_set[constraint.sup] {\n+                    if !result_set[constraint.sub] {\n+                        result_set[constraint.sub] = true;\n+                        changed = true;\n                     }\n                 }\n             }\n-            debug!(\"\\n\");\n         }\n \n-        self.inferred_values = Some(inferred_values);\n-        errors\n+        result_set\n     }\n }\n \n@@ -434,11 +494,7 @@ impl<'tcx> RegionDefinition<'tcx> {\n         // Create a new region definition. Note that, for free\n         // regions, these fields get updated later in\n         // `init_free_regions`.\n-        Self {\n-            origin,\n-            name: None,\n-            constant: false,\n-        }\n+        Self { origin, name: None }\n     }\n }\n "}, {"sha": "7039de727faa98b7b6b319bb12145e85ce9d3f65", "filename": "src/test/mir-opt/nll/named-lifetimes-basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs?ref=a96b0cf86df86c9b9f9bbc5a24d06e4304bc871d", "patch": "@@ -26,9 +26,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.use_x.nll.0.mir\n-// | '_#0r: {bb0[0], bb0[1], '_#0r, '_#1r, '_#2r, '_#3r}\n+// | '_#0r: {bb0[0], bb0[1], '_#0r}\n // | '_#1r: {bb0[0], bb0[1], '_#1r}\n-// | '_#2r: {bb0[0], bb0[1], '_#1r, '_#2r}\n+// | '_#2r: {bb0[0], bb0[1], '_#2r}\n // | '_#3r: {bb0[0], bb0[1], '_#3r}\n // fn use_x(_1: &'_#1r mut i32, _2: &'_#2r u32, _3: &'_#1r u32, _4: &'_#3r u32) -> bool {\n // END rustc.use_x.nll.0.mir"}]}