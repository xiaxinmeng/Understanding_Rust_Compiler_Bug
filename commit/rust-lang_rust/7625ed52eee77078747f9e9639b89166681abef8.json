{"sha": "7625ed52eee77078747f9e9639b89166681abef8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MjVlZDUyZWVlNzcwNzg3NDdmOWU5NjM5Yjg5MTY2NjgxYWJlZjg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T05:48:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T19:14:06Z"}, "message": "Remove vecs from std::sort", "tree": {"sha": "7a842c731963da6dffadbaf55bd0268bc9b872fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a842c731963da6dffadbaf55bd0268bc9b872fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7625ed52eee77078747f9e9639b89166681abef8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7625ed52eee77078747f9e9639b89166681abef8", "html_url": "https://github.com/rust-lang/rust/commit/7625ed52eee77078747f9e9639b89166681abef8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7625ed52eee77078747f9e9639b89166681abef8/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abf41e15ead7bcf4a4faff86b1f9dd2a07a64ef6", "url": "https://api.github.com/repos/rust-lang/rust/commits/abf41e15ead7bcf4a4faff86b1f9dd2a07a64ef6", "html_url": "https://github.com/rust-lang/rust/commit/abf41e15ead7bcf4a4faff86b1f9dd2a07a64ef6"}], "stats": {"total": 282, "additions": 57, "deletions": 225}, "files": [{"sha": "3d3a26bc228906ac3d5ec793868c924a79fe8b1b", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7625ed52eee77078747f9e9639b89166681abef8/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7625ed52eee77078747f9e9639b89166681abef8/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=7625ed52eee77078747f9e9639b89166681abef8", "patch": "@@ -155,7 +155,7 @@ fn sort_meta_items(items: &[@ast::meta_item]) -> [@ast::meta_item] {\n     let v: [mutable @ast::meta_item] = ~[mutable];\n     for mi: @ast::meta_item  in items { v += ~[mutable mi]; }\n \n-    std::sort::ivector::quick_sort(lteq, v);\n+    std::sort::quick_sort(lteq, v);\n \n     let v2: [@ast::meta_item] = ~[];\n     for mi: @ast::meta_item  in v { v2 += ~[mi]; }"}, {"sha": "de06f0114bc22aaf77a75ba9bab0e005ddef93b2", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7625ed52eee77078747f9e9639b89166681abef8/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7625ed52eee77078747f9e9639b89166681abef8/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=7625ed52eee77078747f9e9639b89166681abef8", "patch": "@@ -552,7 +552,7 @@ fn encode_crate_deps(ebml_w: &ebmlivec::writer, cstore: &cstore::cstore) {\n         fn lteq(kv1: &numname, kv2: &numname) -> bool {\n             kv1.crate <= kv2.crate\n         }\n-        std::sort::ivector::quick_sort(lteq, pairs);\n+        std::sort::quick_sort(lteq, pairs);\n \n         // Sanity-check the crate numbers\n         let expected_cnum = 1;"}, {"sha": "428fb20059ec623687360fb2fb04d423aedde2c4", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7625ed52eee77078747f9e9639b89166681abef8/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7625ed52eee77078747f9e9639b89166681abef8/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=7625ed52eee77078747f9e9639b89166681abef8", "patch": "@@ -460,7 +460,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n \n         // Sort and process all the methods.\n         let meths =\n-            std::sort::ivector::merge_sort[@ast::method]\n+            std::sort::merge_sort[@ast::method]\n             (bind ast_mthd_lteq(_, _), ob.methods);\n \n         for m: @ast::method in meths {\n@@ -504,7 +504,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n \n         // Sort all the methods and process them.\n         meths =\n-            std::sort::ivector::merge_sort[vtbl_mthd]\n+            std::sort::merge_sort[vtbl_mthd]\n             (bind vtbl_mthd_lteq(_, _), meths);\n \n         // To create forwarding methods, we'll need a \"backwarding\" vtbl.  See"}, {"sha": "c631e9bbd4add8ff70cc7cd1393787dbf69172f4", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7625ed52eee77078747f9e9639b89166681abef8/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7625ed52eee77078747f9e9639b89166681abef8/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=7625ed52eee77078747f9e9639b89166681abef8", "patch": "@@ -1991,7 +1991,7 @@ fn sort_methods(meths: &[method]) -> [method] {\n     fn method_lteq(a: &method, b: &method) -> bool {\n         ret str::lteq(a.ident, b.ident);\n     }\n-    ret std::sort::ivector::merge_sort[method](bind method_lteq(_, _), meths);\n+    ret std::sort::merge_sort[method](bind method_lteq(_, _), meths);\n }\n \n fn is_lval(expr: &@ast::expr) -> bool {"}, {"sha": "19242b74c742b9afd29f004d4a9581f287736aea", "filename": "src/lib/sort.rs", "status": "modified", "additions": 19, "deletions": 157, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/7625ed52eee77078747f9e9639b89166681abef8/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7625ed52eee77078747f9e9639b89166681abef8/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=7625ed52eee77078747f9e9639b89166681abef8", "patch": "@@ -1,28 +1,25 @@\n \n-import vec::len;\n-import vec::slice;\n-import ilen = ivec::len;\n-import islice = ivec::slice;\n-export ivector;\n-export lteq;\n+import ivec::len;\n+import ivec::slice;\n+\n export merge_sort;\n export quick_sort;\n export quick_sort3;\n \n type lteq[T] = block(&T, &T) -> bool ;\n \n-fn merge_sort[@T](le: &lteq[T], v: vec[T]) -> vec[T] {\n-    fn merge[@T](le: &lteq[T], a: vec[T], b: vec[T]) -> vec[T] {\n-        let rs: vec[T] = [];\n+fn merge_sort[@T](le: &lteq[T], v: &[T]) -> [T] {\n+    fn merge[@T](le: &lteq[T], a: &[T], b: &[T]) -> [T] {\n+        let rs: [T] = ~[];\n         let a_len: uint = len[T](a);\n         let a_ix: uint = 0u;\n         let b_len: uint = len[T](b);\n         let b_ix: uint = 0u;\n         while a_ix < a_len && b_ix < b_len {\n             if le(a.(a_ix), b.(b_ix)) {\n-                rs += [a.(a_ix)];\n+                rs += ~[a.(a_ix)];\n                 a_ix += 1u;\n-            } else { rs += [b.(b_ix)]; b_ix += 1u; }\n+            } else { rs += ~[b.(b_ix)]; b_ix += 1u; }\n         }\n         rs += slice[T](a, a_ix, a_len);\n         rs += slice[T](b, b_ix, b_len);\n@@ -31,18 +28,18 @@ fn merge_sort[@T](le: &lteq[T], v: vec[T]) -> vec[T] {\n     let v_len: uint = len[T](v);\n     if v_len <= 1u { ret v; }\n     let mid: uint = v_len / 2u;\n-    let a: vec[T] = slice[T](v, 0u, mid);\n-    let b: vec[T] = slice[T](v, mid, v_len);\n+    let a: [T] = slice[T](v, 0u, mid);\n+    let b: [T] = slice[T](v, mid, v_len);\n     ret merge[T](le, merge_sort[T](le, a), merge_sort[T](le, b));\n }\n \n-fn swap[@T](arr: vec[mutable T], x: uint, y: uint) {\n+fn swap[@T](arr: &[mutable T], x: uint, y: uint) {\n     let a = arr.(x);\n     arr.(x) = arr.(y);\n     arr.(y) = a;\n }\n \n-fn part[@T](compare_func: &lteq[T], arr: vec[mutable T], left: uint,\n+fn part[@T](compare_func: &lteq[T], arr: &[mutable T], left: uint,\n             right: uint, pivot: uint) -> uint {\n     let pivot_value = arr.(pivot);\n     swap[T](arr, pivot, right);\n@@ -59,7 +56,7 @@ fn part[@T](compare_func: &lteq[T], arr: vec[mutable T], left: uint,\n     ret storage_index;\n }\n \n-fn qsort[@T](compare_func: &lteq[T], arr: vec[mutable T], left: uint,\n+fn qsort[@T](compare_func: &lteq[T], arr: &[mutable T], left: uint,\n              right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -72,7 +69,7 @@ fn qsort[@T](compare_func: &lteq[T], arr: vec[mutable T], left: uint,\n     }\n }\n \n-fn quick_sort[@T](compare_func: &lteq[T], arr: vec[mutable T]) {\n+fn quick_sort[@T](compare_func: &lteq[T], arr: &[mutable T]) {\n     if len[T](arr) == 0u { ret; }\n     qsort[T](compare_func, arr, 0u, len[T](arr) - 1u);\n }\n@@ -83,7 +80,7 @@ fn quick_sort[@T](compare_func: &lteq[T], arr: vec[mutable T]) {\n // According to these slides this is the algorithm of choice for\n // 'randomly ordered keys, abstract compare' & 'small number of key values'\n fn qsort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n-             arr: vec[mutable T], left: int, right: int) {\n+              arr: &[mutable T], left: int, right: int) {\n     if right <= left { ret; }\n     let v: T = arr.(right);\n     let i: int = left - 1;\n@@ -117,7 +114,7 @@ fn qsort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n         swap[T](arr, k as uint, j as uint);\n         k += 1;\n         j -= 1;\n-        if k == vec::len[T](arr) as int { break; }\n+        if k == len[T](arr) as int { break; }\n     }\n     k = right - 1;\n     while k > q {\n@@ -131,145 +128,10 @@ fn qsort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n }\n \n fn quick_sort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n-                  arr: vec[mutable T]) {\n-    if vec::len[T](arr) == 0u { ret; }\n+                   arr: &[mutable T]) {\n+    if len[T](arr) == 0u { ret; }\n     qsort3[T](compare_func_lt, compare_func_eq, arr, 0,\n-              (vec::len[T](arr) as int) - 1);\n-}\n-\n-mod ivector {\n-    export merge_sort;\n-    export quick_sort;\n-    export quick_sort3;\n-\n-    type lteq[T] = fn(&T, &T) -> bool ;\n-\n-    fn merge_sort[@T](le: &lteq[T], v: &[T]) -> [T] {\n-        fn merge[@T](le: &lteq[T], a: &[T], b: &[T]) -> [T] {\n-            let rs: [T] = ~[];\n-            let a_len: uint = ilen[T](a);\n-            let a_ix: uint = 0u;\n-            let b_len: uint = ilen[T](b);\n-            let b_ix: uint = 0u;\n-            while a_ix < a_len && b_ix < b_len {\n-                if le(a.(a_ix), b.(b_ix)) {\n-                    rs += ~[a.(a_ix)];\n-                    a_ix += 1u;\n-                } else { rs += ~[b.(b_ix)]; b_ix += 1u; }\n-            }\n-            rs += islice[T](a, a_ix, a_len);\n-            rs += islice[T](b, b_ix, b_len);\n-            ret rs;\n-        }\n-        let v_len: uint = ilen[T](v);\n-        if v_len <= 1u { ret v; }\n-        let mid: uint = v_len / 2u;\n-        let a: [T] = islice[T](v, 0u, mid);\n-        let b: [T] = islice[T](v, mid, v_len);\n-        ret merge[T](le, merge_sort[T](le, a), merge_sort[T](le, b));\n-    }\n-\n-    fn swap[@T](arr: &[mutable T], x: uint, y: uint) {\n-        let a = arr.(x);\n-        arr.(x) = arr.(y);\n-        arr.(y) = a;\n-    }\n-\n-    fn part[@T](compare_func: &lteq[T], arr: &[mutable T], left: uint,\n-                right: uint, pivot: uint) -> uint {\n-        let pivot_value = arr.(pivot);\n-        swap[T](arr, pivot, right);\n-        let storage_index: uint = left;\n-        let i: uint = left;\n-        while i < right {\n-            if compare_func({ arr.(i) }, pivot_value) {\n-                swap[T](arr, i, storage_index);\n-                storage_index += 1u;\n-            }\n-            i += 1u;\n-        }\n-        swap[T](arr, storage_index, right);\n-        ret storage_index;\n-    }\n-\n-    fn qsort[@T](compare_func: &lteq[T], arr: &[mutable T], left: uint,\n-                 right: uint) {\n-        if right > left {\n-            let pivot = (left + right) / 2u;\n-            let new_pivot = part[T](compare_func, arr, left, right, pivot);\n-            if new_pivot != 0u {\n-                // Need to do this check before recursing due to overflow\n-                qsort[T](compare_func, arr, left, new_pivot - 1u);\n-            }\n-            qsort[T](compare_func, arr, new_pivot + 1u, right);\n-        }\n-    }\n-\n-    fn quick_sort[@T](compare_func: &lteq[T], arr: &[mutable T]) {\n-        if ilen[T](arr) == 0u { ret; }\n-        qsort[T](compare_func, arr, 0u, ilen[T](arr) - 1u);\n-    }\n-\n-\n-    // Based on algorithm presented by Sedgewick and Bentley here:\n-    // http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf\n-    // According to these slides this is the algorithm of choice for\n-    // 'randomly ordered keys, abstract compare' & 'small number of key\n-    // values'\n-    fn qsort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n-                  arr: &[mutable T], left: int, right: int) {\n-        if right <= left { ret; }\n-        let v: T = arr.(right);\n-        let i: int = left - 1;\n-        let j: int = right;\n-        let p: int = i;\n-        let q: int = j;\n-        while true {\n-            i += 1;\n-            while compare_func_lt({ arr.(i) }, v) { i += 1; }\n-            j -= 1;\n-            while compare_func_lt(v, { arr.(j) }) {\n-                if j == left { break; }\n-                j -= 1;\n-            }\n-            if i >= j { break; }\n-            swap[T](arr, i as uint, j as uint);\n-            if compare_func_eq({ arr.(i) }, v) {\n-                p += 1;\n-                swap[T](arr, p as uint, i as uint);\n-            }\n-            if compare_func_eq(v, { arr.(j) }) {\n-                q -= 1;\n-                swap[T](arr, j as uint, q as uint);\n-            }\n-        }\n-        swap[T](arr, i as uint, right as uint);\n-        j = i - 1;\n-        i += 1;\n-        let k: int = left;\n-        while k < p {\n-            swap[T](arr, k as uint, j as uint);\n-            k += 1;\n-            j -= 1;\n-            if k == ilen[T](arr) as int { break; }\n-        }\n-        k = right - 1;\n-        while k > q {\n-            swap[T](arr, i as uint, k as uint);\n-            k -= 1;\n-            i += 1;\n-            if k == 0 { break; }\n-        }\n-        qsort3[T](compare_func_lt, compare_func_eq, arr, left, j);\n-        qsort3[T](compare_func_lt, compare_func_eq, arr, i, right);\n-    }\n-\n-    fn quick_sort3[@T](compare_func_lt: &lteq[T], compare_func_eq: &lteq[T],\n-                       arr: &[mutable T]) {\n-        if ilen[T](arr) == 0u { ret; }\n-        qsort3[T](compare_func_lt, compare_func_eq, arr, 0,\n-                  (ilen[T](arr) as int) - 1);\n-    }\n+              (len[T](arr) as int) - 1);\n }\n \n // Local Variables:"}, {"sha": "de6a4555cf1563e5b8944224ec384f0433a1a38e", "filename": "src/lib/test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7625ed52eee77078747f9e9639b89166681abef8/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7625ed52eee77078747f9e9639b89166681abef8/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=7625ed52eee77078747f9e9639b89166681abef8", "patch": "@@ -3,7 +3,6 @@\n // simplest interface possible for representing and running tests\n // while providing a base that other test frameworks may build off of.\n \n-import sort = sort::ivector;\n import generic_os::getenv;\n \n export test_name;"}, {"sha": "0799f505e3cb74c95272fba4a6b6ba67273bb059", "filename": "src/test/stdtest/qsort.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7625ed52eee77078747f9e9639b89166681abef8/src%2Ftest%2Fstdtest%2Fqsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7625ed52eee77078747f9e9639b89166681abef8/src%2Ftest%2Fstdtest%2Fqsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort.rs?ref=7625ed52eee77078747f9e9639b89166681abef8", "patch": "@@ -5,8 +5,8 @@ import std::sort;\n import std::ivec;\n import std::int;\n \n-fn check_sort(v1: vec[mutable int], v2: vec[mutable int]) {\n-    let len = std::vec::len[int](v1);\n+fn check_sort(v1: &[mutable int], v2: &[mutable int]) {\n+    let len = std::ivec::len[int](v1);\n     fn ltequal(a: &int, b: &int) -> bool { ret a <= b; }\n     let f = ltequal;\n     std::sort::quick_sort[int](f, v1);\n@@ -17,24 +17,24 @@ fn check_sort(v1: vec[mutable int], v2: vec[mutable int]) {\n #[test]\n fn test() {\n     {\n-        let v1 = [mutable 3, 7, 4, 5, 2, 9, 5, 8];\n-        let v2 = [mutable 2, 3, 4, 5, 5, 7, 8, 9];\n+        let v1 = ~[mutable 3, 7, 4, 5, 2, 9, 5, 8];\n+        let v2 = ~[mutable 2, 3, 4, 5, 5, 7, 8, 9];\n         check_sort(v1, v2);\n     }\n     {\n-        let v1 = [mutable 1, 1, 1];\n-        let v2 = [mutable 1, 1, 1];\n+        let v1 = ~[mutable 1, 1, 1];\n+        let v2 = ~[mutable 1, 1, 1];\n         check_sort(v1, v2);\n     }\n     {\n-        let v1: vec[mutable int] = [mutable ];\n-        let v2: vec[mutable int] = [mutable ];\n+        let v1: [mutable int] = ~[mutable ];\n+        let v2: [mutable int] = ~[mutable ];\n         check_sort(v1, v2);\n     }\n-    { let v1 = [mutable 9]; let v2 = [mutable 9]; check_sort(v1, v2); }\n+    { let v1 = ~[mutable 9]; let v2 = ~[mutable 9]; check_sort(v1, v2); }\n     {\n-        let v1 = [mutable 9, 3, 3, 3, 9];\n-        let v2 = [mutable 3, 3, 3, 9, 9];\n+        let v1 = ~[mutable 9, 3, 3, 3, 9];\n+        let v2 = ~[mutable 3, 3, 3, 9, 9];\n         check_sort(v1, v2);\n     }\n }\n@@ -47,7 +47,7 @@ fn test_simple() {\n     let expected = ~[1, 2, 3];\n \n     fn lteq(a: &int, b: &int) -> bool { int::le(a, b) }\n-    sort::ivector::quick_sort(lteq, names);\n+    sort::quick_sort(lteq, names);\n \n     let pairs = ivec::zip(expected, ivec::from_mut(names));\n     for p: {_0: int, _1: int}  in pairs {"}, {"sha": "fe871ceda211e75346ce47ae31155937a0e5764d", "filename": "src/test/stdtest/qsort3.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7625ed52eee77078747f9e9639b89166681abef8/src%2Ftest%2Fstdtest%2Fqsort3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7625ed52eee77078747f9e9639b89166681abef8/src%2Ftest%2Fstdtest%2Fqsort3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort3.rs?ref=7625ed52eee77078747f9e9639b89166681abef8", "patch": "@@ -1,8 +1,8 @@\n \n use std;\n \n-fn check_sort(v1: vec[mutable int], v2: vec[mutable int]) {\n-    let len = std::vec::len[int](v1);\n+fn check_sort(v1: &[mutable int], v2: &[mutable int]) {\n+    let len = std::ivec::len[int](v1);\n     fn lt(a: &int, b: &int) -> bool { ret a < b; }\n     fn equal(a: &int, b: &int) -> bool { ret a == b; }\n     let f1 = lt;\n@@ -15,24 +15,24 @@ fn check_sort(v1: vec[mutable int], v2: vec[mutable int]) {\n #[test]\n fn test() {\n     {\n-        let v1 = [mutable 3, 7, 4, 5, 2, 9, 5, 8];\n-        let v2 = [mutable 2, 3, 4, 5, 5, 7, 8, 9];\n+        let v1 = ~[mutable 3, 7, 4, 5, 2, 9, 5, 8];\n+        let v2 = ~[mutable 2, 3, 4, 5, 5, 7, 8, 9];\n         check_sort(v1, v2);\n     }\n     {\n-        let v1 = [mutable 1, 1, 1];\n-        let v2 = [mutable 1, 1, 1];\n+        let v1 = ~[mutable 1, 1, 1];\n+        let v2 = ~[mutable 1, 1, 1];\n         check_sort(v1, v2);\n     }\n     {\n-        let v1: vec[mutable int] = [mutable ];\n-        let v2: vec[mutable int] = [mutable ];\n+        let v1: [mutable int] = ~[mutable ];\n+        let v2: [mutable int] = ~[mutable ];\n         check_sort(v1, v2);\n     }\n-    { let v1 = [mutable 9]; let v2 = [mutable 9]; check_sort(v1, v2); }\n+    { let v1 = ~[mutable 9]; let v2 = ~[mutable 9]; check_sort(v1, v2); }\n     {\n-        let v1 = [mutable 9, 3, 3, 3, 9];\n-        let v2 = [mutable 3, 3, 3, 9, 9];\n+        let v1 = ~[mutable 9, 3, 3, 3, 9];\n+        let v2 = ~[mutable 3, 3, 3, 9, 9];\n         check_sort(v1, v2);\n     }\n }"}, {"sha": "eac5204cde3e5a9e2d68d2301585e1c93531e32a", "filename": "src/test/stdtest/sort.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7625ed52eee77078747f9e9639b89166681abef8/src%2Ftest%2Fstdtest%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7625ed52eee77078747f9e9639b89166681abef8/src%2Ftest%2Fstdtest%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsort.rs?ref=7625ed52eee77078747f9e9639b89166681abef8", "patch": "@@ -1,8 +1,8 @@\n \n use std;\n \n-fn check_sort(v1: vec[int], v2: vec[int]) {\n-    let len = std::vec::len[int](v1);\n+fn check_sort(v1: &[int], v2: &[int]) {\n+    let len = std::ivec::len[int](v1);\n     fn lteq(a: &int, b: &int) -> bool { ret a <= b; }\n     let f = lteq;\n     let v3 = std::sort::merge_sort[int](f, v1);\n@@ -13,16 +13,16 @@ fn check_sort(v1: vec[int], v2: vec[int]) {\n #[test]\n fn test() {\n     {\n-        let v1 = [3, 7, 4, 5, 2, 9, 5, 8];\n-        let v2 = [2, 3, 4, 5, 5, 7, 8, 9];\n+        let v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+        let v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n         check_sort(v1, v2);\n     }\n-    { let v1 = [1, 1, 1]; let v2 = [1, 1, 1]; check_sort(v1, v2); }\n-    { let v1: vec[int] = []; let v2: vec[int] = []; check_sort(v1, v2); }\n-    { let v1 = [9]; let v2 = [9]; check_sort(v1, v2); }\n+    { let v1 = ~[1, 1, 1]; let v2 = ~[1, 1, 1]; check_sort(v1, v2); }\n+    { let v1: [int] = ~[]; let v2: [int] = ~[]; check_sort(v1, v2); }\n+    { let v1 = ~[9]; let v2 = ~[9]; check_sort(v1, v2); }\n     {\n-        let v1 = [9, 3, 3, 3, 9];\n-        let v2 = [3, 3, 3, 9, 9];\n+        let v1 = ~[9, 3, 3, 3, 9];\n+        let v2 = ~[3, 3, 3, 9, 9];\n         check_sort(v1, v2);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3e52de4ad2e74eda68f372b11048999c39c4b41f", "filename": "src/test/stdtest/sort_ivec.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/abf41e15ead7bcf4a4faff86b1f9dd2a07a64ef6/src%2Ftest%2Fstdtest%2Fsort_ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf41e15ead7bcf4a4faff86b1f9dd2a07a64ef6/src%2Ftest%2Fstdtest%2Fsort_ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsort_ivec.rs?ref=abf41e15ead7bcf4a4faff86b1f9dd2a07a64ef6", "patch": "@@ -1,28 +0,0 @@\n-\n-use std;\n-\n-fn check_sort(v1: &[int], v2: &[int]) {\n-    let len = std::ivec::len[int](v1);\n-    fn lteq(a: &int, b: &int) -> bool { ret a <= b; }\n-    let f = lteq;\n-    let v3 = std::sort::ivector::merge_sort[int](f, v1);\n-    let i = 0u;\n-    while i < len { log v3.(i); assert (v3.(i) == v2.(i)); i += 1u; }\n-}\n-\n-#[test]\n-fn test() {\n-    {\n-        let v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n-        let v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n-        check_sort(v1, v2);\n-    }\n-    { let v1 = ~[1, 1, 1]; let v2 = ~[1, 1, 1]; check_sort(v1, v2); }\n-    { let v1: [int] = ~[]; let v2: [int] = ~[]; check_sort(v1, v2); }\n-    { let v1 = ~[9]; let v2 = ~[9]; check_sort(v1, v2); }\n-    {\n-        let v1 = ~[9, 3, 3, 3, 9];\n-        let v2 = ~[3, 3, 3, 9, 9];\n-        check_sort(v1, v2);\n-    }\n-}"}, {"sha": "401587ed36ed5ba9a4c1a1b50148b04637d0b725", "filename": "src/test/stdtest/stdtest.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7625ed52eee77078747f9e9639b89166681abef8/src%2Ftest%2Fstdtest%2Fstdtest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7625ed52eee77078747f9e9639b89166681abef8/src%2Ftest%2Fstdtest%2Fstdtest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstdtest.rc?ref=7625ed52eee77078747f9e9639b89166681abef8", "patch": "@@ -21,7 +21,6 @@ mod qsort;\n mod rand;\n mod run;\n mod sha1;\n-mod sort_ivec;\n mod sort;\n mod str_buf;\n mod str;"}]}