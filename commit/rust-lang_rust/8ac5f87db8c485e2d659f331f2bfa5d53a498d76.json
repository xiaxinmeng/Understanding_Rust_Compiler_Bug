{"sha": "8ac5f87db8c485e2d659f331f2bfa5d53a498d76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYzVmODdkYjhjNDg1ZTJkNjU5ZjMzMWYyYmZhNWQ1M2E0OThkNzY=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-02-09T20:27:42Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-02-12T18:28:42Z"}, "message": "Autoderef in librustc_resolve", "tree": {"sha": "d81046bb46e57dbc5ef9a2a4d713ee9afc9bdca8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d81046bb46e57dbc5ef9a2a4d713ee9afc9bdca8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ac5f87db8c485e2d659f331f2bfa5d53a498d76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac5f87db8c485e2d659f331f2bfa5d53a498d76", "html_url": "https://github.com/rust-lang/rust/commit/8ac5f87db8c485e2d659f331f2bfa5d53a498d76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ac5f87db8c485e2d659f331f2bfa5d53a498d76/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1", "html_url": "https://github.com/rust-lang/rust/commit/93e58cc28fdc978cbc967b131a7ec04bc2a90bb1"}], "stats": {"total": 80, "additions": 40, "deletions": 40}, "files": [{"sha": "f0e4d7578e373e6f4044f0db32a6ff0dadd352a0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5f87db8c485e2d659f331f2bfa5d53a498d76/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5f87db8c485e2d659f331f2bfa5d53a498d76/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8ac5f87db8c485e2d659f331f2bfa5d53a498d76", "patch": "@@ -438,25 +438,25 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                                 help_msg = format!(\"To reference an item from the \\\n                                                     `{module}` module, use \\\n                                                     `{module}::{ident}`\",\n-                                                   module = &*path,\n+                                                   module = path,\n                                                    ident = ident.node);\n                             }\n                             ExprMethodCall(ident, _, _) => {\n                                 help_msg = format!(\"To call a function from the \\\n                                                     `{module}` module, use \\\n                                                     `{module}::{ident}(..)`\",\n-                                                   module = &*path,\n+                                                   module = path,\n                                                    ident = ident.node);\n                             }\n                             ExprCall(_, _) => {\n                                 help_msg = format!(\"No function corresponds to `{module}(..)`\",\n-                                                   module = &*path);\n+                                                   module = path);\n                             }\n                             _ => { } // no help available\n                         }\n                     } else {\n                         help_msg = format!(\"Module `{module}` cannot be the value of an expression\",\n-                                           module = &*path);\n+                                           module = path);\n                     }\n \n                     if !help_msg.is_empty() {\n@@ -577,7 +577,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n         self.resolve_expr(expr);\n     }\n     fn visit_local(&mut self, local: &Local) {\n-        execute_callback!(hir_map::Node::NodeLocal(&*local.pat), self);\n+        execute_callback!(hir_map::Node::NodeLocal(&local.pat), self);\n         self.resolve_local(local);\n     }\n     fn visit_ty(&mut self, ty: &Ty) {\n@@ -1331,8 +1331,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         match search_parent_externals(name, &self.current_module) {\n                             Some(module) => {\n                                 let path_str = names_to_string(module_path);\n-                                let target_mod_str = module_to_string(&*module);\n-                                let current_mod_str = module_to_string(&*self.current_module);\n+                                let target_mod_str = module_to_string(&module);\n+                                let current_mod_str = module_to_string(&self.current_module);\n \n                                 let prefix = if target_mod_str == current_mod_str {\n                                     \"self::\".to_string()\n@@ -1400,7 +1400,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"(resolving module path for import) processing `{}` rooted at `{}`\",\n                names_to_string(module_path),\n-               module_to_string(&*module_));\n+               module_to_string(&module_));\n \n         // Resolve the module prefix, if any.\n         let module_prefix_result = self.resolve_module_prefix(module_, module_path);\n@@ -1494,15 +1494,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in namespace {:?} in `{}`\",\n                name,\n                namespace,\n-               module_to_string(&*module_));\n+               module_to_string(&module_));\n \n         // Proceed up the scope chain looking for parent modules.\n         let mut search_module = module_;\n         loop {\n             // Resolve the name in the parent module.\n             match self.resolve_name_in_module(search_module, name, namespace, true, record_used) {\n                 Failed(Some((span, msg))) => {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n@@ -1592,7 +1592,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Now loop through all the `super`s we find.\n         while i < module_path.len() && \"super\" == module_path[i].as_str() {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n-                   module_to_string(&*containing_module));\n+                   module_to_string(&containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n                 None => return Failed(None),\n                 Some(new_module) => {\n@@ -1603,7 +1603,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         debug!(\"(resolving module prefix) finished resolving prefix at {}\",\n-               module_to_string(&*containing_module));\n+               module_to_string(&containing_module));\n \n         return Success(PrefixFound(containing_module, i));\n     }\n@@ -1770,7 +1770,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ItemImpl(_, _, ref generics, ref opt_trait_ref, ref self_type, ref impl_items) => {\n                 self.resolve_implementation(generics,\n                                             opt_trait_ref,\n-                                            &**self_type,\n+                                            &self_type,\n                                             item.id,\n                                             impl_items);\n             }\n@@ -1965,9 +1965,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Add each argument to the rib.\n         let mut bindings_list = HashMap::new();\n         for argument in &declaration.inputs {\n-            self.resolve_pattern(&*argument.pat, ArgumentIrrefutableMode, &mut bindings_list);\n+            self.resolve_pattern(&argument.pat, ArgumentIrrefutableMode, &mut bindings_list);\n \n-            self.visit_ty(&*argument.ty);\n+            self.visit_ty(&argument.ty);\n \n             debug!(\"(resolving function) recorded argument\");\n         }\n@@ -1997,7 +1997,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let mut err =\n                     resolve_struct_error(self,\n                                   trait_path.span,\n-                                  ResolutionError::IsNotATrait(&*path_names_to_string(trait_path,\n+                                  ResolutionError::IsNotATrait(&path_names_to_string(trait_path,\n                                                                                       path_depth)));\n \n                 // If it's a typedef, give a note\n@@ -2011,7 +2011,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         } else {\n             resolve_error(self,\n                           trait_path.span,\n-                          ResolutionError::UndeclaredTraitName(&*path_names_to_string(trait_path,\n+                          ResolutionError::UndeclaredTraitName(&path_names_to_string(trait_path,\n                                                                                       path_depth)));\n             Err(())\n         }\n@@ -2165,7 +2165,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if !self.trait_item_map.contains_key(&(name, did)) {\n                 let path_str = path_names_to_string(&trait_ref.path, 0);\n-                resolve_error(self, span, err(name, &*path_str));\n+                resolve_error(self, span, err(name, &path_str));\n             }\n         }\n     }\n@@ -2178,7 +2178,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n-        self.resolve_pattern(&*local.pat, LocalIrrefutableMode, &mut HashMap::new());\n+        self.resolve_pattern(&local.pat, LocalIrrefutableMode, &mut HashMap::new());\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n@@ -2204,9 +2204,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if arm.pats.is_empty() {\n             return;\n         }\n-        let map_0 = self.binding_mode_map(&*arm.pats[0]);\n+        let map_0 = self.binding_mode_map(&arm.pats[0]);\n         for (i, p) in arm.pats.iter().enumerate() {\n-            let map_i = self.binding_mode_map(&**p);\n+            let map_i = self.binding_mode_map(&p);\n \n             for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n@@ -2241,15 +2241,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let mut bindings_list = HashMap::new();\n         for pattern in &arm.pats {\n-            self.resolve_pattern(&**pattern, RefutableMode, &mut bindings_list);\n+            self.resolve_pattern(&pattern, RefutableMode, &mut bindings_list);\n         }\n \n         // This has to happen *after* we determine which\n         // pat_idents are variants\n         self.check_consistent_bindings(arm);\n \n         walk_list!(self, visit_expr, &arm.guard);\n-        self.visit_expr(&*arm.body);\n+        self.visit_expr(&arm.body);\n \n         if !self.resolved {\n             self.value_ribs.pop();\n@@ -2340,7 +2340,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                           ty.span,\n                                           ResolutionError::UseOfUndeclared(\n                                                                     kind,\n-                                                                    &*path_names_to_string(path,\n+                                                                    &path_names_to_string(path,\n                                                                                            0))\n                                          );\n                         }\n@@ -2616,7 +2616,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self,\n                                 path.span,\n                                 ResolutionError::DoesNotNameAStruct(\n-                                    &*path_names_to_string(path, 0))\n+                                    &path_names_to_string(path, 0))\n                             );\n                             self.record_def(pattern.id, err_path_resolution());\n                         }\n@@ -2672,7 +2672,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) => {\n-                        resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                        resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                     }\n                     None => (),\n                 }\n@@ -2804,7 +2804,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n             Success(binding) => binding.def().map(LocalDef::from_def),\n             Failed(Some((span, msg))) => {\n-                resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 None\n             }\n             _ => None,\n@@ -2927,7 +2927,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 return None;\n             }\n             Indeterminate => return None,\n@@ -2982,7 +2982,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 return None;\n             }\n \n@@ -3064,8 +3064,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     -> Option<(Path, NodeId, FallbackChecks)> {\n             match t.node {\n                 TyPath(None, ref path) => Some((path.clone(), t.id, allow)),\n-                TyPtr(ref mut_ty) => extract_path_and_node_id(&*mut_ty.ty, OnlyTraitAndStatics),\n-                TyRptr(_, ref mut_ty) => extract_path_and_node_id(&*mut_ty.ty, allow),\n+                TyPtr(ref mut_ty) => extract_path_and_node_id(&mut_ty.ty, OnlyTraitAndStatics),\n+                TyRptr(_, ref mut_ty) => extract_path_and_node_id(&mut_ty.ty, allow),\n                 // This doesn't handle the remaining `Ty` variants as they are not\n                 // that commonly the self_type, it might be interesting to provide\n                 // support for those in future.\n@@ -3183,7 +3183,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     .flat_map(|rib| rib.bindings.keys());\n \n         if let Some(found) = find_best_match_for_name(names, name, None) {\n-            if name != &*found {\n+            if name != found {\n                 return SuggestionType::Function(found);\n             }\n         } SuggestionType::NotFound\n@@ -3229,7 +3229,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                         let mut err = resolve_struct_error(self,\n                                         expr.span,\n-                                        ResolutionError::StructVariantUsedAsFunction(&*path_name));\n+                                        ResolutionError::StructVariantUsedAsFunction(&path_name));\n \n                         let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                           path_name);\n@@ -3270,7 +3270,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         Some(Def::Struct(..)) => {\n                             let mut err = resolve_struct_error(self,\n                                 expr.span,\n-                                ResolutionError::StructVariantUsedAsFunction(&*path_name));\n+                                ResolutionError::StructVariantUsedAsFunction(&path_name));\n \n                             let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                               path_name);\n@@ -3346,7 +3346,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 resolve_error(self,\n                                               expr.span,\n                                               ResolutionError::UnresolvedName(\n-                                                  &*path_name, &*msg, context));\n+                                                  &path_name, &msg, context));\n                             }\n                         }\n                     }\n@@ -3367,7 +3367,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         resolve_error(self,\n                                       path.span,\n                                       ResolutionError::DoesNotNameAStruct(\n-                                                                &*path_names_to_string(path, 0))\n+                                                                &path_names_to_string(path, 0))\n                                      );\n                         self.record_def(expr.id, err_path_resolution());\n                     }"}, {"sha": "f21ffb9b9a16d61d1d42b800e1c405a1044a026d", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ac5f87db8c485e2d659f331f2bfa5d53a498d76/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac5f87db8c485e2d659f331f2bfa5d53a498d76/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8ac5f87db8c485e2d659f331f2bfa5d53a498d76", "patch": "@@ -238,7 +238,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                           -> Vec<ImportResolvingError<'b>> {\n         let mut errors = Vec::new();\n         debug!(\"(resolving imports for module subtree) resolving {}\",\n-               module_to_string(&*module_));\n+               module_to_string(&module_));\n         let orig_module = replace(&mut self.resolver.current_module, module_);\n         errors.extend(self.resolve_imports_for_module(module_));\n         self.resolver.current_module = orig_module;\n@@ -268,7 +268,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         if module.all_imports_resolved() {\n             debug!(\"(resolving imports for module) all imports resolved for {}\",\n-                   module_to_string(&*module));\n+                   module_to_string(&module));\n             return errors;\n         }\n \n@@ -320,7 +320,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                  -> ResolveResult<()> {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                names_to_string(&import_directive.module_path),\n-               module_to_string(&*module_));\n+               module_to_string(&module_));\n \n         self.resolver\n             .resolve_module_path(module_,\n@@ -370,7 +370,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from `{}` id {}, last \\\n                 private {:?}\",\n                target,\n-               module_to_string(&*target_module),\n+               module_to_string(&target_module),\n                source,\n                module_to_string(module_),\n                directive.id,"}]}