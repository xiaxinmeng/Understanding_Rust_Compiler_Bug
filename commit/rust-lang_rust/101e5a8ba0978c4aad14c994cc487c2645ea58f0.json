{"sha": "101e5a8ba0978c4aad14c994cc487c2645ea58f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMWU1YThiYTA5NzhjNGFhZDE0Yzk5NGNjNDg3YzI2NDVlYTU4ZjA=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-20T11:11:40Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-20T11:11:40Z"}, "message": "Move rustc tests from tests to a binary, since they are only run manually anyway", "tree": {"sha": "b4b015a7e550cd922fece0e4f495f41b6b0fbf95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4b015a7e550cd922fece0e4f495f41b6b0fbf95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/101e5a8ba0978c4aad14c994cc487c2645ea58f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/101e5a8ba0978c4aad14c994cc487c2645ea58f0", "html_url": "https://github.com/rust-lang/rust/commit/101e5a8ba0978c4aad14c994cc487c2645ea58f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/101e5a8ba0978c4aad14c994cc487c2645ea58f0/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e38ee0a30a3775f69ca5e98f680b724072c809fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e38ee0a30a3775f69ca5e98f680b724072c809fa", "html_url": "https://github.com/rust-lang/rust/commit/e38ee0a30a3775f69ca5e98f680b724072c809fa"}], "stats": {"total": 694, "additions": 532, "deletions": 162}, "files": [{"sha": "354aedcae088af51f40c2db177c1ce2627e16423", "filename": "rustc_tests/Cargo.lock", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/101e5a8ba0978c4aad14c994cc487c2645ea58f0/rustc_tests%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/101e5a8ba0978c4aad14c994cc487c2645ea58f0/rustc_tests%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tests%2FCargo.lock?ref=101e5a8ba0978c4aad14c994cc487c2645ea58f0", "patch": "@@ -0,0 +1,246 @@\n+[root]\n+name = \"rustc_tests\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"miri 0.1.0\",\n+]\n+\n+[[package]]\n+name = \"aho-corasick\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"byteorder\"\n+version = \"1.1.0\"\n+source = \"git+https://github.com/BurntSushi/byteorder#88f0b9851e9824d54248b862b20fe28415a30ec0\"\n+\n+[[package]]\n+name = \"cargo_metadata\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"dtoa\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"env_logger\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"itoa\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"kernel32-sys\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"lazy_static\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.26\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"log\"\n+version = \"0.3.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"log_settings\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"memchr\"\n+version = \"0.1.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"miri\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"byteorder 1.1.0 (git+https://github.com/BurntSushi/byteorder)\",\n+ \"cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"num-traits\"\n+version = \"0.1.40\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"quote\"\n+version = \"0.3.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"regex\"\n+version = \"0.1.80\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"regex-syntax\"\n+version = \"0.3.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"serde\"\n+version = \"1.0.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"serde_derive_internals\"\n+version = \"0.15.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"0.11.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"synom\"\n+version = \"0.11.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"thread-id\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.26 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"thread_local\"\n+version = \"0.2.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"utf8-ranges\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[metadata]\n+\"checksum aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca972c2ea5f742bfce5687b9aef75506a764f61d37f8f649047846a9686ddb66\"\n+\"checksum byteorder 1.1.0 (git+https://github.com/BurntSushi/byteorder)\" = \"<none>\"\n+\"checksum cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be1057b8462184f634c3a208ee35b0f935cfd94b694b26deadccd98732088d7b\"\n+\"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n+\"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n+\"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n+\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n+\"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n+\"checksum libc 0.2.26 (registry+https://github.com/rust-lang/crates.io-index)\" = \"30885bcb161cf67054244d10d4a7f4835ffd58773bc72e07d35fecf472295503\"\n+\"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b\"\n+\"checksum log_settings 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3d382732ea0fbc09790c4899db3255bdea0fc78b54bf234bd18a63bb603915b6\"\n+\"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n+\"checksum num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99843c856d68d8b4313b03a17e33c4bb42ae8f6610ea81b28abe076ac721b9b0\"\n+\"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n+\"checksum regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4fd4ace6a8cf7860714a2c2280d6c1f7e6a413486c13298bbc86fd3da019402f\"\n+\"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n+\"checksum serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"433d7d9f8530d5a939ad5e0e72a6243d2e42a24804f70bf592c679363dcacb2f\"\n+\"checksum serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7b707cf0d4cab852084f573058def08879bb467fda89d99052485e7d00edd624\"\n+\"checksum serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"37aee4e0da52d801acfbc0cc219eb1eda7142112339726e427926a6f6ee65d3a\"\n+\"checksum serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48b04779552e92037212c3615370f6bd57a40ebba7f20e554ff9f55e41a69a7b\"\n+\"checksum syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad\"\n+\"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n+\"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n+\"checksum thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8576dbbfcaef9641452d5cf0df9b0e7eeab7694956dd33bb61515fb8f18cfdd5\"\n+\"checksum unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f860d7d29cf02cb2f3f359fd35991af3d30bac52c57d265a3c461074cb4dc\"\n+\"checksum utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1ca13c08c41c9c3e04224ed9ff80461d97e121589ff27c753a16cb10830ae0f\"\n+\"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n+\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "736f0629768f28cee37b812a3071ed2dedf7befa", "filename": "rustc_tests/Cargo.toml", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/101e5a8ba0978c4aad14c994cc487c2645ea58f0/rustc_tests%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/101e5a8ba0978c4aad14c994cc487c2645ea58f0/rustc_tests%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tests%2FCargo.toml?ref=101e5a8ba0978c4aad14c994cc487c2645ea58f0", "patch": "@@ -0,0 +1,7 @@\n+[package]\n+name = \"rustc_tests\"\n+version = \"0.1.0\"\n+authors = [\"Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de>\"]\n+\n+[dependencies]\n+miri = { path = \"..\" }"}, {"sha": "551a0f1fcb31380ce785a13d1b7e0f4d15d477c1", "filename": "rustc_tests/src/main.rs", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/101e5a8ba0978c4aad14c994cc487c2645ea58f0/rustc_tests%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101e5a8ba0978c4aad14c994cc487c2645ea58f0/rustc_tests%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustc_tests%2Fsrc%2Fmain.rs?ref=101e5a8ba0978c4aad14c994cc487c2645ea58f0", "patch": "@@ -0,0 +1,279 @@\n+#![feature(rustc_private, i128_type)]\n+extern crate miri;\n+extern crate getopts;\n+extern crate rustc;\n+extern crate rustc_driver;\n+extern crate rustc_errors;\n+extern crate syntax;\n+\n+use std::path::{PathBuf, Path};\n+use std::io::Write;\n+use std::sync::{Mutex, Arc};\n+use std::io;\n+\n+\n+use rustc::session::Session;\n+use rustc_driver::{Compilation, CompilerCalls, RustcDefaultCalls};\n+use rustc_driver::driver::{CompileState, CompileController};\n+use rustc::session::config::{self, Input, ErrorOutputType};\n+use rustc::hir::{self, itemlikevisit};\n+use rustc::ty::TyCtxt;\n+use syntax::ast;\n+\n+struct MiriCompilerCalls(RustcDefaultCalls);\n+\n+impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n+    fn early_callback(\n+        &mut self,\n+        matches: &getopts::Matches,\n+        sopts: &config::Options,\n+        cfg: &ast::CrateConfig,\n+        descriptions: &rustc_errors::registry::Registry,\n+        output: ErrorOutputType\n+    ) -> Compilation {\n+        self.0.early_callback(matches, sopts, cfg, descriptions, output)\n+    }\n+    fn no_input(\n+        &mut self,\n+        matches: &getopts::Matches,\n+        sopts: &config::Options,\n+        cfg: &ast::CrateConfig,\n+        odir: &Option<PathBuf>,\n+        ofile: &Option<PathBuf>,\n+        descriptions: &rustc_errors::registry::Registry\n+    ) -> Option<(Input, Option<PathBuf>)> {\n+        self.0.no_input(matches, sopts, cfg, odir, ofile, descriptions)\n+    }\n+    fn late_callback(\n+        &mut self,\n+        matches: &getopts::Matches,\n+        sess: &Session,\n+        input: &Input,\n+        odir: &Option<PathBuf>,\n+        ofile: &Option<PathBuf>\n+    ) -> Compilation {\n+        self.0.late_callback(matches, sess, input, odir, ofile)\n+    }\n+    fn build_controller(&mut self, sess: &Session, matches: &getopts::Matches) -> CompileController<'a> {\n+        let mut control = self.0.build_controller(sess, matches);\n+        control.after_hir_lowering.callback = Box::new(after_hir_lowering);\n+        control.after_analysis.callback = Box::new(after_analysis);\n+        if std::env::var(\"MIRI_HOST_TARGET\") != Ok(\"yes\".to_owned()) {\n+            // only fully compile targets on the host\n+            control.after_analysis.stop = Compilation::Stop;\n+        }\n+        control\n+    }\n+}\n+\n+fn after_hir_lowering(state: &mut CompileState) {\n+    let attr = (String::from(\"miri\"), syntax::feature_gate::AttributeType::Whitelisted);\n+    state.session.plugin_attributes.borrow_mut().push(attr);\n+}\n+\n+fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n+    state.session.abort_if_errors();\n+\n+    let tcx = state.tcx.unwrap();\n+    let limits = Default::default();\n+\n+    if std::env::args().any(|arg| arg == \"--test\") {\n+        struct Visitor<'a, 'tcx: 'a>(miri::ResourceLimits, TyCtxt<'a, 'tcx, 'tcx>, &'a CompileState<'a, 'tcx>);\n+        impl<'a, 'tcx: 'a, 'hir> itemlikevisit::ItemLikeVisitor<'hir> for Visitor<'a, 'tcx> {\n+            fn visit_item(&mut self, i: &'hir hir::Item) {\n+                if let hir::Item_::ItemFn(_, _, _, _, _, body_id) = i.node {\n+                    if i.attrs.iter().any(|attr| attr.name().map_or(false, |n| n == \"test\")) {\n+                        let did = self.1.hir.body_owner_def_id(body_id);\n+                        println!(\"running test: {}\", self.1.hir.def_path(did).to_string(self.1));\n+                        miri::eval_main(self.1, did, None, self.0);\n+                        self.2.session.abort_if_errors();\n+                    }\n+                }\n+            }\n+            fn visit_trait_item(&mut self, _trait_item: &'hir hir::TraitItem) {}\n+            fn visit_impl_item(&mut self, _impl_item: &'hir hir::ImplItem) {}\n+        }\n+        state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(limits, tcx, state));\n+    } else if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n+        let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n+        let start_wrapper = tcx.lang_items.start_fn().and_then(|start_fn|\n+                                if tcx.is_mir_available(start_fn) { Some(start_fn) } else { None });\n+        miri::eval_main(tcx, entry_def_id, start_wrapper, limits);\n+\n+        state.session.abort_if_errors();\n+    } else {\n+        println!(\"no main function found, assuming auxiliary build\");\n+    }\n+}\n+\n+fn main() {\n+    let path = option_env!(\"MIRI_RUSTC_TEST\")\n+        .map(String::from)\n+        .unwrap_or_else(|| {\n+            std::env::var(\"MIRI_RUSTC_TEST\")\n+                .expect(\"need to set MIRI_RUSTC_TEST to path of rustc tests\")\n+        });\n+\n+    let mut mir_not_found = Vec::new();\n+    let mut crate_not_found = Vec::new();\n+    let mut success = 0;\n+    let mut failed = Vec::new();\n+    let mut c_abi_fns = Vec::new();\n+    let mut abi = Vec::new();\n+    let mut unsupported = Vec::new();\n+    let mut unimplemented_intrinsic = Vec::new();\n+    let mut limits = Vec::new();\n+    let mut files: Vec<_> = std::fs::read_dir(path).unwrap().collect();\n+    while let Some(file) = files.pop() {\n+        let file = file.unwrap();\n+        let path = file.path();\n+        if file.metadata().unwrap().is_dir() {\n+            if !path.to_str().unwrap().ends_with(\"auxiliary\") {\n+                // add subdirs recursively\n+                files.extend(std::fs::read_dir(path).unwrap());\n+            }\n+            continue;\n+        }\n+        if !file.metadata().unwrap().is_file() || !path.to_str().unwrap().ends_with(\".rs\") {\n+            continue;\n+        }\n+        let stderr = std::io::stderr();\n+        write!(stderr.lock(), \"test [miri-pass] {} ... \", path.display()).unwrap();\n+        let mut args: Vec<String> = std::env::args().collect();\n+        // file to process\n+        args.push(path.display().to_string());\n+\n+        let sysroot_flag = String::from(\"--sysroot\");\n+        if !args.contains(&sysroot_flag) {\n+            args.push(sysroot_flag);\n+            args.push(Path::new(&std::env::var(\"HOME\").unwrap()).join(\".xargo\").join(\"HOST\").display().to_string());\n+        }\n+\n+        // we run the optimization passes inside miri\n+        // if we ran them twice we'd get funny failures due to borrowck ElaborateDrops only working on\n+        // unoptimized MIR\n+        // FIXME: add an after-mir-passes hook to rustc driver\n+        args.push(\"-Zmir-opt-level=0\".to_owned());\n+        // for auxilary builds in unit tests\n+        args.push(\"-Zalways-encode-mir\".to_owned());\n+\n+        // A threadsafe buffer for writing.\n+        #[derive(Default, Clone)]\n+        struct BufWriter(Arc<Mutex<Vec<u8>>>);\n+\n+        impl Write for BufWriter {\n+            fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+                self.0.lock().unwrap().write(buf)\n+            }\n+            fn flush(&mut self) -> io::Result<()> {\n+                self.0.lock().unwrap().flush()\n+            }\n+        }\n+        let buf = BufWriter::default();\n+        let output = buf.clone();\n+        let result = std::panic::catch_unwind(|| {\n+            rustc_driver::run_compiler(&args, &mut MiriCompilerCalls(RustcDefaultCalls), None, Some(Box::new(buf)));\n+        });\n+\n+        match result {\n+            Ok(()) => {\n+                success += 1;\n+                writeln!(stderr.lock(), \"ok\").unwrap()\n+            },\n+            Err(_) => {\n+                let output = output.0.lock().unwrap();\n+                let output_err = std::str::from_utf8(&output).unwrap();\n+                if let Some(text) = output_err.splitn(2, \"no mir for `\").nth(1) {\n+                    let end = text.find('`').unwrap();\n+                    mir_not_found.push(text[..end].to_string());\n+                    writeln!(stderr.lock(), \"NO MIR FOR `{}`\", &text[..end]).unwrap();\n+                } else if let Some(text) = output_err.splitn(2, \"can't find crate for `\").nth(1) {\n+                    let end = text.find('`').unwrap();\n+                    crate_not_found.push(text[..end].to_string());\n+                    writeln!(stderr.lock(), \"CAN'T FIND CRATE FOR `{}`\", &text[..end]).unwrap();\n+                } else {\n+                    for text in output_err.split(\"error: \").skip(1) {\n+                        let end = text.find('\\n').unwrap_or(text.len());\n+                        let c_abi = \"can't call C ABI function: \";\n+                        let unimplemented_intrinsic_s = \"unimplemented intrinsic: \";\n+                        let unsupported_s = \"miri does not support \";\n+                        let abi_s = \"can't handle function with \";\n+                        let limit_s = \"reached the configured maximum \";\n+                        if text.starts_with(c_abi) {\n+                            c_abi_fns.push(text[c_abi.len()..end].to_string());\n+                        } else if text.starts_with(unimplemented_intrinsic_s) {\n+                            unimplemented_intrinsic.push(text[unimplemented_intrinsic_s.len()..end].to_string());\n+                        } else if text.starts_with(unsupported_s) {\n+                            unsupported.push(text[unsupported_s.len()..end].to_string());\n+                        } else if text.starts_with(abi_s) {\n+                            abi.push(text[abi_s.len()..end].to_string());\n+                        } else if text.starts_with(limit_s) {\n+                            limits.push(text[limit_s.len()..end].to_string());\n+                        } else if text.find(\"aborting\").is_none() {\n+                            failed.push(text[..end].to_string());\n+                        }\n+                    }\n+                    writeln!(stderr.lock(), \"stderr: \\n {}\", output_err).unwrap();\n+                }\n+            }\n+        }\n+    }\n+    let stderr = std::io::stderr();:{MetaItemKind, NestedMetaItemKind, self};\n+    let mut stderr = stderr.lock();\n+    writeln!(stderr, \"{} success, {} no mir, {} crate not found, {} failed, \\\n+                        {} C fn, {} ABI, {} unsupported, {} intrinsic\",\n+                        success, mir_not_found.len(), crate_not_found.len(), failed.len(),\n+                        c_abi_fns.len(), abi.len(), unsupported.len(), unimplemented_intrinsic.len()).unwrap();\n+    writeln!(stderr, \"# The \\\"other reasons\\\" errors\").unwrap();\n+    writeln!(stderr, \"(sorted, deduplicated)\").unwrap();\n+    print_vec(&mut stderr, failed);\n+\n+    writeln!(stderr, \"# can't call C ABI function\").unwrap();\n+    print_vec(&mut stderr, c_abi_fns);\n+\n+    writeln!(stderr, \"# unsupported ABI\").unwrap();\n+    print_vec(&mut stderr, abi);\n+\n+    writeln!(stderr, \"# unsupported\").unwrap();\n+    print_vec(&mut stderr, unsupported);\n+\n+    writeln!(stderr, \"# unimplemented intrinsics\").unwrap();\n+    print_vec(&mut stderr, unimplemented_intrinsic);\n+\n+    writeln!(stderr, \"# mir not found\").unwrap();\n+    print_vec(&mut stderr, mir_not_found);\n+\n+    writeln!(stderr, \"# crate not found\").unwrap();\n+    print_vec(&mut stderr, crate_not_found);\n+}\n+\n+fn print_vec<W: std::io::Write>(stderr: &mut W, v: Vec<String>) {\n+    writeln!(stderr, \"```\").unwrap();\n+    for (n, s) in vec_to_hist(v).into_iter().rev() {\n+        writeln!(stderr, \"{:4} {}\", n, s).unwrap();\n+    }\n+    writeln!(stderr, \"```\").unwrap();\n+}\n+\n+fn vec_to_hist<T: PartialEq + Ord>(mut v: Vec<T>) -> Vec<(usize, T)> {\n+    v.sort();\n+    let mut v = v.into_iter();\n+    let mut result = Vec::new();\n+    let mut current = v.next();\n+    'outer: while let Some(current_val) = current {\n+        let mut n = 1;\n+        for next in &mut v {\n+            if next == current_val {\n+                n += 1;\n+            } else {\n+                result.push((n, current_val));\n+                current = Some(next);\n+                continue 'outer;\n+            }\n+        }\n+        result.push((n, current_val));\n+        break;\n+    }\n+    result.sort();\n+    result\n+}"}, {"sha": "5512669cedbf52aaa3280ff3d5ec0ecbbcff0146", "filename": "tests/compiletest.rs", "status": "modified", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/101e5a8ba0978c4aad14c994cc487c2645ea58f0/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/101e5a8ba0978c4aad14c994cc487c2645ea58f0/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=101e5a8ba0978c4aad14c994cc487c2645ea58f0", "patch": "@@ -108,131 +108,8 @@ fn get_host() -> String {\n     String::from(host)\n }\n \n-#[test]\n-fn rustc_test() {\n-    if let Ok(path) = std::env::var(\"MIRI_RUSTC_TEST\") {\n-        let sysroot = get_sysroot();\n-        let host = get_host();\n-\n-        let mut mir_not_found = Vec::new();\n-        let mut crate_not_found = Vec::new();\n-        let mut success = 0;\n-        let mut failed = Vec::new();\n-        let mut c_abi_fns = Vec::new();\n-        let mut abi = Vec::new();\n-        let mut unsupported = Vec::new();\n-        let mut unimplemented_intrinsic = Vec::new();\n-        let mut limits = Vec::new();\n-        let mut files: Vec<_> = std::fs::read_dir(path).unwrap().collect();\n-        while let Some(file) = files.pop() {\n-            let file = file.unwrap();\n-            let path = file.path();\n-            if file.metadata().unwrap().is_dir() {\n-                if !path.to_str().unwrap().ends_with(\"auxiliary\") {\n-                    // add subdirs recursively\n-                    files.extend(std::fs::read_dir(path).unwrap());\n-                }\n-                continue;\n-            }\n-            if !file.metadata().unwrap().is_file() || !path.to_str().unwrap().ends_with(\".rs\") {\n-                continue;\n-            }\n-            let stderr = std::io::stderr();\n-            write!(stderr.lock(), \"test [miri-pass] {} ... \", path.display()).unwrap();\n-            let mut cmd = std::process::Command::new(\"target/debug/miri\");\n-            cmd.arg(path);\n-            let libs = Path::new(&sysroot).join(\"lib\");\n-            let sysroot = libs.join(\"rustlib\").join(&host).join(\"lib\");\n-            let paths = std::env::join_paths(&[libs, sysroot]).unwrap();\n-            cmd.env(compiletest::procsrv::dylib_env_var(), paths);\n-            cmd.env(\"MIRI_SYSROOT\", Path::new(&std::env::var(\"HOME\").unwrap()).join(\".xargo\").join(\"HOST\"));\n-\n-            match cmd.output() {\n-                Ok(ref output) if output.status.success() => {\n-                    success += 1;\n-                    writeln!(stderr.lock(), \"ok\").unwrap()\n-                },\n-                Ok(output) => {\n-                    let output_err = std::str::from_utf8(&output.stderr).unwrap();\n-                    if let Some(text) = output_err.splitn(2, \"no mir for `\").nth(1) {\n-                        let end = text.find('`').unwrap();\n-                        mir_not_found.push(text[..end].to_string());\n-                        writeln!(stderr.lock(), \"NO MIR FOR `{}`\", &text[..end]).unwrap();\n-                    } else if let Some(text) = output_err.splitn(2, \"can't find crate for `\").nth(1) {\n-                        let end = text.find('`').unwrap();\n-                        crate_not_found.push(text[..end].to_string());\n-                        writeln!(stderr.lock(), \"CAN'T FIND CRATE FOR `{}`\", &text[..end]).unwrap();\n-                    } else {\n-                        for text in output_err.split(\"error: \").skip(1) {\n-                            let end = text.find('\\n').unwrap_or(text.len());\n-                            let c_abi = \"can't call C ABI function: \";\n-                            let unimplemented_intrinsic_s = \"unimplemented intrinsic: \";\n-                            let unsupported_s = \"miri does not support \";\n-                            let abi_s = \"can't handle function with \";\n-                            let limit_s = \"reached the configured maximum \";\n-                            if text.starts_with(c_abi) {\n-                                c_abi_fns.push(text[c_abi.len()..end].to_string());\n-                            } else if text.starts_with(unimplemented_intrinsic_s) {\n-                                unimplemented_intrinsic.push(text[unimplemented_intrinsic_s.len()..end].to_string());\n-                            } else if text.starts_with(unsupported_s) {\n-                                unsupported.push(text[unsupported_s.len()..end].to_string());\n-                            } else if text.starts_with(abi_s) {\n-                                abi.push(text[abi_s.len()..end].to_string());\n-                            } else if text.starts_with(limit_s) {\n-                                limits.push(text[limit_s.len()..end].to_string());\n-                            } else if text.find(\"aborting\").is_none() {\n-                                failed.push(text[..end].to_string());\n-                            }\n-                        }\n-                        writeln!(stderr.lock(), \"FAILED with exit code {:?}\", output.status.code()).unwrap();\n-                        writeln!(stderr.lock(), \"stdout: \\n {}\", std::str::from_utf8(&output.stdout).unwrap()).unwrap();\n-                        writeln!(stderr.lock(), \"stderr: \\n {}\", output_err).unwrap();\n-                    }\n-                }\n-                Err(e) => {\n-                    writeln!(stderr.lock(), \"FAILED: {}\", e).unwrap();\n-                    panic!(\"failed to execute miri\");\n-                },\n-            }\n-        }\n-        let stderr = std::io::stderr();\n-        let mut stderr = stderr.lock();\n-        writeln!(stderr, \"{} success, {} no mir, {} crate not found, {} failed, \\\n-                          {} C fn, {} ABI, {} unsupported, {} intrinsic\",\n-                          success, mir_not_found.len(), crate_not_found.len(), failed.len(),\n-                          c_abi_fns.len(), abi.len(), unsupported.len(), unimplemented_intrinsic.len()).unwrap();\n-        writeln!(stderr, \"# The \\\"other reasons\\\" errors\").unwrap();\n-        writeln!(stderr, \"(sorted, deduplicated)\").unwrap();\n-        print_vec(&mut stderr, failed);\n-\n-        writeln!(stderr, \"# can't call C ABI function\").unwrap();\n-        print_vec(&mut stderr, c_abi_fns);\n-\n-        writeln!(stderr, \"# unsupported ABI\").unwrap();\n-        print_vec(&mut stderr, abi);\n-\n-        writeln!(stderr, \"# unsupported\").unwrap();\n-        print_vec(&mut stderr, unsupported);\n-\n-        writeln!(stderr, \"# unimplemented intrinsics\").unwrap();\n-        print_vec(&mut stderr, unimplemented_intrinsic);\n-\n-        writeln!(stderr, \"# mir not found\").unwrap();\n-        print_vec(&mut stderr, mir_not_found);\n-\n-        writeln!(stderr, \"# crate not found\").unwrap();\n-        print_vec(&mut stderr, crate_not_found);\n-\n-        panic!(\"ran miri on rustc test suite. Test failing for convenience\");\n-    }\n-}\n-\n #[test]\n fn run_pass_miri() {\n-    if let Ok(_) = std::env::var(\"MIRI_RUSTC_TEST\") {\n-        return;\n-    }\n-\n     let sysroot = get_sysroot();\n     let host = get_host();\n \n@@ -244,20 +121,12 @@ fn run_pass_miri() {\n \n #[test]\n fn run_pass_rustc() {\n-    if let Ok(_) = std::env::var(\"MIRI_RUSTC_TEST\") {\n-        return;\n-    }\n-\n     run_pass(\"tests/run-pass\");\n     run_pass(\"tests/run-pass-fullmir\");\n }\n \n #[test]\n fn compile_fail_miri() {\n-    if let Ok(_) = std::env::var(\"MIRI_RUSTC_TEST\") {\n-        return;\n-    }\n-\n     let sysroot = get_sysroot();\n     let host = get_host();\n \n@@ -266,34 +135,3 @@ fn compile_fail_miri() {\n     });\n     compile_fail(&sysroot, \"tests/compile-fail-fullmir\", &host, &host, true);\n }\n-\n-fn print_vec<W: std::io::Write>(stderr: &mut W, v: Vec<String>) {\n-    writeln!(stderr, \"```\").unwrap();\n-    for (n, s) in vec_to_hist(v).into_iter().rev() {\n-        writeln!(stderr, \"{:4} {}\", n, s).unwrap();\n-    }\n-    writeln!(stderr, \"```\").unwrap();\n-}\n-\n-fn vec_to_hist<T: PartialEq + Ord>(mut v: Vec<T>) -> Vec<(usize, T)> {\n-    v.sort();\n-    let mut v = v.into_iter();\n-    let mut result = Vec::new();\n-    let mut current = v.next();\n-    'outer: while let Some(current_val) = current {\n-        let mut n = 1;\n-        for next in &mut v {\n-            if next == current_val {\n-                n += 1;\n-            } else {\n-                result.push((n, current_val));\n-                current = Some(next);\n-                continue 'outer;\n-            }\n-        }\n-        result.push((n, current_val));\n-        break;\n-    }\n-    result.sort();\n-    result\n-}"}]}