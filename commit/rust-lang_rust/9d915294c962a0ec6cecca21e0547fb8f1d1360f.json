{"sha": "9d915294c962a0ec6cecca21e0547fb8f1d1360f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkOTE1Mjk0Yzk2MmEwZWM2Y2VjY2EyMWUwNTQ3ZmI4ZjFkMTM2MGY=", "commit": {"author": {"name": "Viktor Dahl", "email": "pazaconyoman@gmail.com", "date": "2012-10-24T15:20:54Z"}, "committer": {"name": "Viktor Dahl", "email": "pazaconyoman@gmail.com", "date": "2012-10-24T16:44:37Z"}, "message": "Implemented '-W type-limits' (#3833)", "tree": {"sha": "cd49226ec03d89b039717201fd617222e818663f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd49226ec03d89b039717201fd617222e818663f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d915294c962a0ec6cecca21e0547fb8f1d1360f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d915294c962a0ec6cecca21e0547fb8f1d1360f", "html_url": "https://github.com/rust-lang/rust/commit/9d915294c962a0ec6cecca21e0547fb8f1d1360f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d915294c962a0ec6cecca21e0547fb8f1d1360f/comments", "author": {"login": "veddan", "id": 307180, "node_id": "MDQ6VXNlcjMwNzE4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/307180?v=4", "gravatar_id": "", "url": "https://api.github.com/users/veddan", "html_url": "https://github.com/veddan", "followers_url": "https://api.github.com/users/veddan/followers", "following_url": "https://api.github.com/users/veddan/following{/other_user}", "gists_url": "https://api.github.com/users/veddan/gists{/gist_id}", "starred_url": "https://api.github.com/users/veddan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/veddan/subscriptions", "organizations_url": "https://api.github.com/users/veddan/orgs", "repos_url": "https://api.github.com/users/veddan/repos", "events_url": "https://api.github.com/users/veddan/events{/privacy}", "received_events_url": "https://api.github.com/users/veddan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "veddan", "id": 307180, "node_id": "MDQ6VXNlcjMwNzE4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/307180?v=4", "gravatar_id": "", "url": "https://api.github.com/users/veddan", "html_url": "https://github.com/veddan", "followers_url": "https://api.github.com/users/veddan/followers", "following_url": "https://api.github.com/users/veddan/following{/other_user}", "gists_url": "https://api.github.com/users/veddan/gists{/gist_id}", "starred_url": "https://api.github.com/users/veddan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/veddan/subscriptions", "organizations_url": "https://api.github.com/users/veddan/orgs", "repos_url": "https://api.github.com/users/veddan/repos", "events_url": "https://api.github.com/users/veddan/events{/privacy}", "received_events_url": "https://api.github.com/users/veddan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61bb3571a59f4659a0a46565c71fa7ecfa352811", "url": "https://api.github.com/repos/rust-lang/rust/commits/61bb3571a59f4659a0a46565c71fa7ecfa352811", "html_url": "https://github.com/rust-lang/rust/commit/61bb3571a59f4659a0a46565c71fa7ecfa352811"}], "stats": {"total": 109, "additions": 109, "deletions": 0}, "files": [{"sha": "0e8cdbeb880c52d6eeabc9ce5393fb61b9763fcf", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9d915294c962a0ec6cecca21e0547fb8f1d1360f/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d915294c962a0ec6cecca21e0547fb8f1d1360f/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=9d915294c962a0ec6cecca21e0547fb8f1d1360f", "patch": "@@ -54,6 +54,7 @@ enum lint {\n     deprecated_pattern,\n     non_camel_case_types,\n     structural_records,\n+\ttype_limits,\n \n     managed_heap_memory,\n     owned_heap_memory,\n@@ -186,6 +187,11 @@ fn get_lint_dict() -> lint_dict {\n            desc: ~\"allow legacy modes\",\n            default: forbid}),\n \n+\t\t(~\"type_limits\",\n+\t\t @{lint: type_limits,\n+\t\t   desc: ~\"comparisons made useless by limits of the types involved\",\n+\t\t   default: warn})\n+\n         /* FIXME(#3266)--make liveness warnings lintable\n         (~\"unused_variable\",\n          @{lint: unused_variable,\n@@ -397,6 +403,7 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_heap(cx, i);\n     check_item_structural_records(cx, i);\n     check_item_deprecated_modes(cx, i);\n+\tcheck_item_type_limits(cx, i);\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -430,6 +437,108 @@ fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n     visit::visit_item(it, (), visit);\n }\n \n+fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n+\tpure fn is_valid<T: cmp::Ord>(binop: ast::binop, v: T, min: T, max: T) -> bool {\n+\t\tmatch binop {\n+\t\t\tast::lt => v <= max,\n+\t\t\tast::le => v < max,\n+\t\t\tast::gt => v >= min,\n+\t\t\tast::ge => v > min,\n+\t\t\tast::eq | ast::ne => v >= min && v <= max,\n+\t\t\t_ => fail\n+\t\t}\n+\t}\n+\n+\tpure fn rev_binop(binop: ast::binop) -> ast::binop {\n+\t\tmatch binop {\n+\t\t\tast::lt => ast::ge,\n+\t\t\tast::le => ast::gt,\n+\t\t\tast::gt => ast::le,\n+\t\t\tast::ge => ast::lt,\n+\t\t\t_ => binop\n+\t\t}\n+\t}\n+\n+\tfn check_limits(cx: ty::ctxt, binop: ast::binop, l: &ast::expr,\n+\t\t\t\t\tr: &ast::expr) -> bool {\n+\t\tlet (lit, expr, swap) = match (l.node, r.node) {\n+\t\t\t(ast::expr_lit(_), _) => (l, r, true),\n+\t\t\t(_, ast::expr_lit(_)) => (r, l, false),\n+\t\t\t_ => return true\n+\t\t};\n+\t\t// Normalize the binop so that the literal is always on the RHS in\n+\t\t// the comparison\n+\t\tlet norm_binop = if (swap) {\n+\t\t\trev_binop(binop)\n+\t\t} else {\n+\t\t\tbinop\n+\t\t};\n+\t\tmatch ty::get(ty::expr_ty(cx, @*expr)).sty {\n+\t\t\tty::ty_int(int_ty) => {\n+\t\t\t\tlet (min, max): (i64, i64) = match int_ty {\n+\t\t\t\t\tast::ty_i =>\t(int::min_value as i64,\tint::max_value as i64),\n+\t\t\t\t\tast::ty_char =>\t(u32::min_value as i64,\tu32::max_value as i64),\n+\t\t\t\t\tast::ty_i8 =>\t(i8::min_value  as i64,\ti8::max_value  as i64),\n+\t\t\t\t\tast::ty_i16 =>\t(i16::min_value as i64,\ti16::max_value as i64),\n+\t\t\t\t\tast::ty_i32 =>\t(i32::min_value as i64,\ti32::max_value as i64),\n+\t\t\t\t\tast::ty_i64 =>\t(i64::min_value, \t\ti64::max_value)\n+\t\t\t\t};\n+\t\t\t\tlet lit_val: i64 = match lit.node {\n+\t\t\t\t\tast::expr_lit(@li) => match li.node {\n+\t\t\t\t\t\tast::lit_int(v, _) => v,\n+\t\t\t\t\t\tast::lit_uint(v, _) => v as i64,\n+\t\t\t\t\t\tast::lit_int_unsuffixed(v) => v,\n+\t\t\t\t\t\t_ => return true\n+\t\t\t\t\t},\n+\t\t\t\t\t_ => fail\n+\t\t\t\t};\n+\t\t\t\tis_valid(norm_binop, lit_val, min, max)\n+\t\t\t}\n+\t\t\tty::ty_uint(uint_ty) => {\n+\t\t\t\tlet (min, max): (u64, u64) = match uint_ty {\n+\t\t\t\t\tast::ty_u =>\t(uint::min_value as u64, uint::max_value as u64),\n+\t\t\t\t\tast::ty_u8 =>\t(u8::min_value   as u64, u8::max_value   as u64),\n+\t\t\t\t\tast::ty_u16 =>\t(u16::min_value  as u64, u16::max_value  as u64),\n+\t\t\t\t\tast::ty_u32 =>\t(u32::min_value  as u64, u32::max_value  as u64),\n+\t\t\t\t\tast::ty_u64 =>\t(u64::min_value, \t\t u64::max_value)\n+\t\t\t\t};\n+\t\t\t\tlet lit_val: u64 = match lit.node {\n+\t\t\t\t\tast::expr_lit(@li) => match li.node {\n+\t\t\t\t\t\tast::lit_int(v, _) => v as u64,\n+\t\t\t\t\t\tast::lit_uint(v, _) => v,\n+\t\t\t\t\t\tast::lit_int_unsuffixed(v) => v as u64,\n+\t\t\t\t\t\t_ => return true\n+\t\t\t\t\t},\n+\t\t\t\t\t_ => fail\n+\t\t\t\t};\n+\t\t\t\tis_valid(norm_binop, lit_val, min, max)\n+\t\t\t}\n+\t\t\t_ => true\n+\t\t}\n+\t}\n+\n+\tlet visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n+\t\tvisit_expr: fn@(e: @ast::expr) {\n+\t\t\tmatch e.node {\n+\t\t\t\tast::expr_binary(binop, @l, @r) => {\n+\t\t\t\t\tmatch binop {\n+\t\t\t\t\t\tast::eq | ast::lt | ast::le | ast::ne | ast::ge | ast::gt => {\n+\t\t\t\t\t\t\tif !check_limits(cx, binop, &l, &r) {\n+\t\t\t\t\t\t\t\tcx.sess.span_lint(type_limits, e.id, it.id, e.span,\n+\t\t\t\t\t\t\t\t\t~\"comparison is useless due to type limits\");\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t_ => ()\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t_ => ()\n+\t\t\t}\n+\t\t},\n+\t\t.. *visit::default_simple_visitor()\n+\t}));\n+\tvisit::visit_item(it, (), visit);\n+}\n+\n fn check_item_structural_records(cx: ty::ctxt, it: @ast::item) {\n     let visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n         visit_expr: fn@(e: @ast::expr) {"}]}