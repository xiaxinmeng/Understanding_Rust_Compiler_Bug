{"sha": "e8a96c97f4972c3d4823105f53e28b88cd9b533e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4YTk2Yzk3ZjQ5NzJjM2Q0ODIzMTA1ZjUzZTI4Yjg4Y2Q5YjUzM2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-02T21:24:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-02T22:38:24Z"}, "message": "fallback to provided signature in the event of a type error\n\nThis prevents regressions on some annoying cases.", "tree": {"sha": "36ac2f09fbe01b2345538acdd457e052ded8cbfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36ac2f09fbe01b2345538acdd457e052ded8cbfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8a96c97f4972c3d4823105f53e28b88cd9b533e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8a96c97f4972c3d4823105f53e28b88cd9b533e", "html_url": "https://github.com/rust-lang/rust/commit/e8a96c97f4972c3d4823105f53e28b88cd9b533e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8a96c97f4972c3d4823105f53e28b88cd9b533e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "053383dbeff008744fb5dea7c1c8f4fba98cc06e", "url": "https://api.github.com/repos/rust-lang/rust/commits/053383dbeff008744fb5dea7c1c8f4fba98cc06e", "html_url": "https://github.com/rust-lang/rust/commit/053383dbeff008744fb5dea7c1c8f4fba98cc06e"}], "stats": {"total": 429, "additions": 251, "deletions": 178}, "files": [{"sha": "d475fb0cf1a142c5139f8a607f996d79743c1aaf", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 246, "deletions": 156, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/e8a96c97f4972c3d4823105f53e28b88cd9b533e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a96c97f4972c3d4823105f53e28b88cd9b533e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=e8a96c97f4972c3d4823105f53e28b88cd9b533e", "patch": "@@ -14,6 +14,7 @@ use super::{check_fn, Expectation, FnCtxt};\n \n use astconv::AstConv;\n use rustc::hir::def_id::DefId;\n+use rustc::infer::{InferOk, InferResult};\n use rustc::infer::LateBoundRegionConversionTime;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n@@ -30,16 +31,19 @@ struct ClosureSignatures<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn check_expr_closure(&self,\n-                              expr: &hir::Expr,\n-                              _capture: hir::CaptureClause,\n-                              decl: &'gcx hir::FnDecl,\n-                              body_id: hir::BodyId,\n-                              expected: Expectation<'tcx>)\n-                              -> Ty<'tcx> {\n-        debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n-               expr,\n-               expected);\n+    pub fn check_expr_closure(\n+        &self,\n+        expr: &hir::Expr,\n+        _capture: hir::CaptureClause,\n+        decl: &'gcx hir::FnDecl,\n+        body_id: hir::BodyId,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n+        debug!(\n+            \"check_expr_closure(expr={:?},expected={:?})\",\n+            expr,\n+            expected\n+        );\n \n         // It's always helpful for inference if we know the kind of\n         // closure sooner rather than later, so first examine the expected\n@@ -52,60 +56,84 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.check_closure(expr, expected_kind, decl, body, expected_sig)\n     }\n \n-    fn check_closure(&self,\n-                     expr: &hir::Expr,\n-                     opt_kind: Option<ty::ClosureKind>,\n-                     decl: &'gcx hir::FnDecl,\n-                     body: &'gcx hir::Body,\n-                     expected_sig: Option<ty::FnSig<'tcx>>)\n-                     -> Ty<'tcx> {\n-        debug!(\"check_closure(opt_kind={:?}, expected_sig={:?})\",\n-               opt_kind,\n-               expected_sig);\n+    fn check_closure(\n+        &self,\n+        expr: &hir::Expr,\n+        opt_kind: Option<ty::ClosureKind>,\n+        decl: &'gcx hir::FnDecl,\n+        body: &'gcx hir::Body,\n+        expected_sig: Option<ty::FnSig<'tcx>>,\n+    ) -> Ty<'tcx> {\n+        debug!(\n+            \"check_closure(opt_kind={:?}, expected_sig={:?})\",\n+            opt_kind,\n+            expected_sig\n+        );\n \n         let expr_def_id = self.tcx.hir.local_def_id(expr.id);\n \n-        let ClosureSignatures { bound_sig, liberated_sig } =\n-            self.sig_of_closure(expr_def_id, decl, body, expected_sig);\n+        let ClosureSignatures {\n+            bound_sig,\n+            liberated_sig,\n+        } = self.sig_of_closure(expr_def_id, decl, body, expected_sig);\n \n         debug!(\"check_closure: ty_of_closure returns {:?}\", liberated_sig);\n \n-        let interior = check_fn(self, self.param_env, liberated_sig, decl, expr.id, body, true).1;\n+        let interior = check_fn(\n+            self,\n+            self.param_env,\n+            liberated_sig,\n+            decl,\n+            expr.id,\n+            body,\n+            true,\n+        ).1;\n \n         // Create type variables (for now) to represent the transformed\n         // types of upvars. These will be unified during the upvar\n         // inference phase (`upvar.rs`).\n-        let base_substs = Substs::identity_for_item(self.tcx,\n-            self.tcx.closure_base_def_id(expr_def_id));\n-        let substs = base_substs.extend_to(self.tcx, expr_def_id,\n-                |_, _| span_bug!(expr.span, \"closure has region param\"),\n-                |_, _| self.infcx.next_ty_var(TypeVariableOrigin::TransformedUpvar(expr.span))\n+        let base_substs =\n+            Substs::identity_for_item(self.tcx, self.tcx.closure_base_def_id(expr_def_id));\n+        let substs = base_substs.extend_to(\n+            self.tcx,\n+            expr_def_id,\n+            |_, _| span_bug!(expr.span, \"closure has region param\"),\n+            |_, _| {\n+                self.infcx\n+                    .next_ty_var(TypeVariableOrigin::TransformedUpvar(expr.span))\n+            },\n         );\n         let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n \n         if let Some(interior) = interior {\n-            let closure_substs = ty::ClosureSubsts {\n-                substs: substs,\n-            };\n+            let closure_substs = ty::ClosureSubsts { substs: substs };\n             return self.tcx.mk_generator(expr_def_id, closure_substs, interior);\n         }\n \n-        debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n+        debug!(\n+            \"check_closure: expr.id={:?} closure_type={:?}\",\n+            expr.id,\n+            closure_type\n+        );\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table.\n-        let sig = bound_sig.map_bound(|sig| self.tcx.mk_fn_sig(\n-            iter::once(self.tcx.intern_tup(sig.inputs(), false)),\n-            sig.output(),\n-            sig.variadic,\n-            sig.unsafety,\n-            sig.abi\n-        ));\n-\n-        debug!(\"check_closure: expr_def_id={:?}, sig={:?}, opt_kind={:?}\",\n-               expr_def_id,\n-               sig,\n-               opt_kind);\n+        let sig = bound_sig.map_bound(|sig| {\n+            self.tcx.mk_fn_sig(\n+                iter::once(self.tcx.intern_tup(sig.inputs(), false)),\n+                sig.output(),\n+                sig.variadic,\n+                sig.unsafety,\n+                sig.abi,\n+            )\n+        });\n+\n+        debug!(\n+            \"check_closure: expr_def_id={:?}, sig={:?}, opt_kind={:?}\",\n+            expr_def_id,\n+            sig,\n+            opt_kind\n+        );\n \n         {\n             let mut tables = self.tables.borrow_mut();\n@@ -121,22 +149,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         closure_type\n     }\n \n-    fn deduce_expectations_from_expected_type\n-        (&self,\n-         expected_ty: Ty<'tcx>)\n-         -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n-        debug!(\"deduce_expectations_from_expected_type(expected_ty={:?})\",\n-               expected_ty);\n+    fn deduce_expectations_from_expected_type(\n+        &self,\n+        expected_ty: Ty<'tcx>,\n+    ) -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n+        debug!(\n+            \"deduce_expectations_from_expected_type(expected_ty={:?})\",\n+            expected_ty\n+        );\n \n         match expected_ty.sty {\n             ty::TyDynamic(ref object_type, ..) => {\n-                let sig = object_type.projection_bounds()\n+                let sig = object_type\n+                    .projection_bounds()\n                     .filter_map(|pb| {\n                         let pb = pb.with_self_ty(self.tcx, self.tcx.types.err);\n                         self.deduce_sig_from_projection(&pb)\n                     })\n                     .next();\n-                let kind = object_type.principal()\n+                let kind = object_type\n+                    .principal()\n                     .and_then(|p| self.tcx.lang_items().fn_trait_kind(p.def_id()));\n                 (sig, kind)\n             }\n@@ -146,19 +178,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn deduce_expectations_from_obligations\n-        (&self,\n-         expected_vid: ty::TyVid)\n-         -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n+    fn deduce_expectations_from_obligations(\n+        &self,\n+        expected_vid: ty::TyVid,\n+    ) -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n         let fulfillment_cx = self.fulfillment_cx.borrow();\n         // Here `expected_ty` is known to be a type inference variable.\n \n-        let expected_sig = fulfillment_cx.pending_obligations()\n+        let expected_sig = fulfillment_cx\n+            .pending_obligations()\n             .iter()\n             .map(|obligation| &obligation.obligation)\n             .filter_map(|obligation| {\n-                debug!(\"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n-                       obligation.predicate);\n+                debug!(\n+                    \"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n+                    obligation.predicate\n+                );\n \n                 match obligation.predicate {\n                     // Given a Projection predicate, we can potentially infer\n@@ -177,7 +212,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // infer the kind. This can occur if there is a trait-reference\n         // like `F : Fn<A>`. Note that due to subtyping we could encounter\n         // many viable options, so pick the most restrictive.\n-        let expected_kind = fulfillment_cx.pending_obligations()\n+        let expected_kind = fulfillment_cx\n+            .pending_obligations()\n             .iter()\n             .map(|obligation| &obligation.obligation)\n             .filter_map(|obligation| {\n@@ -202,20 +238,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // inference variable.\n                     ty::Predicate::ClosureKind(..) => None,\n                 };\n-                opt_trait_ref.and_then(|tr| self.self_type_matches_expected_vid(tr, expected_vid))\n+                opt_trait_ref\n+                    .and_then(|tr| self.self_type_matches_expected_vid(tr, expected_vid))\n                     .and_then(|tr| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n             })\n-            .fold(None,\n-                  |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n+            .fold(None, |best, cur| {\n+                Some(best.map_or(cur, |best| cmp::min(best, cur)))\n+            });\n \n         (expected_sig, expected_kind)\n     }\n \n     /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n     /// everything we need to know about a closure.\n-    fn deduce_sig_from_projection(&self,\n-                                  projection: &ty::PolyProjectionPredicate<'tcx>)\n-                                  -> Option<ty::FnSig<'tcx>> {\n+    fn deduce_sig_from_projection(\n+        &self,\n+        projection: &ty::PolyProjectionPredicate<'tcx>,\n+    ) -> Option<ty::FnSig<'tcx>> {\n         let tcx = self.tcx;\n \n         debug!(\"deduce_sig_from_projection({:?})\", projection);\n@@ -228,8 +267,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let arg_param_ty = trait_ref.substs().type_at(1);\n         let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n-        debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\",\n-               arg_param_ty);\n+        debug!(\n+            \"deduce_sig_from_projection: arg_param_ty {:?}\",\n+            arg_param_ty\n+        );\n \n         let input_tys = match arg_param_ty.sty {\n             ty::TyTuple(tys, _) => tys.into_iter(),\n@@ -240,41 +281,47 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let ret_param_ty = projection.0.ty;\n         let ret_param_ty = self.resolve_type_vars_if_possible(&ret_param_ty);\n-        debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\", ret_param_ty);\n+        debug!(\n+            \"deduce_sig_from_projection: ret_param_ty {:?}\",\n+            ret_param_ty\n+        );\n \n         let fn_sig = self.tcx.mk_fn_sig(\n             input_tys.cloned(),\n             ret_param_ty,\n             false,\n             hir::Unsafety::Normal,\n-            Abi::Rust\n+            Abi::Rust,\n         );\n         debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);\n \n         Some(fn_sig)\n     }\n \n-    fn self_type_matches_expected_vid(&self,\n-                                      trait_ref: ty::PolyTraitRef<'tcx>,\n-                                      expected_vid: ty::TyVid)\n-                                      -> Option<ty::PolyTraitRef<'tcx>> {\n+    fn self_type_matches_expected_vid(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        expected_vid: ty::TyVid,\n+    ) -> Option<ty::PolyTraitRef<'tcx>> {\n         let self_ty = self.shallow_resolve(trait_ref.self_ty());\n-        debug!(\"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n-               trait_ref,\n-               self_ty);\n+        debug!(\n+            \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n+            trait_ref,\n+            self_ty\n+        );\n         match self_ty.sty {\n             ty::TyInfer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n             _ => None,\n         }\n     }\n \n-    fn sig_of_closure(&self,\n-                      expr_def_id: DefId,\n-                      decl: &hir::FnDecl,\n-                      body: &hir::Body,\n-                      expected_sig: Option<ty::FnSig<'tcx>>)\n-                      -> ClosureSignatures<'tcx>\n-    {\n+    fn sig_of_closure(\n+        &self,\n+        expr_def_id: DefId,\n+        decl: &hir::FnDecl,\n+        body: &hir::Body,\n+        expected_sig: Option<ty::FnSig<'tcx>>,\n+    ) -> ClosureSignatures<'tcx> {\n         if let Some(e) = expected_sig {\n             self.sig_of_closure_with_expectation(expr_def_id, decl, body, e)\n         } else {\n@@ -284,12 +331,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// If there is no expected signature, then we will convert the\n     /// types that the user gave into a signature.\n-    fn sig_of_closure_no_expectation(&self,\n-                                     expr_def_id: DefId,\n-                                     decl: &hir::FnDecl,\n-                                     body: &hir::Body)\n-                                     -> ClosureSignatures<'tcx>\n-    {\n+    fn sig_of_closure_no_expectation(\n+        &self,\n+        expr_def_id: DefId,\n+        decl: &hir::FnDecl,\n+        body: &hir::Body,\n+    ) -> ClosureSignatures<'tcx> {\n         debug!(\"sig_of_closure_no_expectation()\");\n \n         let bound_sig = self.supplied_sig_of_closure(decl);\n@@ -344,14 +391,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// - `expected_sig`: the expected signature (if any). Note that\n     ///   this is missing a binder: that is, there may be late-bound\n     ///   regions with depth 1, which are bound then by the closure.\n-    fn sig_of_closure_with_expectation(&self,\n-                                       expr_def_id: DefId,\n-                                       decl: &hir::FnDecl,\n-                                       body: &hir::Body,\n-                                       expected_sig: ty::FnSig<'tcx>)\n-                                       -> ClosureSignatures<'tcx>\n-    {\n-        debug!(\"sig_of_closure_with_expectation(expected_sig={:?})\", expected_sig);\n+    fn sig_of_closure_with_expectation(\n+        &self,\n+        expr_def_id: DefId,\n+        decl: &hir::FnDecl,\n+        body: &hir::Body,\n+        expected_sig: ty::FnSig<'tcx>,\n+    ) -> ClosureSignatures<'tcx> {\n+        debug!(\n+            \"sig_of_closure_with_expectation(expected_sig={:?})\",\n+            expected_sig\n+        );\n \n         // Watch out for some surprises and just ignore the\n         // expectation if things don't see to match up with what we\n@@ -367,13 +417,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // regions appearing free in `expected_sig` are now bound up\n         // in this binder we are creating.\n         assert!(!expected_sig.has_regions_escaping_depth(1));\n-        let bound_sig =\n-            ty::Binder(self.tcx.mk_fn_sig(\n-                expected_sig.inputs().iter().cloned(),\n-                expected_sig.output(),\n-                decl.variadic,\n-                hir::Unsafety::Normal,\n-                Abi::RustCall));\n+        let bound_sig = ty::Binder(self.tcx.mk_fn_sig(\n+            expected_sig.inputs().iter().cloned(),\n+            expected_sig.output(),\n+            decl.variadic,\n+            hir::Unsafety::Normal,\n+            Abi::RustCall,\n+        ));\n \n         // `deduce_expectations_from_expected_type` introduces\n         // late-bound lifetimes defined elsewhere, which we now\n@@ -387,66 +437,101 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Along the way, it also writes out entries for types that the user\n         // wrote into our tables, which are then later used by the privacy\n         // check.\n-        self.check_supplied_sig_against_expectation(decl, &closure_sigs);\n+        match self.check_supplied_sig_against_expectation(decl, &closure_sigs) {\n+            Ok(infer_ok) => self.register_infer_ok_obligations(infer_ok),\n+            Err(_) => return self.sig_of_closure_no_expectation(expr_def_id, decl, body),\n+        }\n \n         closure_sigs\n     }\n \n     /// Enforce the user's types against the expectation.  See\n     /// `sig_of_closure_with_expectation` for details on the overall\n     /// strategy.\n-    fn check_supplied_sig_against_expectation(&self,\n-                                              decl: &hir::FnDecl,\n-                                              expected_sigs: &ClosureSignatures<'tcx>)\n-    {\n+    fn check_supplied_sig_against_expectation(\n+        &self,\n+        decl: &hir::FnDecl,\n+        expected_sigs: &ClosureSignatures<'tcx>,\n+    ) -> InferResult<'tcx, ()> {\n         // Get the signature S that the user gave.\n         //\n         // (See comment on `sig_of_closure_with_expectation` for the\n         // meaning of these letters.)\n         let supplied_sig = self.supplied_sig_of_closure(decl);\n \n-        debug!(\"check_supplied_sig_against_expectation: supplied_sig={:?}\",\n-               supplied_sig);\n-\n-        // The liberated version of this signature should be be a subtype\n-        // of the liberated form of the expectation.\n-        for ((hir_ty, &supplied_ty), expected_ty) in\n-            decl.inputs.iter()\n-            .zip(*supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n-            .zip(expected_sigs.liberated_sig.inputs()) // `liberated_sig` is E'.\n-        {\n-            // Instantiate (this part of..) S to S', i.e., with fresh variables.\n-            let (supplied_ty, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n-                hir_ty.span,\n-                LateBoundRegionConversionTime::FnCall,\n-                &ty::Binder(supplied_ty)); // recreated from (*) above\n+        debug!(\n+            \"check_supplied_sig_against_expectation: supplied_sig={:?}\",\n+            supplied_sig\n+        );\n \n-            // Check that E' = S'.\n-            self.demand_eqtype(hir_ty.span, expected_ty, supplied_ty);\n-        }\n+        // FIXME(#45727): As discussed in [this comment][c1], naively\n+        // forcing equality here actually results in suboptimal error\n+        // messages in some cases.  For now, if there would have been\n+        // an obvious error, we fallback to declaring the type of the\n+        // closure to be the one the user gave, which allows other\n+        // error message code to trigger.\n+        //\n+        // However, I think [there is potential to do even better\n+        // here][c2], since in *this* code we have the precise span of\n+        // the type parameter in question in hand when we report the\n+        // error.\n+        //\n+        // [c1]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341089706\n+        // [c2]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341096796\n+        self.infcx.commit_if_ok(|_| {\n+            let mut all_obligations = vec![];\n+\n+            // The liberated version of this signature should be be a subtype\n+            // of the liberated form of the expectation.\n+            for ((hir_ty, &supplied_ty), expected_ty) in decl.inputs.iter()\n+                           .zip(*supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n+                           .zip(expected_sigs.liberated_sig.inputs())\n+            // `liberated_sig` is E'.\n+            {\n+                // Instantiate (this part of..) S to S', i.e., with fresh variables.\n+                let (supplied_ty, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    hir_ty.span,\n+                    LateBoundRegionConversionTime::FnCall,\n+                    &ty::Binder(supplied_ty),\n+                ); // recreated from (*) above\n+\n+                // Check that E' = S'.\n+                let cause = &self.misc(hir_ty.span);\n+                let InferOk {\n+                    value: (),\n+                    obligations,\n+                } = self.at(cause, self.param_env)\n+                    .eq(*expected_ty, supplied_ty)?;\n+                all_obligations.extend(obligations);\n+            }\n \n-        let (supplied_output_ty, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n-            decl.output.span(),\n-            LateBoundRegionConversionTime::FnCall,\n-            &supplied_sig.output());\n-        self.demand_eqtype(decl.output.span(),\n-                           expected_sigs.liberated_sig.output(),\n-                           supplied_output_ty);\n+            let (supplied_output_ty, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+                decl.output.span(),\n+                LateBoundRegionConversionTime::FnCall,\n+                &supplied_sig.output(),\n+            );\n+            let cause = &self.misc(decl.output.span());\n+            let InferOk {\n+                value: (),\n+                obligations,\n+            } = self.at(cause, self.param_env)\n+                .eq(expected_sigs.liberated_sig.output(), supplied_output_ty)?;\n+            all_obligations.extend(obligations);\n+\n+            Ok(InferOk {\n+                value: (),\n+                obligations: all_obligations,\n+            })\n+        })\n     }\n \n     /// If there is no expected signature, then we will convert the\n     /// types that the user gave into a signature.\n-    fn supplied_sig_of_closure(&self,\n-                               decl: &hir::FnDecl)\n-                               -> ty::PolyFnSig<'tcx>\n-    {\n+    fn supplied_sig_of_closure(&self, decl: &hir::FnDecl) -> ty::PolyFnSig<'tcx> {\n         let astconv: &AstConv = self;\n \n         // First, convert the types that the user supplied (if any).\n-        let supplied_arguments =\n-            decl.inputs\n-                .iter()\n-                .map(|a| astconv.ast_ty_to_ty(a));\n+        let supplied_arguments = decl.inputs.iter().map(|a| astconv.ast_ty_to_ty(a));\n         let supplied_return = match decl.output {\n             hir::Return(ref output) => astconv.ast_ty_to_ty(&output),\n             hir::DefaultReturn(_) => astconv.ty_infer(decl.output.span()),\n@@ -457,25 +542,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             supplied_return,\n             decl.variadic,\n             hir::Unsafety::Normal,\n-            Abi::RustCall));\n+            Abi::RustCall,\n+        ));\n \n         debug!(\"supplied_sig_of_closure: result={:?}\", result);\n \n         result\n     }\n \n-    fn closure_sigs(&self,\n-                    expr_def_id: DefId,\n-                    body: &hir::Body,\n-                    bound_sig: ty::PolyFnSig<'tcx>)\n-                    -> ClosureSignatures<'tcx>\n-    {\n+    fn closure_sigs(\n+        &self,\n+        expr_def_id: DefId,\n+        body: &hir::Body,\n+        bound_sig: ty::PolyFnSig<'tcx>,\n+    ) -> ClosureSignatures<'tcx> {\n         let liberated_sig = self.liberate_late_bound_regions(expr_def_id, &bound_sig);\n-        let liberated_sig = self.inh.normalize_associated_types_in(body.value.span,\n-                                                                   body.value.id,\n-                                                                   self.param_env,\n-                                                                   &liberated_sig);\n-        ClosureSignatures { bound_sig, liberated_sig }\n+        let liberated_sig = self.inh.normalize_associated_types_in(\n+            body.value.span,\n+            body.value.id,\n+            self.param_env,\n+            &liberated_sig,\n+        );\n+        ClosureSignatures {\n+            bound_sig,\n+            liberated_sig,\n+        }\n     }\n }\n-"}, {"sha": "645fd1f80babf339dfe3521cd9901234ae31d389", "filename": "src/test/compile-fail/closure-expected-type/expect-fn-supply-fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8a96c97f4972c3d4823105f53e28b88cd9b533e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a96c97f4972c3d4823105f53e28b88cd9b533e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs?ref=e8a96c97f4972c3d4823105f53e28b88cd9b533e", "patch": "@@ -40,14 +40,14 @@ fn expect_free_supply_bound() {\n     // Here, we are given a function whose region is bound at closure level,\n     // but we expect one bound in the argument. Error results.\n     with_closure_expecting_fn_with_free_region(|x: fn(&u32), y| {});\n-    //~^ ERROR mismatched types\n+    //~^ ERROR type mismatch in closure arguments\n }\n \n fn expect_bound_supply_free_from_fn<'x>(x: &'x u32) {\n     // Here, we are given a `fn(&u32)` but we expect a `fn(&'x\n     // u32)`. In principle, this could be ok, but we demand equality.\n     with_closure_expecting_fn_with_bound_region(|x: fn(&'x u32), y| {});\n-    //~^ ERROR mismatched types\n+    //~^ ERROR type mismatch in closure arguments\n }\n \n fn expect_bound_supply_free_from_closure() {\n@@ -56,7 +56,7 @@ fn expect_bound_supply_free_from_closure() {\n     // the argument level.\n     type Foo<'a> = fn(&'a u32);\n     with_closure_expecting_fn_with_bound_region(|_x: Foo<'_>, y| {});\n-    //~^ ERROR mismatched types\n+    //~^ ERROR type mismatch in closure arguments\n }\n \n fn expect_bound_supply_bound<'x>(x: &'x u32) {"}, {"sha": "bef69a4b0b9f86c62e62c318e4c07b38c392a98b", "filename": "src/test/compile-fail/closure-expected-type/expect-infer-var-appearing-twice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8a96c97f4972c3d4823105f53e28b88cd9b533e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-appearing-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8a96c97f4972c3d4823105f53e28b88cd9b533e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-appearing-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-appearing-twice.rs?ref=e8a96c97f4972c3d4823105f53e28b88cd9b533e", "patch": "@@ -22,7 +22,7 @@ fn a() {\n fn b() {\n     // Here we take the supplied types, resulting in an error later on.\n     with_closure(|x: u32, y: i32| {\n-        //~^ ERROR mismatched types\n+        //~^ ERROR type mismatch in closure arguments\n     });\n }\n "}, {"sha": "9de5e8fea0194e15b836a09593635e3eefdb2066", "filename": "src/test/ui/mismatched_types/closure-arg-count.stderr", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e8a96c97f4972c3d4823105f53e28b88cd9b533e/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8a96c97f4972c3d4823105f53e28b88cd9b533e/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr?ref=e8a96c97f4972c3d4823105f53e28b88cd9b533e", "patch": "@@ -14,23 +14,6 @@ error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n    |               |\n    |               expected closure that takes 2 arguments\n \n-error: non-reference pattern used to match a reference (see issue #42640)\n-  --> $DIR/closure-arg-count.rs:17:24\n-   |\n-17 |     [1, 2, 3].sort_by(|(tuple, tuple2)| panic!());\n-   |                        ^^^^^^^^^^^^^^^ help: consider using: `&(tuple, tuple2)`\n-   |\n-   = help: add #![feature(match_default_bindings)] to the crate attributes to enable\n-\n-error[E0308]: mismatched types\n-  --> $DIR/closure-arg-count.rs:17:24\n-   |\n-17 |     [1, 2, 3].sort_by(|(tuple, tuple2)| panic!());\n-   |                        ^^^^^^^^^^^^^^^ expected integral variable, found tuple\n-   |\n-   = note: expected type `{integer}`\n-              found type `(_, _)`\n-\n error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n   --> $DIR/closure-arg-count.rs:17:15\n    |\n@@ -73,5 +56,5 @@ error[E0593]: closure is expected to take a single 2-tuple as argument, but it t\n    |                                                     |\n    |                                                     expected closure that takes a single 2-tuple as argument\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 7 previous errors\n "}]}