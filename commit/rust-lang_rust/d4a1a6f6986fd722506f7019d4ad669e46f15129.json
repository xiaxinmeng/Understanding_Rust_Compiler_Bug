{"sha": "d4a1a6f6986fd722506f7019d4ad669e46f15129", "node_id": "C_kwDOAAsO6NoAKGQ0YTFhNmY2OTg2ZmQ3MjI1MDZmNzAxOWQ0YWQ2NjllNDZmMTUxMjk", "commit": {"author": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-09-11T16:30:18Z"}, "committer": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-09-22T15:25:50Z"}, "message": "Make SetOnce nicer to use", "tree": {"sha": "ef04d12778a311d3cb806279df29da1602de49c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef04d12778a311d3cb806279df29da1602de49c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4a1a6f6986fd722506f7019d4ad669e46f15129", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a1a6f6986fd722506f7019d4ad669e46f15129", "html_url": "https://github.com/rust-lang/rust/commit/d4a1a6f6986fd722506f7019d4ad669e46f15129", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4a1a6f6986fd722506f7019d4ad669e46f15129/comments", "author": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efb20bc85547b48c2de0950fbca1dd5b2ed2a564", "url": "https://api.github.com/repos/rust-lang/rust/commits/efb20bc85547b48c2de0950fbca1dd5b2ed2a564", "html_url": "https://github.com/rust-lang/rust/commit/efb20bc85547b48c2de0950fbca1dd5b2ed2a564"}], "stats": {"total": 65, "additions": 39, "deletions": 26}, "files": [{"sha": "72f20efc8346b8dc3fe7e2f61cc95e8747f7643b", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d4a1a6f6986fd722506f7019d4ad669e46f15129/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a1a6f6986fd722506f7019d4ad669e46f15129/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=d4a1a6f6986fd722506f7019d4ad669e46f15129", "patch": "@@ -18,6 +18,8 @@ use syn::{\n };\n use synstructure::{BindingInfo, Structure};\n \n+use super::utils::SpannedOption;\n+\n /// What kind of diagnostic is being derived - a fatal/error/warning or a lint?\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub(crate) enum DiagnosticDeriveKind {\n@@ -40,10 +42,10 @@ pub(crate) struct DiagnosticDeriveBuilder {\n     pub kind: DiagnosticDeriveKind,\n     /// Slug is a mandatory part of the struct attribute as corresponds to the Fluent message that\n     /// has the actual diagnostic message.\n-    pub slug: Option<(Path, proc_macro::Span)>,\n+    pub slug: SpannedOption<Path>,\n     /// Error codes are a optional part of the struct attribute - this is only set to detect\n     /// multiple specifications.\n-    pub code: Option<(String, proc_macro::Span)>,\n+    pub code: SpannedOption<String>,\n }\n \n impl HasFieldMap for DiagnosticDeriveBuilder {\n@@ -191,7 +193,7 @@ impl DiagnosticDeriveBuilder {\n             match nested_attr {\n                 NestedMeta::Meta(Meta::Path(path)) => {\n                     if is_diag {\n-                        self.slug.set_once((path.clone(), span));\n+                        self.slug.set_once(path.clone(), span);\n                     } else {\n                         let fn_name = proc_macro2::Ident::new(name, attr.span());\n                         return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::#path); });\n@@ -224,8 +226,8 @@ impl DiagnosticDeriveBuilder {\n                 let span = s.span().unwrap();\n                 match nested_name.as_str() {\n                     \"code\" => {\n-                        self.code.set_once((s.value(), span));\n-                        let code = &self.code.as_ref().map(|(v, _)| v);\n+                        self.code.set_once(s.value(), span);\n+                        let code = &self.code.value_ref();\n                         tokens.push(quote! {\n                             #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n                         });\n@@ -476,10 +478,10 @@ impl DiagnosticDeriveBuilder {\n                     match nested_name {\n                         \"code\" => {\n                             let formatted_str = self.build_format(&s.value(), s.span());\n-                            code.set_once((formatted_str, span));\n+                            code.set_once(formatted_str, span);\n                         }\n                         \"applicability\" => match Applicability::from_str(&s.value()) {\n-                            Ok(v) => applicability.set_once((quote! { #v }, span)),\n+                            Ok(v) => applicability.set_once(quote! { #v }, span),\n                             Err(()) => {\n                                 span_err(span, \"invalid applicability\").emit();\n                             }\n@@ -546,7 +548,7 @@ impl DiagnosticDeriveBuilder {\n     fn span_and_applicability_of_ty(\n         &self,\n         info: FieldInfo<'_>,\n-    ) -> Result<(TokenStream, Option<(TokenStream, proc_macro::Span)>), DiagnosticDeriveError> {\n+    ) -> Result<(TokenStream, SpannedOption<TokenStream>), DiagnosticDeriveError> {\n         match &info.ty {\n             // If `ty` is `Span` w/out applicability, then use `Applicability::Unspecified`.\n             ty @ Type::Path(..) if type_matches_path(ty, &[\"rustc_span\", \"Span\"]) => {\n@@ -570,9 +572,9 @@ impl DiagnosticDeriveBuilder {\n \n                 for (idx, elem) in tup.elems.iter().enumerate() {\n                     if type_matches_path(elem, &[\"rustc_span\", \"Span\"]) {\n-                        span_idx.set_once((syn::Index::from(idx), elem.span().unwrap()));\n+                        span_idx.set_once(syn::Index::from(idx), elem.span().unwrap());\n                     } else if type_matches_path(elem, &[\"rustc_errors\", \"Applicability\"]) {\n-                        applicability_idx.set_once((syn::Index::from(idx), elem.span().unwrap()));\n+                        applicability_idx.set_once(syn::Index::from(idx), elem.span().unwrap());\n                     } else {\n                         type_err(&elem.span())?;\n                     }"}, {"sha": "9116dd186f96dc1042f2649e8a91e9a0c6c6af2b", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d4a1a6f6986fd722506f7019d4ad669e46f15129/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a1a6f6986fd722506f7019d4ad669e46f15129/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=d4a1a6f6986fd722506f7019d4ad669e46f15129", "patch": "@@ -15,6 +15,8 @@ use std::str::FromStr;\n use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n+use super::utils::SpannedOption;\n+\n /// Which kind of suggestion is being created?\n #[derive(Clone, Copy)]\n enum SubdiagnosticSuggestionKind {\n@@ -195,10 +197,10 @@ struct SubdiagnosticDeriveBuilder<'a> {\n     fields: HashMap<String, TokenStream>,\n \n     /// Identifier for the binding to the `#[primary_span]` field.\n-    span_field: Option<(proc_macro2::Ident, proc_macro::Span)>,\n+    span_field: SpannedOption<proc_macro2::Ident>,\n     /// If a suggestion, the identifier for the binding to the `#[applicability]` field or a\n     /// `rustc_errors::Applicability::*` variant directly.\n-    applicability: Option<(TokenStream, proc_macro::Span)>,\n+    applicability: SpannedOption<TokenStream>,\n \n     /// Set to true when a `#[suggestion_part]` field is encountered, used to generate an error\n     /// during finalization if still `false`.\n@@ -283,7 +285,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n             if let Some(nested_attr) = nested_iter.next() {\n                 match nested_attr {\n                     NestedMeta::Meta(Meta::Path(path)) => {\n-                        slug.set_once((path.clone(), span));\n+                        slug.set_once(path.clone(), span);\n                     }\n                     NestedMeta::Meta(meta @ Meta::NameValue(_))\n                         if matches!(\n@@ -326,7 +328,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                     \"code\" => {\n                         if matches!(kind, SubdiagnosticKind::Suggestion { .. }) {\n                             let formatted_str = self.build_format(&value.value(), value.span());\n-                            code.set_once((formatted_str, span));\n+                            code.set_once(formatted_str, span);\n                         } else {\n                             span_err(\n                                 span,\n@@ -349,7 +351,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                                     span_err(span, \"invalid applicability\").emit();\n                                     Applicability::Unspecified\n                                 });\n-                            self.applicability.set_once((quote! { #value }, span));\n+                            self.applicability.set_once(quote! { #value }, span);\n                         } else {\n                             span_err(\n                                 span,\n@@ -485,7 +487,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                 report_error_if_not_applied_to_span(attr, &info)?;\n \n                 let binding = info.binding.binding.clone();\n-                self.span_field.set_once((binding, span));\n+                self.span_field.set_once(binding, span);\n \n                 Ok(quote! {})\n             }\n@@ -509,7 +511,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                     report_error_if_not_applied_to_applicability(attr, &info)?;\n \n                     let binding = info.binding.binding.clone();\n-                    self.applicability.set_once((quote! { #binding }, span));\n+                    self.applicability.set_once(quote! { #binding }, span);\n                 } else {\n                     span_err(span, \"`#[applicability]` is only valid on suggestions\").emit();\n                 }\n@@ -577,7 +579,7 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n                     match nested_name {\n                         \"code\" => {\n                             let formatted_str = self.build_format(&value.value(), value.span());\n-                            code.set_once((formatted_str, span));\n+                            code.set_once(formatted_str, span);\n                         }\n                         _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n                             diag.help(\"`code` is the only valid nested attribute\")\n@@ -635,11 +637,12 @@ impl<'a> SubdiagnosticDeriveBuilder<'a> {\n             .map(|binding| self.generate_field_attr_code(binding, kind_stats))\n             .collect();\n \n-        let span_field = self.span_field.as_ref().map(|(span, _)| span);\n-        let applicability = self.applicability.take().map_or_else(\n-            || quote! { rustc_errors::Applicability::Unspecified },\n-            |(applicability, _)| applicability,\n-        );\n+        let span_field = self.span_field.value_ref();\n+        let applicability = self\n+            .applicability\n+            .take()\n+            .value()\n+            .unwrap_or_else(|| quote! { rustc_errors::Applicability::Unspecified });\n \n         let diag = &self.diag;\n         let mut calls = TokenStream::new();"}, {"sha": "3efcd216d1931f4f218cb1e3bba212bbaa73910f", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4a1a6f6986fd722506f7019d4ad669e46f15129/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a1a6f6986fd722506f7019d4ad669e46f15129/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=d4a1a6f6986fd722506f7019d4ad669e46f15129", "patch": "@@ -172,13 +172,17 @@ pub(crate) struct FieldInfo<'a> {\n /// Small helper trait for abstracting over `Option` fields that contain a value and a `Span`\n /// for error reporting if they are set more than once.\n pub(crate) trait SetOnce<T> {\n-    fn set_once(&mut self, _: (T, Span));\n+    fn set_once(&mut self, value: T, span: Span);\n \n     fn value(self) -> Option<T>;\n+    fn value_ref(&self) -> Option<&T>;\n }\n \n-impl<T> SetOnce<T> for Option<(T, Span)> {\n-    fn set_once(&mut self, (value, span): (T, Span)) {\n+/// An [`Option<T>`] that keeps track of the span that caused it to be set; used with [`SetOnce`].\n+pub(super) type SpannedOption<T> = Option<(T, Span)>;\n+\n+impl<T> SetOnce<T> for SpannedOption<T> {\n+    fn set_once(&mut self, value: T, span: Span) {\n         match self {\n             None => {\n                 *self = Some((value, span));\n@@ -194,6 +198,10 @@ impl<T> SetOnce<T> for Option<(T, Span)> {\n     fn value(self) -> Option<T> {\n         self.map(|(v, _)| v)\n     }\n+\n+    fn value_ref(&self) -> Option<&T> {\n+        self.as_ref().map(|(v, _)| v)\n+    }\n }\n \n pub(crate) trait HasFieldMap {"}]}