{"sha": "a9f2c5a7b27e929061117095ae6f2ec5eb2a1b4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZjJjNWE3YjI3ZTkyOTA2MTExNzA5NWFlNmYyZWM1ZWIyYTFiNGQ=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-23T09:22:45Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-16T19:09:05Z"}, "message": "Fix sign conversion arithmetic errors", "tree": {"sha": "3eee7a5bd9ee675a977f15876461c63bbea5b4f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3eee7a5bd9ee675a977f15876461c63bbea5b4f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9f2c5a7b27e929061117095ae6f2ec5eb2a1b4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f2c5a7b27e929061117095ae6f2ec5eb2a1b4d", "html_url": "https://github.com/rust-lang/rust/commit/a9f2c5a7b27e929061117095ae6f2ec5eb2a1b4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9f2c5a7b27e929061117095ae6f2ec5eb2a1b4d/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4af3b015f7192d4dab33b8d4ee984b7b258037e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4af3b015f7192d4dab33b8d4ee984b7b258037e", "html_url": "https://github.com/rust-lang/rust/commit/f4af3b015f7192d4dab33b8d4ee984b7b258037e"}], "stats": {"total": 77, "additions": 44, "deletions": 33}, "files": [{"sha": "ceb065cc0c8772dce3b46c7e34f2befbb3666ee9", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a9f2c5a7b27e929061117095ae6f2ec5eb2a1b4d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f2c5a7b27e929061117095ae6f2ec5eb2a1b4d/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=a9f2c5a7b27e929061117095ae6f2ec5eb2a1b4d", "patch": "@@ -471,9 +471,9 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         }\n         ty::TyInt(_) if exhaustive_integer_patterns => {\n             let size = cx.tcx.layout_of(ty::ParamEnv::reveal_all().and(pcx.ty))\n-                             .unwrap().size.bits() as i128;\n-            let min = (1i128 << (size - 1)).wrapping_neg();\n-            let max = (1i128 << (size - 1)).wrapping_sub(1);\n+                             .unwrap().size.bits() as u128;\n+            let min = (1u128 << (size - 1)).wrapping_neg();\n+            let max = (1u128 << (size - 1)).wrapping_sub(1);\n             value_constructors = true;\n             vec![ConstantRange(ty::Const::from_bits(cx.tcx, min as u128, pcx.ty),\n                                ty::Const::from_bits(cx.tcx, max as u128, pcx.ty),\n@@ -603,13 +603,17 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n }\n \n /// An inclusive interval, used for precise integer exhaustiveness checking.\n+/// `Interval`s always store a contiguous range of integers. That means that\n+/// signed integers are offset (see `offset_sign`) by their minimum value.\n struct Interval<'tcx> {\n     pub range: RangeInclusive<u128>,\n     pub ty: Ty<'tcx>,\n }\n \n impl<'tcx> Interval<'tcx> {\n-    fn from_ctor(ctor: &Constructor<'tcx>) -> Option<Interval<'tcx>> {\n+    fn from_ctor(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                 ctor: &Constructor<'tcx>)\n+                 -> Option<Interval<'tcx>> {\n         match ctor {\n             ConstantRange(lo, hi, end) => {\n                 assert_eq!(lo.ty, hi.ty);\n@@ -618,7 +622,7 @@ impl<'tcx> Interval<'tcx> {\n                     if let Some(hi) = hi.assert_bits(ty) {\n                         // Perform a shift if the underlying types are signed,\n                         // which makes the interval arithmetic simpler.\n-                        let (lo, hi) = Interval::offset_sign(ty, lo..=hi, true);\n+                        let (lo, hi) = Self::offset_sign(tcx, ty, lo..=hi, true);\n                         // Make sure the interval is well-formed.\n                         return if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n                             None\n@@ -632,38 +636,45 @@ impl<'tcx> Interval<'tcx> {\n             }\n             ConstantValue(val) => {\n                 let ty = val.ty;\n-                val.assert_bits(ty).map(|val| Interval { range: val..=val, ty })\n+                if let Some(val) = val.assert_bits(ty) {\n+                    let (lo, hi) = Self::offset_sign(tcx, ty, val..=val, true);\n+                    Some(Interval { range: lo..=hi, ty })\n+                } else {\n+                    None\n+                }\n             }\n             Single | Variant(_) | Slice(_) => {\n                 None\n             }\n         }\n     }\n \n-    fn offset_sign(ty: Ty<'tcx>, range: RangeInclusive<u128>, forwards: bool) -> (u128, u128) {\n+    fn offset_sign(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                   ty: Ty<'tcx>,\n+                   range: RangeInclusive<u128>,\n+                   encode: bool)\n+                   -> (u128, u128) {\n+        // We ensure that all integer values are contiguous: that is, that their\n+        // minimum value is represented by 0, so that comparisons and increments/\n+        // decrements on interval endpoints work consistently whether the endpoints\n+        // are signed or unsigned.\n         let (lo, hi) = range.into_inner();\n-        use syntax::ast::IntTy::*;\n         match ty.sty {\n-            ty::TyInt(int_ty) => {\n-                macro_rules! offset_sign_for_ty {\n-                    ($ity:ident, $uty:ty) => {{\n-                        let min = Wrapping($ity::MIN as $uty);\n-                        if forwards {\n-                            ((Wrapping(lo as $uty) + min).0 as u128,\n-                             (Wrapping(hi as $uty) + min).0 as u128)\n-                        } else {\n-                            ((Wrapping(lo as $uty) + min).0 as $ity as u128,\n-                             (Wrapping(hi as $uty) + min).0 as $ity as u128)\n-                        }\n-                    }}\n-                }\n-                match int_ty {\n-                    Isize => offset_sign_for_ty!(isize, usize),\n-                    I8    => offset_sign_for_ty!(i8, u8),\n-                    I16   => offset_sign_for_ty!(i16, u16),\n-                    I32   => offset_sign_for_ty!(i32, u32),\n-                    I64   => offset_sign_for_ty!(i64, u64),\n-                    I128  => offset_sign_for_ty!(i128, u128),\n+            ty::TyInt(_) => {\n+                let size = tcx.layout_of(ty::ParamEnv::reveal_all().and(ty))\n+                                 .unwrap().size.bits() as u128;\n+                let min = (1u128 << (size - 1)).wrapping_neg();\n+                let shift = 1u128.overflowing_shl(size as u32);\n+                let mask = shift.0.wrapping_sub(1 + (shift.1 as u128));\n+                if encode {\n+                    let offset = |x: u128| x.wrapping_sub(min) & mask;\n+                    (offset(lo), offset(hi))\n+                } else {\n+                    let offset = |x: u128| {\n+                        interpret::sign_extend(tcx, x.wrapping_add(min) & mask, ty)\n+                                  .expect(\"layout error for TyInt\")\n+                    };\n+                    (offset(lo), offset(hi))\n                 }\n             }\n             ty::TyUint(_) | ty::TyChar => {\n@@ -685,10 +696,10 @@ fn ranges_subtract_pattern<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                      pat_ctor: &Constructor<'tcx>,\n                                      ranges: Vec<Constructor<'tcx>>)\n                                      -> Vec<Constructor<'tcx>> {\n-    if let Some(pat_interval) = Interval::from_ctor(pat_ctor) {\n+    if let Some(pat_interval) = Interval::from_ctor(cx.tcx, pat_ctor) {\n         let mut remaining_ranges = vec![];\n         let mut ranges: Vec<_> = ranges.into_iter().filter_map(|r| {\n-            Interval::from_ctor(&r).map(|i| i.into_inner())\n+            Interval::from_ctor(cx.tcx, &r).map(|i| i.into_inner())\n         }).collect();\n         let ty = pat_interval.ty;\n         let (pat_interval_lo, pat_interval_hi) = pat_interval.into_inner();\n@@ -712,7 +723,7 @@ fn ranges_subtract_pattern<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         }\n         // Convert the remaining ranges from pairs to inclusive `ConstantRange`s.\n         remaining_ranges.into_iter().map(|r| {\n-            let (lo, hi) = Interval::offset_sign(ty, r, false);\n+            let (lo, hi) = Interval::offset_sign(cx.tcx, ty, r, false);\n             ConstantRange(ty::Const::from_bits(cx.tcx, lo, ty),\n                           ty::Const::from_bits(cx.tcx, hi, ty),\n                           RangeEnd::Included)"}, {"sha": "3d308a9e5d1e6b1cb0332d6814b04a4fd2c48d35", "filename": "src/test/ui/exhaustive_integer_patterns.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9f2c5a7b27e929061117095ae6f2ec5eb2a1b4d/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9f2c5a7b27e929061117095ae6f2ec5eb2a1b4d/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr?ref=a9f2c5a7b27e929061117095ae6f2ec5eb2a1b4d", "patch": "@@ -28,11 +28,11 @@ error: unreachable pattern\n LL |         -2..=20 => {} //~ ERROR unreachable pattern\n    |         ^^^^^^^\n \n-error[E0004]: non-exhaustive patterns: `-128i8...-6i8` and `122i8...127i8` not covered\n+error[E0004]: non-exhaustive patterns: `-128i8...-8i8`, `-6i8`, `121i8...124i8` and 1 more not covered\n   --> $DIR/exhaustive_integer_patterns.rs:50:11\n    |\n LL |     match x { //~ ERROR non-exhaustive patterns\n-   |           ^ patterns `-128i8...-6i8` and `122i8...127i8` not covered\n+   |           ^ patterns `-128i8...-8i8`, `-6i8`, `121i8...124i8` and 1 more not covered\n \n error[E0004]: non-exhaustive patterns: `-128i8` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:99:11"}]}