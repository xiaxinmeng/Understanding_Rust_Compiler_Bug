{"sha": "c990e2922ac7ff27e9a7516e9ac92cac5989c9e0", "node_id": "C_kwDOAAsO6NoAKGM5OTBlMjkyMmFjN2ZmMjdlOWE3NTE2ZTlhYzkyY2FjNTk4OWM5ZTA", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-07-05T20:03:51Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-07-17T15:14:07Z"}, "message": "Don't suggest using auto deref for block expressions", "tree": {"sha": "21cc787be881707ef9de7aba46e71b6051a976c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21cc787be881707ef9de7aba46e71b6051a976c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c990e2922ac7ff27e9a7516e9ac92cac5989c9e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c990e2922ac7ff27e9a7516e9ac92cac5989c9e0", "html_url": "https://github.com/rust-lang/rust/commit/c990e2922ac7ff27e9a7516e9ac92cac5989c9e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c990e2922ac7ff27e9a7516e9ac92cac5989c9e0/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a4e4575ede9eedbb3ce84851c7b3df1e6e3812a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a4e4575ede9eedbb3ce84851c7b3df1e6e3812a", "html_url": "https://github.com/rust-lang/rust/commit/3a4e4575ede9eedbb3ce84851c7b3df1e6e3812a"}], "stats": {"total": 233, "additions": 167, "deletions": 66}, "files": [{"sha": "b87d41455d9b63492a129ea9e69a3e1b93dc87dd", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 94, "deletions": 33, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/c990e2922ac7ff27e9a7516e9ac92cac5989c9e0/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c990e2922ac7ff27e9a7516e9ac92cac5989c9e0/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=c990e2922ac7ff27e9a7516e9ac92cac5989c9e0", "patch": "@@ -17,7 +17,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span, Symbol};\n+use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n declare_clippy_lint! {\n@@ -609,26 +609,29 @@ enum Position {\n     Postfix,\n     Deref,\n     /// Any other location which will trigger auto-deref to a specific time.\n-    DerefStable(i8),\n+    /// Contains the precedence of the parent expression and whether the target type is sized.\n+    DerefStable(i8, bool),\n     /// Any other location which will trigger auto-reborrowing.\n+    /// Contains the precedence of the parent expression.\n     ReborrowStable(i8),\n+    /// Contains the precedence of the parent expression.\n     Other(i8),\n }\n impl Position {\n     fn is_deref_stable(self) -> bool {\n-        matches!(self, Self::DerefStable(_))\n+        matches!(self, Self::DerefStable(..))\n     }\n \n     fn is_reborrow_stable(self) -> bool {\n-        matches!(self, Self::DerefStable(_) | Self::ReborrowStable(_))\n+        matches!(self, Self::DerefStable(..) | Self::ReborrowStable(_))\n     }\n \n     fn can_auto_borrow(self) -> bool {\n         matches!(self, Self::MethodReceiver | Self::FieldAccess(_) | Self::Callee)\n     }\n \n     fn lint_explicit_deref(self) -> bool {\n-        matches!(self, Self::Other(_) | Self::DerefStable(_) | Self::ReborrowStable(_))\n+        matches!(self, Self::Other(_) | Self::DerefStable(..) | Self::ReborrowStable(_))\n     }\n \n     fn precedence(self) -> i8 {\n@@ -639,7 +642,7 @@ impl Position {\n             | Self::FieldAccess(_)\n             | Self::Postfix => PREC_POSTFIX,\n             Self::Deref => PREC_PREFIX,\n-            Self::DerefStable(p) | Self::ReborrowStable(p) | Self::Other(p) => p,\n+            Self::DerefStable(p, _) | Self::ReborrowStable(p) | Self::Other(p) => p,\n         }\n     }\n }\n@@ -659,7 +662,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n         }\n         match parent {\n             Node::Local(Local { ty: Some(ty), span, .. }) if span.ctxt() == ctxt => {\n-                Some(binding_ty_auto_deref_stability(ty, precedence))\n+                Some(binding_ty_auto_deref_stability(cx, ty, precedence))\n             },\n             Node::Item(&Item {\n                 kind: ItemKind::Static(..) | ItemKind::Const(..),\n@@ -680,8 +683,11 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                 ..\n             }) if span.ctxt() == ctxt => {\n                 let ty = cx.tcx.type_of(def_id);\n-                Some(if ty.is_ref() {\n-                    Position::DerefStable(precedence)\n+                Some(if let ty::Ref(_, ty, _) = *ty.kind() {\n+                    Position::DerefStable(\n+                        precedence,\n+                        ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                    )\n                 } else {\n                     Position::Other(precedence)\n                 })\n@@ -705,13 +711,20 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                 span,\n                 ..\n             }) if span.ctxt() == ctxt => {\n-                let output = cx.tcx.fn_sig(def_id.to_def_id()).skip_binder().output();\n-                Some(if !output.is_ref() {\n-                    Position::Other(precedence)\n-                } else if output.has_placeholders() || output.has_opaque_types() {\n-                    Position::ReborrowStable(precedence)\n+                let output = cx\n+                    .tcx\n+                    .erase_late_bound_regions(cx.tcx.fn_sig(def_id.to_def_id()).output());\n+                Some(if let ty::Ref(_, ty, _) = *output.kind() {\n+                    if ty.has_placeholders() || ty.has_opaque_types() {\n+                        Position::ReborrowStable(precedence)\n+                    } else {\n+                        Position::DerefStable(\n+                            precedence,\n+                            ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                        )\n+                    }\n                 } else {\n-                    Position::DerefStable(precedence)\n+                    Position::Other(precedence)\n                 })\n             },\n \n@@ -725,21 +738,24 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                         }) = cx.tcx.hir().get(owner_id)\n                         {\n                             match fn_decl.output {\n-                                FnRetTy::Return(ty) => binding_ty_auto_deref_stability(ty, precedence),\n+                                FnRetTy::Return(ty) => binding_ty_auto_deref_stability(cx, ty, precedence),\n                                 FnRetTy::DefaultReturn(_) => Position::Other(precedence),\n                             }\n                         } else {\n                             let output = cx\n                                 .tcx\n-                                .fn_sig(cx.tcx.hir().local_def_id(owner_id))\n-                                .skip_binder()\n-                                .output();\n-                            if !output.is_ref() {\n-                                Position::Other(precedence)\n-                            } else if output.has_placeholders() || output.has_opaque_types() {\n-                                Position::ReborrowStable(precedence)\n+                                .erase_late_bound_regions(cx.tcx.fn_sig(cx.tcx.hir().local_def_id(owner_id)).output());\n+                            if let ty::Ref(_, ty, _) = *output.kind() {\n+                                if ty.has_placeholders() || ty.has_opaque_types() {\n+                                    Position::ReborrowStable(precedence)\n+                                } else {\n+                                    Position::DerefStable(\n+                                        precedence,\n+                                        ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                                    )\n+                                }\n                             } else {\n-                                Position::DerefStable(precedence)\n+                                Position::Other(precedence)\n                             }\n                         },\n                     )\n@@ -755,8 +771,8 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                     .map(|(hir_ty, ty)| match hir_ty {\n                         // Type inference for closures can depend on how they're called. Only go by the explicit\n                         // types here.\n-                        Some(ty) => binding_ty_auto_deref_stability(ty, precedence),\n-                        None => param_auto_deref_stability(ty.skip_binder(), precedence),\n+                        Some(ty) => binding_ty_auto_deref_stability(cx, ty, precedence),\n+                        None => param_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence),\n                     }),\n                 ExprKind::MethodCall(_, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n@@ -797,7 +813,11 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                                 Position::MethodReceiver\n                             }\n                         } else {\n-                            param_auto_deref_stability(cx.tcx.fn_sig(id).skip_binder().inputs()[i], precedence)\n+                            param_auto_deref_stability(\n+                                cx,\n+                                cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n+                                precedence,\n+                            )\n                         }\n                     })\n                 },\n@@ -808,7 +828,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n                         .find(|f| f.expr.hir_id == child_id)\n                         .zip(variant)\n                         .and_then(|(field, variant)| variant.fields.iter().find(|f| f.name == field.ident.name))\n-                        .map(|field| param_auto_deref_stability(cx.tcx.type_of(field.did), precedence))\n+                        .map(|field| param_auto_deref_stability(cx, cx.tcx.type_of(field.did), precedence))\n                 },\n                 ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess(name.name)),\n                 ExprKind::Unary(UnOp::Deref, child) if child.hir_id == e.hir_id => Some(Position::Deref),\n@@ -840,7 +860,7 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &\n //\n // Here `y1` and `y2` would resolve to different types, so the type `&Box<_>` is not stable when\n // switching to auto-dereferencing.\n-fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>, precedence: i8) -> Position {\n+fn binding_ty_auto_deref_stability(cx: &LateContext<'_>, ty: &hir::Ty<'_>, precedence: i8) -> Position {\n     let TyKind::Rptr(_, ty) = &ty.kind else {\n         return Position::Other(precedence);\n     };\n@@ -870,7 +890,13 @@ fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>, precedence: i8) -> Position\n                 {\n                     Position::ReborrowStable(precedence)\n                 } else {\n-                    Position::DerefStable(precedence)\n+                    Position::DerefStable(\n+                        precedence,\n+                        cx\n+                            .typeck_results()\n+                            .node_type(ty.ty.hir_id)\n+                            .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                    )\n                 }\n             },\n             TyKind::Slice(_)\n@@ -880,7 +906,13 @@ fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>, precedence: i8) -> Position\n             | TyKind::Tup(_)\n             | TyKind::Ptr(_)\n             | TyKind::TraitObject(..)\n-            | TyKind::Path(_) => Position::DerefStable(precedence),\n+            | TyKind::Path(_) => Position::DerefStable(\n+                precedence,\n+                cx\n+                    .typeck_results()\n+                    .node_type(ty.ty.hir_id)\n+                    .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+            ),\n             TyKind::OpaqueDef(..)\n             | TyKind::Infer\n             | TyKind::Typeof(..)\n@@ -921,7 +953,7 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n }\n \n // Checks whether a type is stable when switching to auto dereferencing,\n-fn param_auto_deref_stability(ty: Ty<'_>, precedence: i8) -> Position {\n+fn param_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedence: i8) -> Position {\n     let ty::Ref(_, mut ty, _) = *ty.kind() else {\n         return Position::Other(precedence);\n     };\n@@ -960,7 +992,10 @@ fn param_auto_deref_stability(ty: Ty<'_>, precedence: i8) -> Position {\n             | ty::GeneratorWitness(..)\n             | ty::Never\n             | ty::Tuple(_)\n-            | ty::Projection(_) => Position::DerefStable(precedence),\n+            | ty::Projection(_) => Position::DerefStable(\n+                precedence,\n+                ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+            ),\n         };\n     }\n }\n@@ -1040,6 +1075,19 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n             });\n         },\n         State::ExplicitDeref { deref_span_id } => {\n+            if matches!(\n+                expr.kind,\n+                ExprKind::Block(..)\n+                    | ExprKind::ConstBlock(_)\n+                    | ExprKind::If(..)\n+                    | ExprKind::Loop(..)\n+                    | ExprKind::Match(..)\n+            ) && matches!(data.position, Position::DerefStable(_, true))\n+            {\n+                // Rustc bug: auto deref doesn't work on block expression when targeting sized types.\n+                return;\n+            }\n+\n             let (span, hir_id, precedence) = if let Some((span, hir_id)) = deref_span_id\n                 && !cx.typeck_results().expr_ty(expr).is_ref()\n             {\n@@ -1067,6 +1115,19 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n             );\n         },\n         State::ExplicitDerefField { .. } => {\n+            if matches!(\n+                expr.kind,\n+                ExprKind::Block(..)\n+                    | ExprKind::ConstBlock(_)\n+                    | ExprKind::If(..)\n+                    | ExprKind::Loop(..)\n+                    | ExprKind::Match(..)\n+            ) && matches!(data.position, Position::DerefStable(_, true))\n+            {\n+                // Rustc bug: auto deref doesn't work on block expression when targeting sized types.\n+                return;\n+            }\n+\n             span_lint_hir_and_then(\n                 cx,\n                 EXPLICIT_AUTO_DEREF,"}, {"sha": "327cfbaf32428f6012d55bab79c8e6fd2a02d001", "filename": "tests/ui/explicit_auto_deref.fixed", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c990e2922ac7ff27e9a7516e9ac92cac5989c9e0/tests%2Fui%2Fexplicit_auto_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c990e2922ac7ff27e9a7516e9ac92cac5989c9e0/tests%2Fui%2Fexplicit_auto_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.fixed?ref=c990e2922ac7ff27e9a7516e9ac92cac5989c9e0", "patch": "@@ -67,6 +67,7 @@ fn main() {\n     let s = String::new();\n \n     let _: &str = &s;\n+    let _: &str = &{ String::new() };\n     let _ = &*s; // Don't lint. Inferred type would change.\n     let _: &_ = &*s; // Don't lint. Inferred type would change.\n \n@@ -215,4 +216,20 @@ fn main() {\n     let s = &\"str\";\n     let _ = || return *s;\n     let _ = || -> &'static str { return s };\n+\n+    struct X;\n+    struct Y(X);\n+    impl core::ops::Deref for Y {\n+        type Target = X;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    let _: &X = &*{ Y(X) };\n+    let _: &X = &*match 0 {\n+        #[rustfmt::skip]\n+        0 => { Y(X) },\n+        _ => panic!(),\n+    };\n+    let _: &X = &*if true { Y(X) } else { panic!() };\n }"}, {"sha": "471a03d60a96b2e2bdb475fe9a0a8becf4118837", "filename": "tests/ui/explicit_auto_deref.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c990e2922ac7ff27e9a7516e9ac92cac5989c9e0/tests%2Fui%2Fexplicit_auto_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c990e2922ac7ff27e9a7516e9ac92cac5989c9e0/tests%2Fui%2Fexplicit_auto_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.rs?ref=c990e2922ac7ff27e9a7516e9ac92cac5989c9e0", "patch": "@@ -67,6 +67,7 @@ fn main() {\n     let s = String::new();\n \n     let _: &str = &*s;\n+    let _: &str = &*{ String::new() };\n     let _ = &*s; // Don't lint. Inferred type would change.\n     let _: &_ = &*s; // Don't lint. Inferred type would change.\n \n@@ -215,4 +216,20 @@ fn main() {\n     let s = &\"str\";\n     let _ = || return *s;\n     let _ = || -> &'static str { return *s };\n+\n+    struct X;\n+    struct Y(X);\n+    impl core::ops::Deref for Y {\n+        type Target = X;\n+        fn deref(&self) -> &Self::Target {\n+            &self.0\n+        }\n+    }\n+    let _: &X = &*{ Y(X) };\n+    let _: &X = &*match 0 {\n+        #[rustfmt::skip]\n+        0 => { Y(X) },\n+        _ => panic!(),\n+    };\n+    let _: &X = &*if true { Y(X) } else { panic!() };\n }"}, {"sha": "d1bc51f5bddf7a2f7058fe17ea41d0ffefb05f0a", "filename": "tests/ui/explicit_auto_deref.stderr", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c990e2922ac7ff27e9a7516e9ac92cac5989c9e0/tests%2Fui%2Fexplicit_auto_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c990e2922ac7ff27e9a7516e9ac92cac5989c9e0/tests%2Fui%2Fexplicit_auto_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.stderr?ref=c990e2922ac7ff27e9a7516e9ac92cac5989c9e0", "patch": "@@ -7,196 +7,202 @@ LL |     let _: &str = &*s;\n    = note: `-D clippy::explicit-auto-deref` implied by `-D warnings`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:73:12\n+  --> $DIR/explicit_auto_deref.rs:70:20\n+   |\n+LL |     let _: &str = &*{ String::new() };\n+   |                    ^^^^^^^^^^^^^^^^^^ help: try this: `{ String::new() }`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:74:12\n    |\n LL |     f_str(&*s);\n    |            ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:77:14\n+  --> $DIR/explicit_auto_deref.rs:78:14\n    |\n LL |     f_str_t(&*s, &*s); // Don't lint second param.\n    |              ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:80:25\n+  --> $DIR/explicit_auto_deref.rs:81:25\n    |\n LL |     let _: &Box<i32> = &**b;\n    |                         ^^^ help: try this: `b`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:86:8\n+  --> $DIR/explicit_auto_deref.rs:87:8\n    |\n LL |     c(&*s);\n    |        ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:92:9\n+  --> $DIR/explicit_auto_deref.rs:93:9\n    |\n LL |         &**x\n    |         ^^^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:96:11\n+  --> $DIR/explicit_auto_deref.rs:97:11\n    |\n LL |         { &**x }\n    |           ^^^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:100:9\n+  --> $DIR/explicit_auto_deref.rs:101:9\n    |\n LL |         &**{ x }\n    |         ^^^^^^^^ help: try this: `{ x }`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:104:9\n+  --> $DIR/explicit_auto_deref.rs:105:9\n    |\n LL |         &***x\n    |         ^^^^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:121:13\n+  --> $DIR/explicit_auto_deref.rs:122:13\n    |\n LL |         f1(&*x);\n    |             ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:122:13\n+  --> $DIR/explicit_auto_deref.rs:123:13\n    |\n LL |         f2(&*x);\n    |             ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:123:13\n+  --> $DIR/explicit_auto_deref.rs:124:13\n    |\n LL |         f3(&*x);\n    |             ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:124:28\n+  --> $DIR/explicit_auto_deref.rs:125:28\n    |\n LL |         f4.callable_str()(&*x);\n    |                            ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:125:13\n+  --> $DIR/explicit_auto_deref.rs:126:13\n    |\n LL |         f5(&*x);\n    |             ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:126:13\n+  --> $DIR/explicit_auto_deref.rs:127:13\n    |\n LL |         f6(&*x);\n    |             ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:127:28\n+  --> $DIR/explicit_auto_deref.rs:128:28\n    |\n LL |         f7.callable_str()(&*x);\n    |                            ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:128:26\n+  --> $DIR/explicit_auto_deref.rs:129:26\n    |\n LL |         f8.callable_t()(&*x);\n    |                          ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:129:13\n+  --> $DIR/explicit_auto_deref.rs:130:13\n    |\n LL |         f9(&*x);\n    |             ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:130:14\n+  --> $DIR/explicit_auto_deref.rs:131:14\n    |\n LL |         f10(&*x);\n    |              ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:131:27\n+  --> $DIR/explicit_auto_deref.rs:132:27\n    |\n LL |         f11.callable_t()(&*x);\n    |                           ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:135:17\n+  --> $DIR/explicit_auto_deref.rs:136:17\n    |\n LL |     let _ = S1(&*s);\n    |                 ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:140:22\n+  --> $DIR/explicit_auto_deref.rs:141:22\n    |\n LL |     let _ = S2 { s: &*s };\n    |                      ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:156:30\n+  --> $DIR/explicit_auto_deref.rs:157:30\n    |\n LL |             let _ = Self::S1(&**s);\n    |                              ^^^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:157:35\n+  --> $DIR/explicit_auto_deref.rs:158:35\n    |\n LL |             let _ = Self::S2 { s: &**s };\n    |                                   ^^^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:160:21\n+  --> $DIR/explicit_auto_deref.rs:161:21\n    |\n LL |     let _ = E1::S1(&*s);\n    |                     ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:161:26\n+  --> $DIR/explicit_auto_deref.rs:162:26\n    |\n LL |     let _ = E1::S2 { s: &*s };\n    |                          ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:179:13\n+  --> $DIR/explicit_auto_deref.rs:180:13\n    |\n LL |     let _ = (*b).foo;\n    |             ^^^^ help: try this: `b`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:180:13\n+  --> $DIR/explicit_auto_deref.rs:181:13\n    |\n LL |     let _ = (**b).foo;\n    |             ^^^^^ help: try this: `b`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:195:19\n+  --> $DIR/explicit_auto_deref.rs:196:19\n    |\n LL |     let _ = f_str(*ref_str);\n    |                   ^^^^^^^^ help: try this: `ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:197:19\n+  --> $DIR/explicit_auto_deref.rs:198:19\n    |\n LL |     let _ = f_str(**ref_ref_str);\n    |                   ^^^^^^^^^^^^^ help: try this: `ref_ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:207:13\n+  --> $DIR/explicit_auto_deref.rs:208:13\n    |\n LL |     f_str(&&*ref_str); // `needless_borrow` will suggest removing both references\n    |             ^^^^^^^^ help: try this: `ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:208:12\n+  --> $DIR/explicit_auto_deref.rs:209:12\n    |\n LL |     f_str(&&**ref_str); // `needless_borrow` will suggest removing only one reference\n    |            ^^^^^^^^^^ help: try this: `ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:217:41\n+  --> $DIR/explicit_auto_deref.rs:218:41\n    |\n LL |     let _ = || -> &'static str { return *s };\n    |                                         ^^ help: try this: `s`\n \n-error: aborting due to 33 previous errors\n+error: aborting due to 34 previous errors\n "}]}