{"sha": "946aea3eb34d1b7f09900e017bb94708e6299d0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NmFlYTNlYjM0ZDFiN2YwOTkwMGUwMTdiYjk0NzA4ZTYyOTlkMGE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-25T07:32:13Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-25T07:32:13Z"}, "message": "Merge #634\n\n634: rename def_id -> def r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "a662d8e9c63835950af45792dd538ce7d30b9251", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a662d8e9c63835950af45792dd538ce7d30b9251"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/946aea3eb34d1b7f09900e017bb94708e6299d0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/946aea3eb34d1b7f09900e017bb94708e6299d0a", "html_url": "https://github.com/rust-lang/rust/commit/946aea3eb34d1b7f09900e017bb94708e6299d0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/946aea3eb34d1b7f09900e017bb94708e6299d0a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "675943712ce92e0ce04e85e6952f50bcbf1ee611", "url": "https://api.github.com/repos/rust-lang/rust/commits/675943712ce92e0ce04e85e6952f50bcbf1ee611", "html_url": "https://github.com/rust-lang/rust/commit/675943712ce92e0ce04e85e6952f50bcbf1ee611"}, {"sha": "0707f65806961028f2be64812869c66020e2a1a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0707f65806961028f2be64812869c66020e2a1a6", "html_url": "https://github.com/rust-lang/rust/commit/0707f65806961028f2be64812869c66020e2a1a6"}], "stats": {"total": 391, "additions": 186, "deletions": 205}, "files": [{"sha": "be80edaf38a0b9b91b051ef0ebea47df1e83d6f7", "filename": "crates/ra_arena/src/map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_arena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_arena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Fmap.rs?ref=946aea3eb34d1b7f09900e017bb94708e6299d0a", "patch": "@@ -29,6 +29,10 @@ impl<ID: ArenaId, T> ArenaMap<ID, T> {\n         self.v.get(Self::to_idx(id)).and_then(|it| it.as_ref())\n     }\n \n+    pub fn get_mut(&mut self, id: ID) -> Option<&mut T> {\n+        self.v.get_mut(Self::to_idx(id)).and_then(|it| it.as_mut())\n+    }\n+\n     pub fn values(&self) -> impl Iterator<Item = &T> {\n         self.v.iter().filter_map(|o| o.as_ref())\n     }"}, {"sha": "a469ad47709ec1e2d9b218ff6a72f8eb813cb7bf", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=946aea3eb34d1b7f09900e017bb94708e6299d0a", "patch": "@@ -165,11 +165,11 @@ impl Module {\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n     pub fn scope(&self, db: &impl HirDatabase) -> ModuleScope {\n-        self.scope_impl(db)\n+        db.item_map(self.krate)[self.module_id].clone()\n     }\n \n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<ModuleDef> {\n-        self.resolve_path_impl(db, path)\n+        db.item_map(self.krate).resolve_path(db, *self, path)\n     }\n \n     pub fn problems(&self, db: &impl HirDatabase) -> Vec<(TreeArc<SyntaxNode>, Problem)> {"}, {"sha": "480ec27bf530e797d32d4fa198702004de28926a", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 3, "deletions": 71, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=946aea3eb34d1b7f09900e017bb94708e6299d0a", "patch": "@@ -2,10 +2,10 @@ use ra_db::FileId;\n use ra_syntax::{ast, SyntaxNode, TreeArc};\n \n use crate::{\n-    Module, ModuleSource, Problem, ModuleDef,\n-    Crate, Name, Path, PathKind, PerNs,\n+    Module, ModuleSource, Problem,\n+    Crate, Name,\n     module_tree::ModuleId,\n-    nameres::{ModuleScope, lower::ImportId},\n+    nameres::{lower::ImportId},\n     db::HirDatabase,\n };\n \n@@ -90,74 +90,6 @@ impl Module {\n         Some(self.with_module_id(parent_id))\n     }\n \n-    /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub(crate) fn scope_impl(&self, db: &impl HirDatabase) -> ModuleScope {\n-        let item_map = db.item_map(self.krate);\n-        item_map.per_module[&self.module_id].clone()\n-    }\n-\n-    pub(crate) fn resolve_path_impl(&self, db: &impl HirDatabase, path: &Path) -> PerNs<ModuleDef> {\n-        let mut curr_per_ns: PerNs<ModuleDef> = PerNs::types(match path.kind {\n-            PathKind::Crate => self.crate_root(db).into(),\n-            PathKind::Self_ | PathKind::Plain => self.clone().into(),\n-            PathKind::Super => {\n-                if let Some(p) = self.parent(db) {\n-                    p.into()\n-                } else {\n-                    return PerNs::none();\n-                }\n-            }\n-            PathKind::Abs => {\n-                // TODO: absolute use is not supported\n-                return PerNs::none();\n-            }\n-        });\n-\n-        for segment in path.segments.iter() {\n-            let curr = match curr_per_ns.as_ref().take_types() {\n-                Some(r) => r,\n-                None => {\n-                    // we still have path segments left, but the path so far\n-                    // didn't resolve in the types namespace => no resolution\n-                    // (don't break here because curr_per_ns might contain\n-                    // something in the value namespace, and it would be wrong\n-                    // to return that)\n-                    return PerNs::none();\n-                }\n-            };\n-            // resolve segment in curr\n-\n-            curr_per_ns = match curr {\n-                ModuleDef::Module(m) => {\n-                    let scope = m.scope(db);\n-                    match scope.get(&segment.name) {\n-                        Some(r) => r.def_id.clone(),\n-                        None => PerNs::none(),\n-                    }\n-                }\n-                ModuleDef::Enum(e) => {\n-                    // enum variant\n-                    let matching_variant = e\n-                        .variants(db)\n-                        .into_iter()\n-                        .find(|(n, _variant)| n == &segment.name);\n-\n-                    match matching_variant {\n-                        Some((_n, variant)) => PerNs::both(variant.into(), (*e).into()),\n-                        None => PerNs::none(),\n-                    }\n-                }\n-                _ => {\n-                    // could be an inherent method call in UFCS form\n-                    // (`Struct::method`), or some other kind of associated\n-                    // item... Which we currently don't handle (TODO)\n-                    PerNs::none()\n-                }\n-            };\n-        }\n-        curr_per_ns\n-    }\n-\n     pub(crate) fn problems_impl(\n         &self,\n         db: &impl HirDatabase,"}, {"sha": "338ed0516a8b606b58224dd2250f19e2fda21d76", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=946aea3eb34d1b7f09900e017bb94708e6299d0a", "patch": "@@ -1,3 +1,4 @@\n-use test_utils::mark;\n-\n-mark!(name_res_works_for_broken_modules);\n+test_utils::marks!(\n+    name_res_works_for_broken_modules\n+    item_map_enum_importing\n+);"}, {"sha": "639726b5eebd2f98dcbd326f24e3e3417f1c527e", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 143, "deletions": 117, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=946aea3eb34d1b7f09900e017bb94708e6299d0a", "patch": "@@ -19,6 +19,8 @@ pub(crate) mod lower;\n use std::sync::Arc;\n \n use ra_db::CrateId;\n+use ra_arena::map::ArenaMap;\n+use test_utils::tested_by;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n@@ -27,16 +29,21 @@ use crate::{\n     HirDatabase, Crate,\n     Name,\n     module_tree::{ModuleId, ModuleTree},\n-//FIXME: deglobify\n-    nameres::lower::*,\n+    nameres::lower::{ImportId, LoweredModule, ImportData},\n };\n \n /// `ItemMap` is the result of name resolution. It contains, for each\n /// module, the set of visible items.\n-// FIXME: currenty we compute item map per source-root. We should do it per crate instead.\n #[derive(Default, Debug, PartialEq, Eq)]\n pub struct ItemMap {\n-    pub per_module: FxHashMap<ModuleId, ModuleScope>,\n+    per_module: ArenaMap<ModuleId, ModuleScope>,\n+}\n+\n+impl std::ops::Index<ModuleId> for ItemMap {\n+    type Output = ModuleScope;\n+    fn index(&self, id: ModuleId) -> &ModuleScope {\n+        &self.per_module[id]\n+    }\n }\n \n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n@@ -58,7 +65,7 @@ impl ModuleScope {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Resolution {\n     /// None for unresolved\n-    pub def_id: PerNs<ModuleDef>,\n+    pub def: PerNs<ModuleDef>,\n     /// ident by which this is imported into local scope.\n     pub import: Option<ImportId>,\n }\n@@ -210,11 +217,11 @@ where\n                 let krate = Crate::new(crate_id);\n                 for dep in krate.dependencies(self.db) {\n                     if let Some(module) = dep.krate.root_module(self.db) {\n-                        let def_id = module.into();\n+                        let def = module.into();\n                         self.add_module_item(\n                             &mut module_items,\n                             dep.name.clone(),\n-                            PerNs::types(def_id),\n+                            PerNs::types(def),\n                         );\n                     }\n                 }\n@@ -226,19 +233,16 @@ where\n                     module_items.items.insert(\n                         segment.name.clone(),\n                         Resolution {\n-                            def_id: PerNs::none(),\n+                            def: PerNs::none(),\n                             import: Some(import_id),\n                         },\n                     );\n                 }\n             }\n         }\n         // Populate explicitly declared items, except modules\n-        for (name, &def_id) in input.declarations.iter() {\n-            let resolution = Resolution {\n-                def_id,\n-                import: None,\n-            };\n+        for (name, &def) in input.declarations.iter() {\n+            let resolution = Resolution { def, import: None };\n             module_items.items.insert(name.clone(), resolution);\n         }\n \n@@ -254,16 +258,8 @@ where\n         self.result.per_module.insert(module_id, module_items);\n     }\n \n-    fn add_module_item(\n-        &self,\n-        module_items: &mut ModuleScope,\n-        name: Name,\n-        def_id: PerNs<ModuleDef>,\n-    ) {\n-        let resolution = Resolution {\n-            def_id,\n-            import: None,\n-        };\n+    fn add_module_item(&self, module_items: &mut ModuleScope, name: Name, def: PerNs<ModuleDef>) {\n+        let resolution = Resolution { def, import: None };\n         module_items.items.insert(name, resolution);\n     }\n \n@@ -273,7 +269,7 @@ where\n                 // already done\n                 continue;\n             }\n-            if self.resolve_import(module_id, import_id, import_data) {\n+            if self.resolve_import(module_id, import_id, import_data) == ReachedFixedPoint::Yes {\n                 log::debug!(\"import {:?} resolved (or definite error)\", import_id);\n                 self.processed_imports.insert((module_id, import_id));\n             }\n@@ -285,116 +281,146 @@ where\n         module_id: ModuleId,\n         import_id: ImportId,\n         import: &ImportData,\n-    ) -> bool {\n+    ) -> ReachedFixedPoint {\n         log::debug!(\"resolving import: {:?}\", import);\n         if import.is_glob {\n-            return false;\n+            return ReachedFixedPoint::Yes;\n         };\n+        let original_module = Module {\n+            krate: self.krate,\n+            module_id,\n+        };\n+        let (def, reached_fixedpoint) =\n+            self.result\n+                .resolve_path_fp(self.db, original_module, &import.path);\n+\n+        if reached_fixedpoint == ReachedFixedPoint::Yes {\n+            let last_segment = import.path.segments.last().unwrap();\n+            self.update(module_id, |items| {\n+                let res = Resolution {\n+                    def,\n+                    import: Some(import_id),\n+                };\n+                items.items.insert(last_segment.name.clone(), res);\n+            });\n+            log::debug!(\n+                \"resolved import {:?} ({:?}) cross-source root to {:?}\",\n+                last_segment.name,\n+                import,\n+                def,\n+            );\n+        }\n+        reached_fixedpoint\n+    }\n+\n+    fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {\n+        let module_items = self.result.per_module.get_mut(module_id).unwrap();\n+        f(module_items)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum ReachedFixedPoint {\n+    Yes,\n+    No,\n+}\n \n-        let mut curr: ModuleId = match import.path.kind {\n-            PathKind::Plain | PathKind::Self_ => module_id,\n+impl ItemMap {\n+    pub(crate) fn resolve_path(\n+        &self,\n+        db: &impl HirDatabase,\n+        original_module: Module,\n+        path: &Path,\n+    ) -> PerNs<ModuleDef> {\n+        self.resolve_path_fp(db, original_module, path).0\n+    }\n+\n+    // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n+    // the result.\n+    fn resolve_path_fp(\n+        &self,\n+        db: &impl HirDatabase,\n+        original_module: Module,\n+        path: &Path,\n+    ) -> (PerNs<ModuleDef>, ReachedFixedPoint) {\n+        let mut curr_per_ns: PerNs<ModuleDef> = PerNs::types(match path.kind {\n+            PathKind::Crate => original_module.crate_root(db).into(),\n+            PathKind::Self_ | PathKind::Plain => original_module.into(),\n             PathKind::Super => {\n-                match module_id.parent(&self.module_tree) {\n-                    Some(it) => it,\n-                    None => {\n-                        // TODO: error\n-                        log::debug!(\"super path in root module\");\n-                        return true; // this can't suddenly resolve if we just resolve some other imports\n-                    }\n+                if let Some(p) = original_module.parent(db) {\n+                    p.into()\n+                } else {\n+                    log::debug!(\"super path in root module\");\n+                    return (PerNs::none(), ReachedFixedPoint::Yes);\n                 }\n             }\n-            PathKind::Crate => module_id.crate_root(&self.module_tree),\n             PathKind::Abs => {\n-                // TODO: absolute use is not supported for now\n-                return false;\n+                // TODO: absolute use is not supported\n+                return (PerNs::none(), ReachedFixedPoint::Yes);\n             }\n-        };\n-\n-        for (i, segment) in import.path.segments.iter().enumerate() {\n-            let is_last = i == import.path.segments.len() - 1;\n-\n-            let def_id = match self.result.per_module[&curr].items.get(&segment.name) {\n-                Some(res) if !res.def_id.is_none() => res.def_id,\n-                _ => {\n-                    log::debug!(\"path segment {:?} not found\", segment.name);\n-                    return false;\n+        });\n+\n+        for (i, segment) in path.segments.iter().enumerate() {\n+            let curr = match curr_per_ns.as_ref().take_types() {\n+                Some(r) => r,\n+                None => {\n+                    // we still have path segments left, but the path so far\n+                    // didn't resolve in the types namespace => no resolution\n+                    // (don't break here because curr_per_ns might contain\n+                    // something in the value namespace, and it would be wrong\n+                    // to return that)\n+                    return (PerNs::none(), ReachedFixedPoint::No);\n                 }\n             };\n+            // resolve segment in curr\n+\n+            curr_per_ns = match curr {\n+                ModuleDef::Module(module) => {\n+                    if module.krate != original_module.krate {\n+                        let path = Path {\n+                            segments: path.segments[i..].iter().cloned().collect(),\n+                            kind: PathKind::Crate,\n+                        };\n+                        log::debug!(\"resolving {:?} in other crate\", path);\n+                        let def = module.resolve_path(db, &path);\n+                        return (def, ReachedFixedPoint::Yes);\n+                    }\n \n-            if !is_last {\n-                let type_def_id = if let Some(d) = def_id.take(Namespace::Types) {\n-                    d\n-                } else {\n-                    log::debug!(\n-                        \"path segment {:?} resolved to value only, but is not last\",\n-                        segment.name\n-                    );\n-                    return false;\n-                };\n-                curr = match type_def_id {\n-                    ModuleDef::Module(module) => {\n-                        if module.krate == self.krate {\n-                            module.module_id\n-                        } else {\n-                            let path = Path {\n-                                segments: import.path.segments[i + 1..].iter().cloned().collect(),\n-                                kind: PathKind::Crate,\n-                            };\n-                            log::debug!(\"resolving {:?} in other source root\", path);\n-                            let def_id = module.resolve_path(self.db, &path);\n-                            if !def_id.is_none() {\n-                                let last_segment = path.segments.last().unwrap();\n-                                self.update(module_id, |items| {\n-                                    let res = Resolution {\n-                                        def_id,\n-                                        import: Some(import_id),\n-                                    };\n-                                    items.items.insert(last_segment.name.clone(), res);\n-                                });\n-                                log::debug!(\n-                                    \"resolved import {:?} ({:?}) cross-source root to {:?}\",\n-                                    last_segment.name,\n-                                    import,\n-                                    def_id,\n-                                );\n-                                return true;\n-                            } else {\n-                                log::debug!(\"rest of path did not resolve in other source root\");\n-                                return true;\n-                            }\n+                    match self[module.module_id].items.get(&segment.name) {\n+                        Some(res) if !res.def.is_none() => res.def,\n+                        _ => {\n+                            log::debug!(\"path segment {:?} not found\", segment.name);\n+                            return (PerNs::none(), ReachedFixedPoint::No);\n                         }\n                     }\n-                    _ => {\n-                        log::debug!(\n-                            \"path segment {:?} resolved to non-module {:?}, but is not last\",\n-                            segment.name,\n-                            type_def_id,\n-                        );\n-                        return true; // this resolved to a non-module, so the path won't ever resolve\n+                }\n+                ModuleDef::Enum(e) => {\n+                    // enum variant\n+                    tested_by!(item_map_enum_importing);\n+                    let matching_variant = e\n+                        .variants(db)\n+                        .into_iter()\n+                        .find(|(n, _variant)| n == &segment.name);\n+\n+                    match matching_variant {\n+                        Some((_n, variant)) => PerNs::both(variant.into(), (*e).into()),\n+                        None => PerNs::none(),\n                     }\n                 }\n-            } else {\n-                log::debug!(\n-                    \"resolved import {:?} ({:?}) within source root to {:?}\",\n-                    segment.name,\n-                    import,\n-                    def_id,\n-                );\n-                self.update(module_id, |items| {\n-                    let res = Resolution {\n-                        def_id,\n-                        import: Some(import_id),\n-                    };\n-                    items.items.insert(segment.name.clone(), res);\n-                })\n-            }\n+                _ => {\n+                    // could be an inherent method call in UFCS form\n+                    // (`Struct::method`), or some other kind of associated\n+                    // item... Which we currently don't handle (TODO)\n+                    log::debug!(\n+                        \"path segment {:?} resolved to non-module {:?}, but is not last\",\n+                        segment.name,\n+                        curr,\n+                    );\n+                    return (PerNs::none(), ReachedFixedPoint::Yes);\n+                }\n+            };\n         }\n-        true\n-    }\n-\n-    fn update(&mut self, module_id: ModuleId, f: impl FnOnce(&mut ModuleScope)) {\n-        let module_items = self.result.per_module.get_mut(&module_id).unwrap();\n-        f(module_items)\n+        (curr_per_ns, ReachedFixedPoint::Yes)\n     }\n }\n "}, {"sha": "c033bebe87a9adefb25841dfbdc4c229785218e2", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=946aea3eb34d1b7f09900e017bb94708e6299d0a", "patch": "@@ -20,7 +20,7 @@ fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n }\n \n fn check_module_item_map(map: &ItemMap, module_id: ModuleId, expected: &str) {\n-    let mut lines = map.per_module[&module_id]\n+    let mut lines = map[module_id]\n         .items\n         .iter()\n         .map(|(name, res)| format!(\"{}: {}\", name, dump_resolution(res)))\n@@ -37,8 +37,8 @@ fn check_module_item_map(map: &ItemMap, module_id: ModuleId, expected: &str) {\n \n     fn dump_resolution(resolution: &Resolution) -> &'static str {\n         match (\n-            resolution.def_id.types.is_some(),\n-            resolution.def_id.values.is_some(),\n+            resolution.def.types.is_some(),\n+            resolution.def.values.is_some(),\n         ) {\n             (true, true) => \"t v\",\n             (true, false) => \"t\",\n@@ -215,6 +215,27 @@ fn item_map_using_self() {\n     );\n }\n \n+#[test]\n+fn item_map_enum_importing() {\n+    covers!(item_map_enum_importing);\n+    let (item_map, module_id) = item_map(\n+        \"\n+        //- /lib.rs\n+        enum E { V }\n+        use self::E::V;\n+        <|>\n+        \",\n+    );\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+        E: t\n+        V: t v\n+        \",\n+    );\n+}\n+\n #[test]\n fn item_map_across_crates() {\n     let (mut db, sr) = MockDatabase::with_files("}, {"sha": "b2b0477661d93f4e4b3c83b045c251500bbb64c3", "filename": "crates/ra_ide_api/src/completion/completion_item.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=946aea3eb34d1b7f09900e017bb94708e6299d0a", "patch": "@@ -209,10 +209,7 @@ impl Builder {\n         ctx: &CompletionContext,\n         resolution: &hir::Resolution,\n     ) -> Builder {\n-        let def = resolution\n-            .def_id\n-            .take_types()\n-            .or(resolution.def_id.take_values());\n+        let def = resolution.def.take_types().or(resolution.def.take_values());\n         let def = match def {\n             None => return self,\n             Some(it) => it,"}, {"sha": "dc5b2702aee4c1aaee8bc9e7de1495445581cb32", "filename": "crates/ra_ide_api/src/marks.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_ide_api%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Fra_ide_api%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmarks.rs?ref=946aea3eb34d1b7f09900e017bb94708e6299d0a", "patch": "@@ -1,3 +1 @@\n-use test_utils::mark;\n-\n-mark!(inserts_parens_for_function_calls);\n+test_utils::marks!(inserts_parens_for_function_calls);"}, {"sha": "ee47b5219814f11e2e98a395436e5312ac16bff6", "filename": "crates/test_utils/src/marks.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/946aea3eb34d1b7f09900e017bb94708e6299d0a/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fmarks.rs?ref=946aea3eb34d1b7f09900e017bb94708e6299d0a", "patch": "@@ -46,11 +46,13 @@ macro_rules! covers {\n }\n \n #[macro_export]\n-macro_rules! mark {\n-    ($ident:ident) => {\n+macro_rules! marks {\n+    ($($ident:ident)*) => {\n+        $(\n         #[allow(bad_style)]\n         pub(crate) static $ident: std::sync::atomic::AtomicUsize =\n             std::sync::atomic::AtomicUsize::new(0);\n+        )*\n     };\n }\n "}]}