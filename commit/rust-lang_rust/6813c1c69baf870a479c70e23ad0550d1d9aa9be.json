{"sha": "6813c1c69baf870a479c70e23ad0550d1d9aa9be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MTNjMWM2OWJhZjg3MGE0NzljNzBlMjNhZDA1NTBkMWQ5YWE5YmU=", "commit": {"author": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2020-06-03T18:40:22Z"}, "committer": {"name": "Stefan Lankes", "email": "slankes@eonerc.rwth-aachen.de", "date": "2020-06-25T22:02:59Z"}, "message": "revise RwLock, which is derived from the wasm implementation\n\n- increasing the readability of `Condvar`\n- simplify the interface to the libos HermitCore", "tree": {"sha": "6a01779bb3d0942d2216c986a512cde927d79908", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a01779bb3d0942d2216c986a512cde927d79908"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6813c1c69baf870a479c70e23ad0550d1d9aa9be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6813c1c69baf870a479c70e23ad0550d1d9aa9be", "html_url": "https://github.com/rust-lang/rust/commit/6813c1c69baf870a479c70e23ad0550d1d9aa9be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6813c1c69baf870a479c70e23ad0550d1d9aa9be/comments", "author": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stlankes", "id": 5888473, "node_id": "MDQ6VXNlcjU4ODg0NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/5888473?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stlankes", "html_url": "https://github.com/stlankes", "followers_url": "https://api.github.com/users/stlankes/followers", "following_url": "https://api.github.com/users/stlankes/following{/other_user}", "gists_url": "https://api.github.com/users/stlankes/gists{/gist_id}", "starred_url": "https://api.github.com/users/stlankes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stlankes/subscriptions", "organizations_url": "https://api.github.com/users/stlankes/orgs", "repos_url": "https://api.github.com/users/stlankes/repos", "events_url": "https://api.github.com/users/stlankes/events{/privacy}", "received_events_url": "https://api.github.com/users/stlankes/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50fc24d8a172a853b5dfe40702d6550e3b8562ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/50fc24d8a172a853b5dfe40702d6550e3b8562ba", "html_url": "https://github.com/rust-lang/rust/commit/50fc24d8a172a853b5dfe40702d6550e3b8562ba"}], "stats": {"total": 181, "additions": 143, "deletions": 38}, "files": [{"sha": "cca8db2714d5ee60ef57d60fe477b297cc2f01fd", "filename": "src/libstd/sys/hermit/condvar.rs", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6813c1c69baf870a479c70e23ad0550d1d9aa9be/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6813c1c69baf870a479c70e23ad0550d1d9aa9be/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs?ref=6813c1c69baf870a479c70e23ad0550d1d9aa9be", "patch": "@@ -1,60 +1,70 @@\n use crate::cmp;\n+use crate::ffi::c_void;\n+use crate::mem;\n+use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n use crate::sys::hermit::abi;\n use crate::sys::mutex::Mutex;\n+use crate::ptr;\n use crate::time::Duration;\n \n+// The implementation is inspired by Andrew D. Birrell's paper\n+// \"Implementing Condition Variables with Semaphores\"\n+\n pub struct Condvar {\n-    identifier: usize,\n+    counter: AtomicUsize,\n+    sem1: *const c_void,\n+    sem2: *const c_void,\n }\n \n+unsafe impl Send for Condvar {}\n+unsafe impl Sync for Condvar {}\n+\n impl Condvar {\n     pub const fn new() -> Condvar {\n-        Condvar { identifier: 0 }\n+        Condvar {\n+            counter: AtomicUsize::new(0),\n+            sem1: ptr::null(),\n+            sem2: ptr::null(),\n+        }\n     }\n \n     pub unsafe fn init(&mut self) {\n-        let _ = abi::init_queue(self.id());\n+        let _ = abi::sem_init(&mut self.sem1 as *mut *const c_void, 0);\n+        let _ = abi::sem_init(&mut self.sem2 as *mut *const c_void, 0);\n     }\n \n     pub unsafe fn notify_one(&self) {\n-        let _ = abi::notify(self.id(), 1);\n+        if self.counter.load(SeqCst) > 0 {\n+            self.counter.fetch_sub(1, SeqCst);\n+            abi::sem_post(self.sem1);\n+            abi::sem_timedwait(self.sem2, 0);\n+        }\n     }\n \n-    #[inline]\n     pub unsafe fn notify_all(&self) {\n-        let _ = abi::notify(self.id(), -1 /* =all */);\n+        let counter = self.counter.swap(0, SeqCst);\n+        for _ in 0..counter {\n+            abi::sem_post(self.sem1);\n+        }\n+        for _ in 0..counter {\n+            abi::sem_timedwait(self.sem2, 0);\n+        }\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {\n-        // add current task to the wait queue\n-        let _ = abi::add_queue(self.id(), -1 /* no timeout */);\n+        self.counter.fetch_add(1, SeqCst);\n         mutex.unlock();\n-        let _ = abi::wait(self.id());\n+        abi::sem_timedwait(self.sem1, 0);\n+        abi::sem_post(self.sem2);\n         mutex.lock();\n     }\n \n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        let nanos = dur.as_nanos();\n-        let nanos = cmp::min(i64::MAX as u128, nanos);\n-\n-        // add current task to the wait queue\n-        let _ = abi::add_queue(self.id(), nanos as i64);\n-\n-        mutex.unlock();\n-        // If the return value is !0 then a timeout happened, so we return\n-        // `false` as we weren't actually notified.\n-        let ret = abi::wait(self.id()) == 0;\n-        mutex.lock();\n-\n-        ret\n+        panic!(\"wait_timeout not supported on hermit\");\n     }\n \n     pub unsafe fn destroy(&self) {\n-        let _ = abi::destroy_queue(self.id());\n-    }\n-\n-    #[inline]\n-    fn id(&self) -> usize {\n-        &self.identifier as *const usize as usize\n+        let _ = abi::sem_destroy(self.sem1);\n+        let _ = abi::sem_destroy(self.sem2);\n     }\n }"}, {"sha": "06442e925f4c8710d33caf6fff3e18a54e495081", "filename": "src/libstd/sys/hermit/rwlock.rs", "status": "modified", "additions": 105, "deletions": 10, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6813c1c69baf870a479c70e23ad0550d1d9aa9be/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6813c1c69baf870a479c70e23ad0550d1d9aa9be/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs?ref=6813c1c69baf870a479c70e23ad0550d1d9aa9be", "patch": "@@ -1,49 +1,144 @@\n-use super::mutex::Mutex;\n+use crate::cell::UnsafeCell;\n+use crate::sys::condvar::Condvar;\n+use crate::sys::mutex::Mutex;\n \n pub struct RWLock {\n-    mutex: Mutex,\n+    lock: Mutex,\n+    cond: Condvar,\n+    state: UnsafeCell<State>,\n+}\n+\n+enum State {\n+    Unlocked,\n+    Reading(usize),\n+    Writing,\n }\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n+// This rwlock implementation is a relatively simple implementation which has a\n+// condition variable for readers/writers as well as a mutex protecting the\n+// internal state of the lock. A current downside of the implementation is that\n+// unlocking the lock will notify *all* waiters rather than just readers or just\n+// writers. This can cause lots of \"thundering stampede\" problems. While\n+// hopefully correct this implementation is very likely to want to be changed in\n+// the future.\n+\n impl RWLock {\n     pub const fn new() -> RWLock {\n-        RWLock { mutex: Mutex::new() }\n+        RWLock { lock: Mutex::new(), cond: Condvar::new(), state: UnsafeCell::new(State::Unlocked) }\n     }\n \n     #[inline]\n     pub unsafe fn read(&self) {\n-        self.mutex.lock();\n+        self.lock.lock();\n+        while !(*self.state.get()).inc_readers() {\n+            self.cond.wait(&self.lock);\n+        }\n+        self.lock.unlock();\n     }\n \n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        self.mutex.try_lock()\n+        self.lock.lock();\n+        let ok = (*self.state.get()).inc_readers();\n+        self.lock.unlock();\n+        return ok;\n     }\n \n     #[inline]\n     pub unsafe fn write(&self) {\n-        self.mutex.lock();\n+        self.lock.lock();\n+        while !(*self.state.get()).inc_writers() {\n+            self.cond.wait(&self.lock);\n+        }\n+        self.lock.unlock();\n     }\n \n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        self.mutex.try_lock()\n+        self.lock.lock();\n+        let ok = (*self.state.get()).inc_writers();\n+        self.lock.unlock();\n+        return ok;\n     }\n \n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        self.mutex.unlock();\n+        self.lock.lock();\n+        let notify = (*self.state.get()).dec_readers();\n+        self.lock.unlock();\n+        if notify {\n+            // FIXME: should only wake up one of these some of the time\n+            self.cond.notify_all();\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn write_unlock(&self) {\n-        self.mutex.unlock();\n+        self.lock.lock();\n+        (*self.state.get()).dec_writers();\n+        self.lock.unlock();\n+        // FIXME: should only wake up one of these some of the time\n+        self.cond.notify_all();\n     }\n \n     #[inline]\n     pub unsafe fn destroy(&self) {\n-        self.mutex.destroy();\n+        self.lock.destroy();\n+        self.cond.destroy();\n+    }\n+}\n+\n+impl State {\n+    fn inc_readers(&mut self) -> bool {\n+        match *self {\n+            State::Unlocked => {\n+                *self = State::Reading(1);\n+                true\n+            }\n+            State::Reading(ref mut cnt) => {\n+                *cnt += 1;\n+                true\n+            }\n+            State::Writing => false,\n+        }\n+    }\n+\n+    fn inc_writers(&mut self) -> bool {\n+        match *self {\n+            State::Unlocked => {\n+                *self = State::Writing;\n+                true\n+            }\n+            State::Reading(_) | State::Writing => false,\n+        }\n+    }\n+\n+    fn dec_readers(&mut self) -> bool {\n+        let zero = match *self {\n+            State::Reading(ref mut cnt) => {\n+                *cnt -= 1;\n+                *cnt == 0\n+            }\n+            State::Unlocked | State::Writing => invalid(),\n+        };\n+        if zero {\n+            *self = State::Unlocked;\n+        }\n+        zero\n     }\n+\n+    fn dec_writers(&mut self) {\n+        match *self {\n+            State::Writing => {}\n+            State::Unlocked | State::Reading(_) => invalid(),\n+        }\n+        *self = State::Unlocked;\n+    }\n+}\n+\n+fn invalid() -> ! {\n+    panic!(\"inconsistent rwlock\");\n }"}]}