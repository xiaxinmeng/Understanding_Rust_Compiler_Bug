{"sha": "c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYTU0Y2M0ZWI2MTExY2FjOWFkNzVjYzQzOWY3NWI3OTY5OGI0YTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-25T21:34:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-25T21:34:55Z"}, "message": "Auto merge of #82530 - Aaron1011:rollup-aalwq15, r=Aaron1011\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #82269 (Cleanup `PpMode` and friends)\n - #82431 (Set RUST_BACKTRACE=0 when running `treat-err-as-bug` tests)\n - #82441 (Fix typo in sanitizer flag in unstable book.)\n - #82463 (panic_bounds_checks should be panic_bounds_check)\n - #82464 (Update outdated comment in unix Command.)\n - #82467 (library: Normalize safety-for-unsafe-block comments)\n - #82468 (Move pick_by_value_method docs above function header)\n - #82484 (rustdoc: Remove duplicate \"List of all items\")\n - #82502 (Only look for HTML `tidy` when running rustdoc tests)\n - #82503 (fix typo in `pre-commit.sh`)\n - #82510 (Fix typo in `param_env_reveal_all_normalized`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c53ca0c588422e538c94226dcb0a3f81c86c433a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c53ca0c588422e538c94226dcb0a3f81c86c433a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "html_url": "https://github.com/rust-lang/rust/commit/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98f8cce6db6c6c6660eeffee2b3903104e547ecf", "url": "https://api.github.com/repos/rust-lang/rust/commits/98f8cce6db6c6c6660eeffee2b3903104e547ecf", "html_url": "https://github.com/rust-lang/rust/commit/98f8cce6db6c6c6660eeffee2b3903104e547ecf"}, {"sha": "42e53ff8adf8a4c7ab8d5f87816e30405a1ec9e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/42e53ff8adf8a4c7ab8d5f87816e30405a1ec9e2", "html_url": "https://github.com/rust-lang/rust/commit/42e53ff8adf8a4c7ab8d5f87816e30405a1ec9e2"}], "stats": {"total": 342, "additions": 174, "deletions": 168}, "files": [{"sha": "1dcc4d147acf23a45de96335b4c4b9fba070d67e", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 27, "deletions": 45, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -9,7 +9,7 @@ use rustc_hir_pretty as pprust_hir;\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_mir::util::{write_mir_graphviz, write_mir_pretty};\n-use rustc_session::config::{Input, PpMode, PpSourceMode};\n+use rustc_session::config::{Input, PpHirMode, PpMode, PpSourceMode};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::FileName;\n@@ -42,43 +42,41 @@ where\n     F: FnOnce(&dyn PrinterSupport) -> A,\n {\n     match *ppmode {\n-        PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n+        Normal | EveryBodyLoops | Expanded => {\n             let annotation = NoAnn { sess, tcx };\n             f(&annotation)\n         }\n \n-        PpmIdentified | PpmExpandedIdentified => {\n+        Identified | ExpandedIdentified => {\n             let annotation = IdentifiedAnnotation { sess, tcx };\n             f(&annotation)\n         }\n-        PpmExpandedHygiene => {\n+        ExpandedHygiene => {\n             let annotation = HygieneAnnotation { sess };\n             f(&annotation)\n         }\n-        _ => panic!(\"Should use call_with_pp_support_hir\"),\n     }\n }\n-fn call_with_pp_support_hir<A, F>(ppmode: &PpSourceMode, tcx: TyCtxt<'_>, f: F) -> A\n+fn call_with_pp_support_hir<A, F>(ppmode: &PpHirMode, tcx: TyCtxt<'_>, f: F) -> A\n where\n     F: FnOnce(&dyn HirPrinterSupport<'_>, &hir::Crate<'_>) -> A,\n {\n     match *ppmode {\n-        PpmNormal => {\n+        PpHirMode::Normal => {\n             let annotation = NoAnn { sess: tcx.sess, tcx: Some(tcx) };\n             f(&annotation, tcx.hir().krate())\n         }\n \n-        PpmIdentified => {\n+        PpHirMode::Identified => {\n             let annotation = IdentifiedAnnotation { sess: tcx.sess, tcx: Some(tcx) };\n             f(&annotation, tcx.hir().krate())\n         }\n-        PpmTyped => {\n+        PpHirMode::Typed => {\n             abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n \n             let annotation = TypedAnnotation { tcx, maybe_typeck_results: Cell::new(None) };\n             tcx.dep_graph.with_ignore(|| f(&annotation, tcx.hir().krate()))\n         }\n-        _ => panic!(\"Should use call_with_pp_support\"),\n     }\n }\n \n@@ -393,16 +391,13 @@ pub fn print_after_parsing(\n ) {\n     let (src, src_name) = get_source(input, sess);\n \n-    let mut out = String::new();\n-\n-    if let PpmSource(s) = ppm {\n+    let out = if let Source(s) = ppm {\n         // Silently ignores an identified node.\n-        let out = &mut out;\n         call_with_pp_support(&s, sess, None, move |annotation| {\n             debug!(\"pretty printing source code {:?}\", s);\n             let sess = annotation.sess();\n             let parse = &sess.parse_sess;\n-            *out = pprust::print_crate(\n+            pprust::print_crate(\n                 sess.source_map(),\n                 krate,\n                 src_name,\n@@ -413,7 +408,7 @@ pub fn print_after_parsing(\n             )\n         })\n     } else {\n-        unreachable!();\n+        unreachable!()\n     };\n \n     write_or_print(&out, ofile);\n@@ -433,17 +428,14 @@ pub fn print_after_hir_lowering<'tcx>(\n \n     let (src, src_name) = get_source(input, tcx.sess);\n \n-    let mut out = String::new();\n-\n-    match ppm {\n-        PpmSource(s) => {\n+    let out = match ppm {\n+        Source(s) => {\n             // Silently ignores an identified node.\n-            let out = &mut out;\n             call_with_pp_support(&s, tcx.sess, Some(tcx), move |annotation| {\n                 debug!(\"pretty printing source code {:?}\", s);\n                 let sess = annotation.sess();\n                 let parse = &sess.parse_sess;\n-                *out = pprust::print_crate(\n+                pprust::print_crate(\n                     sess.source_map(),\n                     krate,\n                     src_name,\n@@ -455,26 +447,20 @@ pub fn print_after_hir_lowering<'tcx>(\n             })\n         }\n \n-        PpmHir(s) => {\n-            let out = &mut out;\n-            call_with_pp_support_hir(&s, tcx, move |annotation, krate| {\n-                debug!(\"pretty printing source code {:?}\", s);\n-                let sess = annotation.sess();\n-                let sm = sess.source_map();\n-                *out = pprust_hir::print_crate(sm, krate, src_name, src, annotation.pp_ann())\n-            })\n-        }\n+        Hir(s) => call_with_pp_support_hir(&s, tcx, move |annotation, krate| {\n+            debug!(\"pretty printing HIR {:?}\", s);\n+            let sess = annotation.sess();\n+            let sm = sess.source_map();\n+            pprust_hir::print_crate(sm, krate, src_name, src, annotation.pp_ann())\n+        }),\n \n-        PpmHirTree(s) => {\n-            let out = &mut out;\n-            call_with_pp_support_hir(&s, tcx, move |_annotation, krate| {\n-                debug!(\"pretty printing source code {:?}\", s);\n-                *out = format!(\"{:#?}\", krate);\n-            });\n-        }\n+        HirTree => call_with_pp_support_hir(&PpHirMode::Normal, tcx, move |_annotation, krate| {\n+            debug!(\"pretty printing HIR tree\");\n+            format!(\"{:#?}\", krate)\n+        }),\n \n         _ => unreachable!(),\n-    }\n+    };\n \n     write_or_print(&out, ofile);\n }\n@@ -493,14 +479,10 @@ fn print_with_analysis(\n     tcx.analysis(LOCAL_CRATE)?;\n \n     match ppm {\n-        PpmMir | PpmMirCFG => match ppm {\n-            PpmMir => write_mir_pretty(tcx, None, &mut out),\n-            PpmMirCFG => write_mir_graphviz(tcx, None, &mut out),\n-            _ => unreachable!(),\n-        },\n+        Mir => write_mir_pretty(tcx, None, &mut out).unwrap(),\n+        MirCFG => write_mir_graphviz(tcx, None, &mut out).unwrap(),\n         _ => unreachable!(),\n     }\n-    .unwrap();\n \n     let out = std::str::from_utf8(&out).unwrap();\n     write_or_print(out, ofile);"}, {"sha": "5217066bbefdec8f5b3a3f786fb8083287786563", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -350,7 +350,7 @@ fn configure_and_expand_inner<'a>(\n         rustc_builtin_macros::test_harness::inject(&sess, &mut resolver, &mut krate)\n     });\n \n-    if let Some(PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops)) = sess.opts.pretty {\n+    if let Some(PpMode::Source(PpSourceMode::EveryBodyLoops)) = sess.opts.pretty {\n         tracing::debug!(\"replacing bodies with loop {{}}\");\n         util::ReplaceBodyWithLoop::new(&mut resolver).visit_crate(&mut krate);\n     }"}, {"sha": "a8600af1de28e9806f190a6c9311408ec493a011", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -956,7 +956,7 @@ rustc_queries! {\n         desc { |tcx| \"computing normalized predicates of `{}`\", tcx.def_path_str(def_id) }\n     }\n \n-    /// Like `param_env`, but returns the `ParamEnv in `Reveal::All` mode.\n+    /// Like `param_env`, but returns the `ParamEnv` in `Reveal::All` mode.\n     /// Prefer this over `tcx.param_env(def_id).with_reveal_all_normalized(tcx)`,\n     /// as this method is more efficient.\n     query param_env_reveal_all_normalized(def_id: DefId) -> ty::ParamEnv<'tcx> {"}, {"sha": "38da52b88f36969ff48eda4dbbe63bca93eed987", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 64, "deletions": 53, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -2057,40 +2057,21 @@ fn parse_pretty(\n     debugging_opts: &DebuggingOptions,\n     efmt: ErrorOutputType,\n ) -> Option<PpMode> {\n-    let pretty = if debugging_opts.unstable_options {\n-        matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-            // stable pretty-print variants only\n-            parse_pretty_inner(efmt, &a, false)\n-        })\n-    } else {\n-        None\n-    };\n-\n-    return if pretty.is_none() {\n-        debugging_opts.unpretty.as_ref().map(|a| {\n-            // extended with unstable pretty-print variants\n-            parse_pretty_inner(efmt, &a, true)\n-        })\n-    } else {\n-        pretty\n-    };\n-\n     fn parse_pretty_inner(efmt: ErrorOutputType, name: &str, extended: bool) -> PpMode {\n         use PpMode::*;\n-        use PpSourceMode::*;\n         let first = match (name, extended) {\n-            (\"normal\", _) => PpmSource(PpmNormal),\n-            (\"identified\", _) => PpmSource(PpmIdentified),\n-            (\"everybody_loops\", true) => PpmSource(PpmEveryBodyLoops),\n-            (\"expanded\", _) => PpmSource(PpmExpanded),\n-            (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n-            (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n-            (\"hir\", true) => PpmHir(PpmNormal),\n-            (\"hir,identified\", true) => PpmHir(PpmIdentified),\n-            (\"hir,typed\", true) => PpmHir(PpmTyped),\n-            (\"hir-tree\", true) => PpmHirTree(PpmNormal),\n-            (\"mir\", true) => PpmMir,\n-            (\"mir-cfg\", true) => PpmMirCFG,\n+            (\"normal\", _) => Source(PpSourceMode::Normal),\n+            (\"identified\", _) => Source(PpSourceMode::Identified),\n+            (\"everybody_loops\", true) => Source(PpSourceMode::EveryBodyLoops),\n+            (\"expanded\", _) => Source(PpSourceMode::Expanded),\n+            (\"expanded,identified\", _) => Source(PpSourceMode::ExpandedIdentified),\n+            (\"expanded,hygiene\", _) => Source(PpSourceMode::ExpandedHygiene),\n+            (\"hir\", true) => Hir(PpHirMode::Normal),\n+            (\"hir,identified\", true) => Hir(PpHirMode::Identified),\n+            (\"hir,typed\", true) => Hir(PpHirMode::Typed),\n+            (\"hir-tree\", true) => HirTree,\n+            (\"mir\", true) => Mir,\n+            (\"mir-cfg\", true) => MirCFG,\n             _ => {\n                 if extended {\n                     early_error(\n@@ -2119,6 +2100,18 @@ fn parse_pretty(\n         tracing::debug!(\"got unpretty option: {:?}\", first);\n         first\n     }\n+\n+    if debugging_opts.unstable_options {\n+        if let Some(a) = matches.opt_default(\"pretty\", \"normal\") {\n+            // stable pretty-print variants only\n+            return Some(parse_pretty_inner(efmt, &a, false));\n+        }\n+    }\n+\n+    debugging_opts.unpretty.as_ref().map(|a| {\n+        // extended with unstable pretty-print variants\n+        parse_pretty_inner(efmt, &a, true)\n+    })\n }\n \n pub fn make_crate_type_option() -> RustcOptGroup {\n@@ -2226,45 +2219,63 @@ impl fmt::Display for CrateType {\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpSourceMode {\n-    PpmNormal,\n-    PpmEveryBodyLoops,\n-    PpmExpanded,\n-    PpmIdentified,\n-    PpmExpandedIdentified,\n-    PpmExpandedHygiene,\n-    PpmTyped,\n+    /// `--pretty=normal`\n+    Normal,\n+    /// `-Zunpretty=everybody_loops`\n+    EveryBodyLoops,\n+    /// `--pretty=expanded`\n+    Expanded,\n+    /// `--pretty=identified`\n+    Identified,\n+    /// `--pretty=expanded,identified`\n+    ExpandedIdentified,\n+    /// `--pretty=expanded,hygiene`\n+    ExpandedHygiene,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum PpHirMode {\n+    /// `-Zunpretty=hir`\n+    Normal,\n+    /// `-Zunpretty=hir,identified`\n+    Identified,\n+    /// `-Zunpretty=hir,typed`\n+    Typed,\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpMode {\n-    PpmSource(PpSourceMode),\n-    PpmHir(PpSourceMode),\n-    PpmHirTree(PpSourceMode),\n-    PpmMir,\n-    PpmMirCFG,\n+    /// Options that print the source code, i.e.\n+    /// `--pretty` and `-Zunpretty=everybody_loops`\n+    Source(PpSourceMode),\n+    /// Options that print the HIR, i.e. `-Zunpretty=hir`\n+    Hir(PpHirMode),\n+    /// `-Zunpretty=hir-tree`\n+    HirTree,\n+    /// `-Zunpretty=mir`\n+    Mir,\n+    /// `-Zunpretty=mir-cfg`\n+    MirCFG,\n }\n \n impl PpMode {\n     pub fn needs_ast_map(&self) -> bool {\n         use PpMode::*;\n         use PpSourceMode::*;\n         match *self {\n-            PpmSource(PpmNormal | PpmIdentified) => false,\n+            Source(Normal | Identified) => false,\n \n-            PpmSource(\n-                PpmExpanded | PpmEveryBodyLoops | PpmExpandedIdentified | PpmExpandedHygiene,\n-            )\n-            | PpmHir(_)\n-            | PpmHirTree(_)\n-            | PpmMir\n-            | PpmMirCFG => true,\n-            PpmSource(PpmTyped) => panic!(\"invalid state\"),\n+            Source(Expanded | EveryBodyLoops | ExpandedIdentified | ExpandedHygiene)\n+            | Hir(_)\n+            | HirTree\n+            | Mir\n+            | MirCFG => true,\n         }\n     }\n \n     pub fn needs_analysis(&self) -> bool {\n         use PpMode::*;\n-        matches!(*self, PpmMir | PpmMirCFG)\n+        matches!(*self, Mir | MirCFG)\n     }\n }\n "}, {"sha": "c25aec5b2b7e9bdd2c35813337b33185f738e577", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -160,21 +160,21 @@ pub struct Pick<'tcx> {\n     pub kind: PickKind<'tcx>,\n     pub import_ids: SmallVec<[LocalDefId; 1]>,\n \n-    // Indicates that the source expression should be autoderef'd N times\n-    //\n-    // A = expr | *expr | **expr | ...\n+    /// Indicates that the source expression should be autoderef'd N times\n+    ///\n+    ///     A = expr | *expr | **expr | ...\n     pub autoderefs: usize,\n \n-    // Indicates that an autoref is applied after the optional autoderefs\n-    //\n-    // B = A | &A | &mut A\n+    /// Indicates that an autoref is applied after the optional autoderefs\n+    ///\n+    ///     B = A | &A | &mut A\n     pub autoref: Option<hir::Mutability>,\n \n-    // Indicates that the source expression should be \"unsized\" to a\n-    // target type. This should probably eventually go away in favor\n-    // of just coercing method receivers.\n-    //\n-    // C = B | unsize(B)\n+    /// Indicates that the source expression should be \"unsized\" to a\n+    /// target type. This should probably eventually go away in favor\n+    /// of just coercing method receivers.\n+    ///\n+    ///     C = B | unsize(B)\n     pub unsize: Option<Ty<'tcx>>,\n }\n \n@@ -1091,19 +1091,17 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             .next()\n     }\n \n+    /// For each type `T` in the step list, this attempts to find a method where\n+    /// the (transformed) self type is exactly `T`. We do however do one\n+    /// transformation on the adjustment: if we are passing a region pointer in,\n+    /// we will potentially *reborrow* it to a shorter lifetime. This allows us\n+    /// to transparently pass `&mut` pointers, in particular, without consuming\n+    /// them for their entire lifetime.\n     fn pick_by_value_method(\n         &mut self,\n         step: &CandidateStep<'tcx>,\n         self_ty: Ty<'tcx>,\n     ) -> Option<PickResult<'tcx>> {\n-        //! For each type `T` in the step list, this attempts to find a\n-        //! method where the (transformed) self type is exactly `T`. We\n-        //! do however do one transformation on the adjustment: if we\n-        //! are passing a region pointer in, we will potentially\n-        //! *reborrow* it to a shorter lifetime. This allows us to\n-        //! transparently pass `&mut` pointers, in particular, without\n-        //! consuming them for their entire lifetime.\n-\n         if step.unsize {\n             return None;\n         }"}, {"sha": "941f82a8070a02e1861c23d57a567c4d2993ed4e", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -278,14 +278,14 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     pub fn insert(self, value: V) -> &'a mut V {\n         let out_ptr = match self.handle.insert_recursing(self.key, value) {\n             (Fit(_), val_ptr) => {\n-                // Safety: We have consumed self.handle and the handle returned.\n+                // SAFETY: We have consumed self.handle and the handle returned.\n                 let map = unsafe { self.dormant_map.awaken() };\n                 map.length += 1;\n                 val_ptr\n             }\n             (Split(ins), val_ptr) => {\n                 drop(ins.left);\n-                // Safety: We have consumed self.handle and the reference returned.\n+                // SAFETY: We have consumed self.handle and the reference returned.\n                 let map = unsafe { self.dormant_map.awaken() };\n                 let root = map.root.as_mut().unwrap();\n                 root.push_internal_level().push(ins.kv.0, ins.kv.1, ins.right);"}, {"sha": "b1b2619428366fbfcb18d19a9432a0884d83aa0f", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -1938,13 +1938,13 @@ impl<T, A: Allocator> Vec<T, A> {\n     pub fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]) {\n         let ptr = self.as_mut_ptr();\n \n-        // Safety:\n+        // SAFETY:\n         // - `ptr` is guaranteed to be in bounds for `capacity` elements\n         // - `len` is guaranteed to less or equal to `capacity`\n         // - `MaybeUninit<T>` has the same layout as `T`\n         let spare_ptr = unsafe { ptr.cast::<MaybeUninit<T>>().add(self.len) };\n \n-        // Safety:\n+        // SAFETY:\n         // - `ptr` is guaranteed to be valid for `len` elements\n         // - `spare_ptr` is offseted from `ptr` by `len`, so it doesn't overlap `initialized` slice\n         unsafe {\n@@ -2154,7 +2154,8 @@ pub fn from_elem_in<T: Clone, A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<\n }\n \n trait ExtendFromWithinSpec {\n-    /// Safety:\n+    /// # Safety\n+    ///\n     /// - `src` needs to be valid index\n     /// - `self.capacity() - self.len()` must be `>= src.len()`\n     unsafe fn spec_extend_from_within(&mut self, src: Range<usize>);\n@@ -2165,14 +2166,14 @@ impl<T: Clone, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n         let initialized = {\n             let (this, spare) = self.split_at_spare_mut();\n \n-            // Safety:\n+            // SAFETY:\n             // - caller guaratees that src is a valid index\n             let to_clone = unsafe { this.get_unchecked(src) };\n \n             to_clone.iter().cloned().zip(spare.iter_mut()).map(|(e, s)| s.write(e)).count()\n         };\n \n-        // Safety:\n+        // SAFETY:\n         // - elements were just initialized\n         unsafe {\n             let new_len = self.len() + initialized;\n@@ -2187,11 +2188,11 @@ impl<T: Copy, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n         {\n             let (init, spare) = self.split_at_spare_mut();\n \n-            // Safety:\n+            // SAFETY:\n             // - caller guaratees that `src` is a valid index\n             let source = unsafe { init.get_unchecked(src) };\n \n-            // Safety:\n+            // SAFETY:\n             // - Both pointers are created from unique slice references (`&mut [_]`)\n             //   so they are valid and do not overlap.\n             // - Elements are :Copy so it's OK to to copy them, without doing\n@@ -2203,7 +2204,7 @@ impl<T: Copy, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n             unsafe { ptr::copy_nonoverlapping(source.as_ptr(), spare.as_mut_ptr() as _, count) };\n         }\n \n-        // Safety:\n+        // SAFETY:\n         // - The elements were just initialized by `copy_nonoverlapping`\n         self.len += count;\n     }"}, {"sha": "eb60df214c489cff2d420e15b68f811cdbdd2d22", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -106,7 +106,7 @@ impl<I: Write> BufferedCopySpec for BufWriter<I> {\n                     Ok(0) => return Ok(len), // EOF reached\n                     Ok(bytes_read) => {\n                         assert!(bytes_read <= spare_cap.len());\n-                        // Safety: The initializer contract guarantees that either it or `read`\n+                        // SAFETY: The initializer contract guarantees that either it or `read`\n                         // will have initialized these bytes. And we just checked that the number\n                         // of bytes is within the buffer capacity.\n                         unsafe { buf.set_len(buf.len() + bytes_read) };"}, {"sha": "aec2a2aa639edc799f2d87fff6535e595a984dff", "filename": "library/std/src/lazy.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Fstd%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Fstd%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -440,13 +440,17 @@ impl<T> SyncOnceCell<T> {\n         res\n     }\n \n-    /// Safety: The value must be initialized\n+    /// # Safety\n+    ///\n+    /// The value must be initialized\n     unsafe fn get_unchecked(&self) -> &T {\n         debug_assert!(self.is_initialized());\n         (&*self.value.get()).assume_init_ref()\n     }\n \n-    /// Safety: The value must be initialized\n+    /// # Safety\n+    ///\n+    /// The value must be initialized\n     unsafe fn get_unchecked_mut(&mut self) -> &mut T {\n         debug_assert!(self.is_initialized());\n         (&mut *self.value.get()).assume_init_mut()\n@@ -456,7 +460,7 @@ impl<T> SyncOnceCell<T> {\n unsafe impl<#[may_dangle] T> Drop for SyncOnceCell<T> {\n     fn drop(&mut self) {\n         if self.is_initialized() {\n-            // Safety: The cell is initialized and being dropped, so it can't\n+            // SAFETY: The cell is initialized and being dropped, so it can't\n             // be accessed again. We also don't touch the `T` other than\n             // dropping it, which validates our usage of #[may_dangle].\n             unsafe { (&mut *self.value.get()).assume_init_drop() };"}, {"sha": "88a27f27f6628e866cf620e7da76a440af0defc9", "filename": "library/std/src/sys/unix/ext/process.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -172,6 +172,8 @@ impl CommandExt for process::Command {\n     }\n \n     fn exec(&mut self) -> io::Error {\n+        // NOTE: This may *not* be safe to call after `libc::fork`, because it\n+        // may allocate. That may be worth fixing at some point in the future.\n         self.as_inner_mut().exec(sys::process::Stdio::Inherit)\n     }\n "}, {"sha": "b9dcc4e4b9e381c13b078e55781c1a7f8946a573", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -60,25 +60,13 @@ cfg_if::cfg_if! {\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct Command {\n-    // Currently we try hard to ensure that the call to `.exec()` doesn't\n-    // actually allocate any memory. While many platforms try to ensure that\n-    // memory allocation works after a fork in a multithreaded process, it's\n-    // been observed to be buggy and somewhat unreliable, so we do our best to\n-    // just not do it at all!\n-    //\n-    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n-    // what's gonna get passed to `execvp`. The `argv` array starts with the\n-    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n-    // also null-terminated.\n-    //\n-    // Right now we don't support removing arguments, so there's no much fancy\n-    // support there, but we support adding and removing environment variables,\n-    // so a side table is used to track where in the `envp` array each key is\n-    // located. Whenever we add a key we update it in place if it's already\n-    // present, and whenever we remove a key we update the locations of all\n-    // other keys.\n     program: CString,\n     args: Vec<CString>,\n+    /// Exactly what will be passed to `execvp`.\n+    ///\n+    /// First element is a pointer to `program`, followed by pointers to\n+    /// `args`, followed by a `null`. Be careful when modifying `program` or\n+    /// `args` to properly update this as well.\n     argv: Argv,\n     env: CommandEnv,\n "}, {"sha": "b8f512f6a232fc88fdf64fd3b2eb05fa1f3441f6", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -8,7 +8,9 @@ mod tests;\n pub const MAIN_SEP_STR: &str = \"\\\\\";\n pub const MAIN_SEP: char = '\\\\';\n \n-// Safety: `bytes` must be a valid wtf8 encoded slice\n+/// # Safety\n+///\n+/// `bytes` must be a valid wtf8 encoded slice\n #[inline]\n unsafe fn bytes_as_os_str(bytes: &[u8]) -> &OsStr {\n     // &OsStr is layout compatible with &Slice, which is compatible with &Wtf8,\n@@ -130,7 +132,7 @@ fn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n             // The max `separator_end` is `bytes.len()` and `bytes[bytes.len()..]` is a valid index.\n             let path = &path.bytes()[separator_end..];\n \n-            // Safety: `path` is a valid wtf8 encoded slice and each of the separators ('/', '\\')\n+            // SAFETY: `path` is a valid wtf8 encoded slice and each of the separators ('/', '\\')\n             // is encoded in a single byte, therefore `bytes[separator_start]` and\n             // `bytes[separator_end]` must be code point boundaries and thus\n             // `bytes[..separator_start]` and `bytes[separator_end..]` are valid wtf8 slices."}, {"sha": "70b31b19f824cb16eda7030a235fc7de88d3f4c5", "filename": "library/std/src/sys_common/rwlock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -103,7 +103,7 @@ impl StaticRWLock {\n     /// The lock is automatically unlocked when the returned guard is dropped.\n     #[inline]\n     pub fn read_with_guard(&'static self) -> RWLockReadGuard {\n-        // Safety: All methods require static references, therefore self\n+        // SAFETY: All methods require static references, therefore self\n         // cannot be moved between invocations.\n         unsafe {\n             self.0.read();\n@@ -117,7 +117,7 @@ impl StaticRWLock {\n     /// The lock is automatically unlocked when the returned guard is dropped.\n     #[inline]\n     pub fn write_with_guard(&'static self) -> RWLockWriteGuard {\n-        // Safety: All methods require static references, therefore self\n+        // SAFETY: All methods require static references, therefore self\n         // cannot be moved between invocations.\n         unsafe {\n             self.0.write();"}, {"sha": "29a267053b47d109e1f3d68154104701ee802e22", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -286,8 +286,8 @@ achieve that will result in false positive reports.\n \n Detecting the use of uninitialized memory. The `-Zbuild-std` flag rebuilds and\n instruments the standard library, and is strictly necessary for the correct\n-operation of the tool. The `-Zsanitizer-track-origins` enables tracking of the\n-origins of uninitialized memory:\n+operation of the tool. The `-Zsanitizer-memory-track-origins` enables tracking\n+of the origins of uninitialized memory:\n \n ```rust\n use std::mem::MaybeUninit;"}, {"sha": "22780804610b6365821d0bb67ad621912db541fd", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -66,7 +66,7 @@ Other features provided by lang items include:\n   marked with lang items; those specific four are `eq`, `ord`,\n   `deref`, and `add` respectively.\n - stack unwinding and general failure; the `eh_personality`,\n-  `panic` and `panic_bounds_checks` lang items.\n+  `panic` and `panic_bounds_check` lang items.\n - the traits in `std::marker` used to indicate types of\n   various kinds; lang items `send`, `sync` and `copy`.\n - the marker types and variance indicators found in"}, {"sha": "9045adb54dc1e425bb9825b85c867799515f30fe", "filename": "src/etc/pre-commit.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Fetc%2Fpre-commit.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Fetc%2Fpre-commit.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fpre-commit.sh?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -1,7 +1,7 @@\n #!/usr/bin/env bash\n #\n # Call `tidy --bless` before each commit\n-# Copy this scripts to .git/hooks to activate,\n+# Copy this script to .git/hooks to activate,\n # and remove it from .git/hooks to deactivate.\n #\n "}, {"sha": "6665f160dec8a2933469174665c1246fe3178417", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -1343,7 +1343,6 @@ impl AllTypes {\n                          </a>\\\n                      </span>\n                  </span>\n-                 <span class=\\\"in-band\\\">List of all items</span>\\\n              </h1>\",\n         );\n         // Note: print_entries does not escape the title, because we know the current set of titles"}, {"sha": "224c794fb3b4a035cc8ad077756a0f8d1c5a4102", "filename": "src/librustdoc/html/render/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -38,3 +38,14 @@ fn test_name_sorting() {\n     sorted.sort_by(|&l, r| compare_names(l, r));\n     assert_eq!(names, sorted);\n }\n+\n+#[test]\n+fn test_all_types_prints_header_once() {\n+    // Regression test for #82477\n+    let all_types = AllTypes::new();\n+\n+    let mut buffer = Buffer::new();\n+    all_types.print(&mut buffer);\n+\n+    assert_eq!(1, buffer.into_inner().matches(\"List of all items\").count());\n+}"}, {"sha": "d4d44049c9186d15e96a24f0063aef0e11a667a6", "filename": "src/test/ui/treat-err-as-bug/delay_span_bug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -4,6 +4,7 @@\n // error-pattern: [trigger_delay_span_bug] trigger a delay span bug\n // normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n // normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n+// rustc-env:RUST_BACKTRACE=0\n \n #![feature(rustc_attrs)]\n "}, {"sha": "c23c2b81b9767904dec24a0ddbc5c7101c31cb45", "filename": "src/test/ui/treat-err-as-bug/delay_span_bug.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.stderr?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -1,5 +1,5 @@\n error: internal compiler error: delayed span bug triggered by #[rustc_error(delay_span_bug_from_inside_query)]\n-  --> $DIR/delay_span_bug.rs:11:1\n+  --> $DIR/delay_span_bug.rs:12:1\n    |\n LL | fn main() {}\n    | ^^^^^^^^^"}, {"sha": "de3e9ed6cf910e5cda2d8c97bf10b83da0c0993e", "filename": "src/test/ui/treat-err-as-bug/err.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Ferr.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -4,6 +4,7 @@\n // error-pattern: [eval_to_allocation_raw] const-evaluating + checking `C`\n // normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n // normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n+// rustc-env:RUST_BACKTRACE=0\n \n #![crate_type = \"rlib\"]\n "}, {"sha": "8f67571c2990ea56a1c2494fd2331fb36cb5423f", "filename": "src/test/ui/treat-err-as-bug/err.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Ferr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Ferr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Ferr.stderr?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -1,5 +1,5 @@\n error[E0080]: could not evaluate static initializer\n-  --> $DIR/err.rs:10:21\n+  --> $DIR/err.rs:11:21\n    |\n LL | pub static C: u32 = 0 - 1;\n    |                     ^^^^^ attempt to compute `0_u32 - 1_u32`, which would overflow"}, {"sha": "b32a6f08638cc028ee9ddaead485e0fb0ba240e1", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -195,11 +195,17 @@ pub fn parse_config(args: Vec<String>) -> Config {\n \n     let src_base = opt_path(matches, \"src-base\");\n     let run_ignored = matches.opt_present(\"ignored\");\n-    let has_tidy = Command::new(\"tidy\")\n-        .arg(\"--version\")\n-        .stdout(Stdio::null())\n-        .status()\n-        .map_or(false, |status| status.success());\n+    let mode = matches.opt_str(\"mode\").unwrap().parse().expect(\"invalid mode\");\n+    let has_tidy = if mode == Mode::Rustdoc {\n+        Command::new(\"tidy\")\n+            .arg(\"--version\")\n+            .stdout(Stdio::null())\n+            .status()\n+            .map_or(false, |status| status.success())\n+    } else {\n+        // Avoid spawning an external command when we know tidy won't be used.\n+        false\n+    };\n     Config {\n         bless: matches.opt_present(\"bless\"),\n         compile_lib_path: make_absolute(opt_path(matches, \"compile-lib-path\")),\n@@ -218,7 +224,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         src_base,\n         build_base: opt_path(matches, \"build-base\"),\n         stage_id: matches.opt_str(\"stage-id\").unwrap(),\n-        mode: matches.opt_str(\"mode\").unwrap().parse().expect(\"invalid mode\"),\n+        mode,\n         suite: matches.opt_str(\"suite\").unwrap(),\n         debugger: None,\n         run_ignored,"}, {"sha": "75c43343023f9a08ece28e7e1dfdbf092c9d8c73", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a54cc4eb6111cac9ad75cc439f75b79698b4a7/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=c0a54cc4eb6111cac9ad75cc439f75b79698b4a7", "patch": "@@ -289,7 +289,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n                     suppressible_tidy_err!(err, skip_undocumented_unsafe, \"undocumented unsafe\");\n                 }\n             }\n-            if line.contains(\"// SAFETY:\") || line.contains(\"// Safety:\") {\n+            if line.contains(\"// SAFETY:\") {\n                 last_safety_comment = true;\n             } else if line.trim().starts_with(\"//\") || line.trim().is_empty() {\n                 // keep previous value"}]}