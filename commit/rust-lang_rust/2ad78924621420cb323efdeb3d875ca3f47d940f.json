{"sha": "2ad78924621420cb323efdeb3d875ca3f47d940f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZDc4OTI0NjIxNDIwY2IzMjNlZmRlYjNkODc1Y2EzZjQ3ZDk0MGY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-13T17:35:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-13T17:35:03Z"}, "message": "Merge #9253\n\n9253: internal: refactor missing or or some diagnostic r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "eb34ec6e46f8a15b015e62dc404773a938e45819", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb34ec6e46f8a15b015e62dc404773a938e45819"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ad78924621420cb323efdeb3d875ca3f47d940f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgxkHHCRBK7hj4Ov3rIwAAABAIAEoBArVnQQZ0x6ty8jP+aBqS\nU1Jau/J4rzSWZZKKvIt3vSuze6RPm3Z+1rVhan4usjd4v29cTziLrXWUhcwezP3M\nKB3crQfcVxc7RcgX0j/sJPzvrE/+dgDNT15RueZ69PP2MYX/jIvrXfEja9BF3b3l\nxREPnzs4l3u5kEQ1wwWKb4TXAK4Axf5I+eHOGfWnPwLKNKTdHJgR8+HJJOoTLuhi\n9J9+YPvSEt4tQr32cUQW9st2O1E+wTakdkzR9YTGWuttu7Zzdxonvx99TFotW99O\nXQjpH4Jc1m+I0rFsOgfjEpAZ2vsBt9IVxIZe6uxrDIZGbFrvTwYAs6yVBmJBBus=\n=Bq4G\n-----END PGP SIGNATURE-----\n", "payload": "tree eb34ec6e46f8a15b015e62dc404773a938e45819\nparent 60ca03e8aa00956d1511969da5f1844a02483bc9\nparent b66f4bb8d1748b83a6f4c5edc3c77a46b213e1c2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623605703 +0000\ncommitter GitHub <noreply@github.com> 1623605703 +0000\n\nMerge #9253\n\n9253: internal: refactor missing or or some diagnostic r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad78924621420cb323efdeb3d875ca3f47d940f", "html_url": "https://github.com/rust-lang/rust/commit/2ad78924621420cb323efdeb3d875ca3f47d940f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ad78924621420cb323efdeb3d875ca3f47d940f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60ca03e8aa00956d1511969da5f1844a02483bc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/60ca03e8aa00956d1511969da5f1844a02483bc9", "html_url": "https://github.com/rust-lang/rust/commit/60ca03e8aa00956d1511969da5f1844a02483bc9"}, {"sha": "b66f4bb8d1748b83a6f4c5edc3c77a46b213e1c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b66f4bb8d1748b83a6f4c5edc3c77a46b213e1c2", "html_url": "https://github.com/rust-lang/rust/commit/b66f4bb8d1748b83a6f4c5edc3c77a46b213e1c2"}], "stats": {"total": 793, "additions": 378, "deletions": 415}, "files": [{"sha": "c294a803b28b755c3cca8cbbab84511118e305d5", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 67, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=2ad78924621420cb323efdeb3d875ca3f47d940f", "patch": "@@ -37,8 +37,11 @@ diagnostics![\n     MacroError,\n     MismatchedArgCount,\n     MissingFields,\n+    MissingOkOrSomeInTailExpr,\n     MissingUnsafe,\n     NoSuchField,\n+    RemoveThisSemicolon,\n+    ReplaceFilterMapNextWithFindMap,\n     UnimplementedBuiltinMacro,\n     UnresolvedExternCrate,\n     UnresolvedImport,\n@@ -119,31 +122,13 @@ pub struct MissingFields {\n     pub missed_fields: Vec<Name>,\n }\n \n-// Diagnostic: replace-filter-map-next-with-find-map\n-//\n-// This diagnostic is triggered when `.filter_map(..).next()` is used, rather than the more concise `.find_map(..)`.\n #[derive(Debug)]\n pub struct ReplaceFilterMapNextWithFindMap {\n     pub file: HirFileId,\n     /// This expression is the whole method chain up to and including `.filter_map(..).next()`.\n     pub next_expr: AstPtr<ast::Expr>,\n }\n \n-impl Diagnostic for ReplaceFilterMapNextWithFindMap {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"replace-filter-map-next-with-find-map\")\n-    }\n-    fn message(&self) -> String {\n-        \"replace filter_map(..).next() with find_map(..)\".to_string()\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.next_expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MismatchedArgCount {\n     pub call_expr: InFile<AstPtr<ast::Expr>>,\n@@ -153,63 +138,16 @@ pub struct MismatchedArgCount {\n \n #[derive(Debug)]\n pub struct RemoveThisSemicolon {\n-    pub file: HirFileId,\n-    pub expr: AstPtr<ast::Expr>,\n-}\n-\n-impl Diagnostic for RemoveThisSemicolon {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"remove-this-semicolon\")\n-    }\n-\n-    fn message(&self) -> String {\n-        \"Remove this semicolon\".to_string()\n-    }\n-\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.expr.clone().into() }\n-    }\n-\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n }\n \n-// Diagnostic: missing-ok-or-some-in-tail-expr\n-//\n-// This diagnostic is triggered if a block that should return `Result` returns a value not wrapped in `Ok`,\n-// or if a block that should return `Option` returns a value not wrapped in `Some`.\n-//\n-// Example:\n-//\n-// ```rust\n-// fn foo() -> Result<u8, ()> {\n-//     10\n-// }\n-// ```\n #[derive(Debug)]\n pub struct MissingOkOrSomeInTailExpr {\n-    pub file: HirFileId,\n-    pub expr: AstPtr<ast::Expr>,\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n     // `Some` or `Ok` depending on whether the return type is Result or Option\n     pub required: String,\n }\n \n-impl Diagnostic for MissingOkOrSomeInTailExpr {\n-    fn code(&self) -> DiagnosticCode {\n-        DiagnosticCode(\"missing-ok-or-some-in-tail-expr\")\n-    }\n-    fn message(&self) -> String {\n-        format!(\"wrap return expression in {}\", self.required)\n-    }\n-    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.expr.clone().into() }\n-    }\n-    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n-        self\n-    }\n-}\n-\n // Diagnostic: missing-match-arm\n //\n // This diagnostic is triggered if `match` block is missing one or more match arms."}, {"sha": "b2731b62fee447d9b21bf95b3578623860e8833a", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=2ad78924621420cb323efdeb3d875ca3f47d940f", "patch": "@@ -1168,10 +1168,13 @@ impl Function {\n                 }\n                 BodyValidationDiagnostic::ReplaceFilterMapNextWithFindMap { method_call_expr } => {\n                     if let Ok(next_source_ptr) = source_map.expr_syntax(method_call_expr) {\n-                        sink.push(ReplaceFilterMapNextWithFindMap {\n-                            file: next_source_ptr.file_id,\n-                            next_expr: next_source_ptr.value,\n-                        });\n+                        acc.push(\n+                            ReplaceFilterMapNextWithFindMap {\n+                                file: next_source_ptr.file_id,\n+                                next_expr: next_source_ptr.value,\n+                            }\n+                            .into(),\n+                        );\n                     }\n                 }\n                 BodyValidationDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n@@ -1184,20 +1187,13 @@ impl Function {\n                 }\n                 BodyValidationDiagnostic::RemoveThisSemicolon { expr } => {\n                     match source_map.expr_syntax(expr) {\n-                        Ok(source_ptr) => sink.push(RemoveThisSemicolon {\n-                            file: source_ptr.file_id,\n-                            expr: source_ptr.value,\n-                        }),\n+                        Ok(expr) => acc.push(RemoveThisSemicolon { expr }.into()),\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n                 BodyValidationDiagnostic::MissingOkOrSomeInTailExpr { expr, required } => {\n                     match source_map.expr_syntax(expr) {\n-                        Ok(source_ptr) => sink.push(MissingOkOrSomeInTailExpr {\n-                            file: source_ptr.file_id,\n-                            expr: source_ptr.value,\n-                            required,\n-                        }),\n+                        Ok(expr) => acc.push(MissingOkOrSomeInTailExpr { expr, required }.into()),\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }"}, {"sha": "814e64ae4ffbf7889b7989235259d55584c3ce3b", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 184, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=2ad78924621420cb323efdeb3d875ca3f47d940f", "patch": "@@ -9,8 +9,11 @@ mod inactive_code;\n mod macro_error;\n mod mismatched_arg_count;\n mod missing_fields;\n+mod missing_ok_or_some_in_tail_expr;\n mod missing_unsafe;\n mod no_such_field;\n+mod remove_this_semicolon;\n+mod replace_filter_map_next_with_find_map;\n mod unimplemented_builtin_macro;\n mod unresolved_extern_crate;\n mod unresolved_import;\n@@ -162,18 +165,9 @@ pub(crate) fn diagnostics(\n     }\n     let res = RefCell::new(res);\n     let sink_builder = DiagnosticSinkBuilder::new()\n-        .on::<hir::diagnostics::MissingOkOrSomeInTailExpr, _>(|d| {\n-            res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n-        })\n-        .on::<hir::diagnostics::RemoveThisSemicolon, _>(|d| {\n-            res.borrow_mut().push(diagnostic_with_fix(d, &sema, resolve));\n-        })\n         .on::<hir::diagnostics::IncorrectCase, _>(|d| {\n             res.borrow_mut().push(warning_with_fix(d, &sema, resolve));\n         })\n-        .on::<hir::diagnostics::ReplaceFilterMapNextWithFindMap, _>(|d| {\n-            res.borrow_mut().push(warning_with_fix(d, &sema, resolve));\n-        })\n         .on::<UnlinkedFile, _>(|d| {\n             // Limit diagnostic to the first few characters in the file. This matches how VS Code\n             // renders it with the full span, but on other editors, and is less invasive.\n@@ -223,10 +217,13 @@ pub(crate) fn diagnostics(\n         let d = match diag {\n             AnyDiagnostic::BreakOutsideOfLoop(d) => break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => macro_error::macro_error(&ctx, &d),\n+            AnyDiagnostic::MismatchedArgCount(d) => mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n+            AnyDiagnostic::MissingOkOrSomeInTailExpr(d) => missing_ok_or_some_in_tail_expr::missing_ok_or_some_in_tail_expr(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => missing_unsafe::missing_unsafe(&ctx, &d),\n-            AnyDiagnostic::MismatchedArgCount(d) => mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => no_such_field::no_such_field(&ctx, &d),\n+            AnyDiagnostic::RemoveThisSemicolon(d) => remove_this_semicolon::remove_this_semicolon(&ctx, &d),\n+            AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n             AnyDiagnostic::UnimplementedBuiltinMacro(d) => unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),\n             AnyDiagnostic::UnresolvedExternCrate(d) => unresolved_extern_crate::unresolved_extern_crate(&ctx, &d),\n             AnyDiagnostic::UnresolvedImport(d) => unresolved_import::unresolved_import(&ctx, &d),\n@@ -253,16 +250,6 @@ pub(crate) fn diagnostics(\n     res\n }\n \n-fn diagnostic_with_fix<D: DiagnosticWithFixes>(\n-    d: &D,\n-    sema: &Semantics<RootDatabase>,\n-    resolve: &AssistResolveStrategy,\n-) -> Diagnostic {\n-    Diagnostic::error(sema.diagnostics_display_range(d.display_source()).range, d.message())\n-        .with_fixes(d.fixes(sema, resolve))\n-        .with_code(Some(d.code()))\n-}\n-\n fn warning_with_fix<D: DiagnosticWithFixes>(\n     d: &D,\n     sema: &Semantics<RootDatabase>,\n@@ -448,39 +435,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    fn range_mapping_out_of_macros() {\n-        // FIXME: this is very wrong, but somewhat tricky to fix.\n-        check_fix(\n-            r#\"\n-fn some() {}\n-fn items() {}\n-fn here() {}\n-\n-macro_rules! id { ($($tt:tt)*) => { $($tt)*}; }\n-\n-fn main() {\n-    let _x = id![Foo { a: $042 }];\n-}\n-\n-pub struct Foo { pub a: i32, pub b: i32 }\n-\"#,\n-            r#\"\n-fn some(, b: () ) {}\n-fn items() {}\n-fn here() {}\n-\n-macro_rules! id { ($($tt:tt)*) => { $($tt)*}; }\n-\n-fn main() {\n-    let _x = id![Foo { a: 42 }];\n-}\n-\n-pub struct Foo { pub a: i32, pub b: i32 }\n-\"#,\n-        );\n-    }\n-\n     #[test]\n     fn test_check_unnecessary_braces_in_use_statement() {\n         check_diagnostics(\n@@ -717,137 +671,6 @@ mod foo;\n         );\n     }\n \n-    // Register the required standard library types to make the tests work\n-    fn add_filter_map_with_find_next_boilerplate(body: &str) -> String {\n-        let prefix = r#\"\n-        //- /main.rs crate:main deps:core\n-        use core::iter::Iterator;\n-        use core::option::Option::{self, Some, None};\n-        \"#;\n-        let suffix = r#\"\n-        //- /core/lib.rs crate:core\n-        pub mod option {\n-            pub enum Option<T> { Some(T), None }\n-        }\n-        pub mod iter {\n-            pub trait Iterator {\n-                type Item;\n-                fn filter_map<B, F>(self, f: F) -> FilterMap where F: FnMut(Self::Item) -> Option<B> { FilterMap }\n-                fn next(&mut self) -> Option<Self::Item>;\n-            }\n-            pub struct FilterMap {}\n-            impl Iterator for FilterMap {\n-                type Item = i32;\n-                fn next(&mut self) -> i32 { 7 }\n-            }\n-        }\n-        \"#;\n-        format!(\"{}{}{}\", prefix, body, suffix)\n-    }\n-\n-    #[test]\n-    fn replace_filter_map_next_with_find_map2() {\n-        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n-            r#\"\n-            fn foo() {\n-                let m = [1, 2, 3].iter().filter_map(|x| if *x == 2 { Some (4) } else { None }).next();\n-                      //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ replace filter_map(..).next() with find_map(..)\n-            }\n-        \"#,\n-        ));\n-    }\n-\n-    #[test]\n-    fn replace_filter_map_next_with_find_map_no_diagnostic_without_next() {\n-        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n-            r#\"\n-            fn foo() {\n-                let m = [1, 2, 3]\n-                    .iter()\n-                    .filter_map(|x| if *x == 2 { Some (4) } else { None })\n-                    .len();\n-            }\n-            \"#,\n-        ));\n-    }\n-\n-    #[test]\n-    fn replace_filter_map_next_with_find_map_no_diagnostic_with_intervening_methods() {\n-        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n-            r#\"\n-            fn foo() {\n-                let m = [1, 2, 3]\n-                    .iter()\n-                    .filter_map(|x| if *x == 2 { Some (4) } else { None })\n-                    .map(|x| x + 2)\n-                    .len();\n-            }\n-            \"#,\n-        ));\n-    }\n-\n-    #[test]\n-    fn replace_filter_map_next_with_find_map_no_diagnostic_if_not_in_chain() {\n-        check_diagnostics(&add_filter_map_with_find_next_boilerplate(\n-            r#\"\n-            fn foo() {\n-                let m = [1, 2, 3]\n-                    .iter()\n-                    .filter_map(|x| if *x == 2 { Some (4) } else { None });\n-                let n = m.next();\n-            }\n-            \"#,\n-        ));\n-    }\n-\n-    #[test]\n-    fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n-        check_diagnostics(\n-            r\"\n-struct S { foo: i32, bar: () }\n-fn baz(s: S) -> i32 {\n-    match s {\n-        S { foo, .. } => foo,\n-    }\n-}\n-\",\n-        )\n-    }\n-\n-    #[test]\n-    fn missing_record_pat_field_box() {\n-        check_diagnostics(\n-            r\"\n-struct S { s: Box<u32> }\n-fn x(a: S) {\n-    let S { box s } = a;\n-}\n-\",\n-        )\n-    }\n-\n-    #[test]\n-    fn missing_record_pat_field_ref() {\n-        check_diagnostics(\n-            r\"\n-struct S { s: u32 }\n-fn x(a: S) {\n-    let S { ref s } = a;\n-}\n-\",\n-        )\n-    }\n-\n-    #[test]\n-    fn missing_semicolon() {\n-        check_diagnostics(\n-            r#\"\n-                fn test() -> i32 { 123; }\n-                                 //^^^ Remove this semicolon\n-            \"#,\n-        );\n-    }\n-\n     #[test]\n     fn import_extern_crate_clash_with_inner_item() {\n         // This is more of a resolver test, but doesn't really work with the hir_def testsuite."}, {"sha": "e4bd90c3fc396e365de0825bc8d32bd6ef7ce46f", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=2ad78924621420cb323efdeb3d875ca3f47d940f", "patch": "@@ -1,10 +1,6 @@\n //! Provides a way to attach fixes to the diagnostics.\n //! The same module also has all curret custom fixes for the diagnostics implemented.\n mod change_case;\n-mod create_field;\n-mod remove_semicolon;\n-mod replace_with_find_map;\n-mod wrap_tail_expr;\n \n use hir::{diagnostics::Diagnostic, Semantics};\n use ide_assists::AssistResolveStrategy;"}, {"sha": "8b137891791fe96927ad78e64b0aad7bded08bdc", "filename": "crates/ide/src/diagnostics/fixes/create_field.rs", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fcreate_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fcreate_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fcreate_field.rs?ref=60ca03e8aa00956d1511969da5f1844a02483bc9", "patch": "@@ -1 +0,0 @@\n-"}, {"sha": "f1724d47918c35be20ff0d7fc9fecc759cf43110", "filename": "crates/ide/src/diagnostics/fixes/remove_semicolon.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fremove_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fremove_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fremove_semicolon.rs?ref=60ca03e8aa00956d1511969da5f1844a02483bc9", "patch": "@@ -1,41 +0,0 @@\n-use hir::{db::AstDatabase, diagnostics::RemoveThisSemicolon, Semantics};\n-use ide_assists::{Assist, AssistResolveStrategy};\n-use ide_db::{source_change::SourceChange, RootDatabase};\n-use syntax::{ast, AstNode};\n-use text_edit::TextEdit;\n-\n-use crate::diagnostics::{fix, DiagnosticWithFixes};\n-\n-impl DiagnosticWithFixes for RemoveThisSemicolon {\n-    fn fixes(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-\n-        let semicolon = self\n-            .expr\n-            .to_node(&root)\n-            .syntax()\n-            .parent()\n-            .and_then(ast::ExprStmt::cast)\n-            .and_then(|expr| expr.semicolon_token())?\n-            .text_range();\n-\n-        let edit = TextEdit::delete(semicolon);\n-        let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n-\n-        Some(vec![fix(\"remove_semicolon\", \"Remove this semicolon\", source_change, semicolon)])\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::diagnostics::tests::check_fix;\n-\n-    #[test]\n-    fn remove_semicolon() {\n-        check_fix(r#\"fn f() -> i32 { 92$0; }\"#, r#\"fn f() -> i32 { 92 }\"#);\n-    }\n-}"}, {"sha": "444bf563b557b02f798b0afad93a5a5e3eee03a2", "filename": "crates/ide/src/diagnostics/fixes/replace_with_find_map.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Freplace_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60ca03e8aa00956d1511969da5f1844a02483bc9/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Freplace_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Freplace_with_find_map.rs?ref=60ca03e8aa00956d1511969da5f1844a02483bc9", "patch": "@@ -1,84 +0,0 @@\n-use hir::{db::AstDatabase, diagnostics::ReplaceFilterMapNextWithFindMap, Semantics};\n-use ide_assists::{Assist, AssistResolveStrategy};\n-use ide_db::{source_change::SourceChange, RootDatabase};\n-use syntax::{\n-    ast::{self, ArgListOwner},\n-    AstNode, TextRange,\n-};\n-use text_edit::TextEdit;\n-\n-use crate::diagnostics::{fix, DiagnosticWithFixes};\n-\n-impl DiagnosticWithFixes for ReplaceFilterMapNextWithFindMap {\n-    fn fixes(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let next_expr = self.next_expr.to_node(&root);\n-        let next_call = ast::MethodCallExpr::cast(next_expr.syntax().clone())?;\n-\n-        let filter_map_call = ast::MethodCallExpr::cast(next_call.receiver()?.syntax().clone())?;\n-        let filter_map_name_range = filter_map_call.name_ref()?.ident_token()?.text_range();\n-        let filter_map_args = filter_map_call.arg_list()?;\n-\n-        let range_to_replace =\n-            TextRange::new(filter_map_name_range.start(), next_expr.syntax().text_range().end());\n-        let replacement = format!(\"find_map{}\", filter_map_args.syntax().text());\n-        let trigger_range = next_expr.syntax().text_range();\n-\n-        let edit = TextEdit::replace(range_to_replace, replacement);\n-\n-        let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n-\n-        Some(vec![fix(\n-            \"replace_with_find_map\",\n-            \"Replace filter_map(..).next() with find_map()\",\n-            source_change,\n-            trigger_range,\n-        )])\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::diagnostics::tests::check_fix;\n-\n-    #[test]\n-    fn replace_with_wind_map() {\n-        check_fix(\n-            r#\"\n-//- /main.rs crate:main deps:core\n-use core::iter::Iterator;\n-use core::option::Option::{self, Some, None};\n-fn foo() {\n-    let m = [1, 2, 3].iter().$0filter_map(|x| if *x == 2 { Some (4) } else { None }).next();\n-}\n-//- /core/lib.rs crate:core\n-pub mod option {\n-    pub enum Option<T> { Some(T), None }\n-}\n-pub mod iter {\n-    pub trait Iterator {\n-        type Item;\n-        fn filter_map<B, F>(self, f: F) -> FilterMap where F: FnMut(Self::Item) -> Option<B> { FilterMap }\n-        fn next(&mut self) -> Option<Self::Item>;\n-    }\n-    pub struct FilterMap {}\n-    impl Iterator for FilterMap {\n-        type Item = i32;\n-        fn next(&mut self) -> i32 { 7 }\n-    }\n-}\n-\"#,\n-            r#\"\n-use core::iter::Iterator;\n-use core::option::Option::{self, Some, None};\n-fn foo() {\n-    let m = [1, 2, 3].iter().find_map(|x| if *x == 2 { Some (4) } else { None });\n-}\n-\"#,\n-        )\n-    }\n-}"}, {"sha": "d01f050414cbbd56a12ff8e88d4cd804c0743d50", "filename": "crates/ide/src/diagnostics/missing_fields.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_fields.rs?ref=2ad78924621420cb323efdeb3d875ca3f47d940f", "patch": "@@ -93,6 +93,77 @@ fn baz(s: S) {\n         );\n     }\n \n+    #[test]\n+    fn missing_record_pat_field_no_diagnostic_if_not_exhaustive() {\n+        check_diagnostics(\n+            r\"\n+struct S { foo: i32, bar: () }\n+fn baz(s: S) -> i32 {\n+    match s {\n+        S { foo, .. } => foo,\n+    }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn missing_record_pat_field_box() {\n+        check_diagnostics(\n+            r\"\n+struct S { s: Box<u32> }\n+fn x(a: S) {\n+    let S { box s } = a;\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn missing_record_pat_field_ref() {\n+        check_diagnostics(\n+            r\"\n+struct S { s: u32 }\n+fn x(a: S) {\n+    let S { ref s } = a;\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn range_mapping_out_of_macros() {\n+        // FIXME: this is very wrong, but somewhat tricky to fix.\n+        check_fix(\n+            r#\"\n+fn some() {}\n+fn items() {}\n+fn here() {}\n+\n+macro_rules! id { ($($tt:tt)*) => { $($tt)*}; }\n+\n+fn main() {\n+    let _x = id![Foo { a: $042 }];\n+}\n+\n+pub struct Foo { pub a: i32, pub b: i32 }\n+\"#,\n+            r#\"\n+fn some(, b: () ) {}\n+fn items() {}\n+fn here() {}\n+\n+macro_rules! id { ($($tt:tt)*) => { $($tt)*}; }\n+\n+fn main() {\n+    let _x = id![Foo { a: 42 }];\n+}\n+\n+pub struct Foo { pub a: i32, pub b: i32 }\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_fill_struct_fields_empty() {\n         check_fix("}, {"sha": "06005d156c0552cc87f07f2aea9dfd253da6a59d", "filename": "crates/ide/src/diagnostics/missing_ok_or_some_in_tail_expr.rs", "status": "renamed", "additions": 39, "deletions": 20, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_ok_or_some_in_tail_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_ok_or_some_in_tail_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fmissing_ok_or_some_in_tail_expr.rs?ref=2ad78924621420cb323efdeb3d875ca3f47d940f", "patch": "@@ -1,26 +1,45 @@\n-use hir::{db::AstDatabase, diagnostics::MissingOkOrSomeInTailExpr, Semantics};\n-use ide_assists::{Assist, AssistResolveStrategy};\n-use ide_db::{source_change::SourceChange, RootDatabase};\n+use hir::db::AstDatabase;\n+use ide_assists::Assist;\n+use ide_db::source_change::SourceChange;\n use syntax::AstNode;\n use text_edit::TextEdit;\n \n-use crate::diagnostics::{fix, DiagnosticWithFixes};\n-\n-impl DiagnosticWithFixes for MissingOkOrSomeInTailExpr {\n-    fn fixes(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Vec<Assist>> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let tail_expr = self.expr.to_node(&root);\n-        let tail_expr_range = tail_expr.syntax().text_range();\n-        let replacement = format!(\"{}({})\", self.required, tail_expr.syntax());\n-        let edit = TextEdit::replace(tail_expr_range, replacement);\n-        let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n-        let name = if self.required == \"Ok\" { \"Wrap with Ok\" } else { \"Wrap with Some\" };\n-        Some(vec![fix(\"wrap_tail_expr\", name, source_change, tail_expr_range)])\n-    }\n+use crate::diagnostics::{fix, Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: missing-ok-or-some-in-tail-expr\n+//\n+// This diagnostic is triggered if a block that should return `Result` returns a value not wrapped in `Ok`,\n+// or if a block that should return `Option` returns a value not wrapped in `Some`.\n+//\n+// Example:\n+//\n+// ```rust\n+// fn foo() -> Result<u8, ()> {\n+//     10\n+// }\n+// ```\n+pub(super) fn missing_ok_or_some_in_tail_expr(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::MissingOkOrSomeInTailExpr,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"missing-ok-or-some-in-tail-expr\",\n+        format!(\"wrap return expression in {}\", d.required),\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingOkOrSomeInTailExpr) -> Option<Vec<Assist>> {\n+    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n+    let tail_expr = d.expr.value.to_node(&root);\n+    let tail_expr_range = tail_expr.syntax().text_range();\n+    let replacement = format!(\"{}({})\", d.required, tail_expr.syntax());\n+    let edit = TextEdit::replace(tail_expr_range, replacement);\n+    let source_change =\n+        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+    let name = if d.required == \"Ok\" { \"Wrap with Ok\" } else { \"Wrap with Some\" };\n+    Some(vec![fix(\"wrap_tail_expr\", name, source_change, tail_expr_range)])\n }\n \n #[cfg(test)]", "previous_filename": "crates/ide/src/diagnostics/fixes/wrap_tail_expr.rs"}, {"sha": "edc63c2468cd37b2b8c9cac5d2dc77c5cb98f3bf", "filename": "crates/ide/src/diagnostics/no_such_field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fno_such_field.rs?ref=2ad78924621420cb323efdeb3d875ca3f47d940f", "patch": "@@ -17,7 +17,7 @@ use crate::{\n pub(super) fn no_such_field(ctx: &DiagnosticsContext<'_>, d: &hir::NoSuchField) -> Diagnostic {\n     Diagnostic::new(\n         \"no-such-field\",\n-        \"no such field\".to_string(),\n+        \"no such field\",\n         ctx.sema.diagnostics_display_range(d.field.clone().map(|it| it.into())).range,\n     )\n     .with_fixes(fixes(ctx, d))"}, {"sha": "814cb0f8c280b4127c91327d5057b737f66ccd8d", "filename": "crates/ide/src/diagnostics/remove_this_semicolon.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Fremove_this_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Fremove_this_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Fremove_this_semicolon.rs?ref=2ad78924621420cb323efdeb3d875ca3f47d940f", "patch": "@@ -0,0 +1,64 @@\n+use hir::db::AstDatabase;\n+use ide_db::source_change::SourceChange;\n+use syntax::{ast, AstNode};\n+use text_edit::TextEdit;\n+\n+use crate::{\n+    diagnostics::{fix, Diagnostic, DiagnosticsContext},\n+    Assist,\n+};\n+\n+// Diagnostic: remove-this-semicolon\n+//\n+// This diagnostic is triggered when there's an erroneous `;` at the end of the block.\n+pub(super) fn remove_this_semicolon(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::RemoveThisSemicolon,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"remove-this-semicolon\",\n+        \"remove this semicolon\",\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::RemoveThisSemicolon) -> Option<Vec<Assist>> {\n+    let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n+\n+    let semicolon = d\n+        .expr\n+        .value\n+        .to_node(&root)\n+        .syntax()\n+        .parent()\n+        .and_then(ast::ExprStmt::cast)\n+        .and_then(|expr| expr.semicolon_token())?\n+        .text_range();\n+\n+    let edit = TextEdit::delete(semicolon);\n+    let source_change =\n+        SourceChange::from_text_edit(d.expr.file_id.original_file(ctx.sema.db), edit);\n+\n+    Some(vec![fix(\"remove_semicolon\", \"Remove this semicolon\", source_change, semicolon)])\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::{check_diagnostics, check_fix};\n+\n+    #[test]\n+    fn missing_semicolon() {\n+        check_diagnostics(\n+            r#\"\n+fn test() -> i32 { 123; }\n+                 //^^^ remove this semicolon\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_semicolon() {\n+        check_fix(r#\"fn f() -> i32 { 92$0; }\"#, r#\"fn f() -> i32 { 92 }\"#);\n+    }\n+}"}, {"sha": "f3b011495b8a8c8cd5af9090eeaa38acce9849b6", "filename": "crates/ide/src/diagnostics/replace_filter_map_next_with_find_map.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Freplace_filter_map_next_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad78924621420cb323efdeb3d875ca3f47d940f/crates%2Fide%2Fsrc%2Fdiagnostics%2Freplace_filter_map_next_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Freplace_filter_map_next_with_find_map.rs?ref=2ad78924621420cb323efdeb3d875ca3f47d940f", "patch": "@@ -0,0 +1,182 @@\n+use hir::{db::AstDatabase, InFile};\n+use ide_db::source_change::SourceChange;\n+use syntax::{\n+    ast::{self, ArgListOwner},\n+    AstNode, TextRange,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::{\n+    diagnostics::{fix, Diagnostic, DiagnosticsContext},\n+    Assist, Severity,\n+};\n+\n+// Diagnostic: replace-filter-map-next-with-find-map\n+//\n+// This diagnostic is triggered when `.filter_map(..).next()` is used, rather than the more concise `.find_map(..)`.\n+pub(super) fn replace_filter_map_next_with_find_map(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::ReplaceFilterMapNextWithFindMap,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"replace-filter-map-next-with-find-map\",\n+        \"replace filter_map(..).next() with find_map(..)\",\n+        ctx.sema.diagnostics_display_range(InFile::new(d.file, d.next_expr.clone().into())).range,\n+    )\n+    .severity(Severity::WeakWarning)\n+    .with_fixes(fixes(ctx, d))\n+}\n+\n+fn fixes(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::ReplaceFilterMapNextWithFindMap,\n+) -> Option<Vec<Assist>> {\n+    let root = ctx.sema.db.parse_or_expand(d.file)?;\n+    let next_expr = d.next_expr.to_node(&root);\n+    let next_call = ast::MethodCallExpr::cast(next_expr.syntax().clone())?;\n+\n+    let filter_map_call = ast::MethodCallExpr::cast(next_call.receiver()?.syntax().clone())?;\n+    let filter_map_name_range = filter_map_call.name_ref()?.ident_token()?.text_range();\n+    let filter_map_args = filter_map_call.arg_list()?;\n+\n+    let range_to_replace =\n+        TextRange::new(filter_map_name_range.start(), next_expr.syntax().text_range().end());\n+    let replacement = format!(\"find_map{}\", filter_map_args.syntax().text());\n+    let trigger_range = next_expr.syntax().text_range();\n+\n+    let edit = TextEdit::replace(range_to_replace, replacement);\n+\n+    let source_change = SourceChange::from_text_edit(d.file.original_file(ctx.sema.db), edit);\n+\n+    Some(vec![fix(\n+        \"replace_with_find_map\",\n+        \"Replace filter_map(..).next() with find_map()\",\n+        source_change,\n+        trigger_range,\n+    )])\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_fix;\n+\n+    // Register the required standard library types to make the tests work\n+    #[track_caller]\n+    fn check_diagnostics(ra_fixture: &str) {\n+        let prefix = r#\"\n+//- /main.rs crate:main deps:core\n+use core::iter::Iterator;\n+use core::option::Option::{self, Some, None};\n+\"#;\n+        let suffix = r#\"\n+//- /core/lib.rs crate:core\n+pub mod option {\n+    pub enum Option<T> { Some(T), None }\n+}\n+pub mod iter {\n+    pub trait Iterator {\n+        type Item;\n+        fn filter_map<B, F>(self, f: F) -> FilterMap where F: FnMut(Self::Item) -> Option<B> { FilterMap }\n+        fn next(&mut self) -> Option<Self::Item>;\n+    }\n+    pub struct FilterMap {}\n+    impl Iterator for FilterMap {\n+        type Item = i32;\n+        fn next(&mut self) -> i32 { 7 }\n+    }\n+}\n+\"#;\n+        crate::diagnostics::tests::check_diagnostics(&format!(\"{}{}{}\", prefix, ra_fixture, suffix))\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map2() {\n+        check_diagnostics(\n+            r#\"\n+    fn foo() {\n+        let m = [1, 2, 3].iter().filter_map(|x| if *x == 2 { Some (4) } else { None }).next();\n+    }         //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ replace filter_map(..).next() with find_map(..)\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map_no_diagnostic_without_next() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    let m = [1, 2, 3]\n+        .iter()\n+        .filter_map(|x| if *x == 2 { Some (4) } else { None })\n+        .len();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map_no_diagnostic_with_intervening_methods() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    let m = [1, 2, 3]\n+        .iter()\n+        .filter_map(|x| if *x == 2 { Some (4) } else { None })\n+        .map(|x| x + 2)\n+        .len();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_filter_map_next_with_find_map_no_diagnostic_if_not_in_chain() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    let m = [1, 2, 3]\n+        .iter()\n+        .filter_map(|x| if *x == 2 { Some (4) } else { None });\n+    let n = m.next();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_with_wind_map() {\n+        check_fix(\n+            r#\"\n+//- /main.rs crate:main deps:core\n+use core::iter::Iterator;\n+use core::option::Option::{self, Some, None};\n+fn foo() {\n+    let m = [1, 2, 3].iter().$0filter_map(|x| if *x == 2 { Some (4) } else { None }).next();\n+}\n+//- /core/lib.rs crate:core\n+pub mod option {\n+    pub enum Option<T> { Some(T), None }\n+}\n+pub mod iter {\n+    pub trait Iterator {\n+        type Item;\n+        fn filter_map<B, F>(self, f: F) -> FilterMap where F: FnMut(Self::Item) -> Option<B> { FilterMap }\n+        fn next(&mut self) -> Option<Self::Item>;\n+    }\n+    pub struct FilterMap {}\n+    impl Iterator for FilterMap {\n+        type Item = i32;\n+        fn next(&mut self) -> i32 { 7 }\n+    }\n+}\n+\"#,\n+            r#\"\n+use core::iter::Iterator;\n+use core::option::Option::{self, Some, None};\n+fn foo() {\n+    let m = [1, 2, 3].iter().find_map(|x| if *x == 2 { Some (4) } else { None });\n+}\n+\"#,\n+        )\n+    }\n+}"}]}