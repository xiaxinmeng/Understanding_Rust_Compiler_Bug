{"sha": "43acb501b93c637b32fa134ba8cf586d82e96732", "node_id": "C_kwDOAAsO6NoAKDQzYWNiNTAxYjkzYzYzN2IzMmZhMTM0YmE4Y2Y1ODZkODJlOTY3MzI", "commit": {"author": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-07-24T08:37:08Z"}, "committer": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-07-24T08:37:08Z"}, "message": "Add 'src/tools/rust-analyzer/' from commit '977e12a0bdc3e329af179ef3a9d466af9eb613bb'\n\ngit-subtree-dir: src/tools/rust-analyzer\ngit-subtree-mainline: 3c98486a0cdb6d92f0fca34ffb1fd46c0e498653\ngit-subtree-split: 977e12a0bdc3e329af179ef3a9d466af9eb613bb", "tree": {"sha": "949f39638614b460137b2bf5d9edf88cac77bba5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/949f39638614b460137b2bf5d9edf88cac77bba5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43acb501b93c637b32fa134ba8cf586d82e96732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43acb501b93c637b32fa134ba8cf586d82e96732", "html_url": "https://github.com/rust-lang/rust/commit/43acb501b93c637b32fa134ba8cf586d82e96732", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43acb501b93c637b32fa134ba8cf586d82e96732/comments", "author": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c98486a0cdb6d92f0fca34ffb1fd46c0e498653", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c98486a0cdb6d92f0fca34ffb1fd46c0e498653", "html_url": "https://github.com/rust-lang/rust/commit/3c98486a0cdb6d92f0fca34ffb1fd46c0e498653"}, {"sha": "977e12a0bdc3e329af179ef3a9d466af9eb613bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/977e12a0bdc3e329af179ef3a9d466af9eb613bb", "html_url": "https://github.com/rust-lang/rust/commit/977e12a0bdc3e329af179ef3a9d466af9eb613bb"}], "stats": {"total": 345854, "additions": 345854, "deletions": 0}, "files": [{"sha": "24745d1c806febc2fbcc4fd04207d94d0b148782", "filename": "src/tools/rust-analyzer/.cargo/config.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.cargo%2Fconfig.toml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.cargo%2Fconfig.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.cargo%2Fconfig.toml?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,11 @@\n+[alias]\n+xtask = \"run --package xtask --bin xtask --\"\n+tq = \"test -- -q\"\n+qt = \"tq\"\n+lint = \"clippy --all-targets -- -Aclippy::collapsible_if -Aclippy::needless_pass_by_value -Aclippy::nonminimal_bool -Aclippy::redundant_pattern_matching --cap-lints warn\"\n+\n+[target.x86_64-pc-windows-msvc]\n+linker = \"rust-lld\"\n+\n+[env]\n+CARGO_WORKSPACE_DIR = { value = \"\", relative = true }\n\\ No newline at end of file"}, {"sha": "314f79d3f901c5482629fb54380e6cf6906383b7", "filename": "src/tools/rust-analyzer/.editorconfig", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.editorconfig?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,19 @@\n+# https://EditorConfig.org\n+root = true\n+\n+[*]\n+charset = utf-8\n+trim_trailing_whitespace = true\n+end_of_line = lf\n+insert_final_newline = true\n+indent_style = space\n+\n+[*.{rs,toml}]\n+indent_size = 4\n+\n+[*.ts]\n+indent_size = 4\n+[*.js]\n+indent_size = 4\n+[*.json]\n+indent_size = 4"}, {"sha": "a302e23781ae9127e461ae35ad87af3b0ec05029", "filename": "src/tools/rust-analyzer/.git-blame-ignore-revs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.git-blame-ignore-revs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.git-blame-ignore-revs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.git-blame-ignore-revs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,8 @@\n+# for this file to take effect make sure you use git ^2.23 and\n+# add ignoreFile to your git configuration:\n+# ```\n+# git config --global blame.ignoreRevsFile .git-blame-ignore-revs\n+# ```\n+\n+# prettier format\n+f247090558c9ba3c551566eae5882b7ca865225f"}, {"sha": "3b3d2d0d656d32c909b61bfbeb33b4bbb1b36387", "filename": "src/tools/rust-analyzer/.gitattributes", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.gitattributes?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,8 @@\n+* text=auto eol=lf\n+# git grep shouldn't match entries in this benchmark data\n+bench_data/** binary\n+crates/syntax/test_data/** -text eof=LF\n+# Older git versions try to fix line endings on images, this prevents it.\n+*.png binary\n+*.jpg binary\n+*.ico binary"}, {"sha": "a08ad07cbf8d3b5af82424d9cc78865cc5d70095", "filename": "src/tools/rust-analyzer/.github/ISSUE_TEMPLATE/blank_issue.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fblank_issue.md?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,10 @@\n+---\n+name: Blank Issue\n+about: Create a blank issue.\n+title: ''\n+labels: ''\n+assignees: ''\n+\n+---\n+\n+"}, {"sha": "7ba06356a37ceaed48e84b0e7a40d749ecf9c8e3", "filename": "src/tools/rust-analyzer/.github/ISSUE_TEMPLATE/bug_report.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,26 @@\n+---\n+name: Bug report\n+about: Create a bug report for rust-analyzer.\n+title: ''\n+labels: ''\n+assignees: ''\n+\n+---\n+\n+<!--\n+Troubleshooting guide: https://rust-analyzer.github.io/manual.html#troubleshooting\n+Forum for questions: https://users.rust-lang.org/c/ide/14\n+\n+Before submitting, please make sure that you're not running into one of these known issues:\n+\n+ 1. extension doesn't load in VSCodium: #11080\n+ 2. on-the-fly diagnostics are mostly unimplemented (`cargo check` diagnostics will be shown when saving a file): #3107\n+\n+Otherwise please try to provide information which will help us to fix the issue faster. Minimal reproducible examples with few dependencies are especially lovely <3.\n+-->\n+\n+**rust-analyzer version**: (eg. output of \"Rust Analyzer: Show RA Version\" command)\n+\n+**rustc version**: (eg. output of `rustc -V`)\n+\n+**relevant settings**: (eg. client settings, or environment variables like `CARGO`, `RUSTUP_HOME` or `CARGO_HOME`)"}, {"sha": "a0b1627d7e2efba51625f4332849c3ee6f02aefb", "filename": "src/tools/rust-analyzer/.github/ISSUE_TEMPLATE/critical_nightly_regression.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fcritical_nightly_regression.md", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fcritical_nightly_regression.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2FISSUE_TEMPLATE%2Fcritical_nightly_regression.md?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,17 @@\n+---\n+name: Critical Nightly Regression\n+about: You are using nightly rust-analyzer and the latest version is unusable.\n+title: ''\n+labels: ''\n+assignees: 'matklad'\n+\n+---\n+\n+<!--\n+Troubleshooting guide: https://rust-analyzer.github.io/manual.html#troubleshooting\n+\n+Please try to provide information which will help us to fix the issue faster. Minimal reproducible examples with few dependencies are especially lovely <3.\n+-->\n+\n+This is a serious regression in nightly and it's important to fix it before the next release.\n+@matklad, please take a look."}, {"sha": "5849eac7d246a30549ffff371a5e54ae0d099967", "filename": "src/tools/rust-analyzer/.github/actions/github-release/Dockerfile", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2FDockerfile?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,8 @@\n+FROM node:slim\n+\n+COPY . /action\n+WORKDIR /action\n+\n+RUN npm install --production\n+\n+ENTRYPOINT [\"node\", \"/action/main.js\"]"}, {"sha": "7b50d002001ee85a3fcdf0d4ac67638332b176d5", "filename": "src/tools/rust-analyzer/.github/actions/github-release/README.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2FREADME.md?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,21 @@\n+# github-release\n+\n+Copy-pasted from\n+https://github.com/bytecodealliance/wasmtime/tree/8acfdbdd8aa550d1b84e0ce1e6222a6605d14e38/.github/actions/github-release\n+\n+An action used to publish GitHub releases for `wasmtime`.\n+\n+As of the time of this writing there's a few actions floating around which\n+perform github releases but they all tend to have their set of drawbacks.\n+Additionally nothing handles deleting releases which we need for our rolling\n+`dev` release.\n+\n+To handle all this this action rolls-its-own implementation using the\n+actions/toolkit repository and packages published there. These run in a Docker\n+container and take various inputs to orchestrate the release from the build.\n+\n+More comments can be found in `main.js`.\n+\n+Testing this is really hard. If you want to try though run `npm install` and\n+then `node main.js`. You'll have to configure a bunch of env vars though to get\n+anything reasonably working."}, {"sha": "51a074adfaa886dba302f4e019002cb19ba23e15", "filename": "src/tools/rust-analyzer/.github/actions/github-release/action.yml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2Faction.yml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2Faction.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2Faction.yml?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,15 @@\n+name: 'wasmtime github releases'\n+description: 'wasmtime github releases'\n+inputs:\n+  token:\n+    description: ''\n+    required: true\n+  name:\n+    description: ''\n+    required: true\n+  files:\n+    description: ''\n+    required: true\n+runs:\n+  using: 'docker'\n+  image: 'Dockerfile'"}, {"sha": "e8dba398733c181da3306330778fda29b2310f49", "filename": "src/tools/rust-analyzer/.github/actions/github-release/main.js", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2Fmain.js?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,144 @@\n+const core = require('@actions/core');\n+const path = require(\"path\");\n+const fs = require(\"fs\");\n+const github = require('@actions/github');\n+const glob = require('glob');\n+\n+function sleep(milliseconds) {\n+  return new Promise(resolve => setTimeout(resolve, milliseconds));\n+}\n+\n+async function runOnce() {\n+  // Load all our inputs and env vars. Note that `getInput` reads from `INPUT_*`\n+  const files = core.getInput('files');\n+  const name = core.getInput('name');\n+  const token = core.getInput('token');\n+  const slug = process.env.GITHUB_REPOSITORY;\n+  const owner = slug.split('/')[0];\n+  const repo = slug.split('/')[1];\n+  const sha = process.env.HEAD_SHA;\n+\n+  core.info(`files: ${files}`);\n+  core.info(`name: ${name}`);\n+\n+  const options = {\n+    request: {\n+      timeout: 30000,\n+    }\n+  };\n+  const octokit = github.getOctokit(token, options);\n+\n+  // Delete the previous release since we can't overwrite one. This may happen\n+  // due to retrying an upload or it may happen because we're doing the dev\n+  // release.\n+  const releases = await octokit.paginate(\"GET /repos/:owner/:repo/releases\", { owner, repo });\n+  for (const release of releases) {\n+    if (release.tag_name !== name) {\n+      continue;\n+    }\n+    const release_id = release.id;\n+    core.info(`deleting release ${release_id}`);\n+    await octokit.rest.repos.deleteRelease({ owner, repo, release_id });\n+  }\n+\n+  // We also need to update the `dev` tag while we're at it on the `dev` branch.\n+  if (name == 'nightly') {\n+    try {\n+      core.info(`updating nightly tag`);\n+      await octokit.rest.git.updateRef({\n+        owner,\n+        repo,\n+        ref: 'tags/nightly',\n+        sha,\n+        force: true,\n+      });\n+    } catch (e) {\n+      core.error(e);\n+      core.info(`creating nightly tag`);\n+      await octokit.rest.git.createTag({\n+        owner,\n+        repo,\n+        tag: 'nightly',\n+        message: 'nightly release',\n+        object: sha,\n+        type: 'commit',\n+      });\n+    }\n+  }\n+\n+  // Creates an official GitHub release for this `tag`, and if this is `dev`\n+  // then we know that from the previous block this should be a fresh release.\n+  core.info(`creating a release`);\n+  const release = await octokit.rest.repos.createRelease({\n+    owner,\n+    repo,\n+    name,\n+    tag_name: name,\n+    target_commitish: sha,\n+    prerelease: name === 'nightly',\n+  });\n+  const release_id = release.data.id;\n+\n+  // Upload all the relevant assets for this release as just general blobs.\n+  for (const file of glob.sync(files)) {\n+    const size = fs.statSync(file).size;\n+    const name = path.basename(file);\n+\n+    await runWithRetry(async function () {\n+      // We can't overwrite assets, so remove existing ones from a previous try.\n+      let assets = await octokit.rest.repos.listReleaseAssets({\n+        owner,\n+        repo,\n+        release_id\n+      });\n+      for (const asset of assets.data) {\n+        if (asset.name === name) {\n+          core.info(`delete asset ${name}`);\n+          const asset_id = asset.id;\n+          await octokit.rest.repos.deleteReleaseAsset({ owner, repo, asset_id });\n+        }\n+      }\n+\n+      core.info(`upload ${file}`);\n+      const headers = { 'content-length': size, 'content-type': 'application/octet-stream' };\n+      const data = fs.createReadStream(file);\n+      await octokit.rest.repos.uploadReleaseAsset({\n+        data,\n+        headers,\n+        name,\n+        url: release.data.upload_url,\n+      });\n+    });\n+  }\n+}\n+\n+async function runWithRetry(f) {\n+  const retries = 10;\n+  const maxDelay = 4000;\n+  let delay = 1000;\n+\n+  for (let i = 0; i < retries; i++) {\n+    try {\n+      await f();\n+      break;\n+    } catch (e) {\n+      if (i === retries - 1)\n+        throw e;\n+\n+      core.error(e);\n+      const currentDelay = Math.round(Math.random() * delay);\n+      core.info(`sleeping ${currentDelay} ms`);\n+      await sleep(currentDelay);\n+      delay = Math.min(delay * 2, maxDelay);\n+    }\n+  }\n+}\n+\n+async function run() {\n+  await runWithRetry(runOnce);\n+}\n+\n+run().catch(err => {\n+  core.error(err);\n+  core.setFailed(err.message);\n+});"}, {"sha": "af4bf074d2d03b76ff18c1a4b6172462d8418eef", "filename": "src/tools/rust-analyzer/.github/actions/github-release/package.json", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Factions%2Fgithub-release%2Fpackage.json?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,10 @@\n+{\n+  \"name\": \"wasmtime-github-release\",\n+  \"version\": \"0.0.0\",\n+  \"main\": \"main.js\",\n+  \"dependencies\": {\n+    \"@actions/core\": \"^1.6\",\n+    \"@actions/github\": \"^5.0\",\n+    \"glob\": \"^7.1.5\"\n+  }\n+}"}, {"sha": "0c81ff0789fbbd592c784a3bf299ffdf7ea23f67", "filename": "src/tools/rust-analyzer/.github/workflows/ci.yaml", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,156 @@\n+# Please make sure that the `needs` fields for both `end-success` and `end-failure`\n+# are updated when adding new jobs!\n+\n+name: CI\n+on:\n+  pull_request:\n+  push:\n+    branches:\n+    - auto\n+    - try\n+\n+env:\n+  CARGO_INCREMENTAL: 0\n+  CARGO_NET_RETRY: 10\n+  CI: 1\n+  RUST_BACKTRACE: short\n+  RUSTFLAGS: \"-D warnings -W unreachable-pub -W rust-2021-compatibility\"\n+  RUSTUP_MAX_RETRIES: 10\n+\n+jobs:\n+  rust:\n+    if: github.repository == 'rust-lang/rust-analyzer'\n+    name: Rust\n+    runs-on: ${{ matrix.os }}\n+    env:\n+      CC: deny_c\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        os: [ubuntu-latest, windows-latest, macos-latest]\n+\n+    steps:\n+    - name: Checkout repository\n+      uses: actions/checkout@v3\n+      with:\n+        ref: ${{ github.event.pull_request.head.sha }}\n+        fetch-depth: 20\n+\n+    - name: Install Rust toolchain\n+      run: |\n+        rustup update --no-self-update stable\n+        rustup component add rustfmt rust-src\n+\n+    - name: Cache Dependencies\n+      uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n+\n+    - name: Compile\n+      run: cargo test --no-run --locked\n+\n+    - name: Test\n+      run: cargo test -- --nocapture --quiet\n+\n+  # Weird targets to catch non-portable code\n+  rust-cross:\n+    if: github.repository == 'rust-lang/rust-analyzer'\n+    name: Rust Cross\n+    runs-on: ubuntu-latest\n+\n+    env:\n+      targets: \"powerpc-unknown-linux-gnu x86_64-unknown-linux-musl\"\n+      # The rust-analyzer binary is not expected to compile on WASM, but the IDE\n+      # crate should\n+      targets_ide: \"wasm32-unknown-unknown\"\n+\n+    steps:\n+    - name: Checkout repository\n+      uses: actions/checkout@v3\n+\n+    - name: Install Rust toolchain\n+      run: |\n+        rustup update --no-self-update stable\n+        rustup target add ${{ env.targets }} ${{ env.targets_ide }}\n+\n+    - name: Cache Dependencies\n+      uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n+\n+    - name: Check\n+      run: |\n+        for target in ${{ env.targets }}; do\n+          cargo check --target=$target --all-targets\n+        done\n+        for target in ${{ env.targets_ide }}; do\n+          cargo check -p ide --target=$target --all-targets\n+        done\n+\n+  typescript:\n+    if: github.repository == 'rust-lang/rust-analyzer'\n+    name: TypeScript\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        os: [ubuntu-latest, windows-latest]\n+\n+    runs-on: ${{ matrix.os }}\n+\n+    steps:\n+    - name: Checkout repository\n+      uses: actions/checkout@v3\n+\n+    - name: Install Nodejs\n+      uses: actions/setup-node@v1\n+      with:\n+        node-version: 14.x\n+\n+    - name: Install xvfb\n+      if: matrix.os == 'ubuntu-latest'\n+      run: sudo apt-get install -y xvfb\n+\n+    - run: npm ci\n+      working-directory: ./editors/code\n+\n+#    - run: npm audit || { sleep 10 && npm audit; } || { sleep 30 && npm audit; }\n+#      if: runner.os == 'Linux'\n+#      working-directory: ./editors/code\n+\n+    - run: npm run lint\n+      working-directory: ./editors/code\n+\n+    - name: Run VS Code tests (Linux)\n+      if: matrix.os == 'ubuntu-latest'\n+      env:\n+        VSCODE_CLI: 1\n+      run: xvfb-run npm test\n+      working-directory: ./editors/code\n+\n+    - name: Run VS Code tests (Windows)\n+      if: matrix.os == 'windows-latest'\n+      env:\n+        VSCODE_CLI: 1\n+      run: npm test\n+      working-directory: ./editors/code\n+\n+    - run: npm run pretest\n+      working-directory: ./editors/code\n+\n+    - run: npm run package --scripts-prepend-node-path\n+      working-directory: ./editors/code\n+\n+  end-success:\n+    name: bors build finished\n+    if: github.event.pusher.name == 'bors' && success()\n+    runs-on: ubuntu-latest\n+    needs: [rust, rust-cross, typescript]\n+    steps:\n+      - name: Mark the job as successful\n+        run: exit 0\n+\n+  end-failure:\n+    name: bors build finished\n+    if: github.event.pusher.name == 'bors' && (failure() || cancelled())\n+    runs-on: ubuntu-latest\n+    needs: [rust, rust-cross, typescript]\n+    steps:\n+      - name: Mark the job as a failure\n+        run: exit 1"}, {"sha": "3fe2fc917a39a294c224c054821aea3a7cafd3d2", "filename": "src/tools/rust-analyzer/.github/workflows/metrics.yaml", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fmetrics.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fmetrics.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fmetrics.yaml?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,30 @@\n+name: metrics\n+on:\n+  push:\n+   branches:\n+   - master\n+\n+env:\n+  CARGO_INCREMENTAL: 0\n+  CARGO_NET_RETRY: 10\n+  RUSTFLAGS: \"-D warnings -W unreachable-pub\"\n+  RUSTUP_MAX_RETRIES: 10\n+\n+jobs:\n+  metrics:\n+    if: github.repository == 'rust-lang/rust-analyzer'\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - name: Checkout repository\n+      uses: actions/checkout@v3\n+\n+    - name: Install Rust toolchain\n+      run: |\n+        rustup update --no-self-update stable\n+        rustup component add rustfmt rust-src\n+\n+    - name: Collect metrics\n+      run: cargo xtask metrics\n+      env:\n+        METRICS_TOKEN: ${{ secrets.METRICS_TOKEN }}"}, {"sha": "927996c1bef21d7f8a5c631a13577c3ee6fcaeb7", "filename": "src/tools/rust-analyzer/.github/workflows/publish.yml", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish.yml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fpublish.yml?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,41 @@\n+name: publish\n+on:\n+  workflow_dispatch: # We can add version input when 1.0 is released and scheduled releases are removed\n+\n+#   schedule:\n+#     - cron: \"0 0 * * *\" # midnight UTC\n+\n+  push:\n+    branches:\n+      - release\n+\n+jobs:\n+  publish:\n+    name: publish\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout repository\n+        uses: actions/checkout@v3\n+        with:\n+          fetch-depth: 0\n+\n+      - name: Install Rust toolchain\n+        run: rustup update --no-self-update stable\n+\n+      - name: Install cargo-workspaces\n+        run: cargo install cargo-workspaces\n+\n+      - name: Release\n+        env:\n+          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}\n+          PATCH: ${{ github.run_number }}\n+        shell: bash\n+        run: |\n+          git config --global user.email \"runner@gha.local\"\n+          git config --global user.name \"Github Action\"\n+          rm Cargo.lock\n+          cargo workspaces rename ra_ap_%n\n+          find crates/rust-analyzer -type f -name '*.rs' -exec sed -i 's/rust_analyzer/ra_ap_rust_analyzer/g' {} +\n+          # Fix names for crates that were published before switch to kebab-case.\n+          find crates -name 'Cargo.toml' -exec sed -i \"s/ra_ap_base-db/ra_ap_base_db/g; s/ra_ap_hir-def/ra_ap_hir_def/g; s/ra_ap_hir-expand/ra_ap_hir_expand/g; s/ra_ap_hir-ty/ra_ap_hir_ty/g; s/ra_ap_ide-assists/ra_ap_ide_assists/g; s/ra_ap_ide-completion/ra_ap_ide_completion/g; s/ra_ap_ide-db/ra_ap_ide_db/g; s/ra_ap_ide-diagnostics/ra_ap_ide_diagnostics/g; s/ra_ap_ide-ssr/ra_ap_ide_ssr/g; s/ra_ap_proc-macro-api/ra_ap_proc_macro_api/g; s/ra_ap_proc-macro-srv/ra_ap_proc_macro_srv/g; s/ra_ap_project-model/ra_ap_project_model/g; s/ra_ap_test-utils/ra_ap_test_utils/g; s/ra_ap_text-edit/ra_ap_text_edit/g\" {} +\n+          cargo workspaces publish --yes --force '*' --exact --no-git-commit --allow-dirty --skip-published custom 0.0.$PATCH"}, {"sha": "4e62f2cde279905ec463421f2b1127a29c8c2d7c", "filename": "src/tools/rust-analyzer/.github/workflows/release.yaml", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,249 @@\n+name: release\n+on:\n+  schedule:\n+    - cron: \"0 0 * * *\" # midnight UTC\n+\n+  workflow_dispatch:\n+\n+  push:\n+    branches:\n+      - release\n+      - trigger-nightly\n+\n+env:\n+  CARGO_INCREMENTAL: 0\n+  CARGO_NET_RETRY: 10\n+  RUSTFLAGS: \"-D warnings -W unreachable-pub\"\n+  RUSTUP_MAX_RETRIES: 10\n+  FETCH_DEPTH: 0 # pull in the tags for the version string\n+  MACOSX_DEPLOYMENT_TARGET: 10.15\n+  CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER: aarch64-linux-gnu-gcc\n+\n+jobs:\n+  dist:\n+    strategy:\n+      matrix:\n+        include:\n+          - os: windows-latest\n+            target: x86_64-pc-windows-msvc\n+            code-target: win32-x64\n+          - os: windows-latest\n+            target: aarch64-pc-windows-msvc\n+            code-target: win32-arm64\n+          - os: ubuntu-18.04\n+            target: x86_64-unknown-linux-gnu\n+            code-target: linux-x64\n+          - os: ubuntu-18.04\n+            target: aarch64-unknown-linux-gnu\n+            code-target: linux-arm64\n+          - os: macos-11\n+            target: x86_64-apple-darwin\n+            code-target: darwin-x64\n+          - os: macos-11\n+            target: aarch64-apple-darwin\n+            code-target: darwin-arm64\n+\n+    name: dist (${{ matrix.target }})\n+    runs-on: ${{ matrix.os }}\n+\n+    env:\n+      RA_TARGET: ${{ matrix.target }}\n+\n+    steps:\n+      - name: Checkout repository\n+        uses: actions/checkout@v3\n+        with:\n+          fetch-depth: ${{ env.FETCH_DEPTH }}\n+\n+      - name: Install Rust toolchain\n+        run: |\n+          rustup update --no-self-update stable\n+          rustup target add ${{ matrix.target }}\n+          rustup component add rust-src\n+\n+      - name: Install Node.js\n+        uses: actions/setup-node@v1\n+        with:\n+          node-version: 14.x\n+\n+      - name: Update apt repositories\n+        if: matrix.target == 'aarch64-unknown-linux-gnu'\n+        run: sudo apt-get update\n+\n+      - name: Install target toolchain\n+        if: matrix.target == 'aarch64-unknown-linux-gnu'\n+        run: sudo apt-get install gcc-aarch64-linux-gnu\n+\n+      - name: Dist\n+        run: cargo xtask dist --client-patch-version ${{ github.run_number }}\n+\n+      - run: npm ci\n+        working-directory: editors/code\n+\n+      - name: Package Extension (release)\n+        if: github.ref == 'refs/heads/release'\n+        run: npx vsce package -o \"../../dist/rust-analyzer-${{ matrix.code-target }}.vsix\" --target ${{ matrix.code-target }}\n+        working-directory: editors/code\n+\n+      - name: Package Extension (nightly)\n+        if: github.ref != 'refs/heads/release'\n+        run: npx vsce package -o \"../../dist/rust-analyzer-${{ matrix.code-target }}.vsix\" --target ${{ matrix.code-target }} --pre-release\n+        working-directory: editors/code\n+\n+      - if: matrix.target == 'x86_64-unknown-linux-gnu'\n+        run: rm -rf editors/code/server\n+\n+      - if: matrix.target == 'x86_64-unknown-linux-gnu' && github.ref == 'refs/heads/release'\n+        run: npx vsce package -o ../../dist/rust-analyzer-no-server.vsix\n+        working-directory: editors/code\n+\n+      - if: matrix.target == 'x86_64-unknown-linux-gnu' && github.ref != 'refs/heads/release'\n+        run: npx vsce package -o ../../dist/rust-analyzer-no-server.vsix --pre-release\n+        working-directory: editors/code\n+\n+      - name: Run analysis-stats on rust-analyzer\n+        if: matrix.target == 'x86_64-unknown-linux-gnu'\n+        run: target/${{ matrix.target }}/release/rust-analyzer analysis-stats .\n+\n+      - name: Run analysis-stats on rust std library\n+        if: matrix.target == 'x86_64-unknown-linux-gnu'\n+        run: target/${{ matrix.target }}/release/rust-analyzer analysis-stats --with-deps $(rustc --print sysroot)/lib/rustlib/src/rust/library/std\n+\n+      - name: Upload artifacts\n+        uses: actions/upload-artifact@v1\n+        with:\n+          name: dist-${{ matrix.target }}\n+          path: ./dist\n+\n+  dist-x86_64-unknown-linux-musl:\n+    name: dist (x86_64-unknown-linux-musl)\n+    runs-on: ubuntu-latest\n+    env:\n+      RA_TARGET: x86_64-unknown-linux-musl\n+      # For some reason `-crt-static` is not working for clang without lld\n+      RUSTFLAGS: \"-C link-arg=-fuse-ld=lld -C target-feature=-crt-static\"\n+    container:\n+      image: rust:alpine\n+      volumes:\n+        - /usr/local/cargo/registry\n+\n+    steps:\n+      - name: Install dependencies\n+        run: apk add --no-cache git clang lld musl-dev nodejs npm\n+\n+      - name: Checkout repository\n+        uses: actions/checkout@v3\n+        with:\n+          fetch-depth: ${{ env.FETCH_DEPTH }}\n+\n+      - name: Dist\n+        run: cargo xtask dist --client-patch-version ${{ github.run_number }}\n+\n+      - run: npm ci\n+        working-directory: editors/code\n+\n+      - name: Package Extension (release)\n+        if: github.ref == 'refs/heads/release'\n+        run: npx vsce package -o \"../../dist/rust-analyzer-alpine-x64.vsix\" --target alpine-x64\n+        working-directory: editors/code\n+\n+      - name: Package Extension (nightly)\n+        if: github.ref != 'refs/heads/release'\n+        run: npx vsce package -o \"../../dist/rust-analyzer-alpine-x64.vsix\" --target alpine-x64 --pre-release\n+        working-directory: editors/code\n+\n+      - run: rm -rf editors/code/server\n+\n+      - name: Upload artifacts\n+        uses: actions/upload-artifact@v1\n+        with:\n+          name: dist-x86_64-unknown-linux-musl\n+          path: ./dist\n+\n+  publish:\n+    name: publish\n+    runs-on: ubuntu-latest\n+    needs: [\"dist\", \"dist-x86_64-unknown-linux-musl\"]\n+    steps:\n+      - name: Install Nodejs\n+        uses: actions/setup-node@v1\n+        with:\n+          node-version: 14.x\n+\n+      - run: echo \"TAG=$(date --iso -u)\" >> $GITHUB_ENV\n+        if: github.ref == 'refs/heads/release'\n+      - run: echo \"TAG=nightly\" >> $GITHUB_ENV\n+        if: github.ref != 'refs/heads/release'\n+      - run: 'echo \"TAG: $TAG\"'\n+\n+      - name: Checkout repository\n+        uses: actions/checkout@v3\n+        with:\n+          fetch-depth: ${{ env.FETCH_DEPTH }}\n+\n+      - run: echo \"HEAD_SHA=$(git rev-parse HEAD)\" >> $GITHUB_ENV\n+      - run: 'echo \"HEAD_SHA: $HEAD_SHA\"'\n+\n+      - uses: actions/download-artifact@v1\n+        with:\n+          name: dist-aarch64-apple-darwin\n+          path: dist\n+      - uses: actions/download-artifact@v1\n+        with:\n+          name: dist-x86_64-apple-darwin\n+          path: dist\n+      - uses: actions/download-artifact@v1\n+        with:\n+          name: dist-x86_64-unknown-linux-gnu\n+          path: dist\n+      - uses: actions/download-artifact@v1\n+        with:\n+          name: dist-x86_64-unknown-linux-musl\n+          path: dist\n+      - uses: actions/download-artifact@v1\n+        with:\n+          name: dist-aarch64-unknown-linux-gnu\n+          path: dist\n+      - uses: actions/download-artifact@v1\n+        with:\n+          name: dist-x86_64-pc-windows-msvc\n+          path: dist\n+      - uses: actions/download-artifact@v1\n+        with:\n+          name: dist-aarch64-pc-windows-msvc\n+          path: dist\n+      - run: ls -al ./dist\n+\n+      - name: Publish Release\n+        uses: ./.github/actions/github-release\n+        with:\n+          files: \"dist/*\"\n+          name: ${{ env.TAG }}\n+          token: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - run: rm dist/rust-analyzer-no-server.vsix\n+\n+      - run: npm ci\n+        working-directory: ./editors/code\n+\n+      - name: Publish Extension (Code Marketplace, release)\n+        if: github.ref == 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n+        working-directory: ./editors/code\n+        # token from https://dev.azure.com/rust-analyzer/\n+        run: npx vsce publish --pat ${{ secrets.MARKETPLACE_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix\n+\n+      - name: Publish Extension (OpenVSX, release)\n+        if: github.ref == 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n+        working-directory: ./editors/code\n+        # token from https://dev.azure.com/rust-analyzer/\n+        run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix\n+\n+      - name: Publish Extension (Code Marketplace, nightly)\n+        if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n+        working-directory: ./editors/code\n+        run: npx vsce publish --pat ${{ secrets.MARKETPLACE_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix --pre-release\n+\n+      - name: Publish Extension (OpenVSX, nightly)\n+        if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n+        working-directory: ./editors/code\n+        run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix --pre-release"}, {"sha": "05f3e254e5f5aa5e0a10c643dd720be7dc6f0f58", "filename": "src/tools/rust-analyzer/.github/workflows/rustdoc.yaml", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frustdoc.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frustdoc.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frustdoc.yaml?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,34 @@\n+name: rustdoc\n+on:\n+  push:\n+   branches:\n+   - master\n+\n+env:\n+  CARGO_INCREMENTAL: 0\n+  CARGO_NET_RETRY: 10\n+  RUSTFLAGS: \"-D warnings -W unreachable-pub\"\n+  RUSTUP_MAX_RETRIES: 10\n+\n+jobs:\n+  rustdoc:\n+    if: github.repository == 'rust-lang/rust-analyzer'\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - name: Checkout repository\n+      uses: actions/checkout@v3\n+\n+    - name: Install Rust toolchain\n+      run: rustup update --no-self-update stable\n+\n+    - name: Build Documentation\n+      run: cargo doc --all --no-deps\n+\n+    - name: Deploy Docs\n+      uses: peaceiris/actions-gh-pages@364c31d33bb99327c77b3a5438a83a357a6729ad # v3.4.0\n+      with:\n+        github_token: ${{ secrets.GITHUB_TOKEN }}\n+        publish_branch: gh-pages\n+        publish_dir: ./target/doc\n+        force_orphan: true"}, {"sha": "68c87a6b1ed4156fd7ba602dac1ee52edc2e2f0e", "filename": "src/tools/rust-analyzer/.gitignore", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.gitignore?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,16 @@\n+/target/\n+/dist/\n+crates/*/target\n+**/*.rs.bk\n+**/*.rs.pending-snap\n+.idea/*\n+*.log\n+*.iml\n+.vscode/settings.json\n+generated_assists.adoc\n+generated_features.adoc\n+generated_diagnostic.adoc\n+.DS_Store\n+/out/\n+/dump.lsif\n+.envrc"}, {"sha": "027eeabc4c3e50e9002a85343397d5fe271efdf8", "filename": "src/tools/rust-analyzer/.vscode/extensions.json", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.vscode%2Fextensions.json", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.vscode%2Fextensions.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.vscode%2Fextensions.json?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,9 @@\n+{\n+  // See http://go.microsoft.com/fwlink/?LinkId=827846 to learn about workspace recommendations.\n+  // Extension identifier format: ${publisher}.${name}. Example: vscode.csharp\n+\n+  // List of extensions which should be recommended for users of this workspace.\n+  \"recommendations\": [\"vadimcn.vscode-lldb\"],\n+  // List of extensions recommended by VS Code that should not be recommended for users of this workspace.\n+  \"unwantedRecommendations\": []\n+}"}, {"sha": "021b8f048cf2c3f8efae6a9da797650edbf0e238", "filename": "src/tools/rust-analyzer/.vscode/launch.json", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.vscode%2Flaunch.json", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.vscode%2Flaunch.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.vscode%2Flaunch.json?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,131 @@\n+{\n+  // Use IntelliSense to learn about possible attributes.\n+  // Hover to view descriptions of existing attributes.\n+  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n+\n+  // NOTE: --disable-extensions\n+  // Disable all installed extensions to increase performance of the debug instance\n+  // and prevent potential conflicts with other installed extensions.\n+\n+  \"version\": \"0.2.0\",\n+  \"configurations\": [\n+    {\n+      // Used for testing the extension with the installed LSP server.\n+      \"name\": \"Run Installed Extension\",\n+      \"type\": \"extensionHost\",\n+      \"request\": \"launch\",\n+      \"runtimeExecutable\": \"${execPath}\",\n+      \"args\": [\n+        // \"--user-data-dir=${workspaceFolder}/target/code\",\n+        \"--disable-extensions\",\n+        \"--extensionDevelopmentPath=${workspaceFolder}/editors/code\"\n+      ],\n+      \"outFiles\": [\n+        \"${workspaceFolder}/editors/code/out/**/*.js\"\n+      ],\n+      \"preLaunchTask\": \"Build Extension\",\n+      \"skipFiles\": [\n+        \"<node_internals>/**/*.js\"\n+      ]\n+    },\n+    {\n+      // Used for testing the extension with a local build of the LSP server (in `target/debug`).\n+      \"name\": \"Run Extension (Debug Build)\",\n+      \"type\": \"extensionHost\",\n+      \"request\": \"launch\",\n+      \"runtimeExecutable\": \"${execPath}\",\n+      \"args\": [\n+        \"--disable-extensions\",\n+        \"--extensionDevelopmentPath=${workspaceFolder}/editors/code\"\n+      ],\n+      \"outFiles\": [\n+        \"${workspaceFolder}/editors/code/out/**/*.js\"\n+      ],\n+      \"preLaunchTask\": \"Build Server and Extension\",\n+      \"skipFiles\": [\n+        \"<node_internals>/**/*.js\"\n+      ],\n+      \"env\": {\n+        \"__RA_LSP_SERVER_DEBUG\": \"${workspaceFolder}/target/debug/rust-analyzer\"\n+      }\n+    },\n+    {\n+      // Used for testing the extension with a local build of the LSP server (in `target/release`).\n+      \"name\": \"Run Extension (Release Build)\",\n+      \"type\": \"extensionHost\",\n+      \"request\": \"launch\",\n+      \"runtimeExecutable\": \"${execPath}\",\n+      \"args\": [\n+        \"--disable-extensions\",\n+        \"--extensionDevelopmentPath=${workspaceFolder}/editors/code\"\n+      ],\n+      \"outFiles\": [\n+        \"${workspaceFolder}/editors/code/out/**/*.js\"\n+      ],\n+      \"preLaunchTask\": \"Build Server (Release) and Extension\",\n+      \"skipFiles\": [\n+        \"<node_internals>/**/*.js\"\n+      ],\n+      \"env\": {\n+        \"__RA_LSP_SERVER_DEBUG\": \"${workspaceFolder}/target/release/rust-analyzer\"\n+      }\n+    },\n+    {\n+      // Used for testing the extension with a local build of the LSP server (in `target/release`)\n+      // with all other extendions loaded.\n+      \"name\": \"Run With Extensions\",\n+      \"type\": \"extensionHost\",\n+      \"request\": \"launch\",\n+      \"runtimeExecutable\": \"${execPath}\",\n+      \"args\": [\n+        \"--disable-extension\", \"matklad.rust-analyzer\",\n+        \"--extensionDevelopmentPath=${workspaceFolder}/editors/code\"\n+      ],\n+      \"outFiles\": [\n+        \"${workspaceFolder}/editors/code/out/**/*.js\"\n+      ],\n+      \"preLaunchTask\": \"Build Server (Release) and Extension\",\n+      \"skipFiles\": [\n+        \"<node_internals>/**/*.js\"\n+      ],\n+      \"env\": {\n+        \"__RA_LSP_SERVER_DEBUG\": \"${workspaceFolder}/target/release/rust-analyzer\"\n+      }\n+    },\n+    {\n+      // Used to attach LLDB to a running LSP server.\n+      // NOTE: Might require root permissions. For this run:\n+      //\n+      // `echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope`\n+      //\n+      // Don't forget to set `debug = 2` in `Cargo.toml` before building the server\n+\n+      \"name\": \"Attach To Server\",\n+      \"type\": \"lldb\",\n+      \"request\": \"attach\",\n+      \"program\": \"${workspaceFolder}/target/debug/rust-analyzer\",\n+      \"pid\": \"${command:pickMyProcess}\",\n+      \"sourceLanguages\": [\n+        \"rust\"\n+      ]\n+    },\n+    {\n+      \"name\": \"Run Unit Tests\",\n+      \"type\": \"extensionHost\",\n+      \"request\": \"launch\",\n+      \"runtimeExecutable\": \"${execPath}\",\n+      \"args\": [\n+          \"--extensionDevelopmentPath=${workspaceFolder}/editors/code\",\n+          \"--extensionTestsPath=${workspaceFolder}/editors/code/out/tests/unit\" ],\n+      \"sourceMaps\": true,\n+      \"outFiles\": [ \"${workspaceFolder}/editors/code/out/tests/unit/**/*.js\" ],\n+      \"preLaunchTask\": \"Pretest\"\n+    },\n+    {\n+      \"name\": \"Win Attach to Server\",\n+      \"type\": \"cppvsdbg\",\n+      \"processId\":\"${command:pickProcess}\",\n+      \"request\": \"attach\"\n+    }\n+  ]\n+}"}, {"sha": "a25dff19e4155d6081665ae3636d609b6bc80863", "filename": "src/tools/rust-analyzer/.vscode/tasks.json", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.vscode%2Ftasks.json", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2F.vscode%2Ftasks.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.vscode%2Ftasks.json?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,67 @@\n+// See https://go.microsoft.com/fwlink/?LinkId=733558\n+// for the documentation about the tasks.json format\n+{\n+  \"version\": \"2.0.0\",\n+  \"tasks\": [\n+    {\n+      \"label\": \"Build Extension in Background\",\n+      \"group\": \"build\",\n+      \"type\": \"npm\",\n+      \"script\": \"watch\",\n+      \"path\": \"editors/code/\",\n+      \"problemMatcher\": {\n+        \"base\": \"$tsc-watch\",\n+        \"fileLocation\": [\"relative\", \"${workspaceFolder}/editors/code/\"]\n+      },\n+      \"isBackground\": true,\n+    },\n+    {\n+      \"label\": \"Build Extension\",\n+      \"group\": \"build\",\n+      \"type\": \"npm\",\n+      \"script\": \"build\",\n+      \"path\": \"editors/code/\",\n+      \"problemMatcher\": {\n+        \"base\": \"$tsc\",\n+        \"fileLocation\": [\"relative\", \"${workspaceFolder}/editors/code/\"]\n+      },\n+    },\n+    {\n+      \"label\": \"Build Server\",\n+      \"group\": \"build\",\n+      \"type\": \"shell\",\n+      \"command\": \"cargo build --package rust-analyzer\",\n+      \"problemMatcher\": \"$rustc\"\n+    },\n+    {\n+      \"label\": \"Build Server (Release)\",\n+      \"group\": \"build\",\n+      \"type\": \"shell\",\n+      \"command\": \"cargo build --release --package rust-analyzer\",\n+      \"problemMatcher\": \"$rustc\"\n+    },\n+    {\n+      \"label\": \"Pretest\",\n+      \"group\": \"build\",\n+      \"isBackground\": false,\n+      \"type\": \"npm\",\n+      \"script\": \"pretest\",\n+      \"path\": \"editors/code/\",\n+      \"problemMatcher\": {\n+        \"base\": \"$tsc\",\n+        \"fileLocation\": [\"relative\", \"${workspaceFolder}/editors/code/\"]\n+      }\n+    },\n+\n+    {\n+      \"label\": \"Build Server and Extension\",\n+      \"dependsOn\": [\"Build Server\", \"Build Extension\"],\n+      \"problemMatcher\": \"$rustc\"\n+    },\n+    {\n+      \"label\": \"Build Server (Release) and Extension\",\n+      \"dependsOn\": [\"Build Server (Release)\", \"Build Extension\"],\n+      \"problemMatcher\": \"$rustc\"\n+    }\n+  ]\n+}"}, {"sha": "4c830006832c978fb8841e76a0e54afe75956d03", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "added", "additions": 2094, "deletions": 0, "changes": 2094, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,2094 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"addr2line\"\n+version = \"0.17.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b\"\n+dependencies = [\n+ \"gimli\",\n+]\n+\n+[[package]]\n+name = \"adler\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n+\n+[[package]]\n+name = \"always-assert\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fbf688625d06217d5b1bb0ea9d9c44a1635fd0ee3534466388d18203174f4d11\"\n+dependencies = [\n+ \"log\",\n+]\n+\n+[[package]]\n+name = \"ansi_term\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"anyhow\"\n+version = \"1.0.58\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bb07d2053ccdbe10e2af2995a2f116c1330396493dc1269f6a91d0ae82e19704\"\n+\n+[[package]]\n+name = \"anymap\"\n+version = \"1.0.0-beta.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8f1f8f5a6f3d50d89e3797d7593a50f96bb2aaa20ca0cc7be1fb673232c91d72\"\n+\n+[[package]]\n+name = \"arbitrary\"\n+version = \"1.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5a7924531f38b1970ff630f03eb20a2fde69db5c590c93b0f3482e95dcc5fd60\"\n+\n+[[package]]\n+name = \"arrayvec\"\n+version = \"0.7.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8da52d66c7071e2e3fa2a1e5c6d088fec47b593032b254f5e980de8ea54454d6\"\n+\n+[[package]]\n+name = \"atty\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n+dependencies = [\n+ \"hermit-abi\",\n+ \"libc\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"autocfg\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n+\n+[[package]]\n+name = \"backtrace\"\n+version = \"0.3.65\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"11a17d453482a265fd5f8479f2a3f405566e6ca627837aaddb85af8b1ab8ef61\"\n+dependencies = [\n+ \"addr2line\",\n+ \"cc\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"miniz_oxide\",\n+ \"object 0.28.4\",\n+ \"rustc-demangle\",\n+]\n+\n+[[package]]\n+name = \"base-db\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cfg\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"salsa\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test-utils\",\n+ \"tt\",\n+ \"vfs\",\n+]\n+\n+[[package]]\n+name = \"bitflags\"\n+version = \"1.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n+\n+[[package]]\n+name = \"camino\"\n+version = \"1.0.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"869119e97797867fd90f5e22af7d0bd274bd4635ebb9eb68c04f3f513ae6c412\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"cargo-platform\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cbdb825da8a5df079a43676dbe042702f1707b1109f713a01420fbb4cc71fa27\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"cargo_metadata\"\n+version = \"0.15.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3abb7553d5b9b8421c6de7cb02606ff15e0c6eea7d8eadd75ef013fd636bec36\"\n+dependencies = [\n+ \"camino\",\n+ \"cargo-platform\",\n+ \"semver\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n+[[package]]\n+name = \"cc\"\n+version = \"1.0.73\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2fff2a6927b3bb87f9595d67196a70493f627687a71d87a0d692242c33f58c11\"\n+\n+[[package]]\n+name = \"cfg\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arbitrary\",\n+ \"derive_arbitrary\",\n+ \"expect-test\",\n+ \"mbe\",\n+ \"oorandom\",\n+ \"rustc-hash\",\n+ \"syntax\",\n+ \"tt\",\n+]\n+\n+[[package]]\n+name = \"cfg-if\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n+\n+[[package]]\n+name = \"chalk-derive\"\n+version = \"0.83.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"83553c2ef7717e58aecdf42dd9e3c876229f5a1f35a16435b5ddc4addef81827\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"synstructure\",\n+]\n+\n+[[package]]\n+name = \"chalk-ir\"\n+version = \"0.83.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2dd42107d579d8ec2a5af20a8de62a37524a67bf6a4c0ff08a950068f0bfea91\"\n+dependencies = [\n+ \"bitflags\",\n+ \"chalk-derive\",\n+ \"lazy_static\",\n+]\n+\n+[[package]]\n+name = \"chalk-recursive\"\n+version = \"0.83.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c444031541a76c13c145e76d91f1548e9feb2240e7f0c3e77879ceb694994f2d\"\n+dependencies = [\n+ \"chalk-derive\",\n+ \"chalk-ir\",\n+ \"chalk-solve\",\n+ \"rustc-hash\",\n+ \"tracing\",\n+]\n+\n+[[package]]\n+name = \"chalk-solve\"\n+version = \"0.83.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c76f2db19c5e8a3d42340cf5b4d90b8c218750536fca35e2bb285ab6653c0bc8\"\n+dependencies = [\n+ \"chalk-derive\",\n+ \"chalk-ir\",\n+ \"ena\",\n+ \"indexmap\",\n+ \"itertools\",\n+ \"petgraph\",\n+ \"rustc-hash\",\n+ \"tracing\",\n+]\n+\n+[[package]]\n+name = \"countme\"\n+version = \"3.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7704b5fdd17b18ae31c4c1da5a2e0305a2bf17b5249300a9ee9ed7b72114c636\"\n+dependencies = [\n+ \"dashmap\",\n+ \"once_cell\",\n+ \"rustc-hash\",\n+]\n+\n+[[package]]\n+name = \"cov-mark\"\n+version = \"2.0.0-pre.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0d48d8f76bd9331f19fe2aaf3821a9f9fb32c3963e1e3d6ce82a8c09cef7444a\"\n+\n+[[package]]\n+name = \"crc32fast\"\n+version = \"1.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b540bd8bc810d3885c6ea91e2018302f68baba2129ab3e88f32389ee9370880d\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"crossbeam\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ae5588f6b3c3cb05239e90bd110f257254aecd01e4635400391aeae07497845\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-channel\",\n+ \"crossbeam-deque\",\n+ \"crossbeam-epoch\",\n+ \"crossbeam-queue\",\n+ \"crossbeam-utils\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-channel\"\n+version = \"0.5.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4c02a4d71819009c192cf4872265391563fd6a84c81ff2c0f2a7026ca4c1d85c\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-utils\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-deque\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6455c0ca19f0d2fbf751b908d5c55c1f5cbc65e03c4225427254b46890bdde1e\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-epoch\",\n+ \"crossbeam-utils\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-epoch\"\n+version = \"0.9.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"07db9d94cbd326813772c968ccd25999e5f8ae22f4f8d1b11effa37ef6ce281d\"\n+dependencies = [\n+ \"autocfg\",\n+ \"cfg-if\",\n+ \"crossbeam-utils\",\n+ \"memoffset\",\n+ \"once_cell\",\n+ \"scopeguard\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-queue\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1f25d8400f4a7a5778f0e4e52384a48cbd9b5c495d110786187fc750075277a2\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-utils\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.8.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7d82ee10ce34d7bc12c2122495e7593a9c41347ecdd64185af4ecf72cb1a7f83\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"once_cell\",\n+]\n+\n+[[package]]\n+name = \"dashmap\"\n+version = \"5.3.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3495912c9c1ccf2e18976439f4443f3fee0fd61f424ff99fde6a66b15ecb448f\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"hashbrown\",\n+ \"lock_api\",\n+ \"parking_lot_core 0.9.3\",\n+]\n+\n+[[package]]\n+name = \"derive_arbitrary\"\n+version = \"1.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c9a577516173adb681466d517d39bd468293bc2c2a16439375ef0f35bba45f3d\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"dissimilar\"\n+version = \"1.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8c97b9233581d84b8e1e689cdd3a47b6f69770084fc246e86a7f78b0d9c1d4a5\"\n+\n+[[package]]\n+name = \"dot\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a74b6c4d4a1cff5f454164363c16b72fa12463ca6b31f4b5f2035a65fa3d5906\"\n+\n+[[package]]\n+name = \"drop_bomb\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9bda8e21c04aca2ae33ffc2fd8c23134f3cac46db123ba97bd9d3f3b8a4a85e1\"\n+\n+[[package]]\n+name = \"either\"\n+version = \"1.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3f107b87b6afc2a64fd13cac55fe06d6c8859f12d4b14cbcdd2c67d0976781be\"\n+\n+[[package]]\n+name = \"ena\"\n+version = \"0.14.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d7402b94a93c24e742487327a7cd839dc9d36fec9de9fb25b09f2dae459f36c3\"\n+dependencies = [\n+ \"log\",\n+]\n+\n+[[package]]\n+name = \"expect-test\"\n+version = \"1.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1d4661aca38d826eb7c72fe128e4238220616de4c0cc00db7bfc38e2e1364dd3\"\n+dependencies = [\n+ \"dissimilar\",\n+ \"once_cell\",\n+]\n+\n+[[package]]\n+name = \"filetime\"\n+version = \"0.2.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e94a7bbaa59354bc20dd75b67f23e2797b4490e9d6928203fb105c79e448c86c\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"windows-sys 0.36.1\",\n+]\n+\n+[[package]]\n+name = \"fixedbitset\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"37ab347416e802de484e4d03c7316c48f1ecb56574dfd4a46a80f173ce1de04d\"\n+\n+[[package]]\n+name = \"flate2\"\n+version = \"1.0.24\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f82b0f4c27ad9f8bfd1f3208d882da2b09c301bc1c828fd3a00d0216d2fbbff6\"\n+dependencies = [\n+ \"crc32fast\",\n+ \"miniz_oxide\",\n+]\n+\n+[[package]]\n+name = \"flycheck\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cargo_metadata\",\n+ \"crossbeam-channel\",\n+ \"jod-thread\",\n+ \"paths\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"stdx\",\n+ \"toolchain\",\n+ \"tracing\",\n+]\n+\n+[[package]]\n+name = \"form_urlencoded\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5fc25a87fa4fd2094bffb06925852034d90a17f0d1e05197d4956d3555752191\"\n+dependencies = [\n+ \"matches\",\n+ \"percent-encoding\",\n+]\n+\n+[[package]]\n+name = \"fs_extra\"\n+version = \"1.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2022715d62ab30faffd124d40b76f4134a550a87792276512b18d63272333394\"\n+\n+[[package]]\n+name = \"fsevent-sys\"\n+version = \"4.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"76ee7a02da4d231650c7cea31349b889be2f45ddb3ef3032d2ec8185f6313fd2\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"fst\"\n+version = \"0.4.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7ab85b9b05e3978cc9a9cf8fea7f01b494e1a09ed3037e16ba39edc7a29eb61a\"\n+\n+[[package]]\n+name = \"gimli\"\n+version = \"0.26.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n+\n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"db0d4cf898abf0081f964436dc980e96670a0f36863e4b83aaacdb65c9d7ccc3\"\n+\n+[[package]]\n+name = \"heck\"\n+version = \"0.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6d621efb26863f0e9924c6ac577e8275e5e6b77455db64ffa6c65c904e9e132c\"\n+dependencies = [\n+ \"unicode-segmentation\",\n+]\n+\n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.1.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"hir\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arrayvec\",\n+ \"base-db\",\n+ \"cfg\",\n+ \"either\",\n+ \"hir-def\",\n+ \"hir-expand\",\n+ \"hir-ty\",\n+ \"itertools\",\n+ \"once_cell\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"smallvec\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"tt\",\n+]\n+\n+[[package]]\n+name = \"hir-def\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"anymap\",\n+ \"arrayvec\",\n+ \"base-db\",\n+ \"bitflags\",\n+ \"cfg\",\n+ \"cov-mark\",\n+ \"dashmap\",\n+ \"drop_bomb\",\n+ \"either\",\n+ \"expect-test\",\n+ \"fst\",\n+ \"hashbrown\",\n+ \"hir-expand\",\n+ \"indexmap\",\n+ \"itertools\",\n+ \"la-arena\",\n+ \"limit\",\n+ \"mbe\",\n+ \"once_cell\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"smallvec\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test-utils\",\n+ \"tracing\",\n+ \"tt\",\n+]\n+\n+[[package]]\n+name = \"hir-expand\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"base-db\",\n+ \"cfg\",\n+ \"cov-mark\",\n+ \"either\",\n+ \"expect-test\",\n+ \"hashbrown\",\n+ \"itertools\",\n+ \"la-arena\",\n+ \"limit\",\n+ \"mbe\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"smallvec\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"tracing\",\n+ \"tt\",\n+]\n+\n+[[package]]\n+name = \"hir-ty\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arrayvec\",\n+ \"base-db\",\n+ \"chalk-ir\",\n+ \"chalk-recursive\",\n+ \"chalk-solve\",\n+ \"cov-mark\",\n+ \"ena\",\n+ \"expect-test\",\n+ \"hir-def\",\n+ \"hir-expand\",\n+ \"itertools\",\n+ \"la-arena\",\n+ \"limit\",\n+ \"once_cell\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"scoped-tls\",\n+ \"smallvec\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test-utils\",\n+ \"tracing\",\n+ \"tracing-subscriber\",\n+ \"tracing-tree\",\n+ \"typed-arena\",\n+]\n+\n+[[package]]\n+name = \"home\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2456aef2e6b6a9784192ae780c0f15bc57df0e918585282325e8c8ac27737654\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"ide\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cfg\",\n+ \"cov-mark\",\n+ \"crossbeam-channel\",\n+ \"dot\",\n+ \"either\",\n+ \"expect-test\",\n+ \"hir\",\n+ \"ide-assists\",\n+ \"ide-completion\",\n+ \"ide-db\",\n+ \"ide-diagnostics\",\n+ \"ide-ssr\",\n+ \"itertools\",\n+ \"oorandom\",\n+ \"profile\",\n+ \"pulldown-cmark\",\n+ \"pulldown-cmark-to-cmark\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test-utils\",\n+ \"text-edit\",\n+ \"toolchain\",\n+ \"tracing\",\n+ \"url\",\n+]\n+\n+[[package]]\n+name = \"ide-assists\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cov-mark\",\n+ \"either\",\n+ \"expect-test\",\n+ \"hir\",\n+ \"ide-db\",\n+ \"itertools\",\n+ \"profile\",\n+ \"sourcegen\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test-utils\",\n+ \"text-edit\",\n+]\n+\n+[[package]]\n+name = \"ide-completion\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"base-db\",\n+ \"cov-mark\",\n+ \"expect-test\",\n+ \"hir\",\n+ \"ide-db\",\n+ \"itertools\",\n+ \"once_cell\",\n+ \"profile\",\n+ \"smallvec\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test-utils\",\n+ \"text-edit\",\n+]\n+\n+[[package]]\n+name = \"ide-db\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arrayvec\",\n+ \"base-db\",\n+ \"cov-mark\",\n+ \"either\",\n+ \"expect-test\",\n+ \"fst\",\n+ \"hir\",\n+ \"indexmap\",\n+ \"itertools\",\n+ \"limit\",\n+ \"once_cell\",\n+ \"parser\",\n+ \"profile\",\n+ \"rayon\",\n+ \"rustc-hash\",\n+ \"sourcegen\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test-utils\",\n+ \"text-edit\",\n+ \"tracing\",\n+ \"xshell\",\n+]\n+\n+[[package]]\n+name = \"ide-diagnostics\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cfg\",\n+ \"cov-mark\",\n+ \"either\",\n+ \"expect-test\",\n+ \"hir\",\n+ \"ide-db\",\n+ \"itertools\",\n+ \"profile\",\n+ \"sourcegen\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test-utils\",\n+ \"text-edit\",\n+]\n+\n+[[package]]\n+name = \"ide-ssr\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cov-mark\",\n+ \"expect-test\",\n+ \"hir\",\n+ \"ide-db\",\n+ \"itertools\",\n+ \"parser\",\n+ \"syntax\",\n+ \"test-utils\",\n+ \"text-edit\",\n+]\n+\n+[[package]]\n+name = \"idna\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"418a0a6fab821475f634efe3ccc45c013f742efe03d853e8d3355d5cb850ecf8\"\n+dependencies = [\n+ \"matches\",\n+ \"unicode-bidi\",\n+ \"unicode-normalization\",\n+]\n+\n+[[package]]\n+name = \"indexmap\"\n+version = \"1.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"10a35a97730320ffe8e2d410b5d3b69279b98d2c14bdb8b70ea89ecf7888d41e\"\n+dependencies = [\n+ \"autocfg\",\n+ \"hashbrown\",\n+]\n+\n+[[package]]\n+name = \"inotify\"\n+version = \"0.9.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f8069d3ec154eb856955c1c0fbffefbf5f3c40a104ec912d4797314c1801abff\"\n+dependencies = [\n+ \"bitflags\",\n+ \"inotify-sys\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"inotify-sys\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e05c02b5e89bff3b946cedeca278abc628fe811e604f027c45a8aa3cf793d0eb\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"instant\"\n+version = \"0.1.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7a5bbe824c507c5da5956355e86a746d82e0e1464f65d862cc5e71da70e94b2c\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"itertools\"\n+version = \"0.10.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a9a9d19fa1e79b6215ff29b9d6880b706147f16e9b1dbb1e4e5947b5b02bc5e3\"\n+dependencies = [\n+ \"either\",\n+]\n+\n+[[package]]\n+name = \"itoa\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"112c678d4050afce233f4f2852bb2eb519230b3cf12f33585275537d7e41578d\"\n+\n+[[package]]\n+name = \"jod-thread\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8b23360e99b8717f20aaa4598f5a6541efbe30630039fbc7706cf954a87947ae\"\n+\n+[[package]]\n+name = \"kqueue\"\n+version = \"1.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4d6112e8f37b59803ac47a42d14f1f3a59bbf72fc6857ffc5be455e28a691f8e\"\n+dependencies = [\n+ \"kqueue-sys\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"kqueue-sys\"\n+version = \"1.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8367585489f01bc55dd27404dcf56b95e6da061a256a666ab23be9ba96a2e587\"\n+dependencies = [\n+ \"bitflags\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"la-arena\"\n+version = \"0.3.0\"\n+\n+[[package]]\n+name = \"lazy_static\"\n+version = \"1.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.126\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"349d5a591cd28b49e1d1037471617a32ddcda5731b99419008085f72d5a53836\"\n+\n+[[package]]\n+name = \"libloading\"\n+version = \"0.7.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"efbc0f03f9a775e9f6aed295c6a1ba2253c5757a9e03d55c6caa46a681abcddd\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"libmimalloc-sys\"\n+version = \"0.1.25\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"11ca136052550448f55df7898c6dbe651c6b574fe38a0d9ea687a9f8088a2e2c\"\n+dependencies = [\n+ \"cc\",\n+]\n+\n+[[package]]\n+name = \"limit\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"lock_api\"\n+version = \"0.4.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"327fa5b6a6940e4699ec49a9beae1ea4845c6bab9314e4f84ac68742139d8c53\"\n+dependencies = [\n+ \"autocfg\",\n+ \"scopeguard\",\n+]\n+\n+[[package]]\n+name = \"log\"\n+version = \"0.4.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"abb12e687cfb44aa40f41fc3978ef76448f9b6038cad6aef4259d3c095a2382e\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"lsp-server\"\n+version = \"0.6.0\"\n+dependencies = [\n+ \"crossbeam-channel\",\n+ \"log\",\n+ \"lsp-types\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n+[[package]]\n+name = \"lsp-types\"\n+version = \"0.93.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"70c74e2173b2b31f8655d33724b4b45ac13f439386f66290f539c22b144c2212\"\n+dependencies = [\n+ \"bitflags\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"serde_repr\",\n+ \"url\",\n+]\n+\n+[[package]]\n+name = \"matchers\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8263075bb86c5a1b1427b5ae862e8889656f126e9f77c484496e8b47cf5c5558\"\n+dependencies = [\n+ \"regex-automata\",\n+]\n+\n+[[package]]\n+name = \"matches\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a3e378b66a060d48947b590737b30a1be76706c8dd7b8ba0f2fe3989c68a853f\"\n+\n+[[package]]\n+name = \"mbe\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cov-mark\",\n+ \"parser\",\n+ \"rustc-hash\",\n+ \"smallvec\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test-utils\",\n+ \"tracing\",\n+ \"tt\",\n+]\n+\n+[[package]]\n+name = \"memchr\"\n+version = \"2.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n+\n+[[package]]\n+name = \"memmap2\"\n+version = \"0.5.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d5172b50c23043ff43dd53e51392f36519d9b35a8f3a410d30ece5d1aedd58ae\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"memoffset\"\n+version = \"0.6.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5aa361d4faea93603064a027415f07bd8e1d5c88c9fbf68bf56a285428fd79ce\"\n+dependencies = [\n+ \"autocfg\",\n+]\n+\n+[[package]]\n+name = \"mimalloc\"\n+version = \"0.1.29\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2f64ad83c969af2e732e907564deb0d0ed393cec4af80776f77dd77a1a427698\"\n+dependencies = [\n+ \"libmimalloc-sys\",\n+]\n+\n+[[package]]\n+name = \"miniz_oxide\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6f5c75688da582b8ffc1f1799e9db273f32133c49e048f614d22ec3256773ccc\"\n+dependencies = [\n+ \"adler\",\n+]\n+\n+[[package]]\n+name = \"mio\"\n+version = \"0.8.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"57ee1c23c7c63b0c9250c339ffdc69255f110b298b901b9f6c82547b7b87caaf\"\n+dependencies = [\n+ \"libc\",\n+ \"log\",\n+ \"wasi\",\n+ \"windows-sys 0.36.1\",\n+]\n+\n+[[package]]\n+name = \"miow\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a7377f7792b3afb6a3cba68daa54ca23c032137010460d667fda53a8d66be00e\"\n+dependencies = [\n+ \"windows-sys 0.28.0\",\n+]\n+\n+[[package]]\n+name = \"notify\"\n+version = \"5.0.0-pre.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"553f9844ad0b0824605c20fb55a661679782680410abfb1a8144c2e7e437e7a7\"\n+dependencies = [\n+ \"bitflags\",\n+ \"crossbeam-channel\",\n+ \"filetime\",\n+ \"fsevent-sys\",\n+ \"inotify\",\n+ \"kqueue\",\n+ \"libc\",\n+ \"mio\",\n+ \"walkdir\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"num_cpus\"\n+version = \"1.13.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"19e64526ebdee182341572e50e9ad03965aa510cd94427a4549448f285e957a1\"\n+dependencies = [\n+ \"hermit-abi\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"object\"\n+version = \"0.28.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e42c982f2d955fac81dd7e1d0e1426a7d702acd9c98d19ab01083a6a0328c424\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n+[[package]]\n+name = \"object\"\n+version = \"0.29.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n+[[package]]\n+name = \"once_cell\"\n+version = \"1.13.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"18a6dbe30758c9f83eb00cbea4ac95966305f5a7772f3f42ebfc7fc7eddbd8e1\"\n+\n+[[package]]\n+name = \"oorandom\"\n+version = \"11.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0ab1bc2a289d34bd04a330323ac98a1b4bc82c9d9fcb1e66b63caa84da26b575\"\n+\n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.11.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99\"\n+dependencies = [\n+ \"instant\",\n+ \"lock_api\",\n+ \"parking_lot_core 0.8.5\",\n+]\n+\n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f\"\n+dependencies = [\n+ \"lock_api\",\n+ \"parking_lot_core 0.9.3\",\n+]\n+\n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.8.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d76e8e1493bcac0d2766c42737f34458f1c8c50c0d23bcb24ea953affb273216\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"instant\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"smallvec\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.9.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"09a279cbf25cb0757810394fbc1e359949b59e348145c643a939a525692e6929\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"smallvec\",\n+ \"windows-sys 0.36.1\",\n+]\n+\n+[[package]]\n+name = \"parser\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"drop_bomb\",\n+ \"expect-test\",\n+ \"limit\",\n+ \"rustc-ap-rustc_lexer\",\n+ \"sourcegen\",\n+]\n+\n+[[package]]\n+name = \"paste\"\n+version = \"1.0.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0c520e05135d6e763148b6426a837e239041653ba7becd2e538c076c738025fc\"\n+\n+[[package]]\n+name = \"paths\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"percent-encoding\"\n+version = \"2.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e\"\n+\n+[[package]]\n+name = \"perf-event\"\n+version = \"0.4.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5396562cd2eaa828445d6d34258ae21ee1eb9d40fe626ca7f51c8dccb4af9d66\"\n+dependencies = [\n+ \"libc\",\n+ \"perf-event-open-sys\",\n+]\n+\n+[[package]]\n+name = \"perf-event-open-sys\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ce9bedf5da2c234fdf2391ede2b90fabf585355f33100689bc364a3ea558561a\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"petgraph\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"467d164a6de56270bd7c4d070df81d07beace25012d5103ced4e9ff08d6afdb7\"\n+dependencies = [\n+ \"fixedbitset\",\n+ \"indexmap\",\n+]\n+\n+[[package]]\n+name = \"pin-project-lite\"\n+version = \"0.2.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e0a7ae3ac2f1173085d398531c705756c94a4c56843785df85a60c1a0afac116\"\n+\n+[[package]]\n+name = \"proc-macro-api\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"memmap2\",\n+ \"object 0.29.0\",\n+ \"paths\",\n+ \"profile\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"snap\",\n+ \"stdx\",\n+ \"tracing\",\n+ \"tt\",\n+]\n+\n+[[package]]\n+name = \"proc-macro-srv\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"crossbeam\",\n+ \"expect-test\",\n+ \"libloading\",\n+ \"mbe\",\n+ \"memmap2\",\n+ \"object 0.29.0\",\n+ \"paths\",\n+ \"proc-macro-api\",\n+ \"proc-macro-test\",\n+ \"tt\",\n+]\n+\n+[[package]]\n+name = \"proc-macro-test\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cargo_metadata\",\n+ \"proc-macro-test-impl\",\n+ \"toolchain\",\n+]\n+\n+[[package]]\n+name = \"proc-macro-test-impl\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"proc-macro2\"\n+version = \"1.0.40\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dd96a1e8ed2596c337f8eae5f24924ec83f5ad5ab21ea8e455d3566c69fbcaf7\"\n+dependencies = [\n+ \"unicode-ident\",\n+]\n+\n+[[package]]\n+name = \"profile\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"countme\",\n+ \"la-arena\",\n+ \"libc\",\n+ \"once_cell\",\n+ \"perf-event\",\n+ \"tikv-jemalloc-ctl\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"project-model\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"base-db\",\n+ \"cargo_metadata\",\n+ \"cfg\",\n+ \"expect-test\",\n+ \"la-arena\",\n+ \"paths\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"semver\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"stdx\",\n+ \"toolchain\",\n+ \"tracing\",\n+]\n+\n+[[package]]\n+name = \"pulldown-cmark\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"34f197a544b0c9ab3ae46c359a7ec9cbbb5c7bf97054266fecb7ead794a181d6\"\n+dependencies = [\n+ \"bitflags\",\n+ \"memchr\",\n+ \"unicase\",\n+]\n+\n+[[package]]\n+name = \"pulldown-cmark-to-cmark\"\n+version = \"10.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c1353ac408192fa925228d3e60ff746167d03f4f7e54835d78ef79e08225d913\"\n+dependencies = [\n+ \"pulldown-cmark\",\n+]\n+\n+[[package]]\n+name = \"quote\"\n+version = \"1.0.20\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3bcdf212e9776fbcb2d23ab029360416bb1706b1aea2d1a5ba002727cbcab804\"\n+dependencies = [\n+ \"proc-macro2\",\n+]\n+\n+[[package]]\n+name = \"rayon\"\n+version = \"1.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bd99e5772ead8baa5215278c9b15bf92087709e9c1b2d1f97cdb5a183c933a7d\"\n+dependencies = [\n+ \"autocfg\",\n+ \"crossbeam-deque\",\n+ \"either\",\n+ \"rayon-core\",\n+]\n+\n+[[package]]\n+name = \"rayon-core\"\n+version = \"1.9.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"258bcdb5ac6dad48491bb2992db6b7cf74878b0384908af124823d118c99683f\"\n+dependencies = [\n+ \"crossbeam-channel\",\n+ \"crossbeam-deque\",\n+ \"crossbeam-utils\",\n+ \"num_cpus\",\n+]\n+\n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.2.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"62f25bc4c7e55e0b0b7a1d43fb893f4fa1361d0abe38b9ce4f323c2adfe6ef42\"\n+dependencies = [\n+ \"bitflags\",\n+]\n+\n+[[package]]\n+name = \"regex\"\n+version = \"1.5.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d83f127d94bdbcda4c8cc2e50f6f84f4b611f69c902699ca385a39c3a75f9ff1\"\n+dependencies = [\n+ \"regex-syntax\",\n+]\n+\n+[[package]]\n+name = \"regex-automata\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6c230d73fb8d8c1b9c0b3135c5142a8acee3a0558fb8db5cf1cb65f8d7862132\"\n+dependencies = [\n+ \"regex-syntax\",\n+]\n+\n+[[package]]\n+name = \"regex-syntax\"\n+version = \"0.6.26\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"49b3de9ec5dc0a3417da371aab17d729997c15010e7fd24ff707773a33bddb64\"\n+\n+[[package]]\n+name = \"rowan\"\n+version = \"0.15.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e88acf7b001007e9e8c989fe7449f6601d909e5dd2c56399fc158977ad6c56e8\"\n+dependencies = [\n+ \"countme\",\n+ \"hashbrown\",\n+ \"memoffset\",\n+ \"rustc-hash\",\n+ \"text-size\",\n+]\n+\n+[[package]]\n+name = \"rust-analyzer\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"always-assert\",\n+ \"anyhow\",\n+ \"cfg\",\n+ \"crossbeam-channel\",\n+ \"dissimilar\",\n+ \"expect-test\",\n+ \"flycheck\",\n+ \"hir\",\n+ \"hir-def\",\n+ \"hir-ty\",\n+ \"ide\",\n+ \"ide-db\",\n+ \"ide-ssr\",\n+ \"itertools\",\n+ \"jod-thread\",\n+ \"lsp-server\",\n+ \"lsp-types\",\n+ \"mbe\",\n+ \"mimalloc\",\n+ \"num_cpus\",\n+ \"oorandom\",\n+ \"parking_lot 0.12.1\",\n+ \"proc-macro-api\",\n+ \"proc-macro-srv\",\n+ \"profile\",\n+ \"project-model\",\n+ \"rayon\",\n+ \"rustc-hash\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"sourcegen\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test-utils\",\n+ \"threadpool\",\n+ \"tikv-jemallocator\",\n+ \"toolchain\",\n+ \"tracing\",\n+ \"tracing-log\",\n+ \"tracing-subscriber\",\n+ \"tracing-tree\",\n+ \"tt\",\n+ \"vfs\",\n+ \"vfs-notify\",\n+ \"winapi\",\n+ \"xflags\",\n+ \"xshell\",\n+]\n+\n+[[package]]\n+name = \"rustc-ap-rustc_lexer\"\n+version = \"725.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f950742ef8a203aa7661aad3ab880438ddeb7f95d4b837c30d65db1a2c5df68e\"\n+dependencies = [\n+ \"unicode-xid\",\n+]\n+\n+[[package]]\n+name = \"rustc-demangle\"\n+version = \"0.1.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7ef03e0a2b150c7a90d01faf6254c9c48a41e95fb2a8c2ac1c6f0d2b9aefc342\"\n+\n+[[package]]\n+name = \"rustc-hash\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"08d43f7aa6b08d49f382cde6a7982047c3426db949b1424bc4b7ec9ae12c6ce2\"\n+\n+[[package]]\n+name = \"ryu\"\n+version = \"1.0.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f3f6f92acf49d1b98f7a81226834412ada05458b7364277387724a237f062695\"\n+\n+[[package]]\n+name = \"salsa\"\n+version = \"0.17.0-pre.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9b223dccb46c32753144d0b51290da7230bb4aedcd8379d6b4c9a474c18bf17a\"\n+dependencies = [\n+ \"crossbeam-utils\",\n+ \"indexmap\",\n+ \"lock_api\",\n+ \"log\",\n+ \"oorandom\",\n+ \"parking_lot 0.11.2\",\n+ \"rustc-hash\",\n+ \"salsa-macros\",\n+ \"smallvec\",\n+]\n+\n+[[package]]\n+name = \"salsa-macros\"\n+version = \"0.17.0-pre.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ac6c2e352df550bf019da7b16164ed2f7fa107c39653d1311d1bba42d1582ff7\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"same-file\"\n+version = \"1.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"93fc1dc3aaa9bfed95e02e6eadabb4baf7e3078b0bd1b4d7b6b0b68378900502\"\n+dependencies = [\n+ \"winapi-util\",\n+]\n+\n+[[package]]\n+name = \"scoped-tls\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ea6a9290e3c9cf0f18145ef7ffa62d68ee0bf5fcd651017e586dc7fd5da448c2\"\n+\n+[[package]]\n+name = \"scopeguard\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n+\n+[[package]]\n+name = \"semver\"\n+version = \"1.0.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a2333e6df6d6598f2b1974829f853c2b4c5f4a6e503c10af918081aa6f8564e1\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"serde\"\n+version = \"1.0.138\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1578c6245786b9d168c5447eeacfb96856573ca56c9d68fdcf394be134882a47\"\n+dependencies = [\n+ \"serde_derive\",\n+]\n+\n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.138\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"023e9b1467aef8a10fb88f25611870ada9800ef7e22afce356bb0d2387b6f27c\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"1.0.82\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"82c2c1fdcd807d1098552c5b9a36e425e42e9fbd7c6a37a8425f390f781f7fa7\"\n+dependencies = [\n+ \"indexmap\",\n+ \"itoa\",\n+ \"ryu\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"serde_repr\"\n+version = \"0.1.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a2ad84e47328a31223de7fed7a4f5087f2d6ddfe586cf3ca25b7a165bc0a5aed\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"sharded-slab\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"900fba806f70c630b0a382d0d825e17a0f19fcd059a2ade1ff237bcddf446b31\"\n+dependencies = [\n+ \"lazy_static\",\n+]\n+\n+[[package]]\n+name = \"smallvec\"\n+version = \"1.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1\"\n+\n+[[package]]\n+name = \"smol_str\"\n+version = \"0.1.23\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7475118a28b7e3a2e157ce0131ba8c5526ea96e90ee601d9f6bb2e286a35ab44\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"snap\"\n+version = \"1.0.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"45456094d1983e2ee2a18fdfebce3189fa451699d0502cb8e3b49dba5ba41451\"\n+\n+[[package]]\n+name = \"sourcegen\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"xshell\",\n+]\n+\n+[[package]]\n+name = \"stdx\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"always-assert\",\n+ \"backtrace\",\n+ \"libc\",\n+ \"miow\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"1.0.98\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c50aef8a904de4c23c788f104b7dddc7d6f79c647c7c8ce4cc8f73eb0ca773dd\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-ident\",\n+]\n+\n+[[package]]\n+name = \"synstructure\"\n+version = \"0.12.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f36bdaa60a83aca3921b5259d5400cbf5e90fc51931376a9bd4a0eb79aa7210f\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"unicode-xid\",\n+]\n+\n+[[package]]\n+name = \"syntax\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cov-mark\",\n+ \"expect-test\",\n+ \"indexmap\",\n+ \"itertools\",\n+ \"once_cell\",\n+ \"parser\",\n+ \"proc-macro2\",\n+ \"profile\",\n+ \"quote\",\n+ \"rayon\",\n+ \"rowan\",\n+ \"rustc-ap-rustc_lexer\",\n+ \"rustc-hash\",\n+ \"smol_str\",\n+ \"sourcegen\",\n+ \"stdx\",\n+ \"test-utils\",\n+ \"text-edit\",\n+ \"ungrammar\",\n+]\n+\n+[[package]]\n+name = \"test-utils\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"dissimilar\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"stdx\",\n+ \"text-size\",\n+]\n+\n+[[package]]\n+name = \"text-edit\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"itertools\",\n+ \"text-size\",\n+]\n+\n+[[package]]\n+name = \"text-size\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"288cb548dbe72b652243ea797201f3d481a0609a967980fcc5b2315ea811560a\"\n+\n+[[package]]\n+name = \"thread_local\"\n+version = \"1.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5516c27b78311c50bf42c071425c560ac799b11c30b31f87e3081965fe5e0180\"\n+dependencies = [\n+ \"once_cell\",\n+]\n+\n+[[package]]\n+name = \"threadpool\"\n+version = \"1.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa\"\n+dependencies = [\n+ \"num_cpus\",\n+]\n+\n+[[package]]\n+name = \"tikv-jemalloc-ctl\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e37706572f4b151dff7a0146e040804e9c26fe3a3118591112f05cf12a4216c1\"\n+dependencies = [\n+ \"libc\",\n+ \"paste\",\n+ \"tikv-jemalloc-sys\",\n+]\n+\n+[[package]]\n+name = \"tikv-jemalloc-sys\"\n+version = \"0.5.1+5.3.0-patched\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"931e876f91fed0827f863a2d153897790da0b24d882c721a79cb3beb0b903261\"\n+dependencies = [\n+ \"cc\",\n+ \"fs_extra\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"tikv-jemallocator\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"20612db8a13a6c06d57ec83953694185a367e16945f66565e8028d2c0bd76979\"\n+dependencies = [\n+ \"libc\",\n+ \"tikv-jemalloc-sys\",\n+]\n+\n+[[package]]\n+name = \"tinyvec\"\n+version = \"1.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"87cc5ceb3875bb20c2890005a4e226a4651264a5c75edb2421b52861a0a0cb50\"\n+dependencies = [\n+ \"tinyvec_macros\",\n+]\n+\n+[[package]]\n+name = \"tinyvec_macros\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cda74da7e1a664f795bb1f8a87ec406fb89a02522cf6e50620d016add6dbbf5c\"\n+\n+[[package]]\n+name = \"toolchain\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"home\",\n+]\n+\n+[[package]]\n+name = \"tracing\"\n+version = \"0.1.35\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a400e31aa60b9d44a52a8ee0343b5b18566b03a8321e0d321f695cf56e940160\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"pin-project-lite\",\n+ \"tracing-attributes\",\n+ \"tracing-core\",\n+]\n+\n+[[package]]\n+name = \"tracing-attributes\"\n+version = \"0.1.22\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"11c75893af559bc8e10716548bdef5cb2b983f8e637db9d0e15126b61b484ee2\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"tracing-core\"\n+version = \"0.1.28\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7b7358be39f2f274f322d2aaed611acc57f382e8eb1e5b48cb9ae30933495ce7\"\n+dependencies = [\n+ \"once_cell\",\n+ \"valuable\",\n+]\n+\n+[[package]]\n+name = \"tracing-log\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"78ddad33d2d10b1ed7eb9d1f518a5674713876e97e5bb9b7345a7984fbb4f922\"\n+dependencies = [\n+ \"lazy_static\",\n+ \"log\",\n+ \"tracing-core\",\n+]\n+\n+[[package]]\n+name = \"tracing-subscriber\"\n+version = \"0.3.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3a713421342a5a666b7577783721d3117f1b69a393df803ee17bb73b1e122a59\"\n+dependencies = [\n+ \"matchers\",\n+ \"once_cell\",\n+ \"regex\",\n+ \"sharded-slab\",\n+ \"thread_local\",\n+ \"tracing\",\n+ \"tracing-core\",\n+ \"tracing-log\",\n+]\n+\n+[[package]]\n+name = \"tracing-tree\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d07e90b329c621ade432823988574e820212648aa40e7a2497777d58de0fb453\"\n+dependencies = [\n+ \"ansi_term\",\n+ \"atty\",\n+ \"tracing-core\",\n+ \"tracing-log\",\n+ \"tracing-subscriber\",\n+]\n+\n+[[package]]\n+name = \"tt\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"smol_str\",\n+ \"stdx\",\n+]\n+\n+[[package]]\n+name = \"typed-arena\"\n+version = \"2.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0685c84d5d54d1c26f7d3eb96cd41550adb97baed141a761cf335d3d33bcd0ae\"\n+\n+[[package]]\n+name = \"ungrammar\"\n+version = \"1.16.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a3e5df347f0bf3ec1d670aad6ca5c6a1859cd9ea61d2113125794654ccced68f\"\n+\n+[[package]]\n+name = \"unicase\"\n+version = \"2.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"50f37be617794602aabbeee0be4f259dc1778fabe05e2d67ee8f79326d5cb4f6\"\n+dependencies = [\n+ \"version_check\",\n+]\n+\n+[[package]]\n+name = \"unicode-bidi\"\n+version = \"0.3.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"099b7128301d285f79ddd55b9a83d5e6b9e97c92e0ea0daebee7263e932de992\"\n+\n+[[package]]\n+name = \"unicode-ident\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5bd2fe26506023ed7b5e1e315add59d6f584c621d037f9368fea9cfb988f368c\"\n+\n+[[package]]\n+name = \"unicode-normalization\"\n+version = \"0.1.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"854cbdc4f7bc6ae19c820d44abdc3277ac3e1b2b93db20a636825d9322fb60e6\"\n+dependencies = [\n+ \"tinyvec\",\n+]\n+\n+[[package]]\n+name = \"unicode-segmentation\"\n+version = \"1.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7e8820f5d777f6224dc4be3632222971ac30164d4a258d595640799554ebfd99\"\n+\n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"957e51f3646910546462e67d5f7599b9e4fb8acdd304b087a6494730f9eebf04\"\n+\n+[[package]]\n+name = \"url\"\n+version = \"2.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a507c383b2d33b5fc35d1861e77e6b383d158b2da5e14fe51b83dfedf6fd578c\"\n+dependencies = [\n+ \"form_urlencoded\",\n+ \"idna\",\n+ \"matches\",\n+ \"percent-encoding\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"valuable\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"830b7e5d4d90034032940e4ace0d9a9a057e7a45cd94e6c007832e39edb82f6d\"\n+\n+[[package]]\n+name = \"version_check\"\n+version = \"0.9.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n+\n+[[package]]\n+name = \"vfs\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"fst\",\n+ \"indexmap\",\n+ \"paths\",\n+ \"rustc-hash\",\n+]\n+\n+[[package]]\n+name = \"vfs-notify\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"crossbeam-channel\",\n+ \"jod-thread\",\n+ \"notify\",\n+ \"paths\",\n+ \"tracing\",\n+ \"vfs\",\n+ \"walkdir\",\n+]\n+\n+[[package]]\n+name = \"walkdir\"\n+version = \"2.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"808cf2735cd4b6866113f648b791c6adc5714537bc222d9347bb203386ffda56\"\n+dependencies = [\n+ \"same-file\",\n+ \"winapi\",\n+ \"winapi-util\",\n+]\n+\n+[[package]]\n+name = \"wasi\"\n+version = \"0.11.0+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.3.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\n+dependencies = [\n+ \"winapi-i686-pc-windows-gnu\",\n+ \"winapi-x86_64-pc-windows-gnu\",\n+]\n+\n+[[package]]\n+name = \"winapi-i686-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n+\n+[[package]]\n+name = \"winapi-util\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"winapi-x86_64-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n+\n+[[package]]\n+name = \"windows-sys\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"82ca39602d5cbfa692c4b67e3bcbb2751477355141c1ed434c94da4186836ff6\"\n+dependencies = [\n+ \"windows_aarch64_msvc 0.28.0\",\n+ \"windows_i686_gnu 0.28.0\",\n+ \"windows_i686_msvc 0.28.0\",\n+ \"windows_x86_64_gnu 0.28.0\",\n+ \"windows_x86_64_msvc 0.28.0\",\n+]\n+\n+[[package]]\n+name = \"windows-sys\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n+dependencies = [\n+ \"windows_aarch64_msvc 0.36.1\",\n+ \"windows_i686_gnu 0.36.1\",\n+ \"windows_i686_msvc 0.36.1\",\n+ \"windows_x86_64_gnu 0.36.1\",\n+ \"windows_x86_64_msvc 0.36.1\",\n+]\n+\n+[[package]]\n+name = \"windows_aarch64_msvc\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"52695a41e536859d5308cc613b4a022261a274390b25bd29dfff4bf08505f3c2\"\n+\n+[[package]]\n+name = \"windows_aarch64_msvc\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n+\n+[[package]]\n+name = \"windows_i686_gnu\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f54725ac23affef038fecb177de6c9bf065787c2f432f79e3c373da92f3e1d8a\"\n+\n+[[package]]\n+name = \"windows_i686_gnu\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n+\n+[[package]]\n+name = \"windows_i686_msvc\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"51d5158a43cc43623c0729d1ad6647e62fa384a3d135fd15108d37c683461f64\"\n+\n+[[package]]\n+name = \"windows_i686_msvc\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnu\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bc31f409f565611535130cfe7ee8e6655d3fa99c1c61013981e491921b5ce954\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnu\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n+\n+[[package]]\n+name = \"windows_x86_64_msvc\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3f2b8c7cbd3bfdddd9ab98769f9746a7fad1bca236554cd032b78d768bc0e89f\"\n+\n+[[package]]\n+name = \"windows_x86_64_msvc\"\n+version = \"0.36.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\"\n+\n+[[package]]\n+name = \"write-json\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"06069a848f95fceae3e5e03c0ddc8cb78452b56654ee0c8e68f938cf790fb9e3\"\n+\n+[[package]]\n+name = \"xflags\"\n+version = \"0.2.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3f14fe1ed41a5a2b5ef3f565586c4a8a559ee55d3953faab360a771135bdee00\"\n+dependencies = [\n+ \"xflags-macros\",\n+]\n+\n+[[package]]\n+name = \"xflags-macros\"\n+version = \"0.2.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"45d11d5fc2a97287eded8b170ca80533b3c42646dd7fa386a5eb045817921022\"\n+\n+[[package]]\n+name = \"xshell\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6d47097dc5c85234b1e41851b3422dd6d19b3befdd35b4ae5ce386724aeca981\"\n+dependencies = [\n+ \"xshell-macros\",\n+]\n+\n+[[package]]\n+name = \"xshell-macros\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"88301b56c26dd9bf5c43d858538f82d6f3f7764767defbc5d34e59459901c41a\"\n+\n+[[package]]\n+name = \"xtask\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"flate2\",\n+ \"write-json\",\n+ \"xflags\",\n+ \"xshell\",\n+]"}, {"sha": "6b68ca823894f90f3769a6c4dc60a6b4e1cb49a5", "filename": "src/tools/rust-analyzer/Cargo.toml", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.toml?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,33 @@\n+[workspace]\n+members = [\"xtask/\", \"lib/*\", \"crates/*\"]\n+exclude = [\"crates/proc-macro-test/imp\"]\n+\n+[profile.dev]\n+# Disabling debug info speeds up builds a bunch,\n+# and we don't rely on it for debugging that much.\n+debug = 0\n+\n+[profile.dev.package]\n+# These speed up local tests.\n+rowan.opt-level = 3\n+rustc-hash.opt-level = 3\n+smol_str.opt-level = 3\n+text-size.opt-level = 3\n+# This speeds up `cargo xtask dist`.\n+miniz_oxide.opt-level = 3\n+\n+[profile.release]\n+incremental = true\n+# Set this to 1 or 2 to get more useful backtraces in debugger.\n+debug = 0\n+\n+[patch.'crates-io']\n+# rowan = { path = \"../rowan\" }\n+\n+# chalk-solve = { path = \"../chalk/chalk-solve\" }\n+# chalk-ir = { path = \"../chalk/chalk-ir\" }\n+# chalk-recursive = { path = \"../chalk/chalk-recursive\" }\n+\n+# ungrammar = { path = \"../ungrammar\" }\n+\n+# salsa = { path = \"../salsa\" }"}, {"sha": "16fe87b06e802f094b3fbb0894b137bca2b16ef1", "filename": "src/tools/rust-analyzer/LICENSE-APACHE", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FLICENSE-APACHE?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,201 @@\n+                              Apache License\n+                        Version 2.0, January 2004\n+                     http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+   \"License\" shall mean the terms and conditions for use, reproduction,\n+   and distribution as defined by Sections 1 through 9 of this document.\n+\n+   \"Licensor\" shall mean the copyright owner or entity authorized by\n+   the copyright owner that is granting the License.\n+\n+   \"Legal Entity\" shall mean the union of the acting entity and all\n+   other entities that control, are controlled by, or are under common\n+   control with that entity. For the purposes of this definition,\n+   \"control\" means (i) the power, direct or indirect, to cause the\n+   direction or management of such entity, whether by contract or\n+   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+   outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+   exercising permissions granted by this License.\n+\n+   \"Source\" form shall mean the preferred form for making modifications,\n+   including but not limited to software source code, documentation\n+   source, and configuration files.\n+\n+   \"Object\" form shall mean any form resulting from mechanical\n+   transformation or translation of a Source form, including but\n+   not limited to compiled object code, generated documentation,\n+   and conversions to other media types.\n+\n+   \"Work\" shall mean the work of authorship, whether in Source or\n+   Object form, made available under the License, as indicated by a\n+   copyright notice that is included in or attached to the work\n+   (an example is provided in the Appendix below).\n+\n+   \"Derivative Works\" shall mean any work, whether in Source or Object\n+   form, that is based on (or derived from) the Work and for which the\n+   editorial revisions, annotations, elaborations, or other modifications\n+   represent, as a whole, an original work of authorship. For the purposes\n+   of this License, Derivative Works shall not include works that remain\n+   separable from, or merely link (or bind by name) to the interfaces of,\n+   the Work and Derivative Works thereof.\n+\n+   \"Contribution\" shall mean any work of authorship, including\n+   the original version of the Work and any modifications or additions\n+   to that Work or Derivative Works thereof, that is intentionally\n+   submitted to Licensor for inclusion in the Work by the copyright owner\n+   or by an individual or Legal Entity authorized to submit on behalf of\n+   the copyright owner. For the purposes of this definition, \"submitted\"\n+   means any form of electronic, verbal, or written communication sent\n+   to the Licensor or its representatives, including but not limited to\n+   communication on electronic mailing lists, source code control systems,\n+   and issue tracking systems that are managed by, or on behalf of, the\n+   Licensor for the purpose of discussing and improving the Work, but\n+   excluding communication that is conspicuously marked or otherwise\n+   designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+   on behalf of whom a Contribution has been received by Licensor and\n+   subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   copyright license to reproduce, prepare Derivative Works of,\n+   publicly display, publicly perform, sublicense, and distribute the\n+   Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   (except as stated in this section) patent license to make, have made,\n+   use, offer to sell, sell, import, and otherwise transfer the Work,\n+   where such license applies only to those patent claims licensable\n+   by such Contributor that are necessarily infringed by their\n+   Contribution(s) alone or by combination of their Contribution(s)\n+   with the Work to which such Contribution(s) was submitted. If You\n+   institute patent litigation against any entity (including a\n+   cross-claim or counterclaim in a lawsuit) alleging that the Work\n+   or a Contribution incorporated within the Work constitutes direct\n+   or contributory patent infringement, then any patent licenses\n+   granted to You under this License for that Work shall terminate\n+   as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the\n+   Work or Derivative Works thereof in any medium, with or without\n+   modifications, and in Source or Object form, provided that You\n+   meet the following conditions:\n+\n+   (a) You must give any other recipients of the Work or\n+       Derivative Works a copy of this License; and\n+\n+   (b) You must cause any modified files to carry prominent notices\n+       stating that You changed the files; and\n+\n+   (c) You must retain, in the Source form of any Derivative Works\n+       that You distribute, all copyright, patent, trademark, and\n+       attribution notices from the Source form of the Work,\n+       excluding those notices that do not pertain to any part of\n+       the Derivative Works; and\n+\n+   (d) If the Work includes a \"NOTICE\" text file as part of its\n+       distribution, then any Derivative Works that You distribute must\n+       include a readable copy of the attribution notices contained\n+       within such NOTICE file, excluding those notices that do not\n+       pertain to any part of the Derivative Works, in at least one\n+       of the following places: within a NOTICE text file distributed\n+       as part of the Derivative Works; within the Source form or\n+       documentation, if provided along with the Derivative Works; or,\n+       within a display generated by the Derivative Works, if and\n+       wherever such third-party notices normally appear. The contents\n+       of the NOTICE file are for informational purposes only and\n+       do not modify the License. You may add Your own attribution\n+       notices within Derivative Works that You distribute, alongside\n+       or as an addendum to the NOTICE text from the Work, provided\n+       that such additional attribution notices cannot be construed\n+       as modifying the License.\n+\n+   You may add Your own copyright statement to Your modifications and\n+   may provide additional or different license terms and conditions\n+   for use, reproduction, or distribution of Your modifications, or\n+   for any such Derivative Works as a whole, provided Your use,\n+   reproduction, and distribution of the Work otherwise complies with\n+   the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise,\n+   any Contribution intentionally submitted for inclusion in the Work\n+   by You to the Licensor shall be under the terms and conditions of\n+   this License, without any additional terms or conditions.\n+   Notwithstanding the above, nothing herein shall supersede or modify\n+   the terms of any separate license agreement you may have executed\n+   with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade\n+   names, trademarks, service marks, or product names of the Licensor,\n+   except as required for reasonable and customary use in describing the\n+   origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or\n+   agreed to in writing, Licensor provides the Work (and each\n+   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+   implied, including, without limitation, any warranties or conditions\n+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+   PARTICULAR PURPOSE. You are solely responsible for determining the\n+   appropriateness of using or redistributing the Work and assume any\n+   risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory,\n+   whether in tort (including negligence), contract, or otherwise,\n+   unless required by applicable law (such as deliberate and grossly\n+   negligent acts) or agreed to in writing, shall any Contributor be\n+   liable to You for damages, including any direct, indirect, special,\n+   incidental, or consequential damages of any character arising as a\n+   result of this License or out of the use or inability to use the\n+   Work (including but not limited to damages for loss of goodwill,\n+   work stoppage, computer failure or malfunction, or any and all\n+   other commercial damages or losses), even if such Contributor\n+   has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing\n+   the Work or Derivative Works thereof, You may choose to offer,\n+   and charge a fee for, acceptance of support, warranty, indemnity,\n+   or other liability obligations and/or rights consistent with this\n+   License. However, in accepting such obligations, You may act only\n+   on Your own behalf and on Your sole responsibility, not on behalf\n+   of any other Contributor, and only if You agree to indemnify,\n+   defend, and hold each Contributor harmless for any liability\n+   incurred by, or claims asserted against, such Contributor by reason\n+   of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS\n+\n+APPENDIX: How to apply the Apache License to your work.\n+\n+   To apply the Apache License to your work, attach the following\n+   boilerplate notice, with the fields enclosed by brackets \"[]\"\n+   replaced with your own identifying information. (Don't include\n+   the brackets!)  The text should be enclosed in the appropriate\n+   comment syntax for the file format. We also recommend that a\n+   file or class name and description of purpose be included on the\n+   same \"printed page\" as the copyright notice for easier\n+   identification within third-party archives.\n+\n+Copyright [yyyy] [name of copyright owner]\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License."}, {"sha": "31aa79387f27e730e33d871925e152e35e428031", "filename": "src/tools/rust-analyzer/LICENSE-MIT", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FLICENSE-MIT?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,23 @@\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE."}, {"sha": "89e252be731d0d190a02e2e33368842e7c823eac", "filename": "src/tools/rust-analyzer/PRIVACY.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2FPRIVACY.md", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2FPRIVACY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FPRIVACY.md?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1 @@\n+See the [Privacy](https://rust-analyzer.github.io/manual.html#privacy) section of the user manual."}, {"sha": "8bb0517ed5abbe1518ea4b510d586da047c07b54", "filename": "src/tools/rust-analyzer/README.md", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FREADME.md?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,49 @@\n+<p align=\"center\">\n+  <img\n+    src=\"https://raw.githubusercontent.com/rust-analyzer/rust-analyzer/master/assets/logo-wide.svg\"\n+    alt=\"rust-analyzer logo\">\n+</p>\n+\n+rust-analyzer is a modular compiler frontend for the Rust language.\n+It is a part of a larger rls-2.0 effort to create excellent IDE support for Rust.\n+\n+## Quick Start\n+\n+https://rust-analyzer.github.io/manual.html#installation\n+\n+## Documentation\n+\n+If you want to **contribute** to rust-analyzer or are just curious about how\n+things work under the hood, check the [./docs/dev](./docs/dev) folder.\n+\n+If you want to **use** rust-analyzer's language server with your editor of\n+choice, check [the manual](https://rust-analyzer.github.io/manual.html) folder.\n+It also contains some tips & tricks to help you be more productive when using rust-analyzer.\n+\n+## Security and Privacy\n+\n+See the corresponding sections of [the manual](https://rust-analyzer.github.io/manual.html#security).\n+\n+## Communication\n+\n+For usage and troubleshooting requests, please use \"IDEs and Editors\" category of the Rust forum:\n+\n+https://users.rust-lang.org/c/ide/14\n+\n+For questions about development and implementation, join rust-analyzer working group on Zulip:\n+\n+https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frust-analyzer\n+\n+## Quick Links\n+\n+* Website: https://rust-analyzer.github.io/\n+* Metrics: https://rust-analyzer.github.io/metrics/\n+* API docs: https://rust-lang.github.io/rust-analyzer/ide/\n+* Changelog: https://rust-analyzer.github.io/thisweek\n+\n+## License\n+\n+Rust analyzer is primarily distributed under the terms of both the MIT\n+license and the Apache License (Version 2.0).\n+\n+See LICENSE-APACHE and LICENSE-MIT for details."}, {"sha": "fe1c1fa02271b1981c1da00664b4b3cf1d5a3234", "filename": "src/tools/rust-analyzer/assets/logo-square.svg", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fassets%2Flogo-square.svg", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fassets%2Flogo-square.svg", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fassets%2Flogo-square.svg?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,88 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<!-- Created with Inkscape (http://www.inkscape.org/) -->\n+\n+<svg\n+   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n+   xmlns:cc=\"http://creativecommons.org/ns#\"\n+   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n+   xmlns:svg=\"http://www.w3.org/2000/svg\"\n+   xmlns=\"http://www.w3.org/2000/svg\"\n+   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"\n+   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"\n+   width=\"24mm\"\n+   height=\"24mm\"\n+   viewBox=\"0 0 23.999999 24.000001\"\n+   version=\"1.1\"\n+   id=\"svg8\"\n+   inkscape:version=\"0.92.4 5da689c313, 2019-01-14\"\n+   sodipodi:docname=\"ra.svg\">\n+  <defs\n+     id=\"defs2\" />\n+  <sodipodi:namedview\n+     id=\"base\"\n+     pagecolor=\"#ffffff\"\n+     bordercolor=\"#666666\"\n+     borderopacity=\"1.0\"\n+     inkscape:pageopacity=\"0.0\"\n+     inkscape:pageshadow=\"2\"\n+     inkscape:zoom=\"3.959798\"\n+     inkscape:cx=\"-31.307418\"\n+     inkscape:cy=\"43.570897\"\n+     inkscape:document-units=\"mm\"\n+     inkscape:current-layer=\"layer1\"\n+     showgrid=\"false\"\n+     inkscape:window-width=\"1920\"\n+     inkscape:window-height=\"1006\"\n+     inkscape:window-x=\"0\"\n+     inkscape:window-y=\"0\"\n+     inkscape:window-maximized=\"1\" />\n+  <metadata\n+     id=\"metadata5\">\n+    <rdf:RDF>\n+      <cc:Work\n+         rdf:about=\"\">\n+        <dc:format>image/svg+xml</dc:format>\n+        <dc:type\n+           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n+        <dc:title />\n+      </cc:Work>\n+    </rdf:RDF>\n+  </metadata>\n+  <g\n+     inkscape:label=\"Ebene 1\"\n+     inkscape:groupmode=\"layer\"\n+     id=\"layer1\"\n+     transform=\"translate(-48.088531,-60.285631)\">\n+    <g\n+       aria-label=\"r.\"\n+       style=\"font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:#ffffff;stroke-width:0.5px;paint-order:stroke\"\n+       id=\"text3715\">\n+      <path\n+         d=\"m 55.00077,63.442544 c -0.588718,-0.01704 -1.180779,0.251078 -1.524352,0.735633 -0.163942,0.198364 -0.296316,0.49938 -0.394953,0.683311 -0.101099,-0.416482 -0.202199,-0.832964 -0.303298,-1.249445 -0.671966,0 -1.343932,0 -2.015897,0 0,0.370348 0,0.740695 0,1.111043 0.246841,0 0.493682,0 0.740523,0 0,1.128958 0,2.257916 0,3.386874 -0.246841,0 -0.493682,0 -0.740523,0 0,0.373792 0,0.747585 0,1.121378 1.174777,0 2.349555,0 3.524332,0 0,-0.373793 0,-0.747586 0,-1.121378 -0.37052,0 -0.74104,0 -1.11156,0 0,-0.53623 0,-1.072458 0,-1.608688 0.190282,-0.586609 0.512347,-1.195617 1.085749,-1.482555 0.177384,-0.100666 0.369603,-0.139942 0.305897,0.108125 0,0.278138 0,0.556274 0,0.834412 0.349333,0 0.698666,0 1.047998,0 0.104042,-0.783071 0.208084,-1.566141 0.312126,-2.349211 -0.293304,-0.117433 -0.610556,-0.17161 -0.926042,-0.169499 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold'\"\n+         id=\"path817\" />\n+      <circle\n+         cx=\"59.49345\"\n+         cy=\"68.231422\"\n+         r=\"1.1800417\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold'\"\n+         id=\"path819\" />\n+    </g>\n+    <rect\n+       style=\"fill:#30363b;fill-opacity:1;stroke:#20262b;stroke-width:0.39559129;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n+       id=\"rect3721\"\n+       width=\"10.604409\"\n+       height=\"12.604408\"\n+       x=\"61.286327\"\n+       y=\"71.483421\" />\n+    <g\n+       aria-label=\"a\"\n+       style=\"font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:0.26458332\"\n+       id=\"text3719\">\n+      <path\n+         d=\"m 69.065615,79.143583 q 0,0.3175 0.08467,0.460375 0.08996,0.142875 0.28575,0.216958 l -0.343958,1.100667 q -0.497417,-0.04762 -0.841375,-0.216959 -0.338667,-0.174625 -0.534459,-0.523875 -0.322791,0.386292 -0.825499,0.576792 -0.502709,0.185208 -1.026584,0.185208 -0.867833,0 -1.386416,-0.492125 -0.513292,-0.497416 -0.513292,-1.275291 0,-0.915459 0.714375,-1.412875 0.719667,-0.497417 2.021417,-0.497417 h 0.756708 v -0.211667 q 0,-0.439208 -0.28575,-0.650875 -0.280458,-0.211666 -0.8255,-0.211666 -0.269875,0 -0.693208,0.07937 -0.423334,0.07408 -0.846667,0.216958 l -0.386292,-1.11125 q 0.545042,-0.206375 1.132417,-0.312208 0.592667,-0.105834 1.058333,-0.105834 1.254125,0 1.852083,0.513292 0.60325,0.508 0.60325,1.471083 z m -2.624666,0.60325 q 0.269875,0 0.566208,-0.15875 0.296334,-0.164042 0.449792,-0.460375 v -0.910167 h -0.41275 q -0.6985,0 -1.026583,0.216958 -0.328084,0.211667 -0.328084,0.624417 0,0.322792 0.195792,0.508 0.201083,0.179917 0.555625,0.179917 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';fill:#ffffff;stroke-width:0.26458332\"\n+         id=\"path822\" />\n+    </g>\n+  </g>\n+</svg>"}, {"sha": "c5fb55b36a899009e32ad31be6344a7bbdad5080", "filename": "src/tools/rust-analyzer/assets/logo-wide.svg", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fassets%2Flogo-wide.svg", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fassets%2Flogo-wide.svg", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fassets%2Flogo-wide.svg?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,142 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<!-- Created with Inkscape (http://www.inkscape.org/) -->\n+\n+<svg\n+   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n+   xmlns:cc=\"http://creativecommons.org/ns#\"\n+   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n+   xmlns:svg=\"http://www.w3.org/2000/svg\"\n+   xmlns=\"http://www.w3.org/2000/svg\"\n+   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"\n+   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"\n+   width=\"85.797134mm\"\n+   height=\"24.747536mm\"\n+   viewBox=\"0 0 85.797134 24.747536\"\n+   version=\"1.1\"\n+   id=\"svg8\"\n+   inkscape:version=\"0.92.4 5da689c313, 2019-01-14\"\n+   sodipodi:docname=\"rust analyzer.svg\">\n+  <defs\n+     id=\"defs2\" />\n+  <style>\n+    #text3715 {\n+      fill: #000000;\n+      stroke: #ffffff;\n+      stroke-width: 0.5;\n+      paint-order: stroke;\n+    }\n+    @media (prefers-color-scheme: dark) {\n+      #text3715 {\n+        fill: #ffffff;\n+        stroke: none;\n+      }\n+    }\n+  </style>\n+  <sodipodi:namedview\n+     id=\"base\"\n+     pagecolor=\"#ffffff\"\n+     bordercolor=\"#666666\"\n+     borderopacity=\"1.0\"\n+     inkscape:pageopacity=\"0.0\"\n+     inkscape:pageshadow=\"2\"\n+     inkscape:zoom=\"1.979899\"\n+     inkscape:cx=\"64.938033\"\n+     inkscape:cy=\"-10.231391\"\n+     inkscape:document-units=\"mm\"\n+     inkscape:current-layer=\"layer1\"\n+     showgrid=\"false\"\n+     inkscape:window-width=\"1920\"\n+     inkscape:window-height=\"1006\"\n+     inkscape:window-x=\"0\"\n+     inkscape:window-y=\"0\"\n+     inkscape:window-maximized=\"1\" />\n+  <metadata\n+     id=\"metadata5\">\n+    <rdf:RDF>\n+      <cc:Work\n+         rdf:about=\"\">\n+        <dc:format>image/svg+xml</dc:format>\n+        <dc:type\n+           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n+        <dc:title />\n+      </cc:Work>\n+    </rdf:RDF>\n+  </metadata>\n+  <g\n+     inkscape:label=\"Ebene 1\"\n+     inkscape:groupmode=\"layer\"\n+     id=\"layer1\"\n+     transform=\"translate(-29.534624,-59.398722)\">\n+    <g\n+       aria-label=\"rust.\"\n+       style=\"font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px\"\n+       id=\"text3715\">\n+      <path\n+         d=\"m 35.95077,62.913236 c -0.588719,-0.01704 -1.180779,0.251078 -1.524352,0.735632 -0.163943,0.198364 -0.296317,0.499384 -0.394954,0.683311 -0.101099,-0.416482 -0.202198,-0.832963 -0.303298,-1.249444 -0.671965,0 -1.343931,0 -2.015897,0 0,0.370348 0,0.740695 0,1.111043 0.246841,0 0.493682,0 0.740523,0 0,1.128958 0,2.257916 0,3.386873 -0.246841,0 -0.493682,0 -0.740523,0 0,0.373965 0,0.747931 0,1.121896 1.174777,0 2.349555,0 3.524332,0 0,-0.373965 0,-0.747931 0,-1.121896 -0.37052,0 -0.74104,0 -1.11156,0 0,-0.536229 0,-1.072458 0,-1.608687 0.190283,-0.586609 0.512347,-1.195617 1.085749,-1.482555 0.177393,-0.100673 0.369604,-0.139934 0.305898,0.108135 0,0.278134 0,0.556268 0,0.834401 0.349332,0 0.698665,0 1.047998,0 0.104041,-0.78307 0.208084,-1.56614 0.312125,-2.34921 -0.293304,-0.117432 -0.610556,-0.17161 -0.926041,-0.169499 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';\"\n+         id=\"path817\" />\n+      <path\n+         d=\"m 39.681433,63.082627 v 3.847042 q 0,0.407458 0.148167,0.560917 0.153458,0.153458 0.423333,0.153458 0.259292,0 0.518583,-0.164042 0.259292,-0.164041 0.433917,-0.4445 V 63.082627 H 42.8776 v 5.61975 h -1.4605 l -0.07408,-0.656166 q -0.28575,0.41275 -0.751416,0.624416 -0.465667,0.211667 -0.973667,0.211667 -0.814917,0 -1.211792,-0.470958 -0.396875,-0.47625 -0.396875,-1.275292 v -4.053417 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';\"\n+         id=\"path819\" />\n+      <path\n+         d=\"m 46.6135,67.686377 q 0.418042,0 0.672042,-0.132291 0.259291,-0.132292 0.259291,-0.396875 0,-0.179917 -0.100541,-0.301625 -0.100542,-0.121709 -0.386292,-0.232834 -0.28575,-0.111125 -0.846667,-0.264583 -0.513291,-0.137583 -0.910166,-0.34925 -0.391584,-0.211667 -0.613834,-0.545042 -0.216958,-0.333375 -0.216958,-0.830791 0,-0.502709 0.280458,-0.894292 0.280459,-0.391583 0.8255,-0.613833 0.545042,-0.227542 1.3335,-0.227542 0.751417,0 1.307042,0.195792 0.560917,0.1905 0.968375,0.486833 l -0.66675,0.98425 q -0.34925,-0.216958 -0.751417,-0.343958 -0.402166,-0.132292 -0.809625,-0.132292 -0.407458,0 -0.608541,0.111125 -0.195792,0.105833 -0.195792,0.322792 0,0.142875 0.100542,0.248708 0.105833,0.100542 0.391583,0.211667 0.28575,0.105833 0.836083,0.264583 0.545042,0.153458 0.947209,0.354542 0.407458,0.201083 0.629708,0.53975 0.22225,0.333375 0.22225,0.883708 0,0.613833 -0.365125,1.031875 -0.365125,0.41275 -0.968375,0.619125 -0.60325,0.206375 -1.322917,0.206375 -0.814916,0 -1.439333,-0.232833 -0.624417,-0.232834 -1.063625,-0.613834 L 44.9625,67.093711 q 0.328083,0.254 0.740833,0.423333 0.418042,0.169333 0.910167,0.169333 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';\"\n+         id=\"path821\" />\n+      <path\n+         d=\"m 55.768067,68.374294 q -0.328083,0.211667 -0.79375,0.359833 -0.465666,0.148167 -1.047749,0.148167 -1.100667,0 -1.635125,-0.560917 -0.534459,-0.566208 -0.534459,-1.534583 v -2.550583 h -1.180041 v -1.153584 h 1.180041 v -1.217083 l 1.672167,-0.201083 v 1.418166 h 1.80975 l -0.164042,1.153584 h -1.645708 v 2.550583 q 0,0.418042 0.1905,0.597958 0.1905,0.179917 0.608541,0.179917 0.296334,0 0.53975,-0.06879 0.248709,-0.07408 0.4445,-0.185208 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';\"\n+         id=\"path823\" />\n+      <circle\n+         cx=\"59.493385\"\n+         cy=\"67.702255\"\n+         r=\"1.1799999\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';\"\n+         id=\"path825\" />\n+    </g>\n+    <rect\n+       style=\"fill:#30363b;fill-opacity:1;stroke:#20262b;stroke-width:0.39205828;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\"\n+       id=\"rect3721\"\n+       width=\"54.407944\"\n+       height=\"12.607942\"\n+       x=\"60.730652\"\n+       y=\"71.342285\" />\n+    <g\n+       aria-label=\"analyzer\"\n+       style=\"font-style:normal;font-weight:normal;font-size:10.58333302px;line-height:1.25;font-family:sans-serif;letter-spacing:0px;word-spacing:0px;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:0.26458332\"\n+       id=\"text3719\">\n+      <path\n+         d=\"m 68.007281,79.143583 q 0,0.3175 0.08467,0.460375 0.08996,0.142875 0.28575,0.216958 l -0.343959,1.100667 q -0.497416,-0.04762 -0.841375,-0.216959 -0.338666,-0.174625 -0.534458,-0.523875 -0.322792,0.386292 -0.8255,0.576792 -0.502708,0.185208 -1.026583,0.185208 -0.867833,0 -1.386417,-0.492125 -0.513291,-0.497416 -0.513291,-1.275291 0,-0.915459 0.714375,-1.412875 0.719666,-0.497417 2.021416,-0.497417 h 0.756708 v -0.211667 q 0,-0.439208 -0.28575,-0.650875 -0.280458,-0.211666 -0.825499,-0.211666 -0.269875,0 -0.693209,0.07937 -0.423333,0.07408 -0.846666,0.216958 l -0.386292,-1.11125 q 0.545042,-0.206375 1.132417,-0.312208 0.592666,-0.105834 1.058333,-0.105834 1.254125,0 1.852083,0.513292 0.60325,0.508 0.60325,1.471083 z m -2.624666,0.60325 q 0.269875,0 0.566208,-0.15875 0.296333,-0.164042 0.449791,-0.460375 v -0.910167 h -0.412749 q -0.6985,0 -1.026584,0.216958 -0.328083,0.211667 -0.328083,0.624417 0,0.322792 0.195792,0.508 0.201083,0.179917 0.555625,0.179917 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';fill:#ffffff;stroke-width:0.26458332\"\n+         id=\"path828\" />\n+      <path\n+         d=\"m 69.626515,80.762833 v -5.61975 h 1.4605 l 0.116417,0.650875 q 0.375708,-0.423334 0.79375,-0.629709 0.418041,-0.206375 0.9525,-0.206375 0.719666,0 1.132416,0.439209 0.41275,0.439208 0.41275,1.23825 v 4.1275 h -1.672166 v -3.645959 q 0,-0.343958 -0.04762,-0.545041 -0.04763,-0.206375 -0.169334,-0.291042 -0.116416,-0.08996 -0.322791,-0.08996 -0.174625,0 -0.343959,0.07937 -0.164041,0.07408 -0.322791,0.216958 -0.15875,0.142875 -0.3175,0.343958 v 3.931709 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';fill:#ffffff;stroke-width:0.26458332\"\n+         id=\"path830\" />\n+      <path\n+         d=\"m 80.707248,79.143583 q 0,0.3175 0.08467,0.460375 0.08996,0.142875 0.28575,0.216958 l -0.343958,1.100667 q -0.497417,-0.04762 -0.841375,-0.216959 -0.338667,-0.174625 -0.534458,-0.523875 -0.322792,0.386292 -0.8255,0.576792 -0.502709,0.185208 -1.026584,0.185208 -0.867833,0 -1.386416,-0.492125 -0.513292,-0.497416 -0.513292,-1.275291 0,-0.915459 0.714375,-1.412875 0.719667,-0.497417 2.021417,-0.497417 h 0.756708 v -0.211667 q 0,-0.439208 -0.28575,-0.650875 -0.280458,-0.211666 -0.8255,-0.211666 -0.269875,0 -0.693208,0.07937 -0.423334,0.07408 -0.846667,0.216958 l -0.386292,-1.11125 q 0.545042,-0.206375 1.132417,-0.312208 0.592667,-0.105834 1.058333,-0.105834 1.254125,0 1.852084,0.513292 0.603249,0.508 0.603249,1.471083 z m -2.624666,0.60325 q 0.269875,0 0.566208,-0.15875 0.296334,-0.164042 0.449792,-0.460375 v -0.910167 h -0.41275 q -0.6985,0 -1.026583,0.216958 -0.328084,0.211667 -0.328084,0.624417 0,0.322792 0.195792,0.508 0.201083,0.179917 0.555625,0.179917 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';fill:#ffffff;stroke-width:0.26458332\"\n+         id=\"path832\" />\n+      <path\n+         d=\"m 85.258066,72.91 v 6.085416 q 0,0.338667 0.1905,0.486833 0.195792,0.142875 0.534458,0.142875 0.216959,0 0.418042,-0.04762 0.201083,-0.05292 0.375708,-0.121708 l 0.402167,1.116542 q -0.28575,0.148166 -0.687917,0.259291 -0.402166,0.111125 -0.936625,0.111125 -1.016,0 -1.49225,-0.582083 -0.47625,-0.587375 -0.47625,-1.571625 V 74.053 H 81.929608 V 72.91 Z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';fill:#ffffff;stroke-width:0.26458332\"\n+         id=\"path834\" />\n+      <path\n+         d=\"m 93.989299,75.143083 -1.87325,5.61975 q -0.248708,0.746125 -0.661458,1.248833 -0.407458,0.508 -1.021292,0.783167 -0.608541,0.275166 -1.465791,0.322791 l -0.1905,-1.180041 q 0.555625,-0.06879 0.894291,-0.206375 0.343959,-0.137584 0.550334,-0.375709 0.211666,-0.232833 0.365125,-0.592666 h -0.5715 l -1.783292,-5.61975 h 1.767417 l 1.090083,4.550833 1.185333,-4.550833 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';fill:#ffffff;stroke-width:0.26458332\"\n+         id=\"path836\" />\n+      <path\n+         d=\"m 97.021408,79.498124 h 2.815166 l -0.15875,1.264709 h -4.630208 v -1.180042 l 2.788708,-3.180292 h -2.555875 v -1.259416 h 4.503208 v 1.17475 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';fill:#ffffff;stroke-width:0.26458332\"\n+         id=\"path838\" />\n+      <path\n+         d=\"m 102.82635,78.439791 q 0.0582,0.460375 0.23813,0.746125 0.1852,0.280458 0.47095,0.41275 0.28575,0.127 0.6403,0.127 0.38629,0 0.74612,-0.127 0.35983,-0.127 0.69321,-0.338667 l 0.67204,0.910167 q -0.39687,0.338667 -0.96308,0.555625 -0.56092,0.216958 -1.28059,0.216958 -0.96308,0 -1.61395,-0.381 -0.65088,-0.386291 -0.97896,-1.058333 -0.32809,-0.672042 -0.32809,-1.545167 0,-0.830791 0.3175,-1.508125 0.3175,-0.682625 0.92605,-1.084791 0.61383,-0.407459 1.49754,-0.407459 0.80433,0 1.39171,0.343959 0.59266,0.343958 0.91545,0.989541 0.32809,0.645584 0.32809,1.550459 0,0.142875 -0.0106,0.306916 -0.005,0.164042 -0.0212,0.291042 z m 1.03717,-2.360083 q -0.44979,0 -0.72496,0.322791 -0.27517,0.322792 -0.33338,1.031875 h 2.06375 q -0.005,-0.613833 -0.23812,-0.98425 -0.23283,-0.370416 -0.76729,-0.370416 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';fill:#ffffff;stroke-width:0.26458332\"\n+         id=\"path840\" />\n+      <path\n+         d=\"m 107.77933,80.762833 v -1.121834 h 0.74084 v -3.386666 h -0.74084 v -1.11125 h 2.01613 l 0.30692,1.264708 q 0.30162,-0.724958 0.76729,-1.0795 0.47096,-0.354542 1.14829,-0.354542 0.28575,0 0.508,0.04762 0.22225,0.04233 0.41804,0.121709 l -0.508,1.381125 q -0.15346,-0.04233 -0.30692,-0.0635 -0.15345,-0.02117 -0.33866,-0.02117 -0.55034,0 -0.96838,0.449792 -0.41275,0.449791 -0.62971,1.143 v 1.608666 h 1.11125 v 1.121834 z m 3.80471,-3.27025 v -1.640417 l 0.24871,-0.709083 h 1.11125 l -0.31221,2.3495 z\"\n+         style=\"font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-family:'Fira Code';-inkscape-font-specification:'Fira Code Bold';fill:#ffffff;stroke-width:0.26458332\"\n+         id=\"path842\" />\n+    </g>\n+  </g>\n+</svg>"}, {"sha": "7e900dfeb1eeb1040eae25390c66c3c4fc3155da", "filename": "src/tools/rust-analyzer/bench_data/glorious_old_parser", "status": "added", "additions": 8562, "deletions": 0, "changes": 8562, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fglorious_old_parser", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fglorious_old_parser", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fglorious_old_parser?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "bf89ed594f7070c5c234dea8d72afa0578d097e6", "filename": "src/tools/rust-analyzer/bench_data/numerous_macro_rules", "status": "added", "additions": 560, "deletions": 0, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fnumerous_macro_rules", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fnumerous_macro_rules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fbench_data%2Fnumerous_macro_rules?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f02a51ab6c47f06a86cf8ec7a43d5d690f6b8479", "filename": "src/tools/rust-analyzer/crates/base-db/Cargo.toml", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2FCargo.toml?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,22 @@\n+[package]\n+name = \"base-db\"\n+version = \"0.0.0\"\n+description = \"TBD\"\n+license = \"MIT OR Apache-2.0\"\n+edition = \"2021\"\n+rust-version = \"1.57\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+salsa = \"0.17.0-pre.2\"\n+rustc-hash = \"1.1.0\"\n+\n+syntax = { path = \"../syntax\", version = \"0.0.0\" }\n+stdx = { path = \"../stdx\", version = \"0.0.0\" }\n+cfg = { path = \"../cfg\", version = \"0.0.0\" }\n+profile = { path = \"../profile\", version = \"0.0.0\" }\n+tt = { path = \"../tt\", version = \"0.0.0\" }\n+test-utils = { path = \"../test-utils\", version = \"0.0.0\" }\n+vfs = { path = \"../vfs\", version = \"0.0.0\" }"}, {"sha": "b57f2345767d0fa45ee6ebde1607d5a8343cbded", "filename": "src/tools/rust-analyzer/crates/base-db/src/change.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Fchange.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,85 @@\n+//! Defines a unit of change that can applied to the database to get the next\n+//! state. Changes are transactional.\n+\n+use std::{fmt, sync::Arc};\n+\n+use salsa::Durability;\n+use vfs::FileId;\n+\n+use crate::{CrateGraph, SourceDatabaseExt, SourceRoot, SourceRootId};\n+\n+/// Encapsulate a bunch of raw `.set` calls on the database.\n+#[derive(Default)]\n+pub struct Change {\n+    pub roots: Option<Vec<SourceRoot>>,\n+    pub files_changed: Vec<(FileId, Option<Arc<String>>)>,\n+    pub crate_graph: Option<CrateGraph>,\n+}\n+\n+impl fmt::Debug for Change {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut d = fmt.debug_struct(\"Change\");\n+        if let Some(roots) = &self.roots {\n+            d.field(\"roots\", roots);\n+        }\n+        if !self.files_changed.is_empty() {\n+            d.field(\"files_changed\", &self.files_changed.len());\n+        }\n+        if self.crate_graph.is_some() {\n+            d.field(\"crate_graph\", &self.crate_graph);\n+        }\n+        d.finish()\n+    }\n+}\n+\n+impl Change {\n+    pub fn new() -> Change {\n+        Change::default()\n+    }\n+\n+    pub fn set_roots(&mut self, roots: Vec<SourceRoot>) {\n+        self.roots = Some(roots);\n+    }\n+\n+    pub fn change_file(&mut self, file_id: FileId, new_text: Option<Arc<String>>) {\n+        self.files_changed.push((file_id, new_text))\n+    }\n+\n+    pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n+        self.crate_graph = Some(graph);\n+    }\n+\n+    pub fn apply(self, db: &mut dyn SourceDatabaseExt) {\n+        let _p = profile::span(\"RootDatabase::apply_change\");\n+        if let Some(roots) = self.roots {\n+            for (idx, root) in roots.into_iter().enumerate() {\n+                let root_id = SourceRootId(idx as u32);\n+                let durability = durability(&root);\n+                for file_id in root.iter() {\n+                    db.set_file_source_root_with_durability(file_id, root_id, durability);\n+                }\n+                db.set_source_root_with_durability(root_id, Arc::new(root), durability);\n+            }\n+        }\n+\n+        for (file_id, text) in self.files_changed {\n+            let source_root_id = db.file_source_root(file_id);\n+            let source_root = db.source_root(source_root_id);\n+            let durability = durability(&source_root);\n+            // XXX: can't actually remove the file, just reset the text\n+            let text = text.unwrap_or_default();\n+            db.set_file_text_with_durability(file_id, text, durability)\n+        }\n+        if let Some(crate_graph) = self.crate_graph {\n+            db.set_crate_graph_with_durability(Arc::new(crate_graph), Durability::HIGH)\n+        }\n+    }\n+}\n+\n+fn durability(source_root: &SourceRoot) -> Durability {\n+    if source_root.is_library {\n+        Durability::HIGH\n+    } else {\n+        Durability::LOW\n+    }\n+}"}, {"sha": "8e6e6a11abda83b0cf2c3a92fc7207ede0704b0c", "filename": "src/tools/rust-analyzer/crates/base-db/src/fixture.rs", "status": "added", "additions": 494, "deletions": 0, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Ffixture.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,494 @@\n+//! A set of high-level utility fixture methods to use in tests.\n+use std::{mem, str::FromStr, sync::Arc};\n+\n+use cfg::CfgOptions;\n+use rustc_hash::FxHashMap;\n+use test_utils::{\n+    extract_range_or_offset, Fixture, RangeOrOffset, CURSOR_MARKER, ESCAPED_CURSOR_MARKER,\n+};\n+use tt::Subtree;\n+use vfs::{file_set::FileSet, VfsPath};\n+\n+use crate::{\n+    input::{CrateName, CrateOrigin, LangCrateOrigin},\n+    Change, CrateDisplayName, CrateGraph, CrateId, Dependency, Edition, Env, FileId, FilePosition,\n+    FileRange, ProcMacro, ProcMacroExpander, ProcMacroExpansionError, SourceDatabaseExt,\n+    SourceRoot, SourceRootId,\n+};\n+\n+pub const WORKSPACE: SourceRootId = SourceRootId(0);\n+\n+pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n+    fn with_single_file(ra_fixture: &str) -> (Self, FileId) {\n+        let fixture = ChangeFixture::parse(ra_fixture);\n+        let mut db = Self::default();\n+        fixture.change.apply(&mut db);\n+        assert_eq!(fixture.files.len(), 1);\n+        (db, fixture.files[0])\n+    }\n+\n+    fn with_many_files(ra_fixture: &str) -> (Self, Vec<FileId>) {\n+        let fixture = ChangeFixture::parse(ra_fixture);\n+        let mut db = Self::default();\n+        fixture.change.apply(&mut db);\n+        assert!(fixture.file_position.is_none());\n+        (db, fixture.files)\n+    }\n+\n+    fn with_files(ra_fixture: &str) -> Self {\n+        let fixture = ChangeFixture::parse(ra_fixture);\n+        let mut db = Self::default();\n+        fixture.change.apply(&mut db);\n+        assert!(fixture.file_position.is_none());\n+        db\n+    }\n+\n+    fn with_files_extra_proc_macros(\n+        ra_fixture: &str,\n+        proc_macros: Vec<(String, ProcMacro)>,\n+    ) -> Self {\n+        let fixture = ChangeFixture::parse_with_proc_macros(ra_fixture, proc_macros);\n+        let mut db = Self::default();\n+        fixture.change.apply(&mut db);\n+        assert!(fixture.file_position.is_none());\n+        db\n+    }\n+\n+    fn with_position(ra_fixture: &str) -> (Self, FilePosition) {\n+        let (db, file_id, range_or_offset) = Self::with_range_or_offset(ra_fixture);\n+        let offset = range_or_offset.expect_offset();\n+        (db, FilePosition { file_id, offset })\n+    }\n+\n+    fn with_range(ra_fixture: &str) -> (Self, FileRange) {\n+        let (db, file_id, range_or_offset) = Self::with_range_or_offset(ra_fixture);\n+        let range = range_or_offset.expect_range();\n+        (db, FileRange { file_id, range })\n+    }\n+\n+    fn with_range_or_offset(ra_fixture: &str) -> (Self, FileId, RangeOrOffset) {\n+        let fixture = ChangeFixture::parse(ra_fixture);\n+        let mut db = Self::default();\n+        fixture.change.apply(&mut db);\n+        let (file_id, range_or_offset) = fixture\n+            .file_position\n+            .expect(\"Could not find file position in fixture. Did you forget to add an `$0`?\");\n+        (db, file_id, range_or_offset)\n+    }\n+\n+    fn test_crate(&self) -> CrateId {\n+        let crate_graph = self.crate_graph();\n+        let mut it = crate_graph.iter();\n+        let res = it.next().unwrap();\n+        assert!(it.next().is_none());\n+        res\n+    }\n+}\n+\n+impl<DB: SourceDatabaseExt + Default + 'static> WithFixture for DB {}\n+\n+pub struct ChangeFixture {\n+    pub file_position: Option<(FileId, RangeOrOffset)>,\n+    pub files: Vec<FileId>,\n+    pub change: Change,\n+}\n+\n+impl ChangeFixture {\n+    pub fn parse(ra_fixture: &str) -> ChangeFixture {\n+        Self::parse_with_proc_macros(ra_fixture, Vec::new())\n+    }\n+\n+    pub fn parse_with_proc_macros(\n+        ra_fixture: &str,\n+        mut proc_macros: Vec<(String, ProcMacro)>,\n+    ) -> ChangeFixture {\n+        let (mini_core, proc_macro_names, fixture) = Fixture::parse(ra_fixture);\n+        let mut change = Change::new();\n+\n+        let mut files = Vec::new();\n+        let mut crate_graph = CrateGraph::default();\n+        let mut crates = FxHashMap::default();\n+        let mut crate_deps = Vec::new();\n+        let mut default_crate_root: Option<FileId> = None;\n+        let mut default_cfg = CfgOptions::default();\n+\n+        let mut file_set = FileSet::default();\n+        let mut current_source_root_kind = SourceRootKind::Local;\n+        let source_root_prefix = \"/\".to_string();\n+        let mut file_id = FileId(0);\n+        let mut roots = Vec::new();\n+\n+        let mut file_position = None;\n+\n+        for entry in fixture {\n+            let text = if entry.text.contains(CURSOR_MARKER) {\n+                if entry.text.contains(ESCAPED_CURSOR_MARKER) {\n+                    entry.text.replace(ESCAPED_CURSOR_MARKER, CURSOR_MARKER)\n+                } else {\n+                    let (range_or_offset, text) = extract_range_or_offset(&entry.text);\n+                    assert!(file_position.is_none());\n+                    file_position = Some((file_id, range_or_offset));\n+                    text\n+                }\n+            } else {\n+                entry.text.clone()\n+            };\n+\n+            let meta = FileMeta::from(entry);\n+            assert!(meta.path.starts_with(&source_root_prefix));\n+            if !meta.deps.is_empty() {\n+                assert!(meta.krate.is_some(), \"can't specify deps without naming the crate\")\n+            }\n+\n+            if let Some(kind) = &meta.introduce_new_source_root {\n+                let root = match current_source_root_kind {\n+                    SourceRootKind::Local => SourceRoot::new_local(mem::take(&mut file_set)),\n+                    SourceRootKind::Library => SourceRoot::new_library(mem::take(&mut file_set)),\n+                };\n+                roots.push(root);\n+                current_source_root_kind = *kind;\n+            }\n+\n+            if let Some((krate, origin, version)) = meta.krate {\n+                let crate_name = CrateName::normalize_dashes(&krate);\n+                let crate_id = crate_graph.add_crate_root(\n+                    file_id,\n+                    meta.edition,\n+                    Some(crate_name.clone().into()),\n+                    version,\n+                    meta.cfg.clone(),\n+                    meta.cfg,\n+                    meta.env,\n+                    Ok(Vec::new()),\n+                    false,\n+                    origin,\n+                );\n+                let prev = crates.insert(crate_name.clone(), crate_id);\n+                assert!(prev.is_none());\n+                for dep in meta.deps {\n+                    let prelude = meta.extern_prelude.contains(&dep);\n+                    let dep = CrateName::normalize_dashes(&dep);\n+                    crate_deps.push((crate_name.clone(), dep, prelude))\n+                }\n+            } else if meta.path == \"/main.rs\" || meta.path == \"/lib.rs\" {\n+                assert!(default_crate_root.is_none());\n+                default_crate_root = Some(file_id);\n+                default_cfg = meta.cfg;\n+            }\n+\n+            change.change_file(file_id, Some(Arc::new(text)));\n+            let path = VfsPath::new_virtual_path(meta.path);\n+            file_set.insert(file_id, path);\n+            files.push(file_id);\n+            file_id.0 += 1;\n+        }\n+\n+        if crates.is_empty() {\n+            let crate_root = default_crate_root\n+                .expect(\"missing default crate root, specify a main.rs or lib.rs\");\n+            crate_graph.add_crate_root(\n+                crate_root,\n+                Edition::CURRENT,\n+                Some(CrateName::new(\"test\").unwrap().into()),\n+                None,\n+                default_cfg.clone(),\n+                default_cfg,\n+                Env::default(),\n+                Ok(Vec::new()),\n+                false,\n+                CrateOrigin::CratesIo { repo: None },\n+            );\n+        } else {\n+            for (from, to, prelude) in crate_deps {\n+                let from_id = crates[&from];\n+                let to_id = crates[&to];\n+                crate_graph\n+                    .add_dep(\n+                        from_id,\n+                        Dependency::with_prelude(CrateName::new(&to).unwrap(), to_id, prelude),\n+                    )\n+                    .unwrap();\n+            }\n+        }\n+\n+        if let Some(mini_core) = mini_core {\n+            let core_file = file_id;\n+            file_id.0 += 1;\n+\n+            let mut fs = FileSet::default();\n+            fs.insert(core_file, VfsPath::new_virtual_path(\"/sysroot/core/lib.rs\".to_string()));\n+            roots.push(SourceRoot::new_library(fs));\n+\n+            change.change_file(core_file, Some(Arc::new(mini_core.source_code())));\n+\n+            let all_crates = crate_graph.crates_in_topological_order();\n+\n+            let core_crate = crate_graph.add_crate_root(\n+                core_file,\n+                Edition::Edition2021,\n+                Some(CrateDisplayName::from_canonical_name(\"core\".to_string())),\n+                None,\n+                CfgOptions::default(),\n+                CfgOptions::default(),\n+                Env::default(),\n+                Ok(Vec::new()),\n+                false,\n+                CrateOrigin::Lang(LangCrateOrigin::Core),\n+            );\n+\n+            for krate in all_crates {\n+                crate_graph\n+                    .add_dep(krate, Dependency::new(CrateName::new(\"core\").unwrap(), core_crate))\n+                    .unwrap();\n+            }\n+        }\n+\n+        if !proc_macro_names.is_empty() {\n+            let proc_lib_file = file_id;\n+            file_id.0 += 1;\n+\n+            proc_macros.extend(default_test_proc_macros());\n+            let (proc_macro, source) = filter_test_proc_macros(&proc_macro_names, proc_macros);\n+            let mut fs = FileSet::default();\n+            fs.insert(\n+                proc_lib_file,\n+                VfsPath::new_virtual_path(\"/sysroot/proc_macros/lib.rs\".to_string()),\n+            );\n+            roots.push(SourceRoot::new_library(fs));\n+\n+            change.change_file(proc_lib_file, Some(Arc::new(source)));\n+\n+            let all_crates = crate_graph.crates_in_topological_order();\n+\n+            let proc_macros_crate = crate_graph.add_crate_root(\n+                proc_lib_file,\n+                Edition::Edition2021,\n+                Some(CrateDisplayName::from_canonical_name(\"proc_macros\".to_string())),\n+                None,\n+                CfgOptions::default(),\n+                CfgOptions::default(),\n+                Env::default(),\n+                Ok(proc_macro),\n+                true,\n+                CrateOrigin::CratesIo { repo: None },\n+            );\n+\n+            for krate in all_crates {\n+                crate_graph\n+                    .add_dep(\n+                        krate,\n+                        Dependency::new(CrateName::new(\"proc_macros\").unwrap(), proc_macros_crate),\n+                    )\n+                    .unwrap();\n+            }\n+        }\n+\n+        let root = match current_source_root_kind {\n+            SourceRootKind::Local => SourceRoot::new_local(mem::take(&mut file_set)),\n+            SourceRootKind::Library => SourceRoot::new_library(mem::take(&mut file_set)),\n+        };\n+        roots.push(root);\n+        change.set_roots(roots);\n+        change.set_crate_graph(crate_graph);\n+\n+        ChangeFixture { file_position, files, change }\n+    }\n+}\n+\n+fn default_test_proc_macros() -> [(String, ProcMacro); 4] {\n+    [\n+        (\n+            r#\"\n+#[proc_macro_attribute]\n+pub fn identity(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    item\n+}\n+\"#\n+            .into(),\n+            ProcMacro {\n+                name: \"identity\".into(),\n+                kind: crate::ProcMacroKind::Attr,\n+                expander: Arc::new(IdentityProcMacroExpander),\n+            },\n+        ),\n+        (\n+            r#\"\n+#[proc_macro_derive(DeriveIdentity)]\n+pub fn derive_identity(item: TokenStream) -> TokenStream {\n+    item\n+}\n+\"#\n+            .into(),\n+            ProcMacro {\n+                name: \"DeriveIdentity\".into(),\n+                kind: crate::ProcMacroKind::CustomDerive,\n+                expander: Arc::new(IdentityProcMacroExpander),\n+            },\n+        ),\n+        (\n+            r#\"\n+#[proc_macro_attribute]\n+pub fn input_replace(attr: TokenStream, _item: TokenStream) -> TokenStream {\n+    attr\n+}\n+\"#\n+            .into(),\n+            ProcMacro {\n+                name: \"input_replace\".into(),\n+                kind: crate::ProcMacroKind::Attr,\n+                expander: Arc::new(AttributeInputReplaceProcMacroExpander),\n+            },\n+        ),\n+        (\n+            r#\"\n+#[proc_macro]\n+pub fn mirror(input: TokenStream) -> TokenStream {\n+    input\n+}\n+\"#\n+            .into(),\n+            ProcMacro {\n+                name: \"mirror\".into(),\n+                kind: crate::ProcMacroKind::FuncLike,\n+                expander: Arc::new(MirrorProcMacroExpander),\n+            },\n+        ),\n+    ]\n+}\n+\n+fn filter_test_proc_macros(\n+    proc_macro_names: &[String],\n+    proc_macro_defs: Vec<(String, ProcMacro)>,\n+) -> (Vec<ProcMacro>, String) {\n+    // The source here is only required so that paths to the macros exist and are resolvable.\n+    let mut source = String::new();\n+    let mut proc_macros = Vec::new();\n+\n+    for (c, p) in proc_macro_defs {\n+        if !proc_macro_names.iter().any(|name| name == &stdx::to_lower_snake_case(&p.name)) {\n+            continue;\n+        }\n+        proc_macros.push(p);\n+        source += &c;\n+    }\n+\n+    (proc_macros, source)\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum SourceRootKind {\n+    Local,\n+    Library,\n+}\n+\n+#[derive(Debug)]\n+struct FileMeta {\n+    path: String,\n+    krate: Option<(String, CrateOrigin, Option<String>)>,\n+    deps: Vec<String>,\n+    extern_prelude: Vec<String>,\n+    cfg: CfgOptions,\n+    edition: Edition,\n+    env: Env,\n+    introduce_new_source_root: Option<SourceRootKind>,\n+}\n+\n+fn parse_crate(crate_str: String) -> (String, CrateOrigin, Option<String>) {\n+    if let Some((a, b)) = crate_str.split_once('@') {\n+        let (version, origin) = match b.split_once(':') {\n+            Some((\"CratesIo\", data)) => match data.split_once(',') {\n+                Some((version, url)) => {\n+                    (version, CrateOrigin::CratesIo { repo: Some(url.to_owned()) })\n+                }\n+                _ => panic!(\"Bad crates.io parameter: {}\", data),\n+            },\n+            _ => panic!(\"Bad string for crate origin: {}\", b),\n+        };\n+        (a.to_owned(), origin, Some(version.to_string()))\n+    } else {\n+        let crate_origin = match &*crate_str {\n+            \"std\" => CrateOrigin::Lang(LangCrateOrigin::Std),\n+            \"core\" => CrateOrigin::Lang(LangCrateOrigin::Core),\n+            _ => CrateOrigin::CratesIo { repo: None },\n+        };\n+        (crate_str, crate_origin, None)\n+    }\n+}\n+\n+impl From<Fixture> for FileMeta {\n+    fn from(f: Fixture) -> FileMeta {\n+        let mut cfg = CfgOptions::default();\n+        f.cfg_atoms.iter().for_each(|it| cfg.insert_atom(it.into()));\n+        f.cfg_key_values.iter().for_each(|(k, v)| cfg.insert_key_value(k.into(), v.into()));\n+        let deps = f.deps;\n+        FileMeta {\n+            path: f.path,\n+            krate: f.krate.map(parse_crate),\n+            extern_prelude: f.extern_prelude.unwrap_or_else(|| deps.clone()),\n+            deps,\n+            cfg,\n+            edition: f.edition.as_ref().map_or(Edition::CURRENT, |v| Edition::from_str(v).unwrap()),\n+            env: f.env.into_iter().collect(),\n+            introduce_new_source_root: f.introduce_new_source_root.map(|kind| match &*kind {\n+                \"local\" => SourceRootKind::Local,\n+                \"library\" => SourceRootKind::Library,\n+                invalid => panic!(\"invalid source root kind '{}'\", invalid),\n+            }),\n+        }\n+    }\n+}\n+\n+// Identity mapping\n+#[derive(Debug)]\n+struct IdentityProcMacroExpander;\n+impl ProcMacroExpander for IdentityProcMacroExpander {\n+    fn expand(\n+        &self,\n+        subtree: &Subtree,\n+        _: Option<&Subtree>,\n+        _: &Env,\n+    ) -> Result<Subtree, ProcMacroExpansionError> {\n+        Ok(subtree.clone())\n+    }\n+}\n+\n+// Pastes the attribute input as its output\n+#[derive(Debug)]\n+struct AttributeInputReplaceProcMacroExpander;\n+impl ProcMacroExpander for AttributeInputReplaceProcMacroExpander {\n+    fn expand(\n+        &self,\n+        _: &Subtree,\n+        attrs: Option<&Subtree>,\n+        _: &Env,\n+    ) -> Result<Subtree, ProcMacroExpansionError> {\n+        attrs\n+            .cloned()\n+            .ok_or_else(|| ProcMacroExpansionError::Panic(\"Expected attribute input\".into()))\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct MirrorProcMacroExpander;\n+impl ProcMacroExpander for MirrorProcMacroExpander {\n+    fn expand(\n+        &self,\n+        input: &Subtree,\n+        _: Option<&Subtree>,\n+        _: &Env,\n+    ) -> Result<Subtree, ProcMacroExpansionError> {\n+        fn traverse(input: &Subtree) -> Subtree {\n+            let mut res = Subtree::default();\n+            res.delimiter = input.delimiter;\n+            for tt in input.token_trees.iter().rev() {\n+                let tt = match tt {\n+                    tt::TokenTree::Leaf(leaf) => tt::TokenTree::Leaf(leaf.clone()),\n+                    tt::TokenTree::Subtree(sub) => tt::TokenTree::Subtree(traverse(sub)),\n+                };\n+                res.token_trees.push(tt);\n+            }\n+            res\n+        }\n+        Ok(traverse(input))\n+    }\n+}"}, {"sha": "9b5a10acfbeaf90711e17c66c21b24105557a665", "filename": "src/tools/rust-analyzer/crates/base-db/src/input.rs", "status": "added", "additions": 792, "deletions": 0, "changes": 792, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Finput.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,792 @@\n+//! This module specifies the input to rust-analyzer. In some sense, this is\n+//! **the** most important module, because all other fancy stuff is strictly\n+//! derived from this input.\n+//!\n+//! Note that neither this module, nor any other part of the analyzer's core do\n+//! actual IO. See `vfs` and `project_model` in the `rust-analyzer` crate for how\n+//! actual IO is done and lowered to input.\n+\n+use std::{fmt, iter::FromIterator, ops, panic::RefUnwindSafe, str::FromStr, sync::Arc};\n+\n+use cfg::CfgOptions;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use syntax::SmolStr;\n+use tt::Subtree;\n+use vfs::{file_set::FileSet, FileId, VfsPath};\n+\n+/// Files are grouped into source roots. A source root is a directory on the\n+/// file systems which is watched for changes. Typically it corresponds to a\n+/// Rust crate. Source roots *might* be nested: in this case, a file belongs to\n+/// the nearest enclosing source root. Paths to files are always relative to a\n+/// source root, and the analyzer does not know the root path of the source root at\n+/// all. So, a file from one source root can't refer to a file in another source\n+/// root by path.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct SourceRootId(pub u32);\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct SourceRoot {\n+    /// Sysroot or crates.io library.\n+    ///\n+    /// Libraries are considered mostly immutable, this assumption is used to\n+    /// optimize salsa's query structure\n+    pub is_library: bool,\n+    pub(crate) file_set: FileSet,\n+}\n+\n+impl SourceRoot {\n+    pub fn new_local(file_set: FileSet) -> SourceRoot {\n+        SourceRoot { is_library: false, file_set }\n+    }\n+    pub fn new_library(file_set: FileSet) -> SourceRoot {\n+        SourceRoot { is_library: true, file_set }\n+    }\n+    pub fn path_for_file(&self, file: &FileId) -> Option<&VfsPath> {\n+        self.file_set.path_for_file(file)\n+    }\n+    pub fn file_for_path(&self, path: &VfsPath) -> Option<&FileId> {\n+        self.file_set.file_for_path(path)\n+    }\n+    pub fn iter(&self) -> impl Iterator<Item = FileId> + '_ {\n+        self.file_set.iter()\n+    }\n+}\n+\n+/// `CrateGraph` is a bit of information which turns a set of text files into a\n+/// number of Rust crates.\n+///\n+/// Each crate is defined by the `FileId` of its root module, the set of enabled\n+/// `cfg` flags and the set of dependencies.\n+///\n+/// Note that, due to cfg's, there might be several crates for a single `FileId`!\n+///\n+/// For the purposes of analysis, a crate does not have a name. Instead, names\n+/// are specified on dependency edges. That is, a crate might be known under\n+/// different names in different dependent crates.\n+///\n+/// Note that `CrateGraph` is build-system agnostic: it's a concept of the Rust\n+/// language proper, not a concept of the build system. In practice, we get\n+/// `CrateGraph` by lowering `cargo metadata` output.\n+///\n+/// `CrateGraph` is `!Serialize` by design, see\n+/// <https://github.com/rust-lang/rust-analyzer/blob/master/docs/dev/architecture.md#serialization>\n+#[derive(Debug, Clone, Default /* Serialize, Deserialize */)]\n+pub struct CrateGraph {\n+    arena: FxHashMap<CrateId, CrateData>,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct CrateId(pub u32);\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateName(SmolStr);\n+\n+impl CrateName {\n+    /// Creates a crate name, checking for dashes in the string provided.\n+    /// Dashes are not allowed in the crate names,\n+    /// hence the input string is returned as `Err` for those cases.\n+    pub fn new(name: &str) -> Result<CrateName, &str> {\n+        if name.contains('-') {\n+            Err(name)\n+        } else {\n+            Ok(Self(SmolStr::new(name)))\n+        }\n+    }\n+\n+    /// Creates a crate name, unconditionally replacing the dashes with underscores.\n+    pub fn normalize_dashes(name: &str) -> CrateName {\n+        Self(SmolStr::new(name.replace('-', \"_\")))\n+    }\n+\n+    pub fn as_smol_str(&self) -> &SmolStr {\n+        &self.0\n+    }\n+}\n+\n+impl fmt::Display for CrateName {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+impl ops::Deref for CrateName {\n+    type Target = str;\n+    fn deref(&self) -> &str {\n+        &*self.0\n+    }\n+}\n+\n+/// Origin of the crates. It is used in emitting monikers.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum CrateOrigin {\n+    /// Crates that are from crates.io official registry,\n+    CratesIo { repo: Option<String> },\n+    /// Crates that are provided by the language, like std, core, proc-macro, ...\n+    Lang(LangCrateOrigin),\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum LangCrateOrigin {\n+    Alloc,\n+    Core,\n+    ProcMacro,\n+    Std,\n+    Test,\n+    Other,\n+}\n+\n+impl From<&str> for LangCrateOrigin {\n+    fn from(s: &str) -> Self {\n+        match s {\n+            \"alloc\" => LangCrateOrigin::Alloc,\n+            \"core\" => LangCrateOrigin::Core,\n+            \"proc-macro\" => LangCrateOrigin::ProcMacro,\n+            \"std\" => LangCrateOrigin::Std,\n+            \"test\" => LangCrateOrigin::Test,\n+            _ => LangCrateOrigin::Other,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for LangCrateOrigin {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let text = match self {\n+            LangCrateOrigin::Alloc => \"alloc\",\n+            LangCrateOrigin::Core => \"core\",\n+            LangCrateOrigin::ProcMacro => \"proc_macro\",\n+            LangCrateOrigin::Std => \"std\",\n+            LangCrateOrigin::Test => \"test\",\n+            LangCrateOrigin::Other => \"other\",\n+        };\n+        f.write_str(text)\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateDisplayName {\n+    // The name we use to display various paths (with `_`).\n+    crate_name: CrateName,\n+    // The name as specified in Cargo.toml (with `-`).\n+    canonical_name: String,\n+}\n+\n+impl CrateDisplayName {\n+    pub fn canonical_name(&self) -> &str {\n+        &self.canonical_name\n+    }\n+    pub fn crate_name(&self) -> &CrateName {\n+        &self.crate_name\n+    }\n+}\n+\n+impl From<CrateName> for CrateDisplayName {\n+    fn from(crate_name: CrateName) -> CrateDisplayName {\n+        let canonical_name = crate_name.to_string();\n+        CrateDisplayName { crate_name, canonical_name }\n+    }\n+}\n+\n+impl fmt::Display for CrateDisplayName {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.crate_name.fmt(f)\n+    }\n+}\n+\n+impl ops::Deref for CrateDisplayName {\n+    type Target = str;\n+    fn deref(&self) -> &str {\n+        &*self.crate_name\n+    }\n+}\n+\n+impl CrateDisplayName {\n+    pub fn from_canonical_name(canonical_name: String) -> CrateDisplayName {\n+        let crate_name = CrateName::normalize_dashes(&canonical_name);\n+        CrateDisplayName { crate_name, canonical_name }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct ProcMacroId(pub u32);\n+\n+#[derive(Copy, Clone, Eq, PartialEq, Debug, Hash)]\n+pub enum ProcMacroKind {\n+    CustomDerive,\n+    FuncLike,\n+    Attr,\n+}\n+\n+pub trait ProcMacroExpander: fmt::Debug + Send + Sync + RefUnwindSafe {\n+    fn expand(\n+        &self,\n+        subtree: &Subtree,\n+        attrs: Option<&Subtree>,\n+        env: &Env,\n+    ) -> Result<Subtree, ProcMacroExpansionError>;\n+}\n+\n+pub enum ProcMacroExpansionError {\n+    Panic(String),\n+    /// Things like \"proc macro server was killed by OOM\".\n+    System(String),\n+}\n+\n+pub type ProcMacroLoadResult = Result<Vec<ProcMacro>, String>;\n+\n+#[derive(Debug, Clone)]\n+pub struct ProcMacro {\n+    pub name: SmolStr,\n+    pub kind: ProcMacroKind,\n+    pub expander: Arc<dyn ProcMacroExpander>,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct CrateData {\n+    pub root_file_id: FileId,\n+    pub edition: Edition,\n+    pub version: Option<String>,\n+    /// A name used in the package's project declaration: for Cargo projects,\n+    /// its `[package].name` can be different for other project types or even\n+    /// absent (a dummy crate for the code snippet, for example).\n+    ///\n+    /// For purposes of analysis, crates are anonymous (only names in\n+    /// `Dependency` matters), this name should only be used for UI.\n+    pub display_name: Option<CrateDisplayName>,\n+    pub cfg_options: CfgOptions,\n+    pub potential_cfg_options: CfgOptions,\n+    pub env: Env,\n+    pub dependencies: Vec<Dependency>,\n+    pub proc_macro: ProcMacroLoadResult,\n+    pub origin: CrateOrigin,\n+    pub is_proc_macro: bool,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum Edition {\n+    Edition2015,\n+    Edition2018,\n+    Edition2021,\n+}\n+\n+impl Edition {\n+    pub const CURRENT: Edition = Edition::Edition2018;\n+}\n+\n+#[derive(Default, Debug, Clone, PartialEq, Eq)]\n+pub struct Env {\n+    entries: FxHashMap<String, String>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Dependency {\n+    pub crate_id: CrateId,\n+    pub name: CrateName,\n+    prelude: bool,\n+}\n+\n+impl Dependency {\n+    pub fn new(name: CrateName, crate_id: CrateId) -> Self {\n+        Self { name, crate_id, prelude: true }\n+    }\n+\n+    pub fn with_prelude(name: CrateName, crate_id: CrateId, prelude: bool) -> Self {\n+        Self { name, crate_id, prelude }\n+    }\n+\n+    /// Whether this dependency is to be added to the depending crate's extern prelude.\n+    pub fn is_prelude(&self) -> bool {\n+        self.prelude\n+    }\n+}\n+\n+impl CrateGraph {\n+    pub fn add_crate_root(\n+        &mut self,\n+        root_file_id: FileId,\n+        edition: Edition,\n+        display_name: Option<CrateDisplayName>,\n+        version: Option<String>,\n+        cfg_options: CfgOptions,\n+        potential_cfg_options: CfgOptions,\n+        env: Env,\n+        proc_macro: ProcMacroLoadResult,\n+        is_proc_macro: bool,\n+        origin: CrateOrigin,\n+    ) -> CrateId {\n+        let data = CrateData {\n+            root_file_id,\n+            edition,\n+            version,\n+            display_name,\n+            cfg_options,\n+            potential_cfg_options,\n+            env,\n+            proc_macro,\n+            dependencies: Vec::new(),\n+            origin,\n+            is_proc_macro,\n+        };\n+        let crate_id = CrateId(self.arena.len() as u32);\n+        let prev = self.arena.insert(crate_id, data);\n+        assert!(prev.is_none());\n+        crate_id\n+    }\n+\n+    pub fn add_dep(\n+        &mut self,\n+        from: CrateId,\n+        dep: Dependency,\n+    ) -> Result<(), CyclicDependenciesError> {\n+        let _p = profile::span(\"add_dep\");\n+\n+        // Check if adding a dep from `from` to `to` creates a cycle. To figure\n+        // that out, look for a  path in the *opposite* direction, from `to` to\n+        // `from`.\n+        if let Some(path) = self.find_path(&mut FxHashSet::default(), dep.crate_id, from) {\n+            let path = path.into_iter().map(|it| (it, self[it].display_name.clone())).collect();\n+            let err = CyclicDependenciesError { path };\n+            assert!(err.from().0 == from && err.to().0 == dep.crate_id);\n+            return Err(err);\n+        }\n+\n+        self.arena.get_mut(&from).unwrap().add_dep(dep);\n+        Ok(())\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.arena.is_empty()\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = CrateId> + '_ {\n+        self.arena.keys().copied()\n+    }\n+\n+    /// Returns an iterator over all transitive dependencies of the given crate,\n+    /// including the crate itself.\n+    pub fn transitive_deps(&self, of: CrateId) -> impl Iterator<Item = CrateId> {\n+        let mut worklist = vec![of];\n+        let mut deps = FxHashSet::default();\n+\n+        while let Some(krate) = worklist.pop() {\n+            if !deps.insert(krate) {\n+                continue;\n+            }\n+\n+            worklist.extend(self[krate].dependencies.iter().map(|dep| dep.crate_id));\n+        }\n+\n+        deps.into_iter()\n+    }\n+\n+    /// Returns all transitive reverse dependencies of the given crate,\n+    /// including the crate itself.\n+    pub fn transitive_rev_deps(&self, of: CrateId) -> impl Iterator<Item = CrateId> {\n+        let mut worklist = vec![of];\n+        let mut rev_deps = FxHashSet::default();\n+        rev_deps.insert(of);\n+\n+        let mut inverted_graph = FxHashMap::<_, Vec<_>>::default();\n+        self.arena.iter().for_each(|(&krate, data)| {\n+            data.dependencies\n+                .iter()\n+                .for_each(|dep| inverted_graph.entry(dep.crate_id).or_default().push(krate))\n+        });\n+\n+        while let Some(krate) = worklist.pop() {\n+            if let Some(krate_rev_deps) = inverted_graph.get(&krate) {\n+                krate_rev_deps\n+                    .iter()\n+                    .copied()\n+                    .filter(|&rev_dep| rev_deps.insert(rev_dep))\n+                    .for_each(|rev_dep| worklist.push(rev_dep));\n+            }\n+        }\n+\n+        rev_deps.into_iter()\n+    }\n+\n+    /// Returns all crates in the graph, sorted in topological order (ie. dependencies of a crate\n+    /// come before the crate itself).\n+    pub fn crates_in_topological_order(&self) -> Vec<CrateId> {\n+        let mut res = Vec::new();\n+        let mut visited = FxHashSet::default();\n+\n+        for krate in self.arena.keys().copied() {\n+            go(self, &mut visited, &mut res, krate);\n+        }\n+\n+        return res;\n+\n+        fn go(\n+            graph: &CrateGraph,\n+            visited: &mut FxHashSet<CrateId>,\n+            res: &mut Vec<CrateId>,\n+            source: CrateId,\n+        ) {\n+            if !visited.insert(source) {\n+                return;\n+            }\n+            for dep in graph[source].dependencies.iter() {\n+                go(graph, visited, res, dep.crate_id)\n+            }\n+            res.push(source)\n+        }\n+    }\n+\n+    // FIXME: this only finds one crate with the given root; we could have multiple\n+    pub fn crate_id_for_crate_root(&self, file_id: FileId) -> Option<CrateId> {\n+        let (&crate_id, _) =\n+            self.arena.iter().find(|(_crate_id, data)| data.root_file_id == file_id)?;\n+        Some(crate_id)\n+    }\n+\n+    /// Extends this crate graph by adding a complete disjoint second crate\n+    /// graph.\n+    ///\n+    /// The ids of the crates in the `other` graph are shifted by the return\n+    /// amount.\n+    pub fn extend(&mut self, other: CrateGraph) -> u32 {\n+        let start = self.arena.len() as u32;\n+        self.arena.extend(other.arena.into_iter().map(|(id, mut data)| {\n+            let new_id = id.shift(start);\n+            for dep in &mut data.dependencies {\n+                dep.crate_id = dep.crate_id.shift(start);\n+            }\n+            (new_id, data)\n+        }));\n+        start\n+    }\n+\n+    fn find_path(\n+        &self,\n+        visited: &mut FxHashSet<CrateId>,\n+        from: CrateId,\n+        to: CrateId,\n+    ) -> Option<Vec<CrateId>> {\n+        if !visited.insert(from) {\n+            return None;\n+        }\n+\n+        if from == to {\n+            return Some(vec![to]);\n+        }\n+\n+        for dep in &self[from].dependencies {\n+            let crate_id = dep.crate_id;\n+            if let Some(mut path) = self.find_path(visited, crate_id, to) {\n+                path.push(from);\n+                return Some(path);\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    // Work around for https://github.com/rust-lang/rust-analyzer/issues/6038.\n+    // As hacky as it gets.\n+    pub fn patch_cfg_if(&mut self) -> bool {\n+        let cfg_if = self.hacky_find_crate(\"cfg_if\");\n+        let std = self.hacky_find_crate(\"std\");\n+        match (cfg_if, std) {\n+            (Some(cfg_if), Some(std)) => {\n+                self.arena.get_mut(&cfg_if).unwrap().dependencies.clear();\n+                self.arena\n+                    .get_mut(&std)\n+                    .unwrap()\n+                    .dependencies\n+                    .push(Dependency::new(CrateName::new(\"cfg_if\").unwrap(), cfg_if));\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn hacky_find_crate(&self, display_name: &str) -> Option<CrateId> {\n+        self.iter().find(|it| self[*it].display_name.as_deref() == Some(display_name))\n+    }\n+}\n+\n+impl ops::Index<CrateId> for CrateGraph {\n+    type Output = CrateData;\n+    fn index(&self, crate_id: CrateId) -> &CrateData {\n+        &self.arena[&crate_id]\n+    }\n+}\n+\n+impl CrateId {\n+    fn shift(self, amount: u32) -> CrateId {\n+        CrateId(self.0 + amount)\n+    }\n+}\n+\n+impl CrateData {\n+    fn add_dep(&mut self, dep: Dependency) {\n+        self.dependencies.push(dep)\n+    }\n+}\n+\n+impl FromStr for Edition {\n+    type Err = ParseEditionError;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        let res = match s {\n+            \"2015\" => Edition::Edition2015,\n+            \"2018\" => Edition::Edition2018,\n+            \"2021\" => Edition::Edition2021,\n+            _ => return Err(ParseEditionError { invalid_input: s.to_string() }),\n+        };\n+        Ok(res)\n+    }\n+}\n+\n+impl fmt::Display for Edition {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            Edition::Edition2015 => \"2015\",\n+            Edition::Edition2018 => \"2018\",\n+            Edition::Edition2021 => \"2021\",\n+        })\n+    }\n+}\n+\n+impl FromIterator<(String, String)> for Env {\n+    fn from_iter<T: IntoIterator<Item = (String, String)>>(iter: T) -> Self {\n+        Env { entries: FromIterator::from_iter(iter) }\n+    }\n+}\n+\n+impl Env {\n+    pub fn set(&mut self, env: &str, value: String) {\n+        self.entries.insert(env.to_owned(), value);\n+    }\n+\n+    pub fn get(&self, env: &str) -> Option<String> {\n+        self.entries.get(env).cloned()\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = (&str, &str)> {\n+        self.entries.iter().map(|(k, v)| (k.as_str(), v.as_str()))\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ParseEditionError {\n+    invalid_input: String,\n+}\n+\n+impl fmt::Display for ParseEditionError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"invalid edition: {:?}\", self.invalid_input)\n+    }\n+}\n+\n+impl std::error::Error for ParseEditionError {}\n+\n+#[derive(Debug)]\n+pub struct CyclicDependenciesError {\n+    path: Vec<(CrateId, Option<CrateDisplayName>)>,\n+}\n+\n+impl CyclicDependenciesError {\n+    fn from(&self) -> &(CrateId, Option<CrateDisplayName>) {\n+        self.path.first().unwrap()\n+    }\n+    fn to(&self) -> &(CrateId, Option<CrateDisplayName>) {\n+        self.path.last().unwrap()\n+    }\n+}\n+\n+impl fmt::Display for CyclicDependenciesError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let render = |(id, name): &(CrateId, Option<CrateDisplayName>)| match name {\n+            Some(it) => format!(\"{}({:?})\", it, id),\n+            None => format!(\"{:?}\", id),\n+        };\n+        let path = self.path.iter().rev().map(render).collect::<Vec<String>>().join(\" -> \");\n+        write!(\n+            f,\n+            \"cyclic deps: {} -> {}, alternative path: {}\",\n+            render(self.from()),\n+            render(self.to()),\n+            path\n+        )\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::CrateOrigin;\n+\n+    use super::{CfgOptions, CrateGraph, CrateName, Dependency, Edition::Edition2018, Env, FileId};\n+\n+    #[test]\n+    fn detect_cyclic_dependency_indirect() {\n+        let mut graph = CrateGraph::default();\n+        let crate1 = graph.add_crate_root(\n+            FileId(1u32),\n+            Edition2018,\n+            None,\n+            None,\n+            CfgOptions::default(),\n+            CfgOptions::default(),\n+            Env::default(),\n+            Ok(Vec::new()),\n+            false,\n+            CrateOrigin::CratesIo { repo: None },\n+        );\n+        let crate2 = graph.add_crate_root(\n+            FileId(2u32),\n+            Edition2018,\n+            None,\n+            None,\n+            CfgOptions::default(),\n+            CfgOptions::default(),\n+            Env::default(),\n+            Ok(Vec::new()),\n+            false,\n+            CrateOrigin::CratesIo { repo: None },\n+        );\n+        let crate3 = graph.add_crate_root(\n+            FileId(3u32),\n+            Edition2018,\n+            None,\n+            None,\n+            CfgOptions::default(),\n+            CfgOptions::default(),\n+            Env::default(),\n+            Ok(Vec::new()),\n+            false,\n+            CrateOrigin::CratesIo { repo: None },\n+        );\n+        assert!(graph\n+            .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n+            .is_ok());\n+        assert!(graph\n+            .add_dep(crate2, Dependency::new(CrateName::new(\"crate3\").unwrap(), crate3))\n+            .is_ok());\n+        assert!(graph\n+            .add_dep(crate3, Dependency::new(CrateName::new(\"crate1\").unwrap(), crate1))\n+            .is_err());\n+    }\n+\n+    #[test]\n+    fn detect_cyclic_dependency_direct() {\n+        let mut graph = CrateGraph::default();\n+        let crate1 = graph.add_crate_root(\n+            FileId(1u32),\n+            Edition2018,\n+            None,\n+            None,\n+            CfgOptions::default(),\n+            CfgOptions::default(),\n+            Env::default(),\n+            Ok(Vec::new()),\n+            false,\n+            CrateOrigin::CratesIo { repo: None },\n+        );\n+        let crate2 = graph.add_crate_root(\n+            FileId(2u32),\n+            Edition2018,\n+            None,\n+            None,\n+            CfgOptions::default(),\n+            CfgOptions::default(),\n+            Env::default(),\n+            Ok(Vec::new()),\n+            false,\n+            CrateOrigin::CratesIo { repo: None },\n+        );\n+        assert!(graph\n+            .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n+            .is_ok());\n+        assert!(graph\n+            .add_dep(crate2, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n+            .is_err());\n+    }\n+\n+    #[test]\n+    fn it_works() {\n+        let mut graph = CrateGraph::default();\n+        let crate1 = graph.add_crate_root(\n+            FileId(1u32),\n+            Edition2018,\n+            None,\n+            None,\n+            CfgOptions::default(),\n+            CfgOptions::default(),\n+            Env::default(),\n+            Ok(Vec::new()),\n+            false,\n+            CrateOrigin::CratesIo { repo: None },\n+        );\n+        let crate2 = graph.add_crate_root(\n+            FileId(2u32),\n+            Edition2018,\n+            None,\n+            None,\n+            CfgOptions::default(),\n+            CfgOptions::default(),\n+            Env::default(),\n+            Ok(Vec::new()),\n+            false,\n+            CrateOrigin::CratesIo { repo: None },\n+        );\n+        let crate3 = graph.add_crate_root(\n+            FileId(3u32),\n+            Edition2018,\n+            None,\n+            None,\n+            CfgOptions::default(),\n+            CfgOptions::default(),\n+            Env::default(),\n+            Ok(Vec::new()),\n+            false,\n+            CrateOrigin::CratesIo { repo: None },\n+        );\n+        assert!(graph\n+            .add_dep(crate1, Dependency::new(CrateName::new(\"crate2\").unwrap(), crate2))\n+            .is_ok());\n+        assert!(graph\n+            .add_dep(crate2, Dependency::new(CrateName::new(\"crate3\").unwrap(), crate3))\n+            .is_ok());\n+    }\n+\n+    #[test]\n+    fn dashes_are_normalized() {\n+        let mut graph = CrateGraph::default();\n+        let crate1 = graph.add_crate_root(\n+            FileId(1u32),\n+            Edition2018,\n+            None,\n+            None,\n+            CfgOptions::default(),\n+            CfgOptions::default(),\n+            Env::default(),\n+            Ok(Vec::new()),\n+            false,\n+            CrateOrigin::CratesIo { repo: None },\n+        );\n+        let crate2 = graph.add_crate_root(\n+            FileId(2u32),\n+            Edition2018,\n+            None,\n+            None,\n+            CfgOptions::default(),\n+            CfgOptions::default(),\n+            Env::default(),\n+            Ok(Vec::new()),\n+            false,\n+            CrateOrigin::CratesIo { repo: None },\n+        );\n+        assert!(graph\n+            .add_dep(\n+                crate1,\n+                Dependency::new(CrateName::normalize_dashes(\"crate-name-with-dashes\"), crate2)\n+            )\n+            .is_ok());\n+        assert_eq!(\n+            graph[crate1].dependencies,\n+            vec![Dependency::new(CrateName::new(\"crate_name_with_dashes\").unwrap(), crate2)]\n+        );\n+    }\n+}"}, {"sha": "2d0a95b09d9a1a5b7d0bcb5116ad0572f4a1930f", "filename": "src/tools/rust-analyzer/crates/base-db/src/lib.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fbase-db%2Fsrc%2Flib.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,131 @@\n+//! base_db defines basic database traits. The concrete DB is defined by ide.\n+\n+#![warn(rust_2018_idioms, unused_lifetimes, semicolon_in_expressions_from_macros)]\n+\n+mod input;\n+mod change;\n+pub mod fixture;\n+\n+use std::{panic, sync::Arc};\n+\n+use rustc_hash::FxHashSet;\n+use syntax::{ast, Parse, SourceFile, TextRange, TextSize};\n+\n+pub use crate::{\n+    change::Change,\n+    input::{\n+        CrateData, CrateDisplayName, CrateGraph, CrateId, CrateName, CrateOrigin, Dependency,\n+        Edition, Env, LangCrateOrigin, ProcMacro, ProcMacroExpander, ProcMacroExpansionError,\n+        ProcMacroId, ProcMacroKind, ProcMacroLoadResult, SourceRoot, SourceRootId,\n+    },\n+};\n+pub use salsa::{self, Cancelled};\n+pub use vfs::{file_set::FileSet, AnchoredPath, AnchoredPathBuf, FileId, VfsPath};\n+\n+#[macro_export]\n+macro_rules! impl_intern_key {\n+    ($name:ident) => {\n+        impl $crate::salsa::InternKey for $name {\n+            fn from_intern_id(v: $crate::salsa::InternId) -> Self {\n+                $name(v)\n+            }\n+            fn as_intern_id(&self) -> $crate::salsa::InternId {\n+                self.0\n+            }\n+        }\n+    };\n+}\n+\n+pub trait Upcast<T: ?Sized> {\n+    fn upcast(&self) -> &T;\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct FilePosition {\n+    pub file_id: FileId,\n+    pub offset: TextSize,\n+}\n+\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]\n+pub struct FileRange {\n+    pub file_id: FileId,\n+    pub range: TextRange,\n+}\n+\n+pub const DEFAULT_LRU_CAP: usize = 128;\n+\n+pub trait FileLoader {\n+    /// Text of the file.\n+    fn file_text(&self, file_id: FileId) -> Arc<String>;\n+    fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId>;\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>>;\n+}\n+\n+/// Database which stores all significant input facts: source code and project\n+/// model. Everything else in rust-analyzer is derived from these queries.\n+#[salsa::query_group(SourceDatabaseStorage)]\n+pub trait SourceDatabase: FileLoader + std::fmt::Debug {\n+    // Parses the file into the syntax tree.\n+    #[salsa::invoke(parse_query)]\n+    fn parse(&self, file_id: FileId) -> Parse<ast::SourceFile>;\n+\n+    /// The crate graph.\n+    #[salsa::input]\n+    fn crate_graph(&self) -> Arc<CrateGraph>;\n+}\n+\n+fn parse_query(db: &dyn SourceDatabase, file_id: FileId) -> Parse<ast::SourceFile> {\n+    let _p = profile::span(\"parse_query\").detail(|| format!(\"{:?}\", file_id));\n+    let text = db.file_text(file_id);\n+    SourceFile::parse(&*text)\n+}\n+\n+/// We don't want to give HIR knowledge of source roots, hence we extract these\n+/// methods into a separate DB.\n+#[salsa::query_group(SourceDatabaseExtStorage)]\n+pub trait SourceDatabaseExt: SourceDatabase {\n+    #[salsa::input]\n+    fn file_text(&self, file_id: FileId) -> Arc<String>;\n+    /// Path to a file, relative to the root of its source root.\n+    /// Source root of the file.\n+    #[salsa::input]\n+    fn file_source_root(&self, file_id: FileId) -> SourceRootId;\n+    /// Contents of the source root.\n+    #[salsa::input]\n+    fn source_root(&self, id: SourceRootId) -> Arc<SourceRoot>;\n+\n+    fn source_root_crates(&self, id: SourceRootId) -> Arc<FxHashSet<CrateId>>;\n+}\n+\n+fn source_root_crates(db: &dyn SourceDatabaseExt, id: SourceRootId) -> Arc<FxHashSet<CrateId>> {\n+    let graph = db.crate_graph();\n+    let res = graph\n+        .iter()\n+        .filter(|&krate| {\n+            let root_file = graph[krate].root_file_id;\n+            db.file_source_root(root_file) == id\n+        })\n+        .collect();\n+    Arc::new(res)\n+}\n+\n+/// Silly workaround for cyclic deps between the traits\n+pub struct FileLoaderDelegate<T>(pub T);\n+\n+impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n+    fn file_text(&self, file_id: FileId) -> Arc<String> {\n+        SourceDatabaseExt::file_text(self.0, file_id)\n+    }\n+    fn resolve_path(&self, path: AnchoredPath<'_>) -> Option<FileId> {\n+        // FIXME: this *somehow* should be platform agnostic...\n+        let source_root = self.0.file_source_root(path.anchor);\n+        let source_root = self.0.source_root(source_root);\n+        source_root.file_set.resolve_path(path)\n+    }\n+\n+    fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n+        let _p = profile::span(\"relevant_crates\");\n+        let source_root = self.0.file_source_root(file_id);\n+        self.0.source_root_crates(source_root)\n+    }\n+}"}, {"sha": "c9664a83ab863094701421f1aef244d5f728d95e", "filename": "src/tools/rust-analyzer/crates/cfg/Cargo.toml", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,26 @@\n+[package]\n+name = \"cfg\"\n+version = \"0.0.0\"\n+description = \"TBD\"\n+license = \"MIT OR Apache-2.0\"\n+edition = \"2021\"\n+rust-version = \"1.57\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+rustc-hash = \"1.1.0\"\n+\n+tt = { path = \"../tt\", version = \"0.0.0\" }\n+\n+[dev-dependencies]\n+mbe = { path = \"../mbe\" }\n+syntax = { path = \"../syntax\" }\n+expect-test = \"1.4.0\"\n+oorandom = \"11.1.3\"\n+# We depend on both individually instead of using `features = [\"derive\"]` to microoptimize the\n+# build graph: if the feature was enabled, syn would be built early on in the graph if `smolstr`\n+# supports `arbitrary`. This way, we avoid feature unification.\n+arbitrary = \"1.1.0\"\n+derive_arbitrary = \"1.1.0\""}, {"sha": "fd9e31ed3b4f52472a47659ca7f159329e87c223", "filename": "src/tools/rust-analyzer/crates/cfg/src/cfg_expr.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Fcfg_expr.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,145 @@\n+//! The condition expression used in `#[cfg(..)]` attributes.\n+//!\n+//! See: <https://doc.rust-lang.org/reference/conditional-compilation.html#conditional-compilation>\n+\n+use std::{fmt, slice::Iter as SliceIter};\n+\n+use tt::SmolStr;\n+\n+/// A simple configuration value passed in from the outside.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub enum CfgAtom {\n+    /// eg. `#[cfg(test)]`\n+    Flag(SmolStr),\n+    /// eg. `#[cfg(target_os = \"linux\")]`\n+    ///\n+    /// Note that a key can have multiple values that are all considered \"active\" at the same time.\n+    /// For example, `#[cfg(target_feature = \"sse\")]` and `#[cfg(target_feature = \"sse2\")]`.\n+    KeyValue { key: SmolStr, value: SmolStr },\n+}\n+\n+impl CfgAtom {\n+    /// Returns `true` when the atom comes from the target specification.\n+    ///\n+    /// If this returns `true`, then changing this atom requires changing the compilation target. If\n+    /// it returns `false`, the atom might come from a build script or the build system.\n+    pub fn is_target_defined(&self) -> bool {\n+        match self {\n+            CfgAtom::Flag(flag) => matches!(&**flag, \"unix\" | \"windows\"),\n+            CfgAtom::KeyValue { key, value: _ } => matches!(\n+                &**key,\n+                \"target_arch\"\n+                    | \"target_os\"\n+                    | \"target_env\"\n+                    | \"target_family\"\n+                    | \"target_endian\"\n+                    | \"target_pointer_width\"\n+                    | \"target_vendor\" // NOTE: `target_feature` is left out since it can be configured via `-Ctarget-feature`\n+            ),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for CfgAtom {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            CfgAtom::Flag(name) => name.fmt(f),\n+            CfgAtom::KeyValue { key, value } => write!(f, \"{} = {:?}\", key, value),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[cfg_attr(test, derive(derive_arbitrary::Arbitrary))]\n+pub enum CfgExpr {\n+    Invalid,\n+    Atom(CfgAtom),\n+    All(Vec<CfgExpr>),\n+    Any(Vec<CfgExpr>),\n+    Not(Box<CfgExpr>),\n+}\n+\n+impl From<CfgAtom> for CfgExpr {\n+    fn from(atom: CfgAtom) -> Self {\n+        CfgExpr::Atom(atom)\n+    }\n+}\n+\n+impl CfgExpr {\n+    pub fn parse(tt: &tt::Subtree) -> CfgExpr {\n+        next_cfg_expr(&mut tt.token_trees.iter()).unwrap_or(CfgExpr::Invalid)\n+    }\n+    /// Fold the cfg by querying all basic `Atom` and `KeyValue` predicates.\n+    pub fn fold(&self, query: &dyn Fn(&CfgAtom) -> bool) -> Option<bool> {\n+        match self {\n+            CfgExpr::Invalid => None,\n+            CfgExpr::Atom(atom) => Some(query(atom)),\n+            CfgExpr::All(preds) => {\n+                preds.iter().try_fold(true, |s, pred| Some(s && pred.fold(query)?))\n+            }\n+            CfgExpr::Any(preds) => {\n+                preds.iter().try_fold(false, |s, pred| Some(s || pred.fold(query)?))\n+            }\n+            CfgExpr::Not(pred) => pred.fold(query).map(|s| !s),\n+        }\n+    }\n+}\n+\n+fn next_cfg_expr(it: &mut SliceIter<'_, tt::TokenTree>) -> Option<CfgExpr> {\n+    let name = match it.next() {\n+        None => return None,\n+        Some(tt::TokenTree::Leaf(tt::Leaf::Ident(ident))) => ident.text.clone(),\n+        Some(_) => return Some(CfgExpr::Invalid),\n+    };\n+\n+    // Peek\n+    let ret = match it.as_slice().first() {\n+        Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) if punct.char == '=' => {\n+            match it.as_slice().get(1) {\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Literal(literal))) => {\n+                    it.next();\n+                    it.next();\n+                    // FIXME: escape? raw string?\n+                    let value =\n+                        SmolStr::new(literal.text.trim_start_matches('\"').trim_end_matches('\"'));\n+                    CfgAtom::KeyValue { key: name, value }.into()\n+                }\n+                _ => return Some(CfgExpr::Invalid),\n+            }\n+        }\n+        Some(tt::TokenTree::Subtree(subtree)) => {\n+            it.next();\n+            let mut sub_it = subtree.token_trees.iter();\n+            let mut subs = std::iter::from_fn(|| next_cfg_expr(&mut sub_it)).collect();\n+            match name.as_str() {\n+                \"all\" => CfgExpr::All(subs),\n+                \"any\" => CfgExpr::Any(subs),\n+                \"not\" => CfgExpr::Not(Box::new(subs.pop().unwrap_or(CfgExpr::Invalid))),\n+                _ => CfgExpr::Invalid,\n+            }\n+        }\n+        _ => CfgAtom::Flag(name).into(),\n+    };\n+\n+    // Eat comma separator\n+    if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) = it.as_slice().first() {\n+        if punct.char == ',' {\n+            it.next();\n+        }\n+    }\n+    Some(ret)\n+}\n+\n+#[cfg(test)]\n+impl arbitrary::Arbitrary<'_> for CfgAtom {\n+    fn arbitrary(u: &mut arbitrary::Unstructured<'_>) -> arbitrary::Result<Self> {\n+        if u.arbitrary()? {\n+            Ok(CfgAtom::Flag(String::arbitrary(u)?.into()))\n+        } else {\n+            Ok(CfgAtom::KeyValue {\n+                key: String::arbitrary(u)?.into(),\n+                value: String::arbitrary(u)?.into(),\n+            })\n+        }\n+    }\n+}"}, {"sha": "fd80e1ebe683b155bca97f98ccab163c5d18a117", "filename": "src/tools/rust-analyzer/crates/cfg/src/dnf.rs", "status": "added", "additions": 345, "deletions": 0, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Fdnf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Fdnf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Fdnf.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,345 @@\n+//! Disjunctive Normal Form construction.\n+//!\n+//! Algorithm from <https://www.cs.drexel.edu/~jjohnson/2015-16/fall/CS270/Lectures/3/dnf.pdf>,\n+//! which would have been much easier to read if it used pattern matching. It's also missing the\n+//! entire \"distribute ANDs over ORs\" part, which is not trivial. Oh well.\n+//!\n+//! This is currently both messy and inefficient. Feel free to improve, there are unit tests.\n+\n+use std::fmt::{self, Write};\n+\n+use rustc_hash::FxHashSet;\n+\n+use crate::{CfgAtom, CfgDiff, CfgExpr, CfgOptions, InactiveReason};\n+\n+/// A `#[cfg]` directive in Disjunctive Normal Form (DNF).\n+pub struct DnfExpr {\n+    conjunctions: Vec<Conjunction>,\n+}\n+\n+struct Conjunction {\n+    literals: Vec<Literal>,\n+}\n+\n+struct Literal {\n+    negate: bool,\n+    var: Option<CfgAtom>, // None = Invalid\n+}\n+\n+impl DnfExpr {\n+    pub fn new(expr: CfgExpr) -> Self {\n+        let builder = Builder { expr: DnfExpr { conjunctions: Vec::new() } };\n+\n+        builder.lower(expr)\n+    }\n+\n+    /// Computes a list of present or absent atoms in `opts` that cause this expression to evaluate\n+    /// to `false`.\n+    ///\n+    /// Note that flipping a subset of these atoms might be sufficient to make the whole expression\n+    /// evaluate to `true`. For that, see `compute_enable_hints`.\n+    ///\n+    /// Returns `None` when `self` is already true, or contains errors.\n+    pub fn why_inactive(&self, opts: &CfgOptions) -> Option<InactiveReason> {\n+        let mut res = InactiveReason { enabled: Vec::new(), disabled: Vec::new() };\n+\n+        for conj in &self.conjunctions {\n+            let mut conj_is_true = true;\n+            for lit in &conj.literals {\n+                let atom = lit.var.as_ref()?;\n+                let enabled = opts.enabled.contains(atom);\n+                if lit.negate == enabled {\n+                    // Literal is false, but needs to be true for this conjunction.\n+                    conj_is_true = false;\n+\n+                    if enabled {\n+                        res.enabled.push(atom.clone());\n+                    } else {\n+                        res.disabled.push(atom.clone());\n+                    }\n+                }\n+            }\n+\n+            if conj_is_true {\n+                // This expression is not actually inactive.\n+                return None;\n+            }\n+        }\n+\n+        res.enabled.sort_unstable();\n+        res.enabled.dedup();\n+        res.disabled.sort_unstable();\n+        res.disabled.dedup();\n+        Some(res)\n+    }\n+\n+    /// Returns `CfgDiff` objects that would enable this directive if applied to `opts`.\n+    pub fn compute_enable_hints<'a>(\n+        &'a self,\n+        opts: &'a CfgOptions,\n+    ) -> impl Iterator<Item = CfgDiff> + 'a {\n+        // A cfg is enabled if any of `self.conjunctions` evaluate to `true`.\n+\n+        self.conjunctions.iter().filter_map(move |conj| {\n+            let mut enable = FxHashSet::default();\n+            let mut disable = FxHashSet::default();\n+            for lit in &conj.literals {\n+                let atom = lit.var.as_ref()?;\n+                let enabled = opts.enabled.contains(atom);\n+                if lit.negate && enabled {\n+                    disable.insert(atom.clone());\n+                }\n+                if !lit.negate && !enabled {\n+                    enable.insert(atom.clone());\n+                }\n+            }\n+\n+            // Check that this actually makes `conj` true.\n+            for lit in &conj.literals {\n+                let atom = lit.var.as_ref()?;\n+                let enabled = enable.contains(atom)\n+                    || (opts.enabled.contains(atom) && !disable.contains(atom));\n+                if enabled == lit.negate {\n+                    return None;\n+                }\n+            }\n+\n+            if enable.is_empty() && disable.is_empty() {\n+                return None;\n+            }\n+\n+            let mut diff = CfgDiff {\n+                enable: enable.into_iter().collect(),\n+                disable: disable.into_iter().collect(),\n+            };\n+\n+            // Undo the FxHashMap randomization for consistent output.\n+            diff.enable.sort_unstable();\n+            diff.disable.sort_unstable();\n+\n+            Some(diff)\n+        })\n+    }\n+}\n+\n+impl fmt::Display for DnfExpr {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.conjunctions.len() != 1 {\n+            f.write_str(\"any(\")?;\n+        }\n+        for (i, conj) in self.conjunctions.iter().enumerate() {\n+            if i != 0 {\n+                f.write_str(\", \")?;\n+            }\n+\n+            conj.fmt(f)?;\n+        }\n+        if self.conjunctions.len() != 1 {\n+            f.write_char(')')?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl Conjunction {\n+    fn new(parts: Vec<CfgExpr>) -> Self {\n+        let mut literals = Vec::new();\n+        for part in parts {\n+            match part {\n+                CfgExpr::Invalid | CfgExpr::Atom(_) | CfgExpr::Not(_) => {\n+                    literals.push(Literal::new(part));\n+                }\n+                CfgExpr::All(conj) => {\n+                    // Flatten.\n+                    literals.extend(Conjunction::new(conj).literals);\n+                }\n+                CfgExpr::Any(_) => unreachable!(\"disjunction in conjunction\"),\n+            }\n+        }\n+\n+        Self { literals }\n+    }\n+}\n+\n+impl fmt::Display for Conjunction {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.literals.len() != 1 {\n+            f.write_str(\"all(\")?;\n+        }\n+        for (i, lit) in self.literals.iter().enumerate() {\n+            if i != 0 {\n+                f.write_str(\", \")?;\n+            }\n+\n+            lit.fmt(f)?;\n+        }\n+        if self.literals.len() != 1 {\n+            f.write_str(\")\")?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl Literal {\n+    fn new(expr: CfgExpr) -> Self {\n+        match expr {\n+            CfgExpr::Invalid => Self { negate: false, var: None },\n+            CfgExpr::Atom(atom) => Self { negate: false, var: Some(atom) },\n+            CfgExpr::Not(expr) => match *expr {\n+                CfgExpr::Invalid => Self { negate: true, var: None },\n+                CfgExpr::Atom(atom) => Self { negate: true, var: Some(atom) },\n+                _ => unreachable!(\"non-atom {:?}\", expr),\n+            },\n+            CfgExpr::Any(_) | CfgExpr::All(_) => unreachable!(\"non-literal {:?}\", expr),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.negate {\n+            write!(f, \"not(\")?;\n+        }\n+\n+        match &self.var {\n+            Some(var) => var.fmt(f)?,\n+            None => f.write_str(\"<invalid>\")?,\n+        }\n+\n+        if self.negate {\n+            f.write_char(')')?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+struct Builder {\n+    expr: DnfExpr,\n+}\n+\n+impl Builder {\n+    fn lower(mut self, expr: CfgExpr) -> DnfExpr {\n+        let expr = make_nnf(expr);\n+        let expr = make_dnf(expr);\n+\n+        match expr {\n+            CfgExpr::Invalid | CfgExpr::Atom(_) | CfgExpr::Not(_) => {\n+                self.expr.conjunctions.push(Conjunction::new(vec![expr]));\n+            }\n+            CfgExpr::All(conj) => {\n+                self.expr.conjunctions.push(Conjunction::new(conj));\n+            }\n+            CfgExpr::Any(mut disj) => {\n+                disj.reverse();\n+                while let Some(conj) = disj.pop() {\n+                    match conj {\n+                        CfgExpr::Invalid | CfgExpr::Atom(_) | CfgExpr::All(_) | CfgExpr::Not(_) => {\n+                            self.expr.conjunctions.push(Conjunction::new(vec![conj]));\n+                        }\n+                        CfgExpr::Any(inner_disj) => {\n+                            // Flatten.\n+                            disj.extend(inner_disj.into_iter().rev());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.expr\n+    }\n+}\n+\n+fn make_dnf(expr: CfgExpr) -> CfgExpr {\n+    match expr {\n+        CfgExpr::Invalid | CfgExpr::Atom(_) | CfgExpr::Not(_) => expr,\n+        CfgExpr::Any(e) => flatten(CfgExpr::Any(e.into_iter().map(make_dnf).collect())),\n+        CfgExpr::All(e) => {\n+            let e = e.into_iter().map(make_dnf).collect::<Vec<_>>();\n+\n+            flatten(CfgExpr::Any(distribute_conj(&e)))\n+        }\n+    }\n+}\n+\n+/// Turns a conjunction of expressions into a disjunction of expressions.\n+fn distribute_conj(conj: &[CfgExpr]) -> Vec<CfgExpr> {\n+    fn go(out: &mut Vec<CfgExpr>, with: &mut Vec<CfgExpr>, rest: &[CfgExpr]) {\n+        match rest {\n+            [head, tail @ ..] => match head {\n+                CfgExpr::Any(disj) => {\n+                    for part in disj {\n+                        with.push(part.clone());\n+                        go(out, with, tail);\n+                        with.pop();\n+                    }\n+                }\n+                _ => {\n+                    with.push(head.clone());\n+                    go(out, with, tail);\n+                    with.pop();\n+                }\n+            },\n+            _ => {\n+                // Turn accumulated parts into a new conjunction.\n+                out.push(CfgExpr::All(with.clone()));\n+            }\n+        }\n+    }\n+\n+    let mut out = Vec::new(); // contains only `all()`\n+    let mut with = Vec::new();\n+\n+    go(&mut out, &mut with, conj);\n+\n+    out\n+}\n+\n+fn make_nnf(expr: CfgExpr) -> CfgExpr {\n+    match expr {\n+        CfgExpr::Invalid | CfgExpr::Atom(_) => expr,\n+        CfgExpr::Any(expr) => CfgExpr::Any(expr.into_iter().map(make_nnf).collect()),\n+        CfgExpr::All(expr) => CfgExpr::All(expr.into_iter().map(make_nnf).collect()),\n+        CfgExpr::Not(operand) => match *operand {\n+            CfgExpr::Invalid | CfgExpr::Atom(_) => CfgExpr::Not(operand.clone()), // Original negated expr\n+            CfgExpr::Not(expr) => {\n+                // Remove double negation.\n+                make_nnf(*expr)\n+            }\n+            // Convert negated conjunction/disjunction using DeMorgan's Law.\n+            CfgExpr::Any(inner) => CfgExpr::All(\n+                inner.into_iter().map(|expr| make_nnf(CfgExpr::Not(Box::new(expr)))).collect(),\n+            ),\n+            CfgExpr::All(inner) => CfgExpr::Any(\n+                inner.into_iter().map(|expr| make_nnf(CfgExpr::Not(Box::new(expr)))).collect(),\n+            ),\n+        },\n+    }\n+}\n+\n+/// Collapses nested `any()` and `all()` predicates.\n+fn flatten(expr: CfgExpr) -> CfgExpr {\n+    match expr {\n+        CfgExpr::All(inner) => CfgExpr::All(\n+            inner\n+                .into_iter()\n+                .flat_map(|e| match e {\n+                    CfgExpr::All(inner) => inner,\n+                    _ => vec![e],\n+                })\n+                .collect(),\n+        ),\n+        CfgExpr::Any(inner) => CfgExpr::Any(\n+            inner\n+                .into_iter()\n+                .flat_map(|e| match e {\n+                    CfgExpr::Any(inner) => inner,\n+                    _ => vec![e],\n+                })\n+                .collect(),\n+        ),\n+        _ => expr,\n+    }\n+}"}, {"sha": "d78ef4fb11e7ff2b3f18931032fcc19984dba7ba", "filename": "src/tools/rust-analyzer/crates/cfg/src/lib.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Flib.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,202 @@\n+//! cfg defines conditional compiling options, `cfg` attribute parser and evaluator\n+\n+#![warn(rust_2018_idioms, unused_lifetimes, semicolon_in_expressions_from_macros)]\n+\n+mod cfg_expr;\n+mod dnf;\n+#[cfg(test)]\n+mod tests;\n+\n+use std::fmt;\n+\n+use rustc_hash::FxHashSet;\n+use tt::SmolStr;\n+\n+pub use cfg_expr::{CfgAtom, CfgExpr};\n+pub use dnf::DnfExpr;\n+\n+/// Configuration options used for conditional compilation on items with `cfg` attributes.\n+/// We have two kind of options in different namespaces: atomic options like `unix`, and\n+/// key-value options like `target_arch=\"x86\"`.\n+///\n+/// Note that for key-value options, one key can have multiple values (but not none).\n+/// `feature` is an example. We have both `feature=\"foo\"` and `feature=\"bar\"` if features\n+/// `foo` and `bar` are both enabled. And here, we store key-value options as a set of tuple\n+/// of key and value in `key_values`.\n+///\n+/// See: <https://doc.rust-lang.org/reference/conditional-compilation.html#set-configuration-options>\n+#[derive(Clone, PartialEq, Eq, Default)]\n+pub struct CfgOptions {\n+    enabled: FxHashSet<CfgAtom>,\n+}\n+\n+impl fmt::Debug for CfgOptions {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut items = self\n+            .enabled\n+            .iter()\n+            .map(|atom| match atom {\n+                CfgAtom::Flag(it) => it.to_string(),\n+                CfgAtom::KeyValue { key, value } => format!(\"{}={}\", key, value),\n+            })\n+            .collect::<Vec<_>>();\n+        items.sort();\n+        f.debug_tuple(\"CfgOptions\").field(&items).finish()\n+    }\n+}\n+\n+impl CfgOptions {\n+    pub fn check(&self, cfg: &CfgExpr) -> Option<bool> {\n+        cfg.fold(&|atom| self.enabled.contains(atom))\n+    }\n+\n+    pub fn insert_atom(&mut self, key: SmolStr) {\n+        self.enabled.insert(CfgAtom::Flag(key));\n+    }\n+\n+    pub fn insert_key_value(&mut self, key: SmolStr, value: SmolStr) {\n+        self.enabled.insert(CfgAtom::KeyValue { key, value });\n+    }\n+\n+    pub fn apply_diff(&mut self, diff: CfgDiff) {\n+        for atom in diff.enable {\n+            self.enabled.insert(atom);\n+        }\n+\n+        for atom in diff.disable {\n+            self.enabled.remove(&atom);\n+        }\n+    }\n+\n+    pub fn get_cfg_keys(&self) -> impl Iterator<Item = &SmolStr> {\n+        self.enabled.iter().map(|x| match x {\n+            CfgAtom::Flag(key) => key,\n+            CfgAtom::KeyValue { key, .. } => key,\n+        })\n+    }\n+\n+    pub fn get_cfg_values<'a>(\n+        &'a self,\n+        cfg_key: &'a str,\n+    ) -> impl Iterator<Item = &'a SmolStr> + 'a {\n+        self.enabled.iter().filter_map(move |x| match x {\n+            CfgAtom::KeyValue { key, value } if cfg_key == key => Some(value),\n+            _ => None,\n+        })\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct CfgDiff {\n+    // Invariants: No duplicates, no atom that's both in `enable` and `disable`.\n+    enable: Vec<CfgAtom>,\n+    disable: Vec<CfgAtom>,\n+}\n+\n+impl CfgDiff {\n+    /// Create a new CfgDiff. Will return None if the same item appears more than once in the set\n+    /// of both.\n+    pub fn new(enable: Vec<CfgAtom>, disable: Vec<CfgAtom>) -> Option<CfgDiff> {\n+        let mut occupied = FxHashSet::default();\n+        for item in enable.iter().chain(disable.iter()) {\n+            if !occupied.insert(item) {\n+                // was present\n+                return None;\n+            }\n+        }\n+\n+        Some(CfgDiff { enable, disable })\n+    }\n+\n+    /// Returns the total number of atoms changed by this diff.\n+    pub fn len(&self) -> usize {\n+        self.enable.len() + self.disable.len()\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+}\n+\n+impl fmt::Display for CfgDiff {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if !self.enable.is_empty() {\n+            f.write_str(\"enable \")?;\n+            for (i, atom) in self.enable.iter().enumerate() {\n+                let sep = match i {\n+                    0 => \"\",\n+                    _ if i == self.enable.len() - 1 => \" and \",\n+                    _ => \", \",\n+                };\n+                f.write_str(sep)?;\n+\n+                atom.fmt(f)?;\n+            }\n+\n+            if !self.disable.is_empty() {\n+                f.write_str(\"; \")?;\n+            }\n+        }\n+\n+        if !self.disable.is_empty() {\n+            f.write_str(\"disable \")?;\n+            for (i, atom) in self.disable.iter().enumerate() {\n+                let sep = match i {\n+                    0 => \"\",\n+                    _ if i == self.enable.len() - 1 => \" and \",\n+                    _ => \", \",\n+                };\n+                f.write_str(sep)?;\n+\n+                atom.fmt(f)?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+pub struct InactiveReason {\n+    enabled: Vec<CfgAtom>,\n+    disabled: Vec<CfgAtom>,\n+}\n+\n+impl fmt::Display for InactiveReason {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if !self.enabled.is_empty() {\n+            for (i, atom) in self.enabled.iter().enumerate() {\n+                let sep = match i {\n+                    0 => \"\",\n+                    _ if i == self.enabled.len() - 1 => \" and \",\n+                    _ => \", \",\n+                };\n+                f.write_str(sep)?;\n+\n+                atom.fmt(f)?;\n+            }\n+            let is_are = if self.enabled.len() == 1 { \"is\" } else { \"are\" };\n+            write!(f, \" {} enabled\", is_are)?;\n+\n+            if !self.disabled.is_empty() {\n+                f.write_str(\" and \")?;\n+            }\n+        }\n+\n+        if !self.disabled.is_empty() {\n+            for (i, atom) in self.disabled.iter().enumerate() {\n+                let sep = match i {\n+                    0 => \"\",\n+                    _ if i == self.disabled.len() - 1 => \" and \",\n+                    _ => \", \",\n+                };\n+                f.write_str(sep)?;\n+\n+                atom.fmt(f)?;\n+            }\n+            let is_are = if self.disabled.len() == 1 { \"is\" } else { \"are\" };\n+            write!(f, \" {} disabled\", is_are)?;\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "bdc3f854e08661cd6cd9e377813ae6e8530a1fc3", "filename": "src/tools/rust-analyzer/crates/cfg/src/tests.rs", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2Fsrc%2Ftests.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,224 @@\n+use arbitrary::{Arbitrary, Unstructured};\n+use expect_test::{expect, Expect};\n+use mbe::syntax_node_to_token_tree;\n+use syntax::{ast, AstNode};\n+\n+use crate::{CfgAtom, CfgExpr, CfgOptions, DnfExpr};\n+\n+fn assert_parse_result(input: &str, expected: CfgExpr) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        syntax_node_to_token_tree(tt.syntax())\n+    };\n+    let cfg = CfgExpr::parse(&tt);\n+    assert_eq!(cfg, expected);\n+}\n+\n+fn check_dnf(input: &str, expect: Expect) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        syntax_node_to_token_tree(tt.syntax())\n+    };\n+    let cfg = CfgExpr::parse(&tt);\n+    let actual = format!(\"#![cfg({})]\", DnfExpr::new(cfg));\n+    expect.assert_eq(&actual);\n+}\n+\n+fn check_why_inactive(input: &str, opts: &CfgOptions, expect: Expect) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        syntax_node_to_token_tree(tt.syntax())\n+    };\n+    let cfg = CfgExpr::parse(&tt);\n+    let dnf = DnfExpr::new(cfg);\n+    let why_inactive = dnf.why_inactive(opts).unwrap().to_string();\n+    expect.assert_eq(&why_inactive);\n+}\n+\n+#[track_caller]\n+fn check_enable_hints(input: &str, opts: &CfgOptions, expected_hints: &[&str]) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        syntax_node_to_token_tree(tt.syntax())\n+    };\n+    let cfg = CfgExpr::parse(&tt);\n+    let dnf = DnfExpr::new(cfg);\n+    let hints = dnf.compute_enable_hints(opts).map(|diff| diff.to_string()).collect::<Vec<_>>();\n+    assert_eq!(hints, expected_hints);\n+}\n+\n+#[test]\n+fn test_cfg_expr_parser() {\n+    assert_parse_result(\"#![cfg(foo)]\", CfgAtom::Flag(\"foo\".into()).into());\n+    assert_parse_result(\"#![cfg(foo,)]\", CfgAtom::Flag(\"foo\".into()).into());\n+    assert_parse_result(\n+        \"#![cfg(not(foo))]\",\n+        CfgExpr::Not(Box::new(CfgAtom::Flag(\"foo\".into()).into())),\n+    );\n+    assert_parse_result(\"#![cfg(foo(bar))]\", CfgExpr::Invalid);\n+\n+    // Only take the first\n+    assert_parse_result(r#\"#![cfg(foo, bar = \"baz\")]\"#, CfgAtom::Flag(\"foo\".into()).into());\n+\n+    assert_parse_result(\n+        r#\"#![cfg(all(foo, bar = \"baz\"))]\"#,\n+        CfgExpr::All(vec![\n+            CfgAtom::Flag(\"foo\".into()).into(),\n+            CfgAtom::KeyValue { key: \"bar\".into(), value: \"baz\".into() }.into(),\n+        ]),\n+    );\n+\n+    assert_parse_result(\n+        r#\"#![cfg(any(not(), all(), , bar = \"baz\",))]\"#,\n+        CfgExpr::Any(vec![\n+            CfgExpr::Not(Box::new(CfgExpr::Invalid)),\n+            CfgExpr::All(vec![]),\n+            CfgExpr::Invalid,\n+            CfgAtom::KeyValue { key: \"bar\".into(), value: \"baz\".into() }.into(),\n+        ]),\n+    );\n+}\n+\n+#[test]\n+fn smoke() {\n+    check_dnf(\"#![cfg(test)]\", expect![[r#\"#![cfg(test)]\"#]]);\n+    check_dnf(\"#![cfg(not(test))]\", expect![[r#\"#![cfg(not(test))]\"#]]);\n+    check_dnf(\"#![cfg(not(not(test)))]\", expect![[r#\"#![cfg(test)]\"#]]);\n+\n+    check_dnf(\"#![cfg(all(a, b))]\", expect![[r#\"#![cfg(all(a, b))]\"#]]);\n+    check_dnf(\"#![cfg(any(a, b))]\", expect![[r#\"#![cfg(any(a, b))]\"#]]);\n+\n+    check_dnf(\"#![cfg(not(a))]\", expect![[r#\"#![cfg(not(a))]\"#]]);\n+}\n+\n+#[test]\n+fn distribute() {\n+    check_dnf(\"#![cfg(all(any(a, b), c))]\", expect![[r#\"#![cfg(any(all(a, c), all(b, c)))]\"#]]);\n+    check_dnf(\"#![cfg(all(c, any(a, b)))]\", expect![[r#\"#![cfg(any(all(c, a), all(c, b)))]\"#]]);\n+    check_dnf(\n+        \"#![cfg(all(any(a, b), any(c, d)))]\",\n+        expect![[r#\"#![cfg(any(all(a, c), all(a, d), all(b, c), all(b, d)))]\"#]],\n+    );\n+\n+    check_dnf(\n+        \"#![cfg(all(any(a, b, c), any(d, e, f), g))]\",\n+        expect![[\n+            r#\"#![cfg(any(all(a, d, g), all(a, e, g), all(a, f, g), all(b, d, g), all(b, e, g), all(b, f, g), all(c, d, g), all(c, e, g), all(c, f, g)))]\"#\n+        ]],\n+    );\n+}\n+\n+#[test]\n+fn demorgan() {\n+    check_dnf(\"#![cfg(not(all(a, b)))]\", expect![[r#\"#![cfg(any(not(a), not(b)))]\"#]]);\n+    check_dnf(\"#![cfg(not(any(a, b)))]\", expect![[r#\"#![cfg(all(not(a), not(b)))]\"#]]);\n+\n+    check_dnf(\"#![cfg(not(all(not(a), b)))]\", expect![[r#\"#![cfg(any(a, not(b)))]\"#]]);\n+    check_dnf(\"#![cfg(not(any(a, not(b))))]\", expect![[r#\"#![cfg(all(not(a), b))]\"#]]);\n+}\n+\n+#[test]\n+fn nested() {\n+    check_dnf(\"#![cfg(all(any(a), not(all(any(b)))))]\", expect![[r#\"#![cfg(all(a, not(b)))]\"#]]);\n+\n+    check_dnf(\"#![cfg(any(any(a, b)))]\", expect![[r#\"#![cfg(any(a, b))]\"#]]);\n+    check_dnf(\"#![cfg(not(any(any(a, b))))]\", expect![[r#\"#![cfg(all(not(a), not(b)))]\"#]]);\n+    check_dnf(\"#![cfg(all(all(a, b)))]\", expect![[r#\"#![cfg(all(a, b))]\"#]]);\n+    check_dnf(\"#![cfg(not(all(all(a, b))))]\", expect![[r#\"#![cfg(any(not(a), not(b)))]\"#]]);\n+}\n+\n+#[test]\n+fn regression() {\n+    check_dnf(\"#![cfg(all(not(not(any(any(any()))))))]\", expect![[r##\"#![cfg(any())]\"##]]);\n+    check_dnf(\"#![cfg(all(any(all(any()))))]\", expect![[r##\"#![cfg(any())]\"##]]);\n+    check_dnf(\"#![cfg(all(all(any())))]\", expect![[r##\"#![cfg(any())]\"##]]);\n+\n+    check_dnf(\"#![cfg(all(all(any(), x)))]\", expect![[r##\"#![cfg(any())]\"##]]);\n+    check_dnf(\"#![cfg(all(all(any()), x))]\", expect![[r##\"#![cfg(any())]\"##]]);\n+    check_dnf(\"#![cfg(all(all(any(x))))]\", expect![[r##\"#![cfg(x)]\"##]]);\n+    check_dnf(\"#![cfg(all(all(any(x), x)))]\", expect![[r##\"#![cfg(all(x, x))]\"##]]);\n+}\n+\n+#[test]\n+fn hints() {\n+    let mut opts = CfgOptions::default();\n+\n+    check_enable_hints(\"#![cfg(test)]\", &opts, &[\"enable test\"]);\n+    check_enable_hints(\"#![cfg(not(test))]\", &opts, &[]);\n+\n+    check_enable_hints(\"#![cfg(any(a, b))]\", &opts, &[\"enable a\", \"enable b\"]);\n+    check_enable_hints(\"#![cfg(any(b, a))]\", &opts, &[\"enable b\", \"enable a\"]);\n+\n+    check_enable_hints(\"#![cfg(all(a, b))]\", &opts, &[\"enable a and b\"]);\n+\n+    opts.insert_atom(\"test\".into());\n+\n+    check_enable_hints(\"#![cfg(test)]\", &opts, &[]);\n+    check_enable_hints(\"#![cfg(not(test))]\", &opts, &[\"disable test\"]);\n+}\n+\n+/// Tests that we don't suggest hints for cfgs that express an inconsistent formula.\n+#[test]\n+fn hints_impossible() {\n+    let mut opts = CfgOptions::default();\n+\n+    check_enable_hints(\"#![cfg(all(test, not(test)))]\", &opts, &[]);\n+\n+    opts.insert_atom(\"test\".into());\n+\n+    check_enable_hints(\"#![cfg(all(test, not(test)))]\", &opts, &[]);\n+}\n+\n+#[test]\n+fn why_inactive() {\n+    let mut opts = CfgOptions::default();\n+    opts.insert_atom(\"test\".into());\n+    opts.insert_atom(\"test2\".into());\n+\n+    check_why_inactive(\"#![cfg(a)]\", &opts, expect![[\"a is disabled\"]]);\n+    check_why_inactive(\"#![cfg(not(test))]\", &opts, expect![[\"test is enabled\"]]);\n+\n+    check_why_inactive(\n+        \"#![cfg(all(not(test), not(test2)))]\",\n+        &opts,\n+        expect![[\"test and test2 are enabled\"]],\n+    );\n+    check_why_inactive(\"#![cfg(all(a, b))]\", &opts, expect![[\"a and b are disabled\"]]);\n+    check_why_inactive(\n+        \"#![cfg(all(not(test), a))]\",\n+        &opts,\n+        expect![[\"test is enabled and a is disabled\"]],\n+    );\n+    check_why_inactive(\n+        \"#![cfg(all(not(test), test2, a))]\",\n+        &opts,\n+        expect![[\"test is enabled and a is disabled\"]],\n+    );\n+    check_why_inactive(\n+        \"#![cfg(all(not(test), not(test2), a))]\",\n+        &opts,\n+        expect![[\"test and test2 are enabled and a is disabled\"]],\n+    );\n+}\n+\n+#[test]\n+fn proptest() {\n+    const REPEATS: usize = 512;\n+\n+    let mut rng = oorandom::Rand32::new(123456789);\n+    let mut buf = Vec::new();\n+    for _ in 0..REPEATS {\n+        buf.clear();\n+        while buf.len() < 512 {\n+            buf.extend(rng.rand_u32().to_ne_bytes());\n+        }\n+\n+        let mut u = Unstructured::new(&buf);\n+        let cfg = CfgExpr::arbitrary(&mut u).unwrap();\n+        DnfExpr::new(cfg);\n+    }\n+}"}, {"sha": "d3d180ece512a4a72f3d9dd15d2cb3643391fe44", "filename": "src/tools/rust-analyzer/crates/flycheck/Cargo.toml", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,22 @@\n+[package]\n+name = \"flycheck\"\n+version = \"0.0.0\"\n+description = \"TBD\"\n+license = \"MIT OR Apache-2.0\"\n+edition = \"2021\"\n+rust-version = \"1.57\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+crossbeam-channel = \"0.5.5\"\n+tracing = \"0.1.35\"\n+cargo_metadata = \"0.15.0\"\n+serde = { version = \"1.0.137\", features = [\"derive\"] }\n+serde_json = \"1.0.81\"\n+jod-thread = \"0.1.2\"\n+\n+toolchain = { path = \"../toolchain\", version = \"0.0.0\" }\n+stdx = { path = \"../stdx\", version = \"0.0.0\" }\n+paths = { path = \"../paths\", version = \"0.0.0\" }"}, {"sha": "4e8bc881ae7383f8caf04e0627ff244979becd92", "filename": "src/tools/rust-analyzer/crates/flycheck/src/lib.rs", "status": "added", "additions": 396, "deletions": 0, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2Fsrc%2Flib.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,396 @@\n+//! Flycheck provides the functionality needed to run `cargo check` or\n+//! another compatible command (f.x. clippy) in a background thread and provide\n+//! LSP diagnostics based on the output of the command.\n+\n+#![warn(rust_2018_idioms, unused_lifetimes, semicolon_in_expressions_from_macros)]\n+\n+use std::{\n+    fmt, io,\n+    process::{ChildStderr, ChildStdout, Command, Stdio},\n+    time::Duration,\n+};\n+\n+use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n+use paths::AbsPathBuf;\n+use serde::Deserialize;\n+use stdx::{process::streaming_output, JodChild};\n+\n+pub use cargo_metadata::diagnostic::{\n+    Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,\n+    DiagnosticSpanMacroExpansion,\n+};\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum FlycheckConfig {\n+    CargoCommand {\n+        command: String,\n+        target_triple: Option<String>,\n+        all_targets: bool,\n+        no_default_features: bool,\n+        all_features: bool,\n+        features: Vec<String>,\n+        extra_args: Vec<String>,\n+    },\n+    CustomCommand {\n+        command: String,\n+        args: Vec<String>,\n+    },\n+}\n+\n+impl fmt::Display for FlycheckConfig {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            FlycheckConfig::CargoCommand { command, .. } => write!(f, \"cargo {}\", command),\n+            FlycheckConfig::CustomCommand { command, args } => {\n+                write!(f, \"{} {}\", command, args.join(\" \"))\n+            }\n+        }\n+    }\n+}\n+\n+/// Flycheck wraps the shared state and communication machinery used for\n+/// running `cargo check` (or other compatible command) and providing\n+/// diagnostics based on the output.\n+/// The spawned thread is shut down when this struct is dropped.\n+#[derive(Debug)]\n+pub struct FlycheckHandle {\n+    // XXX: drop order is significant\n+    sender: Sender<Restart>,\n+    _thread: jod_thread::JoinHandle,\n+}\n+\n+impl FlycheckHandle {\n+    pub fn spawn(\n+        id: usize,\n+        sender: Box<dyn Fn(Message) + Send>,\n+        config: FlycheckConfig,\n+        workspace_root: AbsPathBuf,\n+    ) -> FlycheckHandle {\n+        let actor = FlycheckActor::new(id, sender, config, workspace_root);\n+        let (sender, receiver) = unbounded::<Restart>();\n+        let thread = jod_thread::Builder::new()\n+            .name(\"Flycheck\".to_owned())\n+            .spawn(move || actor.run(receiver))\n+            .expect(\"failed to spawn thread\");\n+        FlycheckHandle { sender, _thread: thread }\n+    }\n+\n+    /// Schedule a re-start of the cargo check worker.\n+    pub fn update(&self) {\n+        self.sender.send(Restart).unwrap();\n+    }\n+}\n+\n+pub enum Message {\n+    /// Request adding a diagnostic with fixes included to a file\n+    AddDiagnostic { workspace_root: AbsPathBuf, diagnostic: Diagnostic },\n+\n+    /// Request check progress notification to client\n+    Progress {\n+        /// Flycheck instance ID\n+        id: usize,\n+        progress: Progress,\n+    },\n+}\n+\n+impl fmt::Debug for Message {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Message::AddDiagnostic { workspace_root, diagnostic } => f\n+                .debug_struct(\"AddDiagnostic\")\n+                .field(\"workspace_root\", workspace_root)\n+                .field(\"diagnostic_code\", &diagnostic.code.as_ref().map(|it| &it.code))\n+                .finish(),\n+            Message::Progress { id, progress } => {\n+                f.debug_struct(\"Progress\").field(\"id\", id).field(\"progress\", progress).finish()\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum Progress {\n+    DidStart,\n+    DidCheckCrate(String),\n+    DidFinish(io::Result<()>),\n+    DidCancel,\n+}\n+\n+struct Restart;\n+\n+struct FlycheckActor {\n+    id: usize,\n+    sender: Box<dyn Fn(Message) + Send>,\n+    config: FlycheckConfig,\n+    workspace_root: AbsPathBuf,\n+    /// CargoHandle exists to wrap around the communication needed to be able to\n+    /// run `cargo check` without blocking. Currently the Rust standard library\n+    /// doesn't provide a way to read sub-process output without blocking, so we\n+    /// have to wrap sub-processes output handling in a thread and pass messages\n+    /// back over a channel.\n+    cargo_handle: Option<CargoHandle>,\n+}\n+\n+enum Event {\n+    Restart(Restart),\n+    CheckEvent(Option<CargoMessage>),\n+}\n+\n+impl FlycheckActor {\n+    fn new(\n+        id: usize,\n+        sender: Box<dyn Fn(Message) + Send>,\n+        config: FlycheckConfig,\n+        workspace_root: AbsPathBuf,\n+    ) -> FlycheckActor {\n+        FlycheckActor { id, sender, config, workspace_root, cargo_handle: None }\n+    }\n+    fn progress(&self, progress: Progress) {\n+        self.send(Message::Progress { id: self.id, progress });\n+    }\n+    fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n+        let check_chan = self.cargo_handle.as_ref().map(|cargo| &cargo.receiver);\n+        select! {\n+            recv(inbox) -> msg => msg.ok().map(Event::Restart),\n+            recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n+        }\n+    }\n+    fn run(mut self, inbox: Receiver<Restart>) {\n+        while let Some(event) = self.next_event(&inbox) {\n+            match event {\n+                Event::Restart(Restart) => {\n+                    // Cancel the previously spawned process\n+                    self.cancel_check_process();\n+                    while let Ok(Restart) = inbox.recv_timeout(Duration::from_millis(50)) {}\n+\n+                    let command = self.check_command();\n+                    tracing::debug!(?command, \"will restart flycheck\");\n+                    match CargoHandle::spawn(command) {\n+                        Ok(cargo_handle) => {\n+                            tracing::debug!(\n+                                command = ?self.check_command(),\n+                                \"did  restart flycheck\"\n+                            );\n+                            self.cargo_handle = Some(cargo_handle);\n+                            self.progress(Progress::DidStart);\n+                        }\n+                        Err(error) => {\n+                            tracing::error!(\n+                                command = ?self.check_command(),\n+                                %error, \"failed to restart flycheck\"\n+                            );\n+                        }\n+                    }\n+                }\n+                Event::CheckEvent(None) => {\n+                    tracing::debug!(\"flycheck finished\");\n+\n+                    // Watcher finished\n+                    let cargo_handle = self.cargo_handle.take().unwrap();\n+                    let res = cargo_handle.join();\n+                    if res.is_err() {\n+                        tracing::error!(\n+                            \"Flycheck failed to run the following command: {:?}\",\n+                            self.check_command()\n+                        );\n+                    }\n+                    self.progress(Progress::DidFinish(res));\n+                }\n+                Event::CheckEvent(Some(message)) => match message {\n+                    CargoMessage::CompilerArtifact(msg) => {\n+                        self.progress(Progress::DidCheckCrate(msg.target.name));\n+                    }\n+\n+                    CargoMessage::Diagnostic(msg) => {\n+                        self.send(Message::AddDiagnostic {\n+                            workspace_root: self.workspace_root.clone(),\n+                            diagnostic: msg,\n+                        });\n+                    }\n+                },\n+            }\n+        }\n+        // If we rerun the thread, we need to discard the previous check results first\n+        self.cancel_check_process();\n+    }\n+\n+    fn cancel_check_process(&mut self) {\n+        if let Some(cargo_handle) = self.cargo_handle.take() {\n+            cargo_handle.cancel();\n+            self.progress(Progress::DidCancel);\n+        }\n+    }\n+\n+    fn check_command(&self) -> Command {\n+        let mut cmd = match &self.config {\n+            FlycheckConfig::CargoCommand {\n+                command,\n+                target_triple,\n+                no_default_features,\n+                all_targets,\n+                all_features,\n+                extra_args,\n+                features,\n+            } => {\n+                let mut cmd = Command::new(toolchain::cargo());\n+                cmd.arg(command);\n+                cmd.current_dir(&self.workspace_root);\n+                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n+                    .arg(self.workspace_root.join(\"Cargo.toml\").as_os_str());\n+\n+                if let Some(target) = target_triple {\n+                    cmd.args(&[\"--target\", target.as_str()]);\n+                }\n+                if *all_targets {\n+                    cmd.arg(\"--all-targets\");\n+                }\n+                if *all_features {\n+                    cmd.arg(\"--all-features\");\n+                } else {\n+                    if *no_default_features {\n+                        cmd.arg(\"--no-default-features\");\n+                    }\n+                    if !features.is_empty() {\n+                        cmd.arg(\"--features\");\n+                        cmd.arg(features.join(\" \"));\n+                    }\n+                }\n+                cmd.args(extra_args);\n+                cmd\n+            }\n+            FlycheckConfig::CustomCommand { command, args } => {\n+                let mut cmd = Command::new(command);\n+                cmd.args(args);\n+                cmd\n+            }\n+        };\n+        cmd.current_dir(&self.workspace_root);\n+        cmd\n+    }\n+\n+    fn send(&self, check_task: Message) {\n+        (self.sender)(check_task);\n+    }\n+}\n+\n+/// A handle to a cargo process used for fly-checking.\n+struct CargoHandle {\n+    /// The handle to the actual cargo process. As we cannot cancel directly from with\n+    /// a read syscall dropping and therefor terminating the process is our best option.\n+    child: JodChild,\n+    thread: jod_thread::JoinHandle<io::Result<(bool, String)>>,\n+    receiver: Receiver<CargoMessage>,\n+}\n+\n+impl CargoHandle {\n+    fn spawn(mut command: Command) -> std::io::Result<CargoHandle> {\n+        command.stdout(Stdio::piped()).stderr(Stdio::piped()).stdin(Stdio::null());\n+        let mut child = JodChild::spawn(command)?;\n+\n+        let stdout = child.stdout.take().unwrap();\n+        let stderr = child.stderr.take().unwrap();\n+\n+        let (sender, receiver) = unbounded();\n+        let actor = CargoActor::new(sender, stdout, stderr);\n+        let thread = jod_thread::Builder::new()\n+            .name(\"CargoHandle\".to_owned())\n+            .spawn(move || actor.run())\n+            .expect(\"failed to spawn thread\");\n+        Ok(CargoHandle { child, thread, receiver })\n+    }\n+\n+    fn cancel(mut self) {\n+        let _ = self.child.kill();\n+        let _ = self.child.wait();\n+    }\n+\n+    fn join(mut self) -> io::Result<()> {\n+        let _ = self.child.kill();\n+        let exit_status = self.child.wait()?;\n+        let (read_at_least_one_message, error) = self.thread.join()?;\n+        if read_at_least_one_message || exit_status.success() {\n+            Ok(())\n+        } else {\n+            Err(io::Error::new(io::ErrorKind::Other, format!(\n+                \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?}):\\n{}\",\n+                exit_status, error\n+            )))\n+        }\n+    }\n+}\n+\n+struct CargoActor {\n+    sender: Sender<CargoMessage>,\n+    stdout: ChildStdout,\n+    stderr: ChildStderr,\n+}\n+\n+impl CargoActor {\n+    fn new(sender: Sender<CargoMessage>, stdout: ChildStdout, stderr: ChildStderr) -> CargoActor {\n+        CargoActor { sender, stdout, stderr }\n+    }\n+\n+    fn run(self) -> io::Result<(bool, String)> {\n+        // We manually read a line at a time, instead of using serde's\n+        // stream deserializers, because the deserializer cannot recover\n+        // from an error, resulting in it getting stuck, because we try to\n+        // be resilient against failures.\n+        //\n+        // Because cargo only outputs one JSON object per line, we can\n+        // simply skip a line if it doesn't parse, which just ignores any\n+        // erroneus output.\n+\n+        let mut error = String::new();\n+        let mut read_at_least_one_message = false;\n+        let output = streaming_output(\n+            self.stdout,\n+            self.stderr,\n+            &mut |line| {\n+                read_at_least_one_message = true;\n+\n+                // Try to deserialize a message from Cargo or Rustc.\n+                let mut deserializer = serde_json::Deserializer::from_str(line);\n+                deserializer.disable_recursion_limit();\n+                if let Ok(message) = JsonMessage::deserialize(&mut deserializer) {\n+                    match message {\n+                        // Skip certain kinds of messages to only spend time on what's useful\n+                        JsonMessage::Cargo(message) => match message {\n+                            cargo_metadata::Message::CompilerArtifact(artifact)\n+                                if !artifact.fresh =>\n+                            {\n+                                self.sender.send(CargoMessage::CompilerArtifact(artifact)).unwrap();\n+                            }\n+                            cargo_metadata::Message::CompilerMessage(msg) => {\n+                                self.sender.send(CargoMessage::Diagnostic(msg.message)).unwrap();\n+                            }\n+                            _ => (),\n+                        },\n+                        JsonMessage::Rustc(message) => {\n+                            self.sender.send(CargoMessage::Diagnostic(message)).unwrap();\n+                        }\n+                    }\n+                }\n+            },\n+            &mut |line| {\n+                error.push_str(line);\n+                error.push('\\n');\n+            },\n+        );\n+        match output {\n+            Ok(_) => Ok((read_at_least_one_message, error)),\n+            Err(e) => Err(io::Error::new(e.kind(), format!(\"{:?}: {}\", e, error))),\n+        }\n+    }\n+}\n+\n+enum CargoMessage {\n+    CompilerArtifact(cargo_metadata::Artifact),\n+    Diagnostic(Diagnostic),\n+}\n+\n+#[derive(Deserialize)]\n+#[serde(untagged)]\n+enum JsonMessage {\n+    Cargo(cargo_metadata::Message),\n+    Rustc(Diagnostic),\n+}"}, {"sha": "e8cff2f3e6cd7190bb63b188a5063fdd022e3ec6", "filename": "src/tools/rust-analyzer/crates/hir-def/Cargo.toml", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,43 @@\n+[package]\n+name = \"hir-def\"\n+version = \"0.0.0\"\n+description = \"TBD\"\n+license = \"MIT OR Apache-2.0\"\n+edition = \"2021\"\n+rust-version = \"1.57\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+anymap = \"1.0.0-beta.2\"\n+arrayvec = \"0.7.2\"\n+bitflags = \"1.3.2\"\n+cov-mark = \"2.0.0-pre.1\"\n+# We need to freeze the version of the crate, as the raw-api feature is considered unstable\n+dashmap = { version = \"=5.3.4\", features = [\"raw-api\"] }\n+drop_bomb = \"0.1.5\"\n+either = \"1.7.0\"\n+fst = { version = \"0.4.7\", default-features = false }\n+hashbrown = { version = \"0.12.1\", default-features = false }\n+indexmap = \"1.9.1\"\n+itertools = \"0.10.3\"\n+la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n+once_cell = \"1.12.0\"\n+rustc-hash = \"1.1.0\"\n+smallvec = \"1.9.0\"\n+tracing = \"0.1.35\"\n+\n+stdx = { path = \"../stdx\", version = \"0.0.0\" }\n+base-db = { path = \"../base-db\", version = \"0.0.0\" }\n+syntax = { path = \"../syntax\", version = \"0.0.0\" }\n+profile = { path = \"../profile\", version = \"0.0.0\" }\n+hir-expand = { path = \"../hir-expand\", version = \"0.0.0\" }\n+mbe = { path = \"../mbe\", version = \"0.0.0\" }\n+cfg = { path = \"../cfg\", version = \"0.0.0\" }\n+tt = { path = \"../tt\", version = \"0.0.0\" }\n+limit = { path = \"../limit\", version = \"0.0.0\" }\n+\n+[dev-dependencies]\n+test-utils = { path = \"../test-utils\" }\n+expect-test = \"1.4.0\""}, {"sha": "277135d6dc4288798700d48e66712f5add18cc6f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/adt.rs", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,365 @@\n+//! Defines hir-level representation of structs, enums and unions\n+\n+use std::sync::Arc;\n+\n+use base_db::CrateId;\n+use either::Either;\n+use hir_expand::{\n+    name::{AsName, Name},\n+    InFile,\n+};\n+use la_arena::{Arena, ArenaMap};\n+use syntax::ast::{self, HasName, HasVisibility};\n+use tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n+\n+use crate::{\n+    body::{CfgExpander, LowerCtx},\n+    db::DefDatabase,\n+    intern::Interned,\n+    item_tree::{AttrOwner, Field, Fields, ItemTree, ModItem, RawVisibilityId},\n+    src::HasChildSource,\n+    src::HasSource,\n+    trace::Trace,\n+    type_ref::TypeRef,\n+    visibility::RawVisibility,\n+    EnumId, LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StructId, UnionId, VariantId,\n+};\n+use cfg::CfgOptions;\n+\n+/// Note that we use `StructData` for unions as well!\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct StructData {\n+    pub name: Name,\n+    pub variant_data: Arc<VariantData>,\n+    pub repr: Option<ReprKind>,\n+    pub visibility: RawVisibility,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct EnumData {\n+    pub name: Name,\n+    pub variants: Arena<EnumVariantData>,\n+    pub visibility: RawVisibility,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct EnumVariantData {\n+    pub name: Name,\n+    pub variant_data: Arc<VariantData>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum VariantData {\n+    Record(Arena<FieldData>),\n+    Tuple(Arena<FieldData>),\n+    Unit,\n+}\n+\n+/// A single field of an enum variant or struct\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct FieldData {\n+    pub name: Name,\n+    pub type_ref: Interned<TypeRef>,\n+    pub visibility: RawVisibility,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ReprKind {\n+    Packed,\n+    Other,\n+}\n+\n+fn repr_from_value(\n+    db: &dyn DefDatabase,\n+    krate: CrateId,\n+    item_tree: &ItemTree,\n+    of: AttrOwner,\n+) -> Option<ReprKind> {\n+    item_tree.attrs(db, krate, of).by_key(\"repr\").tt_values().find_map(parse_repr_tt)\n+}\n+\n+fn parse_repr_tt(tt: &Subtree) -> Option<ReprKind> {\n+    match tt.delimiter {\n+        Some(Delimiter { kind: DelimiterKind::Parenthesis, .. }) => {}\n+        _ => return None,\n+    }\n+\n+    let mut it = tt.token_trees.iter();\n+    match it.next()? {\n+        TokenTree::Leaf(Leaf::Ident(ident)) if ident.text == \"packed\" => Some(ReprKind::Packed),\n+        _ => Some(ReprKind::Other),\n+    }\n+}\n+\n+impl StructData {\n+    pub(crate) fn struct_data_query(db: &dyn DefDatabase, id: StructId) -> Arc<StructData> {\n+        let loc = id.lookup(db);\n+        let krate = loc.container.krate;\n+        let item_tree = loc.id.item_tree(db);\n+        let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n+        let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n+\n+        let strukt = &item_tree[loc.id.value];\n+        let variant_data = lower_fields(db, krate, &item_tree, &cfg_options, &strukt.fields, None);\n+        Arc::new(StructData {\n+            name: strukt.name.clone(),\n+            variant_data: Arc::new(variant_data),\n+            repr,\n+            visibility: item_tree[strukt.visibility].clone(),\n+        })\n+    }\n+    pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n+        let loc = id.lookup(db);\n+        let krate = loc.container.krate;\n+        let item_tree = loc.id.item_tree(db);\n+        let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n+        let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n+\n+        let union = &item_tree[loc.id.value];\n+        let variant_data = lower_fields(db, krate, &item_tree, &cfg_options, &union.fields, None);\n+\n+        Arc::new(StructData {\n+            name: union.name.clone(),\n+            variant_data: Arc::new(variant_data),\n+            repr,\n+            visibility: item_tree[union.visibility].clone(),\n+        })\n+    }\n+}\n+\n+impl EnumData {\n+    pub(crate) fn enum_data_query(db: &dyn DefDatabase, e: EnumId) -> Arc<EnumData> {\n+        let loc = e.lookup(db);\n+        let krate = loc.container.krate;\n+        let item_tree = loc.id.item_tree(db);\n+        let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n+\n+        let enum_ = &item_tree[loc.id.value];\n+        let mut variants = Arena::new();\n+        for tree_id in enum_.variants.clone() {\n+            if item_tree.attrs(db, krate, tree_id.into()).is_cfg_enabled(&cfg_options) {\n+                let var = &item_tree[tree_id];\n+                let var_data = lower_fields(\n+                    db,\n+                    krate,\n+                    &item_tree,\n+                    &cfg_options,\n+                    &var.fields,\n+                    Some(enum_.visibility),\n+                );\n+\n+                variants.alloc(EnumVariantData {\n+                    name: var.name.clone(),\n+                    variant_data: Arc::new(var_data),\n+                });\n+            }\n+        }\n+\n+        Arc::new(EnumData {\n+            name: enum_.name.clone(),\n+            variants,\n+            visibility: item_tree[enum_.visibility].clone(),\n+        })\n+    }\n+\n+    pub fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {\n+        let (id, _) = self.variants.iter().find(|(_id, data)| &data.name == name)?;\n+        Some(id)\n+    }\n+}\n+\n+impl HasChildSource<LocalEnumVariantId> for EnumId {\n+    type Value = ast::Variant;\n+    fn child_source(\n+        &self,\n+        db: &dyn DefDatabase,\n+    ) -> InFile<ArenaMap<LocalEnumVariantId, Self::Value>> {\n+        let src = self.lookup(db).source(db);\n+        let mut trace = Trace::new_for_map();\n+        lower_enum(db, &mut trace, &src, self.lookup(db).container);\n+        src.with_value(trace.into_map())\n+    }\n+}\n+\n+fn lower_enum(\n+    db: &dyn DefDatabase,\n+    trace: &mut Trace<EnumVariantData, ast::Variant>,\n+    ast: &InFile<ast::Enum>,\n+    module_id: ModuleId,\n+) {\n+    let expander = CfgExpander::new(db, ast.file_id, module_id.krate);\n+    let variants = ast\n+        .value\n+        .variant_list()\n+        .into_iter()\n+        .flat_map(|it| it.variants())\n+        .filter(|var| expander.is_cfg_enabled(db, var));\n+    for var in variants {\n+        trace.alloc(\n+            || var.clone(),\n+            || EnumVariantData {\n+                name: var.name().map_or_else(Name::missing, |it| it.as_name()),\n+                variant_data: Arc::new(VariantData::new(db, ast.with_value(var.kind()), module_id)),\n+            },\n+        );\n+    }\n+}\n+\n+impl VariantData {\n+    fn new(db: &dyn DefDatabase, flavor: InFile<ast::StructKind>, module_id: ModuleId) -> Self {\n+        let mut expander = CfgExpander::new(db, flavor.file_id, module_id.krate);\n+        let mut trace = Trace::new_for_arena();\n+        match lower_struct(db, &mut expander, &mut trace, &flavor) {\n+            StructKind::Tuple => VariantData::Tuple(trace.into_arena()),\n+            StructKind::Record => VariantData::Record(trace.into_arena()),\n+            StructKind::Unit => VariantData::Unit,\n+        }\n+    }\n+\n+    pub fn fields(&self) -> &Arena<FieldData> {\n+        const EMPTY: &Arena<FieldData> = &Arena::new();\n+        match &self {\n+            VariantData::Record(fields) | VariantData::Tuple(fields) => fields,\n+            _ => EMPTY,\n+        }\n+    }\n+\n+    pub fn field(&self, name: &Name) -> Option<LocalFieldId> {\n+        self.fields().iter().find_map(|(id, data)| if &data.name == name { Some(id) } else { None })\n+    }\n+\n+    pub fn kind(&self) -> StructKind {\n+        match self {\n+            VariantData::Record(_) => StructKind::Record,\n+            VariantData::Tuple(_) => StructKind::Tuple,\n+            VariantData::Unit => StructKind::Unit,\n+        }\n+    }\n+}\n+\n+impl HasChildSource<LocalFieldId> for VariantId {\n+    type Value = Either<ast::TupleField, ast::RecordField>;\n+\n+    fn child_source(&self, db: &dyn DefDatabase) -> InFile<ArenaMap<LocalFieldId, Self::Value>> {\n+        let (src, module_id) = match self {\n+            VariantId::EnumVariantId(it) => {\n+                // I don't really like the fact that we call into parent source\n+                // here, this might add to more queries then necessary.\n+                let src = it.parent.child_source(db);\n+                (src.map(|map| map[it.local_id].kind()), it.parent.lookup(db).container)\n+            }\n+            VariantId::StructId(it) => {\n+                (it.lookup(db).source(db).map(|it| it.kind()), it.lookup(db).container)\n+            }\n+            VariantId::UnionId(it) => (\n+                it.lookup(db).source(db).map(|it| {\n+                    it.record_field_list()\n+                        .map(ast::StructKind::Record)\n+                        .unwrap_or(ast::StructKind::Unit)\n+                }),\n+                it.lookup(db).container,\n+            ),\n+        };\n+        let mut expander = CfgExpander::new(db, src.file_id, module_id.krate);\n+        let mut trace = Trace::new_for_map();\n+        lower_struct(db, &mut expander, &mut trace, &src);\n+        src.with_value(trace.into_map())\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum StructKind {\n+    Tuple,\n+    Record,\n+    Unit,\n+}\n+\n+fn lower_struct(\n+    db: &dyn DefDatabase,\n+    expander: &mut CfgExpander,\n+    trace: &mut Trace<FieldData, Either<ast::TupleField, ast::RecordField>>,\n+    ast: &InFile<ast::StructKind>,\n+) -> StructKind {\n+    let ctx = LowerCtx::new(db, ast.file_id);\n+\n+    match &ast.value {\n+        ast::StructKind::Tuple(fl) => {\n+            for (i, fd) in fl.fields().enumerate() {\n+                if !expander.is_cfg_enabled(db, &fd) {\n+                    continue;\n+                }\n+\n+                trace.alloc(\n+                    || Either::Left(fd.clone()),\n+                    || FieldData {\n+                        name: Name::new_tuple_field(i),\n+                        type_ref: Interned::new(TypeRef::from_ast_opt(&ctx, fd.ty())),\n+                        visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n+                    },\n+                );\n+            }\n+            StructKind::Tuple\n+        }\n+        ast::StructKind::Record(fl) => {\n+            for fd in fl.fields() {\n+                if !expander.is_cfg_enabled(db, &fd) {\n+                    continue;\n+                }\n+\n+                trace.alloc(\n+                    || Either::Right(fd.clone()),\n+                    || FieldData {\n+                        name: fd.name().map(|n| n.as_name()).unwrap_or_else(Name::missing),\n+                        type_ref: Interned::new(TypeRef::from_ast_opt(&ctx, fd.ty())),\n+                        visibility: RawVisibility::from_ast(db, ast.with_value(fd.visibility())),\n+                    },\n+                );\n+            }\n+            StructKind::Record\n+        }\n+        ast::StructKind::Unit => StructKind::Unit,\n+    }\n+}\n+\n+fn lower_fields(\n+    db: &dyn DefDatabase,\n+    krate: CrateId,\n+    item_tree: &ItemTree,\n+    cfg_options: &CfgOptions,\n+    fields: &Fields,\n+    override_visibility: Option<RawVisibilityId>,\n+) -> VariantData {\n+    match fields {\n+        Fields::Record(flds) => {\n+            let mut arena = Arena::new();\n+            for field_id in flds.clone() {\n+                if item_tree.attrs(db, krate, field_id.into()).is_cfg_enabled(cfg_options) {\n+                    arena.alloc(lower_field(item_tree, &item_tree[field_id], override_visibility));\n+                }\n+            }\n+            VariantData::Record(arena)\n+        }\n+        Fields::Tuple(flds) => {\n+            let mut arena = Arena::new();\n+            for field_id in flds.clone() {\n+                if item_tree.attrs(db, krate, field_id.into()).is_cfg_enabled(cfg_options) {\n+                    arena.alloc(lower_field(item_tree, &item_tree[field_id], override_visibility));\n+                }\n+            }\n+            VariantData::Tuple(arena)\n+        }\n+        Fields::Unit => VariantData::Unit,\n+    }\n+}\n+\n+fn lower_field(\n+    item_tree: &ItemTree,\n+    field: &Field,\n+    override_visibility: Option<RawVisibilityId>,\n+) -> FieldData {\n+    FieldData {\n+        name: field.name.clone(),\n+        type_ref: field.type_ref.clone(),\n+        visibility: item_tree[override_visibility.unwrap_or(field.visibility)].clone(),\n+    }\n+}"}, {"sha": "8a6b6f3effd2ed33e6f121a79f8bf816688b8125", "filename": "src/tools/rust-analyzer/crates/hir-def/src/attr.rs", "status": "added", "additions": 991, "deletions": 0, "changes": 991, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fattr.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,991 @@\n+//! A higher level attributes based on TokenTree, with also some shortcuts.\n+\n+use std::{fmt, hash::Hash, ops, sync::Arc};\n+\n+use base_db::CrateId;\n+use cfg::{CfgExpr, CfgOptions};\n+use either::Either;\n+use hir_expand::{hygiene::Hygiene, name::AsName, HirFileId, InFile};\n+use itertools::Itertools;\n+use la_arena::{ArenaMap, Idx, RawIdx};\n+use mbe::{syntax_node_to_token_tree, DelimiterKind, Punct};\n+use smallvec::{smallvec, SmallVec};\n+use syntax::{\n+    ast::{self, AstNode, HasAttrs, IsString},\n+    match_ast, AstPtr, AstToken, SmolStr, SyntaxNode, TextRange, TextSize,\n+};\n+use tt::Subtree;\n+\n+use crate::{\n+    db::DefDatabase,\n+    intern::Interned,\n+    item_tree::{AttrOwner, Fields, ItemTreeId, ItemTreeNode},\n+    nameres::{ModuleOrigin, ModuleSource},\n+    path::{ModPath, PathKind},\n+    src::{HasChildSource, HasSource},\n+    AdtId, AttrDefId, EnumId, GenericParamId, LocalEnumVariantId, LocalFieldId, Lookup, MacroId,\n+    VariantId,\n+};\n+\n+/// Holds documentation\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Documentation(String);\n+\n+impl Documentation {\n+    pub fn new(s: String) -> Self {\n+        Documentation(s)\n+    }\n+\n+    pub fn as_str(&self) -> &str {\n+        &self.0\n+    }\n+}\n+\n+impl From<Documentation> for String {\n+    fn from(Documentation(string): Documentation) -> Self {\n+        string\n+    }\n+}\n+\n+/// Syntactical attributes, without filtering of `cfg_attr`s.\n+#[derive(Default, Debug, Clone, PartialEq, Eq)]\n+pub(crate) struct RawAttrs {\n+    entries: Option<Arc<[Attr]>>,\n+}\n+\n+#[derive(Default, Debug, Clone, PartialEq, Eq)]\n+pub struct Attrs(RawAttrs);\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct AttrsWithOwner {\n+    attrs: Attrs,\n+    owner: AttrDefId,\n+}\n+\n+impl ops::Deref for RawAttrs {\n+    type Target = [Attr];\n+\n+    fn deref(&self) -> &[Attr] {\n+        match &self.entries {\n+            Some(it) => &*it,\n+            None => &[],\n+        }\n+    }\n+}\n+impl Attrs {\n+    pub fn get(&self, id: AttrId) -> Option<&Attr> {\n+        (**self).iter().find(|attr| attr.id == id)\n+    }\n+}\n+\n+impl ops::Deref for Attrs {\n+    type Target = [Attr];\n+\n+    fn deref(&self) -> &[Attr] {\n+        match &self.0.entries {\n+            Some(it) => &*it,\n+            None => &[],\n+        }\n+    }\n+}\n+\n+impl ops::Deref for AttrsWithOwner {\n+    type Target = Attrs;\n+\n+    fn deref(&self) -> &Attrs {\n+        &self.attrs\n+    }\n+}\n+\n+impl RawAttrs {\n+    pub(crate) const EMPTY: Self = Self { entries: None };\n+\n+    pub(crate) fn new(db: &dyn DefDatabase, owner: &dyn ast::HasAttrs, hygiene: &Hygiene) -> Self {\n+        let entries = collect_attrs(owner)\n+            .filter_map(|(id, attr)| match attr {\n+                Either::Left(attr) => {\n+                    attr.meta().and_then(|meta| Attr::from_src(db, meta, hygiene, id))\n+                }\n+                Either::Right(comment) => comment.doc_comment().map(|doc| Attr {\n+                    id,\n+                    input: Some(Interned::new(AttrInput::Literal(SmolStr::new(doc)))),\n+                    path: Interned::new(ModPath::from(hir_expand::name!(doc))),\n+                }),\n+            })\n+            .collect::<Arc<_>>();\n+\n+        Self { entries: if entries.is_empty() { None } else { Some(entries) } }\n+    }\n+\n+    fn from_attrs_owner(db: &dyn DefDatabase, owner: InFile<&dyn ast::HasAttrs>) -> Self {\n+        let hygiene = Hygiene::new(db.upcast(), owner.file_id);\n+        Self::new(db, owner.value, &hygiene)\n+    }\n+\n+    pub(crate) fn merge(&self, other: Self) -> Self {\n+        // FIXME: This needs to fixup `AttrId`s\n+        match (&self.entries, &other.entries) {\n+            (None, None) => Self::EMPTY,\n+            (Some(entries), None) | (None, Some(entries)) => {\n+                Self { entries: Some(entries.clone()) }\n+            }\n+            (Some(a), Some(b)) => {\n+                Self { entries: Some(a.iter().chain(b.iter()).cloned().collect()) }\n+            }\n+        }\n+    }\n+\n+    /// Processes `cfg_attr`s, returning the resulting semantic `Attrs`.\n+    pub(crate) fn filter(self, db: &dyn DefDatabase, krate: CrateId) -> Attrs {\n+        let has_cfg_attrs = self.iter().any(|attr| {\n+            attr.path.as_ident().map_or(false, |name| *name == hir_expand::name![cfg_attr])\n+        });\n+        if !has_cfg_attrs {\n+            return Attrs(self);\n+        }\n+\n+        let crate_graph = db.crate_graph();\n+        let new_attrs = self\n+            .iter()\n+            .flat_map(|attr| -> SmallVec<[_; 1]> {\n+                let is_cfg_attr =\n+                    attr.path.as_ident().map_or(false, |name| *name == hir_expand::name![cfg_attr]);\n+                if !is_cfg_attr {\n+                    return smallvec![attr.clone()];\n+                }\n+\n+                let subtree = match attr.token_tree_value() {\n+                    Some(it) => it,\n+                    _ => return smallvec![attr.clone()],\n+                };\n+\n+                // Input subtree is: `(cfg, $(attr),+)`\n+                // Split it up into a `cfg` subtree and the `attr` subtrees.\n+                // FIXME: There should be a common API for this.\n+                let mut parts = subtree.token_trees.split(|tt| {\n+                    matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. })))\n+                });\n+                let cfg = match parts.next() {\n+                    Some(it) => it,\n+                    None => return smallvec![],\n+                };\n+                let cfg = Subtree { delimiter: subtree.delimiter, token_trees: cfg.to_vec() };\n+                let cfg = CfgExpr::parse(&cfg);\n+                let index = attr.id;\n+                let attrs = parts.filter(|a| !a.is_empty()).filter_map(|attr| {\n+                    let tree = Subtree { delimiter: None, token_trees: attr.to_vec() };\n+                    // FIXME hygiene\n+                    let hygiene = Hygiene::new_unhygienic();\n+                    Attr::from_tt(db, &tree, &hygiene, index)\n+                });\n+\n+                let cfg_options = &crate_graph[krate].cfg_options;\n+                if cfg_options.check(&cfg) == Some(false) {\n+                    smallvec![]\n+                } else {\n+                    cov_mark::hit!(cfg_attr_active);\n+\n+                    attrs.collect()\n+                }\n+            })\n+            .collect();\n+\n+        Attrs(RawAttrs { entries: Some(new_attrs) })\n+    }\n+}\n+\n+impl Attrs {\n+    pub const EMPTY: Self = Self(RawAttrs::EMPTY);\n+\n+    pub(crate) fn variants_attrs_query(\n+        db: &dyn DefDatabase,\n+        e: EnumId,\n+    ) -> Arc<ArenaMap<LocalEnumVariantId, Attrs>> {\n+        // FIXME: There should be some proper form of mapping between item tree enum variant ids and hir enum variant ids\n+        let mut res = ArenaMap::default();\n+\n+        let loc = e.lookup(db);\n+        let krate = loc.container.krate;\n+        let item_tree = loc.id.item_tree(db);\n+        let enum_ = &item_tree[loc.id.value];\n+        let crate_graph = db.crate_graph();\n+        let cfg_options = &crate_graph[krate].cfg_options;\n+\n+        let mut idx = 0;\n+        for variant in enum_.variants.clone() {\n+            let attrs = item_tree.attrs(db, krate, variant.into());\n+            if attrs.is_cfg_enabled(cfg_options) {\n+                res.insert(Idx::from_raw(RawIdx::from(idx)), attrs);\n+                idx += 1;\n+            }\n+        }\n+\n+        Arc::new(res)\n+    }\n+\n+    pub(crate) fn fields_attrs_query(\n+        db: &dyn DefDatabase,\n+        v: VariantId,\n+    ) -> Arc<ArenaMap<LocalFieldId, Attrs>> {\n+        // FIXME: There should be some proper form of mapping between item tree field ids and hir field ids\n+        let mut res = ArenaMap::default();\n+\n+        let crate_graph = db.crate_graph();\n+        let (fields, item_tree, krate) = match v {\n+            VariantId::EnumVariantId(it) => {\n+                let e = it.parent;\n+                let loc = e.lookup(db);\n+                let krate = loc.container.krate;\n+                let item_tree = loc.id.item_tree(db);\n+                let enum_ = &item_tree[loc.id.value];\n+\n+                let cfg_options = &crate_graph[krate].cfg_options;\n+                let variant = 'tri: loop {\n+                    let mut idx = 0;\n+                    for variant in enum_.variants.clone() {\n+                        let attrs = item_tree.attrs(db, krate, variant.into());\n+                        if attrs.is_cfg_enabled(cfg_options) {\n+                            if it.local_id == Idx::from_raw(RawIdx::from(idx)) {\n+                                break 'tri variant;\n+                            }\n+                            idx += 1;\n+                        }\n+                    }\n+                    return Arc::new(res);\n+                };\n+                (item_tree[variant].fields.clone(), item_tree, krate)\n+            }\n+            VariantId::StructId(it) => {\n+                let loc = it.lookup(db);\n+                let krate = loc.container.krate;\n+                let item_tree = loc.id.item_tree(db);\n+                let struct_ = &item_tree[loc.id.value];\n+                (struct_.fields.clone(), item_tree, krate)\n+            }\n+            VariantId::UnionId(it) => {\n+                let loc = it.lookup(db);\n+                let krate = loc.container.krate;\n+                let item_tree = loc.id.item_tree(db);\n+                let union_ = &item_tree[loc.id.value];\n+                (union_.fields.clone(), item_tree, krate)\n+            }\n+        };\n+\n+        let fields = match fields {\n+            Fields::Record(fields) | Fields::Tuple(fields) => fields,\n+            Fields::Unit => return Arc::new(res),\n+        };\n+\n+        let cfg_options = &crate_graph[krate].cfg_options;\n+\n+        let mut idx = 0;\n+        for field in fields {\n+            let attrs = item_tree.attrs(db, krate, field.into());\n+            if attrs.is_cfg_enabled(cfg_options) {\n+                res.insert(Idx::from_raw(RawIdx::from(idx)), attrs);\n+                idx += 1;\n+            }\n+        }\n+\n+        Arc::new(res)\n+    }\n+\n+    pub fn by_key(&self, key: &'static str) -> AttrQuery<'_> {\n+        AttrQuery { attrs: self, key }\n+    }\n+}\n+\n+impl Attrs {\n+    pub fn cfg(&self) -> Option<CfgExpr> {\n+        let mut cfgs = self.by_key(\"cfg\").tt_values().map(CfgExpr::parse);\n+        let first = cfgs.next()?;\n+        match cfgs.next() {\n+            Some(second) => {\n+                let cfgs = [first, second].into_iter().chain(cfgs);\n+                Some(CfgExpr::All(cfgs.collect()))\n+            }\n+            None => Some(first),\n+        }\n+    }\n+    pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> bool {\n+        match self.cfg() {\n+            None => true,\n+            Some(cfg) => cfg_options.check(&cfg) != Some(false),\n+        }\n+    }\n+\n+    pub fn lang(&self) -> Option<&SmolStr> {\n+        self.by_key(\"lang\").string_value()\n+    }\n+\n+    pub fn docs(&self) -> Option<Documentation> {\n+        let docs = self.by_key(\"doc\").attrs().filter_map(|attr| attr.string_value());\n+        let indent = doc_indent(self);\n+        let mut buf = String::new();\n+        for doc in docs {\n+            // str::lines doesn't yield anything for the empty string\n+            if !doc.is_empty() {\n+                buf.extend(Itertools::intersperse(\n+                    doc.lines().map(|line| {\n+                        line.char_indices()\n+                            .nth(indent)\n+                            .map_or(line, |(offset, _)| &line[offset..])\n+                            .trim_end()\n+                    }),\n+                    \"\\n\",\n+                ));\n+            }\n+            buf.push('\\n');\n+        }\n+        buf.pop();\n+        if buf.is_empty() {\n+            None\n+        } else {\n+            Some(Documentation(buf))\n+        }\n+    }\n+\n+    pub fn has_doc_hidden(&self) -> bool {\n+        self.by_key(\"doc\").tt_values().any(|tt| {\n+            tt.delimiter_kind() == Some(DelimiterKind::Parenthesis) &&\n+                matches!(&*tt.token_trees, [tt::TokenTree::Leaf(tt::Leaf::Ident(ident))] if ident.text == \"hidden\")\n+        })\n+    }\n+\n+    pub fn is_proc_macro(&self) -> bool {\n+        self.by_key(\"proc_macro\").exists()\n+    }\n+\n+    pub fn is_proc_macro_attribute(&self) -> bool {\n+        self.by_key(\"proc_macro_attribute\").exists()\n+    }\n+\n+    pub fn is_proc_macro_derive(&self) -> bool {\n+        self.by_key(\"proc_macro_derive\").exists()\n+    }\n+}\n+\n+impl AttrsWithOwner {\n+    pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Self {\n+        // FIXME: this should use `Trace` to avoid duplication in `source_map` below\n+        let raw_attrs = match def {\n+            AttrDefId::ModuleId(module) => {\n+                let def_map = module.def_map(db);\n+                let mod_data = &def_map[module.local_id];\n+\n+                match mod_data.origin {\n+                    ModuleOrigin::File { definition, declaration_tree_id, .. } => {\n+                        let decl_attrs = declaration_tree_id\n+                            .item_tree(db)\n+                            .raw_attrs(AttrOwner::ModItem(declaration_tree_id.value.into()))\n+                            .clone();\n+                        let tree = db.file_item_tree(definition.into());\n+                        let def_attrs = tree.raw_attrs(AttrOwner::TopLevel).clone();\n+                        decl_attrs.merge(def_attrs)\n+                    }\n+                    ModuleOrigin::CrateRoot { definition } => {\n+                        let tree = db.file_item_tree(definition.into());\n+                        tree.raw_attrs(AttrOwner::TopLevel).clone()\n+                    }\n+                    ModuleOrigin::Inline { definition_tree_id, .. } => definition_tree_id\n+                        .item_tree(db)\n+                        .raw_attrs(AttrOwner::ModItem(definition_tree_id.value.into()))\n+                        .clone(),\n+                    ModuleOrigin::BlockExpr { block } => RawAttrs::from_attrs_owner(\n+                        db,\n+                        InFile::new(block.file_id, block.to_node(db.upcast()))\n+                            .as_ref()\n+                            .map(|it| it as &dyn ast::HasAttrs),\n+                    ),\n+                }\n+            }\n+            AttrDefId::FieldId(it) => {\n+                return Self { attrs: db.fields_attrs(it.parent)[it.local_id].clone(), owner: def };\n+            }\n+            AttrDefId::EnumVariantId(it) => {\n+                return Self {\n+                    attrs: db.variants_attrs(it.parent)[it.local_id].clone(),\n+                    owner: def,\n+                };\n+            }\n+            AttrDefId::AdtId(it) => match it {\n+                AdtId::StructId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+                AdtId::EnumId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+                AdtId::UnionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            },\n+            AttrDefId::TraitId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::MacroId(it) => match it {\n+                MacroId::Macro2Id(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+                MacroId::MacroRulesId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+                MacroId::ProcMacroId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            },\n+            AttrDefId::ImplId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::ConstId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::StaticId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::FunctionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::TypeAliasId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::GenericParamId(it) => match it {\n+                GenericParamId::ConstParamId(it) => {\n+                    let src = it.parent().child_source(db);\n+                    RawAttrs::from_attrs_owner(\n+                        db,\n+                        src.with_value(src.value[it.local_id()].as_ref().either(\n+                            |it| match it {\n+                                ast::TypeOrConstParam::Type(it) => it as _,\n+                                ast::TypeOrConstParam::Const(it) => it as _,\n+                            },\n+                            |it| it as _,\n+                        )),\n+                    )\n+                }\n+                GenericParamId::TypeParamId(it) => {\n+                    let src = it.parent().child_source(db);\n+                    RawAttrs::from_attrs_owner(\n+                        db,\n+                        src.with_value(src.value[it.local_id()].as_ref().either(\n+                            |it| match it {\n+                                ast::TypeOrConstParam::Type(it) => it as _,\n+                                ast::TypeOrConstParam::Const(it) => it as _,\n+                            },\n+                            |it| it as _,\n+                        )),\n+                    )\n+                }\n+                GenericParamId::LifetimeParamId(it) => {\n+                    let src = it.parent.child_source(db);\n+                    RawAttrs::from_attrs_owner(db, src.with_value(&src.value[it.local_id]))\n+                }\n+            },\n+            AttrDefId::ExternBlockId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+        };\n+\n+        let attrs = raw_attrs.filter(db, def.krate(db));\n+        Self { attrs, owner: def }\n+    }\n+\n+    pub fn source_map(&self, db: &dyn DefDatabase) -> AttrSourceMap {\n+        let owner = match self.owner {\n+            AttrDefId::ModuleId(module) => {\n+                // Modules can have 2 attribute owners (the `mod x;` item, and the module file itself).\n+\n+                let def_map = module.def_map(db);\n+                let mod_data = &def_map[module.local_id];\n+                match mod_data.declaration_source(db) {\n+                    Some(it) => {\n+                        let mut map = AttrSourceMap::new(InFile::new(it.file_id, &it.value));\n+                        if let InFile { file_id, value: ModuleSource::SourceFile(file) } =\n+                            mod_data.definition_source(db)\n+                        {\n+                            map.append_module_inline_attrs(AttrSourceMap::new(InFile::new(\n+                                file_id, &file,\n+                            )));\n+                        }\n+                        return map;\n+                    }\n+                    None => {\n+                        let InFile { file_id, value } = mod_data.definition_source(db);\n+                        let attrs_owner = match &value {\n+                            ModuleSource::SourceFile(file) => file as &dyn ast::HasAttrs,\n+                            ModuleSource::Module(module) => module as &dyn ast::HasAttrs,\n+                            ModuleSource::BlockExpr(block) => block as &dyn ast::HasAttrs,\n+                        };\n+                        return AttrSourceMap::new(InFile::new(file_id, attrs_owner));\n+                    }\n+                }\n+            }\n+            AttrDefId::FieldId(id) => {\n+                let map = db.fields_attrs_source_map(id.parent);\n+                let file_id = id.parent.file_id(db);\n+                let root = db.parse_or_expand(file_id).unwrap();\n+                let owner = match &map[id.local_id] {\n+                    Either::Left(it) => ast::AnyHasAttrs::new(it.to_node(&root)),\n+                    Either::Right(it) => ast::AnyHasAttrs::new(it.to_node(&root)),\n+                };\n+                InFile::new(file_id, owner)\n+            }\n+            AttrDefId::AdtId(adt) => match adt {\n+                AdtId::StructId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+                AdtId::UnionId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+                AdtId::EnumId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            },\n+            AttrDefId::FunctionId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::EnumVariantId(id) => {\n+                let map = db.variants_attrs_source_map(id.parent);\n+                let file_id = id.parent.lookup(db).id.file_id();\n+                let root = db.parse_or_expand(file_id).unwrap();\n+                InFile::new(file_id, ast::AnyHasAttrs::new(map[id.local_id].to_node(&root)))\n+            }\n+            AttrDefId::StaticId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::ConstId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::TraitId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::TypeAliasId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::MacroId(id) => match id {\n+                MacroId::Macro2Id(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+                MacroId::MacroRulesId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+                MacroId::ProcMacroId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            },\n+            AttrDefId::ImplId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::GenericParamId(id) => match id {\n+                GenericParamId::ConstParamId(id) => {\n+                    id.parent().child_source(db).map(|source| match &source[id.local_id()] {\n+                        Either::Left(ast::TypeOrConstParam::Type(id)) => {\n+                            ast::AnyHasAttrs::new(id.clone())\n+                        }\n+                        Either::Left(ast::TypeOrConstParam::Const(id)) => {\n+                            ast::AnyHasAttrs::new(id.clone())\n+                        }\n+                        Either::Right(id) => ast::AnyHasAttrs::new(id.clone()),\n+                    })\n+                }\n+                GenericParamId::TypeParamId(id) => {\n+                    id.parent().child_source(db).map(|source| match &source[id.local_id()] {\n+                        Either::Left(ast::TypeOrConstParam::Type(id)) => {\n+                            ast::AnyHasAttrs::new(id.clone())\n+                        }\n+                        Either::Left(ast::TypeOrConstParam::Const(id)) => {\n+                            ast::AnyHasAttrs::new(id.clone())\n+                        }\n+                        Either::Right(id) => ast::AnyHasAttrs::new(id.clone()),\n+                    })\n+                }\n+                GenericParamId::LifetimeParamId(id) => id\n+                    .parent\n+                    .child_source(db)\n+                    .map(|source| ast::AnyHasAttrs::new(source[id.local_id].clone())),\n+            },\n+            AttrDefId::ExternBlockId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+        };\n+\n+        AttrSourceMap::new(owner.as_ref().map(|node| node as &dyn HasAttrs))\n+    }\n+\n+    pub fn docs_with_rangemap(\n+        &self,\n+        db: &dyn DefDatabase,\n+    ) -> Option<(Documentation, DocsRangeMap)> {\n+        let docs =\n+            self.by_key(\"doc\").attrs().filter_map(|attr| attr.string_value().map(|s| (s, attr.id)));\n+        let indent = doc_indent(self);\n+        let mut buf = String::new();\n+        let mut mapping = Vec::new();\n+        for (doc, idx) in docs {\n+            if !doc.is_empty() {\n+                let mut base_offset = 0;\n+                for raw_line in doc.split('\\n') {\n+                    let line = raw_line.trim_end();\n+                    let line_len = line.len();\n+                    let (offset, line) = match line.char_indices().nth(indent) {\n+                        Some((offset, _)) => (offset, &line[offset..]),\n+                        None => (0, line),\n+                    };\n+                    let buf_offset = buf.len();\n+                    buf.push_str(line);\n+                    mapping.push((\n+                        TextRange::new(buf_offset.try_into().ok()?, buf.len().try_into().ok()?),\n+                        idx,\n+                        TextRange::at(\n+                            (base_offset + offset).try_into().ok()?,\n+                            line_len.try_into().ok()?,\n+                        ),\n+                    ));\n+                    buf.push('\\n');\n+                    base_offset += raw_line.len() + 1;\n+                }\n+            } else {\n+                buf.push('\\n');\n+            }\n+        }\n+        buf.pop();\n+        if buf.is_empty() {\n+            None\n+        } else {\n+            Some((Documentation(buf), DocsRangeMap { mapping, source_map: self.source_map(db) }))\n+        }\n+    }\n+}\n+\n+fn doc_indent(attrs: &Attrs) -> usize {\n+    attrs\n+        .by_key(\"doc\")\n+        .attrs()\n+        .filter_map(|attr| attr.string_value())\n+        .flat_map(|s| s.lines())\n+        .filter(|line| !line.chars().all(|c| c.is_whitespace()))\n+        .map(|line| line.chars().take_while(|c| c.is_whitespace()).count())\n+        .min()\n+        .unwrap_or(0)\n+}\n+\n+fn inner_attributes(\n+    syntax: &SyntaxNode,\n+) -> Option<impl Iterator<Item = Either<ast::Attr, ast::Comment>>> {\n+    let node = match_ast! {\n+        match syntax {\n+            ast::SourceFile(_) => syntax.clone(),\n+            ast::ExternBlock(it) => it.extern_item_list()?.syntax().clone(),\n+            ast::Fn(it) => it.body()?.stmt_list()?.syntax().clone(),\n+            ast::Impl(it) => it.assoc_item_list()?.syntax().clone(),\n+            ast::Module(it) => it.item_list()?.syntax().clone(),\n+            ast::BlockExpr(it) => {\n+                use syntax::SyntaxKind::{BLOCK_EXPR , EXPR_STMT};\n+                // Block expressions accept outer and inner attributes, but only when they are the outer\n+                // expression of an expression statement or the final expression of another block expression.\n+                let may_carry_attributes = matches!(\n+                    it.syntax().parent().map(|it| it.kind()),\n+                     Some(BLOCK_EXPR | EXPR_STMT)\n+                );\n+                if !may_carry_attributes {\n+                    return None\n+                }\n+                syntax.clone()\n+            },\n+            _ => return None,\n+        }\n+    };\n+\n+    let attrs = ast::AttrDocCommentIter::from_syntax_node(&node).filter(|el| match el {\n+        Either::Left(attr) => attr.kind().is_inner(),\n+        Either::Right(comment) => comment.is_inner(),\n+    });\n+    Some(attrs)\n+}\n+\n+#[derive(Debug)]\n+pub struct AttrSourceMap {\n+    source: Vec<Either<ast::Attr, ast::Comment>>,\n+    file_id: HirFileId,\n+    /// If this map is for a module, this will be the [`HirFileId`] of the module's definition site,\n+    /// while `file_id` will be the one of the module declaration site.\n+    /// The usize is the index into `source` from which point on the entries reside in the def site\n+    /// file.\n+    mod_def_site_file_id: Option<(HirFileId, usize)>,\n+}\n+\n+impl AttrSourceMap {\n+    fn new(owner: InFile<&dyn ast::HasAttrs>) -> Self {\n+        Self {\n+            source: collect_attrs(owner.value).map(|(_, it)| it).collect(),\n+            file_id: owner.file_id,\n+            mod_def_site_file_id: None,\n+        }\n+    }\n+\n+    /// Append a second source map to this one, this is required for modules, whose outline and inline\n+    /// attributes can reside in different files\n+    fn append_module_inline_attrs(&mut self, other: Self) {\n+        assert!(self.mod_def_site_file_id.is_none() && other.mod_def_site_file_id.is_none());\n+        let len = self.source.len();\n+        self.source.extend(other.source);\n+        if other.file_id != self.file_id {\n+            self.mod_def_site_file_id = Some((other.file_id, len));\n+        }\n+    }\n+\n+    /// Maps the lowered `Attr` back to its original syntax node.\n+    ///\n+    /// `attr` must come from the `owner` used for AttrSourceMap\n+    ///\n+    /// Note that the returned syntax node might be a `#[cfg_attr]`, or a doc comment, instead of\n+    /// the attribute represented by `Attr`.\n+    pub fn source_of(&self, attr: &Attr) -> InFile<&Either<ast::Attr, ast::Comment>> {\n+        self.source_of_id(attr.id)\n+    }\n+\n+    fn source_of_id(&self, id: AttrId) -> InFile<&Either<ast::Attr, ast::Comment>> {\n+        let ast_idx = id.ast_index as usize;\n+        let file_id = match self.mod_def_site_file_id {\n+            Some((file_id, def_site_cut)) if def_site_cut <= ast_idx => file_id,\n+            _ => self.file_id,\n+        };\n+\n+        self.source\n+            .get(ast_idx)\n+            .map(|it| InFile::new(file_id, it))\n+            .unwrap_or_else(|| panic!(\"cannot find attr at index {:?}\", id))\n+    }\n+}\n+\n+/// A struct to map text ranges from [`Documentation`] back to TextRanges in the syntax tree.\n+#[derive(Debug)]\n+pub struct DocsRangeMap {\n+    source_map: AttrSourceMap,\n+    // (docstring-line-range, attr_index, attr-string-range)\n+    // a mapping from the text range of a line of the [`Documentation`] to the attribute index and\n+    // the original (untrimmed) syntax doc line\n+    mapping: Vec<(TextRange, AttrId, TextRange)>,\n+}\n+\n+impl DocsRangeMap {\n+    /// Maps a [`TextRange`] relative to the documentation string back to its AST range\n+    pub fn map(&self, range: TextRange) -> Option<InFile<TextRange>> {\n+        let found = self.mapping.binary_search_by(|(probe, ..)| probe.ordering(range)).ok()?;\n+        let (line_docs_range, idx, original_line_src_range) = self.mapping[found];\n+        if !line_docs_range.contains_range(range) {\n+            return None;\n+        }\n+\n+        let relative_range = range - line_docs_range.start();\n+\n+        let InFile { file_id, value: source } = self.source_map.source_of_id(idx);\n+        match source {\n+            Either::Left(attr) => {\n+                let string = get_doc_string_in_attr(attr)?;\n+                let text_range = string.open_quote_text_range()?;\n+                let range = TextRange::at(\n+                    text_range.end() + original_line_src_range.start() + relative_range.start(),\n+                    string.syntax().text_range().len().min(range.len()),\n+                );\n+                Some(InFile { file_id, value: range })\n+            }\n+            Either::Right(comment) => {\n+                let text_range = comment.syntax().text_range();\n+                let range = TextRange::at(\n+                    text_range.start()\n+                        + TextSize::try_from(comment.prefix().len()).ok()?\n+                        + original_line_src_range.start()\n+                        + relative_range.start(),\n+                    text_range.len().min(range.len()),\n+                );\n+                Some(InFile { file_id, value: range })\n+            }\n+        }\n+    }\n+}\n+\n+fn get_doc_string_in_attr(it: &ast::Attr) -> Option<ast::String> {\n+    match it.expr() {\n+        // #[doc = lit]\n+        Some(ast::Expr::Literal(lit)) => match lit.kind() {\n+            ast::LiteralKind::String(it) => Some(it),\n+            _ => None,\n+        },\n+        // #[cfg_attr(..., doc = \"\", ...)]\n+        None => {\n+            // FIXME: See highlight injection for what to do here\n+            None\n+        }\n+        _ => None,\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct AttrId {\n+    pub(crate) ast_index: u32,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Attr {\n+    pub(crate) id: AttrId,\n+    pub(crate) path: Interned<ModPath>,\n+    pub(crate) input: Option<Interned<AttrInput>>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum AttrInput {\n+    /// `#[attr = \"string\"]`\n+    Literal(SmolStr),\n+    /// `#[attr(subtree)]`\n+    TokenTree(tt::Subtree, mbe::TokenMap),\n+}\n+\n+impl fmt::Display for AttrInput {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            AttrInput::Literal(lit) => write!(f, \" = \\\"{}\\\"\", lit.escape_debug()),\n+            AttrInput::TokenTree(subtree, _) => subtree.fmt(f),\n+        }\n+    }\n+}\n+\n+impl Attr {\n+    fn from_src(\n+        db: &dyn DefDatabase,\n+        ast: ast::Meta,\n+        hygiene: &Hygiene,\n+        id: AttrId,\n+    ) -> Option<Attr> {\n+        let path = Interned::new(ModPath::from_src(db.upcast(), ast.path()?, hygiene)?);\n+        let input = if let Some(ast::Expr::Literal(lit)) = ast.expr() {\n+            let value = match lit.kind() {\n+                ast::LiteralKind::String(string) => string.value()?.into(),\n+                _ => lit.syntax().first_token()?.text().trim_matches('\"').into(),\n+            };\n+            Some(Interned::new(AttrInput::Literal(value)))\n+        } else if let Some(tt) = ast.token_tree() {\n+            let (tree, map) = syntax_node_to_token_tree(tt.syntax());\n+            Some(Interned::new(AttrInput::TokenTree(tree, map)))\n+        } else {\n+            None\n+        };\n+        Some(Attr { id, path, input })\n+    }\n+\n+    fn from_tt(\n+        db: &dyn DefDatabase,\n+        tt: &tt::Subtree,\n+        hygiene: &Hygiene,\n+        id: AttrId,\n+    ) -> Option<Attr> {\n+        let (parse, _) = mbe::token_tree_to_syntax_node(tt, mbe::TopEntryPoint::MetaItem);\n+        let ast = ast::Meta::cast(parse.syntax_node())?;\n+\n+        Self::from_src(db, ast, hygiene, id)\n+    }\n+\n+    pub fn path(&self) -> &ModPath {\n+        &self.path\n+    }\n+}\n+\n+impl Attr {\n+    /// #[path = \"string\"]\n+    pub fn string_value(&self) -> Option<&SmolStr> {\n+        match self.input.as_deref()? {\n+            AttrInput::Literal(it) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n+    /// #[path(ident)]\n+    pub fn single_ident_value(&self) -> Option<&tt::Ident> {\n+        match self.input.as_deref()? {\n+            AttrInput::TokenTree(subtree, _) => match &*subtree.token_trees {\n+                [tt::TokenTree::Leaf(tt::Leaf::Ident(ident))] => Some(ident),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    /// #[path TokenTree]\n+    pub fn token_tree_value(&self) -> Option<&Subtree> {\n+        match self.input.as_deref()? {\n+            AttrInput::TokenTree(subtree, _) => Some(subtree),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Parses this attribute as a token tree consisting of comma separated paths.\n+    pub fn parse_path_comma_token_tree(&self) -> Option<impl Iterator<Item = ModPath> + '_> {\n+        let args = self.token_tree_value()?;\n+\n+        if args.delimiter_kind() != Some(DelimiterKind::Parenthesis) {\n+            return None;\n+        }\n+        let paths = args\n+            .token_trees\n+            .split(|tt| matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Punct(Punct { char: ',', .. }))))\n+            .filter_map(|tts| {\n+                if tts.is_empty() {\n+                    return None;\n+                }\n+                let segments = tts.iter().filter_map(|tt| match tt {\n+                    tt::TokenTree::Leaf(tt::Leaf::Ident(id)) => Some(id.as_name()),\n+                    _ => None,\n+                });\n+                Some(ModPath::from_segments(PathKind::Plain, segments))\n+            });\n+\n+        Some(paths)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+pub struct AttrQuery<'attr> {\n+    attrs: &'attr Attrs,\n+    key: &'static str,\n+}\n+\n+impl<'attr> AttrQuery<'attr> {\n+    pub fn tt_values(self) -> impl Iterator<Item = &'attr Subtree> {\n+        self.attrs().filter_map(|attr| attr.token_tree_value())\n+    }\n+\n+    pub fn string_value(self) -> Option<&'attr SmolStr> {\n+        self.attrs().find_map(|attr| attr.string_value())\n+    }\n+\n+    pub fn exists(self) -> bool {\n+        self.attrs().next().is_some()\n+    }\n+\n+    pub fn attrs(self) -> impl Iterator<Item = &'attr Attr> + Clone {\n+        let key = self.key;\n+        self.attrs\n+            .iter()\n+            .filter(move |attr| attr.path.as_ident().map_or(false, |s| s.to_smol_str() == key))\n+    }\n+\n+    /// Find string value for a specific key inside token tree\n+    ///\n+    /// ```ignore\n+    /// #[doc(html_root_url = \"url\")]\n+    ///       ^^^^^^^^^^^^^ key\n+    /// ```\n+    pub fn find_string_value_in_tt(self, key: &'attr str) -> Option<&SmolStr> {\n+        self.tt_values().find_map(|tt| {\n+            let name = tt.token_trees.iter()\n+                .skip_while(|tt| !matches!(tt, tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident { text, ..} )) if text == key))\n+                .nth(2);\n+\n+            match name {\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Literal(tt::Literal{ref text, ..}))) => Some(text),\n+                _ => None\n+            }\n+        })\n+    }\n+}\n+\n+fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase) -> RawAttrs {\n+    let tree = id.item_tree(db);\n+    let mod_item = N::id_to_mod_item(id.value);\n+    tree.raw_attrs(mod_item.into()).clone()\n+}\n+\n+fn collect_attrs(\n+    owner: &dyn ast::HasAttrs,\n+) -> impl Iterator<Item = (AttrId, Either<ast::Attr, ast::Comment>)> {\n+    let inner_attrs = inner_attributes(owner.syntax()).into_iter().flatten();\n+    let outer_attrs =\n+        ast::AttrDocCommentIter::from_syntax_node(owner.syntax()).filter(|el| match el {\n+            Either::Left(attr) => attr.kind().is_outer(),\n+            Either::Right(comment) => comment.is_outer(),\n+        });\n+    outer_attrs\n+        .chain(inner_attrs)\n+        .enumerate()\n+        .map(|(id, attr)| (AttrId { ast_index: id as u32 }, attr))\n+}\n+\n+pub(crate) fn variants_attrs_source_map(\n+    db: &dyn DefDatabase,\n+    def: EnumId,\n+) -> Arc<ArenaMap<LocalEnumVariantId, AstPtr<ast::Variant>>> {\n+    let mut res = ArenaMap::default();\n+    let child_source = def.child_source(db);\n+\n+    for (idx, variant) in child_source.value.iter() {\n+        res.insert(idx, AstPtr::new(variant));\n+    }\n+\n+    Arc::new(res)\n+}\n+\n+pub(crate) fn fields_attrs_source_map(\n+    db: &dyn DefDatabase,\n+    def: VariantId,\n+) -> Arc<ArenaMap<LocalFieldId, Either<AstPtr<ast::TupleField>, AstPtr<ast::RecordField>>>> {\n+    let mut res = ArenaMap::default();\n+    let child_source = def.child_source(db);\n+\n+    for (idx, variant) in child_source.value.iter() {\n+        res.insert(\n+            idx,\n+            variant\n+                .as_ref()\n+                .either(|l| Either::Left(AstPtr::new(l)), |r| Either::Right(AstPtr::new(r))),\n+        );\n+    }\n+\n+    Arc::new(res)\n+}"}, {"sha": "080a307b1f8a4540ef1dd3a6a217a0e0f4c3b017", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body.rs", "status": "added", "additions": 471, "deletions": 0, "changes": 471, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,471 @@\n+//! Defines `Body`: a lowered representation of bodies of functions, statics and\n+//! consts.\n+mod lower;\n+#[cfg(test)]\n+mod tests;\n+pub mod scope;\n+\n+use std::{ops::Index, sync::Arc};\n+\n+use base_db::CrateId;\n+use cfg::{CfgExpr, CfgOptions};\n+use drop_bomb::DropBomb;\n+use either::Either;\n+use hir_expand::{hygiene::Hygiene, ExpandError, ExpandResult, HirFileId, InFile, MacroCallId};\n+use la_arena::{Arena, ArenaMap};\n+use limit::Limit;\n+use profile::Count;\n+use rustc_hash::FxHashMap;\n+use syntax::{ast, AstPtr, SyntaxNodePtr};\n+\n+use crate::{\n+    attr::{Attrs, RawAttrs},\n+    db::DefDatabase,\n+    expr::{dummy_expr_id, Expr, ExprId, Label, LabelId, Pat, PatId},\n+    item_scope::BuiltinShadowMode,\n+    macro_id_to_def_id,\n+    nameres::DefMap,\n+    path::{ModPath, Path},\n+    src::HasSource,\n+    AsMacroCall, BlockId, DefWithBodyId, HasModule, LocalModuleId, Lookup, MacroId, ModuleId,\n+    UnresolvedMacro,\n+};\n+\n+pub use lower::LowerCtx;\n+\n+/// A subset of Expander that only deals with cfg attributes. We only need it to\n+/// avoid cyclic queries in crate def map during enum processing.\n+#[derive(Debug)]\n+pub(crate) struct CfgExpander {\n+    cfg_options: CfgOptions,\n+    hygiene: Hygiene,\n+    krate: CrateId,\n+}\n+\n+#[derive(Debug)]\n+pub struct Expander {\n+    cfg_expander: CfgExpander,\n+    def_map: Arc<DefMap>,\n+    current_file_id: HirFileId,\n+    module: LocalModuleId,\n+    recursion_limit: usize,\n+}\n+\n+impl CfgExpander {\n+    pub(crate) fn new(\n+        db: &dyn DefDatabase,\n+        current_file_id: HirFileId,\n+        krate: CrateId,\n+    ) -> CfgExpander {\n+        let hygiene = Hygiene::new(db.upcast(), current_file_id);\n+        let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n+        CfgExpander { cfg_options, hygiene, krate }\n+    }\n+\n+    pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> Attrs {\n+        RawAttrs::new(db, owner, &self.hygiene).filter(db, self.krate)\n+    }\n+\n+    pub(crate) fn is_cfg_enabled(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> bool {\n+        let attrs = self.parse_attrs(db, owner);\n+        attrs.is_cfg_enabled(&self.cfg_options)\n+    }\n+}\n+\n+impl Expander {\n+    pub fn new(db: &dyn DefDatabase, current_file_id: HirFileId, module: ModuleId) -> Expander {\n+        let cfg_expander = CfgExpander::new(db, current_file_id, module.krate);\n+        let def_map = module.def_map(db);\n+        Expander {\n+            cfg_expander,\n+            def_map,\n+            current_file_id,\n+            module: module.local_id,\n+            recursion_limit: 0,\n+        }\n+    }\n+\n+    pub fn enter_expand<T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        macro_call: ast::MacroCall,\n+    ) -> Result<ExpandResult<Option<(Mark, T)>>, UnresolvedMacro> {\n+        if self.recursion_limit(db).check(self.recursion_limit + 1).is_err() {\n+            cov_mark::hit!(your_stack_belongs_to_me);\n+            return Ok(ExpandResult::only_err(ExpandError::Other(\n+                \"reached recursion limit during macro expansion\".into(),\n+            )));\n+        }\n+\n+        let macro_call = InFile::new(self.current_file_id, &macro_call);\n+\n+        let resolver =\n+            |path| self.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n+\n+        let mut err = None;\n+        let call_id =\n+            macro_call.as_call_id_with_errors(db, self.def_map.krate(), resolver, &mut |e| {\n+                err.get_or_insert(e);\n+            })?;\n+        let call_id = match call_id {\n+            Ok(it) => it,\n+            Err(_) => {\n+                return Ok(ExpandResult { value: None, err });\n+            }\n+        };\n+\n+        Ok(self.enter_expand_inner(db, call_id, err))\n+    }\n+\n+    pub fn enter_expand_id<T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        call_id: MacroCallId,\n+    ) -> ExpandResult<Option<(Mark, T)>> {\n+        self.enter_expand_inner(db, call_id, None)\n+    }\n+\n+    fn enter_expand_inner<T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        call_id: MacroCallId,\n+        mut err: Option<ExpandError>,\n+    ) -> ExpandResult<Option<(Mark, T)>> {\n+        if err.is_none() {\n+            err = db.macro_expand_error(call_id);\n+        }\n+\n+        let file_id = call_id.as_file();\n+\n+        let raw_node = match db.parse_or_expand(file_id) {\n+            Some(it) => it,\n+            None => {\n+                // Only `None` if the macro expansion produced no usable AST.\n+                if err.is_none() {\n+                    tracing::warn!(\"no error despite `parse_or_expand` failing\");\n+                }\n+\n+                return ExpandResult::only_err(err.unwrap_or_else(|| {\n+                    ExpandError::Other(\"failed to parse macro invocation\".into())\n+                }));\n+            }\n+        };\n+\n+        let node = match T::cast(raw_node) {\n+            Some(it) => it,\n+            None => {\n+                // This can happen without being an error, so only forward previous errors.\n+                return ExpandResult { value: None, err };\n+            }\n+        };\n+\n+        tracing::debug!(\"macro expansion {:#?}\", node.syntax());\n+\n+        self.recursion_limit += 1;\n+        let mark =\n+            Mark { file_id: self.current_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n+        self.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n+        self.current_file_id = file_id;\n+\n+        ExpandResult { value: Some((mark, node)), err }\n+    }\n+\n+    pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n+        self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n+        self.current_file_id = mark.file_id;\n+        self.recursion_limit -= 1;\n+        mark.bomb.defuse();\n+    }\n+\n+    pub(crate) fn to_source<T>(&self, value: T) -> InFile<T> {\n+        InFile { file_id: self.current_file_id, value }\n+    }\n+\n+    pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> Attrs {\n+        self.cfg_expander.parse_attrs(db, owner)\n+    }\n+\n+    pub(crate) fn cfg_options(&self) -> &CfgOptions {\n+        &self.cfg_expander.cfg_options\n+    }\n+\n+    pub fn current_file_id(&self) -> HirFileId {\n+        self.current_file_id\n+    }\n+\n+    fn parse_path(&mut self, db: &dyn DefDatabase, path: ast::Path) -> Option<Path> {\n+        let ctx = LowerCtx::with_hygiene(db, &self.cfg_expander.hygiene);\n+        Path::from_src(path, &ctx)\n+    }\n+\n+    fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroId> {\n+        self.def_map.resolve_path(db, self.module, path, BuiltinShadowMode::Other).0.take_macros()\n+    }\n+\n+    fn recursion_limit(&self, db: &dyn DefDatabase) -> Limit {\n+        let limit = db.crate_limits(self.cfg_expander.krate).recursion_limit as _;\n+\n+        #[cfg(not(test))]\n+        return Limit::new(limit);\n+\n+        // Without this, `body::tests::your_stack_belongs_to_me` stack-overflows in debug\n+        #[cfg(test)]\n+        return Limit::new(std::cmp::min(32, limit));\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Mark {\n+    file_id: HirFileId,\n+    bomb: DropBomb,\n+}\n+\n+/// The body of an item (function, const etc.).\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct Body {\n+    pub exprs: Arena<Expr>,\n+    pub pats: Arena<Pat>,\n+    pub or_pats: FxHashMap<PatId, Arc<[PatId]>>,\n+    pub labels: Arena<Label>,\n+    /// The patterns for the function's parameters. While the parameter types are\n+    /// part of the function signature, the patterns are not (they don't change\n+    /// the external type of the function).\n+    ///\n+    /// If this `Body` is for the body of a constant, this will just be\n+    /// empty.\n+    pub params: Vec<PatId>,\n+    /// The `ExprId` of the actual body expression.\n+    pub body_expr: ExprId,\n+    /// Block expressions in this body that may contain inner items.\n+    block_scopes: Vec<BlockId>,\n+    _c: Count<Self>,\n+}\n+\n+pub type ExprPtr = AstPtr<ast::Expr>;\n+pub type ExprSource = InFile<ExprPtr>;\n+\n+pub type PatPtr = Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>;\n+pub type PatSource = InFile<PatPtr>;\n+\n+pub type LabelPtr = AstPtr<ast::Label>;\n+pub type LabelSource = InFile<LabelPtr>;\n+/// An item body together with the mapping from syntax nodes to HIR expression\n+/// IDs. This is needed to go from e.g. a position in a file to the HIR\n+/// expression containing it; but for type inference etc., we want to operate on\n+/// a structure that is agnostic to the actual positions of expressions in the\n+/// file, so that we don't recompute types whenever some whitespace is typed.\n+///\n+/// One complication here is that, due to macro expansion, a single `Body` might\n+/// be spread across several files. So, for each ExprId and PatId, we record\n+/// both the HirFileId and the position inside the file. However, we only store\n+/// AST -> ExprId mapping for non-macro files, as it is not clear how to handle\n+/// this properly for macros.\n+#[derive(Default, Debug, Eq, PartialEq)]\n+pub struct BodySourceMap {\n+    expr_map: FxHashMap<ExprSource, ExprId>,\n+    expr_map_back: ArenaMap<ExprId, Result<ExprSource, SyntheticSyntax>>,\n+\n+    pat_map: FxHashMap<PatSource, PatId>,\n+    pat_map_back: ArenaMap<PatId, Result<PatSource, SyntheticSyntax>>,\n+\n+    label_map: FxHashMap<LabelSource, LabelId>,\n+    label_map_back: ArenaMap<LabelId, LabelSource>,\n+\n+    /// We don't create explicit nodes for record fields (`S { record_field: 92 }`).\n+    /// Instead, we use id of expression (`92`) to identify the field.\n+    field_map: FxHashMap<InFile<AstPtr<ast::RecordExprField>>, ExprId>,\n+    field_map_back: FxHashMap<ExprId, InFile<AstPtr<ast::RecordExprField>>>,\n+\n+    expansions: FxHashMap<InFile<AstPtr<ast::MacroCall>>, HirFileId>,\n+\n+    /// Diagnostics accumulated during body lowering. These contain `AstPtr`s and so are stored in\n+    /// the source map (since they're just as volatile).\n+    diagnostics: Vec<BodyDiagnostic>,\n+}\n+\n+#[derive(Default, Debug, Eq, PartialEq, Clone, Copy)]\n+pub struct SyntheticSyntax;\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub enum BodyDiagnostic {\n+    InactiveCode { node: InFile<SyntaxNodePtr>, cfg: CfgExpr, opts: CfgOptions },\n+    MacroError { node: InFile<AstPtr<ast::MacroCall>>, message: String },\n+    UnresolvedProcMacro { node: InFile<AstPtr<ast::MacroCall>>, krate: CrateId },\n+    UnresolvedMacroCall { node: InFile<AstPtr<ast::MacroCall>>, path: ModPath },\n+}\n+\n+impl Body {\n+    pub(crate) fn body_with_source_map_query(\n+        db: &dyn DefDatabase,\n+        def: DefWithBodyId,\n+    ) -> (Arc<Body>, Arc<BodySourceMap>) {\n+        let _p = profile::span(\"body_with_source_map_query\");\n+        let mut params = None;\n+\n+        let (file_id, module, body) = match def {\n+            DefWithBodyId::FunctionId(f) => {\n+                let f = f.lookup(db);\n+                let src = f.source(db);\n+                params = src.value.param_list();\n+                (src.file_id, f.module(db), src.value.body().map(ast::Expr::from))\n+            }\n+            DefWithBodyId::ConstId(c) => {\n+                let c = c.lookup(db);\n+                let src = c.source(db);\n+                (src.file_id, c.module(db), src.value.body())\n+            }\n+            DefWithBodyId::StaticId(s) => {\n+                let s = s.lookup(db);\n+                let src = s.source(db);\n+                (src.file_id, s.module(db), src.value.body())\n+            }\n+        };\n+        let expander = Expander::new(db, file_id, module);\n+        let (mut body, source_map) = Body::new(db, expander, params, body);\n+        body.shrink_to_fit();\n+        (Arc::new(body), Arc::new(source_map))\n+    }\n+\n+    pub(crate) fn body_query(db: &dyn DefDatabase, def: DefWithBodyId) -> Arc<Body> {\n+        db.body_with_source_map(def).0\n+    }\n+\n+    /// Returns an iterator over all block expressions in this body that define inner items.\n+    pub fn blocks<'a>(\n+        &'a self,\n+        db: &'a dyn DefDatabase,\n+    ) -> impl Iterator<Item = (BlockId, Arc<DefMap>)> + '_ {\n+        self.block_scopes\n+            .iter()\n+            .map(move |&block| (block, db.block_def_map(block).expect(\"block ID without DefMap\")))\n+    }\n+\n+    pub fn pattern_representative(&self, pat: PatId) -> PatId {\n+        self.or_pats.get(&pat).and_then(|pats| pats.first().copied()).unwrap_or(pat)\n+    }\n+\n+    /// Retrieves all ident patterns this pattern shares the ident with.\n+    pub fn ident_patterns_for<'slf>(&'slf self, pat: &'slf PatId) -> &'slf [PatId] {\n+        match self.or_pats.get(pat) {\n+            Some(pats) => &**pats,\n+            None => std::slice::from_ref(pat),\n+        }\n+    }\n+\n+    fn new(\n+        db: &dyn DefDatabase,\n+        expander: Expander,\n+        params: Option<ast::ParamList>,\n+        body: Option<ast::Expr>,\n+    ) -> (Body, BodySourceMap) {\n+        lower::lower(db, expander, params, body)\n+    }\n+\n+    fn shrink_to_fit(&mut self) {\n+        let Self { _c: _, body_expr: _, block_scopes, or_pats, exprs, labels, params, pats } = self;\n+        block_scopes.shrink_to_fit();\n+        or_pats.shrink_to_fit();\n+        exprs.shrink_to_fit();\n+        labels.shrink_to_fit();\n+        params.shrink_to_fit();\n+        pats.shrink_to_fit();\n+    }\n+}\n+\n+impl Default for Body {\n+    fn default() -> Self {\n+        Self {\n+            body_expr: dummy_expr_id(),\n+            exprs: Default::default(),\n+            pats: Default::default(),\n+            or_pats: Default::default(),\n+            labels: Default::default(),\n+            params: Default::default(),\n+            block_scopes: Default::default(),\n+            _c: Default::default(),\n+        }\n+    }\n+}\n+\n+impl Index<ExprId> for Body {\n+    type Output = Expr;\n+\n+    fn index(&self, expr: ExprId) -> &Expr {\n+        &self.exprs[expr]\n+    }\n+}\n+\n+impl Index<PatId> for Body {\n+    type Output = Pat;\n+\n+    fn index(&self, pat: PatId) -> &Pat {\n+        &self.pats[pat]\n+    }\n+}\n+\n+impl Index<LabelId> for Body {\n+    type Output = Label;\n+\n+    fn index(&self, label: LabelId) -> &Label {\n+        &self.labels[label]\n+    }\n+}\n+\n+// FIXME: Change `node_` prefix to something more reasonable.\n+// Perhaps `expr_syntax` and `expr_id`?\n+impl BodySourceMap {\n+    pub fn expr_syntax(&self, expr: ExprId) -> Result<ExprSource, SyntheticSyntax> {\n+        self.expr_map_back[expr].clone()\n+    }\n+\n+    pub fn node_expr(&self, node: InFile<&ast::Expr>) -> Option<ExprId> {\n+        let src = node.map(AstPtr::new);\n+        self.expr_map.get(&src).cloned()\n+    }\n+\n+    pub fn node_macro_file(&self, node: InFile<&ast::MacroCall>) -> Option<HirFileId> {\n+        let src = node.map(AstPtr::new);\n+        self.expansions.get(&src).cloned()\n+    }\n+\n+    pub fn pat_syntax(&self, pat: PatId) -> Result<PatSource, SyntheticSyntax> {\n+        self.pat_map_back[pat].clone()\n+    }\n+\n+    pub fn node_pat(&self, node: InFile<&ast::Pat>) -> Option<PatId> {\n+        let src = node.map(|it| Either::Left(AstPtr::new(it)));\n+        self.pat_map.get(&src).cloned()\n+    }\n+\n+    pub fn node_self_param(&self, node: InFile<&ast::SelfParam>) -> Option<PatId> {\n+        let src = node.map(|it| Either::Right(AstPtr::new(it)));\n+        self.pat_map.get(&src).cloned()\n+    }\n+\n+    pub fn label_syntax(&self, label: LabelId) -> LabelSource {\n+        self.label_map_back[label].clone()\n+    }\n+\n+    pub fn node_label(&self, node: InFile<&ast::Label>) -> Option<LabelId> {\n+        let src = node.map(AstPtr::new);\n+        self.label_map.get(&src).cloned()\n+    }\n+\n+    pub fn field_syntax(&self, expr: ExprId) -> InFile<AstPtr<ast::RecordExprField>> {\n+        self.field_map_back[&expr].clone()\n+    }\n+    pub fn node_field(&self, node: InFile<&ast::RecordExprField>) -> Option<ExprId> {\n+        let src = node.map(AstPtr::new);\n+        self.field_map.get(&src).cloned()\n+    }\n+\n+    pub fn macro_expansion_expr(&self, node: InFile<&ast::MacroExpr>) -> Option<ExprId> {\n+        let src = node.map(AstPtr::new).map(AstPtr::upcast::<ast::MacroExpr>).map(AstPtr::upcast);\n+        self.expr_map.get(&src).copied()\n+    }\n+\n+    /// Get a reference to the body source map's diagnostics.\n+    pub fn diagnostics(&self) -> &[BodyDiagnostic] {\n+        &self.diagnostics\n+    }\n+}"}, {"sha": "c3f261122784e4b6021746469d6f380fb2aed0d9", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/lower.rs", "status": "added", "additions": 997, "deletions": 0, "changes": 997, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,997 @@\n+//! Transforms `ast::Expr` into an equivalent `hir_def::expr::Expr`\n+//! representation.\n+\n+use std::{mem, sync::Arc};\n+\n+use either::Either;\n+use hir_expand::{\n+    ast_id_map::AstIdMap,\n+    hygiene::Hygiene,\n+    name::{name, AsName, Name},\n+    AstId, ExpandError, HirFileId, InFile,\n+};\n+use la_arena::Arena;\n+use once_cell::unsync::OnceCell;\n+use profile::Count;\n+use rustc_hash::FxHashMap;\n+use syntax::{\n+    ast::{\n+        self, ArrayExprKind, AstChildren, HasArgList, HasLoopBody, HasName, LiteralKind,\n+        SlicePatComponents,\n+    },\n+    AstNode, AstPtr, SyntaxNodePtr,\n+};\n+\n+use crate::{\n+    adt::StructKind,\n+    body::{Body, BodySourceMap, Expander, LabelSource, PatPtr, SyntheticSyntax},\n+    body::{BodyDiagnostic, ExprSource, PatSource},\n+    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n+    db::DefDatabase,\n+    expr::{\n+        dummy_expr_id, Array, BindingAnnotation, Expr, ExprId, FloatTypeWrapper, Label, LabelId,\n+        Literal, MatchArm, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n+    },\n+    intern::Interned,\n+    item_scope::BuiltinShadowMode,\n+    path::{GenericArgs, Path},\n+    type_ref::{Mutability, Rawness, TypeRef},\n+    AdtId, BlockLoc, ModuleDefId, UnresolvedMacro,\n+};\n+\n+pub struct LowerCtx<'a> {\n+    pub db: &'a dyn DefDatabase,\n+    hygiene: Hygiene,\n+    ast_id_map: Option<(HirFileId, OnceCell<Arc<AstIdMap>>)>,\n+}\n+\n+impl<'a> LowerCtx<'a> {\n+    pub fn new(db: &'a dyn DefDatabase, file_id: HirFileId) -> Self {\n+        LowerCtx {\n+            db,\n+            hygiene: Hygiene::new(db.upcast(), file_id),\n+            ast_id_map: Some((file_id, OnceCell::new())),\n+        }\n+    }\n+\n+    pub fn with_hygiene(db: &'a dyn DefDatabase, hygiene: &Hygiene) -> Self {\n+        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: None }\n+    }\n+\n+    pub(crate) fn hygiene(&self) -> &Hygiene {\n+        &self.hygiene\n+    }\n+\n+    pub(crate) fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n+        Path::from_src(ast, self)\n+    }\n+\n+    pub(crate) fn ast_id<N: AstNode>(&self, db: &dyn DefDatabase, item: &N) -> Option<AstId<N>> {\n+        let &(file_id, ref ast_id_map) = self.ast_id_map.as_ref()?;\n+        let ast_id_map = ast_id_map.get_or_init(|| db.ast_id_map(file_id));\n+        Some(InFile::new(file_id, ast_id_map.ast_id(item)))\n+    }\n+}\n+\n+pub(super) fn lower(\n+    db: &dyn DefDatabase,\n+    expander: Expander,\n+    params: Option<ast::ParamList>,\n+    body: Option<ast::Expr>,\n+) -> (Body, BodySourceMap) {\n+    ExprCollector {\n+        db,\n+        source_map: BodySourceMap::default(),\n+        ast_id_map: db.ast_id_map(expander.current_file_id),\n+        body: Body {\n+            exprs: Arena::default(),\n+            pats: Arena::default(),\n+            labels: Arena::default(),\n+            params: Vec::new(),\n+            body_expr: dummy_expr_id(),\n+            block_scopes: Vec::new(),\n+            _c: Count::new(),\n+            or_pats: Default::default(),\n+        },\n+        expander,\n+        name_to_pat_grouping: Default::default(),\n+        is_lowering_inside_or_pat: false,\n+    }\n+    .collect(params, body)\n+}\n+\n+struct ExprCollector<'a> {\n+    db: &'a dyn DefDatabase,\n+    expander: Expander,\n+    ast_id_map: Arc<AstIdMap>,\n+    body: Body,\n+    source_map: BodySourceMap,\n+    // a poor-mans union-find?\n+    name_to_pat_grouping: FxHashMap<Name, Vec<PatId>>,\n+    is_lowering_inside_or_pat: bool,\n+}\n+\n+impl ExprCollector<'_> {\n+    fn collect(\n+        mut self,\n+        param_list: Option<ast::ParamList>,\n+        body: Option<ast::Expr>,\n+    ) -> (Body, BodySourceMap) {\n+        if let Some(param_list) = param_list {\n+            if let Some(self_param) = param_list.self_param() {\n+                let ptr = AstPtr::new(&self_param);\n+                let param_pat = self.alloc_pat(\n+                    Pat::Bind {\n+                        name: name![self],\n+                        mode: BindingAnnotation::new(\n+                            self_param.mut_token().is_some() && self_param.amp_token().is_none(),\n+                            false,\n+                        ),\n+                        subpat: None,\n+                    },\n+                    Either::Right(ptr),\n+                );\n+                self.body.params.push(param_pat);\n+            }\n+\n+            for pat in param_list.params().filter_map(|param| param.pat()) {\n+                let param_pat = self.collect_pat(pat);\n+                self.body.params.push(param_pat);\n+            }\n+        };\n+\n+        self.body.body_expr = self.collect_expr_opt(body);\n+        (self.body, self.source_map)\n+    }\n+\n+    fn ctx(&self) -> LowerCtx<'_> {\n+        LowerCtx::new(self.db, self.expander.current_file_id)\n+    }\n+\n+    fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n+        let src = self.expander.to_source(ptr);\n+        let id = self.make_expr(expr, Ok(src.clone()));\n+        self.source_map.expr_map.insert(src, id);\n+        id\n+    }\n+    // desugared exprs don't have ptr, that's wrong and should be fixed\n+    // somehow.\n+    fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n+        self.make_expr(expr, Err(SyntheticSyntax))\n+    }\n+    fn missing_expr(&mut self) -> ExprId {\n+        self.alloc_expr_desugared(Expr::Missing)\n+    }\n+    fn make_expr(&mut self, expr: Expr, src: Result<ExprSource, SyntheticSyntax>) -> ExprId {\n+        let id = self.body.exprs.alloc(expr);\n+        self.source_map.expr_map_back.insert(id, src);\n+        id\n+    }\n+\n+    fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n+        let src = self.expander.to_source(ptr);\n+        let id = self.make_pat(pat, Ok(src.clone()));\n+        self.source_map.pat_map.insert(src, id);\n+        id\n+    }\n+    fn missing_pat(&mut self) -> PatId {\n+        self.make_pat(Pat::Missing, Err(SyntheticSyntax))\n+    }\n+    fn make_pat(&mut self, pat: Pat, src: Result<PatSource, SyntheticSyntax>) -> PatId {\n+        let id = self.body.pats.alloc(pat);\n+        self.source_map.pat_map_back.insert(id, src);\n+        id\n+    }\n+\n+    fn alloc_label(&mut self, label: Label, ptr: AstPtr<ast::Label>) -> LabelId {\n+        let src = self.expander.to_source(ptr);\n+        let id = self.make_label(label, src.clone());\n+        self.source_map.label_map.insert(src, id);\n+        id\n+    }\n+    fn make_label(&mut self, label: Label, src: LabelSource) -> LabelId {\n+        let id = self.body.labels.alloc(label);\n+        self.source_map.label_map_back.insert(id, src);\n+        id\n+    }\n+\n+    fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n+        self.maybe_collect_expr(expr).unwrap_or_else(|| self.missing_expr())\n+    }\n+\n+    /// Returns `None` if and only if the expression is `#[cfg]`d out.\n+    fn maybe_collect_expr(&mut self, expr: ast::Expr) -> Option<ExprId> {\n+        let syntax_ptr = AstPtr::new(&expr);\n+        self.check_cfg(&expr)?;\n+\n+        Some(match expr {\n+            ast::Expr::IfExpr(e) => {\n+                let then_branch = self.collect_block_opt(e.then_branch());\n+\n+                let else_branch = e.else_branch().map(|b| match b {\n+                    ast::ElseBranch::Block(it) => self.collect_block(it),\n+                    ast::ElseBranch::IfExpr(elif) => {\n+                        let expr: ast::Expr = ast::Expr::cast(elif.syntax().clone()).unwrap();\n+                        self.collect_expr(expr)\n+                    }\n+                });\n+\n+                let condition = self.collect_expr_opt(e.condition());\n+\n+                self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n+            }\n+            ast::Expr::LetExpr(e) => {\n+                let pat = self.collect_pat_opt(e.pat());\n+                let expr = self.collect_expr_opt(e.expr());\n+                self.alloc_expr(Expr::Let { pat, expr }, syntax_ptr)\n+            }\n+            ast::Expr::BlockExpr(e) => match e.modifier() {\n+                Some(ast::BlockModifier::Try(_)) => {\n+                    let body = self.collect_block(e);\n+                    self.alloc_expr(Expr::TryBlock { body }, syntax_ptr)\n+                }\n+                Some(ast::BlockModifier::Unsafe(_)) => {\n+                    let body = self.collect_block(e);\n+                    self.alloc_expr(Expr::Unsafe { body }, syntax_ptr)\n+                }\n+                // FIXME: we need to record these effects somewhere...\n+                Some(ast::BlockModifier::Label(label)) => {\n+                    let label = self.collect_label(label);\n+                    let res = self.collect_block(e);\n+                    match &mut self.body.exprs[res] {\n+                        Expr::Block { label: block_label, .. } => {\n+                            *block_label = Some(label);\n+                        }\n+                        _ => unreachable!(),\n+                    }\n+                    res\n+                }\n+                Some(ast::BlockModifier::Async(_)) => {\n+                    let body = self.collect_block(e);\n+                    self.alloc_expr(Expr::Async { body }, syntax_ptr)\n+                }\n+                Some(ast::BlockModifier::Const(_)) => {\n+                    let body = self.collect_block(e);\n+                    self.alloc_expr(Expr::Const { body }, syntax_ptr)\n+                }\n+                None => self.collect_block(e),\n+            },\n+            ast::Expr::LoopExpr(e) => {\n+                let label = e.label().map(|label| self.collect_label(label));\n+                let body = self.collect_block_opt(e.loop_body());\n+                self.alloc_expr(Expr::Loop { body, label }, syntax_ptr)\n+            }\n+            ast::Expr::WhileExpr(e) => {\n+                let label = e.label().map(|label| self.collect_label(label));\n+                let body = self.collect_block_opt(e.loop_body());\n+\n+                let condition = self.collect_expr_opt(e.condition());\n+\n+                self.alloc_expr(Expr::While { condition, body, label }, syntax_ptr)\n+            }\n+            ast::Expr::ForExpr(e) => {\n+                let label = e.label().map(|label| self.collect_label(label));\n+                let iterable = self.collect_expr_opt(e.iterable());\n+                let pat = self.collect_pat_opt(e.pat());\n+                let body = self.collect_block_opt(e.loop_body());\n+                self.alloc_expr(Expr::For { iterable, pat, body, label }, syntax_ptr)\n+            }\n+            ast::Expr::CallExpr(e) => {\n+                let callee = self.collect_expr_opt(e.expr());\n+                let args = if let Some(arg_list) = e.arg_list() {\n+                    arg_list.args().filter_map(|e| self.maybe_collect_expr(e)).collect()\n+                } else {\n+                    Box::default()\n+                };\n+                self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n+            }\n+            ast::Expr::MethodCallExpr(e) => {\n+                let receiver = self.collect_expr_opt(e.receiver());\n+                let args = if let Some(arg_list) = e.arg_list() {\n+                    arg_list.args().filter_map(|e| self.maybe_collect_expr(e)).collect()\n+                } else {\n+                    Box::default()\n+                };\n+                let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n+                let generic_args = e\n+                    .generic_arg_list()\n+                    .and_then(|it| GenericArgs::from_ast(&self.ctx(), it))\n+                    .map(Box::new);\n+                self.alloc_expr(\n+                    Expr::MethodCall { receiver, method_name, args, generic_args },\n+                    syntax_ptr,\n+                )\n+            }\n+            ast::Expr::MatchExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let arms = if let Some(match_arm_list) = e.match_arm_list() {\n+                    match_arm_list\n+                        .arms()\n+                        .filter_map(|arm| {\n+                            self.check_cfg(&arm).map(|()| MatchArm {\n+                                pat: self.collect_pat_opt(arm.pat()),\n+                                expr: self.collect_expr_opt(arm.expr()),\n+                                guard: arm\n+                                    .guard()\n+                                    .map(|guard| self.collect_expr_opt(guard.condition())),\n+                            })\n+                        })\n+                        .collect()\n+                } else {\n+                    Box::default()\n+                };\n+                self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n+            }\n+            ast::Expr::PathExpr(e) => {\n+                let path = e\n+                    .path()\n+                    .and_then(|path| self.expander.parse_path(self.db, path))\n+                    .map(Expr::Path)\n+                    .unwrap_or(Expr::Missing);\n+                self.alloc_expr(path, syntax_ptr)\n+            }\n+            ast::Expr::ContinueExpr(e) => self.alloc_expr(\n+                Expr::Continue { label: e.lifetime().map(|l| Name::new_lifetime(&l)) },\n+                syntax_ptr,\n+            ),\n+            ast::Expr::BreakExpr(e) => {\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n+                self.alloc_expr(\n+                    Expr::Break { expr, label: e.lifetime().map(|l| Name::new_lifetime(&l)) },\n+                    syntax_ptr,\n+                )\n+            }\n+            ast::Expr::ParenExpr(e) => {\n+                let inner = self.collect_expr_opt(e.expr());\n+                // make the paren expr point to the inner expression as well\n+                let src = self.expander.to_source(syntax_ptr);\n+                self.source_map.expr_map.insert(src, inner);\n+                inner\n+            }\n+            ast::Expr::ReturnExpr(e) => {\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n+                self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n+            }\n+            ast::Expr::YieldExpr(e) => {\n+                let expr = e.expr().map(|e| self.collect_expr(e));\n+                self.alloc_expr(Expr::Yield { expr }, syntax_ptr)\n+            }\n+            ast::Expr::RecordExpr(e) => {\n+                let path =\n+                    e.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n+                let record_lit = if let Some(nfl) = e.record_expr_field_list() {\n+                    let fields = nfl\n+                        .fields()\n+                        .filter_map(|field| {\n+                            self.check_cfg(&field)?;\n+\n+                            let name = field.field_name()?.as_name();\n+\n+                            let expr = match field.expr() {\n+                                Some(e) => self.collect_expr(e),\n+                                None => self.missing_expr(),\n+                            };\n+                            let src = self.expander.to_source(AstPtr::new(&field));\n+                            self.source_map.field_map.insert(src.clone(), expr);\n+                            self.source_map.field_map_back.insert(expr, src);\n+                            Some(RecordLitField { name, expr })\n+                        })\n+                        .collect();\n+                    let spread = nfl.spread().map(|s| self.collect_expr(s));\n+                    Expr::RecordLit { path, fields, spread }\n+                } else {\n+                    Expr::RecordLit { path, fields: Box::default(), spread: None }\n+                };\n+\n+                self.alloc_expr(record_lit, syntax_ptr)\n+            }\n+            ast::Expr::FieldExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let name = match e.field_access() {\n+                    Some(kind) => kind.as_name(),\n+                    _ => Name::missing(),\n+                };\n+                self.alloc_expr(Expr::Field { expr, name }, syntax_ptr)\n+            }\n+            ast::Expr::AwaitExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                self.alloc_expr(Expr::Await { expr }, syntax_ptr)\n+            }\n+            ast::Expr::TryExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                self.alloc_expr(Expr::Try { expr }, syntax_ptr)\n+            }\n+            ast::Expr::CastExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let type_ref = Interned::new(TypeRef::from_ast_opt(&self.ctx(), e.ty()));\n+                self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr)\n+            }\n+            ast::Expr::RefExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                let raw_tok = e.raw_token().is_some();\n+                let mutability = if raw_tok {\n+                    if e.mut_token().is_some() {\n+                        Mutability::Mut\n+                    } else if e.const_token().is_some() {\n+                        Mutability::Shared\n+                    } else {\n+                        unreachable!(\"parser only remaps to raw_token() if matching mutability token follows\")\n+                    }\n+                } else {\n+                    Mutability::from_mutable(e.mut_token().is_some())\n+                };\n+                let rawness = Rawness::from_raw(raw_tok);\n+                self.alloc_expr(Expr::Ref { expr, rawness, mutability }, syntax_ptr)\n+            }\n+            ast::Expr::PrefixExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                match e.op_kind() {\n+                    Some(op) => self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr),\n+                    None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+                }\n+            }\n+            ast::Expr::ClosureExpr(e) => {\n+                let mut args = Vec::new();\n+                let mut arg_types = Vec::new();\n+                if let Some(pl) = e.param_list() {\n+                    for param in pl.params() {\n+                        let pat = self.collect_pat_opt(param.pat());\n+                        let type_ref =\n+                            param.ty().map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n+                        args.push(pat);\n+                        arg_types.push(type_ref);\n+                    }\n+                }\n+                let ret_type = e\n+                    .ret_type()\n+                    .and_then(|r| r.ty())\n+                    .map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n+                let body = self.collect_expr_opt(e.body());\n+                self.alloc_expr(\n+                    Expr::Closure {\n+                        args: args.into(),\n+                        arg_types: arg_types.into(),\n+                        ret_type,\n+                        body,\n+                    },\n+                    syntax_ptr,\n+                )\n+            }\n+            ast::Expr::BinExpr(e) => {\n+                let lhs = self.collect_expr_opt(e.lhs());\n+                let rhs = self.collect_expr_opt(e.rhs());\n+                let op = e.op_kind();\n+                self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n+            }\n+            ast::Expr::TupleExpr(e) => {\n+                let exprs = e.fields().map(|expr| self.collect_expr(expr)).collect();\n+                self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n+            }\n+            ast::Expr::BoxExpr(e) => {\n+                let expr = self.collect_expr_opt(e.expr());\n+                self.alloc_expr(Expr::Box { expr }, syntax_ptr)\n+            }\n+\n+            ast::Expr::ArrayExpr(e) => {\n+                let kind = e.kind();\n+\n+                match kind {\n+                    ArrayExprKind::ElementList(e) => {\n+                        let exprs = e.map(|expr| self.collect_expr(expr)).collect();\n+                        self.alloc_expr(Expr::Array(Array::ElementList(exprs)), syntax_ptr)\n+                    }\n+                    ArrayExprKind::Repeat { initializer, repeat } => {\n+                        let initializer = self.collect_expr_opt(initializer);\n+                        let repeat = self.collect_expr_opt(repeat);\n+                        self.alloc_expr(\n+                            Expr::Array(Array::Repeat { initializer, repeat }),\n+                            syntax_ptr,\n+                        )\n+                    }\n+                }\n+            }\n+\n+            ast::Expr::Literal(e) => self.alloc_expr(Expr::Literal(e.kind().into()), syntax_ptr),\n+            ast::Expr::IndexExpr(e) => {\n+                let base = self.collect_expr_opt(e.base());\n+                let index = self.collect_expr_opt(e.index());\n+                self.alloc_expr(Expr::Index { base, index }, syntax_ptr)\n+            }\n+            ast::Expr::RangeExpr(e) => {\n+                let lhs = e.start().map(|lhs| self.collect_expr(lhs));\n+                let rhs = e.end().map(|rhs| self.collect_expr(rhs));\n+                match e.op_kind() {\n+                    Some(range_type) => {\n+                        self.alloc_expr(Expr::Range { lhs, rhs, range_type }, syntax_ptr)\n+                    }\n+                    None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+                }\n+            }\n+            ast::Expr::MacroExpr(e) => {\n+                let e = e.macro_call()?;\n+                let macro_ptr = AstPtr::new(&e);\n+                let id = self.collect_macro_call(e, macro_ptr, true, |this, expansion| {\n+                    expansion.map(|it| this.collect_expr(it))\n+                });\n+                match id {\n+                    Some(id) => {\n+                        // Make the macro-call point to its expanded expression so we can query\n+                        // semantics on syntax pointers to the macro\n+                        let src = self.expander.to_source(syntax_ptr);\n+                        self.source_map.expr_map.insert(src, id);\n+                        id\n+                    }\n+                    None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+                }\n+            }\n+            ast::Expr::MacroStmts(e) => {\n+                let statements = e.statements().filter_map(|s| self.collect_stmt(s)).collect();\n+                let tail = e.expr().map(|e| self.collect_expr(e));\n+\n+                self.alloc_expr(Expr::MacroStmts { tail, statements }, syntax_ptr)\n+            }\n+            ast::Expr::UnderscoreExpr(_) => self.alloc_expr(Expr::Underscore, syntax_ptr),\n+        })\n+    }\n+\n+    fn collect_macro_call<F, T, U>(\n+        &mut self,\n+        mcall: ast::MacroCall,\n+        syntax_ptr: AstPtr<ast::MacroCall>,\n+        record_diagnostics: bool,\n+        collector: F,\n+    ) -> U\n+    where\n+        F: FnOnce(&mut Self, Option<T>) -> U,\n+        T: ast::AstNode,\n+    {\n+        // File containing the macro call. Expansion errors will be attached here.\n+        let outer_file = self.expander.current_file_id;\n+\n+        let macro_call_ptr = self.expander.to_source(AstPtr::new(&mcall));\n+        let res = self.expander.enter_expand(self.db, mcall);\n+\n+        let res = match res {\n+            Ok(res) => res,\n+            Err(UnresolvedMacro { path }) => {\n+                if record_diagnostics {\n+                    self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedMacroCall {\n+                        node: InFile::new(outer_file, syntax_ptr),\n+                        path,\n+                    });\n+                }\n+                return collector(self, None);\n+            }\n+        };\n+\n+        if record_diagnostics {\n+            match &res.err {\n+                Some(ExpandError::UnresolvedProcMacro(krate)) => {\n+                    self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedProcMacro {\n+                        node: InFile::new(outer_file, syntax_ptr),\n+                        krate: *krate,\n+                    });\n+                }\n+                Some(err) => {\n+                    self.source_map.diagnostics.push(BodyDiagnostic::MacroError {\n+                        node: InFile::new(outer_file, syntax_ptr),\n+                        message: err.to_string(),\n+                    });\n+                }\n+                None => {}\n+            }\n+        }\n+\n+        match res.value {\n+            Some((mark, expansion)) => {\n+                self.source_map.expansions.insert(macro_call_ptr, self.expander.current_file_id);\n+                let prev_ast_id_map = mem::replace(\n+                    &mut self.ast_id_map,\n+                    self.db.ast_id_map(self.expander.current_file_id),\n+                );\n+\n+                let id = collector(self, Some(expansion));\n+                self.ast_id_map = prev_ast_id_map;\n+                self.expander.exit(self.db, mark);\n+                id\n+            }\n+            None => collector(self, None),\n+        }\n+    }\n+\n+    fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n+        match expr {\n+            Some(expr) => self.collect_expr(expr),\n+            None => self.missing_expr(),\n+        }\n+    }\n+\n+    fn collect_stmt(&mut self, s: ast::Stmt) -> Option<Statement> {\n+        match s {\n+            ast::Stmt::LetStmt(stmt) => {\n+                if self.check_cfg(&stmt).is_none() {\n+                    return None;\n+                }\n+                let pat = self.collect_pat_opt(stmt.pat());\n+                let type_ref =\n+                    stmt.ty().map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n+                let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n+                let else_branch = stmt\n+                    .let_else()\n+                    .and_then(|let_else| let_else.block_expr())\n+                    .map(|block| self.collect_block(block));\n+                Some(Statement::Let { pat, type_ref, initializer, else_branch })\n+            }\n+            ast::Stmt::ExprStmt(stmt) => {\n+                let expr = stmt.expr();\n+                if let Some(expr) = &expr {\n+                    if self.check_cfg(expr).is_none() {\n+                        return None;\n+                    }\n+                }\n+                let has_semi = stmt.semicolon_token().is_some();\n+                // Note that macro could be expanded to multiple statements\n+                if let Some(expr @ ast::Expr::MacroExpr(mac)) = &expr {\n+                    let mac_call = mac.macro_call()?;\n+                    let syntax_ptr = AstPtr::new(expr);\n+                    let macro_ptr = AstPtr::new(&mac_call);\n+                    let stmt = self.collect_macro_call(\n+                        mac_call,\n+                        macro_ptr,\n+                        false,\n+                        |this, expansion: Option<ast::MacroStmts>| match expansion {\n+                            Some(expansion) => {\n+                                let statements = expansion\n+                                    .statements()\n+                                    .filter_map(|stmt| this.collect_stmt(stmt))\n+                                    .collect();\n+                                let tail = expansion.expr().map(|expr| this.collect_expr(expr));\n+\n+                                let mac_stmts = this.alloc_expr(\n+                                    Expr::MacroStmts { tail, statements },\n+                                    AstPtr::new(&ast::Expr::MacroStmts(expansion)),\n+                                );\n+\n+                                Some(mac_stmts)\n+                            }\n+                            None => None,\n+                        },\n+                    );\n+\n+                    let expr = match stmt {\n+                        Some(expr) => {\n+                            // Make the macro-call point to its expanded expression so we can query\n+                            // semantics on syntax pointers to the macro\n+                            let src = self.expander.to_source(syntax_ptr);\n+                            self.source_map.expr_map.insert(src, expr);\n+                            expr\n+                        }\n+                        None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+                    };\n+                    Some(Statement::Expr { expr, has_semi })\n+                } else {\n+                    let expr = self.collect_expr_opt(expr);\n+                    Some(Statement::Expr { expr, has_semi })\n+                }\n+            }\n+            ast::Stmt::Item(_item) => None,\n+        }\n+    }\n+\n+    fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n+        let file_local_id = self.ast_id_map.ast_id(&block);\n+        let ast_id = AstId::new(self.expander.current_file_id, file_local_id);\n+        let block_loc =\n+            BlockLoc { ast_id, module: self.expander.def_map.module_id(self.expander.module) };\n+        let block_id = self.db.intern_block(block_loc);\n+\n+        let (module, def_map) = match self.db.block_def_map(block_id) {\n+            Some(def_map) => {\n+                self.body.block_scopes.push(block_id);\n+                (def_map.root(), def_map)\n+            }\n+            None => (self.expander.module, self.expander.def_map.clone()),\n+        };\n+        let prev_def_map = mem::replace(&mut self.expander.def_map, def_map);\n+        let prev_local_module = mem::replace(&mut self.expander.module, module);\n+\n+        let mut statements: Vec<_> =\n+            block.statements().filter_map(|s| self.collect_stmt(s)).collect();\n+        let tail = block.tail_expr().and_then(|e| self.maybe_collect_expr(e));\n+        let tail = tail.or_else(|| {\n+            let stmt = statements.pop()?;\n+            if let Statement::Expr { expr, has_semi: false } = stmt {\n+                return Some(expr);\n+            }\n+            statements.push(stmt);\n+            None\n+        });\n+\n+        let syntax_node_ptr = AstPtr::new(&block.into());\n+        let expr_id = self.alloc_expr(\n+            Expr::Block {\n+                id: block_id,\n+                statements: statements.into_boxed_slice(),\n+                tail,\n+                label: None,\n+            },\n+            syntax_node_ptr,\n+        );\n+\n+        self.expander.def_map = prev_def_map;\n+        self.expander.module = prev_local_module;\n+        expr_id\n+    }\n+\n+    fn collect_block_opt(&mut self, expr: Option<ast::BlockExpr>) -> ExprId {\n+        match expr {\n+            Some(block) => self.collect_block(block),\n+            None => self.missing_expr(),\n+        }\n+    }\n+\n+    fn collect_label(&mut self, ast_label: ast::Label) -> LabelId {\n+        let label = Label {\n+            name: ast_label.lifetime().as_ref().map_or_else(Name::missing, Name::new_lifetime),\n+        };\n+        self.alloc_label(label, AstPtr::new(&ast_label))\n+    }\n+\n+    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n+        let pat_id = self.collect_pat_(pat);\n+        for (_, pats) in self.name_to_pat_grouping.drain() {\n+            let pats = Arc::<[_]>::from(pats);\n+            self.body.or_pats.extend(pats.iter().map(|&pat| (pat, pats.clone())));\n+        }\n+        self.is_lowering_inside_or_pat = false;\n+        pat_id\n+    }\n+\n+    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+        match pat {\n+            Some(pat) => self.collect_pat(pat),\n+            None => self.missing_pat(),\n+        }\n+    }\n+\n+    fn collect_pat_(&mut self, pat: ast::Pat) -> PatId {\n+        let pattern = match &pat {\n+            ast::Pat::IdentPat(bp) => {\n+                let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n+\n+                let key = self.is_lowering_inside_or_pat.then(|| name.clone());\n+                let annotation =\n+                    BindingAnnotation::new(bp.mut_token().is_some(), bp.ref_token().is_some());\n+                let subpat = bp.pat().map(|subpat| self.collect_pat_(subpat));\n+                let pattern = if annotation == BindingAnnotation::Unannotated && subpat.is_none() {\n+                    // This could also be a single-segment path pattern. To\n+                    // decide that, we need to try resolving the name.\n+                    let (resolved, _) = self.expander.def_map.resolve_path(\n+                        self.db,\n+                        self.expander.module,\n+                        &name.clone().into(),\n+                        BuiltinShadowMode::Other,\n+                    );\n+                    match resolved.take_values() {\n+                        Some(ModuleDefId::ConstId(_)) => Pat::Path(name.into()),\n+                        Some(ModuleDefId::EnumVariantId(_)) => {\n+                            // this is only really valid for unit variants, but\n+                            // shadowing other enum variants with a pattern is\n+                            // an error anyway\n+                            Pat::Path(name.into())\n+                        }\n+                        Some(ModuleDefId::AdtId(AdtId::StructId(s)))\n+                            if self.db.struct_data(s).variant_data.kind() != StructKind::Record =>\n+                        {\n+                            // Funnily enough, record structs *can* be shadowed\n+                            // by pattern bindings (but unit or tuple structs\n+                            // can't).\n+                            Pat::Path(name.into())\n+                        }\n+                        // shadowing statics is an error as well, so we just ignore that case here\n+                        _ => Pat::Bind { name, mode: annotation, subpat },\n+                    }\n+                } else {\n+                    Pat::Bind { name, mode: annotation, subpat }\n+                };\n+\n+                let ptr = AstPtr::new(&pat);\n+                let pat = self.alloc_pat(pattern, Either::Left(ptr));\n+                if let Some(key) = key {\n+                    self.name_to_pat_grouping.entry(key).or_default().push(pat);\n+                }\n+                return pat;\n+            }\n+            ast::Pat::TupleStructPat(p) => {\n+                let path =\n+                    p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n+                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n+                Pat::TupleStruct { path, args, ellipsis }\n+            }\n+            ast::Pat::RefPat(p) => {\n+                let pat = self.collect_pat_opt(p.pat());\n+                let mutability = Mutability::from_mutable(p.mut_token().is_some());\n+                Pat::Ref { pat, mutability }\n+            }\n+            ast::Pat::PathPat(p) => {\n+                let path =\n+                    p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n+                path.map(Pat::Path).unwrap_or(Pat::Missing)\n+            }\n+            ast::Pat::OrPat(p) => {\n+                self.is_lowering_inside_or_pat = true;\n+                let pats = p.pats().map(|p| self.collect_pat_(p)).collect();\n+                Pat::Or(pats)\n+            }\n+            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(p.pat()),\n+            ast::Pat::TuplePat(p) => {\n+                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n+                Pat::Tuple { args, ellipsis }\n+            }\n+            ast::Pat::WildcardPat(_) => Pat::Wild,\n+            ast::Pat::RecordPat(p) => {\n+                let path =\n+                    p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n+                let args = p\n+                    .record_pat_field_list()\n+                    .expect(\"every struct should have a field list\")\n+                    .fields()\n+                    .filter_map(|f| {\n+                        let ast_pat = f.pat()?;\n+                        let pat = self.collect_pat_(ast_pat);\n+                        let name = f.field_name()?.as_name();\n+                        Some(RecordFieldPat { name, pat })\n+                    })\n+                    .collect();\n+\n+                let ellipsis = p\n+                    .record_pat_field_list()\n+                    .expect(\"every struct should have a field list\")\n+                    .rest_pat()\n+                    .is_some();\n+\n+                Pat::Record { path, args, ellipsis }\n+            }\n+            ast::Pat::SlicePat(p) => {\n+                let SlicePatComponents { prefix, slice, suffix } = p.components();\n+\n+                // FIXME properly handle `RestPat`\n+                Pat::Slice {\n+                    prefix: prefix.into_iter().map(|p| self.collect_pat_(p)).collect(),\n+                    slice: slice.map(|p| self.collect_pat_(p)),\n+                    suffix: suffix.into_iter().map(|p| self.collect_pat_(p)).collect(),\n+                }\n+            }\n+            ast::Pat::LiteralPat(lit) => {\n+                if let Some(ast_lit) = lit.literal() {\n+                    let expr = Expr::Literal(ast_lit.kind().into());\n+                    let expr_ptr = AstPtr::new(&ast::Expr::Literal(ast_lit));\n+                    let expr_id = self.alloc_expr(expr, expr_ptr);\n+                    Pat::Lit(expr_id)\n+                } else {\n+                    Pat::Missing\n+                }\n+            }\n+            ast::Pat::RestPat(_) => {\n+                // `RestPat` requires special handling and should not be mapped\n+                // to a Pat. Here we are using `Pat::Missing` as a fallback for\n+                // when `RestPat` is mapped to `Pat`, which can easily happen\n+                // when the source code being analyzed has a malformed pattern\n+                // which includes `..` in a place where it isn't valid.\n+\n+                Pat::Missing\n+            }\n+            ast::Pat::BoxPat(boxpat) => {\n+                let inner = self.collect_pat_opt_(boxpat.pat());\n+                Pat::Box { inner }\n+            }\n+            ast::Pat::ConstBlockPat(const_block_pat) => {\n+                if let Some(expr) = const_block_pat.block_expr() {\n+                    let expr_id = self.collect_block(expr);\n+                    Pat::ConstBlock(expr_id)\n+                } else {\n+                    Pat::Missing\n+                }\n+            }\n+            ast::Pat::MacroPat(mac) => match mac.macro_call() {\n+                Some(call) => {\n+                    let macro_ptr = AstPtr::new(&call);\n+                    let src = self.expander.to_source(Either::Left(AstPtr::new(&pat)));\n+                    let pat =\n+                        self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n+                            this.collect_pat_opt_(expanded_pat)\n+                        });\n+                    self.source_map.pat_map.insert(src, pat);\n+                    return pat;\n+                }\n+                None => Pat::Missing,\n+            },\n+            // FIXME: implement\n+            ast::Pat::RangePat(_) => Pat::Missing,\n+        };\n+        let ptr = AstPtr::new(&pat);\n+        self.alloc_pat(pattern, Either::Left(ptr))\n+    }\n+\n+    fn collect_pat_opt_(&mut self, pat: Option<ast::Pat>) -> PatId {\n+        match pat {\n+            Some(pat) => self.collect_pat_(pat),\n+            None => self.missing_pat(),\n+        }\n+    }\n+\n+    fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Box<[PatId]>, Option<usize>) {\n+        // Find the location of the `..`, if there is one. Note that we do not\n+        // consider the possibility of there being multiple `..` here.\n+        let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::RestPat(_)));\n+        // We want to skip the `..` pattern here, since we account for it above.\n+        let args = args\n+            .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n+            .map(|p| self.collect_pat_(p))\n+            .collect();\n+\n+        (args, ellipsis)\n+    }\n+\n+    /// Returns `None` (and emits diagnostics) when `owner` if `#[cfg]`d out, and `Some(())` when\n+    /// not.\n+    fn check_cfg(&mut self, owner: &dyn ast::HasAttrs) -> Option<()> {\n+        match self.expander.parse_attrs(self.db, owner).cfg() {\n+            Some(cfg) => {\n+                if self.expander.cfg_options().check(&cfg) != Some(false) {\n+                    return Some(());\n+                }\n+\n+                self.source_map.diagnostics.push(BodyDiagnostic::InactiveCode {\n+                    node: InFile::new(\n+                        self.expander.current_file_id,\n+                        SyntaxNodePtr::new(owner.syntax()),\n+                    ),\n+                    cfg,\n+                    opts: self.expander.cfg_options().clone(),\n+                });\n+\n+                None\n+            }\n+            None => Some(()),\n+        }\n+    }\n+}\n+\n+impl From<ast::LiteralKind> for Literal {\n+    fn from(ast_lit_kind: ast::LiteralKind) -> Self {\n+        match ast_lit_kind {\n+            // FIXME: these should have actual values filled in, but unsure on perf impact\n+            LiteralKind::IntNumber(lit) => {\n+                if let builtin @ Some(_) = lit.suffix().and_then(BuiltinFloat::from_suffix) {\n+                    Literal::Float(\n+                        FloatTypeWrapper::new(lit.float_value().unwrap_or(Default::default())),\n+                        builtin,\n+                    )\n+                } else if let builtin @ Some(_) = lit.suffix().and_then(BuiltinInt::from_suffix) {\n+                    Literal::Int(lit.value().unwrap_or(0) as i128, builtin)\n+                } else {\n+                    let builtin = lit.suffix().and_then(BuiltinUint::from_suffix);\n+                    Literal::Uint(lit.value().unwrap_or(0), builtin)\n+                }\n+            }\n+            LiteralKind::FloatNumber(lit) => {\n+                let ty = lit.suffix().and_then(BuiltinFloat::from_suffix);\n+                Literal::Float(FloatTypeWrapper::new(lit.value().unwrap_or(Default::default())), ty)\n+            }\n+            LiteralKind::ByteString(bs) => {\n+                let text = bs.value().map(Box::from).unwrap_or_else(Default::default);\n+                Literal::ByteString(text)\n+            }\n+            LiteralKind::String(s) => {\n+                let text = s.value().map(Box::from).unwrap_or_else(Default::default);\n+                Literal::String(text)\n+            }\n+            LiteralKind::Byte(b) => {\n+                Literal::Uint(b.value().unwrap_or_default() as u128, Some(BuiltinUint::U8))\n+            }\n+            LiteralKind::Char(c) => Literal::Char(c.value().unwrap_or_default()),\n+            LiteralKind::Bool(val) => Literal::Bool(val),\n+        }\n+    }\n+}"}, {"sha": "f4c390dce26e0520168594430508281406137c3f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/scope.rs", "status": "added", "additions": 571, "deletions": 0, "changes": 571, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,571 @@\n+//! Name resolution for expressions.\n+use std::sync::Arc;\n+\n+use hir_expand::name::Name;\n+use la_arena::{Arena, Idx};\n+use rustc_hash::FxHashMap;\n+\n+use crate::{\n+    body::Body,\n+    db::DefDatabase,\n+    expr::{Expr, ExprId, LabelId, Pat, PatId, Statement},\n+    BlockId, DefWithBodyId,\n+};\n+\n+pub type ScopeId = Idx<ScopeData>;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ExprScopes {\n+    scopes: Arena<ScopeData>,\n+    scope_by_expr: FxHashMap<ExprId, ScopeId>,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ScopeEntry {\n+    name: Name,\n+    pat: PatId,\n+}\n+\n+impl ScopeEntry {\n+    pub fn name(&self) -> &Name {\n+        &self.name\n+    }\n+\n+    pub fn pat(&self) -> PatId {\n+        self.pat\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ScopeData {\n+    parent: Option<ScopeId>,\n+    block: Option<BlockId>,\n+    label: Option<(LabelId, Name)>,\n+    entries: Vec<ScopeEntry>,\n+}\n+\n+impl ExprScopes {\n+    pub(crate) fn expr_scopes_query(db: &dyn DefDatabase, def: DefWithBodyId) -> Arc<ExprScopes> {\n+        let body = db.body(def);\n+        Arc::new(ExprScopes::new(&*body))\n+    }\n+\n+    fn new(body: &Body) -> ExprScopes {\n+        let mut scopes =\n+            ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n+        let mut root = scopes.root_scope();\n+        scopes.add_params_bindings(body, root, &body.params);\n+        compute_expr_scopes(body.body_expr, body, &mut scopes, &mut root);\n+        scopes\n+    }\n+\n+    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n+        &self.scopes[scope].entries\n+    }\n+\n+    /// If `scope` refers to a block expression scope, returns the corresponding `BlockId`.\n+    pub fn block(&self, scope: ScopeId) -> Option<BlockId> {\n+        self.scopes[scope].block\n+    }\n+\n+    /// If `scope` refers to a labeled expression scope, returns the corresponding `Label`.\n+    pub fn label(&self, scope: ScopeId) -> Option<(LabelId, Name)> {\n+        self.scopes[scope].label.clone()\n+    }\n+\n+    pub fn scope_chain(&self, scope: Option<ScopeId>) -> impl Iterator<Item = ScopeId> + '_ {\n+        std::iter::successors(scope, move |&scope| self.scopes[scope].parent)\n+    }\n+\n+    pub fn resolve_name_in_scope(&self, scope: ScopeId, name: &Name) -> Option<&ScopeEntry> {\n+        self.scope_chain(Some(scope))\n+            .find_map(|scope| self.entries(scope).iter().find(|it| it.name == *name))\n+    }\n+\n+    pub fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {\n+        self.scope_by_expr.get(&expr).copied()\n+    }\n+\n+    pub fn scope_by_expr(&self) -> &FxHashMap<ExprId, ScopeId> {\n+        &self.scope_by_expr\n+    }\n+\n+    fn root_scope(&mut self) -> ScopeId {\n+        self.scopes.alloc(ScopeData { parent: None, block: None, label: None, entries: vec![] })\n+    }\n+\n+    fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n+        self.scopes.alloc(ScopeData {\n+            parent: Some(parent),\n+            block: None,\n+            label: None,\n+            entries: vec![],\n+        })\n+    }\n+\n+    fn new_labeled_scope(&mut self, parent: ScopeId, label: Option<(LabelId, Name)>) -> ScopeId {\n+        self.scopes.alloc(ScopeData { parent: Some(parent), block: None, label, entries: vec![] })\n+    }\n+\n+    fn new_block_scope(\n+        &mut self,\n+        parent: ScopeId,\n+        block: BlockId,\n+        label: Option<(LabelId, Name)>,\n+    ) -> ScopeId {\n+        self.scopes.alloc(ScopeData {\n+            parent: Some(parent),\n+            block: Some(block),\n+            label,\n+            entries: vec![],\n+        })\n+    }\n+\n+    fn add_bindings(&mut self, body: &Body, scope: ScopeId, pat: PatId) {\n+        let pattern = &body[pat];\n+        if let Pat::Bind { name, .. } = pattern {\n+            let entry = ScopeEntry { name: name.clone(), pat };\n+            self.scopes[scope].entries.push(entry);\n+        }\n+\n+        pattern.walk_child_pats(|pat| self.add_bindings(body, scope, pat));\n+    }\n+\n+    fn add_params_bindings(&mut self, body: &Body, scope: ScopeId, params: &[PatId]) {\n+        params.iter().for_each(|pat| self.add_bindings(body, scope, *pat));\n+    }\n+\n+    fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n+        self.scope_by_expr.insert(node, scope);\n+    }\n+}\n+\n+fn compute_block_scopes(\n+    statements: &[Statement],\n+    tail: Option<ExprId>,\n+    body: &Body,\n+    scopes: &mut ExprScopes,\n+    scope: &mut ScopeId,\n+) {\n+    for stmt in statements {\n+        match stmt {\n+            Statement::Let { pat, initializer, else_branch, .. } => {\n+                if let Some(expr) = initializer {\n+                    compute_expr_scopes(*expr, body, scopes, scope);\n+                }\n+                if let Some(expr) = else_branch {\n+                    compute_expr_scopes(*expr, body, scopes, scope);\n+                }\n+\n+                *scope = scopes.new_scope(*scope);\n+                scopes.add_bindings(body, *scope, *pat);\n+            }\n+            Statement::Expr { expr, .. } => {\n+                compute_expr_scopes(*expr, body, scopes, scope);\n+            }\n+        }\n+    }\n+    if let Some(expr) = tail {\n+        compute_expr_scopes(expr, body, scopes, scope);\n+    }\n+}\n+\n+fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope: &mut ScopeId) {\n+    let make_label =\n+        |label: &Option<LabelId>| label.map(|label| (label, body.labels[label].name.clone()));\n+\n+    scopes.set_scope(expr, *scope);\n+    match &body[expr] {\n+        Expr::MacroStmts { statements, tail } => {\n+            compute_block_scopes(statements, *tail, body, scopes, scope);\n+        }\n+        Expr::Block { statements, tail, id, label } => {\n+            let mut scope = scopes.new_block_scope(*scope, *id, make_label(label));\n+            // Overwrite the old scope for the block expr, so that every block scope can be found\n+            // via the block itself (important for blocks that only contain items, no expressions).\n+            scopes.set_scope(expr, scope);\n+            compute_block_scopes(statements, *tail, body, scopes, &mut scope);\n+        }\n+        Expr::For { iterable, pat, body: body_expr, label } => {\n+            compute_expr_scopes(*iterable, body, scopes, scope);\n+            let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n+            scopes.add_bindings(body, scope, *pat);\n+            compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n+        }\n+        Expr::While { condition, body: body_expr, label } => {\n+            let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n+            compute_expr_scopes(*condition, body, scopes, &mut scope);\n+            compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n+        }\n+        Expr::Loop { body: body_expr, label } => {\n+            let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n+            compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n+        }\n+        Expr::Closure { args, body: body_expr, .. } => {\n+            let mut scope = scopes.new_scope(*scope);\n+            scopes.add_params_bindings(body, scope, args);\n+            compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n+        }\n+        Expr::Match { expr, arms } => {\n+            compute_expr_scopes(*expr, body, scopes, scope);\n+            for arm in arms.iter() {\n+                let mut scope = scopes.new_scope(*scope);\n+                scopes.add_bindings(body, scope, arm.pat);\n+                if let Some(guard) = arm.guard {\n+                    scope = scopes.new_scope(scope);\n+                    compute_expr_scopes(guard, body, scopes, &mut scope);\n+                }\n+                compute_expr_scopes(arm.expr, body, scopes, &mut scope);\n+            }\n+        }\n+        &Expr::If { condition, then_branch, else_branch } => {\n+            let mut then_branch_scope = scopes.new_scope(*scope);\n+            compute_expr_scopes(condition, body, scopes, &mut then_branch_scope);\n+            compute_expr_scopes(then_branch, body, scopes, &mut then_branch_scope);\n+            if let Some(else_branch) = else_branch {\n+                compute_expr_scopes(else_branch, body, scopes, scope);\n+            }\n+        }\n+        &Expr::Let { pat, expr } => {\n+            compute_expr_scopes(expr, body, scopes, scope);\n+            *scope = scopes.new_scope(*scope);\n+            scopes.add_bindings(body, *scope, pat);\n+        }\n+        e => e.walk_child_exprs(|e| compute_expr_scopes(e, body, scopes, scope)),\n+    };\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use base_db::{fixture::WithFixture, FileId, SourceDatabase};\n+    use hir_expand::{name::AsName, InFile};\n+    use syntax::{algo::find_node_at_offset, ast, AstNode};\n+    use test_utils::{assert_eq_text, extract_offset};\n+\n+    use crate::{db::DefDatabase, test_db::TestDB, FunctionId, ModuleDefId};\n+\n+    fn find_function(db: &TestDB, file_id: FileId) -> FunctionId {\n+        let krate = db.test_crate();\n+        let crate_def_map = db.crate_def_map(krate);\n+\n+        let module = crate_def_map.modules_for_file(file_id).next().unwrap();\n+        let (_, def) = crate_def_map[module].scope.entries().next().unwrap();\n+        match def.take_values().unwrap() {\n+            ModuleDefId::FunctionId(it) => it,\n+            _ => panic!(),\n+        }\n+    }\n+\n+    fn do_check(ra_fixture: &str, expected: &[&str]) {\n+        let (offset, code) = extract_offset(ra_fixture);\n+        let code = {\n+            let mut buf = String::new();\n+            let off: usize = offset.into();\n+            buf.push_str(&code[..off]);\n+            buf.push_str(\"$0marker\");\n+            buf.push_str(&code[off..]);\n+            buf\n+        };\n+\n+        let (db, position) = TestDB::with_position(&code);\n+        let file_id = position.file_id;\n+        let offset = position.offset;\n+\n+        let file_syntax = db.parse(file_id).syntax_node();\n+        let marker: ast::PathExpr = find_node_at_offset(&file_syntax, offset).unwrap();\n+        let function = find_function(&db, file_id);\n+\n+        let scopes = db.expr_scopes(function.into());\n+        let (_body, source_map) = db.body_with_source_map(function.into());\n+\n+        let expr_id = source_map\n+            .node_expr(InFile { file_id: file_id.into(), value: &marker.into() })\n+            .unwrap();\n+        let scope = scopes.scope_for(expr_id);\n+\n+        let actual = scopes\n+            .scope_chain(scope)\n+            .flat_map(|scope| scopes.entries(scope))\n+            .map(|it| it.name().to_smol_str())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        let expected = expected.join(\"\\n\");\n+        assert_eq_text!(&expected, &actual);\n+    }\n+\n+    #[test]\n+    fn test_lambda_scope() {\n+        do_check(\n+            r\"\n+            fn quux(foo: i32) {\n+                let f = |bar, baz: i32| {\n+                    $0\n+                };\n+            }\",\n+            &[\"bar\", \"baz\", \"foo\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                f(|x| $0 );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_method_call_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                z.f(|x| $0 );\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_loop_scope() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                loop {\n+                    let x = ();\n+                    $0\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_match() {\n+        do_check(\n+            r\"\n+            fn quux() {\n+                match () {\n+                    Some(x) => {\n+                        $0\n+                    }\n+                };\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_shadow_variable() {\n+        do_check(\n+            r\"\n+            fn foo(x: String) {\n+                let x : &str = &x$0;\n+            }\",\n+            &[\"x\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_bindings_after_at() {\n+        do_check(\n+            r\"\n+fn foo() {\n+    match Some(()) {\n+        opt @ Some(unit) => {\n+            $0\n+        }\n+        _ => {}\n+    }\n+}\n+\",\n+            &[\"opt\", \"unit\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn macro_inner_item() {\n+        do_check(\n+            r\"\n+            macro_rules! mac {\n+                () => {{\n+                    fn inner() {}\n+                    inner();\n+                }};\n+            }\n+\n+            fn foo() {\n+                mac!();\n+                $0\n+            }\n+        \",\n+            &[],\n+        );\n+    }\n+\n+    #[test]\n+    fn broken_inner_item() {\n+        do_check(\n+            r\"\n+            fn foo() {\n+                trait {}\n+                $0\n+            }\n+        \",\n+            &[],\n+        );\n+    }\n+\n+    fn do_check_local_name(ra_fixture: &str, expected_offset: u32) {\n+        let (db, position) = TestDB::with_position(ra_fixture);\n+        let file_id = position.file_id;\n+        let offset = position.offset;\n+\n+        let file = db.parse(file_id).ok().unwrap();\n+        let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n+            .expect(\"failed to find a name at the target offset\");\n+        let name_ref: ast::NameRef = find_node_at_offset(file.syntax(), offset).unwrap();\n+\n+        let function = find_function(&db, file_id);\n+\n+        let scopes = db.expr_scopes(function.into());\n+        let (_body, source_map) = db.body_with_source_map(function.into());\n+\n+        let expr_scope = {\n+            let expr_ast = name_ref.syntax().ancestors().find_map(ast::Expr::cast).unwrap();\n+            let expr_id =\n+                source_map.node_expr(InFile { file_id: file_id.into(), value: &expr_ast }).unwrap();\n+            scopes.scope_for(expr_id).unwrap()\n+        };\n+\n+        let resolved = scopes.resolve_name_in_scope(expr_scope, &name_ref.as_name()).unwrap();\n+        let pat_src = source_map.pat_syntax(resolved.pat()).unwrap();\n+\n+        let local_name = pat_src.value.either(\n+            |it| it.syntax_node_ptr().to_node(file.syntax()),\n+            |it| it.syntax_node_ptr().to_node(file.syntax()),\n+        );\n+        assert_eq!(local_name.text_range(), expected_name.syntax().text_range());\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name() {\n+        do_check_local_name(\n+            r#\"\n+fn foo(x: i32, y: u32) {\n+    {\n+        let z = x * 2;\n+    }\n+    {\n+        let t = x$0 * 3;\n+    }\n+}\n+\"#,\n+            7,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_declaration() {\n+        do_check_local_name(\n+            r#\"\n+fn foo(x: String) {\n+    let x : &str = &x$0;\n+}\n+\"#,\n+            7,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_resolve_local_name_shadow() {\n+        do_check_local_name(\n+            r\"\n+fn foo(x: String) {\n+    let x : &str = &x;\n+    x$0\n+}\n+\",\n+            28,\n+        );\n+    }\n+\n+    #[test]\n+    fn ref_patterns_contribute_bindings() {\n+        do_check_local_name(\n+            r\"\n+fn foo() {\n+    if let Some(&from) = bar() {\n+        from$0;\n+    }\n+}\n+\",\n+            28,\n+        );\n+    }\n+\n+    #[test]\n+    fn while_let_adds_binding() {\n+        do_check_local_name(\n+            r#\"\n+fn test() {\n+    let foo: Option<f32> = None;\n+    while let Option::Some(spam) = foo {\n+        spam$0\n+    }\n+}\n+\"#,\n+            75,\n+        );\n+        do_check_local_name(\n+            r#\"\n+fn test() {\n+    let foo: Option<f32> = None;\n+    while (((let Option::Some(_) = foo))) && let Option::Some(spam) = foo {\n+        spam$0\n+    }\n+}\n+\"#,\n+            107,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_guard_if_let() {\n+        do_check_local_name(\n+            r#\"\n+fn test() {\n+    let foo: Option<f32> = None;\n+    match foo {\n+        _ if let Option::Some(spam) = foo => spam$0,\n+    }\n+}\n+\"#,\n+            93,\n+        );\n+    }\n+\n+    #[test]\n+    fn let_chains_can_reference_previous_lets() {\n+        do_check_local_name(\n+            r#\"\n+fn test() {\n+    let foo: Option<i32> = None;\n+    if let Some(spam) = foo && spa$0m > 1 && let Some(spam) = foo && spam > 1 {}\n+}\n+\"#,\n+            61,\n+        );\n+        do_check_local_name(\n+            r#\"\n+fn test() {\n+    let foo: Option<i32> = None;\n+    if let Some(spam) = foo && spam > 1 && let Some(spam) = foo && sp$0am > 1 {}\n+}\n+\"#,\n+            100,\n+        );\n+    }\n+}"}, {"sha": "c9601f855273799ff127cbefa467cb81990a2205", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/tests.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,127 @@\n+mod block;\n+\n+use base_db::{fixture::WithFixture, SourceDatabase};\n+use expect_test::Expect;\n+\n+use crate::ModuleDefId;\n+\n+use super::*;\n+\n+fn lower(ra_fixture: &str) -> Arc<Body> {\n+    let db = crate::test_db::TestDB::with_files(ra_fixture);\n+\n+    let krate = db.crate_graph().iter().next().unwrap();\n+    let def_map = db.crate_def_map(krate);\n+    let mut fn_def = None;\n+    'outer: for (_, module) in def_map.modules() {\n+        for decl in module.scope.declarations() {\n+            if let ModuleDefId::FunctionId(it) = decl {\n+                fn_def = Some(it);\n+                break 'outer;\n+            }\n+        }\n+    }\n+\n+    db.body(fn_def.unwrap().into())\n+}\n+\n+fn block_def_map_at(ra_fixture: &str) -> String {\n+    let (db, position) = crate::test_db::TestDB::with_position(ra_fixture);\n+\n+    let module = db.module_at_position(position);\n+    module.def_map(&db).dump(&db)\n+}\n+\n+fn check_block_scopes_at(ra_fixture: &str, expect: Expect) {\n+    let (db, position) = crate::test_db::TestDB::with_position(ra_fixture);\n+\n+    let module = db.module_at_position(position);\n+    let actual = module.def_map(&db).dump_block_scopes(&db);\n+    expect.assert_eq(&actual);\n+}\n+\n+fn check_at(ra_fixture: &str, expect: Expect) {\n+    let actual = block_def_map_at(ra_fixture);\n+    expect.assert_eq(&actual);\n+}\n+\n+#[test]\n+fn your_stack_belongs_to_me() {\n+    cov_mark::check!(your_stack_belongs_to_me);\n+    lower(\n+        r#\"\n+macro_rules! n_nuple {\n+    ($e:tt) => ();\n+    ($($rest:tt)*) => {{\n+        (n_nuple!($($rest)*)None,)\n+    }};\n+}\n+fn main() { n_nuple!(1,2,3); }\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn recursion_limit() {\n+    cov_mark::check!(your_stack_belongs_to_me);\n+\n+    lower(\n+        r#\"\n+#![recursion_limit = \"2\"]\n+macro_rules! n_nuple {\n+    ($e:tt) => ();\n+    ($first:tt $($rest:tt)*) => {{\n+        n_nuple!($($rest)*)\n+    }};\n+}\n+fn main() { n_nuple!(1,2,3); }\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn issue_3642_bad_macro_stackover() {\n+    lower(\n+        r#\"\n+#[macro_export]\n+macro_rules! match_ast {\n+    (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };\n+\n+    (match ($node:expr) {\n+        $( ast::$ast:ident($it:ident) => $res:expr, )*\n+        _ => $catch_all:expr $(,)?\n+    }) => {{\n+        $( if let Some($it) = ast::$ast::cast($node.clone()) { $res } else )*\n+        { $catch_all }\n+    }};\n+}\n+\n+fn main() {\n+    let anchor = match_ast! {\n+        match parent {\n+            as => {},\n+            _ => return None\n+        }\n+    };\n+}\"#,\n+    );\n+}\n+\n+#[test]\n+fn macro_resolve() {\n+    // Regression test for a path resolution bug introduced with inner item handling.\n+    lower(\n+        r#\"\n+macro_rules! vec {\n+    () => { () };\n+    ($elem:expr; $n:expr) => { () };\n+    ($($x:expr),+ $(,)?) => { () };\n+}\n+mod m {\n+    fn outer() {\n+        let _ = vec![FileSet::default(); self.len()];\n+    }\n+}\n+\"#,\n+    );\n+}"}, {"sha": "3bba08cfcce48bded7405a0473f6219534230890", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/tests/block.rs", "status": "added", "additions": 397, "deletions": 0, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests%2Fblock.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,397 @@\n+use super::*;\n+use expect_test::expect;\n+\n+#[test]\n+fn inner_item_smoke() {\n+    check_at(\n+        r#\"\n+struct inner {}\n+fn outer() {\n+    $0\n+    fn inner() {}\n+}\n+\"#,\n+        expect![[r#\"\n+            block scope\n+            inner: v\n+\n+            crate\n+            inner: t\n+            outer: v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn use_from_crate() {\n+    check_at(\n+        r#\"\n+struct Struct {}\n+fn outer() {\n+    fn Struct() {}\n+    use Struct as PlainStruct;\n+    use crate::Struct as CrateStruct;\n+    use self::Struct as SelfStruct;\n+    use super::Struct as SuperStruct;\n+    $0\n+}\n+\"#,\n+        expect![[r#\"\n+            block scope\n+            CrateStruct: t\n+            PlainStruct: t v\n+            SelfStruct: t\n+            Struct: v\n+            SuperStruct: _\n+\n+            crate\n+            Struct: t\n+            outer: v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn merge_namespaces() {\n+    check_at(\n+        r#\"\n+struct name {}\n+fn outer() {\n+    fn name() {}\n+\n+    use name as imported; // should import both `name`s\n+\n+    $0\n+}\n+\"#,\n+        expect![[r#\"\n+            block scope\n+            imported: t v\n+            name: v\n+\n+            crate\n+            name: t\n+            outer: v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn nested_blocks() {\n+    check_at(\n+        r#\"\n+fn outer() {\n+    struct inner1 {}\n+    fn inner() {\n+        use inner1;\n+        use outer;\n+        fn inner2() {}\n+        $0\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            block scope\n+            inner1: t\n+            inner2: v\n+            outer: v\n+\n+            block scope\n+            inner: v\n+            inner1: t\n+\n+            crate\n+            outer: v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn super_imports() {\n+    check_at(\n+        r#\"\n+mod module {\n+    fn f() {\n+        use super::Struct;\n+        $0\n+    }\n+}\n+\n+struct Struct {}\n+\"#,\n+        expect![[r#\"\n+            block scope\n+            Struct: t\n+\n+            crate\n+            Struct: t\n+            module: t\n+\n+            crate::module\n+            f: v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn nested_module_scoping() {\n+    check_block_scopes_at(\n+        r#\"\n+fn f() {\n+    mod module {\n+        struct Struct {}\n+        fn f() {\n+            use self::Struct;\n+            $0\n+        }\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+            BlockId(1) in ModuleId { krate: CrateId(0), block: Some(BlockId(0)), local_id: Idx::<ModuleData>(1) }\n+            BlockId(0) in ModuleId { krate: CrateId(0), block: None, local_id: Idx::<ModuleData>(0) }\n+            crate scope\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn legacy_macro_items() {\n+    // Checks that legacy-scoped `macro_rules!` from parent namespaces are resolved and expanded\n+    // correctly.\n+    check_at(\n+        r#\"\n+macro_rules! mark {\n+    () => {\n+        struct Hit {}\n+    }\n+}\n+\n+fn f() {\n+    mark!();\n+    $0\n+}\n+\"#,\n+        expect![[r#\"\n+            block scope\n+            Hit: t\n+\n+            crate\n+            f: v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn macro_resolve() {\n+    check_at(\n+        r#\"\n+//- /lib.rs crate:lib deps:core\n+use core::cov_mark;\n+\n+fn f() {\n+    fn nested() {\n+        cov_mark::mark!(Hit);\n+        $0\n+    }\n+}\n+//- /core.rs crate:core\n+pub mod cov_mark {\n+    #[macro_export]\n+    macro_rules! _mark {\n+        ($name:ident) => {\n+            struct $name {}\n+        }\n+    }\n+\n+    pub use crate::_mark as mark;\n+}\n+\"#,\n+        expect![[r#\"\n+            block scope\n+            Hit: t\n+\n+            block scope\n+            nested: v\n+\n+            crate\n+            cov_mark: t\n+            f: v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn macro_resolve_legacy() {\n+    check_at(\n+        r#\"\n+//- /lib.rs\n+mod module;\n+\n+//- /module.rs\n+macro_rules! m {\n+    () => {\n+        struct Def {}\n+    };\n+}\n+\n+fn f() {\n+    {\n+        m!();\n+        $0\n+    }\n+}\n+        \"#,\n+        expect![[r#\"\n+            block scope\n+            Def: t\n+\n+            crate\n+            module: t\n+\n+            crate::module\n+            f: v\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn super_does_not_resolve_to_block_module() {\n+    check_at(\n+        r#\"\n+fn main() {\n+    struct Struct {}\n+    mod module {\n+        use super::Struct;\n+\n+        $0\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+        block scope\n+        Struct: t\n+        module: t\n+\n+        block scope::module\n+        Struct: _\n+\n+        crate\n+        main: v\n+    \"#]],\n+    );\n+}\n+\n+#[test]\n+fn underscore_import() {\n+    // This used to panic, because the default (private) visibility inside block expressions would\n+    // point into the containing `DefMap`, which visibilities should never be able to do.\n+    cov_mark::check!(adjust_vis_in_block_def_map);\n+    check_at(\n+        r#\"\n+mod m {\n+    fn main() {\n+        use Tr as _;\n+        trait Tr {}\n+        $0\n+    }\n+}\n+    \"#,\n+        expect![[r#\"\n+        block scope\n+        _: t\n+        Tr: t\n+\n+        crate\n+        m: t\n+\n+        crate::m\n+        main: v\n+    \"#]],\n+    );\n+}\n+\n+#[test]\n+fn nested_macro_item_decl() {\n+    cov_mark::check!(macro_call_in_macro_stmts_is_added_to_item_tree);\n+    check_at(\n+        r#\"\n+macro_rules! inner_declare {\n+    ($ident:ident) => {\n+        static $ident: u32 = 0;\n+    };\n+}\n+macro_rules! declare {\n+    ($ident:ident) => {\n+        inner_declare!($ident);\n+    };\n+}\n+\n+fn foo() {\n+    declare!(bar);\n+    bar;\n+    $0\n+}\n+        \"#,\n+        expect![[r#\"\n+            block scope\n+            bar: v\n+\n+            crate\n+            foo: v\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn is_visible_from_same_def_map() {\n+    // Regression test for https://github.com/rust-lang/rust-analyzer/issues/9481\n+    cov_mark::check!(is_visible_from_same_block_def_map);\n+    check_at(\n+        r#\"\n+fn outer() {\n+    mod tests {\n+        use super::*;\n+    }\n+    use crate::name;\n+    $0\n+}\n+        \"#,\n+        expect![[r#\"\n+            block scope\n+            name: _\n+            tests: t\n+\n+            block scope::tests\n+            name: _\n+            outer: v\n+\n+            crate\n+            outer: v\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn stmt_macro_expansion_with_trailing_expr() {\n+    cov_mark::check!(macro_stmt_with_trailing_macro_expr);\n+    check_at(\n+        r#\"\n+macro_rules! mac {\n+    () => { mac!($) };\n+    ($x:tt) => { fn inner() {} };\n+}\n+fn foo() {\n+    mac!();\n+    $0\n+}\n+        \"#,\n+        expect![[r#\"\n+            block scope\n+            inner: v\n+\n+            crate\n+            foo: v\n+        \"#]],\n+    )\n+}"}, {"sha": "0e7ce5f85f96639f1ba3f962f26c621122653451", "filename": "src/tools/rust-analyzer/crates/hir-def/src/builtin_attr.rs", "status": "added", "additions": 654, "deletions": 0, "changes": 654, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_attr.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,654 @@\n+//! Builtin attributes resolved by nameres.\n+//!\n+//! The actual definitions were copied from rustc's `compiler/rustc_feature/src/builtin_attrs.rs`.\n+//!\n+//! It was last synchronized with upstream commit c1a2db3372a4d6896744919284f3287650a38ab7.\n+//!\n+//! The macros were adjusted to only expand to the attribute name, since that is all we need to do\n+//! name resolution, and `BUILTIN_ATTRIBUTES` is almost entirely unchanged from the original, to\n+//! ease updating.\n+\n+use once_cell::sync::OnceCell;\n+use rustc_hash::FxHashMap;\n+\n+/// Ignored attribute namespaces used by tools.\n+pub const TOOL_MODULES: &[&str] = &[\"rustfmt\", \"clippy\"];\n+\n+pub struct BuiltinAttribute {\n+    pub name: &'static str,\n+    pub template: AttributeTemplate,\n+}\n+\n+/// A template that the attribute input must match.\n+/// Only top-level shape (`#[attr]` vs `#[attr(...)]` vs `#[attr = ...]`) is considered now.\n+#[derive(Clone, Copy)]\n+pub struct AttributeTemplate {\n+    pub word: bool,\n+    pub list: Option<&'static str>,\n+    pub name_value_str: Option<&'static str>,\n+}\n+\n+pub fn find_builtin_attr_idx(name: &str) -> Option<usize> {\n+    static BUILTIN_LOOKUP_TABLE: OnceCell<FxHashMap<&'static str, usize>> = OnceCell::new();\n+    BUILTIN_LOOKUP_TABLE\n+        .get_or_init(|| {\n+            INERT_ATTRIBUTES.iter().map(|attr| attr.name).enumerate().map(|(a, b)| (b, a)).collect()\n+        })\n+        .get(name)\n+        .copied()\n+}\n+\n+// impl AttributeTemplate {\n+//     const DEFAULT: AttributeTemplate =\n+//         AttributeTemplate { word: false, list: None, name_value_str: None };\n+// }\n+\n+/// A convenience macro for constructing attribute templates.\n+/// E.g., `template!(Word, List: \"description\")` means that the attribute\n+/// supports forms `#[attr]` and `#[attr(description)]`.\n+macro_rules! template {\n+    (Word) => { template!(@ true, None, None) };\n+    (List: $descr: expr) => { template!(@ false, Some($descr), None) };\n+    (NameValueStr: $descr: expr) => { template!(@ false, None, Some($descr)) };\n+    (Word, List: $descr: expr) => { template!(@ true, Some($descr), None) };\n+    (Word, NameValueStr: $descr: expr) => { template!(@ true, None, Some($descr)) };\n+    (List: $descr1: expr, NameValueStr: $descr2: expr) => {\n+        template!(@ false, Some($descr1), Some($descr2))\n+    };\n+    (Word, List: $descr1: expr, NameValueStr: $descr2: expr) => {\n+        template!(@ true, Some($descr1), Some($descr2))\n+    };\n+    (@ $word: expr, $list: expr, $name_value_str: expr) => {\n+        AttributeTemplate {\n+            word: $word, list: $list, name_value_str: $name_value_str\n+        }\n+    };\n+}\n+\n+macro_rules! ungated {\n+    ($attr:ident, $typ:expr, $tpl:expr, $duplicates:expr $(, @only_local: $only_local:expr)? $(,)?) => {\n+        BuiltinAttribute { name: stringify!($attr), template: $tpl }\n+    };\n+}\n+\n+macro_rules! gated {\n+    ($attr:ident, $typ:expr, $tpl:expr, $duplicates:expr $(, @only_local: $only_local:expr)?, $gate:ident, $msg:expr $(,)?) => {\n+        BuiltinAttribute { name: stringify!($attr), template: $tpl }\n+    };\n+    ($attr:ident, $typ:expr, $tpl:expr, $duplicates:expr $(, @only_local: $only_local:expr)?, $msg:expr $(,)?) => {\n+        BuiltinAttribute { name: stringify!($attr), template: $tpl }\n+    };\n+}\n+\n+macro_rules! rustc_attr {\n+    (TEST, $attr:ident, $typ:expr, $tpl:expr, $duplicate:expr $(, @only_local: $only_local:expr)? $(,)?) => {\n+        rustc_attr!(\n+            $attr,\n+            $typ,\n+            $tpl,\n+            $duplicate,\n+            $(@only_local: $only_local,)?\n+            concat!(\n+                \"the `#[\",\n+                stringify!($attr),\n+                \"]` attribute is just used for rustc unit tests \\\n+                and will never be stable\",\n+            ),\n+        )\n+    };\n+    ($attr:ident, $typ:expr, $tpl:expr, $duplicates:expr $(, @only_local: $only_local:expr)?, $msg:expr $(,)?) => {\n+        BuiltinAttribute { name: stringify!($attr), template: $tpl }\n+    };\n+}\n+\n+#[allow(unused_macros)]\n+macro_rules! experimental {\n+    ($attr:ident) => {\n+        concat!(\"the `#[\", stringify!($attr), \"]` attribute is an experimental feature\")\n+    };\n+}\n+\n+/// \"Inert\" built-in attributes that have a special meaning to rustc or rustdoc.\n+#[rustfmt::skip]\n+pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n+    // ==========================================================================\n+    // Stable attributes:\n+    // ==========================================================================\n+\n+    // Conditional compilation:\n+    ungated!(cfg, Normal, template!(List: \"predicate\"), DuplicatesOk),\n+    ungated!(cfg_attr, Normal, template!(List: \"predicate, attr1, attr2, ...\"), DuplicatesOk),\n+\n+    // Testing:\n+    ungated!(ignore, Normal, template!(Word, NameValueStr: \"reason\"), WarnFollowing),\n+    ungated!(\n+        should_panic, Normal,\n+        template!(Word, List: r#\"expected = \"reason\"#, NameValueStr: \"reason\"), FutureWarnFollowing,\n+    ),\n+    // FIXME(Centril): This can be used on stable but shouldn't.\n+    ungated!(reexport_test_harness_main, CrateLevel, template!(NameValueStr: \"name\"), ErrorFollowing),\n+\n+    // Macros:\n+    ungated!(automatically_derived, Normal, template!(Word), WarnFollowing),\n+    ungated!(macro_use, Normal, template!(Word, List: \"name1, name2, ...\"), WarnFollowingWordOnly),\n+    ungated!(macro_escape, Normal, template!(Word), WarnFollowing), // Deprecated synonym for `macro_use`.\n+    ungated!(macro_export, Normal, template!(Word, List: \"local_inner_macros\"), WarnFollowing),\n+    ungated!(proc_macro, Normal, template!(Word), ErrorFollowing),\n+    ungated!(\n+        proc_macro_derive, Normal,\n+        template!(List: \"TraitName, /*opt*/ attributes(name1, name2, ...)\"), ErrorFollowing,\n+    ),\n+    ungated!(proc_macro_attribute, Normal, template!(Word), ErrorFollowing),\n+\n+    // Lints:\n+    ungated!(\n+        warn, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk\n+    ),\n+    ungated!(\n+        allow, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk\n+    ),\n+    gated!(\n+        expect, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk,\n+        lint_reasons, experimental!(expect)\n+    ),\n+    ungated!(\n+        forbid, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk\n+    ),\n+    ungated!(\n+        deny, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk\n+    ),\n+    ungated!(must_use, Normal, template!(Word, NameValueStr: \"reason\"), FutureWarnFollowing),\n+    gated!(\n+        must_not_suspend, Normal, template!(Word, NameValueStr: \"reason\"), WarnFollowing,\n+        experimental!(must_not_suspend)\n+    ),\n+    ungated!(\n+        deprecated, Normal,\n+        template!(\n+            Word,\n+            List: r#\"/*opt*/ since = \"version\", /*opt*/ note = \"reason\"\"#,\n+            NameValueStr: \"reason\"\n+        ),\n+        ErrorFollowing\n+    ),\n+\n+    // Crate properties:\n+    ungated!(crate_name, CrateLevel, template!(NameValueStr: \"name\"), FutureWarnFollowing),\n+    ungated!(crate_type, CrateLevel, template!(NameValueStr: \"bin|lib|...\"), DuplicatesOk),\n+    // crate_id is deprecated\n+    ungated!(crate_id, CrateLevel, template!(NameValueStr: \"ignored\"), FutureWarnFollowing),\n+\n+    // ABI, linking, symbols, and FFI\n+    ungated!(\n+        link, Normal,\n+        template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ wasm_import_module = \"...\"\"#),\n+        DuplicatesOk,\n+    ),\n+    ungated!(link_name, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n+    ungated!(no_link, Normal, template!(Word), WarnFollowing),\n+    ungated!(repr, Normal, template!(List: \"C\"), DuplicatesOk),\n+    ungated!(export_name, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n+    ungated!(link_section, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n+    ungated!(no_mangle, Normal, template!(Word), WarnFollowing, @only_local: true),\n+    ungated!(used, Normal, template!(Word, List: \"compiler|linker\"), WarnFollowing, @only_local: true),\n+\n+    // Limits:\n+    ungated!(recursion_limit, CrateLevel, template!(NameValueStr: \"N\"), FutureWarnFollowing),\n+    ungated!(type_length_limit, CrateLevel, template!(NameValueStr: \"N\"), FutureWarnFollowing),\n+    gated!(\n+        const_eval_limit, CrateLevel, template!(NameValueStr: \"N\"), ErrorFollowing,\n+        const_eval_limit, experimental!(const_eval_limit)\n+    ),\n+    gated!(\n+        move_size_limit, CrateLevel, template!(NameValueStr: \"N\"), ErrorFollowing,\n+        large_assignments, experimental!(move_size_limit)\n+    ),\n+\n+    // Entry point:\n+    ungated!(start, Normal, template!(Word), WarnFollowing),\n+    ungated!(no_start, CrateLevel, template!(Word), WarnFollowing),\n+    ungated!(no_main, CrateLevel, template!(Word), WarnFollowing),\n+\n+    // Modules, prelude, and resolution:\n+    ungated!(path, Normal, template!(NameValueStr: \"file\"), FutureWarnFollowing),\n+    ungated!(no_std, CrateLevel, template!(Word), WarnFollowing),\n+    ungated!(no_implicit_prelude, Normal, template!(Word), WarnFollowing),\n+    ungated!(non_exhaustive, Normal, template!(Word), WarnFollowing),\n+\n+    // Runtime\n+    ungated!(\n+        windows_subsystem, CrateLevel,\n+        template!(NameValueStr: \"windows|console\"), FutureWarnFollowing\n+    ),\n+    ungated!(panic_handler, Normal, template!(Word), WarnFollowing), // RFC 2070\n+\n+    // Code generation:\n+    ungated!(inline, Normal, template!(Word, List: \"always|never\"), FutureWarnFollowing, @only_local: true),\n+    ungated!(cold, Normal, template!(Word), WarnFollowing, @only_local: true),\n+    ungated!(no_builtins, CrateLevel, template!(Word), WarnFollowing),\n+    ungated!(target_feature, Normal, template!(List: r#\"enable = \"name\"\"#), DuplicatesOk),\n+    ungated!(track_caller, Normal, template!(Word), WarnFollowing),\n+    gated!(\n+        no_sanitize, Normal,\n+        template!(List: \"address, memory, thread\"), DuplicatesOk,\n+        experimental!(no_sanitize)\n+    ),\n+    gated!(no_coverage, Normal, template!(Word), WarnFollowing, experimental!(no_coverage)),\n+\n+    ungated!(\n+        doc, Normal, template!(List: \"hidden|inline|...\", NameValueStr: \"string\"), DuplicatesOk\n+    ),\n+\n+    // ==========================================================================\n+    // Unstable attributes:\n+    // ==========================================================================\n+\n+    // RFC #3191: #[debugger_visualizer] support\n+    gated!(\n+        debugger_visualizer, Normal, template!(List: r#\"natvis_file = \"...\", gdb_script_file = \"...\"\"#),\n+        DuplicatesOk, experimental!(debugger_visualizer)\n+    ),\n+\n+    // Linking:\n+    gated!(naked, Normal, template!(Word), WarnFollowing, @only_local: true, naked_functions, experimental!(naked)),\n+    gated!(\n+        link_ordinal, Normal, template!(List: \"ordinal\"), ErrorPreceding, raw_dylib,\n+        experimental!(link_ordinal)\n+    ),\n+\n+    // Plugins:\n+    // XXX Modified for use in rust-analyzer\n+    // BuiltinAttribute {\n+    //     name: sym::plugin,\n+    //     only_local: false,\n+    //     type_: CrateLevel,\n+    //     template: template!(List: \"name\"),\n+    //     duplicates: DuplicatesOk,\n+    //     gate: Gated(\n+    //         Stability::Deprecated(\n+    //             \"https://github.com/rust-lang/rust/pull/64675\",\n+    //             Some(\"may be removed in a future compiler version\"),\n+    //         ),\n+    //         sym::plugin,\n+    //         \"compiler plugins are deprecated\",\n+    //         cfg_fn!(plugin)\n+    //     ),\n+    // },\n+    BuiltinAttribute {\n+        name: \"plugin\",\n+        template: template!(List: \"name\"),\n+    },\n+\n+    // Testing:\n+    gated!(\n+        test_runner, CrateLevel, template!(List: \"path\"), ErrorFollowing, custom_test_frameworks,\n+        \"custom test frameworks are an unstable feature\",\n+    ),\n+    // RFC #1268\n+    gated!(\n+        marker, Normal, template!(Word), WarnFollowing, marker_trait_attr, experimental!(marker)\n+    ),\n+    gated!(\n+        thread_local, Normal, template!(Word), WarnFollowing,\n+        \"`#[thread_local]` is an experimental feature, and does not currently handle destructors\",\n+    ),\n+    gated!(no_core, CrateLevel, template!(Word), WarnFollowing, experimental!(no_core)),\n+    // RFC 2412\n+    gated!(\n+        optimize, Normal, template!(List: \"size|speed\"), ErrorPreceding, optimize_attribute,\n+        experimental!(optimize),\n+    ),\n+    // RFC 2867\n+    gated!(\n+        instruction_set, Normal, template!(List: \"set\"), ErrorPreceding,\n+        isa_attribute, experimental!(instruction_set)\n+    ),\n+\n+    gated!(\n+        ffi_returns_twice, Normal, template!(Word), WarnFollowing, experimental!(ffi_returns_twice)\n+    ),\n+    gated!(ffi_pure, Normal, template!(Word), WarnFollowing, experimental!(ffi_pure)),\n+    gated!(ffi_const, Normal, template!(Word), WarnFollowing, experimental!(ffi_const)),\n+    gated!(\n+        register_attr, CrateLevel, template!(List: \"attr1, attr2, ...\"), DuplicatesOk,\n+        experimental!(register_attr),\n+    ),\n+    gated!(\n+        register_tool, CrateLevel, template!(List: \"tool1, tool2, ...\"), DuplicatesOk,\n+        experimental!(register_tool),\n+    ),\n+\n+    gated!(\n+        cmse_nonsecure_entry, Normal, template!(Word), WarnFollowing,\n+        experimental!(cmse_nonsecure_entry)\n+    ),\n+    // RFC 2632\n+    gated!(\n+        const_trait, Normal, template!(Word), WarnFollowing, const_trait_impl,\n+        \"`const` is a temporary placeholder for marking a trait that is suitable for `const` \\\n+        `impls` and all default bodies as `const`, which may be removed or renamed in the \\\n+        future.\"\n+    ),\n+    // lang-team MCP 147\n+    gated!(\n+        deprecated_safe, Normal, template!(List: r#\"since = \"version\", note = \"...\"\"#), ErrorFollowing,\n+        experimental!(deprecated_safe),\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes: Stability, deprecation, and unsafe:\n+    // ==========================================================================\n+\n+    ungated!(feature, CrateLevel, template!(List: \"name1, name2, ...\"), DuplicatesOk),\n+    // DuplicatesOk since it has its own validation\n+    ungated!(\n+        stable, Normal, template!(List: r#\"feature = \"name\", since = \"version\"\"#), DuplicatesOk,\n+    ),\n+    ungated!(\n+        unstable, Normal,\n+        template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#), DuplicatesOk,\n+    ),\n+    ungated!(rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n+    ungated!(rustc_const_stable, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n+    gated!(\n+        allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"), DuplicatesOk,\n+        \"allow_internal_unstable side-steps feature gating and stability checks\",\n+    ),\n+    gated!(\n+        rustc_allow_const_fn_unstable, Normal,\n+        template!(Word, List: \"feat1, feat2, ...\"), DuplicatesOk,\n+        \"rustc_allow_const_fn_unstable side-steps feature gating and stability checks\"\n+    ),\n+    gated!(\n+        allow_internal_unsafe, Normal, template!(Word), WarnFollowing,\n+        \"allow_internal_unsafe side-steps the unsafe_code lint\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes: Type system related:\n+    // ==========================================================================\n+\n+    gated!(fundamental, Normal, template!(Word), WarnFollowing, experimental!(fundamental)),\n+    gated!(\n+        may_dangle, Normal, template!(Word), WarnFollowing, dropck_eyepatch,\n+        \"`may_dangle` has unstable semantics and may be removed in the future\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes: Runtime related:\n+    // ==========================================================================\n+\n+    rustc_attr!(rustc_allocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n+    rustc_attr!(rustc_allocator_nounwind, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n+    gated!(\n+        alloc_error_handler, Normal, template!(Word), WarnFollowing,\n+        experimental!(alloc_error_handler)\n+    ),\n+    gated!(\n+        default_lib_allocator, Normal, template!(Word), WarnFollowing, allocator_internals,\n+        experimental!(default_lib_allocator),\n+    ),\n+    gated!(\n+        needs_allocator, Normal, template!(Word), WarnFollowing, allocator_internals,\n+        experimental!(needs_allocator),\n+    ),\n+    gated!(panic_runtime, Normal, template!(Word), WarnFollowing, experimental!(panic_runtime)),\n+    gated!(\n+        needs_panic_runtime, Normal, template!(Word), WarnFollowing,\n+        experimental!(needs_panic_runtime)\n+    ),\n+    gated!(\n+        compiler_builtins, Normal, template!(Word), WarnFollowing,\n+        \"the `#[compiler_builtins]` attribute is used to identify the `compiler_builtins` crate \\\n+        which contains compiler-rt intrinsics and will never be stable\",\n+    ),\n+    gated!(\n+        profiler_runtime, Normal, template!(Word), WarnFollowing,\n+        \"the `#[profiler_runtime]` attribute is used to identify the `profiler_builtins` crate \\\n+        which contains the profiler runtime and will never be stable\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Linkage:\n+    // ==========================================================================\n+\n+    gated!(\n+        linkage, Normal, template!(NameValueStr: \"external|internal|...\"), ErrorPreceding, @only_local: true,\n+        \"the `linkage` attribute is experimental and not portable across platforms\",\n+    ),\n+    rustc_attr!(\n+        rustc_std_internal_symbol, Normal, template!(Word), WarnFollowing, @only_local: true, INTERNAL_UNSTABLE\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Macro related:\n+    // ==========================================================================\n+\n+    rustc_attr!(\n+        rustc_builtin_macro, Normal,\n+        template!(Word, List: \"name, /*opt*/ attributes(name1, name2, ...)\"), ErrorFollowing,\n+        IMPL_DETAIL,\n+    ),\n+    rustc_attr!(rustc_proc_macro_decls, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE),\n+    rustc_attr!(\n+        rustc_macro_transparency, Normal,\n+        template!(NameValueStr: \"transparent|semitransparent|opaque\"), ErrorFollowing,\n+        \"used internally for testing macro hygiene\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Diagnostics related:\n+    // ==========================================================================\n+\n+    rustc_attr!(\n+        rustc_on_unimplemented, Normal,\n+        template!(\n+            List: r#\"/*opt*/ message = \"...\", /*opt*/ label = \"...\", /*opt*/ note = \"...\"\"#,\n+            NameValueStr: \"message\"\n+        ),\n+        ErrorFollowing,\n+        INTERNAL_UNSTABLE\n+    ),\n+    // Enumerates \"identity-like\" conversion methods to suggest on type mismatch.\n+    rustc_attr!(\n+        rustc_conversion_suggestion, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE\n+    ),\n+    // Prevents field reads in the marked trait or method to be considered\n+    // during dead code analysis.\n+    rustc_attr!(\n+        rustc_trivial_field_reads, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE\n+    ),\n+    // Used by the `rustc::potential_query_instability` lint to warn methods which\n+    // might not be stable during incremental compilation.\n+    rustc_attr!(rustc_lint_query_instability, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE),\n+    // Used by the `rustc::untranslatable_diagnostic` and `rustc::diagnostic_outside_of_impl` lints\n+    // to assist in changes to diagnostic APIs.\n+    rustc_attr!(rustc_lint_diagnostics, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE),\n+\n+    // ==========================================================================\n+    // Internal attributes, Const related:\n+    // ==========================================================================\n+\n+    rustc_attr!(rustc_promotable, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n+    rustc_attr!(\n+        rustc_legacy_const_generics, Normal, template!(List: \"N\"), ErrorFollowing,\n+        INTERNAL_UNSTABLE\n+    ),\n+    // Do not const-check this function's body. It will always get replaced during CTFE.\n+    rustc_attr!(\n+        rustc_do_not_const_check, Normal, template!(Word), WarnFollowing, INTERNAL_UNSTABLE\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Layout related:\n+    // ==========================================================================\n+\n+    rustc_attr!(\n+        rustc_layout_scalar_valid_range_start, Normal, template!(List: \"value\"), ErrorFollowing,\n+        \"the `#[rustc_layout_scalar_valid_range_start]` attribute is just used to enable \\\n+        niche optimizations in libcore and libstd and will never be stable\",\n+    ),\n+    rustc_attr!(\n+        rustc_layout_scalar_valid_range_end, Normal, template!(List: \"value\"), ErrorFollowing,\n+        \"the `#[rustc_layout_scalar_valid_range_end]` attribute is just used to enable \\\n+        niche optimizations in libcore and libstd and will never be stable\",\n+    ),\n+    rustc_attr!(\n+        rustc_nonnull_optimization_guaranteed, Normal, template!(Word), WarnFollowing,\n+        \"the `#[rustc_nonnull_optimization_guaranteed]` attribute is just used to enable \\\n+        niche optimizations in libcore and libstd and will never be stable\",\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Misc:\n+    // ==========================================================================\n+    gated!(\n+        lang, Normal, template!(NameValueStr: \"name\"), DuplicatesOk, @only_local: true, lang_items,\n+        \"language items are subject to change\",\n+    ),\n+    rustc_attr!(\n+        rustc_pass_by_value, Normal,\n+        template!(Word), ErrorFollowing,\n+        \"#[rustc_pass_by_value] is used to mark types that must be passed by value instead of reference.\"\n+    ),\n+    rustc_attr!(\n+        rustc_coherence_is_core, AttributeType::CrateLevel, template!(Word), ErrorFollowing, @only_local: true,\n+        \"#![rustc_coherence_is_core] allows inherent methods on builtin types, only intended to be used in `core`.\"\n+    ),\n+    rustc_attr!(\n+        rustc_allow_incoherent_impl, AttributeType::Normal, template!(Word), ErrorFollowing, @only_local: true,\n+        \"#[rustc_allow_incoherent_impl] has to be added to all impl items of an incoherent inherent impl.\"\n+    ),\n+    rustc_attr!(\n+        rustc_has_incoherent_inherent_impls, AttributeType::Normal, template!(Word), ErrorFollowing,\n+        \"#[rustc_has_incoherent_inherent_impls] allows the addition of incoherent inherent impls for \\\n+         the given type by annotating all impl items with #[rustc_allow_incoherent_impl].\"\n+    ),\n+    rustc_attr!(\n+        rustc_box, AttributeType::Normal, template!(Word), ErrorFollowing,\n+        \"#[rustc_box] allows creating boxes \\\n+        and it is only intended to be used in `alloc`.\"\n+    ),\n+\n+    // modified for r-a\n+    // BuiltinAttribute {\n+    //     name: sym::rustc_diagnostic_item,\n+    //     // FIXME: This can be `true` once we always use `tcx.is_diagnostic_item`.\n+    //     only_local: false,\n+    //     type_: Normal,\n+    //     template: template!(NameValueStr: \"name\"),\n+    //     duplicates: ErrorFollowing,\n+    //     gate: Gated(\n+    //         Stability::Unstable,\n+    //         sym::rustc_attrs,\n+    //         \"diagnostic items compiler internal support for linting\",\n+    //         cfg_fn!(rustc_attrs),\n+    //     ),\n+    // },\n+    BuiltinAttribute {\n+        name: \"rustc_diagnostic_item\",\n+        template: template!(NameValueStr: \"name\"),\n+    },\n+    gated!(\n+        // Used in resolve:\n+        prelude_import, Normal, template!(Word), WarnFollowing,\n+        \"`#[prelude_import]` is for use by rustc only\",\n+    ),\n+    gated!(\n+        rustc_paren_sugar, Normal, template!(Word), WarnFollowing, unboxed_closures,\n+        \"unboxed_closures are still evolving\",\n+    ),\n+    rustc_attr!(\n+        rustc_inherit_overflow_checks, Normal, template!(Word), WarnFollowing, @only_local: true,\n+        \"the `#[rustc_inherit_overflow_checks]` attribute is just used to control \\\n+        overflow checking behavior of several libcore functions that are inlined \\\n+        across crates and will never be stable\",\n+    ),\n+    rustc_attr!(\n+        rustc_reservation_impl, Normal,\n+        template!(NameValueStr: \"reservation message\"), ErrorFollowing,\n+        \"the `#[rustc_reservation_impl]` attribute is internally used \\\n+         for reserving for `for<T> From<!> for T` impl\"\n+    ),\n+    rustc_attr!(\n+        rustc_test_marker, Normal, template!(Word), WarnFollowing,\n+        \"the `#[rustc_test_marker]` attribute is used internally to track tests\",\n+    ),\n+    rustc_attr!(\n+        rustc_unsafe_specialization_marker, Normal, template!(Word), WarnFollowing,\n+        \"the `#[rustc_unsafe_specialization_marker]` attribute is used to check specializations\"\n+    ),\n+    rustc_attr!(\n+        rustc_specialization_trait, Normal, template!(Word), WarnFollowing,\n+        \"the `#[rustc_specialization_trait]` attribute is used to check specializations\"\n+    ),\n+    rustc_attr!(\n+        rustc_main, Normal, template!(Word), WarnFollowing,\n+        \"the `#[rustc_main]` attribute is used internally to specify test entry point function\",\n+    ),\n+    rustc_attr!(\n+        rustc_skip_array_during_method_dispatch, Normal, template!(Word), WarnFollowing,\n+        \"the `#[rustc_skip_array_during_method_dispatch]` attribute is used to exclude a trait \\\n+        from method dispatch when the receiver is an array, for compatibility in editions < 2021.\"\n+    ),\n+    rustc_attr!(\n+        rustc_must_implement_one_of, Normal, template!(List: \"function1, function2, ...\"), ErrorFollowing,\n+        \"the `#[rustc_must_implement_one_of]` attribute is used to change minimal complete \\\n+        definition of a trait, it's currently in experimental form and should be changed before \\\n+        being exposed outside of the std\"\n+    ),\n+\n+    // ==========================================================================\n+    // Internal attributes, Testing:\n+    // ==========================================================================\n+\n+    rustc_attr!(TEST, rustc_outlives, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_capture_analysis, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_insignificant_dtor, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_strict_coherence, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_variance, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\"), WarnFollowing),\n+    rustc_attr!(TEST, rustc_regions, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(\n+        TEST, rustc_error, Normal,\n+        template!(Word, List: \"delay_span_bug_from_inside_query\"), WarnFollowingWordOnly\n+    ),\n+    rustc_attr!(TEST, rustc_dump_user_substs, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_evaluate_where_clauses, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(\n+        TEST, rustc_if_this_changed, Normal, template!(Word, List: \"DepNode\"), DuplicatesOk\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_then_this_would_need, Normal, template!(List: \"DepNode\"), DuplicatesOk\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_clean, Normal,\n+        template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\", /*opt*/ except = \"...\"\"#),\n+        DuplicatesOk,\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_partition_reused, Normal,\n+        template!(List: r#\"cfg = \"...\", module = \"...\"\"#), DuplicatesOk,\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_partition_codegened, Normal,\n+        template!(List: r#\"cfg = \"...\", module = \"...\"\"#), DuplicatesOk,\n+    ),\n+    rustc_attr!(\n+        TEST, rustc_expected_cgu_reuse, Normal,\n+        template!(List: r#\"cfg = \"...\", module = \"...\", kind = \"...\"\"#), DuplicatesOk,\n+    ),\n+    rustc_attr!(TEST, rustc_symbol_name, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_polymorphize_error, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_def_path, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_mir, Normal, template!(List: \"arg1, arg2, ...\"), DuplicatesOk),\n+    rustc_attr!(TEST, rustc_dump_program_clauses, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_dump_env_program_clauses, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_object_lifetime_default, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_dump_vtable, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_dummy, Normal, template!(Word /* doesn't matter*/), DuplicatesOk),\n+    gated!(\n+        omit_gdb_pretty_printer_section, Normal, template!(Word), WarnFollowing,\n+        \"the `#[omit_gdb_pretty_printer_section]` attribute is just used for the Rust test suite\",\n+    ),\n+];"}, {"sha": "25a408036ff7d70f0968e6e420d71bf1ac096cab", "filename": "src/tools/rust-analyzer/crates/hir-def/src/builtin_type.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,158 @@\n+//! This module defines built-in types.\n+//!\n+//! A peculiarity of built-in types is that they are always available and are\n+//! not associated with any particular crate.\n+\n+use std::fmt;\n+\n+use hir_expand::name::{name, AsName, Name};\n+/// Different signed int types.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum BuiltinInt {\n+    Isize,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n+}\n+\n+/// Different unsigned int types.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum BuiltinUint {\n+    Usize,\n+    U8,\n+    U16,\n+    U32,\n+    U64,\n+    U128,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum BuiltinFloat {\n+    F32,\n+    F64,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum BuiltinType {\n+    Char,\n+    Bool,\n+    Str,\n+    Int(BuiltinInt),\n+    Uint(BuiltinUint),\n+    Float(BuiltinFloat),\n+}\n+\n+impl BuiltinType {\n+    #[rustfmt::skip]\n+    pub const ALL: &'static [(Name, BuiltinType)] = &[\n+        (name![char], BuiltinType::Char),\n+        (name![bool], BuiltinType::Bool),\n+        (name![str],  BuiltinType::Str),\n+\n+        (name![isize], BuiltinType::Int(BuiltinInt::Isize)),\n+        (name![i8],    BuiltinType::Int(BuiltinInt::I8)),\n+        (name![i16],   BuiltinType::Int(BuiltinInt::I16)),\n+        (name![i32],   BuiltinType::Int(BuiltinInt::I32)),\n+        (name![i64],   BuiltinType::Int(BuiltinInt::I64)),\n+        (name![i128],  BuiltinType::Int(BuiltinInt::I128)),\n+\n+        (name![usize], BuiltinType::Uint(BuiltinUint::Usize)),\n+        (name![u8],    BuiltinType::Uint(BuiltinUint::U8)),\n+        (name![u16],   BuiltinType::Uint(BuiltinUint::U16)),\n+        (name![u32],   BuiltinType::Uint(BuiltinUint::U32)),\n+        (name![u64],   BuiltinType::Uint(BuiltinUint::U64)),\n+        (name![u128],  BuiltinType::Uint(BuiltinUint::U128)),\n+\n+        (name![f32], BuiltinType::Float(BuiltinFloat::F32)),\n+        (name![f64], BuiltinType::Float(BuiltinFloat::F64)),\n+    ];\n+\n+    pub fn by_name(name: &Name) -> Option<Self> {\n+        Self::ALL.iter().find_map(|(n, ty)| if n == name { Some(*ty) } else { None })\n+    }\n+}\n+\n+impl AsName for BuiltinType {\n+    fn as_name(&self) -> Name {\n+        match self {\n+            BuiltinType::Char => name![char],\n+            BuiltinType::Bool => name![bool],\n+            BuiltinType::Str => name![str],\n+            BuiltinType::Int(it) => match it {\n+                BuiltinInt::Isize => name![isize],\n+                BuiltinInt::I8 => name![i8],\n+                BuiltinInt::I16 => name![i16],\n+                BuiltinInt::I32 => name![i32],\n+                BuiltinInt::I64 => name![i64],\n+                BuiltinInt::I128 => name![i128],\n+            },\n+            BuiltinType::Uint(it) => match it {\n+                BuiltinUint::Usize => name![usize],\n+                BuiltinUint::U8 => name![u8],\n+                BuiltinUint::U16 => name![u16],\n+                BuiltinUint::U32 => name![u32],\n+                BuiltinUint::U64 => name![u64],\n+                BuiltinUint::U128 => name![u128],\n+            },\n+            BuiltinType::Float(it) => match it {\n+                BuiltinFloat::F32 => name![f32],\n+                BuiltinFloat::F64 => name![f64],\n+            },\n+        }\n+    }\n+}\n+\n+impl fmt::Display for BuiltinType {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let type_name = self.as_name();\n+        type_name.fmt(f)\n+    }\n+}\n+\n+#[rustfmt::skip]\n+impl BuiltinInt {\n+    pub fn from_suffix(suffix: &str) -> Option<BuiltinInt> {\n+        let res = match suffix {\n+            \"isize\" => Self::Isize,\n+            \"i8\"    => Self::I8,\n+            \"i16\"   => Self::I16,\n+            \"i32\"   => Self::I32,\n+            \"i64\"   => Self::I64,\n+            \"i128\"  => Self::I128,\n+\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+#[rustfmt::skip]\n+impl BuiltinUint {\n+    pub fn from_suffix(suffix: &str) -> Option<BuiltinUint> {\n+        let res = match suffix {\n+            \"usize\" => Self::Usize,\n+            \"u8\"    => Self::U8,\n+            \"u16\"   => Self::U16,\n+            \"u32\"   => Self::U32,\n+            \"u64\"   => Self::U64,\n+            \"u128\"  => Self::U128,\n+\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+#[rustfmt::skip]\n+impl BuiltinFloat {\n+    pub fn from_suffix(suffix: &str) -> Option<BuiltinFloat> {\n+        let res = match suffix {\n+            \"f32\" => BuiltinFloat::F32,\n+            \"f64\" => BuiltinFloat::F64,\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+}"}, {"sha": "5b1435e8f44248f121bf079456bbc7d4cbf0c8b9", "filename": "src/tools/rust-analyzer/crates/hir-def/src/child_by_source.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fchild_by_source.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,207 @@\n+//! When *constructing* `hir`, we start at some parent syntax node and recursively\n+//! lower the children.\n+//!\n+//! This modules allows one to go in the opposite direction: start with a syntax\n+//! node for a *child*, and get its hir.\n+\n+use either::Either;\n+use hir_expand::HirFileId;\n+use syntax::ast::HasDocComments;\n+\n+use crate::{\n+    db::DefDatabase,\n+    dyn_map::DynMap,\n+    item_scope::ItemScope,\n+    keys,\n+    src::{HasChildSource, HasSource},\n+    AdtId, AssocItemId, DefWithBodyId, EnumId, EnumVariantId, FieldId, ImplId, Lookup, MacroId,\n+    ModuleDefId, ModuleId, TraitId, VariantId,\n+};\n+\n+pub trait ChildBySource {\n+    fn child_by_source(&self, db: &dyn DefDatabase, file_id: HirFileId) -> DynMap {\n+        let mut res = DynMap::default();\n+        self.child_by_source_to(db, &mut res, file_id);\n+        res\n+    }\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, map: &mut DynMap, file_id: HirFileId);\n+}\n+\n+impl ChildBySource for TraitId {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n+        let data = db.trait_data(*self);\n+\n+        data.attribute_calls().filter(|(ast_id, _)| ast_id.file_id == file_id).for_each(\n+            |(ast_id, call_id)| {\n+                res[keys::ATTR_MACRO_CALL].insert(ast_id.to_node(db.upcast()), call_id);\n+            },\n+        );\n+        data.items.iter().for_each(|&(_, item)| {\n+            add_assoc_item(db, res, file_id, item);\n+        });\n+    }\n+}\n+\n+impl ChildBySource for ImplId {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n+        let data = db.impl_data(*self);\n+        data.attribute_calls().filter(|(ast_id, _)| ast_id.file_id == file_id).for_each(\n+            |(ast_id, call_id)| {\n+                res[keys::ATTR_MACRO_CALL].insert(ast_id.to_node(db.upcast()), call_id);\n+            },\n+        );\n+        data.items.iter().for_each(|&item| {\n+            add_assoc_item(db, res, file_id, item);\n+        });\n+    }\n+}\n+\n+fn add_assoc_item(db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId, item: AssocItemId) {\n+    match item {\n+        AssocItemId::FunctionId(func) => {\n+            let loc = func.lookup(db);\n+            if loc.id.file_id() == file_id {\n+                res[keys::FUNCTION].insert(loc.source(db).value, func)\n+            }\n+        }\n+        AssocItemId::ConstId(konst) => {\n+            let loc = konst.lookup(db);\n+            if loc.id.file_id() == file_id {\n+                res[keys::CONST].insert(loc.source(db).value, konst)\n+            }\n+        }\n+        AssocItemId::TypeAliasId(ty) => {\n+            let loc = ty.lookup(db);\n+            if loc.id.file_id() == file_id {\n+                res[keys::TYPE_ALIAS].insert(loc.source(db).value, ty)\n+            }\n+        }\n+    }\n+}\n+\n+impl ChildBySource for ModuleId {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n+        let def_map = self.def_map(db);\n+        let module_data = &def_map[self.local_id];\n+        module_data.scope.child_by_source_to(db, res, file_id);\n+    }\n+}\n+\n+impl ChildBySource for ItemScope {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n+        self.declarations().for_each(|item| add_module_def(db, res, file_id, item));\n+        self.impls().for_each(|imp| add_impl(db, res, file_id, imp));\n+        self.unnamed_consts().for_each(|konst| {\n+            let loc = konst.lookup(db);\n+            if loc.id.file_id() == file_id {\n+                res[keys::CONST].insert(loc.source(db).value, konst);\n+            }\n+        });\n+        self.attr_macro_invocs().filter(|(id, _)| id.file_id == file_id).for_each(\n+            |(ast_id, call_id)| {\n+                res[keys::ATTR_MACRO_CALL].insert(ast_id.to_node(db.upcast()), call_id);\n+            },\n+        );\n+        self.legacy_macros().for_each(|(_, ids)| {\n+            ids.iter().for_each(|&id| {\n+                if let MacroId::MacroRulesId(id) = id {\n+                    let loc = id.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        res[keys::MACRO_RULES].insert(loc.source(db).value, id);\n+                    }\n+                }\n+            })\n+        });\n+        self.derive_macro_invocs().filter(|(id, _)| id.file_id == file_id).for_each(\n+            |(ast_id, calls)| {\n+                let adt = ast_id.to_node(db.upcast());\n+                calls.for_each(|(attr_id, call_id, calls)| {\n+                    if let Some(Either::Left(attr)) =\n+                        adt.doc_comments_and_attrs().nth(attr_id.ast_index as usize)\n+                    {\n+                        res[keys::DERIVE_MACRO_CALL].insert(attr, (attr_id, call_id, calls.into()));\n+                    }\n+                });\n+            },\n+        );\n+\n+        fn add_module_def(\n+            db: &dyn DefDatabase,\n+            map: &mut DynMap,\n+            file_id: HirFileId,\n+            item: ModuleDefId,\n+        ) {\n+            macro_rules! insert {\n+                ($map:ident[$key:path].$insert:ident($id:ident)) => {{\n+                    let loc = $id.lookup(db);\n+                    if loc.id.file_id() == file_id {\n+                        $map[$key].$insert(loc.source(db).value, $id)\n+                    }\n+                }};\n+            }\n+            match item {\n+                ModuleDefId::FunctionId(id) => insert!(map[keys::FUNCTION].insert(id)),\n+                ModuleDefId::ConstId(id) => insert!(map[keys::CONST].insert(id)),\n+                ModuleDefId::StaticId(id) => insert!(map[keys::STATIC].insert(id)),\n+                ModuleDefId::TypeAliasId(id) => insert!(map[keys::TYPE_ALIAS].insert(id)),\n+                ModuleDefId::TraitId(id) => insert!(map[keys::TRAIT].insert(id)),\n+                ModuleDefId::AdtId(adt) => match adt {\n+                    AdtId::StructId(id) => insert!(map[keys::STRUCT].insert(id)),\n+                    AdtId::UnionId(id) => insert!(map[keys::UNION].insert(id)),\n+                    AdtId::EnumId(id) => insert!(map[keys::ENUM].insert(id)),\n+                },\n+                ModuleDefId::MacroId(id) => match id {\n+                    MacroId::Macro2Id(id) => insert!(map[keys::MACRO2].insert(id)),\n+                    MacroId::MacroRulesId(id) => insert!(map[keys::MACRO_RULES].insert(id)),\n+                    MacroId::ProcMacroId(id) => insert!(map[keys::PROC_MACRO].insert(id)),\n+                },\n+                ModuleDefId::ModuleId(_)\n+                | ModuleDefId::EnumVariantId(_)\n+                | ModuleDefId::BuiltinType(_) => (),\n+            }\n+        }\n+        fn add_impl(db: &dyn DefDatabase, map: &mut DynMap, file_id: HirFileId, imp: ImplId) {\n+            let loc = imp.lookup(db);\n+            if loc.id.file_id() == file_id {\n+                map[keys::IMPL].insert(loc.source(db).value, imp)\n+            }\n+        }\n+    }\n+}\n+\n+impl ChildBySource for VariantId {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, _: HirFileId) {\n+        let arena_map = self.child_source(db);\n+        let arena_map = arena_map.as_ref();\n+        let parent = *self;\n+        for (local_id, source) in arena_map.value.iter() {\n+            let id = FieldId { parent, local_id };\n+            match source.clone() {\n+                Either::Left(source) => res[keys::TUPLE_FIELD].insert(source, id),\n+                Either::Right(source) => res[keys::RECORD_FIELD].insert(source, id),\n+            }\n+        }\n+    }\n+}\n+\n+impl ChildBySource for EnumId {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, _: HirFileId) {\n+        let arena_map = self.child_source(db);\n+        let arena_map = arena_map.as_ref();\n+        for (local_id, source) in arena_map.value.iter() {\n+            let id = EnumVariantId { parent: *self, local_id };\n+            res[keys::VARIANT].insert(source.clone(), id)\n+        }\n+    }\n+}\n+\n+impl ChildBySource for DefWithBodyId {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n+        let body = db.body(*self);\n+        for (_, def_map) in body.blocks(db) {\n+            // All block expressions are merged into the same map, because they logically all add\n+            // inner items to the containing `DefWithBodyId`.\n+            def_map[def_map.root()].scope.child_by_source_to(db, res, file_id);\n+        }\n+    }\n+}"}, {"sha": "4309411419334d4a3bf358f96d15bf145aa07c5c", "filename": "src/tools/rust-analyzer/crates/hir-def/src/data.rs", "status": "added", "additions": 572, "deletions": 0, "changes": 572, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdata.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,572 @@\n+//! Contains basic data about various HIR declarations.\n+\n+use std::sync::Arc;\n+\n+use hir_expand::{name::Name, AstId, ExpandResult, HirFileId, MacroCallId, MacroDefKind};\n+use smallvec::SmallVec;\n+use syntax::ast;\n+\n+use crate::{\n+    attr::Attrs,\n+    body::{Expander, Mark},\n+    db::DefDatabase,\n+    intern::Interned,\n+    item_tree::{self, AssocItem, FnFlags, ItemTree, ItemTreeId, ModItem, Param, TreeId},\n+    nameres::{attr_resolution::ResolvedAttr, DefMap},\n+    type_ref::{TraitRef, TypeBound, TypeRef},\n+    visibility::RawVisibility,\n+    AssocItemId, AstIdWithPath, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n+    Intern, ItemContainerId, ItemLoc, Lookup, Macro2Id, MacroRulesId, ModuleId, ProcMacroId,\n+    StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n+};\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct FunctionData {\n+    pub name: Name,\n+    pub params: Vec<(Option<Name>, Interned<TypeRef>)>,\n+    pub ret_type: Interned<TypeRef>,\n+    pub async_ret_type: Option<Interned<TypeRef>>,\n+    pub attrs: Attrs,\n+    pub visibility: RawVisibility,\n+    pub abi: Option<Interned<str>>,\n+    pub legacy_const_generics_indices: Box<[u32]>,\n+    flags: FnFlags,\n+}\n+\n+impl FunctionData {\n+    pub(crate) fn fn_data_query(db: &dyn DefDatabase, func: FunctionId) -> Arc<FunctionData> {\n+        let loc = func.lookup(db);\n+        let krate = loc.container.module(db).krate;\n+        let crate_graph = db.crate_graph();\n+        let cfg_options = &crate_graph[krate].cfg_options;\n+        let item_tree = loc.id.item_tree(db);\n+        let func = &item_tree[loc.id.value];\n+        let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n+            db.trait_data(trait_id).visibility.clone()\n+        } else {\n+            item_tree[func.visibility].clone()\n+        };\n+\n+        let enabled_params = func\n+            .params\n+            .clone()\n+            .filter(|&param| item_tree.attrs(db, krate, param.into()).is_cfg_enabled(cfg_options));\n+\n+        // If last cfg-enabled param is a `...` param, it's a varargs function.\n+        let is_varargs = enabled_params\n+            .clone()\n+            .next_back()\n+            .map_or(false, |param| matches!(item_tree[param], Param::Varargs));\n+\n+        let mut flags = func.flags;\n+        if is_varargs {\n+            flags |= FnFlags::IS_VARARGS;\n+        }\n+        if flags.contains(FnFlags::HAS_SELF_PARAM) {\n+            // If there's a self param in the syntax, but it is cfg'd out, remove the flag.\n+            let is_cfgd_out = match func.params.clone().next() {\n+                Some(param) => {\n+                    !item_tree.attrs(db, krate, param.into()).is_cfg_enabled(cfg_options)\n+                }\n+                None => {\n+                    stdx::never!(\"fn HAS_SELF_PARAM but no parameters allocated\");\n+                    true\n+                }\n+            };\n+            if is_cfgd_out {\n+                cov_mark::hit!(cfgd_out_self_param);\n+                flags.remove(FnFlags::HAS_SELF_PARAM);\n+            }\n+        }\n+\n+        let legacy_const_generics_indices = item_tree\n+            .attrs(db, krate, ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_legacy_const_generics\")\n+            .tt_values()\n+            .next()\n+            .map(parse_rustc_legacy_const_generics)\n+            .unwrap_or_default();\n+\n+        Arc::new(FunctionData {\n+            name: func.name.clone(),\n+            params: enabled_params\n+                .clone()\n+                .filter_map(|id| match &item_tree[id] {\n+                    Param::Normal(name, ty) => Some((name.clone(), ty.clone())),\n+                    Param::Varargs => None,\n+                })\n+                .collect(),\n+            ret_type: func.ret_type.clone(),\n+            async_ret_type: func.async_ret_type.clone(),\n+            attrs: item_tree.attrs(db, krate, ModItem::from(loc.id.value).into()),\n+            visibility,\n+            abi: func.abi.clone(),\n+            legacy_const_generics_indices,\n+            flags,\n+        })\n+    }\n+\n+    pub fn has_body(&self) -> bool {\n+        self.flags.contains(FnFlags::HAS_BODY)\n+    }\n+\n+    /// True if the first param is `self`. This is relevant to decide whether this\n+    /// can be called as a method.\n+    pub fn has_self_param(&self) -> bool {\n+        self.flags.contains(FnFlags::HAS_SELF_PARAM)\n+    }\n+\n+    pub fn has_default_kw(&self) -> bool {\n+        self.flags.contains(FnFlags::HAS_DEFAULT_KW)\n+    }\n+\n+    pub fn has_const_kw(&self) -> bool {\n+        self.flags.contains(FnFlags::HAS_CONST_KW)\n+    }\n+\n+    pub fn has_async_kw(&self) -> bool {\n+        self.flags.contains(FnFlags::HAS_ASYNC_KW)\n+    }\n+\n+    pub fn has_unsafe_kw(&self) -> bool {\n+        self.flags.contains(FnFlags::HAS_UNSAFE_KW)\n+    }\n+\n+    pub fn is_varargs(&self) -> bool {\n+        self.flags.contains(FnFlags::IS_VARARGS)\n+    }\n+}\n+\n+fn parse_rustc_legacy_const_generics(tt: &tt::Subtree) -> Box<[u32]> {\n+    let mut indices = Vec::new();\n+    for args in tt.token_trees.chunks(2) {\n+        match &args[0] {\n+            tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => match lit.text.parse() {\n+                Ok(index) => indices.push(index),\n+                Err(_) => break,\n+            },\n+            _ => break,\n+        }\n+\n+        if let Some(comma) = args.get(1) {\n+            match comma {\n+                tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if punct.char == ',' => {}\n+                _ => break,\n+            }\n+        }\n+    }\n+\n+    indices.into_boxed_slice()\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TypeAliasData {\n+    pub name: Name,\n+    pub type_ref: Option<Interned<TypeRef>>,\n+    pub visibility: RawVisibility,\n+    pub is_extern: bool,\n+    /// Bounds restricting the type alias itself (eg. `type Ty: Bound;` in a trait or impl).\n+    pub bounds: Vec<Interned<TypeBound>>,\n+}\n+\n+impl TypeAliasData {\n+    pub(crate) fn type_alias_data_query(\n+        db: &dyn DefDatabase,\n+        typ: TypeAliasId,\n+    ) -> Arc<TypeAliasData> {\n+        let loc = typ.lookup(db);\n+        let item_tree = loc.id.item_tree(db);\n+        let typ = &item_tree[loc.id.value];\n+        let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n+            db.trait_data(trait_id).visibility.clone()\n+        } else {\n+            item_tree[typ.visibility].clone()\n+        };\n+\n+        Arc::new(TypeAliasData {\n+            name: typ.name.clone(),\n+            type_ref: typ.type_ref.clone(),\n+            visibility,\n+            is_extern: matches!(loc.container, ItemContainerId::ExternBlockId(_)),\n+            bounds: typ.bounds.to_vec(),\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TraitData {\n+    pub name: Name,\n+    pub items: Vec<(Name, AssocItemId)>,\n+    pub is_auto: bool,\n+    pub is_unsafe: bool,\n+    pub visibility: RawVisibility,\n+    /// Whether the trait has `#[rust_skip_array_during_method_dispatch]`. `hir_ty` will ignore\n+    /// method calls to this trait's methods when the receiver is an array and the crate edition is\n+    /// 2015 or 2018.\n+    pub skip_array_during_method_dispatch: bool,\n+    // box it as the vec is usually empty anyways\n+    pub attribute_calls: Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>,\n+}\n+\n+impl TraitData {\n+    pub(crate) fn trait_data_query(db: &dyn DefDatabase, tr: TraitId) -> Arc<TraitData> {\n+        let tr_loc @ ItemLoc { container: module_id, id: tree_id } = tr.lookup(db);\n+        let item_tree = tree_id.item_tree(db);\n+        let tr_def = &item_tree[tree_id.value];\n+        let _cx = stdx::panic_context::enter(format!(\n+            \"trait_data_query({:?} -> {:?} -> {:?})\",\n+            tr, tr_loc, tr_def\n+        ));\n+        let name = tr_def.name.clone();\n+        let is_auto = tr_def.is_auto;\n+        let is_unsafe = tr_def.is_unsafe;\n+        let visibility = item_tree[tr_def.visibility].clone();\n+        let skip_array_during_method_dispatch = item_tree\n+            .attrs(db, module_id.krate(), ModItem::from(tree_id.value).into())\n+            .by_key(\"rustc_skip_array_during_method_dispatch\")\n+            .exists();\n+\n+        let mut collector =\n+            AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::TraitId(tr));\n+        collector.collect(&item_tree, tree_id.tree_id(), &tr_def.items);\n+        let (items, attribute_calls) = collector.finish();\n+\n+        Arc::new(TraitData {\n+            name,\n+            attribute_calls,\n+            items,\n+            is_auto,\n+            is_unsafe,\n+            visibility,\n+            skip_array_during_method_dispatch,\n+        })\n+    }\n+\n+    pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {\n+        self.items.iter().filter_map(|(_name, item)| match item {\n+            AssocItemId::TypeAliasId(t) => Some(*t),\n+            _ => None,\n+        })\n+    }\n+\n+    pub fn associated_type_by_name(&self, name: &Name) -> Option<TypeAliasId> {\n+        self.items.iter().find_map(|(item_name, item)| match item {\n+            AssocItemId::TypeAliasId(t) if item_name == name => Some(*t),\n+            _ => None,\n+        })\n+    }\n+\n+    pub fn method_by_name(&self, name: &Name) -> Option<FunctionId> {\n+        self.items.iter().find_map(|(item_name, item)| match item {\n+            AssocItemId::FunctionId(t) if item_name == name => Some(*t),\n+            _ => None,\n+        })\n+    }\n+\n+    pub fn attribute_calls(&self) -> impl Iterator<Item = (AstId<ast::Item>, MacroCallId)> + '_ {\n+        self.attribute_calls.iter().flat_map(|it| it.iter()).copied()\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ImplData {\n+    pub target_trait: Option<Interned<TraitRef>>,\n+    pub self_ty: Interned<TypeRef>,\n+    pub items: Vec<AssocItemId>,\n+    pub is_negative: bool,\n+    // box it as the vec is usually empty anyways\n+    pub attribute_calls: Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>,\n+}\n+\n+impl ImplData {\n+    pub(crate) fn impl_data_query(db: &dyn DefDatabase, id: ImplId) -> Arc<ImplData> {\n+        let _p = profile::span(\"impl_data_query\");\n+        let ItemLoc { container: module_id, id: tree_id } = id.lookup(db);\n+\n+        let item_tree = tree_id.item_tree(db);\n+        let impl_def = &item_tree[tree_id.value];\n+        let target_trait = impl_def.target_trait.clone();\n+        let self_ty = impl_def.self_ty.clone();\n+        let is_negative = impl_def.is_negative;\n+\n+        let mut collector =\n+            AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::ImplId(id));\n+        collector.collect(&item_tree, tree_id.tree_id(), &impl_def.items);\n+\n+        let (items, attribute_calls) = collector.finish();\n+        let items = items.into_iter().map(|(_, item)| item).collect();\n+\n+        Arc::new(ImplData { target_trait, self_ty, items, is_negative, attribute_calls })\n+    }\n+\n+    pub fn attribute_calls(&self) -> impl Iterator<Item = (AstId<ast::Item>, MacroCallId)> + '_ {\n+        self.attribute_calls.iter().flat_map(|it| it.iter()).copied()\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Macro2Data {\n+    pub name: Name,\n+    pub visibility: RawVisibility,\n+}\n+\n+impl Macro2Data {\n+    pub(crate) fn macro2_data_query(db: &dyn DefDatabase, makro: Macro2Id) -> Arc<Macro2Data> {\n+        let loc = makro.lookup(db);\n+        let item_tree = loc.id.item_tree(db);\n+        let makro = &item_tree[loc.id.value];\n+\n+        Arc::new(Macro2Data {\n+            name: makro.name.clone(),\n+            visibility: item_tree[makro.visibility].clone(),\n+        })\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct MacroRulesData {\n+    pub name: Name,\n+    pub macro_export: bool,\n+}\n+\n+impl MacroRulesData {\n+    pub(crate) fn macro_rules_data_query(\n+        db: &dyn DefDatabase,\n+        makro: MacroRulesId,\n+    ) -> Arc<MacroRulesData> {\n+        let loc = makro.lookup(db);\n+        let item_tree = loc.id.item_tree(db);\n+        let makro = &item_tree[loc.id.value];\n+\n+        let macro_export = item_tree\n+            .attrs(db, loc.container.krate(), ModItem::from(loc.id.value).into())\n+            .by_key(\"macro_export\")\n+            .exists();\n+\n+        Arc::new(MacroRulesData { name: makro.name.clone(), macro_export })\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ProcMacroData {\n+    pub name: Name,\n+    // FIXME: Record deriver helper here?\n+}\n+\n+impl ProcMacroData {\n+    pub(crate) fn proc_macro_data_query(\n+        db: &dyn DefDatabase,\n+        makro: ProcMacroId,\n+    ) -> Arc<ProcMacroData> {\n+        let loc = makro.lookup(db);\n+        let item_tree = loc.id.item_tree(db);\n+        let makro = &item_tree[loc.id.value];\n+\n+        let name = if let Some(def) = item_tree\n+            .attrs(db, loc.container.krate(), ModItem::from(loc.id.value).into())\n+            .parse_proc_macro_decl(&makro.name)\n+        {\n+            def.name\n+        } else {\n+            // eeeh...\n+            stdx::never!(\"proc macro declaration is not a proc macro\");\n+            makro.name.clone()\n+        };\n+        Arc::new(ProcMacroData { name })\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct ConstData {\n+    /// `None` for `const _: () = ();`\n+    pub name: Option<Name>,\n+    pub type_ref: Interned<TypeRef>,\n+    pub visibility: RawVisibility,\n+}\n+\n+impl ConstData {\n+    pub(crate) fn const_data_query(db: &dyn DefDatabase, konst: ConstId) -> Arc<ConstData> {\n+        let loc = konst.lookup(db);\n+        let item_tree = loc.id.item_tree(db);\n+        let konst = &item_tree[loc.id.value];\n+        let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n+            db.trait_data(trait_id).visibility.clone()\n+        } else {\n+            item_tree[konst.visibility].clone()\n+        };\n+\n+        Arc::new(ConstData {\n+            name: konst.name.clone(),\n+            type_ref: konst.type_ref.clone(),\n+            visibility,\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct StaticData {\n+    pub name: Name,\n+    pub type_ref: Interned<TypeRef>,\n+    pub visibility: RawVisibility,\n+    pub mutable: bool,\n+    pub is_extern: bool,\n+}\n+\n+impl StaticData {\n+    pub(crate) fn static_data_query(db: &dyn DefDatabase, konst: StaticId) -> Arc<StaticData> {\n+        let loc = konst.lookup(db);\n+        let item_tree = loc.id.item_tree(db);\n+        let statik = &item_tree[loc.id.value];\n+\n+        Arc::new(StaticData {\n+            name: statik.name.clone(),\n+            type_ref: statik.type_ref.clone(),\n+            visibility: item_tree[statik.visibility].clone(),\n+            mutable: statik.mutable,\n+            is_extern: matches!(loc.container, ItemContainerId::ExternBlockId(_)),\n+        })\n+    }\n+}\n+\n+struct AssocItemCollector<'a> {\n+    db: &'a dyn DefDatabase,\n+    module_id: ModuleId,\n+    def_map: Arc<DefMap>,\n+    container: ItemContainerId,\n+    expander: Expander,\n+\n+    items: Vec<(Name, AssocItemId)>,\n+    attr_calls: Vec<(AstId<ast::Item>, MacroCallId)>,\n+}\n+\n+impl<'a> AssocItemCollector<'a> {\n+    fn new(\n+        db: &'a dyn DefDatabase,\n+        module_id: ModuleId,\n+        file_id: HirFileId,\n+        container: ItemContainerId,\n+    ) -> Self {\n+        Self {\n+            db,\n+            module_id,\n+            def_map: module_id.def_map(db),\n+            container,\n+            expander: Expander::new(db, file_id, module_id),\n+            items: Vec::new(),\n+            attr_calls: Vec::new(),\n+        }\n+    }\n+\n+    fn finish(\n+        self,\n+    ) -> (Vec<(Name, AssocItemId)>, Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>) {\n+        (\n+            self.items,\n+            if self.attr_calls.is_empty() { None } else { Some(Box::new(self.attr_calls)) },\n+        )\n+    }\n+\n+    // FIXME: proc-macro diagnostics\n+    fn collect(&mut self, item_tree: &ItemTree, tree_id: TreeId, assoc_items: &[AssocItem]) {\n+        let container = self.container;\n+        self.items.reserve(assoc_items.len());\n+\n+        'items: for &item in assoc_items {\n+            let attrs = item_tree.attrs(self.db, self.module_id.krate, ModItem::from(item).into());\n+            if !attrs.is_cfg_enabled(self.expander.cfg_options()) {\n+                continue;\n+            }\n+\n+            'attrs: for attr in &*attrs {\n+                let ast_id =\n+                    AstId::new(self.expander.current_file_id(), item.ast_id(&item_tree).upcast());\n+                let ast_id_with_path = AstIdWithPath { path: (*attr.path).clone(), ast_id };\n+\n+                if let Ok(ResolvedAttr::Macro(call_id)) = self.def_map.resolve_attr_macro(\n+                    self.db,\n+                    self.module_id.local_id,\n+                    ast_id_with_path,\n+                    attr,\n+                ) {\n+                    self.attr_calls.push((ast_id, call_id));\n+                    // If proc attribute macro expansion is disabled, skip expanding it here\n+                    if !self.db.enable_proc_attr_macros() {\n+                        continue 'attrs;\n+                    }\n+                    let loc = self.db.lookup_intern_macro_call(call_id);\n+                    if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n+                        // If there's no expander for the proc macro (e.g. the\n+                        // proc macro is ignored, or building the proc macro\n+                        // crate failed), skip expansion like we would if it was\n+                        // disabled. This is analogous to the handling in\n+                        // `DefCollector::collect_macros`.\n+                        if exp.is_dummy() {\n+                            continue 'attrs;\n+                        }\n+                    }\n+                    match self.expander.enter_expand_id::<ast::MacroItems>(self.db, call_id) {\n+                        ExpandResult { value: Some((mark, _)), .. } => {\n+                            self.collect_macro_items(mark);\n+                            continue 'items;\n+                        }\n+                        ExpandResult { .. } => {}\n+                    }\n+                }\n+            }\n+\n+            match item {\n+                AssocItem::Function(id) => {\n+                    let item = &item_tree[id];\n+\n+                    let def =\n+                        FunctionLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n+                    self.items.push((item.name.clone(), def.into()));\n+                }\n+                AssocItem::Const(id) => {\n+                    let item = &item_tree[id];\n+\n+                    let name = match item.name.clone() {\n+                        Some(name) => name,\n+                        None => continue,\n+                    };\n+                    let def =\n+                        ConstLoc { container, id: ItemTreeId::new(tree_id, id) }.intern(self.db);\n+                    self.items.push((name, def.into()));\n+                }\n+                AssocItem::TypeAlias(id) => {\n+                    let item = &item_tree[id];\n+\n+                    let def = TypeAliasLoc { container, id: ItemTreeId::new(tree_id, id) }\n+                        .intern(self.db);\n+                    self.items.push((item.name.clone(), def.into()));\n+                }\n+                AssocItem::MacroCall(call) => {\n+                    if let Some(root) = self.db.parse_or_expand(self.expander.current_file_id()) {\n+                        let call = &item_tree[call];\n+\n+                        let ast_id_map = self.db.ast_id_map(self.expander.current_file_id());\n+                        let call = ast_id_map.get(call.ast_id).to_node(&root);\n+                        let _cx = stdx::panic_context::enter(format!(\n+                            \"collect_items MacroCall: {}\",\n+                            call\n+                        ));\n+                        let res = self.expander.enter_expand::<ast::MacroItems>(self.db, call);\n+\n+                        if let Ok(ExpandResult { value: Some((mark, _)), .. }) = res {\n+                            self.collect_macro_items(mark);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn collect_macro_items(&mut self, mark: Mark) {\n+        let tree_id = item_tree::TreeId::new(self.expander.current_file_id(), None);\n+        let item_tree = tree_id.item_tree(self.db);\n+        let iter: SmallVec<[_; 2]> =\n+            item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item).collect();\n+\n+        self.collect(&item_tree, tree_id, &iter);\n+\n+        self.expander.exit(self.db, mark);\n+    }\n+}"}, {"sha": "df6dcb024b5eafb9b71b12d7517903b075da81de", "filename": "src/tools/rust-analyzer/crates/hir-def/src/db.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdb.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,243 @@\n+//! Defines database & queries for name resolution.\n+use std::sync::Arc;\n+\n+use base_db::{salsa, CrateId, SourceDatabase, Upcast};\n+use either::Either;\n+use hir_expand::{db::AstDatabase, HirFileId};\n+use la_arena::ArenaMap;\n+use syntax::{ast, AstPtr, SmolStr};\n+\n+use crate::{\n+    adt::{EnumData, StructData},\n+    attr::{Attrs, AttrsWithOwner},\n+    body::{scope::ExprScopes, Body, BodySourceMap},\n+    data::{\n+        ConstData, FunctionData, ImplData, Macro2Data, MacroRulesData, ProcMacroData, StaticData,\n+        TraitData, TypeAliasData,\n+    },\n+    generics::GenericParams,\n+    import_map::ImportMap,\n+    intern::Interned,\n+    item_tree::{AttrOwner, ItemTree},\n+    lang_item::{LangItemTarget, LangItems},\n+    nameres::DefMap,\n+    visibility::{self, Visibility},\n+    AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, ExternBlockId,\n+    ExternBlockLoc, FunctionId, FunctionLoc, GenericDefId, ImplId, ImplLoc, LocalEnumVariantId,\n+    LocalFieldId, Macro2Id, Macro2Loc, MacroRulesId, MacroRulesLoc, ProcMacroId, ProcMacroLoc,\n+    StaticId, StaticLoc, StructId, StructLoc, TraitId, TraitLoc, TypeAliasId, TypeAliasLoc,\n+    UnionId, UnionLoc, VariantId,\n+};\n+\n+#[salsa::query_group(InternDatabaseStorage)]\n+pub trait InternDatabase: SourceDatabase {\n+    #[salsa::interned]\n+    fn intern_function(&self, loc: FunctionLoc) -> FunctionId;\n+    #[salsa::interned]\n+    fn intern_struct(&self, loc: StructLoc) -> StructId;\n+    #[salsa::interned]\n+    fn intern_union(&self, loc: UnionLoc) -> UnionId;\n+    #[salsa::interned]\n+    fn intern_enum(&self, loc: EnumLoc) -> EnumId;\n+    #[salsa::interned]\n+    fn intern_const(&self, loc: ConstLoc) -> ConstId;\n+    #[salsa::interned]\n+    fn intern_static(&self, loc: StaticLoc) -> StaticId;\n+    #[salsa::interned]\n+    fn intern_trait(&self, loc: TraitLoc) -> TraitId;\n+    #[salsa::interned]\n+    fn intern_type_alias(&self, loc: TypeAliasLoc) -> TypeAliasId;\n+    #[salsa::interned]\n+    fn intern_impl(&self, loc: ImplLoc) -> ImplId;\n+    #[salsa::interned]\n+    fn intern_extern_block(&self, loc: ExternBlockLoc) -> ExternBlockId;\n+    #[salsa::interned]\n+    fn intern_block(&self, loc: BlockLoc) -> BlockId;\n+    #[salsa::interned]\n+    fn intern_macro2(&self, loc: Macro2Loc) -> Macro2Id;\n+    #[salsa::interned]\n+    fn intern_proc_macro(&self, loc: ProcMacroLoc) -> ProcMacroId;\n+    #[salsa::interned]\n+    fn intern_macro_rules(&self, loc: MacroRulesLoc) -> MacroRulesId;\n+}\n+\n+#[salsa::query_group(DefDatabaseStorage)]\n+pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n+    #[salsa::input]\n+    fn enable_proc_attr_macros(&self) -> bool;\n+\n+    #[salsa::invoke(ItemTree::file_item_tree_query)]\n+    fn file_item_tree(&self, file_id: HirFileId) -> Arc<ItemTree>;\n+\n+    #[salsa::invoke(crate_def_map_wait)]\n+    #[salsa::transparent]\n+    fn crate_def_map(&self, krate: CrateId) -> Arc<DefMap>;\n+\n+    #[salsa::invoke(DefMap::crate_def_map_query)]\n+    fn crate_def_map_query(&self, krate: CrateId) -> Arc<DefMap>;\n+\n+    /// Computes the block-level `DefMap`, returning `None` when `block` doesn't contain any inner\n+    /// items directly.\n+    ///\n+    /// For example:\n+    ///\n+    /// ```\n+    /// fn f() { // (0)\n+    ///     { // (1)\n+    ///         fn inner() {}\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// The `block_def_map` for block 0 would return `None`, while `block_def_map` of block 1 would\n+    /// return a `DefMap` containing `inner`.\n+    #[salsa::invoke(DefMap::block_def_map_query)]\n+    fn block_def_map(&self, block: BlockId) -> Option<Arc<DefMap>>;\n+\n+    #[salsa::invoke(StructData::struct_data_query)]\n+    fn struct_data(&self, id: StructId) -> Arc<StructData>;\n+\n+    #[salsa::invoke(StructData::union_data_query)]\n+    fn union_data(&self, id: UnionId) -> Arc<StructData>;\n+\n+    #[salsa::invoke(EnumData::enum_data_query)]\n+    fn enum_data(&self, e: EnumId) -> Arc<EnumData>;\n+\n+    #[salsa::invoke(ImplData::impl_data_query)]\n+    fn impl_data(&self, e: ImplId) -> Arc<ImplData>;\n+\n+    #[salsa::invoke(TraitData::trait_data_query)]\n+    fn trait_data(&self, e: TraitId) -> Arc<TraitData>;\n+\n+    #[salsa::invoke(TypeAliasData::type_alias_data_query)]\n+    fn type_alias_data(&self, e: TypeAliasId) -> Arc<TypeAliasData>;\n+\n+    #[salsa::invoke(FunctionData::fn_data_query)]\n+    fn function_data(&self, func: FunctionId) -> Arc<FunctionData>;\n+\n+    #[salsa::invoke(ConstData::const_data_query)]\n+    fn const_data(&self, konst: ConstId) -> Arc<ConstData>;\n+\n+    #[salsa::invoke(StaticData::static_data_query)]\n+    fn static_data(&self, konst: StaticId) -> Arc<StaticData>;\n+\n+    #[salsa::invoke(Macro2Data::macro2_data_query)]\n+    fn macro2_data(&self, makro: Macro2Id) -> Arc<Macro2Data>;\n+\n+    #[salsa::invoke(MacroRulesData::macro_rules_data_query)]\n+    fn macro_rules_data(&self, makro: MacroRulesId) -> Arc<MacroRulesData>;\n+\n+    #[salsa::invoke(ProcMacroData::proc_macro_data_query)]\n+    fn proc_macro_data(&self, makro: ProcMacroId) -> Arc<ProcMacroData>;\n+\n+    #[salsa::invoke(Body::body_with_source_map_query)]\n+    fn body_with_source_map(&self, def: DefWithBodyId) -> (Arc<Body>, Arc<BodySourceMap>);\n+\n+    #[salsa::invoke(Body::body_query)]\n+    fn body(&self, def: DefWithBodyId) -> Arc<Body>;\n+\n+    #[salsa::invoke(ExprScopes::expr_scopes_query)]\n+    fn expr_scopes(&self, def: DefWithBodyId) -> Arc<ExprScopes>;\n+\n+    #[salsa::invoke(GenericParams::generic_params_query)]\n+    fn generic_params(&self, def: GenericDefId) -> Interned<GenericParams>;\n+\n+    #[salsa::invoke(Attrs::variants_attrs_query)]\n+    fn variants_attrs(&self, def: EnumId) -> Arc<ArenaMap<LocalEnumVariantId, Attrs>>;\n+\n+    #[salsa::invoke(Attrs::fields_attrs_query)]\n+    fn fields_attrs(&self, def: VariantId) -> Arc<ArenaMap<LocalFieldId, Attrs>>;\n+\n+    #[salsa::invoke(crate::attr::variants_attrs_source_map)]\n+    fn variants_attrs_source_map(\n+        &self,\n+        def: EnumId,\n+    ) -> Arc<ArenaMap<LocalEnumVariantId, AstPtr<ast::Variant>>>;\n+\n+    #[salsa::invoke(crate::attr::fields_attrs_source_map)]\n+    fn fields_attrs_source_map(\n+        &self,\n+        def: VariantId,\n+    ) -> Arc<ArenaMap<LocalFieldId, Either<AstPtr<ast::TupleField>, AstPtr<ast::RecordField>>>>;\n+\n+    #[salsa::invoke(AttrsWithOwner::attrs_query)]\n+    fn attrs(&self, def: AttrDefId) -> AttrsWithOwner;\n+\n+    #[salsa::invoke(LangItems::crate_lang_items_query)]\n+    fn crate_lang_items(&self, krate: CrateId) -> Arc<LangItems>;\n+\n+    #[salsa::invoke(LangItems::lang_item_query)]\n+    fn lang_item(&self, start_crate: CrateId, item: SmolStr) -> Option<LangItemTarget>;\n+\n+    #[salsa::invoke(ImportMap::import_map_query)]\n+    fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;\n+\n+    #[salsa::invoke(visibility::field_visibilities_query)]\n+    fn field_visibilities(&self, var: VariantId) -> Arc<ArenaMap<LocalFieldId, Visibility>>;\n+\n+    // FIXME: unify function_visibility and const_visibility?\n+    #[salsa::invoke(visibility::function_visibility_query)]\n+    fn function_visibility(&self, def: FunctionId) -> Visibility;\n+\n+    #[salsa::invoke(visibility::const_visibility_query)]\n+    fn const_visibility(&self, def: ConstId) -> Visibility;\n+\n+    #[salsa::transparent]\n+    fn crate_limits(&self, crate_id: CrateId) -> CrateLimits;\n+\n+    fn crate_supports_no_std(&self, crate_id: CrateId) -> bool;\n+}\n+\n+fn crate_def_map_wait(db: &dyn DefDatabase, krate: CrateId) -> Arc<DefMap> {\n+    let _p = profile::span(\"crate_def_map:wait\");\n+    db.crate_def_map_query(krate)\n+}\n+\n+pub struct CrateLimits {\n+    /// The maximum depth for potentially infinitely-recursive compile-time operations like macro expansion or auto-dereference.\n+    pub recursion_limit: u32,\n+}\n+\n+fn crate_limits(db: &dyn DefDatabase, crate_id: CrateId) -> CrateLimits {\n+    let def_map = db.crate_def_map(crate_id);\n+\n+    CrateLimits {\n+        // 128 is the default in rustc.\n+        recursion_limit: def_map.recursion_limit().unwrap_or(128),\n+    }\n+}\n+\n+fn crate_supports_no_std(db: &dyn DefDatabase, crate_id: CrateId) -> bool {\n+    let file = db.crate_graph()[crate_id].root_file_id;\n+    let item_tree = db.file_item_tree(file.into());\n+    let attrs = item_tree.raw_attrs(AttrOwner::TopLevel);\n+    for attr in &**attrs {\n+        match attr.path().as_ident().and_then(|id| id.as_text()) {\n+            Some(ident) if ident == \"no_std\" => return true,\n+            Some(ident) if ident == \"cfg_attr\" => {}\n+            _ => continue,\n+        }\n+\n+        // This is a `cfg_attr`; check if it could possibly expand to `no_std`.\n+        // Syntax is: `#[cfg_attr(condition(cfg, style), attr0, attr1, <...>)]`\n+        let tt = match attr.token_tree_value() {\n+            Some(tt) => &tt.token_trees,\n+            None => continue,\n+        };\n+\n+        let segments = tt.split(|tt| match tt {\n+            tt::TokenTree::Leaf(tt::Leaf::Punct(p)) if p.char == ',' => true,\n+            _ => false,\n+        });\n+        for output in segments.skip(1) {\n+            match output {\n+                [tt::TokenTree::Leaf(tt::Leaf::Ident(ident))] if ident.text == \"no_std\" => {\n+                    return true\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "166aa04da044ff71dbd7c5c010413fc002b3a865", "filename": "src/tools/rust-analyzer/crates/hir-def/src/dyn_map.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdyn_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdyn_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fdyn_map.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,116 @@\n+//! This module defines a `DynMap` -- a container for heterogeneous maps.\n+//!\n+//! This means that `DynMap` stores a bunch of hash maps inside, and those maps\n+//! can be of different types.\n+//!\n+//! It is used like this:\n+//!\n+//! ```\n+//! // keys define submaps of a `DynMap`\n+//! const STRING_TO_U32: Key<String, u32> = Key::new();\n+//! const U32_TO_VEC: Key<u32, Vec<bool>> = Key::new();\n+//!\n+//! // Note: concrete type, no type params!\n+//! let mut map = DynMap::new();\n+//!\n+//! // To access a specific map, index the `DynMap` by `Key`:\n+//! map[STRING_TO_U32].insert(\"hello\".to_string(), 92);\n+//! let value = map[U32_TO_VEC].get(92);\n+//! assert!(value.is_none());\n+//! ```\n+//!\n+//! This is a work of fiction. Any similarities to Kotlin's `BindingContext` are\n+//! a coincidence.\n+use std::{\n+    hash::Hash,\n+    marker::PhantomData,\n+    ops::{Index, IndexMut},\n+};\n+\n+use anymap::Map;\n+use rustc_hash::FxHashMap;\n+\n+pub struct Key<K, V, P = (K, V)> {\n+    _phantom: PhantomData<(K, V, P)>,\n+}\n+\n+impl<K, V, P> Key<K, V, P> {\n+    pub(crate) const fn new() -> Key<K, V, P> {\n+        Key { _phantom: PhantomData }\n+    }\n+}\n+\n+impl<K, V, P> Copy for Key<K, V, P> {}\n+\n+impl<K, V, P> Clone for Key<K, V, P> {\n+    fn clone(&self) -> Key<K, V, P> {\n+        *self\n+    }\n+}\n+\n+pub trait Policy {\n+    type K;\n+    type V;\n+\n+    fn insert(map: &mut DynMap, key: Self::K, value: Self::V);\n+    fn get<'a>(map: &'a DynMap, key: &Self::K) -> Option<&'a Self::V>;\n+    fn is_empty(map: &DynMap) -> bool;\n+}\n+\n+impl<K: Hash + Eq + 'static, V: 'static> Policy for (K, V) {\n+    type K = K;\n+    type V = V;\n+    fn insert(map: &mut DynMap, key: K, value: V) {\n+        map.map.entry::<FxHashMap<K, V>>().or_insert_with(Default::default).insert(key, value);\n+    }\n+    fn get<'a>(map: &'a DynMap, key: &K) -> Option<&'a V> {\n+        map.map.get::<FxHashMap<K, V>>()?.get(key)\n+    }\n+    fn is_empty(map: &DynMap) -> bool {\n+        map.map.get::<FxHashMap<K, V>>().map_or(true, |it| it.is_empty())\n+    }\n+}\n+\n+pub struct DynMap {\n+    pub(crate) map: Map,\n+}\n+\n+impl Default for DynMap {\n+    fn default() -> Self {\n+        DynMap { map: Map::new() }\n+    }\n+}\n+\n+#[repr(transparent)]\n+pub struct KeyMap<KEY> {\n+    map: DynMap,\n+    _phantom: PhantomData<KEY>,\n+}\n+\n+impl<P: Policy> KeyMap<Key<P::K, P::V, P>> {\n+    pub fn insert(&mut self, key: P::K, value: P::V) {\n+        P::insert(&mut self.map, key, value)\n+    }\n+    pub fn get(&self, key: &P::K) -> Option<&P::V> {\n+        P::get(&self.map, key)\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        P::is_empty(&self.map)\n+    }\n+}\n+\n+impl<P: Policy> Index<Key<P::K, P::V, P>> for DynMap {\n+    type Output = KeyMap<Key<P::K, P::V, P>>;\n+    fn index(&self, _key: Key<P::K, P::V, P>) -> &Self::Output {\n+        // Safe due to `#[repr(transparent)]`.\n+        unsafe { std::mem::transmute::<&DynMap, &KeyMap<Key<P::K, P::V, P>>>(self) }\n+    }\n+}\n+\n+impl<P: Policy> IndexMut<Key<P::K, P::V, P>> for DynMap {\n+    fn index_mut(&mut self, _key: Key<P::K, P::V, P>) -> &mut Self::Output {\n+        // Safe due to `#[repr(transparent)]`.\n+        unsafe { std::mem::transmute::<&mut DynMap, &mut KeyMap<Key<P::K, P::V, P>>>(self) }\n+    }\n+}"}, {"sha": "a991365d6bf4906fd532b2154710094669835d9e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/expr.rs", "status": "added", "additions": 440, "deletions": 0, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,440 @@\n+//! This module describes hir-level representation of expressions.\n+//!\n+//! This representation is:\n+//!\n+//! 1. Identity-based. Each expression has an `id`, so we can distinguish\n+//!    between different `1` in `1 + 1`.\n+//! 2. Independent of syntax. Though syntactic provenance information can be\n+//!    attached separately via id-based side map.\n+//! 3. Unresolved. Paths are stored as sequences of names, and not as defs the\n+//!    names refer to.\n+//! 4. Desugared. There's no `if let`.\n+//!\n+//! See also a neighboring `body` module.\n+\n+use hir_expand::name::Name;\n+use la_arena::{Idx, RawIdx};\n+\n+use crate::{\n+    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n+    intern::Interned,\n+    path::{GenericArgs, Path},\n+    type_ref::{Mutability, Rawness, TypeRef},\n+    BlockId,\n+};\n+\n+pub use syntax::ast::{ArithOp, BinaryOp, CmpOp, LogicOp, Ordering, RangeOp, UnaryOp};\n+\n+pub type ExprId = Idx<Expr>;\n+\n+/// FIXME: this is a hacky function which should be removed\n+pub(crate) fn dummy_expr_id() -> ExprId {\n+    ExprId::from_raw(RawIdx::from(u32::MAX))\n+}\n+\n+pub type PatId = Idx<Pat>;\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Label {\n+    pub name: Name,\n+}\n+pub type LabelId = Idx<Label>;\n+\n+// We convert float values into bits and that's how we don't need to deal with f32 and f64.\n+// For PartialEq, bits comparison should work, as ordering is not important\n+// https://github.com/rust-lang/rust-analyzer/issues/12380#issuecomment-1137284360\n+#[derive(Default, Debug, Clone, Eq, PartialEq)]\n+pub struct FloatTypeWrapper(u64);\n+\n+impl FloatTypeWrapper {\n+    pub fn new(value: f64) -> Self {\n+        Self(value.to_bits())\n+    }\n+}\n+\n+impl std::fmt::Display for FloatTypeWrapper {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{:?}\", f64::from_bits(self.0))\n+    }\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Literal {\n+    String(Box<str>),\n+    ByteString(Box<[u8]>),\n+    Char(char),\n+    Bool(bool),\n+    Int(i128, Option<BuiltinInt>),\n+    Uint(u128, Option<BuiltinUint>),\n+    // Here we are using a wrapper around float because f32 and f64 do not implement Eq, so they\n+    // could not be used directly here, to understand how the wrapper works go to definition of\n+    // FloatTypeWrapper\n+    Float(FloatTypeWrapper, Option<BuiltinFloat>),\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Expr {\n+    /// This is produced if the syntax tree does not have a required expression piece.\n+    Missing,\n+    Path(Path),\n+    If {\n+        condition: ExprId,\n+        then_branch: ExprId,\n+        else_branch: Option<ExprId>,\n+    },\n+    Let {\n+        pat: PatId,\n+        expr: ExprId,\n+    },\n+    Block {\n+        id: BlockId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+        label: Option<LabelId>,\n+    },\n+    Loop {\n+        body: ExprId,\n+        label: Option<LabelId>,\n+    },\n+    While {\n+        condition: ExprId,\n+        body: ExprId,\n+        label: Option<LabelId>,\n+    },\n+    For {\n+        iterable: ExprId,\n+        pat: PatId,\n+        body: ExprId,\n+        label: Option<LabelId>,\n+    },\n+    Call {\n+        callee: ExprId,\n+        args: Box<[ExprId]>,\n+    },\n+    MethodCall {\n+        receiver: ExprId,\n+        method_name: Name,\n+        args: Box<[ExprId]>,\n+        generic_args: Option<Box<GenericArgs>>,\n+    },\n+    Match {\n+        expr: ExprId,\n+        arms: Box<[MatchArm]>,\n+    },\n+    Continue {\n+        label: Option<Name>,\n+    },\n+    Break {\n+        expr: Option<ExprId>,\n+        label: Option<Name>,\n+    },\n+    Return {\n+        expr: Option<ExprId>,\n+    },\n+    Yield {\n+        expr: Option<ExprId>,\n+    },\n+    RecordLit {\n+        path: Option<Box<Path>>,\n+        fields: Box<[RecordLitField]>,\n+        spread: Option<ExprId>,\n+    },\n+    Field {\n+        expr: ExprId,\n+        name: Name,\n+    },\n+    Await {\n+        expr: ExprId,\n+    },\n+    Try {\n+        expr: ExprId,\n+    },\n+    TryBlock {\n+        body: ExprId,\n+    },\n+    Async {\n+        body: ExprId,\n+    },\n+    Const {\n+        body: ExprId,\n+    },\n+    Cast {\n+        expr: ExprId,\n+        type_ref: Interned<TypeRef>,\n+    },\n+    Ref {\n+        expr: ExprId,\n+        rawness: Rawness,\n+        mutability: Mutability,\n+    },\n+    Box {\n+        expr: ExprId,\n+    },\n+    UnaryOp {\n+        expr: ExprId,\n+        op: UnaryOp,\n+    },\n+    BinaryOp {\n+        lhs: ExprId,\n+        rhs: ExprId,\n+        op: Option<BinaryOp>,\n+    },\n+    Range {\n+        lhs: Option<ExprId>,\n+        rhs: Option<ExprId>,\n+        range_type: RangeOp,\n+    },\n+    Index {\n+        base: ExprId,\n+        index: ExprId,\n+    },\n+    Closure {\n+        args: Box<[PatId]>,\n+        arg_types: Box<[Option<Interned<TypeRef>>]>,\n+        ret_type: Option<Interned<TypeRef>>,\n+        body: ExprId,\n+    },\n+    Tuple {\n+        exprs: Box<[ExprId]>,\n+    },\n+    Unsafe {\n+        body: ExprId,\n+    },\n+    MacroStmts {\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n+    },\n+    Array(Array),\n+    Literal(Literal),\n+    Underscore,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Array {\n+    ElementList(Box<[ExprId]>),\n+    Repeat { initializer: ExprId, repeat: ExprId },\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct MatchArm {\n+    pub pat: PatId,\n+    pub guard: Option<ExprId>,\n+    pub expr: ExprId,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct RecordLitField {\n+    pub name: Name,\n+    pub expr: ExprId,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Statement {\n+    Let {\n+        pat: PatId,\n+        type_ref: Option<Interned<TypeRef>>,\n+        initializer: Option<ExprId>,\n+        else_branch: Option<ExprId>,\n+    },\n+    Expr {\n+        expr: ExprId,\n+        has_semi: bool,\n+    },\n+}\n+\n+impl Expr {\n+    pub fn walk_child_exprs(&self, mut f: impl FnMut(ExprId)) {\n+        match self {\n+            Expr::Missing => {}\n+            Expr::Path(_) => {}\n+            Expr::If { condition, then_branch, else_branch } => {\n+                f(*condition);\n+                f(*then_branch);\n+                if let &Some(else_branch) = else_branch {\n+                    f(else_branch);\n+                }\n+            }\n+            Expr::Let { expr, .. } => {\n+                f(*expr);\n+            }\n+            Expr::MacroStmts { tail, statements } | Expr::Block { statements, tail, .. } => {\n+                for stmt in statements.iter() {\n+                    match stmt {\n+                        Statement::Let { initializer, .. } => {\n+                            if let &Some(expr) = initializer {\n+                                f(expr);\n+                            }\n+                        }\n+                        Statement::Expr { expr: expression, .. } => f(*expression),\n+                    }\n+                }\n+                if let &Some(expr) = tail {\n+                    f(expr);\n+                }\n+            }\n+            Expr::TryBlock { body }\n+            | Expr::Unsafe { body }\n+            | Expr::Async { body }\n+            | Expr::Const { body } => f(*body),\n+            Expr::Loop { body, .. } => f(*body),\n+            Expr::While { condition, body, .. } => {\n+                f(*condition);\n+                f(*body);\n+            }\n+            Expr::For { iterable, body, .. } => {\n+                f(*iterable);\n+                f(*body);\n+            }\n+            Expr::Call { callee, args } => {\n+                f(*callee);\n+                args.iter().copied().for_each(f);\n+            }\n+            Expr::MethodCall { receiver, args, .. } => {\n+                f(*receiver);\n+                args.iter().copied().for_each(f);\n+            }\n+            Expr::Match { expr, arms } => {\n+                f(*expr);\n+                arms.iter().map(|arm| arm.expr).for_each(f);\n+            }\n+            Expr::Continue { .. } => {}\n+            Expr::Break { expr, .. } | Expr::Return { expr } | Expr::Yield { expr } => {\n+                if let &Some(expr) = expr {\n+                    f(expr);\n+                }\n+            }\n+            Expr::RecordLit { fields, spread, .. } => {\n+                for field in fields.iter() {\n+                    f(field.expr);\n+                }\n+                if let &Some(expr) = spread {\n+                    f(expr);\n+                }\n+            }\n+            Expr::Closure { body, .. } => {\n+                f(*body);\n+            }\n+            Expr::BinaryOp { lhs, rhs, .. } => {\n+                f(*lhs);\n+                f(*rhs);\n+            }\n+            Expr::Range { lhs, rhs, .. } => {\n+                if let &Some(lhs) = rhs {\n+                    f(lhs);\n+                }\n+                if let &Some(rhs) = lhs {\n+                    f(rhs);\n+                }\n+            }\n+            Expr::Index { base, index } => {\n+                f(*base);\n+                f(*index);\n+            }\n+            Expr::Field { expr, .. }\n+            | Expr::Await { expr }\n+            | Expr::Try { expr }\n+            | Expr::Cast { expr, .. }\n+            | Expr::Ref { expr, .. }\n+            | Expr::UnaryOp { expr, .. }\n+            | Expr::Box { expr } => {\n+                f(*expr);\n+            }\n+            Expr::Tuple { exprs } => exprs.iter().copied().for_each(f),\n+            Expr::Array(a) => match a {\n+                Array::ElementList(exprs) => exprs.iter().copied().for_each(f),\n+                Array::Repeat { initializer, repeat } => {\n+                    f(*initializer);\n+                    f(*repeat)\n+                }\n+            },\n+            Expr::Literal(_) => {}\n+            Expr::Underscore => {}\n+        }\n+    }\n+}\n+\n+/// Explicit binding annotations given in the HIR for a binding. Note\n+/// that this is not the final binding *mode* that we infer after type\n+/// inference.\n+#[derive(Clone, PartialEq, Eq, Debug, Copy)]\n+pub enum BindingAnnotation {\n+    /// No binding annotation given: this means that the final binding mode\n+    /// will depend on whether we have skipped through a `&` reference\n+    /// when matching. For example, the `x` in `Some(x)` will have binding\n+    /// mode `None`; if you do `let Some(x) = &Some(22)`, it will\n+    /// ultimately be inferred to be by-reference.\n+    Unannotated,\n+\n+    /// Annotated with `mut x` -- could be either ref or not, similar to `None`.\n+    Mutable,\n+\n+    /// Annotated as `ref`, like `ref x`\n+    Ref,\n+\n+    /// Annotated as `ref mut x`.\n+    RefMut,\n+}\n+\n+impl BindingAnnotation {\n+    pub fn new(is_mutable: bool, is_ref: bool) -> Self {\n+        match (is_mutable, is_ref) {\n+            (true, true) => BindingAnnotation::RefMut,\n+            (false, true) => BindingAnnotation::Ref,\n+            (true, false) => BindingAnnotation::Mutable,\n+            (false, false) => BindingAnnotation::Unannotated,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct RecordFieldPat {\n+    pub name: Name,\n+    pub pat: PatId,\n+}\n+\n+/// Close relative to rustc's hir::PatKind\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Pat {\n+    Missing,\n+    Wild,\n+    Tuple { args: Box<[PatId]>, ellipsis: Option<usize> },\n+    Or(Box<[PatId]>),\n+    Record { path: Option<Box<Path>>, args: Box<[RecordFieldPat]>, ellipsis: bool },\n+    Range { start: ExprId, end: ExprId },\n+    Slice { prefix: Box<[PatId]>, slice: Option<PatId>, suffix: Box<[PatId]> },\n+    Path(Box<Path>),\n+    Lit(ExprId),\n+    Bind { mode: BindingAnnotation, name: Name, subpat: Option<PatId> },\n+    TupleStruct { path: Option<Box<Path>>, args: Box<[PatId]>, ellipsis: Option<usize> },\n+    Ref { pat: PatId, mutability: Mutability },\n+    Box { inner: PatId },\n+    ConstBlock(ExprId),\n+}\n+\n+impl Pat {\n+    pub fn walk_child_pats(&self, mut f: impl FnMut(PatId)) {\n+        match self {\n+            Pat::Range { .. }\n+            | Pat::Lit(..)\n+            | Pat::Path(..)\n+            | Pat::ConstBlock(..)\n+            | Pat::Wild\n+            | Pat::Missing => {}\n+            Pat::Bind { subpat, .. } => {\n+                subpat.iter().copied().for_each(f);\n+            }\n+            Pat::Or(args) | Pat::Tuple { args, .. } | Pat::TupleStruct { args, .. } => {\n+                args.iter().copied().for_each(f);\n+            }\n+            Pat::Ref { pat, .. } => f(*pat),\n+            Pat::Slice { prefix, slice, suffix } => {\n+                let total_iter = prefix.iter().chain(slice.iter()).chain(suffix.iter());\n+                total_iter.copied().for_each(f);\n+            }\n+            Pat::Record { args, .. } => {\n+                args.iter().map(|f| f.pat).for_each(f);\n+            }\n+            Pat::Box { inner } => f(*inner),\n+        }\n+    }\n+}"}, {"sha": "89e961f84fad26f9d22374b16b1711ac2a3c659d", "filename": "src/tools/rust-analyzer/crates/hir-def/src/find_path.rs", "status": "added", "additions": 1134, "deletions": 0, "changes": 1134, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ffind_path.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,1134 @@\n+//! An algorithm to find a path to refer to a certain item.\n+\n+use std::iter;\n+\n+use hir_expand::name::{known, AsName, Name};\n+use rustc_hash::FxHashSet;\n+\n+use crate::{\n+    db::DefDatabase,\n+    item_scope::ItemInNs,\n+    nameres::DefMap,\n+    path::{ModPath, PathKind},\n+    visibility::Visibility,\n+    ModuleDefId, ModuleId,\n+};\n+\n+/// Find a path that can be used to refer to a certain item. This can depend on\n+/// *from where* you're referring to the item, hence the `from` parameter.\n+pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n+    let _p = profile::span(\"find_path\");\n+    find_path_inner(db, item, from, None)\n+}\n+\n+pub fn find_path_prefixed(\n+    db: &dyn DefDatabase,\n+    item: ItemInNs,\n+    from: ModuleId,\n+    prefix_kind: PrefixKind,\n+) -> Option<ModPath> {\n+    let _p = profile::span(\"find_path_prefixed\");\n+    find_path_inner(db, item, from, Some(prefix_kind))\n+}\n+\n+const MAX_PATH_LEN: usize = 15;\n+\n+trait ModPathExt {\n+    fn starts_with_std(&self) -> bool;\n+    fn can_start_with_std(&self) -> bool;\n+}\n+\n+impl ModPathExt for ModPath {\n+    fn starts_with_std(&self) -> bool {\n+        self.segments().first() == Some(&known::std)\n+    }\n+\n+    // Can we replace the first segment with `std::` and still get a valid, identical path?\n+    fn can_start_with_std(&self) -> bool {\n+        let first_segment = self.segments().first();\n+        first_segment == Some(&known::alloc) || first_segment == Some(&known::core)\n+    }\n+}\n+\n+fn check_self_super(def_map: &DefMap, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n+    if item == ItemInNs::Types(from.into()) {\n+        // - if the item is the module we're in, use `self`\n+        Some(ModPath::from_segments(PathKind::Super(0), None))\n+    } else if let Some(parent_id) = def_map[from.local_id].parent {\n+        // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n+        let parent_id = def_map.module_id(parent_id);\n+        if item == ItemInNs::Types(ModuleDefId::ModuleId(parent_id)) {\n+            Some(ModPath::from_segments(PathKind::Super(1), None))\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum PrefixKind {\n+    /// Causes paths to always start with either `self`, `super`, `crate` or a crate-name.\n+    /// This is the same as plain, just that paths will start with `self` iprepended f the path\n+    /// starts with an identifier that is not a crate.\n+    BySelf,\n+    /// Causes paths to ignore imports in the local module.\n+    Plain,\n+    /// Causes paths to start with `crate` where applicable, effectively forcing paths to be absolute.\n+    ByCrate,\n+}\n+\n+impl PrefixKind {\n+    #[inline]\n+    fn prefix(self) -> PathKind {\n+        match self {\n+            PrefixKind::BySelf => PathKind::Super(0),\n+            PrefixKind::Plain => PathKind::Plain,\n+            PrefixKind::ByCrate => PathKind::Crate,\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_absolute(&self) -> bool {\n+        self == &PrefixKind::ByCrate\n+    }\n+}\n+/// Attempts to find a path to refer to the given `item` visible from the `from` ModuleId\n+fn find_path_inner(\n+    db: &dyn DefDatabase,\n+    item: ItemInNs,\n+    from: ModuleId,\n+    prefixed: Option<PrefixKind>,\n+) -> Option<ModPath> {\n+    // FIXME: Do fast path for std/core libs?\n+\n+    let mut visited_modules = FxHashSet::default();\n+    let def_map = from.def_map(db);\n+    find_path_inner_(db, &def_map, from, item, MAX_PATH_LEN, prefixed, &mut visited_modules)\n+}\n+\n+fn find_path_inner_(\n+    db: &dyn DefDatabase,\n+    def_map: &DefMap,\n+    from: ModuleId,\n+    item: ItemInNs,\n+    max_len: usize,\n+    mut prefixed: Option<PrefixKind>,\n+    visited_modules: &mut FxHashSet<ModuleId>,\n+) -> Option<ModPath> {\n+    if max_len == 0 {\n+        return None;\n+    }\n+\n+    // Base cases:\n+\n+    // - if the item is already in scope, return the name under which it is\n+    let scope_name = def_map.with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n+        def_map[local_id].scope.name_of(item).map(|(name, _)| name.clone())\n+    });\n+    if prefixed.is_none() {\n+        if let Some(scope_name) = scope_name {\n+            return Some(ModPath::from_segments(PathKind::Plain, Some(scope_name)));\n+        }\n+    }\n+\n+    // - if the item is a builtin, it's in scope\n+    if let ItemInNs::Types(ModuleDefId::BuiltinType(builtin)) = item {\n+        return Some(ModPath::from_segments(PathKind::Plain, Some(builtin.as_name())));\n+    }\n+\n+    // - if the item is the crate root, return `crate`\n+    let crate_root = def_map.crate_root(db);\n+    if item == ItemInNs::Types(ModuleDefId::ModuleId(crate_root)) {\n+        return Some(ModPath::from_segments(PathKind::Crate, None));\n+    }\n+\n+    if prefixed.filter(PrefixKind::is_absolute).is_none() {\n+        if let modpath @ Some(_) = check_self_super(&def_map, item, from) {\n+            return modpath;\n+        }\n+    }\n+\n+    // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n+    let root_def_map = crate_root.def_map(db);\n+    if let ItemInNs::Types(ModuleDefId::ModuleId(item)) = item {\n+        for (name, &def_id) in root_def_map.extern_prelude() {\n+            if item == def_id {\n+                let name = scope_name.unwrap_or_else(|| name.clone());\n+\n+                let name_already_occupied_in_type_ns = def_map\n+                    .with_ancestor_maps(db, from.local_id, &mut |def_map, local_id| {\n+                        def_map[local_id]\n+                            .scope\n+                            .type_(&name)\n+                            .filter(|&(id, _)| id != ModuleDefId::ModuleId(def_id))\n+                    })\n+                    .is_some();\n+                let kind = if name_already_occupied_in_type_ns {\n+                    cov_mark::hit!(ambiguous_crate_start);\n+                    PathKind::Abs\n+                } else {\n+                    PathKind::Plain\n+                };\n+                return Some(ModPath::from_segments(kind, Some(name)));\n+            }\n+        }\n+    }\n+\n+    // - if the item is in the prelude, return the name from there\n+    if let Some(prelude_module) = root_def_map.prelude() {\n+        // Preludes in block DefMaps are ignored, only the crate DefMap is searched\n+        let prelude_def_map = prelude_module.def_map(db);\n+        let prelude_scope = &prelude_def_map[prelude_module.local_id].scope;\n+        if let Some((name, vis)) = prelude_scope.name_of(item) {\n+            if vis.is_visible_from(db, from) {\n+                return Some(ModPath::from_segments(PathKind::Plain, Some(name.clone())));\n+            }\n+        }\n+    }\n+\n+    // Recursive case:\n+    // - if the item is an enum variant, refer to it via the enum\n+    if let Some(ModuleDefId::EnumVariantId(variant)) = item.as_module_def_id() {\n+        if let Some(mut path) = find_path(db, ItemInNs::Types(variant.parent.into()), from) {\n+            let data = db.enum_data(variant.parent);\n+            path.push_segment(data.variants[variant.local_id].name.clone());\n+            return Some(path);\n+        }\n+        // If this doesn't work, it seems we have no way of referring to the\n+        // enum; that's very weird, but there might still be a reexport of the\n+        // variant somewhere\n+    }\n+\n+    // - otherwise, look for modules containing (reexporting) it and import it from one of those\n+    let prefer_no_std = db.crate_supports_no_std(crate_root.krate);\n+    let mut best_path = None;\n+    let mut best_path_len = max_len;\n+\n+    if item.krate(db) == Some(from.krate) {\n+        // Item was defined in the same crate that wants to import it. It cannot be found in any\n+        // dependency in this case.\n+        // FIXME: this should have a fast path that doesn't look through the prelude again?\n+        for (module_id, name) in find_local_import_locations(db, item, from) {\n+            if !visited_modules.insert(module_id) {\n+                cov_mark::hit!(recursive_imports);\n+                continue;\n+            }\n+            if let Some(mut path) = find_path_inner_(\n+                db,\n+                def_map,\n+                from,\n+                ItemInNs::Types(ModuleDefId::ModuleId(module_id)),\n+                best_path_len - 1,\n+                prefixed,\n+                visited_modules,\n+            ) {\n+                path.push_segment(name);\n+\n+                let new_path = match best_path {\n+                    Some(best_path) => select_best_path(best_path, path, prefer_no_std),\n+                    None => path,\n+                };\n+                best_path_len = new_path.len();\n+                best_path = Some(new_path);\n+            }\n+        }\n+    } else {\n+        // Item was defined in some upstream crate. This means that it must be exported from one,\n+        // too (unless we can't name it at all). It could *also* be (re)exported by the same crate\n+        // that wants to import it here, but we always prefer to use the external path here.\n+\n+        let crate_graph = db.crate_graph();\n+        let extern_paths = crate_graph[from.krate].dependencies.iter().filter_map(|dep| {\n+            let import_map = db.import_map(dep.crate_id);\n+            import_map.import_info_for(item).and_then(|info| {\n+                // Determine best path for containing module and append last segment from `info`.\n+                // FIXME: we should guide this to look up the path locally, or from the same crate again?\n+                let mut path = find_path_inner_(\n+                    db,\n+                    def_map,\n+                    from,\n+                    ItemInNs::Types(ModuleDefId::ModuleId(info.container)),\n+                    best_path_len - 1,\n+                    prefixed,\n+                    visited_modules,\n+                )?;\n+                cov_mark::hit!(partially_imported);\n+                path.push_segment(info.path.segments.last()?.clone());\n+                Some(path)\n+            })\n+        });\n+\n+        for path in extern_paths {\n+            let new_path = match best_path {\n+                Some(best_path) => select_best_path(best_path, path, prefer_no_std),\n+                None => path,\n+            };\n+            best_path = Some(new_path);\n+        }\n+    }\n+\n+    // If the item is declared inside a block expression, don't use a prefix, as we don't handle\n+    // that correctly (FIXME).\n+    if let Some(item_module) = item.as_module_def_id().and_then(|did| did.module(db)) {\n+        if item_module.def_map(db).block_id().is_some() && prefixed.is_some() {\n+            cov_mark::hit!(prefixed_in_block_expression);\n+            prefixed = Some(PrefixKind::Plain);\n+        }\n+    }\n+\n+    match prefixed.map(PrefixKind::prefix) {\n+        Some(prefix) => best_path.or_else(|| {\n+            scope_name.map(|scope_name| ModPath::from_segments(prefix, Some(scope_name)))\n+        }),\n+        None => best_path,\n+    }\n+}\n+\n+fn select_best_path(old_path: ModPath, new_path: ModPath, prefer_no_std: bool) -> ModPath {\n+    if old_path.starts_with_std() && new_path.can_start_with_std() {\n+        if prefer_no_std {\n+            cov_mark::hit!(prefer_no_std_paths);\n+            new_path\n+        } else {\n+            cov_mark::hit!(prefer_std_paths);\n+            old_path\n+        }\n+    } else if new_path.starts_with_std() && old_path.can_start_with_std() {\n+        if prefer_no_std {\n+            cov_mark::hit!(prefer_no_std_paths);\n+            old_path\n+        } else {\n+            cov_mark::hit!(prefer_std_paths);\n+            new_path\n+        }\n+    } else if new_path.len() < old_path.len() {\n+        new_path\n+    } else {\n+        old_path\n+    }\n+}\n+\n+/// Finds locations in `from.krate` from which `item` can be imported by `from`.\n+fn find_local_import_locations(\n+    db: &dyn DefDatabase,\n+    item: ItemInNs,\n+    from: ModuleId,\n+) -> Vec<(ModuleId, Name)> {\n+    let _p = profile::span(\"find_local_import_locations\");\n+\n+    // `from` can import anything below `from` with visibility of at least `from`, and anything\n+    // above `from` with any visibility. That means we do not need to descend into private siblings\n+    // of `from` (and similar).\n+\n+    let def_map = from.def_map(db);\n+\n+    // Compute the initial worklist. We start with all direct child modules of `from` as well as all\n+    // of its (recursive) parent modules.\n+    let data = &def_map[from.local_id];\n+    let mut worklist =\n+        data.children.values().map(|child| def_map.module_id(*child)).collect::<Vec<_>>();\n+    // FIXME: do we need to traverse out of block expressions here?\n+    for ancestor in iter::successors(from.containing_module(db), |m| m.containing_module(db)) {\n+        worklist.push(ancestor);\n+    }\n+\n+    let def_map = def_map.crate_root(db).def_map(db);\n+\n+    let mut seen: FxHashSet<_> = FxHashSet::default();\n+\n+    let mut locations = Vec::new();\n+    while let Some(module) = worklist.pop() {\n+        if !seen.insert(module) {\n+            continue; // already processed this module\n+        }\n+\n+        let ext_def_map;\n+        let data = if module.krate == from.krate {\n+            if module.block.is_some() {\n+                // Re-query the block's DefMap\n+                ext_def_map = module.def_map(db);\n+                &ext_def_map[module.local_id]\n+            } else {\n+                // Reuse the root DefMap\n+                &def_map[module.local_id]\n+            }\n+        } else {\n+            // The crate might reexport a module defined in another crate.\n+            ext_def_map = module.def_map(db);\n+            &ext_def_map[module.local_id]\n+        };\n+\n+        if let Some((name, vis)) = data.scope.name_of(item) {\n+            if vis.is_visible_from(db, from) {\n+                let is_private = match vis {\n+                    Visibility::Module(private_to) => private_to.local_id == module.local_id,\n+                    Visibility::Public => false,\n+                };\n+                let is_original_def = match item.as_module_def_id() {\n+                    Some(module_def_id) => data.scope.declarations().any(|it| it == module_def_id),\n+                    None => false,\n+                };\n+\n+                // Ignore private imports. these could be used if we are\n+                // in a submodule of this module, but that's usually not\n+                // what the user wants; and if this module can import\n+                // the item and we're a submodule of it, so can we.\n+                // Also this keeps the cached data smaller.\n+                if !is_private || is_original_def {\n+                    locations.push((module, name.clone()));\n+                }\n+            }\n+        }\n+\n+        // Descend into all modules visible from `from`.\n+        for (ty, vis) in data.scope.types() {\n+            if let ModuleDefId::ModuleId(module) = ty {\n+                if vis.is_visible_from(db, from) {\n+                    worklist.push(module);\n+                }\n+            }\n+        }\n+    }\n+\n+    locations\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use base_db::fixture::WithFixture;\n+    use hir_expand::hygiene::Hygiene;\n+    use syntax::ast::AstNode;\n+\n+    use crate::test_db::TestDB;\n+\n+    use super::*;\n+\n+    /// `code` needs to contain a cursor marker; checks that `find_path` for the\n+    /// item the `path` refers to returns that same path when called from the\n+    /// module the cursor is in.\n+    fn check_found_path_(ra_fixture: &str, path: &str, prefix_kind: Option<PrefixKind>) {\n+        let (db, pos) = TestDB::with_position(ra_fixture);\n+        let module = db.module_at_position(pos);\n+        let parsed_path_file = syntax::SourceFile::parse(&format!(\"use {};\", path));\n+        let ast_path =\n+            parsed_path_file.syntax_node().descendants().find_map(syntax::ast::Path::cast).unwrap();\n+        let mod_path = ModPath::from_src(&db, ast_path, &Hygiene::new_unhygienic()).unwrap();\n+\n+        let def_map = module.def_map(&db);\n+        let resolved = def_map\n+            .resolve_path(\n+                &db,\n+                module.local_id,\n+                &mod_path,\n+                crate::item_scope::BuiltinShadowMode::Module,\n+            )\n+            .0\n+            .take_types()\n+            .unwrap();\n+\n+        let found_path = find_path_inner(&db, ItemInNs::Types(resolved), module, prefix_kind);\n+        assert_eq!(found_path, Some(mod_path), \"{:?}\", prefix_kind);\n+    }\n+\n+    fn check_found_path(\n+        ra_fixture: &str,\n+        unprefixed: &str,\n+        prefixed: &str,\n+        absolute: &str,\n+        self_prefixed: &str,\n+    ) {\n+        check_found_path_(ra_fixture, unprefixed, None);\n+        check_found_path_(ra_fixture, prefixed, Some(PrefixKind::Plain));\n+        check_found_path_(ra_fixture, absolute, Some(PrefixKind::ByCrate));\n+        check_found_path_(ra_fixture, self_prefixed, Some(PrefixKind::BySelf));\n+    }\n+\n+    #[test]\n+    fn same_module() {\n+        check_found_path(\n+            r#\"\n+struct S;\n+$0\n+        \"#,\n+            \"S\",\n+            \"S\",\n+            \"crate::S\",\n+            \"self::S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_variant() {\n+        check_found_path(\n+            r#\"\n+enum E { A }\n+$0\n+        \"#,\n+            \"E::A\",\n+            \"E::A\",\n+            \"E::A\",\n+            \"E::A\",\n+        );\n+    }\n+\n+    #[test]\n+    fn sub_module() {\n+        check_found_path(\n+            r#\"\n+mod foo {\n+    pub struct S;\n+}\n+$0\n+        \"#,\n+            \"foo::S\",\n+            \"foo::S\",\n+            \"crate::foo::S\",\n+            \"self::foo::S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn super_module() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs\n+mod foo;\n+//- /foo.rs\n+mod bar;\n+struct S;\n+//- /foo/bar.rs\n+$0\n+        \"#,\n+            \"super::S\",\n+            \"super::S\",\n+            \"crate::foo::S\",\n+            \"super::S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn self_module() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs\n+mod foo;\n+//- /foo.rs\n+$0\n+        \"#,\n+            \"self\",\n+            \"self\",\n+            \"crate::foo\",\n+            \"self\",\n+        );\n+    }\n+\n+    #[test]\n+    fn crate_root() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs\n+mod foo;\n+//- /foo.rs\n+$0\n+        \"#,\n+            \"crate\",\n+            \"crate\",\n+            \"crate\",\n+            \"crate\",\n+        );\n+    }\n+\n+    #[test]\n+    fn same_crate() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs\n+mod foo;\n+struct S;\n+//- /foo.rs\n+$0\n+        \"#,\n+            \"crate::S\",\n+            \"crate::S\",\n+            \"crate::S\",\n+            \"crate::S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn different_crate() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:std\n+$0\n+//- /std.rs crate:std\n+pub struct S;\n+        \"#,\n+            \"std::S\",\n+            \"std::S\",\n+            \"std::S\",\n+            \"std::S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn different_crate_renamed() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:std\n+extern crate std as std_renamed;\n+$0\n+//- /std.rs crate:std\n+pub struct S;\n+        \"#,\n+            \"std_renamed::S\",\n+            \"std_renamed::S\",\n+            \"std_renamed::S\",\n+            \"std_renamed::S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn partially_imported() {\n+        cov_mark::check!(partially_imported);\n+        // Tests that short paths are used even for external items, when parts of the path are\n+        // already in scope.\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:syntax\n+\n+use syntax::ast;\n+$0\n+\n+//- /lib.rs crate:syntax\n+pub mod ast {\n+    pub enum ModuleItem {\n+        A, B, C,\n+    }\n+}\n+        \"#,\n+            \"ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n+        );\n+\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:syntax\n+$0\n+\n+//- /lib.rs crate:syntax\n+pub mod ast {\n+    pub enum ModuleItem {\n+        A, B, C,\n+    }\n+}\n+        \"#,\n+            \"syntax::ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n+        );\n+    }\n+\n+    #[test]\n+    fn same_crate_reexport() {\n+        check_found_path(\n+            r#\"\n+mod bar {\n+    mod foo { pub(super) struct S; }\n+    pub(crate) use foo::*;\n+}\n+$0\n+        \"#,\n+            \"bar::S\",\n+            \"bar::S\",\n+            \"crate::bar::S\",\n+            \"self::bar::S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn same_crate_reexport_rename() {\n+        check_found_path(\n+            r#\"\n+mod bar {\n+    mod foo { pub(super) struct S; }\n+    pub(crate) use foo::S as U;\n+}\n+$0\n+        \"#,\n+            \"bar::U\",\n+            \"bar::U\",\n+            \"crate::bar::U\",\n+            \"self::bar::U\",\n+        );\n+    }\n+\n+    #[test]\n+    fn different_crate_reexport() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:std\n+$0\n+//- /std.rs crate:std deps:core\n+pub use core::S;\n+//- /core.rs crate:core\n+pub struct S;\n+        \"#,\n+            \"std::S\",\n+            \"std::S\",\n+            \"std::S\",\n+            \"std::S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn prelude() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:std\n+$0\n+//- /std.rs crate:std\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub struct S;\n+    }\n+}\n+        \"#,\n+            \"S\",\n+            \"S\",\n+            \"S\",\n+            \"S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_variant_from_prelude() {\n+        let code = r#\"\n+//- /main.rs crate:main deps:std\n+$0\n+//- /std.rs crate:std\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub enum Option<T> { Some(T), None }\n+        pub use Option::*;\n+    }\n+}\n+        \"#;\n+        check_found_path(code, \"None\", \"None\", \"None\", \"None\");\n+        check_found_path(code, \"Some\", \"Some\", \"Some\", \"Some\");\n+    }\n+\n+    #[test]\n+    fn shortest_path() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs\n+pub mod foo;\n+pub mod baz;\n+struct S;\n+$0\n+//- /foo.rs\n+pub mod bar { pub struct S; }\n+//- /baz.rs\n+pub use crate::foo::bar::S;\n+        \"#,\n+            \"baz::S\",\n+            \"baz::S\",\n+            \"crate::baz::S\",\n+            \"self::baz::S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn discount_private_imports() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs\n+mod foo;\n+pub mod bar { pub struct S; }\n+use bar::S;\n+//- /foo.rs\n+$0\n+        \"#,\n+            // crate::S would be shorter, but using private imports seems wrong\n+            \"crate::bar::S\",\n+            \"crate::bar::S\",\n+            \"crate::bar::S\",\n+            \"crate::bar::S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn import_cycle() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs\n+pub mod foo;\n+pub mod bar;\n+pub mod baz;\n+//- /bar.rs\n+$0\n+//- /foo.rs\n+pub use super::baz;\n+pub struct S;\n+//- /baz.rs\n+pub use super::foo;\n+        \"#,\n+            \"crate::foo::S\",\n+            \"crate::foo::S\",\n+            \"crate::foo::S\",\n+            \"crate::foo::S\",\n+        );\n+    }\n+\n+    #[test]\n+    fn prefer_std_paths_over_alloc() {\n+        cov_mark::check!(prefer_std_paths);\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:alloc,std\n+$0\n+\n+//- /std.rs crate:std deps:alloc\n+pub mod sync {\n+    pub use alloc::sync::Arc;\n+}\n+\n+//- /zzz.rs crate:alloc\n+pub mod sync {\n+    pub struct Arc;\n+}\n+        \"#,\n+            \"std::sync::Arc\",\n+            \"std::sync::Arc\",\n+            \"std::sync::Arc\",\n+            \"std::sync::Arc\",\n+        );\n+    }\n+\n+    #[test]\n+    fn prefer_core_paths_over_std() {\n+        cov_mark::check!(prefer_no_std_paths);\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:core,std\n+#![no_std]\n+\n+$0\n+\n+//- /std.rs crate:std deps:core\n+\n+pub mod fmt {\n+    pub use core::fmt::Error;\n+}\n+\n+//- /zzz.rs crate:core\n+\n+pub mod fmt {\n+    pub struct Error;\n+}\n+        \"#,\n+            \"core::fmt::Error\",\n+            \"core::fmt::Error\",\n+            \"core::fmt::Error\",\n+            \"core::fmt::Error\",\n+        );\n+\n+        // Should also work (on a best-effort basis) if `no_std` is conditional.\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:core,std\n+#![cfg_attr(not(test), no_std)]\n+\n+$0\n+\n+//- /std.rs crate:std deps:core\n+\n+pub mod fmt {\n+    pub use core::fmt::Error;\n+}\n+\n+//- /zzz.rs crate:core\n+\n+pub mod fmt {\n+    pub struct Error;\n+}\n+        \"#,\n+            \"core::fmt::Error\",\n+            \"core::fmt::Error\",\n+            \"core::fmt::Error\",\n+            \"core::fmt::Error\",\n+        );\n+    }\n+\n+    #[test]\n+    fn prefer_alloc_paths_over_std() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:alloc,std\n+#![no_std]\n+\n+$0\n+\n+//- /std.rs crate:std deps:alloc\n+\n+pub mod sync {\n+    pub use alloc::sync::Arc;\n+}\n+\n+//- /zzz.rs crate:alloc\n+\n+pub mod sync {\n+    pub struct Arc;\n+}\n+            \"#,\n+            \"alloc::sync::Arc\",\n+            \"alloc::sync::Arc\",\n+            \"alloc::sync::Arc\",\n+            \"alloc::sync::Arc\",\n+        );\n+    }\n+\n+    #[test]\n+    fn prefer_shorter_paths_if_not_alloc() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:megaalloc,std\n+$0\n+\n+//- /std.rs crate:std deps:megaalloc\n+pub mod sync {\n+    pub use megaalloc::sync::Arc;\n+}\n+\n+//- /zzz.rs crate:megaalloc\n+pub struct Arc;\n+            \"#,\n+            \"megaalloc::Arc\",\n+            \"megaalloc::Arc\",\n+            \"megaalloc::Arc\",\n+            \"megaalloc::Arc\",\n+        );\n+    }\n+\n+    #[test]\n+    fn builtins_are_in_scope() {\n+        let code = r#\"\n+$0\n+\n+pub mod primitive {\n+    pub use u8;\n+}\n+        \"#;\n+        check_found_path(code, \"u8\", \"u8\", \"u8\", \"u8\");\n+        check_found_path(code, \"u16\", \"u16\", \"u16\", \"u16\");\n+    }\n+\n+    #[test]\n+    fn inner_items() {\n+        check_found_path(\n+            r#\"\n+fn main() {\n+    struct Inner {}\n+    $0\n+}\n+        \"#,\n+            \"Inner\",\n+            \"Inner\",\n+            \"Inner\",\n+            \"Inner\",\n+        );\n+    }\n+\n+    #[test]\n+    fn inner_items_from_outer_scope() {\n+        check_found_path(\n+            r#\"\n+fn main() {\n+    struct Struct {}\n+    {\n+        $0\n+    }\n+}\n+        \"#,\n+            \"Struct\",\n+            \"Struct\",\n+            \"Struct\",\n+            \"Struct\",\n+        );\n+    }\n+\n+    #[test]\n+    fn inner_items_from_inner_module() {\n+        cov_mark::check!(prefixed_in_block_expression);\n+        check_found_path(\n+            r#\"\n+fn main() {\n+    mod module {\n+        struct Struct {}\n+    }\n+    {\n+        $0\n+    }\n+}\n+        \"#,\n+            \"module::Struct\",\n+            \"module::Struct\",\n+            \"module::Struct\",\n+            \"module::Struct\",\n+        );\n+    }\n+\n+    #[test]\n+    fn outer_items_with_inner_items_present() {\n+        check_found_path(\n+            r#\"\n+mod module {\n+    pub struct CompleteMe;\n+}\n+\n+fn main() {\n+    fn inner() {}\n+    $0\n+}\n+            \"#,\n+            // FIXME: these could use fewer/better prefixes\n+            \"module::CompleteMe\",\n+            \"crate::module::CompleteMe\",\n+            \"crate::module::CompleteMe\",\n+            \"crate::module::CompleteMe\",\n+        )\n+    }\n+\n+    #[test]\n+    fn from_inside_module() {\n+        // This worked correctly, but the test suite logic was broken.\n+        cov_mark::check!(submodule_in_testdb);\n+        check_found_path(\n+            r#\"\n+mod baz {\n+    pub struct Foo {}\n+}\n+\n+mod bar {\n+    fn bar() {\n+        $0\n+    }\n+}\n+            \"#,\n+            \"crate::baz::Foo\",\n+            \"crate::baz::Foo\",\n+            \"crate::baz::Foo\",\n+            \"crate::baz::Foo\",\n+        )\n+    }\n+\n+    #[test]\n+    fn from_inside_module_with_inner_items() {\n+        check_found_path(\n+            r#\"\n+mod baz {\n+    pub struct Foo {}\n+}\n+\n+mod bar {\n+    fn bar() {\n+        fn inner() {}\n+        $0\n+    }\n+}\n+            \"#,\n+            \"crate::baz::Foo\",\n+            \"crate::baz::Foo\",\n+            \"crate::baz::Foo\",\n+            \"crate::baz::Foo\",\n+        )\n+    }\n+\n+    #[test]\n+    fn recursive_pub_mod_reexport() {\n+        cov_mark::check!(recursive_imports);\n+        check_found_path(\n+            r#\"\n+fn main() {\n+    let _ = 22_i32.as_name$0();\n+}\n+\n+pub mod name {\n+    pub trait AsName {\n+        fn as_name(&self) -> String;\n+    }\n+    impl AsName for i32 {\n+        fn as_name(&self) -> String {\n+            format!(\"Name: {}\", self)\n+        }\n+    }\n+    pub use crate::name;\n+}\n+\"#,\n+            \"name::AsName\",\n+            \"name::AsName\",\n+            \"crate::name::AsName\",\n+            \"self::name::AsName\",\n+        );\n+    }\n+\n+    #[test]\n+    fn extern_crate() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:dep\n+$0\n+//- /dep.rs crate:dep\n+\"#,\n+            \"dep\",\n+            \"dep\",\n+            \"dep\",\n+            \"dep\",\n+        );\n+\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:dep\n+fn f() {\n+    fn inner() {}\n+    $0\n+}\n+//- /dep.rs crate:dep\n+\"#,\n+            \"dep\",\n+            \"dep\",\n+            \"dep\",\n+            \"dep\",\n+        );\n+    }\n+\n+    #[test]\n+    fn prelude_with_inner_items() {\n+        check_found_path(\n+            r#\"\n+//- /main.rs crate:main deps:std\n+fn f() {\n+    fn inner() {}\n+    $0\n+}\n+//- /std.rs crate:std\n+pub mod prelude {\n+    pub mod rust_2018 {\n+        pub enum Option { None }\n+        pub use Option::*;\n+    }\n+}\n+        \"#,\n+            \"None\",\n+            \"None\",\n+            \"None\",\n+            \"None\",\n+        );\n+    }\n+}"}, {"sha": "2397cf5015848038b2b2401d8b600b89534aaeaa", "filename": "src/tools/rust-analyzer/crates/hir-def/src/generics.rs", "status": "added", "additions": 522, "deletions": 0, "changes": 522, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,522 @@\n+//! Many kinds of items or constructs can have generic parameters: functions,\n+//! structs, impls, traits, etc. This module provides a common HIR for these\n+//! generic parameters. See also the `Generics` type and the `generics_of` query\n+//! in rustc.\n+\n+use base_db::FileId;\n+use either::Either;\n+use hir_expand::{\n+    name::{AsName, Name},\n+    ExpandResult, HirFileId, InFile,\n+};\n+use la_arena::{Arena, ArenaMap, Idx};\n+use once_cell::unsync::Lazy;\n+use std::ops::DerefMut;\n+use stdx::impl_from;\n+use syntax::ast::{self, HasGenericParams, HasName, HasTypeBounds};\n+\n+use crate::{\n+    body::{Expander, LowerCtx},\n+    child_by_source::ChildBySource,\n+    db::DefDatabase,\n+    dyn_map::DynMap,\n+    intern::Interned,\n+    keys,\n+    src::{HasChildSource, HasSource},\n+    type_ref::{LifetimeRef, TypeBound, TypeRef},\n+    AdtId, ConstParamId, GenericDefId, HasModule, LifetimeParamId, LocalLifetimeParamId,\n+    LocalTypeOrConstParamId, Lookup, TypeOrConstParamId, TypeParamId,\n+};\n+\n+/// Data about a generic type parameter (to a function, struct, impl, ...).\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct TypeParamData {\n+    pub name: Option<Name>,\n+    pub default: Option<Interned<TypeRef>>,\n+    pub provenance: TypeParamProvenance,\n+}\n+\n+/// Data about a generic lifetime parameter (to a function, struct, impl, ...).\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct LifetimeParamData {\n+    pub name: Name,\n+}\n+\n+/// Data about a generic const parameter (to a function, struct, impl, ...).\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct ConstParamData {\n+    pub name: Name,\n+    pub ty: Interned<TypeRef>,\n+    pub has_default: bool,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum TypeParamProvenance {\n+    TypeParamList,\n+    TraitSelf,\n+    ArgumentImplTrait,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum TypeOrConstParamData {\n+    TypeParamData(TypeParamData),\n+    ConstParamData(ConstParamData),\n+}\n+\n+impl TypeOrConstParamData {\n+    pub fn name(&self) -> Option<&Name> {\n+        match self {\n+            TypeOrConstParamData::TypeParamData(x) => x.name.as_ref(),\n+            TypeOrConstParamData::ConstParamData(x) => Some(&x.name),\n+        }\n+    }\n+\n+    pub fn has_default(&self) -> bool {\n+        match self {\n+            TypeOrConstParamData::TypeParamData(x) => x.default.is_some(),\n+            TypeOrConstParamData::ConstParamData(x) => x.has_default,\n+        }\n+    }\n+\n+    pub fn type_param(&self) -> Option<&TypeParamData> {\n+        match self {\n+            TypeOrConstParamData::TypeParamData(x) => Some(x),\n+            TypeOrConstParamData::ConstParamData(_) => None,\n+        }\n+    }\n+\n+    pub fn const_param(&self) -> Option<&ConstParamData> {\n+        match self {\n+            TypeOrConstParamData::TypeParamData(_) => None,\n+            TypeOrConstParamData::ConstParamData(x) => Some(x),\n+        }\n+    }\n+\n+    pub fn is_trait_self(&self) -> bool {\n+        match self {\n+            TypeOrConstParamData::TypeParamData(x) => {\n+                x.provenance == TypeParamProvenance::TraitSelf\n+            }\n+            TypeOrConstParamData::ConstParamData(_) => false,\n+        }\n+    }\n+}\n+\n+impl_from!(TypeParamData, ConstParamData for TypeOrConstParamData);\n+\n+/// Data about the generic parameters of a function, struct, impl, etc.\n+#[derive(Clone, PartialEq, Eq, Debug, Default, Hash)]\n+pub struct GenericParams {\n+    pub type_or_consts: Arena<TypeOrConstParamData>,\n+    pub lifetimes: Arena<LifetimeParamData>,\n+    pub where_predicates: Vec<WherePredicate>,\n+}\n+\n+/// A single predicate from a where clause, i.e. `where Type: Trait`. Combined\n+/// where clauses like `where T: Foo + Bar` are turned into multiple of these.\n+/// It might still result in multiple actual predicates though, because of\n+/// associated type bindings like `Iterator<Item = u32>`.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum WherePredicate {\n+    TypeBound {\n+        target: WherePredicateTypeTarget,\n+        bound: Interned<TypeBound>,\n+    },\n+    Lifetime {\n+        target: LifetimeRef,\n+        bound: LifetimeRef,\n+    },\n+    ForLifetime {\n+        lifetimes: Box<[Name]>,\n+        target: WherePredicateTypeTarget,\n+        bound: Interned<TypeBound>,\n+    },\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum WherePredicateTypeTarget {\n+    TypeRef(Interned<TypeRef>),\n+    /// For desugared where predicates that can directly refer to a type param.\n+    TypeOrConstParam(LocalTypeOrConstParamId),\n+}\n+\n+impl GenericParams {\n+    /// Iterator of type_or_consts field\n+    pub fn iter<'a>(\n+        &'a self,\n+    ) -> impl DoubleEndedIterator<Item = (Idx<TypeOrConstParamData>, &TypeOrConstParamData)> {\n+        self.type_or_consts.iter()\n+    }\n+\n+    pub(crate) fn generic_params_query(\n+        db: &dyn DefDatabase,\n+        def: GenericDefId,\n+    ) -> Interned<GenericParams> {\n+        let _p = profile::span(\"generic_params_query\");\n+\n+        macro_rules! id_to_generics {\n+            ($id:ident) => {{\n+                let id = $id.lookup(db).id;\n+                let tree = id.item_tree(db);\n+                let item = &tree[id.value];\n+                item.generic_params.clone()\n+            }};\n+        }\n+\n+        match def {\n+            GenericDefId::FunctionId(id) => {\n+                let loc = id.lookup(db);\n+                let tree = loc.id.item_tree(db);\n+                let item = &tree[loc.id.value];\n+\n+                let mut generic_params = GenericParams::clone(&item.explicit_generic_params);\n+\n+                let module = loc.container.module(db);\n+                let func_data = db.function_data(id);\n+\n+                // Don't create an `Expander` nor call `loc.source(db)` if not needed since this\n+                // causes a reparse after the `ItemTree` has been created.\n+                let mut expander = Lazy::new(|| Expander::new(db, loc.source(db).file_id, module));\n+                for (_, param) in &func_data.params {\n+                    generic_params.fill_implicit_impl_trait_args(db, &mut expander, param);\n+                }\n+\n+                Interned::new(generic_params)\n+            }\n+            GenericDefId::AdtId(AdtId::StructId(id)) => id_to_generics!(id),\n+            GenericDefId::AdtId(AdtId::EnumId(id)) => id_to_generics!(id),\n+            GenericDefId::AdtId(AdtId::UnionId(id)) => id_to_generics!(id),\n+            GenericDefId::TraitId(id) => id_to_generics!(id),\n+            GenericDefId::TypeAliasId(id) => id_to_generics!(id),\n+            GenericDefId::ImplId(id) => id_to_generics!(id),\n+            GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => {\n+                Interned::new(GenericParams::default())\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn fill(&mut self, lower_ctx: &LowerCtx<'_>, node: &dyn HasGenericParams) {\n+        if let Some(params) = node.generic_param_list() {\n+            self.fill_params(lower_ctx, params)\n+        }\n+        if let Some(where_clause) = node.where_clause() {\n+            self.fill_where_predicates(lower_ctx, where_clause);\n+        }\n+    }\n+\n+    pub(crate) fn fill_bounds(\n+        &mut self,\n+        lower_ctx: &LowerCtx<'_>,\n+        node: &dyn ast::HasTypeBounds,\n+        target: Either<TypeRef, LifetimeRef>,\n+    ) {\n+        for bound in\n+            node.type_bound_list().iter().flat_map(|type_bound_list| type_bound_list.bounds())\n+        {\n+            self.add_where_predicate_from_bound(lower_ctx, bound, None, target.clone());\n+        }\n+    }\n+\n+    fn fill_params(&mut self, lower_ctx: &LowerCtx<'_>, params: ast::GenericParamList) {\n+        for type_or_const_param in params.type_or_const_params() {\n+            match type_or_const_param {\n+                ast::TypeOrConstParam::Type(type_param) => {\n+                    let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n+                    // FIXME: Use `Path::from_src`\n+                    let default = type_param\n+                        .default_type()\n+                        .map(|it| Interned::new(TypeRef::from_ast(lower_ctx, it)));\n+                    let param = TypeParamData {\n+                        name: Some(name.clone()),\n+                        default,\n+                        provenance: TypeParamProvenance::TypeParamList,\n+                    };\n+                    self.type_or_consts.alloc(param.into());\n+                    let type_ref = TypeRef::Path(name.into());\n+                    self.fill_bounds(lower_ctx, &type_param, Either::Left(type_ref));\n+                }\n+                ast::TypeOrConstParam::Const(const_param) => {\n+                    let name = const_param.name().map_or_else(Name::missing, |it| it.as_name());\n+                    let ty = const_param\n+                        .ty()\n+                        .map_or(TypeRef::Error, |it| TypeRef::from_ast(lower_ctx, it));\n+                    let param = ConstParamData {\n+                        name,\n+                        ty: Interned::new(ty),\n+                        has_default: const_param.default_val().is_some(),\n+                    };\n+                    self.type_or_consts.alloc(param.into());\n+                }\n+            }\n+        }\n+        for lifetime_param in params.lifetime_params() {\n+            let name =\n+                lifetime_param.lifetime().map_or_else(Name::missing, |lt| Name::new_lifetime(&lt));\n+            let param = LifetimeParamData { name: name.clone() };\n+            self.lifetimes.alloc(param);\n+            let lifetime_ref = LifetimeRef::new_name(name);\n+            self.fill_bounds(lower_ctx, &lifetime_param, Either::Right(lifetime_ref));\n+        }\n+    }\n+\n+    fn fill_where_predicates(&mut self, lower_ctx: &LowerCtx<'_>, where_clause: ast::WhereClause) {\n+        for pred in where_clause.predicates() {\n+            let target = if let Some(type_ref) = pred.ty() {\n+                Either::Left(TypeRef::from_ast(lower_ctx, type_ref))\n+            } else if let Some(lifetime) = pred.lifetime() {\n+                Either::Right(LifetimeRef::new(&lifetime))\n+            } else {\n+                continue;\n+            };\n+\n+            let lifetimes: Option<Box<_>> = pred.generic_param_list().map(|param_list| {\n+                // Higher-Ranked Trait Bounds\n+                param_list\n+                    .lifetime_params()\n+                    .map(|lifetime_param| {\n+                        lifetime_param\n+                            .lifetime()\n+                            .map_or_else(Name::missing, |lt| Name::new_lifetime(&lt))\n+                    })\n+                    .collect()\n+            });\n+            for bound in pred.type_bound_list().iter().flat_map(|l| l.bounds()) {\n+                self.add_where_predicate_from_bound(\n+                    lower_ctx,\n+                    bound,\n+                    lifetimes.as_ref(),\n+                    target.clone(),\n+                );\n+            }\n+        }\n+    }\n+\n+    fn add_where_predicate_from_bound(\n+        &mut self,\n+        lower_ctx: &LowerCtx<'_>,\n+        bound: ast::TypeBound,\n+        hrtb_lifetimes: Option<&Box<[Name]>>,\n+        target: Either<TypeRef, LifetimeRef>,\n+    ) {\n+        let bound = TypeBound::from_ast(lower_ctx, bound);\n+        let predicate = match (target, bound) {\n+            (Either::Left(type_ref), bound) => match hrtb_lifetimes {\n+                Some(hrtb_lifetimes) => WherePredicate::ForLifetime {\n+                    lifetimes: hrtb_lifetimes.clone(),\n+                    target: WherePredicateTypeTarget::TypeRef(Interned::new(type_ref)),\n+                    bound: Interned::new(bound),\n+                },\n+                None => WherePredicate::TypeBound {\n+                    target: WherePredicateTypeTarget::TypeRef(Interned::new(type_ref)),\n+                    bound: Interned::new(bound),\n+                },\n+            },\n+            (Either::Right(lifetime), TypeBound::Lifetime(bound)) => {\n+                WherePredicate::Lifetime { target: lifetime, bound }\n+            }\n+            _ => return,\n+        };\n+        self.where_predicates.push(predicate);\n+    }\n+\n+    pub(crate) fn fill_implicit_impl_trait_args(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        expander: &mut impl DerefMut<Target = Expander>,\n+        type_ref: &TypeRef,\n+    ) {\n+        type_ref.walk(&mut |type_ref| {\n+            if let TypeRef::ImplTrait(bounds) = type_ref {\n+                let param = TypeParamData {\n+                    name: None,\n+                    default: None,\n+                    provenance: TypeParamProvenance::ArgumentImplTrait,\n+                };\n+                let param_id = self.type_or_consts.alloc(param.into());\n+                for bound in bounds {\n+                    self.where_predicates.push(WherePredicate::TypeBound {\n+                        target: WherePredicateTypeTarget::TypeOrConstParam(param_id),\n+                        bound: bound.clone(),\n+                    });\n+                }\n+            }\n+            if let TypeRef::Macro(mc) = type_ref {\n+                let macro_call = mc.to_node(db.upcast());\n+                match expander.enter_expand::<ast::Type>(db, macro_call) {\n+                    Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n+                        let ctx = LowerCtx::new(db, expander.current_file_id());\n+                        let type_ref = TypeRef::from_ast(&ctx, expanded);\n+                        self.fill_implicit_impl_trait_args(db, expander, &type_ref);\n+                        expander.exit(db, mark);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        });\n+    }\n+\n+    pub(crate) fn shrink_to_fit(&mut self) {\n+        let Self { lifetimes, type_or_consts: types, where_predicates } = self;\n+        lifetimes.shrink_to_fit();\n+        types.shrink_to_fit();\n+        where_predicates.shrink_to_fit();\n+    }\n+\n+    pub fn find_type_by_name(&self, name: &Name, parent: GenericDefId) -> Option<TypeParamId> {\n+        self.type_or_consts.iter().find_map(|(id, p)| {\n+            if p.name().as_ref() == Some(&name) && p.type_param().is_some() {\n+                Some(TypeParamId::from_unchecked(TypeOrConstParamId { local_id: id, parent }))\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    pub fn find_const_by_name(&self, name: &Name, parent: GenericDefId) -> Option<ConstParamId> {\n+        self.type_or_consts.iter().find_map(|(id, p)| {\n+            if p.name().as_ref() == Some(&name) && p.const_param().is_some() {\n+                Some(ConstParamId::from_unchecked(TypeOrConstParamId { local_id: id, parent }))\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    pub fn find_trait_self_param(&self) -> Option<LocalTypeOrConstParamId> {\n+        self.type_or_consts.iter().find_map(|(id, p)| {\n+            matches!(\n+                p,\n+                TypeOrConstParamData::TypeParamData(TypeParamData {\n+                    provenance: TypeParamProvenance::TraitSelf,\n+                    ..\n+                })\n+            )\n+            .then(|| id)\n+        })\n+    }\n+}\n+\n+fn file_id_and_params_of(\n+    def: GenericDefId,\n+    db: &dyn DefDatabase,\n+) -> (HirFileId, Option<ast::GenericParamList>) {\n+    match def {\n+        GenericDefId::FunctionId(it) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        GenericDefId::AdtId(AdtId::StructId(it)) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        GenericDefId::AdtId(AdtId::UnionId(it)) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        GenericDefId::AdtId(AdtId::EnumId(it)) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        GenericDefId::TraitId(it) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        GenericDefId::TypeAliasId(it) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        GenericDefId::ImplId(it) => {\n+            let src = it.lookup(db).source(db);\n+            (src.file_id, src.value.generic_param_list())\n+        }\n+        // We won't be using this ID anyway\n+        GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => (FileId(!0).into(), None),\n+    }\n+}\n+\n+impl HasChildSource<LocalTypeOrConstParamId> for GenericDefId {\n+    type Value = Either<ast::TypeOrConstParam, ast::Trait>;\n+    fn child_source(\n+        &self,\n+        db: &dyn DefDatabase,\n+    ) -> InFile<ArenaMap<LocalTypeOrConstParamId, Self::Value>> {\n+        let generic_params = db.generic_params(*self);\n+        let mut idx_iter = generic_params.type_or_consts.iter().map(|(idx, _)| idx);\n+\n+        let (file_id, generic_params_list) = file_id_and_params_of(*self, db);\n+\n+        let mut params = ArenaMap::default();\n+\n+        // For traits the first type index is `Self`, we need to add it before the other params.\n+        if let GenericDefId::TraitId(id) = *self {\n+            let trait_ref = id.lookup(db).source(db).value;\n+            let idx = idx_iter.next().unwrap();\n+            params.insert(idx, Either::Right(trait_ref))\n+        }\n+\n+        if let Some(generic_params_list) = generic_params_list {\n+            for (idx, ast_param) in idx_iter.zip(generic_params_list.type_or_const_params()) {\n+                params.insert(idx, Either::Left(ast_param));\n+            }\n+        }\n+\n+        InFile::new(file_id, params)\n+    }\n+}\n+\n+impl HasChildSource<LocalLifetimeParamId> for GenericDefId {\n+    type Value = ast::LifetimeParam;\n+    fn child_source(\n+        &self,\n+        db: &dyn DefDatabase,\n+    ) -> InFile<ArenaMap<LocalLifetimeParamId, Self::Value>> {\n+        let generic_params = db.generic_params(*self);\n+        let idx_iter = generic_params.lifetimes.iter().map(|(idx, _)| idx);\n+\n+        let (file_id, generic_params_list) = file_id_and_params_of(*self, db);\n+\n+        let mut params = ArenaMap::default();\n+\n+        if let Some(generic_params_list) = generic_params_list {\n+            for (idx, ast_param) in idx_iter.zip(generic_params_list.lifetime_params()) {\n+                params.insert(idx, ast_param);\n+            }\n+        }\n+\n+        InFile::new(file_id, params)\n+    }\n+}\n+\n+impl ChildBySource for GenericDefId {\n+    fn child_by_source_to(&self, db: &dyn DefDatabase, res: &mut DynMap, file_id: HirFileId) {\n+        let (gfile_id, generic_params_list) = file_id_and_params_of(*self, db);\n+        if gfile_id != file_id {\n+            return;\n+        }\n+\n+        let generic_params = db.generic_params(*self);\n+        let mut toc_idx_iter = generic_params.type_or_consts.iter().map(|(idx, _)| idx);\n+        let lts_idx_iter = generic_params.lifetimes.iter().map(|(idx, _)| idx);\n+\n+        // For traits the first type index is `Self`, skip it.\n+        if let GenericDefId::TraitId(_) = *self {\n+            toc_idx_iter.next().unwrap(); // advance_by(1);\n+        }\n+\n+        if let Some(generic_params_list) = generic_params_list {\n+            for (local_id, ast_param) in\n+                toc_idx_iter.zip(generic_params_list.type_or_const_params())\n+            {\n+                let id = TypeOrConstParamId { parent: *self, local_id };\n+                match ast_param {\n+                    ast::TypeOrConstParam::Type(a) => res[keys::TYPE_PARAM].insert(a, id),\n+                    ast::TypeOrConstParam::Const(a) => res[keys::CONST_PARAM].insert(a, id),\n+                }\n+            }\n+            for (local_id, ast_param) in lts_idx_iter.zip(generic_params_list.lifetime_params()) {\n+                let id = LifetimeParamId { parent: *self, local_id };\n+                res[keys::LIFETIME_PARAM].insert(ast_param, id);\n+            }\n+        }\n+    }\n+}"}, {"sha": "000fe5ac7bb4b3788139ede359a7e4fd03780119", "filename": "src/tools/rust-analyzer/crates/hir-def/src/import_map.rs", "status": "added", "additions": 1108, "deletions": 0, "changes": 1108, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fimport_map.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,1108 @@\n+//! A map of all publicly exported items in a crate.\n+\n+use std::{fmt, hash::BuildHasherDefault, sync::Arc};\n+\n+use base_db::CrateId;\n+use fst::{self, Streamer};\n+use hir_expand::name::Name;\n+use indexmap::{map::Entry, IndexMap};\n+use itertools::Itertools;\n+use rustc_hash::{FxHashSet, FxHasher};\n+\n+use crate::{\n+    db::DefDatabase, item_scope::ItemInNs, visibility::Visibility, AssocItemId, ModuleDefId,\n+    ModuleId, TraitId,\n+};\n+\n+type FxIndexMap<K, V> = IndexMap<K, V, BuildHasherDefault<FxHasher>>;\n+\n+/// Item import details stored in the `ImportMap`.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct ImportInfo {\n+    /// A path that can be used to import the item, relative to the crate's root.\n+    pub path: ImportPath,\n+    /// The module containing this item.\n+    pub container: ModuleId,\n+    /// Whether the import is a trait associated item or not.\n+    pub is_trait_assoc_item: bool,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct ImportPath {\n+    pub segments: Vec<Name>,\n+}\n+\n+impl fmt::Display for ImportPath {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.segments.iter().format(\"::\"), f)\n+    }\n+}\n+\n+impl ImportPath {\n+    fn len(&self) -> usize {\n+        self.segments.len()\n+    }\n+}\n+\n+/// A map from publicly exported items to the path needed to import/name them from a downstream\n+/// crate.\n+///\n+/// Reexports of items are taken into account, ie. if something is exported under multiple\n+/// names, the one with the shortest import path will be used.\n+///\n+/// Note that all paths are relative to the containing crate's root, so the crate name still needs\n+/// to be prepended to the `ModPath` before the path is valid.\n+#[derive(Default)]\n+pub struct ImportMap {\n+    map: FxIndexMap<ItemInNs, ImportInfo>,\n+\n+    /// List of keys stored in `map`, sorted lexicographically by their `ModPath`. Indexed by the\n+    /// values returned by running `fst`.\n+    ///\n+    /// Since a path can refer to multiple items due to namespacing, we store all items with the\n+    /// same path right after each other. This allows us to find all items after the FST gives us\n+    /// the index of the first one.\n+    importables: Vec<ItemInNs>,\n+    fst: fst::Map<Vec<u8>>,\n+}\n+\n+impl ImportMap {\n+    pub fn import_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<Self> {\n+        let _p = profile::span(\"import_map_query\");\n+\n+        let mut import_map = collect_import_map(db, krate);\n+\n+        let mut importables = import_map\n+            .map\n+            .iter()\n+            .map(|(item, info)| (item, fst_path(&info.path)))\n+            .collect::<Vec<_>>();\n+        importables.sort_by(|(_, fst_path), (_, fst_path2)| fst_path.cmp(fst_path2));\n+\n+        // Build the FST, taking care not to insert duplicate values.\n+\n+        let mut builder = fst::MapBuilder::memory();\n+        let mut last_batch_start = 0;\n+\n+        for idx in 0..importables.len() {\n+            let key = &importables[last_batch_start].1;\n+            if let Some((_, fst_path)) = importables.get(idx + 1) {\n+                if key == fst_path {\n+                    continue;\n+                }\n+            }\n+\n+            let _ = builder.insert(key, last_batch_start as u64);\n+\n+            last_batch_start = idx + 1;\n+        }\n+\n+        import_map.fst = builder.into_map();\n+        import_map.importables = importables.iter().map(|&(&item, _)| item).collect();\n+\n+        Arc::new(import_map)\n+    }\n+\n+    /// Returns the `ModPath` needed to import/mention `item`, relative to this crate's root.\n+    pub fn path_of(&self, item: ItemInNs) -> Option<&ImportPath> {\n+        self.import_info_for(item).map(|it| &it.path)\n+    }\n+\n+    pub fn import_info_for(&self, item: ItemInNs) -> Option<&ImportInfo> {\n+        self.map.get(&item)\n+    }\n+\n+    fn collect_trait_assoc_items(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        tr: TraitId,\n+        is_type_in_ns: bool,\n+        original_import_info: &ImportInfo,\n+    ) {\n+        let _p = profile::span(\"collect_trait_assoc_items\");\n+        for (assoc_item_name, item) in &db.trait_data(tr).items {\n+            let module_def_id = match item {\n+                AssocItemId::FunctionId(f) => ModuleDefId::from(*f),\n+                AssocItemId::ConstId(c) => ModuleDefId::from(*c),\n+                // cannot use associated type aliases directly: need a `<Struct as Trait>::TypeAlias`\n+                // qualifier, ergo no need to store it for imports in import_map\n+                AssocItemId::TypeAliasId(_) => {\n+                    cov_mark::hit!(type_aliases_ignored);\n+                    continue;\n+                }\n+            };\n+            let assoc_item = if is_type_in_ns {\n+                ItemInNs::Types(module_def_id)\n+            } else {\n+                ItemInNs::Values(module_def_id)\n+            };\n+\n+            let mut assoc_item_info = original_import_info.clone();\n+            assoc_item_info.path.segments.push(assoc_item_name.to_owned());\n+            assoc_item_info.is_trait_assoc_item = true;\n+            self.map.insert(assoc_item, assoc_item_info);\n+        }\n+    }\n+}\n+\n+fn collect_import_map(db: &dyn DefDatabase, krate: CrateId) -> ImportMap {\n+    let _p = profile::span(\"collect_import_map\");\n+\n+    let def_map = db.crate_def_map(krate);\n+    let mut import_map = ImportMap::default();\n+\n+    // We look only into modules that are public(ly reexported), starting with the crate root.\n+    let empty = ImportPath { segments: vec![] };\n+    let root = def_map.module_id(def_map.root());\n+    let mut worklist = vec![(root, empty)];\n+    while let Some((module, mod_path)) = worklist.pop() {\n+        let ext_def_map;\n+        let mod_data = if module.krate == krate {\n+            &def_map[module.local_id]\n+        } else {\n+            // The crate might reexport a module defined in another crate.\n+            ext_def_map = module.def_map(db);\n+            &ext_def_map[module.local_id]\n+        };\n+\n+        let visible_items = mod_data.scope.entries().filter_map(|(name, per_ns)| {\n+            let per_ns = per_ns.filter_visibility(|vis| vis == Visibility::Public);\n+            if per_ns.is_none() {\n+                None\n+            } else {\n+                Some((name, per_ns))\n+            }\n+        });\n+\n+        for (name, per_ns) in visible_items {\n+            let mk_path = || {\n+                let mut path = mod_path.clone();\n+                path.segments.push(name.clone());\n+                path\n+            };\n+\n+            for item in per_ns.iter_items() {\n+                let path = mk_path();\n+                let path_len = path.len();\n+                let import_info =\n+                    ImportInfo { path, container: module, is_trait_assoc_item: false };\n+\n+                if let Some(ModuleDefId::TraitId(tr)) = item.as_module_def_id() {\n+                    import_map.collect_trait_assoc_items(\n+                        db,\n+                        tr,\n+                        matches!(item, ItemInNs::Types(_)),\n+                        &import_info,\n+                    );\n+                }\n+\n+                match import_map.map.entry(item) {\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(import_info);\n+                    }\n+                    Entry::Occupied(mut entry) => {\n+                        // If the new path is shorter, prefer that one.\n+                        if path_len < entry.get().path.len() {\n+                            *entry.get_mut() = import_info;\n+                        } else {\n+                            continue;\n+                        }\n+                    }\n+                }\n+\n+                // If we've just added a path to a module, descend into it. We might traverse\n+                // modules multiple times, but only if the new path to it is shorter than the\n+                // first (else we `continue` above).\n+                if let Some(ModuleDefId::ModuleId(mod_id)) = item.as_module_def_id() {\n+                    worklist.push((mod_id, mk_path()));\n+                }\n+            }\n+        }\n+    }\n+\n+    import_map\n+}\n+\n+impl PartialEq for ImportMap {\n+    fn eq(&self, other: &Self) -> bool {\n+        // `fst` and `importables` are built from `map`, so we don't need to compare them.\n+        self.map == other.map\n+    }\n+}\n+\n+impl Eq for ImportMap {}\n+\n+impl fmt::Debug for ImportMap {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut importable_paths: Vec<_> = self\n+            .map\n+            .iter()\n+            .map(|(item, info)| {\n+                let ns = match item {\n+                    ItemInNs::Types(_) => \"t\",\n+                    ItemInNs::Values(_) => \"v\",\n+                    ItemInNs::Macros(_) => \"m\",\n+                };\n+                format!(\"- {} ({})\", info.path, ns)\n+            })\n+            .collect();\n+\n+        importable_paths.sort();\n+        f.write_str(&importable_paths.join(\"\\n\"))\n+    }\n+}\n+\n+fn fst_path(path: &ImportPath) -> String {\n+    let _p = profile::span(\"fst_path\");\n+    let mut s = path.to_string();\n+    s.make_ascii_lowercase();\n+    s\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Hash)]\n+pub enum ImportKind {\n+    Module,\n+    Function,\n+    Adt,\n+    EnumVariant,\n+    Const,\n+    Static,\n+    Trait,\n+    TypeAlias,\n+    BuiltinType,\n+    AssociatedItem,\n+    Macro,\n+}\n+\n+/// A way to match import map contents against the search query.\n+#[derive(Debug)]\n+pub enum SearchMode {\n+    /// Import map entry should strictly match the query string.\n+    Equals,\n+    /// Import map entry should contain the query string.\n+    Contains,\n+    /// Import map entry should contain all letters from the query string,\n+    /// in the same order, but not necessary adjacent.\n+    Fuzzy,\n+}\n+\n+#[derive(Debug)]\n+pub struct Query {\n+    query: String,\n+    lowercased: String,\n+    name_only: bool,\n+    assoc_items_only: bool,\n+    search_mode: SearchMode,\n+    case_sensitive: bool,\n+    limit: usize,\n+    exclude_import_kinds: FxHashSet<ImportKind>,\n+}\n+\n+impl Query {\n+    pub fn new(query: String) -> Self {\n+        let lowercased = query.to_lowercase();\n+        Self {\n+            query,\n+            lowercased,\n+            name_only: false,\n+            assoc_items_only: false,\n+            search_mode: SearchMode::Contains,\n+            case_sensitive: false,\n+            limit: usize::max_value(),\n+            exclude_import_kinds: FxHashSet::default(),\n+        }\n+    }\n+\n+    /// Matches entries' names only, ignoring the rest of\n+    /// the qualifier.\n+    /// Example: for `std::marker::PhantomData`, the name is `PhantomData`.\n+    pub fn name_only(self) -> Self {\n+        Self { name_only: true, ..self }\n+    }\n+\n+    /// Matches only the entries that are associated items, ignoring the rest.\n+    pub fn assoc_items_only(self) -> Self {\n+        Self { assoc_items_only: true, ..self }\n+    }\n+\n+    /// Specifies the way to search for the entries using the query.\n+    pub fn search_mode(self, search_mode: SearchMode) -> Self {\n+        Self { search_mode, ..self }\n+    }\n+\n+    /// Limits the returned number of items to `limit`.\n+    pub fn limit(self, limit: usize) -> Self {\n+        Self { limit, ..self }\n+    }\n+\n+    /// Respect casing of the query string when matching.\n+    pub fn case_sensitive(self) -> Self {\n+        Self { case_sensitive: true, ..self }\n+    }\n+\n+    /// Do not include imports of the specified kind in the search results.\n+    pub fn exclude_import_kind(mut self, import_kind: ImportKind) -> Self {\n+        self.exclude_import_kinds.insert(import_kind);\n+        self\n+    }\n+\n+    fn import_matches(&self, import: &ImportInfo, enforce_lowercase: bool) -> bool {\n+        let _p = profile::span(\"import_map::Query::import_matches\");\n+        if import.is_trait_assoc_item {\n+            if self.exclude_import_kinds.contains(&ImportKind::AssociatedItem) {\n+                return false;\n+            }\n+        } else if self.assoc_items_only {\n+            return false;\n+        }\n+\n+        let mut input = if import.is_trait_assoc_item || self.name_only {\n+            import.path.segments.last().unwrap().to_string()\n+        } else {\n+            import.path.to_string()\n+        };\n+        if enforce_lowercase || !self.case_sensitive {\n+            input.make_ascii_lowercase();\n+        }\n+\n+        let query_string =\n+            if !enforce_lowercase && self.case_sensitive { &self.query } else { &self.lowercased };\n+\n+        match self.search_mode {\n+            SearchMode::Equals => &input == query_string,\n+            SearchMode::Contains => input.contains(query_string),\n+            SearchMode::Fuzzy => {\n+                let mut unchecked_query_chars = query_string.chars();\n+                let mut mismatching_query_char = unchecked_query_chars.next();\n+\n+                for input_char in input.chars() {\n+                    match mismatching_query_char {\n+                        None => return true,\n+                        Some(matching_query_char) if matching_query_char == input_char => {\n+                            mismatching_query_char = unchecked_query_chars.next();\n+                        }\n+                        _ => (),\n+                    }\n+                }\n+                mismatching_query_char.is_none()\n+            }\n+        }\n+    }\n+}\n+\n+/// Searches dependencies of `krate` for an importable path matching `query`.\n+///\n+/// This returns a list of items that could be imported from dependencies of `krate`.\n+pub fn search_dependencies<'a>(\n+    db: &'a dyn DefDatabase,\n+    krate: CrateId,\n+    query: Query,\n+) -> FxHashSet<ItemInNs> {\n+    let _p = profile::span(\"search_dependencies\").detail(|| format!(\"{:?}\", query));\n+\n+    let graph = db.crate_graph();\n+    let import_maps: Vec<_> =\n+        graph[krate].dependencies.iter().map(|dep| db.import_map(dep.crate_id)).collect();\n+\n+    let automaton = fst::automaton::Subsequence::new(&query.lowercased);\n+\n+    let mut op = fst::map::OpBuilder::new();\n+    for map in &import_maps {\n+        op = op.add(map.fst.search(&automaton));\n+    }\n+\n+    let mut stream = op.union();\n+\n+    let mut all_indexed_values = FxHashSet::default();\n+    while let Some((_, indexed_values)) = stream.next() {\n+        all_indexed_values.extend(indexed_values.iter().copied());\n+    }\n+\n+    let mut res = FxHashSet::default();\n+    for indexed_value in all_indexed_values {\n+        let import_map = &import_maps[indexed_value.index];\n+        let importables = &import_map.importables[indexed_value.value as usize..];\n+\n+        let common_importable_data = &import_map.map[&importables[0]];\n+        if !query.import_matches(common_importable_data, true) {\n+            continue;\n+        }\n+\n+        // Path shared by the importable items in this group.\n+        let common_importables_path_fst = fst_path(&common_importable_data.path);\n+        // Add the items from this `ModPath` group. Those are all subsequent items in\n+        // `importables` whose paths match `path`.\n+        let iter = importables\n+            .iter()\n+            .copied()\n+            .take_while(|item| common_importables_path_fst == fst_path(&import_map.map[item].path))\n+            .filter(|&item| match item_import_kind(item) {\n+                Some(import_kind) => !query.exclude_import_kinds.contains(&import_kind),\n+                None => true,\n+            })\n+            .filter(|item| {\n+                !query.case_sensitive // we've already checked the common importables path case-insensitively\n+                        || query.import_matches(&import_map.map[item], false)\n+            });\n+        res.extend(iter);\n+\n+        if res.len() >= query.limit {\n+            return res;\n+        }\n+    }\n+\n+    res\n+}\n+\n+fn item_import_kind(item: ItemInNs) -> Option<ImportKind> {\n+    Some(match item.as_module_def_id()? {\n+        ModuleDefId::ModuleId(_) => ImportKind::Module,\n+        ModuleDefId::FunctionId(_) => ImportKind::Function,\n+        ModuleDefId::AdtId(_) => ImportKind::Adt,\n+        ModuleDefId::EnumVariantId(_) => ImportKind::EnumVariant,\n+        ModuleDefId::ConstId(_) => ImportKind::Const,\n+        ModuleDefId::StaticId(_) => ImportKind::Static,\n+        ModuleDefId::TraitId(_) => ImportKind::Trait,\n+        ModuleDefId::TypeAliasId(_) => ImportKind::TypeAlias,\n+        ModuleDefId::BuiltinType(_) => ImportKind::BuiltinType,\n+        ModuleDefId::MacroId(_) => ImportKind::Macro,\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use base_db::{fixture::WithFixture, SourceDatabase, Upcast};\n+    use expect_test::{expect, Expect};\n+\n+    use crate::{test_db::TestDB, ItemContainerId, Lookup};\n+\n+    use super::*;\n+\n+    fn check_search(ra_fixture: &str, crate_name: &str, query: Query, expect: Expect) {\n+        let db = TestDB::with_files(ra_fixture);\n+        let crate_graph = db.crate_graph();\n+        let krate = crate_graph\n+            .iter()\n+            .find(|krate| {\n+                crate_graph[*krate].display_name.as_ref().map(|n| n.to_string())\n+                    == Some(crate_name.to_string())\n+            })\n+            .unwrap();\n+\n+        let actual = search_dependencies(db.upcast(), krate, query)\n+            .into_iter()\n+            .filter_map(|dependency| {\n+                let dependency_krate = dependency.krate(db.upcast())?;\n+                let dependency_imports = db.import_map(dependency_krate);\n+\n+                let (path, mark) = match assoc_item_path(&db, &dependency_imports, dependency) {\n+                    Some(assoc_item_path) => (assoc_item_path, \"a\"),\n+                    None => (\n+                        dependency_imports.path_of(dependency)?.to_string(),\n+                        match dependency {\n+                            ItemInNs::Types(ModuleDefId::FunctionId(_))\n+                            | ItemInNs::Values(ModuleDefId::FunctionId(_)) => \"f\",\n+                            ItemInNs::Types(_) => \"t\",\n+                            ItemInNs::Values(_) => \"v\",\n+                            ItemInNs::Macros(_) => \"m\",\n+                        },\n+                    ),\n+                };\n+\n+                Some(format!(\n+                    \"{}::{} ({})\\n\",\n+                    crate_graph[dependency_krate].display_name.as_ref()?,\n+                    path,\n+                    mark\n+                ))\n+            })\n+            .collect::<String>();\n+        expect.assert_eq(&actual)\n+    }\n+\n+    fn assoc_item_path(\n+        db: &dyn DefDatabase,\n+        dependency_imports: &ImportMap,\n+        dependency: ItemInNs,\n+    ) -> Option<String> {\n+        let dependency_assoc_item_id = match dependency {\n+            ItemInNs::Types(ModuleDefId::FunctionId(id))\n+            | ItemInNs::Values(ModuleDefId::FunctionId(id)) => AssocItemId::from(id),\n+            ItemInNs::Types(ModuleDefId::ConstId(id))\n+            | ItemInNs::Values(ModuleDefId::ConstId(id)) => AssocItemId::from(id),\n+            ItemInNs::Types(ModuleDefId::TypeAliasId(id))\n+            | ItemInNs::Values(ModuleDefId::TypeAliasId(id)) => AssocItemId::from(id),\n+            _ => return None,\n+        };\n+\n+        let trait_ = assoc_to_trait(db, dependency)?;\n+        if let ModuleDefId::TraitId(tr) = trait_.as_module_def_id()? {\n+            let trait_data = db.trait_data(tr);\n+            let assoc_item_name =\n+                trait_data.items.iter().find_map(|(assoc_item_name, assoc_item_id)| {\n+                    if &dependency_assoc_item_id == assoc_item_id {\n+                        Some(assoc_item_name)\n+                    } else {\n+                        None\n+                    }\n+                })?;\n+            return Some(format!(\"{}::{}\", dependency_imports.path_of(trait_)?, assoc_item_name));\n+        }\n+        None\n+    }\n+\n+    fn assoc_to_trait(db: &dyn DefDatabase, item: ItemInNs) -> Option<ItemInNs> {\n+        let assoc: AssocItemId = match item {\n+            ItemInNs::Types(it) | ItemInNs::Values(it) => match it {\n+                ModuleDefId::TypeAliasId(it) => it.into(),\n+                ModuleDefId::FunctionId(it) => it.into(),\n+                ModuleDefId::ConstId(it) => it.into(),\n+                _ => return None,\n+            },\n+            _ => return None,\n+        };\n+\n+        let container = match assoc {\n+            AssocItemId::FunctionId(it) => it.lookup(db).container,\n+            AssocItemId::ConstId(it) => it.lookup(db).container,\n+            AssocItemId::TypeAliasId(it) => it.lookup(db).container,\n+        };\n+\n+        match container {\n+            ItemContainerId::TraitId(it) => Some(ItemInNs::Types(it.into())),\n+            _ => None,\n+        }\n+    }\n+\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let db = TestDB::with_files(ra_fixture);\n+        let crate_graph = db.crate_graph();\n+\n+        let actual = crate_graph\n+            .iter()\n+            .filter_map(|krate| {\n+                let cdata = &crate_graph[krate];\n+                let name = cdata.display_name.as_ref()?;\n+\n+                let map = db.import_map(krate);\n+\n+                Some(format!(\"{}:\\n{:?}\\n\", name, map))\n+            })\n+            .collect::<String>();\n+\n+        expect.assert_eq(&actual)\n+    }\n+\n+    #[test]\n+    fn smoke() {\n+        check(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+\n+            mod private {\n+                pub use lib::Pub;\n+                pub struct InPrivateModule;\n+            }\n+\n+            pub mod publ1 {\n+                use lib::Pub;\n+            }\n+\n+            pub mod real_pub {\n+                pub use lib::Pub;\n+            }\n+            pub mod real_pu2 { // same path length as above\n+                pub use lib::Pub;\n+            }\n+\n+            //- /lib.rs crate:lib\n+            pub struct Pub {}\n+            pub struct Pub2; // t + v\n+            struct Priv;\n+        \",\n+            expect![[r#\"\n+                main:\n+                - publ1 (t)\n+                - real_pu2 (t)\n+                - real_pub (t)\n+                - real_pub::Pub (t)\n+                lib:\n+                - Pub (t)\n+                - Pub2 (t)\n+                - Pub2 (v)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn prefers_shortest_path() {\n+        check(\n+            r\"\n+            //- /main.rs crate:main\n+\n+            pub mod sub {\n+                pub mod subsub {\n+                    pub struct Def {}\n+                }\n+\n+                pub use super::sub::subsub::Def;\n+            }\n+        \",\n+            expect![[r#\"\n+                main:\n+                - sub (t)\n+                - sub::Def (t)\n+                - sub::subsub (t)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn type_reexport_cross_crate() {\n+        // Reexports need to be visible from a crate, even if the original crate exports the item\n+        // at a shorter path.\n+        check(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+            pub mod m {\n+                pub use lib::S;\n+            }\n+            //- /lib.rs crate:lib\n+            pub struct S;\n+        \",\n+            expect![[r#\"\n+                main:\n+                - m (t)\n+                - m::S (t)\n+                - m::S (v)\n+                lib:\n+                - S (t)\n+                - S (v)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn macro_reexport() {\n+        check(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+            pub mod m {\n+                pub use lib::pub_macro;\n+            }\n+            //- /lib.rs crate:lib\n+            #[macro_export]\n+            macro_rules! pub_macro {\n+                () => {};\n+            }\n+        \",\n+            expect![[r#\"\n+                main:\n+                - m (t)\n+                - m::pub_macro (m)\n+                lib:\n+                - pub_macro (m)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn module_reexport() {\n+        // Reexporting modules from a dependency adds all contents to the import map.\n+        check(\n+            r\"\n+            //- /main.rs crate:main deps:lib\n+            pub use lib::module as reexported_module;\n+            //- /lib.rs crate:lib\n+            pub mod module {\n+                pub struct S;\n+            }\n+        \",\n+            expect![[r#\"\n+                main:\n+                - reexported_module (t)\n+                - reexported_module::S (t)\n+                - reexported_module::S (v)\n+                lib:\n+                - module (t)\n+                - module::S (t)\n+                - module::S (v)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn cyclic_module_reexport() {\n+        // A cyclic reexport does not hang.\n+        check(\n+            r\"\n+            //- /lib.rs crate:lib\n+            pub mod module {\n+                pub struct S;\n+                pub use super::sub::*;\n+            }\n+\n+            pub mod sub {\n+                pub use super::module;\n+            }\n+        \",\n+            expect![[r#\"\n+                lib:\n+                - module (t)\n+                - module::S (t)\n+                - module::S (v)\n+                - sub (t)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn private_macro() {\n+        check(\n+            r\"\n+            //- /lib.rs crate:lib\n+            macro_rules! private_macro {\n+                () => {};\n+            }\n+        \",\n+            expect![[r#\"\n+                lib:\n+\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn namespacing() {\n+        check(\n+            r\"\n+            //- /lib.rs crate:lib\n+            pub struct Thing;     // t + v\n+            #[macro_export]\n+            macro_rules! Thing {  // m\n+                () => {};\n+            }\n+        \",\n+            expect![[r#\"\n+                lib:\n+                - Thing (m)\n+                - Thing (t)\n+                - Thing (v)\n+            \"#]],\n+        );\n+\n+        check(\n+            r\"\n+            //- /lib.rs crate:lib\n+            pub mod Thing {}      // t\n+            #[macro_export]\n+            macro_rules! Thing {  // m\n+                () => {};\n+            }\n+        \",\n+            expect![[r#\"\n+                lib:\n+                - Thing (m)\n+                - Thing (t)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn fuzzy_import_trait_and_assoc_items() {\n+        cov_mark::check!(type_aliases_ignored);\n+        let ra_fixture = r#\"\n+        //- /main.rs crate:main deps:dep\n+        //- /dep.rs crate:dep\n+        pub mod fmt {\n+            pub trait Display {\n+                type FmtTypeAlias;\n+                const FMT_CONST: bool;\n+\n+                fn format_function();\n+                fn format_method(&self);\n+            }\n+        }\n+    \"#;\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string()).search_mode(SearchMode::Fuzzy),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::fmt::Display::format_method (a)\n+                dep::fmt::Display (t)\n+                dep::fmt::Display::FMT_CONST (a)\n+                dep::fmt::Display::format_function (a)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn assoc_items_filtering() {\n+        let ra_fixture = r#\"\n+        //- /main.rs crate:main deps:dep\n+        //- /dep.rs crate:dep\n+        pub mod fmt {\n+            pub trait Display {\n+                type FmtTypeAlias;\n+                const FMT_CONST: bool;\n+\n+                fn format_function();\n+                fn format_method(&self);\n+            }\n+        }\n+    \"#;\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string()).search_mode(SearchMode::Fuzzy).assoc_items_only(),\n+            expect![[r#\"\n+            dep::fmt::Display::format_method (a)\n+            dep::fmt::Display::FMT_CONST (a)\n+            dep::fmt::Display::format_function (a)\n+        \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string())\n+                .search_mode(SearchMode::Fuzzy)\n+                .exclude_import_kind(ImportKind::AssociatedItem),\n+            expect![[r#\"\n+            dep::fmt (t)\n+            dep::fmt::Display (t)\n+        \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string())\n+                .search_mode(SearchMode::Fuzzy)\n+                .assoc_items_only()\n+                .exclude_import_kind(ImportKind::AssociatedItem),\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn search_mode() {\n+        let ra_fixture = r#\"\n+            //- /main.rs crate:main deps:dep\n+            //- /dep.rs crate:dep deps:tdep\n+            use tdep::fmt as fmt_dep;\n+            pub mod fmt {\n+                pub trait Display {\n+                    fn fmt();\n+                }\n+            }\n+            #[macro_export]\n+            macro_rules! Fmt {\n+                () => {};\n+            }\n+            pub struct Fmt;\n+\n+            pub fn format() {}\n+            pub fn no() {}\n+\n+            //- /tdep.rs crate:tdep\n+            pub mod fmt {\n+                pub struct NotImportableFromMain;\n+            }\n+        \"#;\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string()).search_mode(SearchMode::Fuzzy),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::format (f)\n+                dep::Fmt (v)\n+                dep::Fmt (m)\n+                dep::Fmt (t)\n+                dep::fmt::Display::fmt (a)\n+                dep::fmt::Display (t)\n+            \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string()).search_mode(SearchMode::Equals),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::Fmt (v)\n+                dep::Fmt (m)\n+                dep::Fmt (t)\n+                dep::fmt::Display::fmt (a)\n+            \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string()).search_mode(SearchMode::Contains),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::Fmt (v)\n+                dep::Fmt (m)\n+                dep::Fmt (t)\n+                dep::fmt::Display::fmt (a)\n+                dep::fmt::Display (t)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn name_only() {\n+        let ra_fixture = r#\"\n+            //- /main.rs crate:main deps:dep\n+            //- /dep.rs crate:dep deps:tdep\n+            use tdep::fmt as fmt_dep;\n+            pub mod fmt {\n+                pub trait Display {\n+                    fn fmt();\n+                }\n+            }\n+            #[macro_export]\n+            macro_rules! Fmt {\n+                () => {};\n+            }\n+            pub struct Fmt;\n+\n+            pub fn format() {}\n+            pub fn no() {}\n+\n+            //- /tdep.rs crate:tdep\n+            pub mod fmt {\n+                pub struct NotImportableFromMain;\n+            }\n+        \"#;\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string()),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::Fmt (v)\n+                dep::Fmt (m)\n+                dep::Fmt (t)\n+                dep::fmt::Display::fmt (a)\n+                dep::fmt::Display (t)\n+            \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"fmt\".to_string()).name_only(),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::Fmt (v)\n+                dep::Fmt (m)\n+                dep::Fmt (t)\n+                dep::fmt::Display::fmt (a)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn search_casing() {\n+        let ra_fixture = r#\"\n+            //- /main.rs crate:main deps:dep\n+            //- /dep.rs crate:dep\n+\n+            pub struct fmt;\n+            pub struct FMT;\n+        \"#;\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"FMT\".to_string()),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::FMT (v)\n+                dep::fmt (v)\n+                dep::FMT (t)\n+            \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"FMT\".to_string()).case_sensitive(),\n+            expect![[r#\"\n+                dep::FMT (t)\n+                dep::FMT (v)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn search_limit() {\n+        check_search(\n+            r#\"\n+        //- /main.rs crate:main deps:dep\n+        //- /dep.rs crate:dep\n+        pub mod fmt {\n+            pub trait Display {\n+                fn fmt();\n+            }\n+        }\n+        #[macro_export]\n+        macro_rules! Fmt {\n+            () => {};\n+        }\n+        pub struct Fmt;\n+\n+        pub fn format() {}\n+        pub fn no() {}\n+    \"#,\n+            \"main\",\n+            Query::new(\"\".to_string()).limit(2),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::Fmt (t)\n+                dep::Fmt (v)\n+                dep::Fmt (m)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn search_exclusions() {\n+        let ra_fixture = r#\"\n+            //- /main.rs crate:main deps:dep\n+            //- /dep.rs crate:dep\n+\n+            pub struct fmt;\n+            pub struct FMT;\n+        \"#;\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"FMT\".to_string()),\n+            expect![[r#\"\n+                dep::fmt (t)\n+                dep::FMT (v)\n+                dep::fmt (v)\n+                dep::FMT (t)\n+            \"#]],\n+        );\n+\n+        check_search(\n+            ra_fixture,\n+            \"main\",\n+            Query::new(\"FMT\".to_string()).exclude_import_kind(ImportKind::Adt),\n+            expect![[r#\"\"#]],\n+        );\n+    }\n+}"}, {"sha": "f08521a34032b7b79846785af3f92daa174d11fd", "filename": "src/tools/rust-analyzer/crates/hir-def/src/intern.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fintern.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,227 @@\n+//! Global `Arc`-based object interning infrastructure.\n+//!\n+//! Eventually this should probably be replaced with salsa-based interning.\n+\n+use std::{\n+    fmt::{self, Debug, Display},\n+    hash::{BuildHasherDefault, Hash, Hasher},\n+    ops::Deref,\n+    sync::Arc,\n+};\n+\n+use dashmap::{DashMap, SharedValue};\n+use hashbrown::HashMap;\n+use once_cell::sync::OnceCell;\n+use rustc_hash::FxHasher;\n+\n+use crate::generics::GenericParams;\n+\n+type InternMap<T> = DashMap<Arc<T>, (), BuildHasherDefault<FxHasher>>;\n+type Guard<T> = dashmap::RwLockWriteGuard<\n+    'static,\n+    HashMap<Arc<T>, SharedValue<()>, BuildHasherDefault<FxHasher>>,\n+>;\n+\n+pub struct Interned<T: Internable + ?Sized> {\n+    arc: Arc<T>,\n+}\n+\n+impl<T: Internable> Interned<T> {\n+    pub fn new(obj: T) -> Self {\n+        match Interned::lookup(&obj) {\n+            Ok(this) => this,\n+            Err(shard) => {\n+                let arc = Arc::new(obj);\n+                Self::alloc(arc, shard)\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> Interned<T> {\n+    fn lookup(obj: &T) -> Result<Self, Guard<T>> {\n+        let storage = T::storage().get();\n+        let shard_idx = storage.determine_map(obj);\n+        let shard = &storage.shards()[shard_idx];\n+        let shard = shard.write();\n+\n+        // Atomically,\n+        // - check if `obj` is already in the map\n+        //   - if so, clone its `Arc` and return it\n+        //   - if not, box it up, insert it, and return a clone\n+        // This needs to be atomic (locking the shard) to avoid races with other thread, which could\n+        // insert the same object between us looking it up and inserting it.\n+\n+        // FIXME: avoid double lookup/hashing by using raw entry API (once stable, or when\n+        // hashbrown can be plugged into dashmap)\n+        match shard.get_key_value(obj) {\n+            Some((arc, _)) => Ok(Self { arc: arc.clone() }),\n+            None => Err(shard),\n+        }\n+    }\n+\n+    fn alloc(arc: Arc<T>, mut shard: Guard<T>) -> Self {\n+        let arc2 = arc.clone();\n+\n+        shard.insert(arc2, SharedValue::new(()));\n+\n+        Self { arc }\n+    }\n+}\n+\n+impl Interned<str> {\n+    pub fn new_str(s: &str) -> Self {\n+        match Interned::lookup(s) {\n+            Ok(this) => this,\n+            Err(shard) => {\n+                let arc = Arc::<str>::from(s);\n+                Self::alloc(arc, shard)\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> Drop for Interned<T> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        // When the last `Ref` is dropped, remove the object from the global map.\n+        if Arc::strong_count(&self.arc) == 2 {\n+            // Only `self` and the global map point to the object.\n+\n+            self.drop_slow();\n+        }\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> Interned<T> {\n+    #[cold]\n+    fn drop_slow(&mut self) {\n+        let storage = T::storage().get();\n+        let shard_idx = storage.determine_map(&self.arc);\n+        let shard = &storage.shards()[shard_idx];\n+        let mut shard = shard.write();\n+\n+        // FIXME: avoid double lookup\n+        let (arc, _) = shard.get_key_value(&self.arc).expect(\"interned value removed prematurely\");\n+\n+        if Arc::strong_count(arc) != 2 {\n+            // Another thread has interned another copy\n+            return;\n+        }\n+\n+        shard.remove(&self.arc);\n+\n+        // Shrink the backing storage if the shard is less than 50% occupied.\n+        if shard.len() * 2 < shard.capacity() {\n+            shard.shrink_to_fit();\n+        }\n+    }\n+}\n+\n+/// Compares interned `Ref`s using pointer equality.\n+impl<T: Internable> PartialEq for Interned<T> {\n+    // NOTE: No `?Sized` because `ptr_eq` doesn't work right with trait objects.\n+\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        Arc::ptr_eq(&self.arc, &other.arc)\n+    }\n+}\n+\n+impl<T: Internable> Eq for Interned<T> {}\n+\n+impl PartialEq for Interned<str> {\n+    fn eq(&self, other: &Self) -> bool {\n+        Arc::ptr_eq(&self.arc, &other.arc)\n+    }\n+}\n+\n+impl Eq for Interned<str> {}\n+\n+impl<T: Internable + ?Sized> Hash for Interned<T> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        // NOTE: Cast disposes vtable pointer / slice/str length.\n+        state.write_usize(Arc::as_ptr(&self.arc) as *const () as usize)\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> AsRef<T> for Interned<T> {\n+    #[inline]\n+    fn as_ref(&self) -> &T {\n+        &self.arc\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> Deref for Interned<T> {\n+    type Target = T;\n+\n+    #[inline]\n+    fn deref(&self) -> &Self::Target {\n+        &self.arc\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> Clone for Interned<T> {\n+    fn clone(&self) -> Self {\n+        Self { arc: self.arc.clone() }\n+    }\n+}\n+\n+impl<T: Debug + Internable + ?Sized> Debug for Interned<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (*self.arc).fmt(f)\n+    }\n+}\n+\n+impl<T: Display + Internable + ?Sized> Display for Interned<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (*self.arc).fmt(f)\n+    }\n+}\n+\n+pub struct InternStorage<T: ?Sized> {\n+    map: OnceCell<InternMap<T>>,\n+}\n+\n+impl<T: ?Sized> InternStorage<T> {\n+    pub const fn new() -> Self {\n+        Self { map: OnceCell::new() }\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> InternStorage<T> {\n+    fn get(&self) -> &InternMap<T> {\n+        self.map.get_or_init(DashMap::default)\n+    }\n+}\n+\n+pub trait Internable: Hash + Eq + 'static {\n+    fn storage() -> &'static InternStorage<Self>;\n+}\n+\n+/// Implements `Internable` for a given list of types, making them usable with `Interned`.\n+#[macro_export]\n+#[doc(hidden)]\n+macro_rules! _impl_internable {\n+    ( $($t:path),+ $(,)? ) => { $(\n+        impl Internable for $t {\n+            fn storage() -> &'static InternStorage<Self> {\n+                static STORAGE: InternStorage<$t> = InternStorage::new();\n+                &STORAGE\n+            }\n+        }\n+    )+ };\n+}\n+\n+pub use crate::_impl_internable as impl_internable;\n+\n+impl_internable!(\n+    crate::type_ref::TypeRef,\n+    crate::type_ref::TraitRef,\n+    crate::type_ref::TypeBound,\n+    crate::path::ModPath,\n+    crate::path::GenericArgs,\n+    crate::attr::AttrInput,\n+    GenericParams,\n+    str,\n+);"}, {"sha": "b98b2855cb084848aed44860d8a784bdad59ca6a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_scope.rs", "status": "added", "additions": 449, "deletions": 0, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,449 @@\n+//! Describes items defined or visible (ie, imported) in a certain scope.\n+//! This is shared between modules and blocks.\n+\n+use std::collections::hash_map::Entry;\n+\n+use base_db::CrateId;\n+use hir_expand::{name::Name, AstId, MacroCallId};\n+use once_cell::sync::Lazy;\n+use profile::Count;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use smallvec::{smallvec, SmallVec};\n+use stdx::format_to;\n+use syntax::ast;\n+\n+use crate::{\n+    attr::AttrId, db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType,\n+    ConstId, HasModule, ImplId, LocalModuleId, MacroId, ModuleDefId, ModuleId, TraitId,\n+};\n+\n+#[derive(Copy, Clone)]\n+pub(crate) enum ImportType {\n+    Glob,\n+    Named,\n+}\n+\n+#[derive(Debug, Default)]\n+pub struct PerNsGlobImports {\n+    types: FxHashSet<(LocalModuleId, Name)>,\n+    values: FxHashSet<(LocalModuleId, Name)>,\n+    macros: FxHashSet<(LocalModuleId, Name)>,\n+}\n+\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct ItemScope {\n+    _c: Count<Self>,\n+\n+    /// Defs visible in this scope. This includes `declarations`, but also\n+    /// imports.\n+    types: FxHashMap<Name, (ModuleDefId, Visibility)>,\n+    values: FxHashMap<Name, (ModuleDefId, Visibility)>,\n+    macros: FxHashMap<Name, (MacroId, Visibility)>,\n+    unresolved: FxHashSet<Name>,\n+\n+    /// The defs declared in this scope. Each def has a single scope where it is\n+    /// declared.\n+    declarations: Vec<ModuleDefId>,\n+\n+    impls: Vec<ImplId>,\n+    unnamed_consts: Vec<ConstId>,\n+    /// Traits imported via `use Trait as _;`.\n+    unnamed_trait_imports: FxHashMap<TraitId, Visibility>,\n+    /// Macros visible in current module in legacy textual scope\n+    ///\n+    /// For macros invoked by an unqualified identifier like `bar!()`, `legacy_macros` will be searched in first.\n+    /// If it yields no result, then it turns to module scoped `macros`.\n+    /// It macros with name qualified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n+    /// and only normal scoped `macros` will be searched in.\n+    ///\n+    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n+    ///\n+    /// Module scoped macros will be inserted into `items` instead of here.\n+    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n+    // be all resolved to the last one defined if shadowing happens.\n+    legacy_macros: FxHashMap<Name, SmallVec<[MacroId; 1]>>,\n+    /// The derive macro invocations in this scope.\n+    attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,\n+    /// The derive macro invocations in this scope, keyed by the owner item over the actual derive attributes\n+    /// paired with the derive macro invocations for the specific attribute.\n+    derive_macros: FxHashMap<\n+        AstId<ast::Adt>,\n+        SmallVec<[(AttrId, MacroCallId, SmallVec<[Option<MacroCallId>; 1]>); 1]>,\n+    >,\n+}\n+\n+pub(crate) static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n+    BuiltinType::ALL\n+        .iter()\n+        .map(|(name, ty)| (name.clone(), PerNs::types((*ty).into(), Visibility::Public)))\n+        .collect()\n+});\n+\n+/// Shadow mode for builtin type which can be shadowed by module.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub(crate) enum BuiltinShadowMode {\n+    /// Prefer user-defined modules (or other types) over builtins.\n+    Module,\n+    /// Prefer builtins over user-defined modules (but not other types).\n+    Other,\n+}\n+\n+/// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n+/// Other methods will only resolve values, types and module scoped macros only.\n+impl ItemScope {\n+    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, PerNs)> + 'a {\n+        // FIXME: shadowing\n+        let keys: FxHashSet<_> = self\n+            .types\n+            .keys()\n+            .chain(self.values.keys())\n+            .chain(self.macros.keys())\n+            .chain(self.unresolved.iter())\n+            .collect();\n+\n+        keys.into_iter().map(move |name| (name, self.get(name)))\n+    }\n+\n+    pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n+        self.declarations.iter().copied()\n+    }\n+\n+    pub fn impls(&self) -> impl Iterator<Item = ImplId> + ExactSizeIterator + '_ {\n+        self.impls.iter().copied()\n+    }\n+\n+    pub fn values(\n+        &self,\n+    ) -> impl Iterator<Item = (ModuleDefId, Visibility)> + ExactSizeIterator + '_ {\n+        self.values.values().copied()\n+    }\n+\n+    pub fn types(\n+        &self,\n+    ) -> impl Iterator<Item = (ModuleDefId, Visibility)> + ExactSizeIterator + '_ {\n+        self.types.values().copied()\n+    }\n+\n+    pub fn unnamed_consts(&self) -> impl Iterator<Item = ConstId> + '_ {\n+        self.unnamed_consts.iter().copied()\n+    }\n+\n+    /// Iterate over all module scoped macros\n+    pub(crate) fn macros(&self) -> impl Iterator<Item = (&Name, MacroId)> + '_ {\n+        self.entries().filter_map(|(name, def)| def.take_macros().map(|macro_| (name, macro_)))\n+    }\n+\n+    /// Iterate over all legacy textual scoped macros visible at the end of the module\n+    pub fn legacy_macros(&self) -> impl Iterator<Item = (&Name, &[MacroId])> + '_ {\n+        self.legacy_macros.iter().map(|(name, def)| (name, &**def))\n+    }\n+\n+    /// Get a name from current module scope, legacy macros are not included\n+    pub(crate) fn get(&self, name: &Name) -> PerNs {\n+        PerNs {\n+            types: self.types.get(name).copied(),\n+            values: self.values.get(name).copied(),\n+            macros: self.macros.get(name).copied(),\n+        }\n+    }\n+\n+    pub(crate) fn type_(&self, name: &Name) -> Option<(ModuleDefId, Visibility)> {\n+        self.types.get(name).copied()\n+    }\n+\n+    /// XXX: this is O(N) rather than O(1), try to not introduce new usages.\n+    pub(crate) fn name_of(&self, item: ItemInNs) -> Option<(&Name, Visibility)> {\n+        let (def, mut iter) = match item {\n+            ItemInNs::Macros(def) => {\n+                return self\n+                    .macros\n+                    .iter()\n+                    .find_map(|(name, &(other_def, vis))| (other_def == def).then(|| (name, vis)));\n+            }\n+            ItemInNs::Types(def) => (def, self.types.iter()),\n+            ItemInNs::Values(def) => (def, self.values.iter()),\n+        };\n+        iter.find_map(|(name, &(other_def, vis))| (other_def == def).then(|| (name, vis)))\n+    }\n+\n+    pub(crate) fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n+        self.types\n+            .values()\n+            .filter_map(|&(def, _)| match def {\n+                ModuleDefId::TraitId(t) => Some(t),\n+                _ => None,\n+            })\n+            .chain(self.unnamed_trait_imports.keys().copied())\n+    }\n+\n+    pub(crate) fn declare(&mut self, def: ModuleDefId) {\n+        self.declarations.push(def)\n+    }\n+\n+    pub(crate) fn get_legacy_macro(&self, name: &Name) -> Option<&[MacroId]> {\n+        self.legacy_macros.get(name).map(|it| &**it)\n+    }\n+\n+    pub(crate) fn define_impl(&mut self, imp: ImplId) {\n+        self.impls.push(imp)\n+    }\n+\n+    pub(crate) fn define_unnamed_const(&mut self, konst: ConstId) {\n+        self.unnamed_consts.push(konst);\n+    }\n+\n+    pub(crate) fn define_legacy_macro(&mut self, name: Name, mac: MacroId) {\n+        self.legacy_macros.entry(name).or_default().push(mac);\n+    }\n+\n+    pub(crate) fn add_attr_macro_invoc(&mut self, item: AstId<ast::Item>, call: MacroCallId) {\n+        self.attr_macros.insert(item, call);\n+    }\n+\n+    pub(crate) fn attr_macro_invocs(\n+        &self,\n+    ) -> impl Iterator<Item = (AstId<ast::Item>, MacroCallId)> + '_ {\n+        self.attr_macros.iter().map(|(k, v)| (*k, *v))\n+    }\n+\n+    pub(crate) fn set_derive_macro_invoc(\n+        &mut self,\n+        adt: AstId<ast::Adt>,\n+        call: MacroCallId,\n+        attr_id: AttrId,\n+        idx: usize,\n+    ) {\n+        if let Some(derives) = self.derive_macros.get_mut(&adt) {\n+            if let Some((.., invocs)) = derives.iter_mut().find(|&&mut (id, ..)| id == attr_id) {\n+                invocs[idx] = Some(call);\n+            }\n+        }\n+    }\n+\n+    /// We are required to set this up front as derive invocation recording happens out of order\n+    /// due to the fixed pointer iteration loop being able to record some derives later than others\n+    /// independent of their indices.\n+    pub(crate) fn init_derive_attribute(\n+        &mut self,\n+        adt: AstId<ast::Adt>,\n+        attr_id: AttrId,\n+        call_id: MacroCallId,\n+        len: usize,\n+    ) {\n+        self.derive_macros.entry(adt).or_default().push((attr_id, call_id, smallvec![None; len]));\n+    }\n+\n+    pub(crate) fn derive_macro_invocs(\n+        &self,\n+    ) -> impl Iterator<\n+        Item = (\n+            AstId<ast::Adt>,\n+            impl Iterator<Item = (AttrId, MacroCallId, &[Option<MacroCallId>])>,\n+        ),\n+    > + '_ {\n+        self.derive_macros.iter().map(|(k, v)| {\n+            (*k, v.iter().map(|&(attr_id, call_id, ref invocs)| (attr_id, call_id, &**invocs)))\n+        })\n+    }\n+\n+    pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> {\n+        self.unnamed_trait_imports.get(&tr).copied()\n+    }\n+\n+    pub(crate) fn push_unnamed_trait(&mut self, tr: TraitId, vis: Visibility) {\n+        self.unnamed_trait_imports.insert(tr, vis);\n+    }\n+\n+    pub(crate) fn push_res_with_import(\n+        &mut self,\n+        glob_imports: &mut PerNsGlobImports,\n+        lookup: (LocalModuleId, Name),\n+        def: PerNs,\n+        def_import_type: ImportType,\n+    ) -> bool {\n+        let mut changed = false;\n+\n+        macro_rules! check_changed {\n+            (\n+                $changed:ident,\n+                ( $this:ident / $def:ident ) . $field:ident,\n+                $glob_imports:ident [ $lookup:ident ],\n+                $def_import_type:ident\n+            ) => {{\n+                if let Some(fld) = $def.$field {\n+                    let existing = $this.$field.entry($lookup.1.clone());\n+                    match existing {\n+                        Entry::Vacant(entry) => {\n+                            match $def_import_type {\n+                                ImportType::Glob => {\n+                                    $glob_imports.$field.insert($lookup.clone());\n+                                }\n+                                ImportType::Named => {\n+                                    $glob_imports.$field.remove(&$lookup);\n+                                }\n+                            }\n+\n+                            entry.insert(fld);\n+                            $changed = true;\n+                        }\n+                        Entry::Occupied(mut entry)\n+                            if $glob_imports.$field.contains(&$lookup)\n+                                && matches!($def_import_type, ImportType::Named) =>\n+                        {\n+                            cov_mark::hit!(import_shadowed);\n+                            $glob_imports.$field.remove(&$lookup);\n+                            entry.insert(fld);\n+                            $changed = true;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }};\n+        }\n+\n+        check_changed!(changed, (self / def).types, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (self / def).values, glob_imports[lookup], def_import_type);\n+        check_changed!(changed, (self / def).macros, glob_imports[lookup], def_import_type);\n+\n+        if def.is_none() && self.unresolved.insert(lookup.1) {\n+            changed = true;\n+        }\n+\n+        changed\n+    }\n+\n+    pub(crate) fn resolutions<'a>(&'a self) -> impl Iterator<Item = (Option<Name>, PerNs)> + 'a {\n+        self.entries().map(|(name, res)| (Some(name.clone()), res)).chain(\n+            self.unnamed_trait_imports\n+                .iter()\n+                .map(|(tr, vis)| (None, PerNs::types(ModuleDefId::TraitId(*tr), *vis))),\n+        )\n+    }\n+\n+    pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, SmallVec<[MacroId; 1]>> {\n+        self.legacy_macros.clone()\n+    }\n+\n+    /// Marks everything that is not a procedural macro as private to `this_module`.\n+    pub(crate) fn censor_non_proc_macros(&mut self, this_module: ModuleId) {\n+        self.types\n+            .values_mut()\n+            .chain(self.values.values_mut())\n+            .map(|(_, v)| v)\n+            .chain(self.unnamed_trait_imports.values_mut())\n+            .for_each(|vis| *vis = Visibility::Module(this_module));\n+\n+        for (mac, vis) in self.macros.values_mut() {\n+            if let MacroId::ProcMacroId(_) = mac {\n+                // FIXME: Technically this is insufficient since reexports of proc macros are also\n+                // forbidden. Practically nobody does that.\n+                continue;\n+            }\n+\n+            *vis = Visibility::Module(this_module);\n+        }\n+    }\n+\n+    pub(crate) fn dump(&self, buf: &mut String) {\n+        let mut entries: Vec<_> = self.resolutions().collect();\n+        entries.sort_by_key(|(name, _)| name.clone());\n+\n+        for (name, def) in entries {\n+            format_to!(buf, \"{}:\", name.map_or(\"_\".to_string(), |name| name.to_string()));\n+\n+            if def.types.is_some() {\n+                buf.push_str(\" t\");\n+            }\n+            if def.values.is_some() {\n+                buf.push_str(\" v\");\n+            }\n+            if def.macros.is_some() {\n+                buf.push_str(\" m\");\n+            }\n+            if def.is_none() {\n+                buf.push_str(\" _\");\n+            }\n+\n+            buf.push('\\n');\n+        }\n+    }\n+\n+    pub(crate) fn shrink_to_fit(&mut self) {\n+        // Exhaustive match to require handling new fields.\n+        let Self {\n+            _c: _,\n+            types,\n+            values,\n+            macros,\n+            unresolved,\n+            declarations,\n+            impls,\n+            unnamed_consts,\n+            unnamed_trait_imports,\n+            legacy_macros,\n+            attr_macros,\n+            derive_macros,\n+        } = self;\n+        types.shrink_to_fit();\n+        values.shrink_to_fit();\n+        macros.shrink_to_fit();\n+        unresolved.shrink_to_fit();\n+        declarations.shrink_to_fit();\n+        impls.shrink_to_fit();\n+        unnamed_consts.shrink_to_fit();\n+        unnamed_trait_imports.shrink_to_fit();\n+        legacy_macros.shrink_to_fit();\n+        attr_macros.shrink_to_fit();\n+        derive_macros.shrink_to_fit();\n+    }\n+}\n+\n+impl PerNs {\n+    pub(crate) fn from_def(def: ModuleDefId, v: Visibility, has_constructor: bool) -> PerNs {\n+        match def {\n+            ModuleDefId::ModuleId(_) => PerNs::types(def, v),\n+            ModuleDefId::FunctionId(_) => PerNs::values(def, v),\n+            ModuleDefId::AdtId(adt) => match adt {\n+                AdtId::UnionId(_) => PerNs::types(def, v),\n+                AdtId::EnumId(_) => PerNs::types(def, v),\n+                AdtId::StructId(_) => {\n+                    if has_constructor {\n+                        PerNs::both(def, def, v)\n+                    } else {\n+                        PerNs::types(def, v)\n+                    }\n+                }\n+            },\n+            ModuleDefId::EnumVariantId(_) => PerNs::both(def, def, v),\n+            ModuleDefId::ConstId(_) | ModuleDefId::StaticId(_) => PerNs::values(def, v),\n+            ModuleDefId::TraitId(_) => PerNs::types(def, v),\n+            ModuleDefId::TypeAliasId(_) => PerNs::types(def, v),\n+            ModuleDefId::BuiltinType(_) => PerNs::types(def, v),\n+            ModuleDefId::MacroId(mac) => PerNs::macros(mac, v),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n+pub enum ItemInNs {\n+    Types(ModuleDefId),\n+    Values(ModuleDefId),\n+    Macros(MacroId),\n+}\n+\n+impl ItemInNs {\n+    pub fn as_module_def_id(self) -> Option<ModuleDefId> {\n+        match self {\n+            ItemInNs::Types(id) | ItemInNs::Values(id) => Some(id),\n+            ItemInNs::Macros(_) => None,\n+        }\n+    }\n+\n+    /// Returns the crate defining this item (or `None` if `self` is built-in).\n+    pub fn krate(&self, db: &dyn DefDatabase) -> Option<CrateId> {\n+        match self {\n+            ItemInNs::Types(did) | ItemInNs::Values(did) => did.module(db).map(|m| m.krate),\n+            ItemInNs::Macros(id) => Some(id.module(db).krate),\n+        }\n+    }\n+}"}, {"sha": "375587ee935bf65425fad8254ad12c60703c18a4", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree.rs", "status": "added", "additions": 961, "deletions": 0, "changes": 961, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,961 @@\n+//! A simplified AST that only contains items.\n+//!\n+//! This is the primary IR used throughout `hir_def`. It is the input to the name resolution\n+//! algorithm, as well as to the queries defined in `adt.rs`, `data.rs`, and most things in\n+//! `attr.rs`.\n+//!\n+//! `ItemTree`s are built per `HirFileId`, from the syntax tree of the parsed file. This means that\n+//! they are crate-independent: they don't know which `#[cfg]`s are active or which module they\n+//! belong to, since those concepts don't exist at this level (a single `ItemTree` might be part of\n+//! multiple crates, or might be included into the same crate twice via `#[path]`).\n+//!\n+//! One important purpose of this layer is to provide an \"invalidation barrier\" for incremental\n+//! computations: when typing inside an item body, the `ItemTree` of the modified file is typically\n+//! unaffected, so we don't have to recompute name resolution results or item data (see `data.rs`).\n+//!\n+//! The `ItemTree` for the currently open file can be displayed by using the VS Code command\n+//! \"Rust Analyzer: Debug ItemTree\".\n+//!\n+//! Compared to rustc's architecture, `ItemTree` has properties from both rustc's AST and HIR: many\n+//! syntax-level Rust features are already desugared to simpler forms in the `ItemTree`, but name\n+//! resolution has not yet been performed. `ItemTree`s are per-file, while rustc's AST and HIR are\n+//! per-crate, because we are interested in incrementally computing it.\n+//!\n+//! The representation of items in the `ItemTree` should generally mirror the surface syntax: it is\n+//! usually a bad idea to desugar a syntax-level construct to something that is structurally\n+//! different here. Name resolution needs to be able to process attributes and expand macros\n+//! (including attribute macros), and having a 1-to-1 mapping between syntax and the `ItemTree`\n+//! avoids introducing subtle bugs.\n+//!\n+//! In general, any item in the `ItemTree` stores its `AstId`, which allows mapping it back to its\n+//! surface syntax.\n+\n+mod lower;\n+mod pretty;\n+#[cfg(test)]\n+mod tests;\n+\n+use std::{\n+    fmt::{self, Debug},\n+    hash::{Hash, Hasher},\n+    marker::PhantomData,\n+    ops::Index,\n+    sync::Arc,\n+};\n+\n+use ast::{AstNode, HasName, StructKind};\n+use base_db::CrateId;\n+use either::Either;\n+use hir_expand::{\n+    ast_id_map::FileAstId,\n+    hygiene::Hygiene,\n+    name::{name, AsName, Name},\n+    ExpandTo, HirFileId, InFile,\n+};\n+use la_arena::{Arena, Idx, IdxRange, RawIdx};\n+use profile::Count;\n+use rustc_hash::FxHashMap;\n+use smallvec::SmallVec;\n+use stdx::never;\n+use syntax::{ast, match_ast, SyntaxKind};\n+\n+use crate::{\n+    attr::{Attrs, RawAttrs},\n+    db::DefDatabase,\n+    generics::GenericParams,\n+    intern::Interned,\n+    path::{path, AssociatedTypeBinding, GenericArgs, ImportAlias, ModPath, Path, PathKind},\n+    type_ref::{Mutability, TraitRef, TypeBound, TypeRef},\n+    visibility::RawVisibility,\n+    BlockId,\n+};\n+\n+#[derive(Copy, Clone, Eq, PartialEq)]\n+pub struct RawVisibilityId(u32);\n+\n+impl RawVisibilityId {\n+    pub const PUB: Self = RawVisibilityId(u32::max_value());\n+    pub const PRIV: Self = RawVisibilityId(u32::max_value() - 1);\n+    pub const PUB_CRATE: Self = RawVisibilityId(u32::max_value() - 2);\n+}\n+\n+impl fmt::Debug for RawVisibilityId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut f = f.debug_tuple(\"RawVisibilityId\");\n+        match *self {\n+            Self::PUB => f.field(&\"pub\"),\n+            Self::PRIV => f.field(&\"pub(self)\"),\n+            Self::PUB_CRATE => f.field(&\"pub(crate)\"),\n+            _ => f.field(&self.0),\n+        };\n+        f.finish()\n+    }\n+}\n+\n+/// The item tree of a source file.\n+#[derive(Debug, Default, Eq, PartialEq)]\n+pub struct ItemTree {\n+    _c: Count<Self>,\n+\n+    top_level: SmallVec<[ModItem; 1]>,\n+    attrs: FxHashMap<AttrOwner, RawAttrs>,\n+\n+    data: Option<Box<ItemTreeData>>,\n+}\n+\n+impl ItemTree {\n+    pub(crate) fn file_item_tree_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<ItemTree> {\n+        let _p = profile::span(\"file_item_tree_query\").detail(|| format!(\"{:?}\", file_id));\n+        let syntax = match db.parse_or_expand(file_id) {\n+            Some(node) => node,\n+            None => return Default::default(),\n+        };\n+        if never!(syntax.kind() == SyntaxKind::ERROR) {\n+            // FIXME: not 100% sure why these crop up, but return an empty tree to avoid a panic\n+            return Default::default();\n+        }\n+\n+        let ctx = lower::Ctx::new(db, file_id);\n+        let mut top_attrs = None;\n+        let mut item_tree = match_ast! {\n+            match syntax {\n+                ast::SourceFile(file) => {\n+                    top_attrs = Some(RawAttrs::new(db, &file, ctx.hygiene()));\n+                    ctx.lower_module_items(&file)\n+                },\n+                ast::MacroItems(items) => {\n+                    ctx.lower_module_items(&items)\n+                },\n+                ast::MacroStmts(stmts) => {\n+                    // The produced statements can include items, which should be added as top-level\n+                    // items.\n+                    ctx.lower_macro_stmts(stmts)\n+                },\n+                _ => {\n+                    panic!(\"cannot create item tree from {:?} {}\", syntax, syntax);\n+                },\n+            }\n+        };\n+\n+        if let Some(attrs) = top_attrs {\n+            item_tree.attrs.insert(AttrOwner::TopLevel, attrs);\n+        }\n+        item_tree.shrink_to_fit();\n+        Arc::new(item_tree)\n+    }\n+\n+    /// Returns an iterator over all items located at the top level of the `HirFileId` this\n+    /// `ItemTree` was created from.\n+    pub fn top_level_items(&self) -> &[ModItem] {\n+        &self.top_level\n+    }\n+\n+    /// Returns the inner attributes of the source file.\n+    pub fn top_level_attrs(&self, db: &dyn DefDatabase, krate: CrateId) -> Attrs {\n+        self.attrs.get(&AttrOwner::TopLevel).unwrap_or(&RawAttrs::EMPTY).clone().filter(db, krate)\n+    }\n+\n+    pub(crate) fn raw_attrs(&self, of: AttrOwner) -> &RawAttrs {\n+        self.attrs.get(&of).unwrap_or(&RawAttrs::EMPTY)\n+    }\n+\n+    pub(crate) fn attrs(&self, db: &dyn DefDatabase, krate: CrateId, of: AttrOwner) -> Attrs {\n+        self.raw_attrs(of).clone().filter(db, krate)\n+    }\n+\n+    pub fn pretty_print(&self) -> String {\n+        pretty::print_item_tree(self)\n+    }\n+\n+    fn data(&self) -> &ItemTreeData {\n+        self.data.as_ref().expect(\"attempted to access data of empty ItemTree\")\n+    }\n+\n+    fn data_mut(&mut self) -> &mut ItemTreeData {\n+        self.data.get_or_insert_with(Box::default)\n+    }\n+\n+    fn block_item_tree(db: &dyn DefDatabase, block: BlockId) -> Arc<ItemTree> {\n+        let loc = db.lookup_intern_block(block);\n+        let block = loc.ast_id.to_node(db.upcast());\n+        let ctx = lower::Ctx::new(db, loc.ast_id.file_id);\n+        Arc::new(ctx.lower_block(&block))\n+    }\n+\n+    fn shrink_to_fit(&mut self) {\n+        if let Some(data) = &mut self.data {\n+            let ItemTreeData {\n+                imports,\n+                extern_crates,\n+                extern_blocks,\n+                functions,\n+                params,\n+                structs,\n+                fields,\n+                unions,\n+                enums,\n+                variants,\n+                consts,\n+                statics,\n+                traits,\n+                impls,\n+                type_aliases,\n+                mods,\n+                macro_calls,\n+                macro_rules,\n+                macro_defs,\n+                vis,\n+            } = &mut **data;\n+\n+            imports.shrink_to_fit();\n+            extern_crates.shrink_to_fit();\n+            extern_blocks.shrink_to_fit();\n+            functions.shrink_to_fit();\n+            params.shrink_to_fit();\n+            structs.shrink_to_fit();\n+            fields.shrink_to_fit();\n+            unions.shrink_to_fit();\n+            enums.shrink_to_fit();\n+            variants.shrink_to_fit();\n+            consts.shrink_to_fit();\n+            statics.shrink_to_fit();\n+            traits.shrink_to_fit();\n+            impls.shrink_to_fit();\n+            type_aliases.shrink_to_fit();\n+            mods.shrink_to_fit();\n+            macro_calls.shrink_to_fit();\n+            macro_rules.shrink_to_fit();\n+            macro_defs.shrink_to_fit();\n+\n+            vis.arena.shrink_to_fit();\n+        }\n+    }\n+}\n+\n+#[derive(Default, Debug, Eq, PartialEq)]\n+struct ItemVisibilities {\n+    arena: Arena<RawVisibility>,\n+}\n+\n+impl ItemVisibilities {\n+    fn alloc(&mut self, vis: RawVisibility) -> RawVisibilityId {\n+        match &vis {\n+            RawVisibility::Public => RawVisibilityId::PUB,\n+            RawVisibility::Module(path) if path.segments().is_empty() => match &path.kind {\n+                PathKind::Super(0) => RawVisibilityId::PRIV,\n+                PathKind::Crate => RawVisibilityId::PUB_CRATE,\n+                _ => RawVisibilityId(self.arena.alloc(vis).into_raw().into()),\n+            },\n+            _ => RawVisibilityId(self.arena.alloc(vis).into_raw().into()),\n+        }\n+    }\n+}\n+\n+static VIS_PUB: RawVisibility = RawVisibility::Public;\n+static VIS_PRIV: RawVisibility = RawVisibility::Module(ModPath::from_kind(PathKind::Super(0)));\n+static VIS_PUB_CRATE: RawVisibility = RawVisibility::Module(ModPath::from_kind(PathKind::Crate));\n+\n+#[derive(Default, Debug, Eq, PartialEq)]\n+struct ItemTreeData {\n+    imports: Arena<Import>,\n+    extern_crates: Arena<ExternCrate>,\n+    extern_blocks: Arena<ExternBlock>,\n+    functions: Arena<Function>,\n+    params: Arena<Param>,\n+    structs: Arena<Struct>,\n+    fields: Arena<Field>,\n+    unions: Arena<Union>,\n+    enums: Arena<Enum>,\n+    variants: Arena<Variant>,\n+    consts: Arena<Const>,\n+    statics: Arena<Static>,\n+    traits: Arena<Trait>,\n+    impls: Arena<Impl>,\n+    type_aliases: Arena<TypeAlias>,\n+    mods: Arena<Mod>,\n+    macro_calls: Arena<MacroCall>,\n+    macro_rules: Arena<MacroRules>,\n+    macro_defs: Arena<MacroDef>,\n+\n+    vis: ItemVisibilities,\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Hash)]\n+pub enum AttrOwner {\n+    /// Attributes on an item.\n+    ModItem(ModItem),\n+    /// Inner attributes of the source file.\n+    TopLevel,\n+\n+    Variant(Idx<Variant>),\n+    Field(Idx<Field>),\n+    Param(Idx<Param>),\n+}\n+\n+macro_rules! from_attrs {\n+    ( $( $var:ident($t:ty) ),+ ) => {\n+        $(\n+            impl From<$t> for AttrOwner {\n+                fn from(t: $t) -> AttrOwner {\n+                    AttrOwner::$var(t)\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+from_attrs!(ModItem(ModItem), Variant(Idx<Variant>), Field(Idx<Field>), Param(Idx<Param>));\n+\n+/// Trait implemented by all item nodes in the item tree.\n+pub trait ItemTreeNode: Clone {\n+    type Source: AstNode + Into<ast::Item>;\n+\n+    fn ast_id(&self) -> FileAstId<Self::Source>;\n+\n+    /// Looks up an instance of `Self` in an item tree.\n+    fn lookup(tree: &ItemTree, index: Idx<Self>) -> &Self;\n+\n+    /// Downcasts a `ModItem` to a `FileItemTreeId` specific to this type.\n+    fn id_from_mod_item(mod_item: ModItem) -> Option<FileItemTreeId<Self>>;\n+\n+    /// Upcasts a `FileItemTreeId` to a generic `ModItem`.\n+    fn id_to_mod_item(id: FileItemTreeId<Self>) -> ModItem;\n+}\n+\n+pub struct FileItemTreeId<N: ItemTreeNode> {\n+    index: Idx<N>,\n+    _p: PhantomData<N>,\n+}\n+\n+impl<N: ItemTreeNode> Clone for FileItemTreeId<N> {\n+    fn clone(&self) -> Self {\n+        Self { index: self.index, _p: PhantomData }\n+    }\n+}\n+impl<N: ItemTreeNode> Copy for FileItemTreeId<N> {}\n+\n+impl<N: ItemTreeNode> PartialEq for FileItemTreeId<N> {\n+    fn eq(&self, other: &FileItemTreeId<N>) -> bool {\n+        self.index == other.index\n+    }\n+}\n+impl<N: ItemTreeNode> Eq for FileItemTreeId<N> {}\n+\n+impl<N: ItemTreeNode> Hash for FileItemTreeId<N> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.index.hash(state)\n+    }\n+}\n+\n+impl<N: ItemTreeNode> fmt::Debug for FileItemTreeId<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.index.fmt(f)\n+    }\n+}\n+\n+/// Identifies a particular [`ItemTree`].\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]\n+pub struct TreeId {\n+    file: HirFileId,\n+    block: Option<BlockId>,\n+}\n+\n+impl TreeId {\n+    pub(crate) fn new(file: HirFileId, block: Option<BlockId>) -> Self {\n+        Self { file, block }\n+    }\n+\n+    pub(crate) fn item_tree(&self, db: &dyn DefDatabase) -> Arc<ItemTree> {\n+        match self.block {\n+            Some(block) => ItemTree::block_item_tree(db, block),\n+            None => db.file_item_tree(self.file),\n+        }\n+    }\n+\n+    pub(crate) fn file_id(self) -> HirFileId {\n+        self.file\n+    }\n+\n+    pub(crate) fn is_block(self) -> bool {\n+        self.block.is_some()\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct ItemTreeId<N: ItemTreeNode> {\n+    tree: TreeId,\n+    pub value: FileItemTreeId<N>,\n+}\n+\n+impl<N: ItemTreeNode> ItemTreeId<N> {\n+    pub fn new(tree: TreeId, idx: FileItemTreeId<N>) -> Self {\n+        Self { tree, value: idx }\n+    }\n+\n+    pub fn file_id(self) -> HirFileId {\n+        self.tree.file\n+    }\n+\n+    pub fn tree_id(self) -> TreeId {\n+        self.tree\n+    }\n+\n+    pub fn item_tree(self, db: &dyn DefDatabase) -> Arc<ItemTree> {\n+        self.tree.item_tree(db)\n+    }\n+}\n+\n+impl<N: ItemTreeNode> Copy for ItemTreeId<N> {}\n+impl<N: ItemTreeNode> Clone for ItemTreeId<N> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<N: ItemTreeNode> PartialEq for ItemTreeId<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.tree == other.tree && self.value == other.value\n+    }\n+}\n+\n+impl<N: ItemTreeNode> Eq for ItemTreeId<N> {}\n+\n+impl<N: ItemTreeNode> Hash for ItemTreeId<N> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.tree.hash(state);\n+        self.value.hash(state);\n+    }\n+}\n+\n+macro_rules! mod_items {\n+    ( $( $typ:ident in $fld:ident -> $ast:ty ),+ $(,)? ) => {\n+        #[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n+        pub enum ModItem {\n+            $(\n+                $typ(FileItemTreeId<$typ>),\n+            )+\n+        }\n+\n+        $(\n+            impl From<FileItemTreeId<$typ>> for ModItem {\n+                fn from(id: FileItemTreeId<$typ>) -> ModItem {\n+                    ModItem::$typ(id)\n+                }\n+            }\n+        )+\n+\n+        $(\n+            impl ItemTreeNode for $typ {\n+                type Source = $ast;\n+\n+                fn ast_id(&self) -> FileAstId<Self::Source> {\n+                    self.ast_id\n+                }\n+\n+                fn lookup(tree: &ItemTree, index: Idx<Self>) -> &Self {\n+                    &tree.data().$fld[index]\n+                }\n+\n+                fn id_from_mod_item(mod_item: ModItem) -> Option<FileItemTreeId<Self>> {\n+                    match mod_item {\n+                        ModItem::$typ(id) => Some(id),\n+                        _ => None,\n+                    }\n+                }\n+\n+                fn id_to_mod_item(id: FileItemTreeId<Self>) -> ModItem {\n+                    ModItem::$typ(id)\n+                }\n+            }\n+\n+            impl Index<Idx<$typ>> for ItemTree {\n+                type Output = $typ;\n+\n+                fn index(&self, index: Idx<$typ>) -> &Self::Output {\n+                    &self.data().$fld[index]\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+mod_items! {\n+    Import in imports -> ast::Use,\n+    ExternCrate in extern_crates -> ast::ExternCrate,\n+    ExternBlock in extern_blocks -> ast::ExternBlock,\n+    Function in functions -> ast::Fn,\n+    Struct in structs -> ast::Struct,\n+    Union in unions -> ast::Union,\n+    Enum in enums -> ast::Enum,\n+    Const in consts -> ast::Const,\n+    Static in statics -> ast::Static,\n+    Trait in traits -> ast::Trait,\n+    Impl in impls -> ast::Impl,\n+    TypeAlias in type_aliases -> ast::TypeAlias,\n+    Mod in mods -> ast::Module,\n+    MacroCall in macro_calls -> ast::MacroCall,\n+    MacroRules in macro_rules -> ast::MacroRules,\n+    MacroDef in macro_defs -> ast::MacroDef,\n+}\n+\n+macro_rules! impl_index {\n+    ( $($fld:ident: $t:ty),+ $(,)? ) => {\n+        $(\n+            impl Index<Idx<$t>> for ItemTree {\n+                type Output = $t;\n+\n+                fn index(&self, index: Idx<$t>) -> &Self::Output {\n+                    &self.data().$fld[index]\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+impl_index!(fields: Field, variants: Variant, params: Param);\n+\n+impl Index<RawVisibilityId> for ItemTree {\n+    type Output = RawVisibility;\n+    fn index(&self, index: RawVisibilityId) -> &Self::Output {\n+        match index {\n+            RawVisibilityId::PRIV => &VIS_PRIV,\n+            RawVisibilityId::PUB => &VIS_PUB,\n+            RawVisibilityId::PUB_CRATE => &VIS_PUB_CRATE,\n+            _ => &self.data().vis.arena[Idx::from_raw(index.0.into())],\n+        }\n+    }\n+}\n+\n+impl<N: ItemTreeNode> Index<FileItemTreeId<N>> for ItemTree {\n+    type Output = N;\n+    fn index(&self, id: FileItemTreeId<N>) -> &N {\n+        N::lookup(self, id.index)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Import {\n+    pub visibility: RawVisibilityId,\n+    pub ast_id: FileAstId<ast::Use>,\n+    pub use_tree: UseTree,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct UseTree {\n+    pub index: Idx<ast::UseTree>,\n+    kind: UseTreeKind,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum UseTreeKind {\n+    /// ```\n+    /// use path::to::Item;\n+    /// use path::to::Item as Renamed;\n+    /// use path::to::Trait as _;\n+    /// ```\n+    Single { path: Interned<ModPath>, alias: Option<ImportAlias> },\n+\n+    /// ```\n+    /// use *;  // (invalid, but can occur in nested tree)\n+    /// use path::*;\n+    /// ```\n+    Glob { path: Option<Interned<ModPath>> },\n+\n+    /// ```\n+    /// use prefix::{self, Item, ...};\n+    /// ```\n+    Prefixed { prefix: Option<Interned<ModPath>>, list: Box<[UseTree]> },\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct ExternCrate {\n+    pub name: Name,\n+    pub alias: Option<ImportAlias>,\n+    pub visibility: RawVisibilityId,\n+    pub ast_id: FileAstId<ast::ExternCrate>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct ExternBlock {\n+    pub abi: Option<Interned<str>>,\n+    pub ast_id: FileAstId<ast::ExternBlock>,\n+    pub children: Box<[ModItem]>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Function {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub explicit_generic_params: Interned<GenericParams>,\n+    pub abi: Option<Interned<str>>,\n+    pub params: IdxRange<Param>,\n+    pub ret_type: Interned<TypeRef>,\n+    pub async_ret_type: Option<Interned<TypeRef>>,\n+    pub ast_id: FileAstId<ast::Fn>,\n+    pub(crate) flags: FnFlags,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum Param {\n+    Normal(Option<Name>, Interned<TypeRef>),\n+    Varargs,\n+}\n+\n+bitflags::bitflags! {\n+    #[derive(Default)]\n+    pub(crate) struct FnFlags: u8 {\n+        const HAS_SELF_PARAM = 1 << 0;\n+        const HAS_BODY = 1 << 1;\n+        const HAS_DEFAULT_KW = 1 << 2;\n+        const HAS_CONST_KW = 1 << 3;\n+        const HAS_ASYNC_KW = 1 << 4;\n+        const HAS_UNSAFE_KW = 1 << 5;\n+        const IS_VARARGS = 1 << 6;\n+    }\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Struct {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub generic_params: Interned<GenericParams>,\n+    pub fields: Fields,\n+    pub ast_id: FileAstId<ast::Struct>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Union {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub generic_params: Interned<GenericParams>,\n+    pub fields: Fields,\n+    pub ast_id: FileAstId<ast::Union>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Enum {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub generic_params: Interned<GenericParams>,\n+    pub variants: IdxRange<Variant>,\n+    pub ast_id: FileAstId<ast::Enum>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Const {\n+    /// `None` for `const _: () = ();`\n+    pub name: Option<Name>,\n+    pub visibility: RawVisibilityId,\n+    pub type_ref: Interned<TypeRef>,\n+    pub ast_id: FileAstId<ast::Const>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Static {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub mutable: bool,\n+    pub type_ref: Interned<TypeRef>,\n+    pub ast_id: FileAstId<ast::Static>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Trait {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub generic_params: Interned<GenericParams>,\n+    pub is_auto: bool,\n+    pub is_unsafe: bool,\n+    pub items: Box<[AssocItem]>,\n+    pub ast_id: FileAstId<ast::Trait>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Impl {\n+    pub generic_params: Interned<GenericParams>,\n+    pub target_trait: Option<Interned<TraitRef>>,\n+    pub self_ty: Interned<TypeRef>,\n+    pub is_negative: bool,\n+    pub items: Box<[AssocItem]>,\n+    pub ast_id: FileAstId<ast::Impl>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TypeAlias {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    /// Bounds on the type alias itself. Only valid in trait declarations, eg. `type Assoc: Copy;`.\n+    pub bounds: Box<[Interned<TypeBound>]>,\n+    pub generic_params: Interned<GenericParams>,\n+    pub type_ref: Option<Interned<TypeRef>>,\n+    pub ast_id: FileAstId<ast::TypeAlias>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Mod {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub kind: ModKind,\n+    pub ast_id: FileAstId<ast::Module>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum ModKind {\n+    /// `mod m { ... }`\n+    Inline { items: Box<[ModItem]> },\n+\n+    /// `mod m;`\n+    Outline,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct MacroCall {\n+    /// Path to the called macro.\n+    pub path: Interned<ModPath>,\n+    pub ast_id: FileAstId<ast::MacroCall>,\n+    pub expand_to: ExpandTo,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct MacroRules {\n+    /// The name of the declared macro.\n+    pub name: Name,\n+    pub ast_id: FileAstId<ast::MacroRules>,\n+}\n+\n+/// \"Macros 2.0\" macro definition.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct MacroDef {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub ast_id: FileAstId<ast::MacroDef>,\n+}\n+\n+impl Import {\n+    /// Maps a `UseTree` contained in this import back to its AST node.\n+    pub fn use_tree_to_ast(\n+        &self,\n+        db: &dyn DefDatabase,\n+        file_id: HirFileId,\n+        index: Idx<ast::UseTree>,\n+    ) -> ast::UseTree {\n+        // Re-lower the AST item and get the source map.\n+        // Note: The AST unwraps are fine, since if they fail we should have never obtained `index`.\n+        let ast = InFile::new(file_id, self.ast_id).to_node(db.upcast());\n+        let ast_use_tree = ast.use_tree().expect(\"missing `use_tree`\");\n+        let hygiene = Hygiene::new(db.upcast(), file_id);\n+        let (_, source_map) =\n+            lower::lower_use_tree(db, &hygiene, ast_use_tree).expect(\"failed to lower use tree\");\n+        source_map[index].clone()\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+pub enum ImportKind {\n+    /// The `ModPath` is imported normally.\n+    Plain,\n+    /// This is a glob-import of all names in the `ModPath`.\n+    Glob,\n+    /// This is a `some::path::self` import, which imports `some::path` only in type namespace.\n+    TypeOnly,\n+}\n+\n+impl UseTree {\n+    /// Expands the `UseTree` into individually imported `ModPath`s.\n+    pub fn expand(\n+        &self,\n+        mut cb: impl FnMut(Idx<ast::UseTree>, ModPath, ImportKind, Option<ImportAlias>),\n+    ) {\n+        self.expand_impl(None, &mut cb)\n+    }\n+\n+    fn expand_impl(\n+        &self,\n+        prefix: Option<ModPath>,\n+        cb: &mut dyn FnMut(Idx<ast::UseTree>, ModPath, ImportKind, Option<ImportAlias>),\n+    ) {\n+        fn concat_mod_paths(\n+            prefix: Option<ModPath>,\n+            path: &ModPath,\n+        ) -> Option<(ModPath, ImportKind)> {\n+            match (prefix, &path.kind) {\n+                (None, _) => Some((path.clone(), ImportKind::Plain)),\n+                (Some(mut prefix), PathKind::Plain) => {\n+                    for segment in path.segments() {\n+                        prefix.push_segment(segment.clone());\n+                    }\n+                    Some((prefix, ImportKind::Plain))\n+                }\n+                (Some(mut prefix), PathKind::Super(n))\n+                    if *n > 0 && prefix.segments().is_empty() =>\n+                {\n+                    // `super::super` + `super::rest`\n+                    match &mut prefix.kind {\n+                        PathKind::Super(m) => {\n+                            cov_mark::hit!(concat_super_mod_paths);\n+                            *m += *n;\n+                            for segment in path.segments() {\n+                                prefix.push_segment(segment.clone());\n+                            }\n+                            Some((prefix, ImportKind::Plain))\n+                        }\n+                        _ => None,\n+                    }\n+                }\n+                (Some(prefix), PathKind::Super(0)) if path.segments().is_empty() => {\n+                    // `some::path::self` == `some::path`\n+                    Some((prefix, ImportKind::TypeOnly))\n+                }\n+                (Some(_), _) => None,\n+            }\n+        }\n+\n+        match &self.kind {\n+            UseTreeKind::Single { path, alias } => {\n+                if let Some((path, kind)) = concat_mod_paths(prefix, path) {\n+                    cb(self.index, path, kind, alias.clone());\n+                }\n+            }\n+            UseTreeKind::Glob { path: Some(path) } => {\n+                if let Some((path, _)) = concat_mod_paths(prefix, path) {\n+                    cb(self.index, path, ImportKind::Glob, None);\n+                }\n+            }\n+            UseTreeKind::Glob { path: None } => {\n+                if let Some(prefix) = prefix {\n+                    cb(self.index, prefix, ImportKind::Glob, None);\n+                }\n+            }\n+            UseTreeKind::Prefixed { prefix: additional_prefix, list } => {\n+                let prefix = match additional_prefix {\n+                    Some(path) => match concat_mod_paths(prefix, path) {\n+                        Some((path, ImportKind::Plain)) => Some(path),\n+                        _ => return,\n+                    },\n+                    None => prefix,\n+                };\n+                for tree in &**list {\n+                    tree.expand_impl(prefix.clone(), cb);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! impl_froms {\n+    ($e:ident { $($v:ident ($t:ty)),* $(,)? }) => {\n+        $(\n+            impl From<$t> for $e {\n+                fn from(it: $t) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+impl ModItem {\n+    pub fn as_assoc_item(&self) -> Option<AssocItem> {\n+        match self {\n+            ModItem::Import(_)\n+            | ModItem::ExternCrate(_)\n+            | ModItem::ExternBlock(_)\n+            | ModItem::Struct(_)\n+            | ModItem::Union(_)\n+            | ModItem::Enum(_)\n+            | ModItem::Static(_)\n+            | ModItem::Trait(_)\n+            | ModItem::Impl(_)\n+            | ModItem::Mod(_)\n+            | ModItem::MacroRules(_)\n+            | ModItem::MacroDef(_) => None,\n+            ModItem::MacroCall(call) => Some(AssocItem::MacroCall(*call)),\n+            ModItem::Const(konst) => Some(AssocItem::Const(*konst)),\n+            ModItem::TypeAlias(alias) => Some(AssocItem::TypeAlias(*alias)),\n+            ModItem::Function(func) => Some(AssocItem::Function(*func)),\n+        }\n+    }\n+\n+    pub fn downcast<N: ItemTreeNode>(self) -> Option<FileItemTreeId<N>> {\n+        N::id_from_mod_item(self)\n+    }\n+\n+    pub fn ast_id(&self, tree: &ItemTree) -> FileAstId<ast::Item> {\n+        match self {\n+            ModItem::Import(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::ExternCrate(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::ExternBlock(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::Function(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::Struct(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::Union(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::Enum(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::Const(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::Static(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::Trait(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::Impl(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::TypeAlias(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::Mod(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::MacroCall(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::MacroRules(it) => tree[it.index].ast_id().upcast(),\n+            ModItem::MacroDef(it) => tree[it.index].ast_id().upcast(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+pub enum AssocItem {\n+    Function(FileItemTreeId<Function>),\n+    TypeAlias(FileItemTreeId<TypeAlias>),\n+    Const(FileItemTreeId<Const>),\n+    MacroCall(FileItemTreeId<MacroCall>),\n+}\n+\n+impl_froms!(AssocItem {\n+    Function(FileItemTreeId<Function>),\n+    TypeAlias(FileItemTreeId<TypeAlias>),\n+    Const(FileItemTreeId<Const>),\n+    MacroCall(FileItemTreeId<MacroCall>),\n+});\n+\n+impl From<AssocItem> for ModItem {\n+    fn from(item: AssocItem) -> Self {\n+        match item {\n+            AssocItem::Function(it) => it.into(),\n+            AssocItem::TypeAlias(it) => it.into(),\n+            AssocItem::Const(it) => it.into(),\n+            AssocItem::MacroCall(it) => it.into(),\n+        }\n+    }\n+}\n+\n+impl AssocItem {\n+    pub fn ast_id(self, tree: &ItemTree) -> FileAstId<ast::AssocItem> {\n+        match self {\n+            AssocItem::Function(id) => tree[id].ast_id.upcast(),\n+            AssocItem::TypeAlias(id) => tree[id].ast_id.upcast(),\n+            AssocItem::Const(id) => tree[id].ast_id.upcast(),\n+            AssocItem::MacroCall(id) => tree[id].ast_id.upcast(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct Variant {\n+    pub name: Name,\n+    pub fields: Fields,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum Fields {\n+    Record(IdxRange<Field>),\n+    Tuple(IdxRange<Field>),\n+    Unit,\n+}\n+\n+/// A single field of an enum variant or struct\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Field {\n+    pub name: Name,\n+    pub type_ref: Interned<TypeRef>,\n+    pub visibility: RawVisibilityId,\n+}"}, {"sha": "7f2551e941871ffaaa47748906b7f9272bd154f2", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/lower.rs", "status": "added", "additions": 773, "deletions": 0, "changes": 773, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,773 @@\n+//! AST -> `ItemTree` lowering code.\n+\n+use std::{collections::hash_map::Entry, sync::Arc};\n+\n+use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, HirFileId};\n+use syntax::ast::{self, HasModuleItem};\n+\n+use crate::{\n+    generics::{GenericParams, TypeParamData, TypeParamProvenance},\n+    type_ref::{LifetimeRef, TraitBoundModifier, TraitRef},\n+};\n+\n+use super::*;\n+\n+fn id<N: ItemTreeNode>(index: Idx<N>) -> FileItemTreeId<N> {\n+    FileItemTreeId { index, _p: PhantomData }\n+}\n+\n+pub(super) struct Ctx<'a> {\n+    db: &'a dyn DefDatabase,\n+    tree: ItemTree,\n+    source_ast_id_map: Arc<AstIdMap>,\n+    body_ctx: crate::body::LowerCtx<'a>,\n+}\n+\n+impl<'a> Ctx<'a> {\n+    pub(super) fn new(db: &'a dyn DefDatabase, file: HirFileId) -> Self {\n+        Self {\n+            db,\n+            tree: ItemTree::default(),\n+            source_ast_id_map: db.ast_id_map(file),\n+            body_ctx: crate::body::LowerCtx::new(db, file),\n+        }\n+    }\n+\n+    pub(super) fn hygiene(&self) -> &Hygiene {\n+        self.body_ctx.hygiene()\n+    }\n+\n+    pub(super) fn lower_module_items(mut self, item_owner: &dyn HasModuleItem) -> ItemTree {\n+        self.tree.top_level =\n+            item_owner.items().flat_map(|item| self.lower_mod_item(&item)).collect();\n+        self.tree\n+    }\n+\n+    pub(super) fn lower_macro_stmts(mut self, stmts: ast::MacroStmts) -> ItemTree {\n+        self.tree.top_level = stmts\n+            .statements()\n+            .filter_map(|stmt| {\n+                match stmt {\n+                    ast::Stmt::Item(item) => Some(item),\n+                    // Macro calls can be both items and expressions. The syntax library always treats\n+                    // them as expressions here, so we undo that.\n+                    ast::Stmt::ExprStmt(es) => match es.expr()? {\n+                        ast::Expr::MacroExpr(expr) => {\n+                            cov_mark::hit!(macro_call_in_macro_stmts_is_added_to_item_tree);\n+                            Some(expr.macro_call()?.into())\n+                        }\n+                        _ => None,\n+                    },\n+                    _ => None,\n+                }\n+            })\n+            .flat_map(|item| self.lower_mod_item(&item))\n+            .collect();\n+\n+        if let Some(ast::Expr::MacroExpr(tail_macro)) = stmts.expr() {\n+            if let Some(call) = tail_macro.macro_call() {\n+                cov_mark::hit!(macro_stmt_with_trailing_macro_expr);\n+                if let Some(mod_item) = self.lower_mod_item(&call.into()) {\n+                    self.tree.top_level.push(mod_item);\n+                }\n+            }\n+        }\n+\n+        self.tree\n+    }\n+\n+    pub(super) fn lower_block(mut self, block: &ast::BlockExpr) -> ItemTree {\n+        self.tree.top_level = block\n+            .statements()\n+            .filter_map(|stmt| match stmt {\n+                ast::Stmt::Item(item) => self.lower_mod_item(&item),\n+                // Macro calls can be both items and expressions. The syntax library always treats\n+                // them as expressions here, so we undo that.\n+                ast::Stmt::ExprStmt(es) => match es.expr()? {\n+                    ast::Expr::MacroExpr(expr) => self.lower_mod_item(&expr.macro_call()?.into()),\n+                    _ => None,\n+                },\n+                _ => None,\n+            })\n+            .collect();\n+\n+        self.tree\n+    }\n+\n+    fn data(&mut self) -> &mut ItemTreeData {\n+        self.tree.data_mut()\n+    }\n+\n+    fn lower_mod_item(&mut self, item: &ast::Item) -> Option<ModItem> {\n+        let attrs = RawAttrs::new(self.db, item, self.hygiene());\n+        let item: ModItem = match item {\n+            ast::Item::Struct(ast) => self.lower_struct(ast)?.into(),\n+            ast::Item::Union(ast) => self.lower_union(ast)?.into(),\n+            ast::Item::Enum(ast) => self.lower_enum(ast)?.into(),\n+            ast::Item::Fn(ast) => self.lower_function(ast)?.into(),\n+            ast::Item::TypeAlias(ast) => self.lower_type_alias(ast)?.into(),\n+            ast::Item::Static(ast) => self.lower_static(ast)?.into(),\n+            ast::Item::Const(ast) => self.lower_const(ast).into(),\n+            ast::Item::Module(ast) => self.lower_module(ast)?.into(),\n+            ast::Item::Trait(ast) => self.lower_trait(ast)?.into(),\n+            ast::Item::Impl(ast) => self.lower_impl(ast)?.into(),\n+            ast::Item::Use(ast) => self.lower_use(ast)?.into(),\n+            ast::Item::ExternCrate(ast) => self.lower_extern_crate(ast)?.into(),\n+            ast::Item::MacroCall(ast) => self.lower_macro_call(ast)?.into(),\n+            ast::Item::MacroRules(ast) => self.lower_macro_rules(ast)?.into(),\n+            ast::Item::MacroDef(ast) => self.lower_macro_def(ast)?.into(),\n+            ast::Item::ExternBlock(ast) => self.lower_extern_block(ast).into(),\n+        };\n+\n+        self.add_attrs(item.into(), attrs);\n+\n+        Some(item)\n+    }\n+\n+    fn add_attrs(&mut self, item: AttrOwner, attrs: RawAttrs) {\n+        match self.tree.attrs.entry(item) {\n+            Entry::Occupied(mut entry) => {\n+                *entry.get_mut() = entry.get().merge(attrs);\n+            }\n+            Entry::Vacant(entry) => {\n+                entry.insert(attrs);\n+            }\n+        }\n+    }\n+\n+    fn lower_assoc_item(&mut self, item: &ast::AssocItem) -> Option<AssocItem> {\n+        match item {\n+            ast::AssocItem::Fn(ast) => self.lower_function(ast).map(Into::into),\n+            ast::AssocItem::TypeAlias(ast) => self.lower_type_alias(ast).map(Into::into),\n+            ast::AssocItem::Const(ast) => Some(self.lower_const(ast).into()),\n+            ast::AssocItem::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n+        }\n+    }\n+\n+    fn lower_struct(&mut self, strukt: &ast::Struct) -> Option<FileItemTreeId<Struct>> {\n+        let visibility = self.lower_visibility(strukt);\n+        let name = strukt.name()?.as_name();\n+        let generic_params = self.lower_generic_params(GenericsOwner::Struct, strukt);\n+        let fields = self.lower_fields(&strukt.kind());\n+        let ast_id = self.source_ast_id_map.ast_id(strukt);\n+        let res = Struct { name, visibility, generic_params, fields, ast_id };\n+        Some(id(self.data().structs.alloc(res)))\n+    }\n+\n+    fn lower_fields(&mut self, strukt_kind: &ast::StructKind) -> Fields {\n+        match strukt_kind {\n+            ast::StructKind::Record(it) => {\n+                let range = self.lower_record_fields(it);\n+                Fields::Record(range)\n+            }\n+            ast::StructKind::Tuple(it) => {\n+                let range = self.lower_tuple_fields(it);\n+                Fields::Tuple(range)\n+            }\n+            ast::StructKind::Unit => Fields::Unit,\n+        }\n+    }\n+\n+    fn lower_record_fields(&mut self, fields: &ast::RecordFieldList) -> IdxRange<Field> {\n+        let start = self.next_field_idx();\n+        for field in fields.fields() {\n+            if let Some(data) = self.lower_record_field(&field) {\n+                let idx = self.data().fields.alloc(data);\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, self.hygiene()));\n+            }\n+        }\n+        let end = self.next_field_idx();\n+        IdxRange::new(start..end)\n+    }\n+\n+    fn lower_record_field(&mut self, field: &ast::RecordField) -> Option<Field> {\n+        let name = field.name()?.as_name();\n+        let visibility = self.lower_visibility(field);\n+        let type_ref = self.lower_type_ref_opt(field.ty());\n+        let res = Field { name, type_ref, visibility };\n+        Some(res)\n+    }\n+\n+    fn lower_tuple_fields(&mut self, fields: &ast::TupleFieldList) -> IdxRange<Field> {\n+        let start = self.next_field_idx();\n+        for (i, field) in fields.fields().enumerate() {\n+            let data = self.lower_tuple_field(i, &field);\n+            let idx = self.data().fields.alloc(data);\n+            self.add_attrs(idx.into(), RawAttrs::new(self.db, &field, self.hygiene()));\n+        }\n+        let end = self.next_field_idx();\n+        IdxRange::new(start..end)\n+    }\n+\n+    fn lower_tuple_field(&mut self, idx: usize, field: &ast::TupleField) -> Field {\n+        let name = Name::new_tuple_field(idx);\n+        let visibility = self.lower_visibility(field);\n+        let type_ref = self.lower_type_ref_opt(field.ty());\n+        Field { name, type_ref, visibility }\n+    }\n+\n+    fn lower_union(&mut self, union: &ast::Union) -> Option<FileItemTreeId<Union>> {\n+        let visibility = self.lower_visibility(union);\n+        let name = union.name()?.as_name();\n+        let generic_params = self.lower_generic_params(GenericsOwner::Union, union);\n+        let fields = match union.record_field_list() {\n+            Some(record_field_list) => self.lower_fields(&StructKind::Record(record_field_list)),\n+            None => Fields::Record(IdxRange::new(self.next_field_idx()..self.next_field_idx())),\n+        };\n+        let ast_id = self.source_ast_id_map.ast_id(union);\n+        let res = Union { name, visibility, generic_params, fields, ast_id };\n+        Some(id(self.data().unions.alloc(res)))\n+    }\n+\n+    fn lower_enum(&mut self, enum_: &ast::Enum) -> Option<FileItemTreeId<Enum>> {\n+        let visibility = self.lower_visibility(enum_);\n+        let name = enum_.name()?.as_name();\n+        let generic_params = self.lower_generic_params(GenericsOwner::Enum, enum_);\n+        let variants = match &enum_.variant_list() {\n+            Some(variant_list) => self.lower_variants(variant_list),\n+            None => IdxRange::new(self.next_variant_idx()..self.next_variant_idx()),\n+        };\n+        let ast_id = self.source_ast_id_map.ast_id(enum_);\n+        let res = Enum { name, visibility, generic_params, variants, ast_id };\n+        Some(id(self.data().enums.alloc(res)))\n+    }\n+\n+    fn lower_variants(&mut self, variants: &ast::VariantList) -> IdxRange<Variant> {\n+        let start = self.next_variant_idx();\n+        for variant in variants.variants() {\n+            if let Some(data) = self.lower_variant(&variant) {\n+                let idx = self.data().variants.alloc(data);\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db, &variant, self.hygiene()));\n+            }\n+        }\n+        let end = self.next_variant_idx();\n+        IdxRange::new(start..end)\n+    }\n+\n+    fn lower_variant(&mut self, variant: &ast::Variant) -> Option<Variant> {\n+        let name = variant.name()?.as_name();\n+        let fields = self.lower_fields(&variant.kind());\n+        let res = Variant { name, fields };\n+        Some(res)\n+    }\n+\n+    fn lower_function(&mut self, func: &ast::Fn) -> Option<FileItemTreeId<Function>> {\n+        let visibility = self.lower_visibility(func);\n+        let name = func.name()?.as_name();\n+\n+        let mut has_self_param = false;\n+        let start_param = self.next_param_idx();\n+        if let Some(param_list) = func.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let self_type = match self_param.ty() {\n+                    Some(type_ref) => TypeRef::from_ast(&self.body_ctx, type_ref),\n+                    None => {\n+                        let self_type = TypeRef::Path(name![Self].into());\n+                        match self_param.kind() {\n+                            ast::SelfParamKind::Owned => self_type,\n+                            ast::SelfParamKind::Ref => TypeRef::Reference(\n+                                Box::new(self_type),\n+                                self_param.lifetime().as_ref().map(LifetimeRef::new),\n+                                Mutability::Shared,\n+                            ),\n+                            ast::SelfParamKind::MutRef => TypeRef::Reference(\n+                                Box::new(self_type),\n+                                self_param.lifetime().as_ref().map(LifetimeRef::new),\n+                                Mutability::Mut,\n+                            ),\n+                        }\n+                    }\n+                };\n+                let ty = Interned::new(self_type);\n+                let idx = self.data().params.alloc(Param::Normal(None, ty));\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db, &self_param, self.hygiene()));\n+                has_self_param = true;\n+            }\n+            for param in param_list.params() {\n+                let idx = match param.dotdotdot_token() {\n+                    Some(_) => self.data().params.alloc(Param::Varargs),\n+                    None => {\n+                        let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ty());\n+                        let ty = Interned::new(type_ref);\n+                        let mut pat = param.pat();\n+                        // FIXME: This really shouldn't be here, in fact FunctionData/ItemTree's function shouldn't know about\n+                        // pattern names at all\n+                        let name = 'name: loop {\n+                            match pat {\n+                                Some(ast::Pat::RefPat(ref_pat)) => pat = ref_pat.pat(),\n+                                Some(ast::Pat::IdentPat(ident)) => {\n+                                    break 'name ident.name().map(|it| it.as_name())\n+                                }\n+                                _ => break 'name None,\n+                            }\n+                        };\n+                        self.data().params.alloc(Param::Normal(name, ty))\n+                    }\n+                };\n+                self.add_attrs(idx.into(), RawAttrs::new(self.db, &param, self.hygiene()));\n+            }\n+        }\n+        let end_param = self.next_param_idx();\n+        let params = IdxRange::new(start_param..end_param);\n+\n+        let ret_type = match func.ret_type() {\n+            Some(rt) => match rt.ty() {\n+                Some(type_ref) => TypeRef::from_ast(&self.body_ctx, type_ref),\n+                None if rt.thin_arrow_token().is_some() => TypeRef::Error,\n+                None => TypeRef::unit(),\n+            },\n+            None => TypeRef::unit(),\n+        };\n+\n+        let (ret_type, async_ret_type) = if func.async_token().is_some() {\n+            let async_ret_type = ret_type.clone();\n+            let future_impl = desugar_future_path(ret_type);\n+            let ty_bound = Interned::new(TypeBound::Path(future_impl, TraitBoundModifier::None));\n+            (TypeRef::ImplTrait(vec![ty_bound]), Some(async_ret_type))\n+        } else {\n+            (ret_type, None)\n+        };\n+\n+        let abi = func.abi().map(lower_abi);\n+\n+        let ast_id = self.source_ast_id_map.ast_id(func);\n+\n+        let mut flags = FnFlags::default();\n+        if func.body().is_some() {\n+            flags |= FnFlags::HAS_BODY;\n+        }\n+        if has_self_param {\n+            flags |= FnFlags::HAS_SELF_PARAM;\n+        }\n+        if func.default_token().is_some() {\n+            flags |= FnFlags::HAS_DEFAULT_KW;\n+        }\n+        if func.const_token().is_some() {\n+            flags |= FnFlags::HAS_CONST_KW;\n+        }\n+        if func.async_token().is_some() {\n+            flags |= FnFlags::HAS_ASYNC_KW;\n+        }\n+        if func.unsafe_token().is_some() {\n+            flags |= FnFlags::HAS_UNSAFE_KW;\n+        }\n+\n+        let mut res = Function {\n+            name,\n+            visibility,\n+            explicit_generic_params: Interned::new(GenericParams::default()),\n+            abi,\n+            params,\n+            ret_type: Interned::new(ret_type),\n+            async_ret_type: async_ret_type.map(Interned::new),\n+            ast_id,\n+            flags,\n+        };\n+        res.explicit_generic_params =\n+            self.lower_generic_params(GenericsOwner::Function(&res), func);\n+\n+        Some(id(self.data().functions.alloc(res)))\n+    }\n+\n+    fn lower_type_alias(\n+        &mut self,\n+        type_alias: &ast::TypeAlias,\n+    ) -> Option<FileItemTreeId<TypeAlias>> {\n+        let name = type_alias.name()?.as_name();\n+        let type_ref = type_alias.ty().map(|it| self.lower_type_ref(&it));\n+        let visibility = self.lower_visibility(type_alias);\n+        let bounds = self.lower_type_bounds(type_alias);\n+        let generic_params = self.lower_generic_params(GenericsOwner::TypeAlias, type_alias);\n+        let ast_id = self.source_ast_id_map.ast_id(type_alias);\n+        let res = TypeAlias {\n+            name,\n+            visibility,\n+            bounds: bounds.into_boxed_slice(),\n+            generic_params,\n+            type_ref,\n+            ast_id,\n+        };\n+        Some(id(self.data().type_aliases.alloc(res)))\n+    }\n+\n+    fn lower_static(&mut self, static_: &ast::Static) -> Option<FileItemTreeId<Static>> {\n+        let name = static_.name()?.as_name();\n+        let type_ref = self.lower_type_ref_opt(static_.ty());\n+        let visibility = self.lower_visibility(static_);\n+        let mutable = static_.mut_token().is_some();\n+        let ast_id = self.source_ast_id_map.ast_id(static_);\n+        let res = Static { name, visibility, mutable, type_ref, ast_id };\n+        Some(id(self.data().statics.alloc(res)))\n+    }\n+\n+    fn lower_const(&mut self, konst: &ast::Const) -> FileItemTreeId<Const> {\n+        let name = konst.name().map(|it| it.as_name());\n+        let type_ref = self.lower_type_ref_opt(konst.ty());\n+        let visibility = self.lower_visibility(konst);\n+        let ast_id = self.source_ast_id_map.ast_id(konst);\n+        let res = Const { name, visibility, type_ref, ast_id };\n+        id(self.data().consts.alloc(res))\n+    }\n+\n+    fn lower_module(&mut self, module: &ast::Module) -> Option<FileItemTreeId<Mod>> {\n+        let name = module.name()?.as_name();\n+        let visibility = self.lower_visibility(module);\n+        let kind = if module.semicolon_token().is_some() {\n+            ModKind::Outline\n+        } else {\n+            ModKind::Inline {\n+                items: module\n+                    .item_list()\n+                    .map(|list| list.items().flat_map(|item| self.lower_mod_item(&item)).collect())\n+                    .unwrap_or_else(|| {\n+                        cov_mark::hit!(name_res_works_for_broken_modules);\n+                        Box::new([]) as Box<[_]>\n+                    }),\n+            }\n+        };\n+        let ast_id = self.source_ast_id_map.ast_id(module);\n+        let res = Mod { name, visibility, kind, ast_id };\n+        Some(id(self.data().mods.alloc(res)))\n+    }\n+\n+    fn lower_trait(&mut self, trait_def: &ast::Trait) -> Option<FileItemTreeId<Trait>> {\n+        let name = trait_def.name()?.as_name();\n+        let visibility = self.lower_visibility(trait_def);\n+        let generic_params = self.lower_generic_params(GenericsOwner::Trait(trait_def), trait_def);\n+        let is_auto = trait_def.auto_token().is_some();\n+        let is_unsafe = trait_def.unsafe_token().is_some();\n+        let items = trait_def.assoc_item_list().map(|list| {\n+            list.assoc_items()\n+                .filter_map(|item| {\n+                    let attrs = RawAttrs::new(self.db, &item, self.hygiene());\n+                    self.lower_assoc_item(&item).map(|item| {\n+                        self.add_attrs(ModItem::from(item).into(), attrs);\n+                        item\n+                    })\n+                })\n+                .collect()\n+        });\n+        let ast_id = self.source_ast_id_map.ast_id(trait_def);\n+        let res = Trait {\n+            name,\n+            visibility,\n+            generic_params,\n+            is_auto,\n+            is_unsafe,\n+            items: items.unwrap_or_default(),\n+            ast_id,\n+        };\n+        Some(id(self.data().traits.alloc(res)))\n+    }\n+\n+    fn lower_impl(&mut self, impl_def: &ast::Impl) -> Option<FileItemTreeId<Impl>> {\n+        let generic_params = self.lower_generic_params(GenericsOwner::Impl, impl_def);\n+        // FIXME: If trait lowering fails, due to a non PathType for example, we treat this impl\n+        // as if it was an non-trait impl. Ideally we want to create a unique missing ref that only\n+        // equals itself.\n+        let target_trait = impl_def.trait_().and_then(|tr| self.lower_trait_ref(&tr));\n+        let self_ty = self.lower_type_ref(&impl_def.self_ty()?);\n+        let is_negative = impl_def.excl_token().is_some();\n+\n+        // We cannot use `assoc_items()` here as that does not include macro calls.\n+        let items = impl_def\n+            .assoc_item_list()\n+            .into_iter()\n+            .flat_map(|it| it.assoc_items())\n+            .filter_map(|item| {\n+                let assoc = self.lower_assoc_item(&item)?;\n+                let attrs = RawAttrs::new(self.db, &item, self.hygiene());\n+                self.add_attrs(ModItem::from(assoc).into(), attrs);\n+                Some(assoc)\n+            })\n+            .collect();\n+        let ast_id = self.source_ast_id_map.ast_id(impl_def);\n+        let res = Impl { generic_params, target_trait, self_ty, is_negative, items, ast_id };\n+        Some(id(self.data().impls.alloc(res)))\n+    }\n+\n+    fn lower_use(&mut self, use_item: &ast::Use) -> Option<FileItemTreeId<Import>> {\n+        let visibility = self.lower_visibility(use_item);\n+        let ast_id = self.source_ast_id_map.ast_id(use_item);\n+        let (use_tree, _) = lower_use_tree(self.db, self.hygiene(), use_item.use_tree()?)?;\n+\n+        let res = Import { visibility, ast_id, use_tree };\n+        Some(id(self.data().imports.alloc(res)))\n+    }\n+\n+    fn lower_extern_crate(\n+        &mut self,\n+        extern_crate: &ast::ExternCrate,\n+    ) -> Option<FileItemTreeId<ExternCrate>> {\n+        let name = extern_crate.name_ref()?.as_name();\n+        let alias = extern_crate.rename().map(|a| {\n+            a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n+        });\n+        let visibility = self.lower_visibility(extern_crate);\n+        let ast_id = self.source_ast_id_map.ast_id(extern_crate);\n+\n+        let res = ExternCrate { name, alias, visibility, ast_id };\n+        Some(id(self.data().extern_crates.alloc(res)))\n+    }\n+\n+    fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<FileItemTreeId<MacroCall>> {\n+        let path = Interned::new(ModPath::from_src(self.db.upcast(), m.path()?, self.hygiene())?);\n+        let ast_id = self.source_ast_id_map.ast_id(m);\n+        let expand_to = hir_expand::ExpandTo::from_call_site(m);\n+        let res = MacroCall { path, ast_id, expand_to };\n+        Some(id(self.data().macro_calls.alloc(res)))\n+    }\n+\n+    fn lower_macro_rules(&mut self, m: &ast::MacroRules) -> Option<FileItemTreeId<MacroRules>> {\n+        let name = m.name().map(|it| it.as_name())?;\n+        let ast_id = self.source_ast_id_map.ast_id(m);\n+\n+        let res = MacroRules { name, ast_id };\n+        Some(id(self.data().macro_rules.alloc(res)))\n+    }\n+\n+    fn lower_macro_def(&mut self, m: &ast::MacroDef) -> Option<FileItemTreeId<MacroDef>> {\n+        let name = m.name().map(|it| it.as_name())?;\n+\n+        let ast_id = self.source_ast_id_map.ast_id(m);\n+        let visibility = self.lower_visibility(m);\n+\n+        let res = MacroDef { name, ast_id, visibility };\n+        Some(id(self.data().macro_defs.alloc(res)))\n+    }\n+\n+    fn lower_extern_block(&mut self, block: &ast::ExternBlock) -> FileItemTreeId<ExternBlock> {\n+        let ast_id = self.source_ast_id_map.ast_id(block);\n+        let abi = block.abi().map(lower_abi);\n+        let children: Box<[_]> = block.extern_item_list().map_or(Box::new([]), |list| {\n+            list.extern_items()\n+                .filter_map(|item| {\n+                    // Note: All items in an `extern` block need to be lowered as if they're outside of one\n+                    // (in other words, the knowledge that they're in an extern block must not be used).\n+                    // This is because an extern block can contain macros whose ItemTree's top-level items\n+                    // should be considered to be in an extern block too.\n+                    let attrs = RawAttrs::new(self.db, &item, self.hygiene());\n+                    let id: ModItem = match item {\n+                        ast::ExternItem::Fn(ast) => self.lower_function(&ast)?.into(),\n+                        ast::ExternItem::Static(ast) => self.lower_static(&ast)?.into(),\n+                        ast::ExternItem::TypeAlias(ty) => self.lower_type_alias(&ty)?.into(),\n+                        ast::ExternItem::MacroCall(call) => self.lower_macro_call(&call)?.into(),\n+                    };\n+                    self.add_attrs(id.into(), attrs);\n+                    Some(id)\n+                })\n+                .collect()\n+        });\n+\n+        let res = ExternBlock { abi, ast_id, children };\n+        id(self.data().extern_blocks.alloc(res))\n+    }\n+\n+    fn lower_generic_params(\n+        &mut self,\n+        owner: GenericsOwner<'_>,\n+        node: &dyn ast::HasGenericParams,\n+    ) -> Interned<GenericParams> {\n+        let mut generics = GenericParams::default();\n+        match owner {\n+            GenericsOwner::Function(_)\n+            | GenericsOwner::Struct\n+            | GenericsOwner::Enum\n+            | GenericsOwner::Union\n+            | GenericsOwner::TypeAlias => {\n+                generics.fill(&self.body_ctx, node);\n+            }\n+            GenericsOwner::Trait(trait_def) => {\n+                // traits get the Self type as an implicit first type parameter\n+                generics.type_or_consts.alloc(\n+                    TypeParamData {\n+                        name: Some(name![Self]),\n+                        default: None,\n+                        provenance: TypeParamProvenance::TraitSelf,\n+                    }\n+                    .into(),\n+                );\n+                // add super traits as bounds on Self\n+                // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n+                let self_param = TypeRef::Path(name![Self].into());\n+                generics.fill_bounds(&self.body_ctx, trait_def, Either::Left(self_param));\n+                generics.fill(&self.body_ctx, node);\n+            }\n+            GenericsOwner::Impl => {\n+                // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n+                // type-parameter, but rather is a type-alias for impl's target\n+                // type, so this is handled by the resolver.\n+                generics.fill(&self.body_ctx, node);\n+            }\n+        }\n+\n+        generics.shrink_to_fit();\n+        Interned::new(generics)\n+    }\n+\n+    fn lower_type_bounds(&mut self, node: &dyn ast::HasTypeBounds) -> Vec<Interned<TypeBound>> {\n+        match node.type_bound_list() {\n+            Some(bound_list) => bound_list\n+                .bounds()\n+                .map(|it| Interned::new(TypeBound::from_ast(&self.body_ctx, it)))\n+                .collect(),\n+            None => Vec::new(),\n+        }\n+    }\n+\n+    fn lower_visibility(&mut self, item: &dyn ast::HasVisibility) -> RawVisibilityId {\n+        let vis = RawVisibility::from_ast_with_hygiene(self.db, item.visibility(), self.hygiene());\n+        self.data().vis.alloc(vis)\n+    }\n+\n+    fn lower_trait_ref(&mut self, trait_ref: &ast::Type) -> Option<Interned<TraitRef>> {\n+        let trait_ref = TraitRef::from_ast(&self.body_ctx, trait_ref.clone())?;\n+        Some(Interned::new(trait_ref))\n+    }\n+\n+    fn lower_type_ref(&mut self, type_ref: &ast::Type) -> Interned<TypeRef> {\n+        let tyref = TypeRef::from_ast(&self.body_ctx, type_ref.clone());\n+        Interned::new(tyref)\n+    }\n+\n+    fn lower_type_ref_opt(&mut self, type_ref: Option<ast::Type>) -> Interned<TypeRef> {\n+        match type_ref.map(|ty| self.lower_type_ref(&ty)) {\n+            Some(it) => it,\n+            None => Interned::new(TypeRef::Error),\n+        }\n+    }\n+\n+    fn next_field_idx(&self) -> Idx<Field> {\n+        Idx::from_raw(RawIdx::from(\n+            self.tree.data.as_ref().map_or(0, |data| data.fields.len() as u32),\n+        ))\n+    }\n+    fn next_variant_idx(&self) -> Idx<Variant> {\n+        Idx::from_raw(RawIdx::from(\n+            self.tree.data.as_ref().map_or(0, |data| data.variants.len() as u32),\n+        ))\n+    }\n+    fn next_param_idx(&self) -> Idx<Param> {\n+        Idx::from_raw(RawIdx::from(\n+            self.tree.data.as_ref().map_or(0, |data| data.params.len() as u32),\n+        ))\n+    }\n+}\n+\n+fn desugar_future_path(orig: TypeRef) -> Path {\n+    let path = path![core::future::Future];\n+    let mut generic_args: Vec<_> =\n+        std::iter::repeat(None).take(path.segments().len() - 1).collect();\n+    let mut last = GenericArgs::empty();\n+    let binding =\n+        AssociatedTypeBinding { name: name![Output], type_ref: Some(orig), bounds: Vec::new() };\n+    last.bindings.push(binding);\n+    generic_args.push(Some(Interned::new(last)));\n+\n+    Path::from_known_path(path, generic_args)\n+}\n+\n+enum GenericsOwner<'a> {\n+    /// We need access to the partially-lowered `Function` for lowering `impl Trait` in argument\n+    /// position.\n+    Function(&'a Function),\n+    Struct,\n+    Enum,\n+    Union,\n+    /// The `TraitDef` is needed to fill the source map for the implicit `Self` parameter.\n+    Trait(&'a ast::Trait),\n+    TypeAlias,\n+    Impl,\n+}\n+\n+fn lower_abi(abi: ast::Abi) -> Interned<str> {\n+    // FIXME: Abi::abi() -> Option<SyntaxToken>?\n+    match abi.syntax().last_token() {\n+        Some(tok) if tok.kind() == SyntaxKind::STRING => {\n+            // FIXME: Better way to unescape?\n+            Interned::new_str(tok.text().trim_matches('\"'))\n+        }\n+        _ => {\n+            // `extern` default to be `extern \"C\"`.\n+            Interned::new_str(\"C\")\n+        }\n+    }\n+}\n+\n+struct UseTreeLowering<'a> {\n+    db: &'a dyn DefDatabase,\n+    hygiene: &'a Hygiene,\n+    mapping: Arena<ast::UseTree>,\n+}\n+\n+impl UseTreeLowering<'_> {\n+    fn lower_use_tree(&mut self, tree: ast::UseTree) -> Option<UseTree> {\n+        if let Some(use_tree_list) = tree.use_tree_list() {\n+            let prefix = match tree.path() {\n+                // E.g. use something::{{{inner}}};\n+                None => None,\n+                // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n+                // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n+                Some(path) => {\n+                    match ModPath::from_src(self.db.upcast(), path, self.hygiene) {\n+                        Some(it) => Some(it),\n+                        None => return None, // FIXME: report errors somewhere\n+                    }\n+                }\n+            };\n+\n+            let list =\n+                use_tree_list.use_trees().filter_map(|tree| self.lower_use_tree(tree)).collect();\n+\n+            Some(\n+                self.use_tree(\n+                    UseTreeKind::Prefixed { prefix: prefix.map(Interned::new), list },\n+                    tree,\n+                ),\n+            )\n+        } else {\n+            let is_glob = tree.star_token().is_some();\n+            let path = match tree.path() {\n+                Some(path) => Some(ModPath::from_src(self.db.upcast(), path, self.hygiene)?),\n+                None => None,\n+            };\n+            let alias = tree.rename().map(|a| {\n+                a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n+            });\n+            if alias.is_some() && is_glob {\n+                return None;\n+            }\n+\n+            match (path, alias, is_glob) {\n+                (path, None, true) => {\n+                    if path.is_none() {\n+                        cov_mark::hit!(glob_enum_group);\n+                    }\n+                    Some(self.use_tree(UseTreeKind::Glob { path: path.map(Interned::new) }, tree))\n+                }\n+                // Globs can't be renamed\n+                (_, Some(_), true) | (None, None, false) => None,\n+                // `bla::{ as Name}` is invalid\n+                (None, Some(_), false) => None,\n+                (Some(path), alias, false) => Some(\n+                    self.use_tree(UseTreeKind::Single { path: Interned::new(path), alias }, tree),\n+                ),\n+            }\n+        }\n+    }\n+\n+    fn use_tree(&mut self, kind: UseTreeKind, ast: ast::UseTree) -> UseTree {\n+        let index = self.mapping.alloc(ast);\n+        UseTree { index, kind }\n+    }\n+}\n+\n+pub(super) fn lower_use_tree(\n+    db: &dyn DefDatabase,\n+    hygiene: &Hygiene,\n+    tree: ast::UseTree,\n+) -> Option<(UseTree, Arena<ast::UseTree>)> {\n+    let mut lowering = UseTreeLowering { db, hygiene, mapping: Arena::new() };\n+    let tree = lowering.lower_use_tree(tree)?;\n+    Some((tree, lowering.mapping))\n+}"}, {"sha": "f12d9a1273cc16bba0c6e67c3e0cbcbbeafb4bd9", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/pretty.rs", "status": "added", "additions": 754, "deletions": 0, "changes": 754, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,754 @@\n+//! `ItemTree` debug printer.\n+\n+use std::fmt::{self, Write};\n+\n+use itertools::Itertools;\n+\n+use crate::{\n+    attr::RawAttrs,\n+    generics::{TypeOrConstParamData, WherePredicate, WherePredicateTypeTarget},\n+    path::GenericArg,\n+    type_ref::TraitBoundModifier,\n+    visibility::RawVisibility,\n+};\n+\n+use super::*;\n+\n+pub(super) fn print_item_tree(tree: &ItemTree) -> String {\n+    let mut p = Printer { tree, buf: String::new(), indent_level: 0, needs_indent: true };\n+\n+    if let Some(attrs) = tree.attrs.get(&AttrOwner::TopLevel) {\n+        p.print_attrs(attrs, true);\n+    }\n+    p.blank();\n+\n+    for item in tree.top_level_items() {\n+        p.print_mod_item(*item);\n+    }\n+\n+    let mut s = p.buf.trim_end_matches('\\n').to_string();\n+    s.push('\\n');\n+    s\n+}\n+\n+macro_rules! w {\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = write!($dst, $($arg)*); }\n+    };\n+}\n+\n+macro_rules! wln {\n+    ($dst:expr) => {\n+        { let _ = writeln!($dst); }\n+    };\n+    ($dst:expr, $($arg:tt)*) => {\n+        { let _ = writeln!($dst, $($arg)*); }\n+    };\n+}\n+\n+struct Printer<'a> {\n+    tree: &'a ItemTree,\n+    buf: String,\n+    indent_level: usize,\n+    needs_indent: bool,\n+}\n+\n+impl<'a> Printer<'a> {\n+    fn indented(&mut self, f: impl FnOnce(&mut Self)) {\n+        self.indent_level += 1;\n+        wln!(self);\n+        f(self);\n+        self.indent_level -= 1;\n+        self.buf = self.buf.trim_end_matches('\\n').to_string();\n+    }\n+\n+    /// Ensures that a blank line is output before the next text.\n+    fn blank(&mut self) {\n+        let mut iter = self.buf.chars().rev().fuse();\n+        match (iter.next(), iter.next()) {\n+            (Some('\\n'), Some('\\n') | None) | (None, None) => {}\n+            (Some('\\n'), Some(_)) => {\n+                self.buf.push('\\n');\n+            }\n+            (Some(_), _) => {\n+                self.buf.push('\\n');\n+                self.buf.push('\\n');\n+            }\n+            (None, Some(_)) => unreachable!(),\n+        }\n+    }\n+\n+    fn whitespace(&mut self) {\n+        match self.buf.chars().next_back() {\n+            None | Some('\\n' | ' ') => {}\n+            _ => self.buf.push(' '),\n+        }\n+    }\n+\n+    fn print_attrs(&mut self, attrs: &RawAttrs, inner: bool) {\n+        let inner = if inner { \"!\" } else { \"\" };\n+        for attr in &**attrs {\n+            wln!(\n+                self,\n+                \"#{}[{}{}]\",\n+                inner,\n+                attr.path,\n+                attr.input.as_ref().map(|it| it.to_string()).unwrap_or_default(),\n+            );\n+        }\n+    }\n+\n+    fn print_attrs_of(&mut self, of: impl Into<AttrOwner>) {\n+        if let Some(attrs) = self.tree.attrs.get(&of.into()) {\n+            self.print_attrs(attrs, false);\n+        }\n+    }\n+\n+    fn print_visibility(&mut self, vis: RawVisibilityId) {\n+        match &self.tree[vis] {\n+            RawVisibility::Module(path) => w!(self, \"pub({}) \", path),\n+            RawVisibility::Public => w!(self, \"pub \"),\n+        };\n+    }\n+\n+    fn print_fields(&mut self, fields: &Fields) {\n+        match fields {\n+            Fields::Record(fields) => {\n+                self.whitespace();\n+                w!(self, \"{{\");\n+                self.indented(|this| {\n+                    for field in fields.clone() {\n+                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        this.print_attrs_of(field);\n+                        this.print_visibility(*visibility);\n+                        w!(this, \"{}: \", name);\n+                        this.print_type_ref(type_ref);\n+                        wln!(this, \",\");\n+                    }\n+                });\n+                w!(self, \"}}\");\n+            }\n+            Fields::Tuple(fields) => {\n+                w!(self, \"(\");\n+                self.indented(|this| {\n+                    for field in fields.clone() {\n+                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        this.print_attrs_of(field);\n+                        this.print_visibility(*visibility);\n+                        w!(this, \"{}: \", name);\n+                        this.print_type_ref(type_ref);\n+                        wln!(this, \",\");\n+                    }\n+                });\n+                w!(self, \")\");\n+            }\n+            Fields::Unit => {}\n+        }\n+    }\n+\n+    fn print_fields_and_where_clause(&mut self, fields: &Fields, params: &GenericParams) {\n+        match fields {\n+            Fields::Record(_) => {\n+                if self.print_where_clause(params) {\n+                    wln!(self);\n+                }\n+                self.print_fields(fields);\n+            }\n+            Fields::Unit => {\n+                self.print_where_clause(params);\n+                self.print_fields(fields);\n+            }\n+            Fields::Tuple(_) => {\n+                self.print_fields(fields);\n+                self.print_where_clause(params);\n+            }\n+        }\n+    }\n+\n+    fn print_use_tree(&mut self, use_tree: &UseTree) {\n+        match &use_tree.kind {\n+            UseTreeKind::Single { path, alias } => {\n+                w!(self, \"{}\", path);\n+                if let Some(alias) = alias {\n+                    w!(self, \" as {}\", alias);\n+                }\n+            }\n+            UseTreeKind::Glob { path } => {\n+                if let Some(path) = path {\n+                    w!(self, \"{}::\", path);\n+                }\n+                w!(self, \"*\");\n+            }\n+            UseTreeKind::Prefixed { prefix, list } => {\n+                if let Some(prefix) = prefix {\n+                    w!(self, \"{}::\", prefix);\n+                }\n+                w!(self, \"{{\");\n+                for (i, tree) in list.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    self.print_use_tree(tree);\n+                }\n+                w!(self, \"}}\");\n+            }\n+        }\n+    }\n+\n+    fn print_mod_item(&mut self, item: ModItem) {\n+        self.print_attrs_of(item);\n+\n+        match item {\n+            ModItem::Import(it) => {\n+                let Import { visibility, use_tree, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"use \");\n+                self.print_use_tree(use_tree);\n+                wln!(self, \";\");\n+            }\n+            ModItem::ExternCrate(it) => {\n+                let ExternCrate { name, alias, visibility, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"extern crate {}\", name);\n+                if let Some(alias) = alias {\n+                    w!(self, \" as {}\", alias);\n+                }\n+                wln!(self, \";\");\n+            }\n+            ModItem::ExternBlock(it) => {\n+                let ExternBlock { abi, ast_id: _, children } = &self.tree[it];\n+                w!(self, \"extern \");\n+                if let Some(abi) = abi {\n+                    w!(self, \"\\\"{}\\\" \", abi);\n+                }\n+                w!(self, \"{{\");\n+                self.indented(|this| {\n+                    for child in &**children {\n+                        this.print_mod_item(*child);\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            ModItem::Function(it) => {\n+                let Function {\n+                    name,\n+                    visibility,\n+                    explicit_generic_params,\n+                    abi,\n+                    params,\n+                    ret_type,\n+                    async_ret_type: _,\n+                    ast_id: _,\n+                    flags,\n+                } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                if flags.contains(FnFlags::HAS_DEFAULT_KW) {\n+                    w!(self, \"default \");\n+                }\n+                if flags.contains(FnFlags::HAS_CONST_KW) {\n+                    w!(self, \"const \");\n+                }\n+                if flags.contains(FnFlags::HAS_ASYNC_KW) {\n+                    w!(self, \"async \");\n+                }\n+                if flags.contains(FnFlags::HAS_UNSAFE_KW) {\n+                    w!(self, \"unsafe \");\n+                }\n+                if let Some(abi) = abi {\n+                    w!(self, \"extern \\\"{}\\\" \", abi);\n+                }\n+                w!(self, \"fn {}\", name);\n+                self.print_generic_params(explicit_generic_params);\n+                w!(self, \"(\");\n+                if !params.is_empty() {\n+                    self.indented(|this| {\n+                        for (i, param) in params.clone().enumerate() {\n+                            this.print_attrs_of(param);\n+                            match &this.tree[param] {\n+                                Param::Normal(name, ty) => {\n+                                    match name {\n+                                        Some(name) => w!(this, \"{}: \", name),\n+                                        None => w!(this, \"_: \"),\n+                                    }\n+                                    this.print_type_ref(ty);\n+                                    w!(this, \",\");\n+                                    if flags.contains(FnFlags::HAS_SELF_PARAM) && i == 0 {\n+                                        wln!(this, \"  // self\");\n+                                    } else {\n+                                        wln!(this);\n+                                    }\n+                                }\n+                                Param::Varargs => {\n+                                    wln!(this, \"...\");\n+                                }\n+                            };\n+                        }\n+                    });\n+                }\n+                w!(self, \") -> \");\n+                self.print_type_ref(ret_type);\n+                self.print_where_clause(explicit_generic_params);\n+                if flags.contains(FnFlags::HAS_BODY) {\n+                    wln!(self, \" {{ ... }}\");\n+                } else {\n+                    wln!(self, \";\");\n+                }\n+            }\n+            ModItem::Struct(it) => {\n+                let Struct { visibility, name, fields, generic_params, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"struct {}\", name);\n+                self.print_generic_params(generic_params);\n+                self.print_fields_and_where_clause(fields, generic_params);\n+                if matches!(fields, Fields::Record(_)) {\n+                    wln!(self);\n+                } else {\n+                    wln!(self, \";\");\n+                }\n+            }\n+            ModItem::Union(it) => {\n+                let Union { name, visibility, fields, generic_params, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"union {}\", name);\n+                self.print_generic_params(generic_params);\n+                self.print_fields_and_where_clause(fields, generic_params);\n+                if matches!(fields, Fields::Record(_)) {\n+                    wln!(self);\n+                } else {\n+                    wln!(self, \";\");\n+                }\n+            }\n+            ModItem::Enum(it) => {\n+                let Enum { name, visibility, variants, generic_params, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"enum {}\", name);\n+                self.print_generic_params(generic_params);\n+                self.print_where_clause_and_opening_brace(generic_params);\n+                self.indented(|this| {\n+                    for variant in variants.clone() {\n+                        let Variant { name, fields } = &this.tree[variant];\n+                        this.print_attrs_of(variant);\n+                        w!(this, \"{}\", name);\n+                        this.print_fields(fields);\n+                        wln!(this, \",\");\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            ModItem::Const(it) => {\n+                let Const { name, visibility, type_ref, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"const \");\n+                match name {\n+                    Some(name) => w!(self, \"{}\", name),\n+                    None => w!(self, \"_\"),\n+                }\n+                w!(self, \": \");\n+                self.print_type_ref(type_ref);\n+                wln!(self, \" = _;\");\n+            }\n+            ModItem::Static(it) => {\n+                let Static { name, visibility, mutable, type_ref, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"static \");\n+                if *mutable {\n+                    w!(self, \"mut \");\n+                }\n+                w!(self, \"{}: \", name);\n+                self.print_type_ref(type_ref);\n+                w!(self, \" = _;\");\n+                wln!(self);\n+            }\n+            ModItem::Trait(it) => {\n+                let Trait {\n+                    name,\n+                    visibility,\n+                    is_auto,\n+                    is_unsafe,\n+                    items,\n+                    generic_params,\n+                    ast_id: _,\n+                } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                if *is_unsafe {\n+                    w!(self, \"unsafe \");\n+                }\n+                if *is_auto {\n+                    w!(self, \"auto \");\n+                }\n+                w!(self, \"trait {}\", name);\n+                self.print_generic_params(generic_params);\n+                self.print_where_clause_and_opening_brace(generic_params);\n+                self.indented(|this| {\n+                    for item in &**items {\n+                        this.print_mod_item((*item).into());\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            ModItem::Impl(it) => {\n+                let Impl { target_trait, self_ty, is_negative, items, generic_params, ast_id: _ } =\n+                    &self.tree[it];\n+                w!(self, \"impl\");\n+                self.print_generic_params(generic_params);\n+                w!(self, \" \");\n+                if *is_negative {\n+                    w!(self, \"!\");\n+                }\n+                if let Some(tr) = target_trait {\n+                    self.print_path(&tr.path);\n+                    w!(self, \" for \");\n+                }\n+                self.print_type_ref(self_ty);\n+                self.print_where_clause_and_opening_brace(generic_params);\n+                self.indented(|this| {\n+                    for item in &**items {\n+                        this.print_mod_item((*item).into());\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            ModItem::TypeAlias(it) => {\n+                let TypeAlias { name, visibility, bounds, type_ref, generic_params, ast_id: _ } =\n+                    &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"type {}\", name);\n+                self.print_generic_params(generic_params);\n+                if !bounds.is_empty() {\n+                    w!(self, \": \");\n+                    self.print_type_bounds(bounds);\n+                }\n+                if let Some(ty) = type_ref {\n+                    w!(self, \" = \");\n+                    self.print_type_ref(ty);\n+                }\n+                self.print_where_clause(generic_params);\n+                w!(self, \";\");\n+                wln!(self);\n+            }\n+            ModItem::Mod(it) => {\n+                let Mod { name, visibility, kind, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"mod {}\", name);\n+                match kind {\n+                    ModKind::Inline { items } => {\n+                        w!(self, \" {{\");\n+                        self.indented(|this| {\n+                            for item in &**items {\n+                                this.print_mod_item(*item);\n+                            }\n+                        });\n+                        wln!(self, \"}}\");\n+                    }\n+                    ModKind::Outline => {\n+                        wln!(self, \";\");\n+                    }\n+                }\n+            }\n+            ModItem::MacroCall(it) => {\n+                let MacroCall { path, ast_id: _, expand_to: _ } = &self.tree[it];\n+                wln!(self, \"{}!(...);\", path);\n+            }\n+            ModItem::MacroRules(it) => {\n+                let MacroRules { name, ast_id: _ } = &self.tree[it];\n+                wln!(self, \"macro_rules! {} {{ ... }}\", name);\n+            }\n+            ModItem::MacroDef(it) => {\n+                let MacroDef { name, visibility, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                wln!(self, \"macro {} {{ ... }}\", name);\n+            }\n+        }\n+\n+        self.blank();\n+    }\n+\n+    fn print_type_ref(&mut self, type_ref: &TypeRef) {\n+        // FIXME: deduplicate with `HirDisplay` impl\n+        match type_ref {\n+            TypeRef::Never => w!(self, \"!\"),\n+            TypeRef::Placeholder => w!(self, \"_\"),\n+            TypeRef::Tuple(fields) => {\n+                w!(self, \"(\");\n+                for (i, field) in fields.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    self.print_type_ref(field);\n+                }\n+                w!(self, \")\");\n+            }\n+            TypeRef::Path(path) => self.print_path(path),\n+            TypeRef::RawPtr(pointee, mtbl) => {\n+                let mtbl = match mtbl {\n+                    Mutability::Shared => \"*const\",\n+                    Mutability::Mut => \"*mut\",\n+                };\n+                w!(self, \"{} \", mtbl);\n+                self.print_type_ref(pointee);\n+            }\n+            TypeRef::Reference(pointee, lt, mtbl) => {\n+                let mtbl = match mtbl {\n+                    Mutability::Shared => \"\",\n+                    Mutability::Mut => \"mut \",\n+                };\n+                w!(self, \"&\");\n+                if let Some(lt) = lt {\n+                    w!(self, \"{} \", lt.name);\n+                }\n+                w!(self, \"{}\", mtbl);\n+                self.print_type_ref(pointee);\n+            }\n+            TypeRef::Array(elem, len) => {\n+                w!(self, \"[\");\n+                self.print_type_ref(elem);\n+                w!(self, \"; {}]\", len);\n+            }\n+            TypeRef::Slice(elem) => {\n+                w!(self, \"[\");\n+                self.print_type_ref(elem);\n+                w!(self, \"]\");\n+            }\n+            TypeRef::Fn(args_and_ret, varargs) => {\n+                let ((_, return_type), args) =\n+                    args_and_ret.split_last().expect(\"TypeRef::Fn is missing return type\");\n+                w!(self, \"fn(\");\n+                for (i, (_, typeref)) in args.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    self.print_type_ref(typeref);\n+                }\n+                if *varargs {\n+                    if !args.is_empty() {\n+                        w!(self, \", \");\n+                    }\n+                    w!(self, \"...\");\n+                }\n+                w!(self, \") -> \");\n+                self.print_type_ref(return_type);\n+            }\n+            TypeRef::Macro(_ast_id) => {\n+                w!(self, \"<macro>\");\n+            }\n+            TypeRef::Error => w!(self, \"{{unknown}}\"),\n+            TypeRef::ImplTrait(bounds) => {\n+                w!(self, \"impl \");\n+                self.print_type_bounds(bounds);\n+            }\n+            TypeRef::DynTrait(bounds) => {\n+                w!(self, \"dyn \");\n+                self.print_type_bounds(bounds);\n+            }\n+        }\n+    }\n+\n+    fn print_type_bounds(&mut self, bounds: &[Interned<TypeBound>]) {\n+        for (i, bound) in bounds.iter().enumerate() {\n+            if i != 0 {\n+                w!(self, \" + \");\n+            }\n+\n+            match bound.as_ref() {\n+                TypeBound::Path(path, modifier) => {\n+                    match modifier {\n+                        TraitBoundModifier::None => (),\n+                        TraitBoundModifier::Maybe => w!(self, \"?\"),\n+                    }\n+                    self.print_path(path)\n+                }\n+                TypeBound::ForLifetime(lifetimes, path) => {\n+                    w!(self, \"for<{}> \", lifetimes.iter().format(\", \"));\n+                    self.print_path(path);\n+                }\n+                TypeBound::Lifetime(lt) => w!(self, \"{}\", lt.name),\n+                TypeBound::Error => w!(self, \"{{unknown}}\"),\n+            }\n+        }\n+    }\n+\n+    fn print_path(&mut self, path: &Path) {\n+        match path.type_anchor() {\n+            Some(anchor) => {\n+                w!(self, \"<\");\n+                self.print_type_ref(anchor);\n+                w!(self, \">::\");\n+            }\n+            None => match path.kind() {\n+                PathKind::Plain => {}\n+                PathKind::Super(0) => w!(self, \"self::\"),\n+                PathKind::Super(n) => {\n+                    for _ in 0..*n {\n+                        w!(self, \"super::\");\n+                    }\n+                }\n+                PathKind::Crate => w!(self, \"crate::\"),\n+                PathKind::Abs => w!(self, \"::\"),\n+                PathKind::DollarCrate(_) => w!(self, \"$crate::\"),\n+            },\n+        }\n+\n+        for (i, segment) in path.segments().iter().enumerate() {\n+            if i != 0 {\n+                w!(self, \"::\");\n+            }\n+\n+            w!(self, \"{}\", segment.name);\n+            if let Some(generics) = segment.args_and_bindings {\n+                // NB: these are all in type position, so `::<` turbofish syntax is not necessary\n+                w!(self, \"<\");\n+                let mut first = true;\n+                let args = if generics.has_self_type {\n+                    let (self_ty, args) = generics.args.split_first().unwrap();\n+                    w!(self, \"Self=\");\n+                    self.print_generic_arg(self_ty);\n+                    first = false;\n+                    args\n+                } else {\n+                    &generics.args\n+                };\n+                for arg in args {\n+                    if !first {\n+                        w!(self, \", \");\n+                    }\n+                    first = false;\n+                    self.print_generic_arg(arg);\n+                }\n+                for binding in &generics.bindings {\n+                    if !first {\n+                        w!(self, \", \");\n+                    }\n+                    first = false;\n+                    w!(self, \"{}\", binding.name);\n+                    if !binding.bounds.is_empty() {\n+                        w!(self, \": \");\n+                        self.print_type_bounds(&binding.bounds);\n+                    }\n+                    if let Some(ty) = &binding.type_ref {\n+                        w!(self, \" = \");\n+                        self.print_type_ref(ty);\n+                    }\n+                }\n+\n+                w!(self, \">\");\n+            }\n+        }\n+    }\n+\n+    fn print_generic_arg(&mut self, arg: &GenericArg) {\n+        match arg {\n+            GenericArg::Type(ty) => self.print_type_ref(ty),\n+            GenericArg::Const(c) => w!(self, \"{}\", c),\n+            GenericArg::Lifetime(lt) => w!(self, \"{}\", lt.name),\n+        }\n+    }\n+\n+    fn print_generic_params(&mut self, params: &GenericParams) {\n+        if params.type_or_consts.is_empty() && params.lifetimes.is_empty() {\n+            return;\n+        }\n+\n+        w!(self, \"<\");\n+        let mut first = true;\n+        for (_, lt) in params.lifetimes.iter() {\n+            if !first {\n+                w!(self, \", \");\n+            }\n+            first = false;\n+            w!(self, \"{}\", lt.name);\n+        }\n+        for (idx, x) in params.type_or_consts.iter() {\n+            if !first {\n+                w!(self, \", \");\n+            }\n+            first = false;\n+            match x {\n+                TypeOrConstParamData::TypeParamData(ty) => match &ty.name {\n+                    Some(name) => w!(self, \"{}\", name),\n+                    None => w!(self, \"_anon_{}\", idx.into_raw()),\n+                },\n+                TypeOrConstParamData::ConstParamData(konst) => {\n+                    w!(self, \"const {}: \", konst.name);\n+                    self.print_type_ref(&konst.ty);\n+                }\n+            }\n+        }\n+        w!(self, \">\");\n+    }\n+\n+    fn print_where_clause_and_opening_brace(&mut self, params: &GenericParams) {\n+        if self.print_where_clause(params) {\n+            w!(self, \"\\n{{\");\n+        } else {\n+            self.whitespace();\n+            w!(self, \"{{\");\n+        }\n+    }\n+\n+    fn print_where_clause(&mut self, params: &GenericParams) -> bool {\n+        if params.where_predicates.is_empty() {\n+            return false;\n+        }\n+\n+        w!(self, \"\\nwhere\");\n+        self.indented(|this| {\n+            for (i, pred) in params.where_predicates.iter().enumerate() {\n+                if i != 0 {\n+                    wln!(this, \",\");\n+                }\n+\n+                let (target, bound) = match pred {\n+                    WherePredicate::TypeBound { target, bound } => (target, bound),\n+                    WherePredicate::Lifetime { target, bound } => {\n+                        wln!(this, \"{}: {},\", target.name, bound.name);\n+                        continue;\n+                    }\n+                    WherePredicate::ForLifetime { lifetimes, target, bound } => {\n+                        w!(this, \"for<\");\n+                        for (i, lt) in lifetimes.iter().enumerate() {\n+                            if i != 0 {\n+                                w!(this, \", \");\n+                            }\n+                            w!(this, \"{}\", lt);\n+                        }\n+                        w!(this, \"> \");\n+                        (target, bound)\n+                    }\n+                };\n+\n+                match target {\n+                    WherePredicateTypeTarget::TypeRef(ty) => this.print_type_ref(ty),\n+                    WherePredicateTypeTarget::TypeOrConstParam(id) => {\n+                        match &params.type_or_consts[*id].name() {\n+                            Some(name) => w!(this, \"{}\", name),\n+                            None => w!(this, \"_anon_{}\", id.into_raw()),\n+                        }\n+                    }\n+                }\n+                w!(this, \": \");\n+                this.print_type_bounds(std::slice::from_ref(bound));\n+            }\n+        });\n+        true\n+    }\n+}\n+\n+impl<'a> Write for Printer<'a> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        for line in s.split_inclusive('\\n') {\n+            if self.needs_indent {\n+                match self.buf.chars().last() {\n+                    Some('\\n') | None => {}\n+                    _ => self.buf.push('\\n'),\n+                }\n+                self.buf.push_str(&\"    \".repeat(self.indent_level));\n+                self.needs_indent = false;\n+            }\n+\n+            self.buf.push_str(line);\n+            self.needs_indent = line.ends_with('\\n');\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "5cdf36cc61b83f2859b5149a8592b31fef9604da", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/tests.rs", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,360 @@\n+use base_db::fixture::WithFixture;\n+use expect_test::{expect, Expect};\n+\n+use crate::{db::DefDatabase, test_db::TestDB};\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    let item_tree = db.file_item_tree(file_id.into());\n+    let pretty = item_tree.pretty_print();\n+    expect.assert_eq(&pretty);\n+}\n+\n+#[test]\n+fn imports() {\n+    check(\n+        r#\"\n+//! file comment\n+#![no_std]\n+//! another file comment\n+\n+extern crate self as renamed;\n+pub(super) extern crate bli;\n+\n+pub use crate::path::{nested, items as renamed, Trait as _};\n+use globs::*;\n+\n+/// docs on import\n+use crate::{A, B};\n+\n+use a::{c, d::{e}};\n+        \"#,\n+        expect![[r##\"\n+            #![doc = \" file comment\"]\n+            #![no_std]\n+            #![doc = \" another file comment\"]\n+\n+            pub(self) extern crate self as renamed;\n+\n+            pub(super) extern crate bli;\n+\n+            pub use crate::path::{nested, items as renamed, Trait as _};\n+\n+            pub(self) use globs::*;\n+\n+            #[doc = \" docs on import\"]\n+            pub(self) use crate::{A, B};\n+\n+            pub(self) use a::{c, d::{e}};\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn extern_blocks() {\n+    check(\n+        r#\"\n+#[on_extern_block]\n+extern \"C\" {\n+    #[on_extern_type]\n+    type ExType;\n+\n+    #[on_extern_static]\n+    static EX_STATIC: u8;\n+\n+    #[on_extern_fn]\n+    fn ex_fn();\n+}\n+        \"#,\n+        expect![[r##\"\n+            #[on_extern_block]\n+            extern \"C\" {\n+                #[on_extern_type]\n+                pub(self) type ExType;\n+\n+                #[on_extern_static]\n+                pub(self) static EX_STATIC: u8 = _;\n+\n+                #[on_extern_fn]\n+                pub(self) fn ex_fn() -> ();\n+            }\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn adts() {\n+    check(\n+        r#\"\n+struct Unit;\n+\n+#[derive(Debug)]\n+struct Struct {\n+    /// fld docs\n+    fld: (),\n+}\n+\n+struct Tuple(#[attr] u8);\n+\n+union Ize {\n+    a: (),\n+    b: (),\n+}\n+\n+enum E {\n+    /// comment on Unit\n+    Unit,\n+    /// comment on Tuple\n+    Tuple(u8),\n+    Struct {\n+        /// comment on a: u8\n+        a: u8,\n+    }\n+}\n+        \"#,\n+        expect![[r##\"\n+            pub(self) struct Unit;\n+\n+            #[derive(Debug)]\n+            pub(self) struct Struct {\n+                #[doc = \" fld docs\"]\n+                pub(self) fld: (),\n+            }\n+\n+            pub(self) struct Tuple(\n+                #[attr]\n+                pub(self) 0: u8,\n+            );\n+\n+            pub(self) union Ize {\n+                pub(self) a: (),\n+                pub(self) b: (),\n+            }\n+\n+            pub(self) enum E {\n+                #[doc = \" comment on Unit\"]\n+                Unit,\n+                #[doc = \" comment on Tuple\"]\n+                Tuple(\n+                    pub(self) 0: u8,\n+                ),\n+                Struct {\n+                    #[doc = \" comment on a: u8\"]\n+                    pub(self) a: u8,\n+                },\n+            }\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn misc() {\n+    check(\n+        r#\"\n+pub static mut ST: () = ();\n+\n+const _: Anon = ();\n+\n+#[attr]\n+fn f(#[attr] arg: u8, _: ()) {\n+    #![inner_attr_in_fn]\n+}\n+\n+trait Tr: SuperTrait + 'lifetime {\n+    type Assoc: AssocBound = Default;\n+    fn method(&self);\n+}\n+        \"#,\n+        expect![[r##\"\n+            pub static mut ST: () = _;\n+\n+            pub(self) const _: Anon = _;\n+\n+            #[attr]\n+            #[inner_attr_in_fn]\n+            pub(self) fn f(\n+                #[attr]\n+                arg: u8,\n+                _: (),\n+            ) -> () { ... }\n+\n+            pub(self) trait Tr<Self>\n+            where\n+                Self: SuperTrait,\n+                Self: 'lifetime\n+            {\n+                pub(self) type Assoc: AssocBound = Default;\n+\n+                pub(self) fn method(\n+                    _: &Self,  // self\n+                ) -> ();\n+            }\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn modules() {\n+    check(\n+        r#\"\n+/// outer\n+mod inline {\n+    //! inner\n+\n+    use super::*;\n+\n+    fn fn_in_module() {}\n+}\n+\n+mod outline;\n+        \"#,\n+        expect![[r##\"\n+            #[doc = \" outer\"]\n+            #[doc = \" inner\"]\n+            pub(self) mod inline {\n+                pub(self) use super::*;\n+\n+                pub(self) fn fn_in_module() -> () { ... }\n+            }\n+\n+            pub(self) mod outline;\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn macros() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    () => {};\n+}\n+\n+pub macro m2() {}\n+\n+m!();\n+        \"#,\n+        expect![[r#\"\n+            macro_rules! m { ... }\n+\n+            pub macro m2 { ... }\n+\n+            m!(...);\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn mod_paths() {\n+    check(\n+        r#\"\n+struct S {\n+    a: self::Ty,\n+    b: super::SuperTy,\n+    c: super::super::SuperSuperTy,\n+    d: ::abs::Path,\n+    e: crate::Crate,\n+    f: plain::path::Ty,\n+}\n+        \"#,\n+        expect![[r#\"\n+            pub(self) struct S {\n+                pub(self) a: self::Ty,\n+                pub(self) b: super::SuperTy,\n+                pub(self) c: super::super::SuperSuperTy,\n+                pub(self) d: ::abs::Path,\n+                pub(self) e: crate::Crate,\n+                pub(self) f: plain::path::Ty,\n+            }\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn types() {\n+    check(\n+        r#\"\n+struct S {\n+    a: Mixed<'a, T, Item=(), OtherItem=u8>,\n+    b: <Fully as Qualified>::Syntax,\n+    c: <TypeAnchored>::Path::<'a>,\n+    d: dyn for<'a> Trait<'a>,\n+}\n+        \"#,\n+        expect![[r#\"\n+            pub(self) struct S {\n+                pub(self) a: Mixed<'a, T, Item = (), OtherItem = u8>,\n+                pub(self) b: Qualified<Self=Fully>::Syntax,\n+                pub(self) c: <TypeAnchored>::Path<'a>,\n+                pub(self) d: dyn for<'a> Trait<'a>,\n+            }\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn generics() {\n+    check(\n+        r#\"\n+struct S<'a, 'b: 'a, T: Copy + 'a + 'b, const K: u8 = 0> {\n+    field: &'a &'b T,\n+}\n+\n+struct Tuple<T: Copy, U: ?Sized>(T, U);\n+\n+impl<'a, 'b: 'a, T: Copy + 'a + 'b, const K: u8 = 0> S<'a, 'b, T, K> {\n+    fn f<G: 'a>(arg: impl Copy) -> impl Copy {}\n+}\n+\n+enum Enum<'a, T, const U: u8> {}\n+union Union<'a, T, const U: u8> {}\n+\n+trait Tr<'a, T: 'a>: Super where Self: for<'a> Tr<'a, T> {}\n+        \"#,\n+        expect![[r#\"\n+            pub(self) struct S<'a, 'b, T, const K: u8>\n+            where\n+                T: Copy,\n+                T: 'a,\n+                T: 'b\n+            {\n+                pub(self) field: &'a &'b T,\n+            }\n+\n+            pub(self) struct Tuple<T, U>(\n+                pub(self) 0: T,\n+                pub(self) 1: U,\n+            )\n+            where\n+                T: Copy,\n+                U: ?Sized;\n+\n+            impl<'a, 'b, T, const K: u8> S<'a, 'b, T, K>\n+            where\n+                T: Copy,\n+                T: 'a,\n+                T: 'b\n+            {\n+                pub(self) fn f<G>(\n+                    arg: impl Copy,\n+                ) -> impl Copy\n+                where\n+                    G: 'a { ... }\n+            }\n+\n+            pub(self) enum Enum<'a, T, const U: u8> {\n+            }\n+\n+            pub(self) union Union<'a, T, const U: u8> {\n+            }\n+\n+            pub(self) trait Tr<'a, Self, T>\n+            where\n+                Self: Super,\n+                T: 'a,\n+                Self: for<'a> Tr<'a, T>\n+            {\n+            }\n+        \"#]],\n+    )\n+}"}, {"sha": "c5cb9a2af53747feb22f6180d64906a4cc22cd56", "filename": "src/tools/rust-analyzer/crates/hir-def/src/keys.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fkeys.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,70 @@\n+//! keys to be used with `DynMap`\n+\n+use std::marker::PhantomData;\n+\n+use hir_expand::MacroCallId;\n+use rustc_hash::FxHashMap;\n+use syntax::{ast, AstNode, AstPtr};\n+\n+use crate::{\n+    attr::AttrId,\n+    dyn_map::{DynMap, Policy},\n+    ConstId, EnumId, EnumVariantId, FieldId, FunctionId, ImplId, LifetimeParamId, Macro2Id,\n+    MacroRulesId, ProcMacroId, StaticId, StructId, TraitId, TypeAliasId, TypeOrConstParamId,\n+    UnionId,\n+};\n+\n+pub type Key<K, V> = crate::dyn_map::Key<K, V, AstPtrPolicy<K, V>>;\n+\n+pub const FUNCTION: Key<ast::Fn, FunctionId> = Key::new();\n+pub const CONST: Key<ast::Const, ConstId> = Key::new();\n+pub const STATIC: Key<ast::Static, StaticId> = Key::new();\n+pub const TYPE_ALIAS: Key<ast::TypeAlias, TypeAliasId> = Key::new();\n+pub const IMPL: Key<ast::Impl, ImplId> = Key::new();\n+pub const TRAIT: Key<ast::Trait, TraitId> = Key::new();\n+pub const STRUCT: Key<ast::Struct, StructId> = Key::new();\n+pub const UNION: Key<ast::Union, UnionId> = Key::new();\n+pub const ENUM: Key<ast::Enum, EnumId> = Key::new();\n+\n+pub const VARIANT: Key<ast::Variant, EnumVariantId> = Key::new();\n+pub const TUPLE_FIELD: Key<ast::TupleField, FieldId> = Key::new();\n+pub const RECORD_FIELD: Key<ast::RecordField, FieldId> = Key::new();\n+pub const TYPE_PARAM: Key<ast::TypeParam, TypeOrConstParamId> = Key::new();\n+pub const CONST_PARAM: Key<ast::ConstParam, TypeOrConstParamId> = Key::new();\n+pub const LIFETIME_PARAM: Key<ast::LifetimeParam, LifetimeParamId> = Key::new();\n+\n+pub const MACRO_RULES: Key<ast::MacroRules, MacroRulesId> = Key::new();\n+pub const MACRO2: Key<ast::MacroDef, Macro2Id> = Key::new();\n+pub const PROC_MACRO: Key<ast::Fn, ProcMacroId> = Key::new();\n+pub const ATTR_MACRO_CALL: Key<ast::Item, MacroCallId> = Key::new();\n+pub const DERIVE_MACRO_CALL: Key<ast::Attr, (AttrId, MacroCallId, Box<[Option<MacroCallId>]>)> =\n+    Key::new();\n+\n+/// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n+/// equal if they point to exactly the same object.\n+///\n+/// In general, we do not guarantee that we have exactly one instance of a\n+/// syntax tree for each file. We probably should add such guarantee, but, for\n+/// the time being, we will use identity-less AstPtr comparison.\n+pub struct AstPtrPolicy<AST, ID> {\n+    _phantom: PhantomData<(AST, ID)>,\n+}\n+\n+impl<AST: AstNode + 'static, ID: 'static> Policy for AstPtrPolicy<AST, ID> {\n+    type K = AST;\n+    type V = ID;\n+    fn insert(map: &mut DynMap, key: AST, value: ID) {\n+        let key = AstPtr::new(&key);\n+        map.map\n+            .entry::<FxHashMap<AstPtr<AST>, ID>>()\n+            .or_insert_with(Default::default)\n+            .insert(key, value);\n+    }\n+    fn get<'a>(map: &'a DynMap, key: &AST) -> Option<&'a ID> {\n+        let key = AstPtr::new(key);\n+        map.map.get::<FxHashMap<AstPtr<AST>, ID>>()?.get(&key)\n+    }\n+    fn is_empty(map: &DynMap) -> bool {\n+        map.map.get::<FxHashMap<AstPtr<AST>, ID>>().map_or(true, |it| it.is_empty())\n+    }\n+}"}, {"sha": "8778501845876d5aaed04881da7d37eceea3a2ee", "filename": "src/tools/rust-analyzer/crates/hir-def/src/lang_item.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flang_item.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732", "patch": "@@ -0,0 +1,174 @@\n+//! Collects lang items: items marked with `#[lang = \"...\"]` attribute.\n+//!\n+//! This attribute to tell the compiler about semi built-in std library\n+//! features, such as Fn family of traits.\n+use std::sync::Arc;\n+\n+use rustc_hash::FxHashMap;\n+use syntax::SmolStr;\n+\n+use crate::{\n+    db::DefDatabase, AdtId, AttrDefId, CrateId, EnumId, EnumVariantId, FunctionId, ImplId,\n+    ModuleDefId, StaticId, StructId, TraitId,\n+};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum LangItemTarget {\n+    EnumId(EnumId),\n+    FunctionId(FunctionId),\n+    ImplDefId(ImplId),\n+    StaticId(StaticId),\n+    StructId(StructId),\n+    TraitId(TraitId),\n+    EnumVariantId(EnumVariantId),\n+}\n+\n+impl LangItemTarget {\n+    pub fn as_enum(self) -> Option<EnumId> {\n+        match self {\n+            LangItemTarget::EnumId(id) => Some(id),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_function(self) -> Option<FunctionId> {\n+        match self {\n+            LangItemTarget::FunctionId(id) => Some(id),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_impl_def(self) -> Option<ImplId> {\n+        match self {\n+            LangItemTarget::ImplDefId(id) => Some(id),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_static(self) -> Option<StaticId> {\n+        match self {\n+            LangItemTarget::StaticId(id) => Some(id),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_struct(self) -> Option<StructId> {\n+        match self {\n+            LangItemTarget::StructId(id) => Some(id),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_trait(self) -> Option<TraitId> {\n+        match self {\n+            LangItemTarget::TraitId(id) => Some(id),\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn as_enum_variant(self) -> Option<EnumVariantId> {\n+        match self {\n+            LangItemTarget::EnumVariantId(id) => Some(id),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[derive(Default, Debug, Clone, PartialEq, Eq)]\n+pub struct LangItems {\n+    items: FxHashMap<SmolStr, LangItemTarget>,\n+}\n+\n+impl LangItems {\n+    pub fn target(&self, item: &str) -> Option<LangItemTarget> {\n+        self.items.get(item).copied()\n+    }\n+\n+    /// Salsa query. This will look for lang items in a specific crate.\n+    pub(crate) fn crate_lang_items_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<LangItems> {\n+        let _p = profile::span(\"crate_lang_items_query\");\n+\n+        let mut lang_items = LangItems::default();\n+\n+        let crate_def_map = db.crate_def_map(krate);\n+\n+        for (_, module_data) in crate_def_map.modules() {\n+            for impl_def in module_data.scope.impls() {\n+                lang_items.collect_lang_item(db, impl_def, LangItemTarget::ImplDefId)\n+            }\n+\n+            for def in module_data.scope.declarations() {\n+                match def {\n+                    ModuleDefId::TraitId(trait_) => {\n+                        lang_items.collect_lang_item(db, trait_, LangItemTarget::TraitId);\n+                        db.trait_data(trait_).items.iter().for_each(|&(_, assoc_id)| {\n+                            if let crate::AssocItemId::FunctionId(f) = assoc_id {\n+                                lang_items.collect_lang_item(db, f, LangItemTarget::FunctionId);\n+                            }\n+                        });\n+                    }\n+                    ModuleDefId::AdtId(AdtId::EnumId(e)) => {\n+                        lang_items.collect_lang_item(db, e, LangItemTarget::EnumId);\n+                        db.enum_data(e).variants.iter().for_each(|(local_id, _)| {\n+                            lang_items.collect_lang_item(\n+                                db,\n+                                EnumVariantId { parent: e, local_id },\n+                                LangItemTarget::EnumVariantId,\n+                            );\n+                        });\n+                    }\n+                    ModuleDefId::AdtId(AdtId::StructId(s)) => {\n+                        lang_items.collect_lang_item(db, s, LangItemTarget::StructId);\n+                    }\n+                    ModuleDefId::FunctionId(f) => {\n+                        lang_items.collect_lang_item(db, f, LangItemTarget::FunctionId);\n+                    }\n+                    ModuleDefId::StaticId(s) => {\n+                        lang_items.collect_lang_item(db, s, LangItemTarget::StaticId);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+\n+        Arc::new(lang_items)\n+    }\n+\n+    /// Salsa query. Look for a lang item, starting from the specified crate and recursively\n+    /// traversing its dependencies.\n+    pub(crate) fn lang_item_query(\n+        db: &dyn DefDatabase,\n+        start_crate: CrateId,\n+        item: SmolStr,\n+    ) -> Option<LangItemTarget> {\n+        let _p = profile::span(\"lang_item_query\");\n+        let lang_items = db.crate_lang_items(start_crate);\n+        let start_crate_target = lang_items.items.get(&item);\n+        if let Some(&target) = start_crate_target {\n+            return Some(target);\n+        }\n+        db.crate_graph()[start_crate]\n+            .dependencies\n+            .iter()\n+            .find_map(|dep| db.lang_item(dep.crate_id, item.clone()))\n+    }\n+\n+    fn collect_lang_item<T>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        item: T,\n+        constructor: fn(T) -> LangItemTarget,\n+    ) where\n+        T: Into<AttrDefId> + Copy,\n+    {\n+        let _p = profile::span(\"collect_lang_item\");\n+        if let Some(lang_item_name) = lang_attr(db, item) {\n+            self.items.entry(lang_item_name).or_insert_with(|| constructor(item));\n+        }\n+    }\n+}\n+\n+pub fn lang_attr(db: &dyn DefDatabase, item: impl Into<AttrDefId> + Copy) -> Option<SmolStr> {\n+    let attrs = db.attrs(item.into());\n+    attrs.by_key(\"lang\").string_value().cloned()\n+}"}, {"sha": "0dd0a5861ef3cfe7b46f6a916284fbc5577069ba", "filename": "src/tools/rust-analyzer/crates/hir-def/src/lib.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Flib.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "81b9c5c4bfaf98bc3a43eb7cdacd050c38945e00", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests.rs", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "6819e9114a02476129260eb553f695b9407a729f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/builtin_derive_macro.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_derive_macro.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "92dffa7f372e6226100f23493a674f812cf8157b", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "added", "additions": 377, "deletions": 0, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "30d39d52f385edf72de443fdf88dac010224ab73", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "added", "additions": 1632, "deletions": 0, "changes": 1632, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "bc162d0fa2069d465db9f6078eaeb3427bf62e39", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/matching.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmatching.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "8aff784087c30189383b9c92e4ec0c2544c774fa", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/meta_syntax.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fmeta_syntax.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "2dff4adf2ee804b538fe612a4cee8af4570705ae", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/regression.rs", "status": "added", "additions": 911, "deletions": 0, "changes": 911, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "0710b1ac3d6961c1fd8ec265ad24eea487974c80", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/tt_conversion.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "72c44a0fbcb21e5b76cec7e4acd928c9000cf89f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/proc_macros.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fproc_macros.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "c67046dfdab55e10fdc72b8469adac10a06f8e87", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres.rs", "status": "added", "additions": 529, "deletions": 0, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "3650204ee9d7327f7c0d051e00b61b61b9f33532", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/attr_resolution.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "67651e06413ca21e95589c9eea86f2b1f794bf1b", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/collector.rs", "status": "added", "additions": 2199, "deletions": 0, "changes": 2199, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "0d01f6d0aba3449517dca190319af8dedeb57b4e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/diagnostics.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fdiagnostics.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "52a620fe22f6e2669bc9ea4a55fd197ddd12f76f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/mod_resolution.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "c579bc9194c30bfbe88232fec290fa7d1e8790e8", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/path_resolution.rs", "status": "added", "additions": 448, "deletions": 0, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "5089ef2d8171769685a419f8b4e3b0eb15dd1d5a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/proc_macro.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "80e5476071487cd5443e1d26e83dd4e6af6b5ca3", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests.rs", "status": "added", "additions": 933, "deletions": 0, "changes": 933, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "17426d54d4057b6d7ea351b6de4fea10df6c9402", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/globs.rs", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "2e8cb3621fce663e35bd4a4a3cf93d4fb7b590c7", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/incremental.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "520a6ae1cba5a345a3069fc458ba413043d8f510", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/macros.rs", "status": "added", "additions": 1182, "deletions": 0, "changes": 1182, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "79a74873b4a47f1ccac61a4f50adb4efa6ff6ca0", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/mod_resolution.rs", "status": "added", "additions": 843, "deletions": 0, "changes": 843, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "215e8952d90299e3c977ef96a51d6e8b96143ec7", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/primitives.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "2f13a9fbf0e401790d4556e5c1bc80e56b19b5b0", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "0428f1a398b1a7e9d97daadf9f7ce5dc0fd5cc6e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path/lower.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "bf5bf10c4caaf7cf21a75a805878fb230ec352f0", "filename": "src/tools/rust-analyzer/crates/hir-def/src/per_ns.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fper_ns.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "c8d3052102f452666580f2b4d60c3b2abb29b970", "filename": "src/tools/rust-analyzer/crates/hir-def/src/resolver.rs", "status": "added", "additions": 907, "deletions": 0, "changes": 907, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f69356cac87d38e4e355cd5d88575463f7f4940d", "filename": "src/tools/rust-analyzer/crates/hir-def/src/src.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fsrc.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "9cdc18d6b66fdfb07ba53e85dcb00a65cc4aede7", "filename": "src/tools/rust-analyzer/crates/hir-def/src/test_db.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftest_db.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "6e6ceb8e47495b28495e3670ad39620fa1b89b4c", "filename": "src/tools/rust-analyzer/crates/hir-def/src/trace.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftrace.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "9248059627d2af2b098d23b588911d1bf473817d", "filename": "src/tools/rust-analyzer/crates/hir-def/src/type_ref.rs", "status": "added", "additions": 486, "deletions": 0, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "6e22a877a9fa7980921f19be2af230e6eec56a3b", "filename": "src/tools/rust-analyzer/crates/hir-def/src/visibility.rs", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fvisibility.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "dfd470ffca6ac025e79ecb331727fd243b32769f", "filename": "src/tools/rust-analyzer/crates/hir-expand/Cargo.toml", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "c1ddef03ba3b439f2795f38e9b74eafafa2c5ef2", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/ast_id_map.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fast_id_map.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "0c886ac4da9dbc3b0d67f65fe500f178e8feb450", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_attr_macro.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "79989bc2e38b601339085934488c44cf09217f7c", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_derive_macro.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "76da7c9f1ee82ecdd48f44654592768b74adbd24", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_fn_macro.rs", "status": "added", "additions": 669, "deletions": 0, "changes": 669, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "bd60c3d26868cb347a8b8a4242f71f89664d3f05", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/db.rs", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "5fd099aea7d64a0b612f2ef98d6e247fbe315514", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/eager.rs", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Feager.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "9999790fae727631460c91ff3c7120b9ed1171df", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/fixup.rs", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Ffixup.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "d60734372c0cedd9589a2b789bb4fabfae4e2098", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/hygiene.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fhygiene.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "252293090bb0cdc3006c3f4ec58c7225ce97bf46", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/lib.rs", "status": "added", "additions": 1000, "deletions": 0, "changes": 1000, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "fea09521e87cb6f96aeac38730a65df3739d7e5b", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/mod_path.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "85b0a7735fe94e9fc4255b89c414b36f2865eabc", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/name.rs", "status": "added", "additions": 433, "deletions": 0, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "5afdcc0e66dbce382f966665344bdee4416bd8b4", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/proc_macro.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fproc_macro.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "82f410ecda91d9d0c704dce00ed8efc4f99689d8", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/quote.rs", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fquote.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "5cd444c1ad3bd6b58dca6fc5a001ce12e91b8ed3", "filename": "src/tools/rust-analyzer/crates/hir-ty/Cargo.toml", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "b6f226dbfd20d238ff19338a20d07eab5a3b7008", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/autoderef.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "94d7806cb6e8f261d6a3d686ceb18f4a5b0d5b07", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/builder.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "faec99c7d33c1f2d7d1b183e3b7a19d478e35e82", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_db.rs", "status": "added", "additions": 799, "deletions": 0, "changes": 799, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "b0885ab003f71317db3669607aaf5515673a81f1", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_ext.rs", "status": "added", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "0495a4e64cacadffb3ade02fa9f044348d945463", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/consteval.rs", "status": "added", "additions": 469, "deletions": 0, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "4a052851afd147b802f5fb12947ece83c967726a", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/consteval/tests.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "b385b1cafaefd09f3db05d293cb88fb0737e1f6b", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/db.rs", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "37eb06be1d3d1de7e9cb400350d70c3c259c71a1", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f7031a8546a290a3d458c0a31d802bf535be7b53", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/decl_check.rs", "status": "added", "additions": 701, "deletions": 0, "changes": 701, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "88d607194f756995aca3986ed65836e9ea985d28", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/decl_check/case_conv.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fcase_conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fcase_conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fcase_conv.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "8cca522aef623877d0cd40d5706c67a546924a78", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/expr.rs", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "d51ad72bd27b12bd8fb6f8da8d7f0a9ae461a834", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/match_check.rs", "status": "added", "additions": 508, "deletions": 0, "changes": 508, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "bbbe539c13fbe2c94b1bb05c5c5ed3e9928398da", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "added", "additions": 1094, "deletions": 0, "changes": 1094, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "b89b4f2bfb7d91c6a339a90aafc6e2c989bab4e7", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/match_check/pat_util.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fpat_util.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "1221327b9510a9791984da46e12ab43d5ee142b9", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/match_check/usefulness.rs", "status": "added", "additions": 811, "deletions": 0, "changes": 811, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "161b19a739ce4c6d2d35f8a7a2a0be0b233fc04b", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/unsafe_check.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "d2f9c2b8b1e1dae302ce60ec0d0b493cab9b0829", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/display.rs", "status": "added", "additions": 1315, "deletions": 0, "changes": 1315, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "46eeea0e6fc4e8863e8128ae1291abeeff118d41", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer.rs", "status": "added", "additions": 1088, "deletions": 0, "changes": 1088, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "3ead929098bcc25843d92fcd6b28c09ac0f07f16", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/closure.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f54440bf5b372e00b8422ae4069a47d0de2f7c5f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/coerce.rs", "status": "added", "additions": 673, "deletions": 0, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "2f3346707209527bc535f097d3501523508e6ef2", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/expr.rs", "status": "added", "additions": 1527, "deletions": 0, "changes": 1527, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "5e7320a5dd305117da6814fbc3ca2e1c09af4d48", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/pat.rs", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpat.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f580e09e91229cdef416b9a250bcd940bdf6d41d", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/path.rs", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "e77b55670b5e1b6c3881129d3497e82d06c39c37", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/unify.rs", "status": "added", "additions": 738, "deletions": 0, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "ca76e08fddb915ee1b10597a6149ab3295177c77", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/interner.rs", "status": "added", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finterner.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "5a5d610e360ffba3d4318288faa1b4422987a929", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lib.rs", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "3ed9c941f4790dc2dd07b949a89fee5cb1b50518", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "added", "additions": 1778, "deletions": 0, "changes": 1778, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "d765fee0e1f4e70b523f26db36db9598b916b1f1", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/mapping.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmapping.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "15df7b3dd2b9b4b658ea0490cf5f36ca3c3541cf", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "added", "additions": 1186, "deletions": 0, "changes": 1186, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "d7f48c69a56ef2198e0a7cbe608b419fbece1f9e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/primitive.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fprimitive.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "dc7252f7072d86a052eb2c2d365938bcf867bb28", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/test_db.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftest_db.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "d2f13e4351c73b17cca725446ddfcbd772988e4f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests.rs", "status": "added", "additions": 578, "deletions": 0, "changes": 578, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "bf59fadc2c33693e75de79a0fe016f2896a6cf18", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/coercion.rs", "status": "added", "additions": 755, "deletions": 0, "changes": 755, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f00fa97294877f8d65343e5bcb87c23ef3a1157c", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/diagnostics.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdiagnostics.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "240942e488d7de79adbe9e9a08e8fe6b8e44255c", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/display_source_code.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "3e08e83e89a3e2b045cd47f1a58996aeddc0f07e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/incremental.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fincremental.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "a1ab6060e790c0cdb4a9a02ffcd33e7b66d2aa0e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/macros.rs", "status": "added", "additions": 1338, "deletions": 0, "changes": 1338, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "68463dc068bcf3d870ab787e380b27f337daa543", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/method_resolution.rs", "status": "added", "additions": 1792, "deletions": 0, "changes": 1792, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "fbdc8209f8f4b13138f5f233e786fab9e91b5e86", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/never_type.rs", "status": "added", "additions": 485, "deletions": 0, "changes": 485, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "399553356b04112997c951e2de528175f9f441f7", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/patterns.rs", "status": "added", "additions": 991, "deletions": 0, "changes": 991, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "93a88ab58ef82dee1d6b7fe9a8e03238136a6987", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/regression.rs", "status": "added", "additions": 1650, "deletions": 0, "changes": 1650, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "5b08f552109efe4a533c134e15046079056636ad", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/simple.rs", "status": "added", "additions": 3072, "deletions": 0, "changes": 3072, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "75802a5eb4db83810cf88cc18cf6f5cb3f1e5d6f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "added", "additions": 3782, "deletions": 0, "changes": 3782, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "547850b021c3cef706d1181ce8f9a16ea93d9822", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tls.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftls.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "77afeb3217dd02779e5ef65cf48d6e9ff162a5e9", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/traits.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "83319755da73aa5fbce84053edf06cbbcd9a7e8f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/utils.rs", "status": "added", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Futils.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "c476894552e6c879e2a1d18841ad5e594bf2bac3", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/walk.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fwalk.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "8e6a2441b33117c4bf924b3c00d6093eec0709a1", "filename": "src/tools/rust-analyzer/crates/hir/Cargo.toml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "0bd37934001094d901dd75cc11eedd48ac69dd32", "filename": "src/tools/rust-analyzer/crates/hir/src/attrs.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fattrs.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "e25d867845824c9f6cb9e78297beab99e24d02ff", "filename": "src/tools/rust-analyzer/crates/hir/src/db.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdb.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "6c6c11ea4ebdc02b787dd4763b14050724b8b36c", "filename": "src/tools/rust-analyzer/crates/hir/src/diagnostics.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "0e29c52ade68347df124bc579b20d27c3a0ea243", "filename": "src/tools/rust-analyzer/crates/hir/src/display.rs", "status": "added", "additions": 530, "deletions": 0, "changes": 530, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdisplay.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "9c7558d1918778a7f85d641459702f0d01ee786d", "filename": "src/tools/rust-analyzer/crates/hir/src/from_id.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Ffrom_id.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f8b01db3e3288df02b49ddd4fc0f09f63ea22a7e", "filename": "src/tools/rust-analyzer/crates/hir/src/has_source.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fhas_source.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "9ffbb3964cf1134e5c89193a7bb9f2238ef5da4b", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "added", "additions": 3609, "deletions": 0, "changes": 3609, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "043f2b7c24dcb42adbf82307e9341543d5f91460", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics.rs", "status": "added", "additions": 1481, "deletions": 0, "changes": 1481, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "5c4cfa7b45a53fa275411abafba764083f39baf5", "filename": "src/tools/rust-analyzer/crates/hir/src/semantics/source_to_def.rs", "status": "added", "additions": 471, "deletions": 0, "changes": 471, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "e89f8a542981cdf185bd3369a6ba1d856c92ebf9", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "added", "additions": 872, "deletions": 0, "changes": 872, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "616a406c72758aa4b0ca77dca33f74b5601aa308", "filename": "src/tools/rust-analyzer/crates/hir/src/symbols.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsymbols.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "51e43d21cb03daa95b3885498d5c6cd96957790b", "filename": "src/tools/rust-analyzer/crates/ide-assists/Cargo.toml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "d4d148c774578f13996383cde831f3002d60103b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/assist_config.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fassist_config.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fassist_config.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fassist_config.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f9b42661425745a6df4323230a3c55e5a5f9a908", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/assist_context.rs", "status": "added", "additions": 347, "deletions": 0, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fassist_context.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "bfa9759ec84bea47b1abbe4e9687e93103af8bbc", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_explicit_type.rs", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "001f1e8bb158545ada906c8d188d601ca737644c", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_label_to_loop.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_label_to_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_label_to_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_label_to_loop.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "12213c8455c77436dc4d5a96095de440a5c6c51b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_lifetime_to_type.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_lifetime_to_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_lifetime_to_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_lifetime_to_type.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "7f2a26ad06741fa6246fe240e2ee4d0d8537fdc9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_missing_impl_members.rs", "status": "added", "additions": 1337, "deletions": 0, "changes": 1337, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "b16f6fe03ae8e12716352b22dc7c514a189e0eea", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_missing_match_arms.rs", "status": "added", "additions": 1709, "deletions": 0, "changes": 1709, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f858d7a15c24276fb591c28996e1ea7f3b2f2bbe", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_return_type.rs", "status": "added", "additions": 447, "deletions": 0, "changes": 447, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "c0bf238db7317a78756dd3fb97a4f04b573e4637", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/add_turbo_fish.rs", "status": "added", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "2853d1d1be3cd57b5935f61bc4899cd2d68d30b3", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/apply_demorgan.rs", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "949cf3167a8a1d94e4c177bf49958a73beda21ea", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/auto_import.rs", "status": "added", "additions": 1292, "deletions": 0, "changes": 1292, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "2b1d8f6f0132aa332778b642b0612850637150ac", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/change_visibility.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "db96ad33047fb3791657260f1304f64a2d9de16b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_bool_then.rs", "status": "added", "additions": 575, "deletions": 0, "changes": 575, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f171dd81a811e7183d70e673e37806fbe813ce87", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_comment_block.rs", "status": "added", "additions": 395, "deletions": 0, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "9060696cdc8e9c76fd26cd5c7eda993d0ebb15d6", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_integer_literal.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "30f6dd41a1d6d53398855c686adfb3df50d87616", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_into_to_from.rs", "status": "added", "additions": 351, "deletions": 0, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "2cf370c090743da3730e37a47fa9785496c6343e", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "added", "additions": 556, "deletions": 0, "changes": 556, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "00095de257d5ab19922c22df209b76b763281a8c", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_let_else_to_match.rs", "status": "added", "additions": 497, "deletions": 0, "changes": 497, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "cb75619ced9c31f46bf0c2a92adfc3902870e67f", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_to_guarded_return.rs", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "4ab8e93a2909f1c3e7020da6d95c753845bb0a35", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "added", "additions": 840, "deletions": 0, "changes": 840, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "c34b684112aaf53471101ce45371089aefb51e79", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_while_to_loop.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_while_to_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_while_to_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_while_to_loop.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "c1f57532bb29623ea75f2083edc55622b0534e18", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/destructure_tuple_binding.rs", "status": "added", "additions": 2147, "deletions": 0, "changes": 2147, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "943c1d90e63659830d017e9ab4b102a594de62f1", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/expand_glob_import.rs", "status": "added", "additions": 900, "deletions": 0, "changes": 900, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "52a55ead3af9629e518dd1ffb621af3738a1b7ec", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_function.rs", "status": "added", "additions": 5333, "deletions": 0, "changes": 5333, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "b3c4d306ac1c58d64fc3b1e4281dfc826ff4d467", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_module.rs", "status": "added", "additions": 1770, "deletions": 0, "changes": 1770, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "a93648f2d315aee65ca326a5fd8b8b5f3b13e2e0", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "added", "additions": 1076, "deletions": 0, "changes": 1076, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "af584cdb4384aa96b508775bfaec88932b14b456", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_type_alias.rs", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "3596b6f82381b5ff1d6127ed162ca27b58aa972e", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_variable.rs", "status": "added", "additions": 1279, "deletions": 0, "changes": 1279, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "b33846f546653e9095520861ea3d4fa819803a91", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/fix_visibility.rs", "status": "added", "additions": 606, "deletions": 0, "changes": 606, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "2ea6f58fa0f1e25cd18b540dfa6ca66d5b090207", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/flip_binexpr.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f40f2713ad1319a5affc21f27100263ef49dbabb", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/flip_comma.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_comma.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "e3ae4970b6a7a172e7c9050277cab3fc9b9f4523", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/flip_trait_bound.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "eaa6de73eb35d4bc0ec6ffafb1ba464e29d4507b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_constant.rs", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "5e9995a9866445ec96dca5a9991440551119f169", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_default_from_enum_variant.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_enum_variant.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "cbd33de19eda0c047675d36cb966e4133d14158a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_default_from_new.rs", "status": "added", "additions": 657, "deletions": 0, "changes": 657, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_default_from_new.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "85b193663a05bc5e2798d7408d53a08500c43b93", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_delegate_methods.rs", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "b9637ee8d7c60bece754d922ccc73e504ee857ce", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_deref.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "339245b94eca4250bb73ff1d664b8433905364ff", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_derive.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "c91141f8eb50f27fd41ccf8634587c62c2b55747", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_documentation_template.rs", "status": "added", "additions": 1328, "deletions": 0, "changes": 1328, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "52d27d8a7d63350b385cf74c5806e23bb612c9c0", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_enum_is_method.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_is_method.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "b19aa0f652aa71acbc5ee9e213ec6520fe241432", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_enum_projection_method.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "4461fbd5ac82709eeb7a6f0b6ff904c88c250028", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_enum_variant.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "507ea012babfc431fcd184f8eff266d9ca580fe2", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_from_impl_for_enum.rs", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "d564a0540898e77ac694f3dd0bc9d4ff61c003e3", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_function.rs", "status": "added", "additions": 1787, "deletions": 0, "changes": 1787, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "76fcef0cad9512a7b823be4cb3bce514923f29f8", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_getter.rs", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "68287a20bf8068ac45677908396ee9bf06c366fb", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_impl.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "9ce525ca375c8ed3a1b6d3b8afce1d4658e0d730", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_is_empty_from_len.rs", "status": "added", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_is_empty_from_len.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "6c93875e9eb62f2b0dd13e12068b19e1acedd543", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_new.rs", "status": "added", "additions": 495, "deletions": 0, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "2a7ad6ce3681145f0f8940124e5c2a8709d882a7", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_setter.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_setter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_setter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_setter.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "658a1aadf53ecf9e0549f27af1671d3d0b9bd127", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_call.rs", "status": "added", "additions": 1150, "deletions": 0, "changes": 1150, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "7259d67819416e502dcceb64452b5f3b2bedc6a6", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_local_variable.rs", "status": "added", "additions": 954, "deletions": 0, "changes": 954, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "054663a06a1154b2868c00590dcc1a325b67e1e2", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/inline_type_alias.rs", "status": "added", "additions": 838, "deletions": 0, "changes": 838, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_type_alias.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "062c816aef0dad95e11d81f48bb230d039b0bcef", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/introduce_named_generic.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_generic.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "ce91dd23703b6dd89633392ab440a3ed9920142b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/introduce_named_lifetime.rs", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "547158e29778e4bdd273c9e0ad0499b636aecab5", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/invert_if.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "7e102ceba891ae2f9d3d2f5132b8a2fff678a9d9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/merge_imports.rs", "status": "added", "additions": 570, "deletions": 0, "changes": 570, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "c24015b1c5175a410d45dab0974e913b78346de1", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/merge_match_arms.rs", "status": "added", "additions": 822, "deletions": 0, "changes": 822, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "176a3bf5803fcdddd52d2baa1f17ba78bbe95066", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_bounds.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "a6c85a2b18b34b535c9e98e3ea01fbfc4b4f2dc6", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_from_mod_rs.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "b8f1b36deb93cbbbed959f05c8fe1dc047ab5926", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_guard.rs", "status": "added", "additions": 997, "deletions": 0, "changes": 997, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "7468318a594afbea619df9e475aebdb414030484", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_module_to_file.rs", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "a909ce8b26791af34208f0aa32b20017978e697b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/move_to_mod_rs.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "424db7437a743b4bce4fa639dc500048718f87d7", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/number_representation.rs", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fnumber_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fnumber_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fnumber_representation.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "cbbea6c1e6373793e5c6392db508b5778c76e6b9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/promote_local_to_const.rs", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fpromote_local_to_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fpromote_local_to_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fpromote_local_to_const.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "4cfe6c99b23c290e15b847a1cabb3cd1fe54922b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/pull_assignment_up.rs", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "121f8b4a136839dfcf1a7f040cb9a7e317d3fb0d", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/qualify_method_call.rs", "status": "added", "additions": 548, "deletions": 0, "changes": 548, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "0c2e9da38639fbcf8844cace2d83bf71599724fa", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/qualify_path.rs", "status": "added", "additions": 1297, "deletions": 0, "changes": 1297, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "dbe8cb7bf031faadb71ed8ebae13819624980f55", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/raw_string.rs", "status": "added", "additions": 509, "deletions": 0, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "afaa7c933c73951093dea8d12d0c12557c03cc76", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/remove_dbg.rs", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "0b299e8349ac1aaa5d76e22948d8da0243d9b604", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/remove_mut.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_mut.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "59ea94ea1ff6b64fc6cb8d16a4837d4d100fcd09", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/remove_unused_param.rs", "status": "added", "additions": 409, "deletions": 0, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "a899c7a6457e0f798280aa6962d59c3d8af236bc", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/reorder_fields.rs", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "208c3e109ddeccb69242b83a171ef568503d37d9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/reorder_impl_items.rs", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "bd50208da5ffdecb81e57cb206d1ce67217529e3", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "added", "additions": 1250, "deletions": 0, "changes": 1250, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "484c27387da94ee7fb71aa5eaf7b9cfae0be80a5", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_if_let_with_match.rs", "status": "added", "additions": 999, "deletions": 0, "changes": 999, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "c2be4593b97d0c410814a9ae63dd67b587dafb1e", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_let_with_if_let.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "2419fa11c155428b66899b88589c8c22833bb2f6", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_qualified_name_with_use.rs", "status": "added", "additions": 438, "deletions": 0, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "decb5fb62a772654e34763f992cf5683ee4d5fff", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_string_with_char.rs", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_string_with_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_string_with_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_string_with_char.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "38fccb33829a3aa7cf379b4fe6f5734e9f631114", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_try_expr_with_match.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_try_expr_with_match.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "6112e09455a47c19c108ea4388346aef778534f7", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_turbofish_with_explicit_type.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "a93704b39474b8ec520fc6fbd84192debea396b6", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/sort_items.rs", "status": "added", "additions": 588, "deletions": 0, "changes": 588, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fsort_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fsort_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fsort_items.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "775ededecbcc8b9587c6f84e3414c51c88616674", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/split_import.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "b7d57f02be566f07a9e9d39f36ba37c68f36263d", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/toggle_ignore.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ftoggle_ignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ftoggle_ignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Ftoggle_ignore.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "3ce028e9306597b87fa117b36cdbfc428c8a2f4a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/unmerge_use.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_use.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "d5cd2d551349d7c225be5e262ce399e2354deafb", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/unnecessary_async.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "7969a491822d19165cdc4e5567f6a040a82ef226", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/unwrap_block.rs", "status": "added", "additions": 719, "deletions": 0, "changes": 719, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "9ef4ae047ef0e9d7a45ec0ae57a887aa1337406a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/unwrap_result_return_type.rs", "status": "added", "additions": 1020, "deletions": 0, "changes": 1020, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_result_return_type.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "83446387db1cf65332b559105fb75a7a8c7326e3", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/wrap_return_type_in_result.rs", "status": "added", "additions": 980, "deletions": 0, "changes": 980, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "fe87aa15fcf23ffa542f5ac3071ba67585f0668e", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/lib.rs", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "249a56b4ae3c1d789b7c4b634fb26b003080fb0b", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests.rs", "status": "added", "additions": 557, "deletions": 0, "changes": 557, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "e8d48607be0e9f938814bb94f5995ae6d84bad40", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/generated.rs", "status": "added", "additions": 2259, "deletions": 0, "changes": 2259, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "d45e54186bb673ca8551d62560d196f015a40a89", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/sourcegen.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fsourcegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fsourcegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fsourcegen.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "3e61d0741d3fe1267030541948bf1849103a0b17", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils.rs", "status": "added", "additions": 703, "deletions": 0, "changes": 703, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "ec4835969f886017c984ca8cec528e134ca9a441", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils/gen_trait_fn_body.rs", "status": "added", "additions": 660, "deletions": 0, "changes": 660, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "779cdbc93c54a59d01914edbc84d2056ae61a608", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils/suggest_name.rs", "status": "added", "additions": 775, "deletions": 0, "changes": 775, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "8c9d6b228648e6bfec6e8c5414a269ebfce949e6", "filename": "src/tools/rust-analyzer/crates/ide-completion/Cargo.toml", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "149afcac9d4786e5bc38bf93b4cfdefb72c04021", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions.rs", "status": "added", "additions": 682, "deletions": 0, "changes": 682, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "1d8a8c5f20db35828438e90abaa8bd1b6dbbed27", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute.rs", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "311060143b06a19c8d08ea437f6791827b41e09b", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute/cfg.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "14538fef6072c8b8a481b182321ab6cb5a6d1b5c", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute/derive.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "967f6ddd9a83b3b2196fa29e0979549954304bed", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute/lint.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "a29417133e68b0c4db81fccd93a219cb96634df6", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/attribute/repr.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "cf40ca489c009733174cb30083f1c3645aabbb72", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/dot.rs", "status": "added", "additions": 947, "deletions": 0, "changes": 947, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "bdf6e64f09696d27660409743a8d42842e8f7751", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/expr.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "4e89ef6960821e8a79cd854fc32bd0352458cc14", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/extern_abi.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "870df63b7bf2a03a2d24b88573f35c96b8b11b8b", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/field.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ffield.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f04cc15d7fabd844eff4d5e8900a89e5c03f5999", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/flyimport.rs", "status": "added", "additions": 407, "deletions": 0, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "f0ecc595af33eaf22838510b6ff35fcc44ec9b48", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/fn_param.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "038bdb4279e07f404246f8c3f51c9df5616af02d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/format_string.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "4e4c9fba6cc57250498a877f159967ca9051e538", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/item_list.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "e9256803cc4f7e46d92c6e51c2d6157a63e1af38", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "added", "additions": 1160, "deletions": 0, "changes": 1160, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "3989a451bde42a150f8cdb9910df50fe9de245cc", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/keyword.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "3b79def639df420aa7295ed1970c09e98541015d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/lifetime.rs", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Flifetime.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "9c975b92953377b2e476edb8065a77a35652f57f", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/mod_.rs", "status": "added", "additions": 354, "deletions": 0, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "17dfe432b3529e453e81a8fbaebf174c99d63046", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/pattern.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "9a891cea2d458491979475f1753b1f3f67b69645", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/postfix.rs", "status": "added", "additions": 616, "deletions": 0, "changes": 616, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "6b94347e0ad05cb7e3b7d451184cfcdc1d04dfdc", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/postfix/format_like.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "1c9042390d3b2fc0703ce730cbbe659ff7703e7f", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/record.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "66adb4286373a85deb59413905e85aa48df811bb", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/snippet.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "87a998dfcce6bfab229e85d6302330a2e7b891bc", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/type.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "bb2ecc9fdde76b384464d22b9c5df5b1056b0a10", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/use_.rs", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "ca8303906a800a82f425cdd716a9f442c8f8ef16", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/vis.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "80d6af28168f5c778b7fb117faabdcebf0e1154a", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/config.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fconfig.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}, {"sha": "93b6ad5d145dff545f979c2aad0d9f06ad96179d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "added", "additions": 636, "deletions": 0, "changes": 636, "blob_url": "https://github.com/rust-lang/rust/blob/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43acb501b93c637b32fa134ba8cf586d82e96732/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=43acb501b93c637b32fa134ba8cf586d82e96732"}]}