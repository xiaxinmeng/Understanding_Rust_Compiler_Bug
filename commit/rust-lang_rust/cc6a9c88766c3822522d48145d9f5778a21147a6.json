{"sha": "cc6a9c88766c3822522d48145d9f5778a21147a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNmE5Yzg4NzY2YzM4MjI1MjJkNDgxNDVkOWY1Nzc4YTIxMTQ3YTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-15T17:18:23Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-15T22:16:06Z"}, "message": "rustc: Remove the \"boxed\" check, and make the static_size_of_tag recursion-eliminating transformation deep", "tree": {"sha": "251d30672ff8cac1c97e06ea8b62668d6ffead46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/251d30672ff8cac1c97e06ea8b62668d6ffead46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc6a9c88766c3822522d48145d9f5778a21147a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc6a9c88766c3822522d48145d9f5778a21147a6", "html_url": "https://github.com/rust-lang/rust/commit/cc6a9c88766c3822522d48145d9f5778a21147a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc6a9c88766c3822522d48145d9f5778a21147a6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2214b6835d8bf5b33a3fb8b6a897abaea55ef368", "url": "https://api.github.com/repos/rust-lang/rust/commits/2214b6835d8bf5b33a3fb8b6a897abaea55ef368", "html_url": "https://github.com/rust-lang/rust/commit/2214b6835d8bf5b33a3fb8b6a897abaea55ef368"}], "stats": {"total": 65, "additions": 32, "deletions": 33}, "files": [{"sha": "bab94982be246b9d6a0ecf054c1a6108f053f2b9", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/cc6a9c88766c3822522d48145d9f5778a21147a6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc6a9c88766c3822522d48145d9f5778a21147a6/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cc6a9c88766c3822522d48145d9f5778a21147a6", "patch": "@@ -532,7 +532,7 @@ fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n         fail;\n     }\n \n-    ret type_of_inner(cx, t, false);\n+    ret type_of_inner(cx, t);\n }\n \n fn type_of_explicit_args(@crate_ctxt cx,\n@@ -546,10 +546,10 @@ fn type_of_explicit_args(@crate_ctxt cx,\n             let TypeRef t;\n             alt (arg.mode) {\n                 case (ast.alias) {\n-                    t = T_ptr(type_of_inner(cx, arg.ty, true));\n+                    t = T_ptr(type_of_inner(cx, arg.ty));\n                 }\n                 case (_) {\n-                    t = type_of_inner(cx, arg.ty, false);\n+                    t = type_of_inner(cx, arg.ty);\n                 }\n             }\n             atys += vec(t);\n@@ -577,7 +577,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n     if (ty.type_has_dynamic_size(output)) {\n         atys += vec(T_typaram_ptr(cx.tn));\n     } else {\n-        atys += vec(T_ptr(type_of_inner(cx, output, false)));\n+        atys += vec(T_ptr(type_of_inner(cx, output)));\n     }\n \n     // Arg 1: Task pointer.\n@@ -644,10 +644,10 @@ fn type_of_native_fn(@crate_ctxt cx, ast.native_abi abi,\n         }\n     }\n     atys += type_of_explicit_args(cx, inputs);\n-    ret T_fn(atys, type_of_inner(cx, output, false));\n+    ret T_fn(atys, type_of_inner(cx, output));\n }\n \n-fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n+fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n     let TypeRef llty = 0 as TypeRef;\n \n     alt (t.struct) {\n@@ -682,28 +682,28 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n             }\n         }\n         case (ty.ty_box(?mt)) {\n-            llty = T_ptr(T_box(type_of_inner(cx, mt.ty, true)));\n+            llty = T_ptr(T_box(type_of_inner(cx, mt.ty)));\n         }\n         case (ty.ty_vec(?mt)) {\n-            llty = T_ptr(T_vec(type_of_inner(cx, mt.ty, true)));\n+            llty = T_ptr(T_vec(type_of_inner(cx, mt.ty)));\n         }\n         case (ty.ty_port(?t)) {\n-            llty = T_ptr(T_port(type_of_inner(cx, t, true)));\n+            llty = T_ptr(T_port(type_of_inner(cx, t)));\n         }\n         case (ty.ty_chan(?t)) {\n-            llty = T_ptr(T_chan(type_of_inner(cx, t, true)));\n+            llty = T_ptr(T_chan(type_of_inner(cx, t)));\n         }\n         case (ty.ty_tup(?elts)) {\n             let vec[TypeRef] tys = vec();\n             for (ty.mt elt in elts) {\n-                tys += vec(type_of_inner(cx, elt.ty, boxed));\n+                tys += vec(type_of_inner(cx, elt.ty));\n             }\n             llty = T_struct(tys);\n         }\n         case (ty.ty_rec(?fields)) {\n             let vec[TypeRef] tys = vec();\n             for (ty.field f in fields) {\n-                tys += vec(type_of_inner(cx, f.mt.ty, boxed));\n+                tys += vec(type_of_inner(cx, f.mt.ty));\n             }\n             llty = T_struct(tys);\n         }\n@@ -768,9 +768,9 @@ fn type_of_arg(@crate_ctxt cx, &ty.arg arg) -> TypeRef {\n \n     auto typ;\n     if (arg.mode == ast.alias) {\n-        typ = T_ptr(type_of_inner(cx, arg.ty, true));\n+        typ = T_ptr(type_of_inner(cx, arg.ty));\n     } else {\n-        typ = type_of_inner(cx, arg.ty, false);\n+        typ = type_of_inner(cx, arg.ty);\n     }\n     ret typ;\n }\n@@ -1099,6 +1099,23 @@ fn array_alloca(@block_ctxt cx, TypeRef t, ValueRef n) -> ValueRef {\n }\n \n \n+// Creates a simpler, size-equivalent type. The resulting type is guaranteed\n+// to have (a) the same size as the type that was passed in; (b) to be non-\n+// recursive. This is done by replacing all boxes in a type with boxed unit\n+// types.\n+fn simplify_type(@ty.t typ) -> @ty.t {\n+    fn simplifier(@ty.t typ) -> @ty.t {\n+        alt (typ.struct) {\n+            case (ty.ty_box(_)) {\n+                ret ty.plain_box_ty(ty.plain_ty(ty.ty_nil), ast.imm);\n+            }\n+            case (_) { ret typ; }\n+        }\n+    }\n+    auto f = simplifier;\n+    ret ty.fold_ty(f, typ);\n+}\n+\n // Computes the size of the data part of a non-dynamically-sized tag.\n fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n     if (ty.type_has_dynamic_size(t)) {\n@@ -1127,25 +1144,7 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n     auto max_size = 0u;\n     auto variants = tag_variants(cx, tid);\n     for (variant_info variant in variants) {\n-\n-        let vec[@ty.t] args = vec();\n-        for (@ty.t t in variant.args) {\n-            alt (t.struct) {\n-                // NB: We're just going for 'size' here, so we can do a little\n-                // faking work here and substitute all boxes to boxed ints;\n-                // this will break any tag cycles we might otherwise traverse\n-                // (which would cause infinite recursion while measuring\n-                // size).\n-                case (ty.ty_box(_)) {\n-                    args += vec(ty.plain_box_ty(ty.plain_ty(ty.ty_int),\n-                                                ast.imm));\n-                }\n-                case (_) {\n-                    args += vec(t);\n-                }\n-            }\n-        }\n-        auto tup_ty = ty.plain_tup_ty(args);\n+        auto tup_ty = simplify_type(ty.plain_tup_ty(variant.args));\n \n         // Perform any type parameter substitutions.\n         tup_ty = ty.bind_params_in_type(tup_ty);"}]}