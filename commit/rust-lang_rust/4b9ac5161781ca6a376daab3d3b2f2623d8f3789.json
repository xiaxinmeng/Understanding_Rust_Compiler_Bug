{"sha": "4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiOWFjNTE2MTc4MWNhNmEzNzZkYWFiM2QzYjJmMjYyM2Q4ZjM3ODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-11T12:31:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-11T12:31:56Z"}, "message": "Auto merge of #75388 - JohnTitor:rollup-9tgkxnl, r=JohnTitor\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #74744 (Update RELEASES.md for 1.46.0)\n - #75085 (Transmute big endian `s6_addr` and `[u16; 8]`)\n - #75226 (Miri: Renamed \"undef\" to \"uninit\")\n - #75333 (polymorphize: constrain unevaluated const handling)\n - #75338 (move stack size check to const_eval machine)\n - #75347 (Rustdoc: Fix natural ordering to look at all numbers.)\n - #75352 (Tweak conditions for E0026 and E0769)\n - #75353 (Tiny cleanup, remove unnecessary `unwrap`)\n - #75359 (unused_delims: trim expr)\n - #75360 (Add sample fix for E0749)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "9c0ef96cc28d572f230886ce0b8f66e529aa2e3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c0ef96cc28d572f230886ce0b8f66e529aa2e3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "html_url": "https://github.com/rust-lang/rust/commit/4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "441fd2255763c2aeea616aeac61b2c795a4c5330", "url": "https://api.github.com/repos/rust-lang/rust/commits/441fd2255763c2aeea616aeac61b2c795a4c5330", "html_url": "https://github.com/rust-lang/rust/commit/441fd2255763c2aeea616aeac61b2c795a4c5330"}, {"sha": "532002853d88a7c9f875dc8c401b8b7e019fe10b", "url": "https://api.github.com/repos/rust-lang/rust/commits/532002853d88a7c9f875dc8c401b8b7e019fe10b", "html_url": "https://github.com/rust-lang/rust/commit/532002853d88a7c9f875dc8c401b8b7e019fe10b"}], "stats": {"total": 459, "additions": 319, "deletions": 140}, "files": [{"sha": "b3d8c2f65f63377b32c5afd3958a6bf842d4cae0", "filename": "RELEASES.md", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -1,3 +1,104 @@\n+Version 1.46.0 (2020-08-27)\n+==========================\n+\n+Language\n+--------\n+- [`if`, `match`, and `loop` expressions can now be used in const functions.][72437]\n+- [Additionally you are now also able to coerce and cast to slices (`&[T]`) in\n+  const functions.][73862]\n+- [The `#[track_caller]` attribute can now be added to functions to use the\n+  function's caller's location information for panic messages.][72445]\n+- [Recursively indexing into tuples no longer needs parentheses.][71322] E.g.\n+  `x.0.0` over `(x.0).0`.\n+- [`mem::transmute` can now be used in static and constants.][72920] **Note**\n+  You currently can't use `mem::transmute` in constant functions.\n+\n+Compiler\n+--------\n+- [You can now use the `cdylib` target on Apple iOS and tvOS platforms.][73516]\n+- [Enabled static \"Position Independent Executables\" by default\n+  for `x86_64-unknown-linux-musl`.][70740]\n+\n+Libraries\n+---------\n+- [`mem::forget` is now a `const fn`.][73887]\n+- [`String` now implements `From<char>`.][73466]\n+- [The `leading_ones`, and `trailing_ones` methods have been stabilised for all\n+  integer types.][73032]\n+- [`vec::IntoIter<T>` now implements `AsRef<[T]>`.][72583]\n+- [All non-zero integer types (`NonZeroU8`) now implement `TryFrom` for their\n+  zero-able equivalent (e.g. `TryFrom<u8>`).][72717]\n+- [`&[T]` and `&mut [T]` now implement `PartialEq<Vec<T>>`.][71660]\n+- [`(String, u16)` now implements `ToSocketAddrs`.][73007]\n+- [`vec::Drain<'_, T>` now implements `AsRef<[T]>`.][72584]\n+\n+Stabilized APIs\n+---------------\n+- [`Option::zip`]\n+- [`vec::Drain::as_slice`]\n+\n+Cargo\n+-----\n+Added a number of new environment variables that are now available when\n+compiling your crate.\n+\n+- [`CARGO_BIN_NAME` and `CARGO_CRATE_NAME`][cargo/8270] Providing the name of\n+  the specific binary being compiled and the name of the crate.\n+- [`CARGO_PKG_LICENSE`][cargo/8325] The license from the manifest of the package.\n+- [`CARGO_PKG_LICENSE_FILE`][cargo/8387] The path to the license file.\n+\n+Compatibility Notes\n+-------------------\n+- [The target configuration option `abi_blacklist` has been renamed\n+  to `unsupported_abis`.][74150] The old name will still continue to work.\n+- [Rustc will now warn if you have a C-like enum that implements `Drop`.][72331]\n+  This was previously accepted but will become a hard error in a future release.\n+- [Rustc will fail to compile if you have a struct with\n+  `#[repr(i128)]` or `#[repr(u128)]`.][74109] This representation is currently only\n+  allowed on `enum`s.\n+- [Tokens passed to `macro_rules!` are now always captured.][73293] This helps\n+  ensure that spans have the correct information, and may cause breakage if you\n+  were relying on receiving spans with dummy information.\n+- [The InnoSetup installer for Windows is no longer available.][72569] This was\n+  a legacy installer that was replaced by a MSI installer a few years ago but\n+  was still being built.\n+- [`{f32, f64}::asinh` now returns the correct values for negative numbers.][72486]\n+- [Rustc will no longer accept overlapping trait implementations that only\n+  differ in how the lifetime was bound.][72493]\n+- [Rustc now correctly relates the lifetime of an existential associated\n+  type.][71896] This fixes some edge cases where `rustc` would erroneously allow\n+  you to pass a shorter lifetime than expected.\n+\n+[74109]: https://github.com/rust-lang/rust/pull/74109/\n+[74150]: https://github.com/rust-lang/rust/pull/74150/\n+[73862]: https://github.com/rust-lang/rust/pull/73862/\n+[73887]: https://github.com/rust-lang/rust/pull/73887/\n+[73466]: https://github.com/rust-lang/rust/pull/73466/\n+[73516]: https://github.com/rust-lang/rust/pull/73516/\n+[73293]: https://github.com/rust-lang/rust/pull/73293/\n+[73007]: https://github.com/rust-lang/rust/pull/73007/\n+[73032]: https://github.com/rust-lang/rust/pull/73032/\n+[72920]: https://github.com/rust-lang/rust/pull/72920/\n+[72569]: https://github.com/rust-lang/rust/pull/72569/\n+[72583]: https://github.com/rust-lang/rust/pull/72583/\n+[72584]: https://github.com/rust-lang/rust/pull/72584/\n+[72717]: https://github.com/rust-lang/rust/pull/72717/\n+[72437]: https://github.com/rust-lang/rust/pull/72437/\n+[72445]: https://github.com/rust-lang/rust/pull/72445/\n+[72486]: https://github.com/rust-lang/rust/pull/72486/\n+[72493]: https://github.com/rust-lang/rust/pull/72493/\n+[72331]: https://github.com/rust-lang/rust/pull/72331/\n+[71896]: https://github.com/rust-lang/rust/pull/71896/\n+[71660]: https://github.com/rust-lang/rust/pull/71660/\n+[71322]: https://github.com/rust-lang/rust/pull/71322/\n+[70740]: https://github.com/rust-lang/rust/pull/70740/\n+[cargo/8270]: https://github.com/rust-lang/cargo/pull/8270/\n+[cargo/8325]: https://github.com/rust-lang/cargo/pull/8325/\n+[cargo/8387]: https://github.com/rust-lang/cargo/pull/8387/\n+[`Option::zip`]: https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.zip\n+[`vec::Drain::as_slice`]: https://doc.rust-lang.org/stable/std/vec/struct.Drain.html#method.as_slice\n+\n+\n Version 1.45.2 (2020-08-03)\n ==========================\n \n@@ -7,6 +108,7 @@ Version 1.45.2 (2020-08-03)\n [74954]: https://github.com/rust-lang/rust/issues/74954\n [74784]: https://github.com/rust-lang/rust/issues/74784\n \n+\n Version 1.45.1 (2020-07-30)\n ==========================\n \n@@ -20,6 +122,7 @@ Version 1.45.1 (2020-07-30)\n [74509]: https://github.com/rust-lang/rust/pull/74509\n [74457]: https://github.com/rust-lang/rust/pull/74457\n \n+\n Version 1.45.0 (2020-07-16)\n ==========================\n "}, {"sha": "f0487e0dff148417154224000b2652f18667808f", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -249,6 +249,7 @@\n #![feature(clamp)]\n #![feature(concat_idents)]\n #![feature(const_cstr_unchecked)]\n+#![feature(const_fn_transmute)]\n #![feature(const_raw_ptr_deref)]\n #![feature(container_error_extra)]\n #![feature(core_intrinsics)]"}, {"sha": "5d103e6403750ca9152a4c5e9bcf064bbf71c7ac", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -10,6 +10,7 @@ use crate::cmp::Ordering;\n use crate::fmt::{self, Write as FmtWrite};\n use crate::hash;\n use crate::io::Write as IoWrite;\n+use crate::mem::transmute;\n use crate::sys::net::netc as c;\n use crate::sys_common::{AsInner, FromInner};\n \n@@ -1045,27 +1046,23 @@ impl Ipv6Addr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.32.0\")]\n+    #[allow_internal_unstable(const_fn_transmute)]\n     pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {\n+        let addr16 = [\n+            a.to_be(),\n+            b.to_be(),\n+            c.to_be(),\n+            d.to_be(),\n+            e.to_be(),\n+            f.to_be(),\n+            g.to_be(),\n+            h.to_be(),\n+        ];\n         Ipv6Addr {\n             inner: c::in6_addr {\n-                s6_addr: [\n-                    (a >> 8) as u8,\n-                    a as u8,\n-                    (b >> 8) as u8,\n-                    b as u8,\n-                    (c >> 8) as u8,\n-                    c as u8,\n-                    (d >> 8) as u8,\n-                    d as u8,\n-                    (e >> 8) as u8,\n-                    e as u8,\n-                    (f >> 8) as u8,\n-                    f as u8,\n-                    (g >> 8) as u8,\n-                    g as u8,\n-                    (h >> 8) as u8,\n-                    h as u8,\n-                ],\n+                // All elements in `addr16` are big endian.\n+                // SAFETY: `[u16; 8]` is always safe to transmute to `[u8; 16]`.\n+                s6_addr: unsafe { transmute::<_, [u8; 16]>(addr16) },\n             },\n         }\n     }\n@@ -1108,16 +1105,19 @@ impl Ipv6Addr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn segments(&self) -> [u16; 8] {\n-        let arr = &self.inner.s6_addr;\n+        // All elements in `s6_addr` must be big endian.\n+        // SAFETY: `[u8; 16]` is always safe to transmute to `[u16; 8]`.\n+        let [a, b, c, d, e, f, g, h] = unsafe { transmute::<_, [u16; 8]>(self.inner.s6_addr) };\n+        // We want native endian u16\n         [\n-            u16::from_be_bytes([arr[0], arr[1]]),\n-            u16::from_be_bytes([arr[2], arr[3]]),\n-            u16::from_be_bytes([arr[4], arr[5]]),\n-            u16::from_be_bytes([arr[6], arr[7]]),\n-            u16::from_be_bytes([arr[8], arr[9]]),\n-            u16::from_be_bytes([arr[10], arr[11]]),\n-            u16::from_be_bytes([arr[12], arr[13]]),\n-            u16::from_be_bytes([arr[14], arr[15]]),\n+            u16::from_be(a),\n+            u16::from_be(b),\n+            u16::from_be(c),\n+            u16::from_be(d),\n+            u16::from_be(e),\n+            u16::from_be(f),\n+            u16::from_be(g),\n+            u16::from_be(h),\n         ]\n     }\n "}, {"sha": "024834bfe2aa558a9f252f7420b831dfd557d7a4", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -41,15 +41,15 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n             // some arbitrary byte value.\n             //\n             // FIXME: relay undef bytes to codegen as undef const bytes\n-            let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(next_offset..offset);\n+            let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(next_offset..offset);\n             llvals.push(cx.const_bytes(bytes));\n         }\n         let ptr_offset = read_target_uint(\n             dl.endian,\n             // This `inspect` is okay since it is within the bounds of the allocation, it doesn't\n             // affect interpreter execution (we inspect the result after interpreter execution),\n             // and we properly interpret the relocation as a relocation pointer offset.\n-            alloc.inspect_with_undef_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n+            alloc.inspect_with_uninit_and_ptr_outside_interpreter(offset..(offset + pointer_size)),\n         )\n         .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n             as u64;\n@@ -74,7 +74,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         // arbitrary byte value.\n         //\n         // FIXME: relay undef bytes to codegen as undef const bytes\n-        let bytes = alloc.inspect_with_undef_and_ptr_outside_interpreter(range);\n+        let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(range);\n         llvals.push(cx.const_bytes(bytes));\n     }\n \n@@ -452,7 +452,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                     // BSS.\n                     let all_bytes_are_zero = alloc.relocations().is_empty()\n                         && alloc\n-                            .inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len())\n+                            .inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len())\n                             .iter()\n                             .all(|&byte| byte == 0);\n \n@@ -480,7 +480,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                     // because we are doing this access to inspect the final interpreter state (not\n                     // as part of the interpreter execution).\n                     let bytes =\n-                        alloc.inspect_with_undef_and_ptr_outside_interpreter(0..alloc.len());\n+                        alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len());\n                     let alloc = llvm::LLVMMDStringInContext(\n                         self.llcx,\n                         bytes.as_ptr().cast(),"}, {"sha": "dfe90ae89e4cb2a9837e60e7d50ff2dcc88e3dd7", "filename": "src/librustc_error_codes/error_codes/E0749.md", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_error_codes%2Ferror_codes%2FE0749.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_error_codes%2Ferror_codes%2FE0749.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0749.md?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -11,9 +11,19 @@ trait MyTrait {\n impl !MyTrait for u32 {\n     type Foo = i32; // error!\n }\n-# fn main() {}\n ```\n \n Negative impls are not allowed to have any items. Negative impls declare that a\n trait is **not** implemented (and never will be) and hence there is no need to\n specify the values for trait methods or other items.\n+\n+One way to fix this is to remove the items in negative impls:\n+\n+```\n+# #![feature(negative_impls)]\n+trait MyTrait {\n+    type Foo;\n+}\n+\n+impl !MyTrait for u32 {}\n+```"}, {"sha": "ecc8a192f18ea9566ba9c49b8aec4f02b01348ae", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -481,25 +481,27 @@ trait UnusedDelimLint {\n             let mut err = lint.build(&span_msg);\n             let mut ate_left_paren = false;\n             let mut ate_right_paren = false;\n-            let parens_removed = pattern.trim_matches(|c| match c {\n-                '(' | '{' => {\n-                    if ate_left_paren {\n-                        false\n-                    } else {\n-                        ate_left_paren = true;\n-                        true\n+            let parens_removed = pattern\n+                .trim_matches(|c| match c {\n+                    '(' | '{' => {\n+                        if ate_left_paren {\n+                            false\n+                        } else {\n+                            ate_left_paren = true;\n+                            true\n+                        }\n                     }\n-                }\n-                ')' | '}' => {\n-                    if ate_right_paren {\n-                        false\n-                    } else {\n-                        ate_right_paren = true;\n-                        true\n+                    ')' | '}' => {\n+                        if ate_right_paren {\n+                            false\n+                        } else {\n+                            ate_right_paren = true;\n+                            true\n+                        }\n                     }\n-                }\n-                _ => false,\n-            });\n+                    _ => false,\n+                })\n+                .trim();\n \n             let replace = {\n                 let mut replace = if keep_space.0 {"}, {"sha": "b23deb2e3bc9b5fe75b368a32dade4c538a0dd72", "filename": "src/librustc_middle/mir/interpret/allocation.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -154,10 +154,10 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n     }\n \n     /// Looks at a slice which may describe uninitialized bytes or describe a relocation. This differs\n-    /// from `get_bytes_with_undef_and_ptr` in that it does no relocation checks (even on the\n+    /// from `get_bytes_with_uninit_and_ptr` in that it does no relocation checks (even on the\n     /// edges) at all. It further ignores `AllocationExtra` callbacks.\n     /// This must not be used for reads affecting the interpreter execution.\n-    pub fn inspect_with_undef_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n+    pub fn inspect_with_uninit_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n         &self.bytes[range]\n     }\n \n@@ -194,7 +194,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     /// The last argument controls whether we error out when there are uninitialized\n     /// or pointer bytes. You should never call this, call `get_bytes` or\n-    /// `get_bytes_with_undef_and_ptr` instead,\n+    /// `get_bytes_with_uninit_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n     /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n@@ -244,7 +244,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     #[inline]\n-    pub fn get_bytes_with_undef_and_ptr(\n+    pub fn get_bytes_with_uninit_and_ptr(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n@@ -302,19 +302,19 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n \n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n-    /// relocation. If `allow_ptr_and_undef` is `false`, also enforces that the memory in the\n+    /// relocation. If `allow_uninit_and_ptr` is `false`, also enforces that the memory in the\n     /// given range contains neither relocations nor uninitialized bytes.\n     pub fn check_bytes(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        allow_ptr_and_undef: bool,\n+        allow_uninit_and_ptr: bool,\n     ) -> InterpResult<'tcx> {\n         // Check bounds and relocations on the edges.\n-        self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n+        self.get_bytes_with_uninit_and_ptr(cx, ptr, size)?;\n         // Check uninit and ptr.\n-        if !allow_ptr_and_undef {\n+        if !allow_uninit_and_ptr {\n             self.check_init(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n         }\n@@ -361,7 +361,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         size: Size,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n         // `get_bytes_unchecked` tests relocation edges.\n-        let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n+        let bytes = self.get_bytes_with_uninit_and_ptr(cx, ptr, size)?;\n         // Uninit check happens *after* we established that the alignment is correct.\n         // We must not return `Ok()` for unaligned pointers!\n         if self.is_init(ptr, size).is_err() {\n@@ -594,7 +594,7 @@ impl InitMaskCompressed {\n /// Transferring the initialization mask to other allocations.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n     /// Creates a run-length encoding of the initialization mask.\n-    pub fn compress_undef_range(&self, src: Pointer<Tag>, size: Size) -> InitMaskCompressed {\n+    pub fn compress_uninit_range(&self, src: Pointer<Tag>, size: Size) -> InitMaskCompressed {\n         // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n         // a naive initialization mask copying algorithm would repeatedly have to read the initialization mask from\n         // the source and write it to the destination. Even if we optimized the memory accesses,\n@@ -636,8 +636,8 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         size: Size,\n         repeat: u64,\n     ) {\n-        // An optimization where we can just overwrite an entire range of definedness bits if\n-        // they are going to be uniformly `1` or `0`.\n+        // An optimization where we can just overwrite an entire range of initialization\n+        // bits if they are going to be uniformly `1` or `0`.\n         if defined.ranges.len() <= 1 {\n             self.init_mask.set_range_inbounds(\n                 dest.offset,"}, {"sha": "50c76e29663f66af14c4355652bd973b3da74030", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -58,7 +58,7 @@ impl<'tcx> ConstValue<'tcx> {\n \n     pub fn try_to_str_slice(&self) -> Option<&'tcx str> {\n         if let ConstValue::Slice { data, start, end } = *self {\n-            ::std::str::from_utf8(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n+            ::std::str::from_utf8(data.inspect_with_uninit_and_ptr_outside_interpreter(start..end))\n                 .ok()\n         } else {\n             None"}, {"sha": "87944db60de66d8e7b7ede44364d6756363e34bf", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -1107,7 +1107,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // The `inspect` here is okay since we checked the bounds, and there are\n                 // no relocations (we have an active slice reference here). We don't use\n                 // this result to affect interpreter execution.\n-                let byte_str = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                let byte_str = data.inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n                 self.pretty_print_byte_str(byte_str)\n             }\n             (\n@@ -1117,7 +1117,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // The `inspect` here is okay since we checked the bounds, and there are no\n                 // relocations (we have an active `str` reference here). We don't use this\n                 // result to affect interpreter execution.\n-                let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                let slice = data.inspect_with_uninit_and_ptr_outside_interpreter(start..end);\n                 let s = ::std::str::from_utf8(slice).expect(\"non utf8 str from miri\");\n                 p!(write(\"{:?}\", s));\n                 Ok(self)"}, {"sha": "3a753a0edb6659cf7a4a5043d88b716388b0dda3", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -301,6 +301,15 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Ok(())\n     }\n \n+    fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        // Enforce stack size limit.\n+        if !ecx.tcx.sess.recursion_limit().value_within_limit(ecx.stack().len()) {\n+            throw_exhaust!(StackFrameLimitReached)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     #[inline(always)]\n     fn stack(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,"}, {"sha": "bcf2899b439b5c85c50174bab64eac553cc27a31", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -687,11 +687,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         M::after_stack_push(self)?;\n         info!(\"ENTERING({}) {}\", self.frame_idx(), self.frame().instance);\n \n-        if !self.tcx.sess.recursion_limit().value_within_limit(self.stack().len()) {\n-            throw_exhaust!(StackFrameLimitReached)\n-        } else {\n-            Ok(())\n-        }\n+        Ok(())\n     }\n \n     /// Jump to the given block."}, {"sha": "705a547262f027463b157ab9ab736a4ac07ede49", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -926,7 +926,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,\n         // since we don't want to keep any relocations at the target.\n-        // (`get_bytes_with_undef_and_ptr` below checks that there are no\n+        // (`get_bytes_with_uninit_and_ptr` below checks that there are no\n         // relocations overlapping the edges; those would not be handled correctly).\n         let relocations =\n             self.get_raw(src.alloc_id)?.prepare_relocation_copy(self, src, size, dest, length);\n@@ -935,7 +935,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         // This checks relocation edges on the src.\n         let src_bytes =\n-            self.get_raw(src.alloc_id)?.get_bytes_with_undef_and_ptr(&tcx, src, size)?.as_ptr();\n+            self.get_raw(src.alloc_id)?.get_bytes_with_uninit_and_ptr(&tcx, src, size)?.as_ptr();\n         let dest_bytes =\n             self.get_raw_mut(dest.alloc_id)?.get_bytes_mut(&tcx, dest, size * length)?; // `Size` multiplication\n \n@@ -948,7 +948,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let dest_bytes = dest_bytes.as_mut_ptr();\n \n         // Prepare a copy of the initialization mask.\n-        let compressed = self.get_raw(src.alloc_id)?.compress_undef_range(src, size);\n+        let compressed = self.get_raw(src.alloc_id)?.compress_uninit_range(src, size);\n \n         if compressed.no_bytes_init() {\n             // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range"}, {"sha": "0b58caef54d2bf2cb7cc679d9e7e8ed27dae89f2", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -106,7 +106,7 @@ impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n                 }\n                 ScalarMaybeUninit::Uninit => cx.typed_value(\n                     |mut this| {\n-                        this.write_str(\"{undef \")?;\n+                        this.write_str(\"{uninit \")?;\n                         Ok(this)\n                     },\n                     |this| this.print_type(ty),"}, {"sha": "20fd8e43361d6561d9c3cb7c74e52c0d5ee8016b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -61,7 +61,7 @@ impl<Tag> MemPlaceMeta<Tag> {\n pub struct MemPlace<Tag = ()> {\n     /// A place may have an integral pointer for ZSTs, and since it might\n     /// be turned back into a reference before ever being dereferenced.\n-    /// However, it may never be undef.\n+    /// However, it may never be uninit.\n     pub ptr: Scalar<Tag>,\n     pub align: Align,\n     /// Metadata for unsized places. Interpretation is up to the type.\n@@ -729,7 +729,7 @@ where\n                         \"Size mismatch when writing bits\"\n                     )\n                 }\n-                Immediate::Scalar(ScalarMaybeUninit::Uninit) => {} // undef can have any size\n+                Immediate::Scalar(ScalarMaybeUninit::Uninit) => {} // uninit can have any size\n                 Immediate::ScalarPair(_, _) => {\n                     // FIXME: Can we check anything here?\n                 }"}, {"sha": "9cd20340138cf290bf539c05a9a9ecc9a7bb6e08", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -508,12 +508,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     }\n                 } else {\n                     // At run-time, for now, we accept *anything* for these types, including\n-                    // undef. We should fix that, but let's start low.\n+                    // uninit. We should fix that, but let's start low.\n                 }\n                 Ok(true)\n             }\n             ty::RawPtr(..) => {\n-                // We are conservative with undef for integers, but try to\n+                // We are conservative with uninit for integers, but try to\n                 // actually enforce the strict rules for raw pointers (mostly because\n                 // that lets us re-use `ref_to_mplace`).\n                 let place = try_validation!(\n@@ -807,12 +807,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // reject it.  However, that's good: We don't inherently want\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n-                // We also accept undef, for consistency with the slow path.\n+                // We also accept uninit, for consistency with the slow path.\n                 match self.ecx.memory.get_raw(ptr.alloc_id)?.check_bytes(\n                     self.ecx,\n                     ptr,\n                     size,\n-                    /*allow_ptr_and_undef*/ self.ref_tracking_for_consts.is_none(),\n+                    /*allow_uninit_and_ptr*/ self.ref_tracking_for_consts.is_none(),\n                 ) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {}"}, {"sha": "fc9f7f1af622f8e7508a81e9cd35b7c9401995c3", "filename": "src/librustc_mir/monomorphize/polymorphize.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -269,15 +269,21 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n                 self.unused_parameters.clear(param.index);\n                 false\n             }\n-            ty::ConstKind::Unevaluated(_, _, Some(p)) => {\n+            ty::ConstKind::Unevaluated(def, _, Some(p))\n+                // Avoid considering `T` unused when constants are of the form:\n+                //   `<Self as Foo<T>>::foo::promoted[p]`\n+                if self.def_id == def.did && !self.tcx.generics_of(def.did).has_self =>\n+            {\n                 // If there is a promoted, don't look at the substs - since it will always contain\n                 // the generic parameters, instead, traverse the promoted MIR.\n-                let promoted = self.tcx.promoted_mir(self.def_id);\n+                let promoted = self.tcx.promoted_mir(def.did);\n                 self.visit_body(&promoted[p]);\n                 false\n             }\n-            ty::ConstKind::Unevaluated(def_id, unevaluated_substs, None) => {\n-                self.visit_child_body(def_id.did, unevaluated_substs);\n+            ty::ConstKind::Unevaluated(def, unevaluated_substs, None)\n+                if self.tcx.def_kind(def.did) == DefKind::AnonConst =>\n+            {\n+                self.visit_child_body(def.did, unevaluated_substs);\n                 false\n             }\n             _ => c.super_visit_with(self),"}, {"sha": "07b13af6ba77678ab1b8a10c842b8837db87b18b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -1076,7 +1076,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 // ```rust\n                 // let mut x = 42;\n                 // x = SOME_MUTABLE_STATIC;\n-                // // x must now be undefined\n+                // // x must now be uninit\n                 // ```\n                 // FIXME: we overzealously erase the entire local, because that's easier to\n                 // implement."}, {"sha": "c3dbac08ed800faa53580d697845f03e0cdc6c16", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -743,8 +743,8 @@ fn write_allocation_bytes<Tag: Copy + Debug, Extra>(\n         if let Some(&(tag, target_id)) = alloc.relocations().get(&i) {\n             // Memory with a relocation must be defined\n             let j = i.bytes_usize();\n-            let offset =\n-                alloc.inspect_with_undef_and_ptr_outside_interpreter(j..j + ptr_size.bytes_usize());\n+            let offset = alloc\n+                .inspect_with_uninit_and_ptr_outside_interpreter(j..j + ptr_size.bytes_usize());\n             let offset = read_target_uint(tcx.data_layout.endian, offset).unwrap();\n             let offset = Size::from_bytes(offset);\n             let relocation_width = |bytes| bytes * 3;\n@@ -803,7 +803,7 @@ fn write_allocation_bytes<Tag: Copy + Debug, Extra>(\n \n             // Checked definedness (and thus range) and relocations. This access also doesn't\n             // influence interpreter execution but is only for debugging.\n-            let c = alloc.inspect_with_undef_and_ptr_outside_interpreter(j..j + 1)[0];\n+            let c = alloc.inspect_with_uninit_and_ptr_outside_interpreter(j..j + 1)[0];\n             write!(w, \"{:02x}\", c)?;\n             if c.is_ascii_control() || c >= 0x80 {\n                 ascii.push('.');"}, {"sha": "c57c0e51941854c0cdc5e5ceda2da66241295c1a", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -392,15 +392,15 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n     /// return the span of whole call and the span for all arguments expect the first one (`self`).\n     fn call_has_self_arg(&self, source: PathSource<'_>) -> Option<(Span, Option<Span>)> {\n         let mut has_self_arg = None;\n-        if let PathSource::Expr(parent) = source {\n-            match &parent?.kind {\n+        if let PathSource::Expr(Some(parent)) = source {\n+            match &parent.kind {\n                 ExprKind::Call(_, args) if !args.is_empty() => {\n                     let mut expr_kind = &args[0].kind;\n                     loop {\n                         match expr_kind {\n                             ExprKind::Path(_, arg_name) if arg_name.segments.len() == 1 => {\n                                 if arg_name.segments[0].ident.name == kw::SelfLower {\n-                                    let call_span = parent.unwrap().span;\n+                                    let call_span = parent.span;\n                                     let tail_args_span = if args.len() > 1 {\n                                         Some(Span::new(\n                                             args[1].span.lo(),"}, {"sha": "1c78bef98527a6b988e4fe3363834d51747522ae", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -1229,8 +1229,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Applicability::MaybeIncorrect,\n                     );\n \n-                    // we don't want to throw `E0027` in case we have thrown `E0026` for them\n-                    unmentioned_fields.retain(|&x| x.name != suggested_name);\n+                    // When we have a tuple struct used with struct we don't want to suggest using\n+                    // the (valid) struct syntax with numeric field names. Instead we want to\n+                    // suggest the expected syntax. We infer that this is the case by parsing the\n+                    // `Ident` into an unsized integer. The suggestion will be emitted elsewhere in\n+                    // `smart_resolve_context_dependent_help`.\n+                    if suggested_name.to_ident_string().parse::<usize>().is_err() {\n+                        // We don't want to throw `E0027` in case we have thrown `E0026` for them.\n+                        unmentioned_fields.retain(|&x| x.name != suggested_name);\n+                    }\n                 }\n             }\n         }"}, {"sha": "363575396928649a963020ac37e5222f2ef68fde", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -1903,23 +1903,41 @@ fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n     }\n }\n \n-fn name_key(name: &str) -> (&str, u64, usize) {\n-    let end = name.bytes().rposition(|b| b.is_ascii_digit()).map_or(name.len(), |i| i + 1);\n-\n-    // find number at end\n-    let split = name[0..end].bytes().rposition(|b| !b.is_ascii_digit()).map_or(0, |i| i + 1);\n-\n-    // count leading zeroes\n-    let after_zeroes =\n-        name[split..end].bytes().position(|b| b != b'0').map_or(name.len(), |extra| split + extra);\n-\n-    // sort leading zeroes last\n-    let num_zeroes = after_zeroes - split;\n-\n-    match name[split..end].parse() {\n-        Ok(n) => (&name[..split], n, num_zeroes),\n-        Err(_) => (name, 0, num_zeroes),\n+/// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).\n+pub fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n+    /// Takes a non-numeric and a numeric part from the given &str.\n+    fn take_parts<'a>(s: &mut &'a str) -> (&'a str, &'a str) {\n+        let i = s.find(|c: char| c.is_ascii_digit());\n+        let (a, b) = s.split_at(i.unwrap_or(s.len()));\n+        let i = b.find(|c: char| !c.is_ascii_digit());\n+        let (b, c) = b.split_at(i.unwrap_or(b.len()));\n+        *s = c;\n+        (a, b)\n+    }\n+\n+    while !lhs.is_empty() || !rhs.is_empty() {\n+        let (la, lb) = take_parts(&mut lhs);\n+        let (ra, rb) = take_parts(&mut rhs);\n+        // First process the non-numeric part.\n+        match la.cmp(ra) {\n+            Ordering::Equal => (),\n+            x => return x,\n+        }\n+        // Then process the numeric part, if both sides have one (and they fit in a u64).\n+        if let (Ok(ln), Ok(rn)) = (lb.parse::<u64>(), rb.parse::<u64>()) {\n+            match ln.cmp(&rn) {\n+                Ordering::Equal => (),\n+                x => return x,\n+            }\n+        }\n+        // Then process the numeric part again, but this time as strings.\n+        match lb.cmp(rb) {\n+            Ordering::Equal => (),\n+            x => return x,\n+        }\n     }\n+\n+    Ordering::Equal\n }\n \n fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean::Item]) {\n@@ -1962,7 +1980,7 @@ fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean:\n         }\n         let lhs = i1.name.as_ref().map_or(\"\", |s| &**s);\n         let rhs = i2.name.as_ref().map_or(\"\", |s| &**s);\n-        name_key(lhs).cmp(&name_key(rhs))\n+        compare_names(lhs, rhs)\n     }\n \n     if cx.shared.sort_modules_alphabetically {\n@@ -2395,7 +2413,7 @@ fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n     let rhs = format!(\"{}\", rhs.inner_impl().print());\n \n     // lhs and rhs are formatted as HTML, which may be unnecessary\n-    name_key(&lhs).cmp(&name_key(&rhs))\n+    compare_names(&lhs, &rhs)\n }\n \n fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait, cache: &Cache) {"}, {"sha": "abf5f05fe58ab71e7f553f4a276278efbf6a1088", "filename": "src/librustdoc/html/render/tests.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Ftests.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -1,24 +1,40 @@\n use super::*;\n \n #[test]\n-fn test_name_key() {\n-    assert_eq!(name_key(\"0\"), (\"\", 0, 1));\n-    assert_eq!(name_key(\"123\"), (\"\", 123, 0));\n-    assert_eq!(name_key(\"Fruit\"), (\"Fruit\", 0, 0));\n-    assert_eq!(name_key(\"Fruit0\"), (\"Fruit\", 0, 1));\n-    assert_eq!(name_key(\"Fruit0000\"), (\"Fruit\", 0, 4));\n-    assert_eq!(name_key(\"Fruit01\"), (\"Fruit\", 1, 1));\n-    assert_eq!(name_key(\"Fruit10\"), (\"Fruit\", 10, 0));\n-    assert_eq!(name_key(\"Fruit123\"), (\"Fruit\", 123, 0));\n+fn test_compare_names() {\n+    for &(a, b) in &[\n+        (\"hello\", \"world\"),\n+        (\"\", \"world\"),\n+        (\"123\", \"hello\"),\n+        (\"123\", \"\"),\n+        (\"123test\", \"123\"),\n+        (\"hello\", \"\"),\n+        (\"hello\", \"hello\"),\n+        (\"hello123\", \"hello123\"),\n+        (\"hello123\", \"hello12\"),\n+        (\"hello12\", \"hello123\"),\n+        (\"hello01abc\", \"hello01xyz\"),\n+        (\"hello0abc\", \"hello0\"),\n+        (\"hello0\", \"hello0abc\"),\n+        (\"01\", \"1\"),\n+    ] {\n+        assert_eq!(compare_names(a, b), a.cmp(b), \"{:?} - {:?}\", a, b);\n+    }\n+    assert_eq!(compare_names(\"u8\", \"u16\"), Ordering::Less);\n+    assert_eq!(compare_names(\"u32\", \"u16\"), Ordering::Greater);\n+    assert_eq!(compare_names(\"u8_to_f64\", \"u16_to_f64\"), Ordering::Less);\n+    assert_eq!(compare_names(\"u32_to_f64\", \"u16_to_f64\"), Ordering::Greater);\n+    assert_eq!(compare_names(\"u16_to_f64\", \"u16_to_f64\"), Ordering::Equal);\n+    assert_eq!(compare_names(\"u16_to_f32\", \"u16_to_f64\"), Ordering::Less);\n }\n \n #[test]\n fn test_name_sorting() {\n     let names = [\n-        \"Apple\", \"Banana\", \"Fruit\", \"Fruit0\", \"Fruit00\", \"Fruit1\", \"Fruit01\", \"Fruit2\", \"Fruit02\",\n+        \"Apple\", \"Banana\", \"Fruit\", \"Fruit0\", \"Fruit00\", \"Fruit01\", \"Fruit1\", \"Fruit02\", \"Fruit2\",\n         \"Fruit20\", \"Fruit30x\", \"Fruit100\", \"Pear\",\n     ];\n     let mut sorted = names.to_owned();\n-    sorted.sort_by_key(|&s| name_key(s));\n+    sorted.sort_by(|&l, r| compare_names(l, r));\n     assert_eq!(names, sorted);\n }"}, {"sha": "836f26efc9601e7df2c5e00dc6e4c8c1e029c9e5", "filename": "src/test/ui/const-generics/unused_braces.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.fixed?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -10,6 +10,6 @@ struct A<const N: usize>;\n \n fn main() {\n     let _: A<7>; // ok\n-    let _: A< 7 >; //~ WARN unnecessary braces\n+    let _: A<7>; //~ WARN unnecessary braces\n     let _: A<{ 3 + 5 }>; // ok\n }"}, {"sha": "5254f45d7c2de7cea3a35418c00b24c10b900e8c", "filename": "src/test/ui/issues/issue-17800.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Fissues%2Fissue-17800.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Fissues%2Fissue-17800.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17800.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -6,7 +6,7 @@ enum MyOption<T> {\n fn main() {\n     match MyOption::MySome(42) {\n         MyOption::MySome { x: 42 } => (),\n-        //~^ ERROR variant `MyOption::MySome` does not have a field named `x`\n+        //~^ ERROR tuple variant `MyOption::MySome` written as struct variant\n         _ => (),\n     }\n }"}, {"sha": "fc034a0cbf3b8120fd2f081a395fa3b3fcda5d66", "filename": "src/test/ui/issues/issue-17800.stderr", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Fissues%2Fissue-17800.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Fissues%2Fissue-17800.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17800.stderr?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -1,12 +1,9 @@\n-error[E0026]: variant `MyOption::MySome` does not have a field named `x`\n-  --> $DIR/issue-17800.rs:8:28\n+error[E0769]: tuple variant `MyOption::MySome` written as struct variant\n+  --> $DIR/issue-17800.rs:8:9\n    |\n LL |         MyOption::MySome { x: 42 } => (),\n-   |                            ^\n-   |                            |\n-   |                            variant `MyOption::MySome` does not have this field\n-   |                            help: a field with a similar name exists: `0`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the tuple variant pattern syntax instead: `MyOption::MySome(42)`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0026`.\n+For more information about this error, try `rustc --explain E0769`."}, {"sha": "1a88d985dd86a6438bf0b6847895a8255c24d5fa", "filename": "src/test/ui/lint/unused_braces.fixed", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Flint%2Funused_braces.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Flint%2Funused_braces.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_braces.fixed?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -23,18 +23,18 @@ fn main() {\n         }\n     }\n \n-    if  true  {\n+    if true {\n         //~^ WARN unnecessary braces\n     }\n \n-    while  false  {\n+    while false {\n         //~^ WARN unnecessary braces\n     }\n \n-    let _: [u8;  3 ];\n+    let _: [u8; 3];\n     //~^ WARN unnecessary braces\n \n-    consume( 7 );\n+    consume(7);\n     //~^ WARN unnecessary braces\n \n     // Do not emit lint for multiline blocks."}, {"sha": "583506f891d019af04aaa5cafe08a2eda050fee2", "filename": "src/test/ui/lint/unused_braces_borrow.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Flint%2Funused_braces_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Flint%2Funused_braces_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_braces_borrow.fixed?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -21,6 +21,6 @@ fn main() {\n     };\n \n     consume(&{ a.b });\n-    consume( a.b );\n+    consume(a.b);\n     //~^ WARN unnecessary braces\n }"}, {"sha": "1c84df13e10b00f8fb13676babd6d18063939cde", "filename": "src/test/ui/polymorphization/promoted-function-3.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Fpolymorphization%2Fpromoted-function-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Fpolymorphization%2Fpromoted-function-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpolymorphization%2Fpromoted-function-3.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+// compile-flags: -Zpolymorphize=on -Zmir-opt-level=3\n+\n+fn caller<T, U>() -> &'static usize {\n+    callee::<U>()\n+}\n+\n+fn callee<T>() -> &'static usize {\n+    &std::mem::size_of::<T>()\n+}\n+\n+fn main() {\n+    assert_eq!(caller::<(), ()>(), &0);\n+}"}, {"sha": "756081738c3d7403423d8bee9f97a493c0ea7fd1", "filename": "src/test/ui/try-block/try-block-unused-delims.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unused-delims.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unused-delims.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unused-delims.fixed?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     consume(try {});\n     //~^ WARN unnecessary parentheses\n \n-    consume( try {} );\n+    consume(try {});\n     //~^ WARN unnecessary braces\n \n     match try {} {"}, {"sha": "c77b80bc23733e1b4495e07f78c1210eafd388c4", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9ac5161781ca6a376daab3d3b2f2623d8f3789/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=4b9ac5161781ca6a376daab3d3b2f2623d8f3789", "patch": "@@ -517,7 +517,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n         ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind {\n             ty::Ref(_, tam, _) => match tam.kind {\n                 ty::Str => String::from_utf8(\n-                    data.inspect_with_undef_and_ptr_outside_interpreter(start..end)\n+                    data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n                         .to_owned(),\n                 )\n                 .ok()\n@@ -530,7 +530,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n             ty::Array(sub_type, len) => match sub_type.kind {\n                 ty::Float(FloatTy::F32) => match miri_to_const(len) {\n                     Some(Constant::Int(len)) => alloc\n-                        .inspect_with_undef_and_ptr_outside_interpreter(0..(4 * len as usize))\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n                         .to_owned()\n                         .chunks(4)\n                         .map(|chunk| {\n@@ -544,7 +544,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n                 },\n                 ty::Float(FloatTy::F64) => match miri_to_const(len) {\n                     Some(Constant::Int(len)) => alloc\n-                        .inspect_with_undef_and_ptr_outside_interpreter(0..(8 * len as usize))\n+                        .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n                         .to_owned()\n                         .chunks(8)\n                         .map(|chunk| {"}]}