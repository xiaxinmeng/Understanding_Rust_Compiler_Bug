{"sha": "bd903bf132dfc188e2f4c634a8b457ab4d7d4852", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkOTAzYmYxMzJkZmMxODhlMmY0YzYzNGE4YjQ1N2FiNGQ3ZDQ4NTI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-26T14:17:22Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-26T14:20:46Z"}, "message": "Be more precise about flycheck status", "tree": {"sha": "f612a3df1286f97e39d93bfdeda99cbf64dfa34f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f612a3df1286f97e39d93bfdeda99cbf64dfa34f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd903bf132dfc188e2f4c634a8b457ab4d7d4852", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd903bf132dfc188e2f4c634a8b457ab4d7d4852", "html_url": "https://github.com/rust-lang/rust/commit/bd903bf132dfc188e2f4c634a8b457ab4d7d4852", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd903bf132dfc188e2f4c634a8b457ab4d7d4852/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce06f8d0416d5851264769eb9583ce43d66f0474", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce06f8d0416d5851264769eb9583ce43d66f0474", "html_url": "https://github.com/rust-lang/rust/commit/ce06f8d0416d5851264769eb9583ce43d66f0474"}], "stats": {"total": 105, "additions": 38, "deletions": 67}, "files": [{"sha": "92ec4f92e3102fab0eae76d65c0ac1db37a2a9d7", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 30, "deletions": 62, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bd903bf132dfc188e2f4c634a8b457ab4d7d4852/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd903bf132dfc188e2f4c634a8b457ab4d7d4852/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=bd903bf132dfc188e2f4c634a8b457ab4d7d4852", "patch": "@@ -7,7 +7,7 @@ use std::{\n     io::{self, BufReader},\n     path::PathBuf,\n     process::{Command, Stdio},\n-    time::Instant,\n+    time::Duration,\n };\n \n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n@@ -74,9 +74,6 @@ impl FlycheckHandle {\n \n #[derive(Debug)]\n pub enum Message {\n-    /// Request a clearing of all cached diagnostics from the check watcher\n-    ClearDiagnostics,\n-\n     /// Request adding a diagnostic with fixes included to a file\n     AddDiagnostic { workspace_root: PathBuf, diagnostic: Diagnostic },\n \n@@ -86,9 +83,10 @@ pub enum Message {\n \n #[derive(Debug)]\n pub enum Progress {\n-    Being,\n+    DidStart,\n     DidCheckCrate(String),\n-    End,\n+    DidFinish,\n+    DidCancel,\n }\n \n struct Restart;\n@@ -97,19 +95,18 @@ struct FlycheckActor {\n     sender: Box<dyn Fn(Message) + Send>,\n     config: FlycheckConfig,\n     workspace_root: PathBuf,\n-    last_update_req: Option<Instant>,\n     /// WatchThread exists to wrap around the communication needed to be able to\n     /// run `cargo check` without blocking. Currently the Rust standard library\n     /// doesn't provide a way to read sub-process output without blocking, so we\n     /// have to wrap sub-processes output handling in a thread and pass messages\n     /// back over a channel.\n     // XXX: drop order is significant\n-    check_process: Option<(Receiver<CheckEvent>, jod_thread::JoinHandle)>,\n+    check_process: Option<(Receiver<cargo_metadata::Message>, jod_thread::JoinHandle)>,\n }\n \n enum Event {\n     Restart(Restart),\n-    CheckEvent(Option<CheckEvent>),\n+    CheckEvent(Option<cargo_metadata::Message>),\n }\n \n impl FlycheckActor {\n@@ -118,7 +115,7 @@ impl FlycheckActor {\n         config: FlycheckConfig,\n         workspace_root: PathBuf,\n     ) -> FlycheckActor {\n-        FlycheckActor { sender, config, workspace_root, last_update_req: None, check_process: None }\n+        FlycheckActor { sender, config, workspace_root, check_process: None }\n     }\n     fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n         let check_chan = self.check_process.as_ref().map(|(chan, _thread)| chan);\n@@ -128,65 +125,48 @@ impl FlycheckActor {\n         }\n     }\n     fn run(&mut self, inbox: Receiver<Restart>) {\n-        // If we rerun the thread, we need to discard the previous check results first\n-        self.send(Message::ClearDiagnostics);\n-        self.send(Message::Progress(Progress::End));\n-\n         while let Some(event) = self.next_event(&inbox) {\n             match event {\n-                Event::Restart(Restart) => self.last_update_req = Some(Instant::now()),\n+                Event::Restart(Restart) => {\n+                    while let Ok(Restart) = inbox.recv_timeout(Duration::from_millis(50)) {}\n+                    self.cancel_check_process();\n+                    self.check_process = Some(self.start_check_process());\n+                    self.send(Message::Progress(Progress::DidStart));\n+                }\n                 Event::CheckEvent(None) => {\n                     // Watcher finished, replace it with a never channel to\n                     // avoid busy-waiting.\n-                    self.check_process = None;\n+                    assert!(self.check_process.take().is_some());\n+                    self.send(Message::Progress(Progress::DidFinish));\n                 }\n-                Event::CheckEvent(Some(event)) => match event {\n-                    CheckEvent::Begin => {\n-                        self.send(Message::Progress(Progress::Being));\n-                    }\n-\n-                    CheckEvent::End => {\n-                        self.send(Message::Progress(Progress::End));\n-                    }\n-\n-                    CheckEvent::Msg(cargo_metadata::Message::CompilerArtifact(msg)) => {\n+                Event::CheckEvent(Some(message)) => match message {\n+                    cargo_metadata::Message::CompilerArtifact(msg) => {\n                         self.send(Message::Progress(Progress::DidCheckCrate(msg.target.name)));\n                     }\n \n-                    CheckEvent::Msg(cargo_metadata::Message::CompilerMessage(msg)) => {\n+                    cargo_metadata::Message::CompilerMessage(msg) => {\n                         self.send(Message::AddDiagnostic {\n                             workspace_root: self.workspace_root.clone(),\n                             diagnostic: msg.message,\n                         });\n                     }\n \n-                    CheckEvent::Msg(cargo_metadata::Message::BuildScriptExecuted(_))\n-                    | CheckEvent::Msg(cargo_metadata::Message::BuildFinished(_))\n-                    | CheckEvent::Msg(cargo_metadata::Message::TextLine(_))\n-                    | CheckEvent::Msg(cargo_metadata::Message::Unknown) => {}\n+                    cargo_metadata::Message::BuildScriptExecuted(_)\n+                    | cargo_metadata::Message::BuildFinished(_)\n+                    | cargo_metadata::Message::TextLine(_)\n+                    | cargo_metadata::Message::Unknown => {}\n                 },\n             }\n-            if self.should_recheck() {\n-                self.last_update_req = None;\n-                self.send(Message::ClearDiagnostics);\n-                self.restart_check_process();\n-            }\n         }\n+        // If we rerun the thread, we need to discard the previous check results first\n+        self.cancel_check_process();\n     }\n-    fn should_recheck(&mut self) -> bool {\n-        if let Some(_last_update_req) = &self.last_update_req {\n-            // We currently only request an update on save, as we need up to\n-            // date source on disk for cargo check to do it's magic, so we\n-            // don't really need to debounce the requests at this point.\n-            return true;\n+    fn cancel_check_process(&mut self) {\n+        if self.check_process.take().is_some() {\n+            self.send(Message::Progress(Progress::DidCancel));\n         }\n-        false\n     }\n-\n-    fn restart_check_process(&mut self) {\n-        // First, clear and cancel the old thread\n-        self.check_process = None;\n-\n+    fn start_check_process(&self) -> (Receiver<cargo_metadata::Message>, jod_thread::JoinHandle) {\n         let mut cmd = match &self.config {\n             FlycheckConfig::CargoCommand {\n                 command,\n@@ -223,8 +203,6 @@ impl FlycheckActor {\n         let thread = jod_thread::spawn(move || {\n             // If we trigger an error here, we will do so in the loop instead,\n             // which will break out of the loop, and continue the shutdown\n-            let _ = message_send.send(CheckEvent::Begin);\n-\n             let res = run_cargo(cmd, &mut |message| {\n                 // Skip certain kinds of messages to only spend time on what's useful\n                 match &message {\n@@ -237,33 +215,23 @@ impl FlycheckActor {\n                 }\n \n                 // if the send channel was closed, we want to shutdown\n-                message_send.send(CheckEvent::Msg(message)).is_ok()\n+                message_send.send(message).is_ok()\n             });\n \n             if let Err(err) = res {\n                 // FIXME: make the `message_send` to be `Sender<Result<CheckEvent, CargoError>>`\n                 // to display user-caused misconfiguration errors instead of just logging them here\n                 log::error!(\"Cargo watcher failed {:?}\", err);\n             }\n-\n-            // We can ignore any error here, as we are already in the progress\n-            // of shutting down.\n-            let _ = message_send.send(CheckEvent::End);\n         });\n-        self.check_process = Some((message_recv, thread))\n+        (message_recv, thread)\n     }\n \n     fn send(&self, check_task: Message) {\n         (self.sender)(check_task)\n     }\n }\n \n-enum CheckEvent {\n-    Begin,\n-    Msg(cargo_metadata::Message),\n-    End,\n-}\n-\n fn run_cargo(\n     mut command: Command,\n     on_message: &mut dyn FnMut(cargo_metadata::Message) -> bool,"}, {"sha": "ed3d27750122d834d8834be2be873a223fc4b3b4", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bd903bf132dfc188e2f4c634a8b457ab4d7d4852/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd903bf132dfc188e2f4c634a8b457ab4d7d4852/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=bd903bf132dfc188e2f4c634a8b457ab4d7d4852", "patch": "@@ -191,8 +191,6 @@ impl GlobalState {\n                 }\n             },\n             Event::Flycheck(task) => match task {\n-                flycheck::Message::ClearDiagnostics => self.diagnostics.clear_check(),\n-\n                 flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n                     let diagnostics = crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n                         &self.config.diagnostics,\n@@ -215,11 +213,16 @@ impl GlobalState {\n \n                 flycheck::Message::Progress(status) => {\n                     let (state, message) = match status {\n-                        flycheck::Progress::Being => (Progress::Begin, None),\n+                        flycheck::Progress::DidStart => {\n+                            self.diagnostics.clear_check();\n+                            (Progress::Begin, None)\n+                        },\n                         flycheck::Progress::DidCheckCrate(target) => {\n                             (Progress::Report, Some(target))\n                         }\n-                        flycheck::Progress::End => (Progress::End, None),\n+                        flycheck::Progress::DidFinish | flycheck::Progress::DidCancel => {\n+                            (Progress::End, None)\n+                        }\n                     };\n \n                     report_progress(self, \"cargo check\", state, message, None);\n@@ -466,7 +469,7 @@ impl GlobalState {\n     }\n }\n \n-#[derive(Eq, PartialEq)]\n+#[derive(Debug, Eq, PartialEq)]\n enum Progress {\n     Begin,\n     Report,"}]}