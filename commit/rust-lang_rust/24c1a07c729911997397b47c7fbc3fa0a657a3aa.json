{"sha": "24c1a07c729911997397b47c7fbc3fa0a657a3aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YzFhMDdjNzI5OTExOTk3Mzk3YjQ3YzdmYmMzZmEwYTY1N2EzYWE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-10T23:01:25Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-28T07:43:24Z"}, "message": "refactor trans::mir::block to trans all calls through the same code", "tree": {"sha": "6be06f0351d7e71ac0b3a2f466b0f56dbdb5a1f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6be06f0351d7e71ac0b3a2f466b0f56dbdb5a1f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24c1a07c729911997397b47c7fbc3fa0a657a3aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24c1a07c729911997397b47c7fbc3fa0a657a3aa", "html_url": "https://github.com/rust-lang/rust/commit/24c1a07c729911997397b47c7fbc3fa0a657a3aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24c1a07c729911997397b47c7fbc3fa0a657a3aa/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9da2aaccfe7dd3452dd066bbc3829af6bd76ace4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4", "html_url": "https://github.com/rust-lang/rust/commit/9da2aaccfe7dd3452dd066bbc3829af6bd76ace4"}], "stats": {"total": 151, "additions": 84, "deletions": 67}, "files": [{"sha": "120f201a9c8b73ef6bd4a93f079f96cc1cf5094a", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24c1a07c729911997397b47c7fbc3fa0a657a3aa/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c1a07c729911997397b47c7fbc3fa0a657a3aa/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=24c1a07c729911997397b47c7fbc3fa0a657a3aa", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef, AttributePlace};\n use base;\n use builder::Builder;\n-use common::{type_is_fat_ptr, C_uint};\n+use common::{instance_ty, ty_fn_sig, type_is_fat_ptr, C_uint};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -610,6 +610,14 @@ pub struct FnType<'tcx> {\n }\n \n impl<'a, 'tcx> FnType<'tcx> {\n+    pub fn of_instance(ccx: &CrateContext<'a, 'tcx>, instance: &ty::Instance<'tcx>)\n+                       -> Self {\n+        let fn_ty = instance_ty(ccx.shared(), &instance);\n+        let sig = ty_fn_sig(ccx, fn_ty);\n+        let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+        Self::new(ccx, sig, &[])\n+    }\n+\n     pub fn new(ccx: &CrateContext<'a, 'tcx>,\n                sig: ty::FnSig<'tcx>,\n                extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n@@ -631,6 +639,8 @@ impl<'a, 'tcx> FnType<'tcx> {\n     pub fn unadjusted(ccx: &CrateContext<'a, 'tcx>,\n                       sig: ty::FnSig<'tcx>,\n                       extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n+        debug!(\"FnType::unadjusted({:?}, {:?})\", sig, extra_args);\n+\n         use self::Abi::*;\n         let cconv = match ccx.sess().target.target.adjust_abi(sig.abi) {\n             RustIntrinsic | PlatformIntrinsic |"}, {"sha": "f6c8ee0c82564c6f2ea113b8aba144aaf5b23aa9", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 73, "deletions": 66, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/24c1a07c729911997397b47c7fbc3fa0a657a3aa/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24c1a07c729911997397b47c7fbc3fa0a657a3aa/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=24c1a07c729911997397b47c7fbc3fa0a657a3aa", "patch": "@@ -53,7 +53,23 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             _ => funclets[bb].as_ref(),\n         };\n \n+        for statement in &data.statements {\n+            bcx = self.trans_statement(bcx, statement);\n+        }\n+\n+        self.trans_terminator(bcx, bb, data.terminator(), funclet);\n+    }\n+\n+    fn trans_terminator(&mut self,\n+                        mut bcx: Builder<'a, 'tcx>,\n+                        bb: mir::BasicBlock,\n+                        terminator: &mir::Terminator<'tcx>,\n+                        funclet: Option<&Funclet>)\n+    {\n+        debug!(\"trans_terminator: {:?}\", terminator);\n+\n         // Create the cleanup bundle, if needed.\n+        let tcx = bcx.tcx();\n         let cleanup_pad = funclet.map(|lp| lp.cleanuppad());\n         let cleanup_bundle = funclet.map(|l| l.bundle());\n \n@@ -104,12 +120,53 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n         };\n \n-        for statement in &data.statements {\n-            bcx = self.trans_statement(bcx, statement);\n-        }\n+        let do_call = |\n+            this: &mut Self,\n+            bcx: Builder<'a, 'tcx>,\n+            fn_ty: FnType<'tcx>,\n+            fn_ptr: ValueRef,\n+            llargs: &[ValueRef],\n+            destination: Option<(ReturnDest, ty::Ty<'tcx>, mir::BasicBlock)>,\n+            cleanup: Option<mir::BasicBlock>\n+        | {\n+            if let Some(cleanup) = cleanup {\n+                let ret_bcx = if let Some((_, _, target)) = destination {\n+                    this.blocks[target]\n+                } else {\n+                    this.unreachable_block()\n+                };\n+                let invokeret = bcx.invoke(fn_ptr,\n+                                           &llargs,\n+                                           ret_bcx,\n+                                           llblock(this, cleanup),\n+                                           cleanup_bundle);\n+                fn_ty.apply_attrs_callsite(invokeret);\n+\n+                if let Some((ret_dest, ret_ty, target)) = destination {\n+                    let ret_bcx = this.get_builder(target);\n+                    this.set_debug_loc(&ret_bcx, terminator.source_info);\n+                    let op = OperandRef {\n+                        val: Immediate(invokeret),\n+                        ty: ret_ty,\n+                    };\n+                    this.store_return(&ret_bcx, ret_dest, &fn_ty.ret, op);\n+                }\n+            } else {\n+                let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n+                fn_ty.apply_attrs_callsite(llret);\n \n-        let terminator = data.terminator();\n-        debug!(\"trans_block: terminator: {:?}\", terminator);\n+                if let Some((ret_dest, ret_ty, target)) = destination {\n+                    let op = OperandRef {\n+                        val: Immediate(llret),\n+                        ty: ret_ty,\n+                    };\n+                    this.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n+                    funclet_br(this, bcx, target);\n+                } else {\n+                    bcx.unreachable();\n+                }\n+            }\n+        };\n \n         let span = terminator.source_info.span;\n         self.set_debug_loc(&bcx, terminator.source_info);\n@@ -218,24 +275,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n \n                 let lvalue = self.trans_lvalue(&bcx, location);\n+                let fn_ty = FnType::of_instance(bcx.ccx, &drop_fn);\n                 let (drop_fn, need_extra) = match ty.sty {\n                     ty::TyDynamic(..) => (meth::DESTRUCTOR.get_fn(&bcx, lvalue.llextra),\n                                           false),\n                     _ => (callee::get_fn(bcx.ccx, drop_fn), lvalue.has_extra())\n                 };\n                 let args = &[lvalue.llval, lvalue.llextra][..1 + need_extra as usize];\n-                if let Some(unwind) = unwind {\n-                    bcx.invoke(\n-                        drop_fn,\n-                        args,\n-                        self.blocks[target],\n-                        llblock(self, unwind),\n-                        cleanup_bundle\n-                    );\n-                } else {\n-                    bcx.call(drop_fn, args, cleanup_bundle);\n-                    funclet_br(self, bcx, target);\n-                }\n+                do_call(self, bcx, fn_ty, drop_fn, args,\n+                        Some((ReturnDest::Nothing, tcx.mk_nil(), target)),\n+                        unwind);\n             }\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n@@ -342,26 +391,18 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // Obtain the panic entry point.\n                 let def_id = common::langcall(bcx.tcx(), Some(span), \"\", lang_item);\n                 let instance = ty::Instance::mono(bcx.tcx(), def_id);\n+                let fn_ty = FnType::of_instance(bcx.ccx, &instance);\n                 let llfn = callee::get_fn(bcx.ccx, instance);\n \n                 // Translate the actual panic invoke/call.\n-                if let Some(unwind) = cleanup {\n-                    bcx.invoke(llfn,\n-                               &args,\n-                               self.unreachable_block(),\n-                               llblock(self, unwind),\n-                               cleanup_bundle);\n-                } else {\n-                    bcx.call(llfn, &args, cleanup_bundle);\n-                    bcx.unreachable();\n-                }\n+                do_call(self, bcx, fn_ty, llfn, &args, None, cleanup);\n             }\n \n             mir::TerminatorKind::DropAndReplace { .. } => {\n-                bug!(\"undesugared DropAndReplace in trans: {:?}\", data);\n+                bug!(\"undesugared DropAndReplace in trans: {:?}\", terminator);\n             }\n \n-            mir::TerminatorKind::Call { ref func, ref args, ref destination, ref cleanup } => {\n+            mir::TerminatorKind::Call { ref func, ref args, ref destination, cleanup } => {\n                 // Create the callee. This is a fn ptr or zero-sized and hence a kind of scalar.\n                 let callee = self.trans_operand(&bcx, func);\n \n@@ -514,43 +555,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     _ => span_bug!(span, \"no llfn for call\"),\n                 };\n \n-                // Many different ways to call a function handled here\n-                if let &Some(cleanup) = cleanup {\n-                    let ret_bcx = if let Some((_, target)) = *destination {\n-                        self.blocks[target]\n-                    } else {\n-                        self.unreachable_block()\n-                    };\n-                    let invokeret = bcx.invoke(fn_ptr,\n-                                               &llargs,\n-                                               ret_bcx,\n-                                               llblock(self, cleanup),\n-                                               cleanup_bundle);\n-                    fn_ty.apply_attrs_callsite(invokeret);\n-\n-                    if let Some((_, target)) = *destination {\n-                        let ret_bcx = self.get_builder(target);\n-                        self.set_debug_loc(&ret_bcx, terminator.source_info);\n-                        let op = OperandRef {\n-                            val: Immediate(invokeret),\n-                            ty: sig.output(),\n-                        };\n-                        self.store_return(&ret_bcx, ret_dest, &fn_ty.ret, op);\n-                    }\n-                } else {\n-                    let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n-                    fn_ty.apply_attrs_callsite(llret);\n-                    if let Some((_, target)) = *destination {\n-                        let op = OperandRef {\n-                            val: Immediate(llret),\n-                            ty: sig.output(),\n-                        };\n-                        self.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n-                        funclet_br(self, bcx, target);\n-                    } else {\n-                        bcx.unreachable();\n-                    }\n-                }\n+                do_call(self, bcx, fn_ty, fn_ptr, &llargs,\n+                        destination.as_ref().map(|&(_, target)| (ret_dest, sig.output(), target)),\n+                        cleanup);\n             }\n         }\n     }"}]}