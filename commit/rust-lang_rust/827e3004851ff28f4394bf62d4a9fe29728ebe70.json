{"sha": "827e3004851ff28f4394bf62d4a9fe29728ebe70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyN2UzMDA0ODUxZmYyOGY0Mzk0YmY2MmQ0YTlmZTI5NzI4ZWJlNzA=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-15T00:33:02Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-15T00:33:28Z"}, "message": "refactor: Move the task and communication-related translation functions to a new module.", "tree": {"sha": "a51b40dbd3368124c13b67a4bde3634399d23dbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a51b40dbd3368124c13b67a4bde3634399d23dbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/827e3004851ff28f4394bf62d4a9fe29728ebe70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/827e3004851ff28f4394bf62d4a9fe29728ebe70", "html_url": "https://github.com/rust-lang/rust/commit/827e3004851ff28f4394bf62d4a9fe29728ebe70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/827e3004851ff28f4394bf62d4a9fe29728ebe70/comments", "author": null, "committer": null, "parents": [{"sha": "ce6a77e24e066f4158b1d6b2c15d619994587884", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce6a77e24e066f4158b1d6b2c15d619994587884", "html_url": "https://github.com/rust-lang/rust/commit/ce6a77e24e066f4158b1d6b2c15d619994587884"}], "stats": {"total": 595, "additions": 311, "deletions": 284}, "files": [{"sha": "78f72124f3d799d6bc82ad9a457bffa2706a2177", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 6, "deletions": 284, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/827e3004851ff28f4394bf62d4a9fe29728ebe70/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/827e3004851ff28f4394bf62d4a9fe29728ebe70/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=827e3004851ff28f4394bf62d4a9fe29728ebe70", "patch": "@@ -67,6 +67,12 @@ import syntax::print::pprust::path_to_str;\n \n import trans_common::*;\n \n+import trans_comm::trans_port;\n+import trans_comm::trans_chan;\n+import trans_comm::trans_spawn;\n+import trans_comm::trans_send;\n+import trans_comm::trans_recv;\n+\n obj namegen(mutable int i) {\n     fn next(str prefix) -> str { i += 1; ret prefix + int::str(i); }\n }\n@@ -6217,287 +6223,6 @@ fn trans_be(&@block_ctxt cx, &@ast::expr e) -> result {\n     ret trans_ret(cx, some(e));\n }\n \n-fn trans_port(&@block_ctxt cx, ast::node_id id) -> result {\n-    auto t = node_id_type(cx.fcx.lcx.ccx, id);\n-    auto unit_ty;\n-    alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n-        case (ty::ty_port(?t)) { unit_ty = t; }\n-        case (_) { cx.fcx.lcx.ccx.sess.bug(\"non-port type in trans_port\"); }\n-    }\n-    auto bcx = cx;\n-    auto unit_sz = size_of(bcx, unit_ty);\n-    bcx = unit_sz.bcx;\n-    auto port_raw_val =\n-        bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_port,\n-                       ~[bcx.fcx.lltaskptr, unit_sz.val]);\n-    auto llty = type_of(cx.fcx.lcx.ccx, cx.sp, t);\n-    auto port_val = bcx.build.PointerCast(port_raw_val, llty);\n-    add_clean_temp(bcx, port_val, t);\n-    ret rslt(bcx, port_val);\n-}\n-\n-fn trans_chan(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n-    auto bcx = cx;\n-    auto prt = trans_expr(bcx, e);\n-    bcx = prt.bcx;\n-    auto prt_val = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n-    auto chan_raw_val =\n-        bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_chan,\n-                       ~[bcx.fcx.lltaskptr, prt_val]);\n-    auto chan_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n-    auto chan_llty = type_of(bcx.fcx.lcx.ccx, e.span, chan_ty);\n-    auto chan_val = bcx.build.PointerCast(chan_raw_val, chan_llty);\n-    add_clean_temp(bcx, chan_val, chan_ty);\n-    ret rslt(bcx, chan_val);\n-}\n-\n-fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n-               &@ast::expr func, &(@ast::expr)[] args, ast::node_id id)\n-        -> result {\n-    auto bcx = cx;\n-    // Make the task name\n-\n-    auto tname =\n-        alt (name) {\n-            case (none) {\n-                auto argss = std::ivec::map(expr_to_str, args);\n-                #fmt(\"%s(%s)\", expr_to_str(func),\n-                     str::connect_ivec(argss, \", \"))\n-            }\n-            case (some(?n)) { n }\n-        };\n-    // Generate code\n-    //\n-    // This is a several step process. The following things need to happen\n-    // (not necessarily in order):\n-    //\n-    // 1. Evaluate all the arguments to the spawnee.\n-    //\n-    // 2. Alloca a tuple that holds these arguments (they must be in reverse\n-    // order, so that they match the expected stack layout for the spawnee)\n-    //\n-    // 3. Fill the tuple with the arguments we evaluated.\n-    //\n-    // 3.5. Generate a wrapper function that takes the tuple and unpacks it to\n-    // call the real task.\n-    //\n-    // 4. Pass a pointer to the wrapper function and the argument tuple to\n-    // upcall_start_task. In order to do this, we need to allocate another\n-    // tuple that matches the arguments expected by rust_task::start.\n-    //\n-    // 5. Oh yeah, we have to create the task before we start it...\n-\n-    // But first, we'll create a task.\n-\n-    let ValueRef lltname = C_str(bcx.fcx.lcx.ccx, tname);\n-    auto new_task =\n-        bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_task,\n-                       ~[bcx.fcx.lltaskptr, lltname]);\n-\n-    // Translate the arguments, remembering their types and where the values\n-    // ended up.\n-\n-    let ty::t[] arg_tys = ~[];\n-    let ValueRef[] arg_vals = ~[];\n-    for (@ast::expr e in args) {\n-        auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n-        auto arg = trans_expr(bcx, e);\n-\n-        arg = deep_copy(arg.bcx, arg.val, e_ty, new_task);\n-\n-        bcx = arg.bcx;\n-\n-        arg_vals += ~[arg.val];\n-        arg_tys += ~[e_ty];\n-    }\n-    // Make the tuple.\n-\n-    auto args_ty = ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, arg_tys);\n-    // Allocate and fill the tuple.\n-\n-    auto llargs = alloc_ty(bcx, args_ty);\n-    auto i = 0u;\n-    for (ValueRef v in arg_vals) {\n-        // log_err #fmt(\"ty(llargs) = %s\",\n-        //              val_str(bcx.fcx.lcx.ccx.tn, llargs.val));\n-\n-        auto target = bcx.build.GEP(llargs.val, ~[C_int(0), C_int(i as int)]);\n-        // log_err #fmt(\"ty(v) = %s\", val_str(bcx.fcx.lcx.ccx.tn, v));\n-        // log_err #fmt(\"ty(target) = %s\",\n-        //              val_str(bcx.fcx.lcx.ccx.tn, target));\n-\n-        bcx.build.Store(v, target);\n-        i += 1u;\n-    }\n-\n-    // Generate the wrapper function\n-    auto wrapper = mk_spawn_wrapper(bcx, func, args_ty);\n-    bcx = wrapper.bcx;\n-    auto llfnptr_i = bcx.build.PointerCast(wrapper.val, T_int());\n-\n-    // And start the task\n-    auto llargs_i = bcx.build.PointerCast(llargs.val, T_int());\n-    auto args_size = size_of(bcx, args_ty).val;\n-    bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.start_task,\n-                   ~[bcx.fcx.lltaskptr, new_task, llfnptr_i, llargs_i,\n-                     args_size]);\n-    auto task_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n-    add_clean_temp(bcx, new_task, task_ty);\n-    ret rslt(bcx, new_task);\n-}\n-\n-fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n-   result {\n-    auto llmod = cx.fcx.lcx.ccx.llmod;\n-    let TypeRef wrapper_fn_type =\n-        type_of_fn(cx.fcx.lcx.ccx, cx.sp, ast::proto_fn,\n-                   ~[rec(mode=ty::mo_alias(false), ty=args_ty)], ty::idx_nil,\n-                   0u);\n-    // TODO: construct a name based on tname\n-\n-    let str wrap_name =\n-        mangle_internal_name_by_path_and_seq(cx.fcx.lcx.ccx, cx.fcx.lcx.path,\n-                                             \"spawn_wrapper\");\n-    auto llfndecl = decl_cdecl_fn(llmod, wrap_name, wrapper_fn_type);\n-    auto fcx = new_fn_ctxt(cx.fcx.lcx, cx.sp, llfndecl);\n-    auto fbcx = new_top_block_ctxt(fcx);\n-    // 3u to skip the three implicit args\n-\n-    let ValueRef arg = llvm::LLVMGetParam(fcx.llfn, 3u);\n-    let ValueRef[] child_args =\n-        ~[llvm::LLVMGetParam(fcx.llfn, 0u), llvm::LLVMGetParam(fcx.llfn, 1u),\n-          llvm::LLVMGetParam(fcx.llfn, 2u)];\n-    // unpack the arguments\n-\n-    alt (ty::struct(fcx.lcx.ccx.tcx, args_ty)) {\n-        case (ty::ty_tup(?elements)) {\n-            auto i = 0;\n-            for (ty::mt m in elements) {\n-                auto src = fbcx.build.GEP(arg, ~[C_int(0), C_int(i)]);\n-                i += 1;\n-                auto child_arg = fbcx.build.Load(src);\n-                child_args += ~[child_arg];\n-            }\n-        }\n-    }\n-    // Find the function\n-\n-    auto fnptr = trans_lval(fbcx, func).res;\n-    fbcx = fnptr.bcx;\n-    auto llfnptr = fbcx.build.GEP(fnptr.val, ~[C_int(0), C_int(0)]);\n-    auto llfn = fbcx.build.Load(llfnptr);\n-    fbcx.build.FastCall(llfn, child_args);\n-    fbcx.build.RetVoid();\n-    finish_fn(fcx, fbcx.llbb);\n-    // TODO: make sure we clean up everything we need to.\n-\n-    ret rslt(cx, llfndecl);\n-}\n-\n-// Does a deep copy of a value. This is needed for passing arguments to child\n-// tasks, and for sending things through channels. There are probably some\n-// uniqueness optimizations and things we can do here for tasks in the same\n-// domain.\n-fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task)\n-    -> result\n-{\n-    // TODO: make sure all paths add any reference counting that they need to.\n-\n-    // TODO: Teach deep copy to understand everything else it needs to.\n-\n-    auto tcx = bcx.fcx.lcx.ccx.tcx;\n-    if(ty::type_is_scalar(tcx, t)) {\n-        ret rslt(bcx, v);\n-    }\n-    else if(ty::type_is_str(tcx, t)) {\n-        ret rslt(bcx,\n-                bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.dup_str,\n-                               ~[bcx.fcx.lltaskptr, target_task, v]));\n-    }\n-    else if(ty::type_is_chan(tcx, t)) {\n-        // If this is a channel, we need to clone it.\n-        auto chan_ptr = bcx.build.PointerCast(v, T_opaque_chan_ptr());\n-\n-        auto chan_raw_val =\n-            bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.clone_chan,\n-                           ~[bcx.fcx.lltaskptr, target_task, chan_ptr]);\n-\n-        // Cast back to the type the context was expecting.\n-        auto chan_val = bcx.build.PointerCast(chan_raw_val,\n-                                              val_ty(v));\n-\n-        ret rslt(bcx, chan_val);\n-    }\n-    else if(ty::type_is_structural(tcx, t)) {\n-        fn inner_deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t) -> result {\n-            log_err \"Unimplemented type for deep_copy.\";\n-            fail;\n-        }\n-\n-        ret iter_structural_ty(bcx, v, t, inner_deep_copy);\n-    }\n-    else {\n-        bcx.fcx.lcx.ccx.sess.bug(\"unexpected type in \" +\n-                                 \"trans::deep_copy: \" +\n-                                 ty_to_str(tcx, t));\n-    }\n-}\n-\n-fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n-              ast::node_id id) -> result {\n-    auto bcx = cx;\n-    auto chn = trans_expr(bcx, lhs);\n-    bcx = chn.bcx;\n-    auto data = trans_lval(bcx, rhs);\n-    bcx = data.res.bcx;\n-    auto chan_ty = node_id_type(cx.fcx.lcx.ccx, id);\n-    auto unit_ty;\n-    alt (ty::struct(cx.fcx.lcx.ccx.tcx, chan_ty)) {\n-        case (ty::ty_chan(?t)) { unit_ty = t; }\n-        case (_) { bcx.fcx.lcx.ccx.sess.bug(\"non-chan type in trans_send\"); }\n-    }\n-    auto data_alloc = alloc_ty(bcx, unit_ty);\n-    bcx = data_alloc.bcx;\n-    auto data_tmp = move_val_if_temp(bcx, INIT, data_alloc.val,\n-                                     data, unit_ty);\n-    bcx = data_tmp.bcx;\n-    add_clean_temp(bcx, data_alloc.val, unit_ty);\n-    auto llchanval = bcx.build.PointerCast(chn.val, T_opaque_chan_ptr());\n-    auto lldataptr = bcx.build.PointerCast(data_alloc.val, T_ptr(T_i8()));\n-    bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.send,\n-                   ~[bcx.fcx.lltaskptr, llchanval, lldataptr]);\n-    ret rslt(bcx, chn.val);\n-}\n-\n-fn trans_recv(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n-              ast::node_id id) -> result {\n-    auto bcx = cx;\n-    auto data = trans_lval(bcx, rhs);\n-    assert (data.is_mem);\n-    bcx = data.res.bcx;\n-    auto unit_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n-    // FIXME: calculate copy init-ness in typestate.\n-\n-    ret recv_val(bcx, data.res.val, lhs, unit_ty, DROP_EXISTING);\n-}\n-\n-fn recv_val(&@block_ctxt cx, ValueRef to, &@ast::expr from, &ty::t unit_ty,\n-            copy_action action) -> result {\n-    auto bcx = cx;\n-    auto prt = trans_expr(bcx, from);\n-    bcx = prt.bcx;\n-    auto lldataptr = bcx.build.PointerCast(to, T_ptr(T_ptr(T_i8())));\n-    auto llportptr = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n-    bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.recv,\n-                   ~[bcx.fcx.lltaskptr, lldataptr, llportptr]);\n-    auto data_load = load_if_immediate(bcx, to, unit_ty);\n-    auto cp = copy_val(bcx, action, to, data_load, unit_ty);\n-    bcx = cp.bcx;\n-    // TODO: Any cleanup need to be done here?\n-    ret rslt(bcx, to);\n-}\n-\n-\n /*\n \n   Suppose we create an anonymous object my_b from a regular object a:\n@@ -6818,9 +6543,6 @@ fn init_local(&@block_ctxt cx, &@ast::local local) -> result {\n                     auto sub = trans_lval(bcx, init.expr);\n                     bcx = move_val(sub.res.bcx, INIT, llptr, sub, ty).bcx;\n                 }\n-                case (ast::init_recv) {\n-                    bcx = recv_val(bcx, llptr, init.expr, ty, INIT).bcx;\n-                }\n             }\n         }\n         case (_) { bcx = zero_alloca(bcx, llptr, ty).bcx; }"}, {"sha": "daa5dc3ea78be61435189f83cf8ff64f9022b2ef", "filename": "src/comp/middle/trans_comm.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/827e3004851ff28f4394bf62d4a9fe29728ebe70/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/827e3004851ff28f4394bf62d4a9fe29728ebe70/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_comm.rs?ref=827e3004851ff28f4394bf62d4a9fe29728ebe70", "patch": "@@ -0,0 +1,304 @@\n+/**\n+   Translation for various task and comm-related things.\n+\n+   Most of this will probably go away as we move more of this into\n+   libraries.\n+\n+*/\n+\n+import std::str;\n+import std::option;\n+import option::none;\n+import option::some;\n+\n+import lib::llvm::llvm;\n+import lib::llvm::llvm::ValueRef;\n+\n+import util::ppaux::ty_to_str;\n+import syntax::print::pprust::expr_to_str;\n+import syntax::ast;\n+import back::link::mangle_internal_name_by_path_and_seq;\n+\n+import trans_common::*;\n+import trans::*;\n+\n+fn trans_port(&@block_ctxt cx, ast::node_id id) -> result {\n+    auto t = node_id_type(cx.fcx.lcx.ccx, id);\n+    auto unit_ty;\n+    alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n+        case (ty::ty_port(?t)) { unit_ty = t; }\n+        case (_) { cx.fcx.lcx.ccx.sess.bug(\"non-port type in trans_port\"); }\n+    }\n+    auto bcx = cx;\n+    auto unit_sz = size_of(bcx, unit_ty);\n+    bcx = unit_sz.bcx;\n+    auto port_raw_val =\n+        bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_port,\n+                       ~[bcx.fcx.lltaskptr, unit_sz.val]);\n+    auto llty = type_of(cx.fcx.lcx.ccx, cx.sp, t);\n+    auto port_val = bcx.build.PointerCast(port_raw_val, llty);\n+    add_clean_temp(bcx, port_val, t);\n+    ret rslt(bcx, port_val);\n+}\n+\n+fn trans_chan(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n+    auto bcx = cx;\n+    auto prt = trans_expr(bcx, e);\n+    bcx = prt.bcx;\n+    auto prt_val = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n+    auto chan_raw_val =\n+        bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_chan,\n+                       ~[bcx.fcx.lltaskptr, prt_val]);\n+    auto chan_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n+    auto chan_llty = type_of(bcx.fcx.lcx.ccx, e.span, chan_ty);\n+    auto chan_val = bcx.build.PointerCast(chan_raw_val, chan_llty);\n+    add_clean_temp(bcx, chan_val, chan_ty);\n+    ret rslt(bcx, chan_val);\n+}\n+\n+fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n+               &@ast::expr func, &(@ast::expr)[] args, ast::node_id id)\n+        -> result {\n+    auto bcx = cx;\n+    // Make the task name\n+\n+    auto tname =\n+        alt (name) {\n+            case (none) {\n+                auto argss = std::ivec::map(expr_to_str, args);\n+                #fmt(\"%s(%s)\", expr_to_str(func),\n+                     str::connect_ivec(argss, \", \"))\n+            }\n+            case (some(?n)) { n }\n+        };\n+    // Generate code\n+    //\n+    // This is a several step process. The following things need to happen\n+    // (not necessarily in order):\n+    //\n+    // 1. Evaluate all the arguments to the spawnee.\n+    //\n+    // 2. Alloca a tuple that holds these arguments (they must be in reverse\n+    // order, so that they match the expected stack layout for the spawnee)\n+    //\n+    // 3. Fill the tuple with the arguments we evaluated.\n+    //\n+    // 3.5. Generate a wrapper function that takes the tuple and unpacks it to\n+    // call the real task.\n+    //\n+    // 4. Pass a pointer to the wrapper function and the argument tuple to\n+    // upcall_start_task. In order to do this, we need to allocate another\n+    // tuple that matches the arguments expected by rust_task::start.\n+    //\n+    // 5. Oh yeah, we have to create the task before we start it...\n+\n+    // But first, we'll create a task.\n+\n+    let ValueRef lltname = C_str(bcx.fcx.lcx.ccx, tname);\n+    auto new_task =\n+        bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_task,\n+                       ~[bcx.fcx.lltaskptr, lltname]);\n+\n+    // Translate the arguments, remembering their types and where the values\n+    // ended up.\n+\n+    let ty::t[] arg_tys = ~[];\n+    let ValueRef[] arg_vals = ~[];\n+    for (@ast::expr e in args) {\n+        auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n+        auto arg = trans_expr(bcx, e);\n+\n+        arg = deep_copy(arg.bcx, arg.val, e_ty, new_task);\n+\n+        bcx = arg.bcx;\n+\n+        arg_vals += ~[arg.val];\n+        arg_tys += ~[e_ty];\n+    }\n+    // Make the tuple.\n+\n+    auto args_ty = ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, arg_tys);\n+    // Allocate and fill the tuple.\n+\n+    auto llargs = alloc_ty(bcx, args_ty);\n+    auto i = 0u;\n+    for (ValueRef v in arg_vals) {\n+        // log_err #fmt(\"ty(llargs) = %s\",\n+        //              val_str(bcx.fcx.lcx.ccx.tn, llargs.val));\n+\n+        auto target = bcx.build.GEP(llargs.val, ~[C_int(0), C_int(i as int)]);\n+        // log_err #fmt(\"ty(v) = %s\", val_str(bcx.fcx.lcx.ccx.tn, v));\n+        // log_err #fmt(\"ty(target) = %s\",\n+        //              val_str(bcx.fcx.lcx.ccx.tn, target));\n+\n+        bcx.build.Store(v, target);\n+        i += 1u;\n+    }\n+\n+    // Generate the wrapper function\n+    auto wrapper = mk_spawn_wrapper(bcx, func, args_ty);\n+    bcx = wrapper.bcx;\n+    auto llfnptr_i = bcx.build.PointerCast(wrapper.val, T_int());\n+\n+    // And start the task\n+    auto llargs_i = bcx.build.PointerCast(llargs.val, T_int());\n+    auto args_size = size_of(bcx, args_ty).val;\n+    bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.start_task,\n+                   ~[bcx.fcx.lltaskptr, new_task, llfnptr_i, llargs_i,\n+                     args_size]);\n+    auto task_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n+    add_clean_temp(bcx, new_task, task_ty);\n+    ret rslt(bcx, new_task);\n+}\n+\n+fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n+   result {\n+    auto llmod = cx.fcx.lcx.ccx.llmod;\n+    auto wrapper_fn_type =\n+        type_of_fn(cx.fcx.lcx.ccx, cx.sp, ast::proto_fn,\n+                   ~[rec(mode=ty::mo_alias(false), ty=args_ty)], ty::idx_nil,\n+                   0u);\n+    // TODO: construct a name based on tname\n+\n+    let str wrap_name =\n+        mangle_internal_name_by_path_and_seq(cx.fcx.lcx.ccx, cx.fcx.lcx.path,\n+                                             \"spawn_wrapper\");\n+    auto llfndecl = decl_cdecl_fn(llmod, wrap_name, wrapper_fn_type);\n+    auto fcx = new_fn_ctxt(cx.fcx.lcx, cx.sp, llfndecl);\n+    auto fbcx = new_top_block_ctxt(fcx);\n+    // 3u to skip the three implicit args\n+\n+    let ValueRef arg = llvm::LLVMGetParam(fcx.llfn, 3u);\n+    let ValueRef[] child_args =\n+        ~[llvm::LLVMGetParam(fcx.llfn, 0u), llvm::LLVMGetParam(fcx.llfn, 1u),\n+          llvm::LLVMGetParam(fcx.llfn, 2u)];\n+    // unpack the arguments\n+\n+    alt (ty::struct(fcx.lcx.ccx.tcx, args_ty)) {\n+        case (ty::ty_tup(?elements)) {\n+            auto i = 0;\n+            for (ty::mt m in elements) {\n+                auto src = fbcx.build.GEP(arg, ~[C_int(0), C_int(i)]);\n+                i += 1;\n+                auto child_arg = fbcx.build.Load(src);\n+                child_args += ~[child_arg];\n+            }\n+        }\n+    }\n+    // Find the function\n+\n+    auto fnptr = trans_lval(fbcx, func).res;\n+    fbcx = fnptr.bcx;\n+    auto llfnptr = fbcx.build.GEP(fnptr.val, ~[C_int(0), C_int(0)]);\n+    auto llfn = fbcx.build.Load(llfnptr);\n+    fbcx.build.FastCall(llfn, child_args);\n+    fbcx.build.RetVoid();\n+    finish_fn(fcx, fbcx.llbb);\n+    // TODO: make sure we clean up everything we need to.\n+\n+    ret rslt(cx, llfndecl);\n+}\n+\n+// Does a deep copy of a value. This is needed for passing arguments to child\n+// tasks, and for sending things through channels. There are probably some\n+// uniqueness optimizations and things we can do here for tasks in the same\n+// domain.\n+fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task)\n+    -> result\n+{\n+    // TODO: make sure all paths add any reference counting that they need to.\n+\n+    // TODO: Teach deep copy to understand everything else it needs to.\n+\n+    auto tcx = bcx.fcx.lcx.ccx.tcx;\n+    if(ty::type_is_scalar(tcx, t)) {\n+        ret rslt(bcx, v);\n+    }\n+    else if(ty::type_is_str(tcx, t)) {\n+        ret rslt(bcx,\n+                bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.dup_str,\n+                               ~[bcx.fcx.lltaskptr, target_task, v]));\n+    }\n+    else if(ty::type_is_chan(tcx, t)) {\n+        // If this is a channel, we need to clone it.\n+        auto chan_ptr = bcx.build.PointerCast(v, T_opaque_chan_ptr());\n+\n+        auto chan_raw_val =\n+            bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.clone_chan,\n+                           ~[bcx.fcx.lltaskptr, target_task, chan_ptr]);\n+\n+        // Cast back to the type the context was expecting.\n+        auto chan_val = bcx.build.PointerCast(chan_raw_val,\n+                                              val_ty(v));\n+\n+        ret rslt(bcx, chan_val);\n+    }\n+    else if(ty::type_is_structural(tcx, t)) {\n+        fn inner_deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t) -> result {\n+            log_err \"Unimplemented type for deep_copy.\";\n+            fail;\n+        }\n+\n+        ret iter_structural_ty(bcx, v, t, inner_deep_copy);\n+    }\n+    else {\n+        bcx.fcx.lcx.ccx.sess.bug(\"unexpected type in \" +\n+                                 \"trans::deep_copy: \" +\n+                                 ty_to_str(tcx, t));\n+    }\n+}\n+\n+fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n+              ast::node_id id) -> result {\n+    auto bcx = cx;\n+    auto chn = trans_expr(bcx, lhs);\n+    bcx = chn.bcx;\n+    auto data = trans_lval(bcx, rhs);\n+    bcx = data.res.bcx;\n+    auto chan_ty = node_id_type(cx.fcx.lcx.ccx, id);\n+    auto unit_ty;\n+    alt (ty::struct(cx.fcx.lcx.ccx.tcx, chan_ty)) {\n+        case (ty::ty_chan(?t)) { unit_ty = t; }\n+        case (_) { bcx.fcx.lcx.ccx.sess.bug(\"non-chan type in trans_send\"); }\n+    }\n+    auto data_alloc = alloc_ty(bcx, unit_ty);\n+    bcx = data_alloc.bcx;\n+    auto data_tmp = move_val_if_temp(bcx, INIT, data_alloc.val,\n+                                     data, unit_ty);\n+    bcx = data_tmp.bcx;\n+    add_clean_temp(bcx, data_alloc.val, unit_ty);\n+    auto llchanval = bcx.build.PointerCast(chn.val, T_opaque_chan_ptr());\n+    auto lldataptr = bcx.build.PointerCast(data_alloc.val, T_ptr(T_i8()));\n+    bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.send,\n+                   ~[bcx.fcx.lltaskptr, llchanval, lldataptr]);\n+    ret rslt(bcx, chn.val);\n+}\n+\n+fn trans_recv(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n+              ast::node_id id) -> result {\n+    auto bcx = cx;\n+    auto data = trans_lval(bcx, rhs);\n+    assert (data.is_mem);\n+    bcx = data.res.bcx;\n+    auto unit_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n+    // FIXME: calculate copy init-ness in typestate.\n+\n+    ret recv_val(bcx, data.res.val, lhs, unit_ty, DROP_EXISTING);\n+}\n+\n+fn recv_val(&@block_ctxt cx, ValueRef to, &@ast::expr from, &ty::t unit_ty,\n+            copy_action action) -> result {\n+    auto bcx = cx;\n+    auto prt = trans_expr(bcx, from);\n+    bcx = prt.bcx;\n+    auto lldataptr = bcx.build.PointerCast(to, T_ptr(T_ptr(T_i8())));\n+    auto llportptr = bcx.build.PointerCast(prt.val, T_opaque_port_ptr());\n+    bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.recv,\n+                   ~[bcx.fcx.lltaskptr, lldataptr, llportptr]);\n+    auto data_load = load_if_immediate(bcx, to, unit_ty);\n+    auto cp = copy_val(bcx, action, to, data_load, unit_ty);\n+    bcx = cp.bcx;\n+    // TODO: Any cleanup need to be done here?\n+    ret rslt(bcx, to);\n+}\n+"}, {"sha": "2115e872531d2479466c6edcab9ecce55a993d54", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/827e3004851ff28f4394bf62d4a9fe29728ebe70/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/827e3004851ff28f4394bf62d4a9fe29728ebe70/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=827e3004851ff28f4394bf62d4a9fe29728ebe70", "patch": "@@ -18,6 +18,7 @@ mod middle {\n     mod trans_common;\n     mod trans;\n     mod trans_alt;\n+    mod trans_comm;\n     mod ty;\n     mod ast_map;\n     mod resolve;"}]}