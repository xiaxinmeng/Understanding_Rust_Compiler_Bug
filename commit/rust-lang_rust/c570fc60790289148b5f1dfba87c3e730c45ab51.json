{"sha": "c570fc60790289148b5f1dfba87c3e730c45ab51", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NzBmYzYwNzkwMjg5MTQ4YjVmMWRmYmE4N2MzZTczMGM0NWFiNTE=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-01-20T19:15:10Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-01-20T19:15:10Z"}, "message": "Merge pull request #566 from mcarton/starts_with\n\nAdd a lint for starts_with", "tree": {"sha": "99269daad958795fba02ac21bc7387bc80e8d575", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99269daad958795fba02ac21bc7387bc80e8d575"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c570fc60790289148b5f1dfba87c3e730c45ab51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c570fc60790289148b5f1dfba87c3e730c45ab51", "html_url": "https://github.com/rust-lang/rust/commit/c570fc60790289148b5f1dfba87c3e730c45ab51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c570fc60790289148b5f1dfba87c3e730c45ab51/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdcd9743ee611a0486b153715d6e6d88a674c8ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdcd9743ee611a0486b153715d6e6d88a674c8ad", "html_url": "https://github.com/rust-lang/rust/commit/fdcd9743ee611a0486b153715d6e6d88a674c8ad"}, {"sha": "7a26cfc991c1d8e60def820d133df39e30e105fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a26cfc991c1d8e60def820d133df39e30e105fd", "html_url": "https://github.com/rust-lang/rust/commit/7a26cfc991c1d8e60def820d133df39e30e105fd"}], "stats": {"total": 145, "additions": 113, "deletions": 32}, "files": [{"sha": "ba257ce43a17846d5c2a1885a21990c27a758cdf", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c570fc60790289148b5f1dfba87c3e730c45ab51/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/c570fc60790289148b5f1dfba87c3e730c45ab51/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=c570fc60790289148b5f1dfba87c3e730c45ab51", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 94 lints included in this crate:\n+There are 95 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -20,6 +20,7 @@ name\n [cast_possible_wrap](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap)                       | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n [cast_precision_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss)                     | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`\n [cast_sign_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_sign_loss)                               | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n+[chars_next_cmp](https://github.com/Manishearth/rust-clippy/wiki#chars_next_cmp)                               | warn    | using `.chars().next()` to check if a string starts with a char\n [cmp_nan](https://github.com/Manishearth/rust-clippy/wiki#cmp_nan)                                             | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n [cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                         | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n [collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                               | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`"}, {"sha": "1a4501ffce6fe05b465e55a8bdb50743e0e0a47a", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c570fc60790289148b5f1dfba87c3e730c45ab51/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c570fc60790289148b5f1dfba87c3e730c45ab51/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c570fc60790289148b5f1dfba87c3e730c45ab51", "patch": "@@ -191,6 +191,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         matches::MATCH_OVERLAPPING_ARM,\n         matches::MATCH_REF_PATS,\n         matches::SINGLE_MATCH,\n+        methods::CHARS_NEXT_CMP,\n         methods::FILTER_NEXT,\n         methods::OK_EXPECT,\n         methods::OPTION_MAP_UNWRAP_OR,"}, {"sha": "6338961b56b3c4cf635a42f1894453c25f2d97a7", "filename": "src/methods.rs", "status": "modified", "additions": 93, "deletions": 27, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c570fc60790289148b5f1dfba87c3e730c45ab51/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c570fc60790289148b5f1dfba87c3e730c45ab51/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=c570fc60790289148b5f1dfba87c3e730c45ab51", "patch": "@@ -7,11 +7,14 @@ use std::borrow::Cow;\n use syntax::ptr::P;\n use syntax::codemap::Span;\n \n-use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, method_chain_args, match_trait_method,\n-            walk_ptrs_ty_depth, walk_ptrs_ty, get_trait_def_id, implements_trait};\n use utils::{\n-    BTREEMAP_ENTRY_PATH, DEFAULT_TRAIT_PATH, HASHMAP_ENTRY_PATH, OPTION_PATH,\n-    RESULT_PATH, STRING_PATH\n+    get_trait_def_id, implements_trait, in_external_macro, in_macro, match_path,\n+    match_trait_method, match_type, method_chain_args, snippet, span_lint, span_lint_and_then,\n+    span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth,\n+};\n+use utils::{\n+    BTREEMAP_ENTRY_PATH, DEFAULT_TRAIT_PATH, HASHMAP_ENTRY_PATH, OPTION_PATH, RESULT_PATH,\n+    STRING_PATH\n };\n use utils::MethodArgs;\n use rustc::middle::cstore::CrateStore;\n@@ -176,6 +179,17 @@ declare_lint!(pub SEARCH_IS_SOME, Warn,\n               \"using an iterator search followed by `is_some()`, which is more succinctly \\\n                expressed as a call to `any()`\");\n \n+/// **What it does:** This lint `Warn`s on using `.chars().next()` on a `str` to check if it\n+/// starts with a given char.\n+///\n+/// **Why is this bad?** Readability, this can be written more concisely as `_.starts_with(_)`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:** `name.chars().next() == Some('_')`\n+declare_lint!(pub CHARS_NEXT_CMP, Warn,\n+              \"using `.chars().next()` to check if a string starts with a char\");\n+\n /// **What it does:** This lint checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`, etc., and\n /// suggests to use `or_else`, `unwrap_or_else`, etc., or `unwrap_or_default` instead.\n ///\n@@ -210,39 +224,56 @@ impl LintPass for MethodsPass {\n                     OK_EXPECT,\n                     OPTION_MAP_UNWRAP_OR,\n                     OPTION_MAP_UNWRAP_OR_ELSE,\n-                    OR_FUN_CALL)\n+                    OR_FUN_CALL,\n+                    CHARS_NEXT_CMP)\n     }\n }\n \n impl LateLintPass for MethodsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprMethodCall(name, _, ref args) = expr.node {\n-            // Chain calls\n-            if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n-                lint_unwrap(cx, expr, arglists[0]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"to_string\"]) {\n-                lint_to_string(cx, expr, arglists[0]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"ok\", \"expect\"]) {\n-                lint_ok_expect(cx, expr, arglists[0]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or\"]) {\n-                lint_map_unwrap_or(cx, expr, arglists[0], arglists[1]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or_else\"]) {\n-                lint_map_unwrap_or_else(cx, expr, arglists[0], arglists[1]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"next\"]) {\n-                lint_filter_next(cx, expr, arglists[0]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"find\", \"is_some\"]) {\n-                lint_search_is_some(cx, expr, \"find\", arglists[0], arglists[1]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"position\", \"is_some\"]) {\n-                lint_search_is_some(cx, expr, \"position\", arglists[0], arglists[1]);\n-            } else if let Some(arglists) = method_chain_args(expr, &[\"rposition\", \"is_some\"]) {\n-                lint_search_is_some(cx, expr, \"rposition\", arglists[0], arglists[1]);\n-            }\n+        if in_macro(cx, expr.span) {\n+            return;\n+        }\n+\n+        match expr.node {\n+            ExprMethodCall(name, _, ref args) => {\n+                // Chain calls\n+                if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n+                    lint_unwrap(cx, expr, arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"to_string\"]) {\n+                    lint_to_string(cx, expr, arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"ok\", \"expect\"]) {\n+                    lint_ok_expect(cx, expr, arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or\"]) {\n+                    lint_map_unwrap_or(cx, expr, arglists[0], arglists[1]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"map\", \"unwrap_or_else\"]) {\n+                    lint_map_unwrap_or_else(cx, expr, arglists[0], arglists[1]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"filter\", \"next\"]) {\n+                    lint_filter_next(cx, expr, arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"find\", \"is_some\"]) {\n+                    lint_search_is_some(cx, expr, \"find\", arglists[0], arglists[1]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"position\", \"is_some\"]) {\n+                    lint_search_is_some(cx, expr, \"position\", arglists[0], arglists[1]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"rposition\", \"is_some\"]) {\n+                    lint_search_is_some(cx, expr, \"rposition\", arglists[0], arglists[1]);\n+                }\n \n-            lint_or_fun_call(cx, expr, &name.node.as_str(), &args);\n+                lint_or_fun_call(cx, expr, &name.node.as_str(), &args);\n+            }\n+            ExprBinary(op, ref lhs, ref rhs) if op.node == BiEq || op.node == BiNe => {\n+                if !lint_chars_next(cx, expr, lhs, rhs, op.node == BiEq) {\n+                    lint_chars_next(cx, expr, rhs, lhs, op.node == BiEq);\n+                }\n+            }\n+            _ => (),\n         }\n     }\n \n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+        if in_external_macro(cx, item.span) {\n+            return;\n+        }\n+\n         if let ItemImpl(_, _, _, None, ref ty, ref items) = item.node {\n             for implitem in items {\n                 let name = implitem.name;\n@@ -570,6 +601,41 @@ fn lint_search_is_some(cx: &LateContext, expr: &Expr, search_method: &str, searc\n     }\n }\n \n+/// Checks for the `CHARS_NEXT_CMP` lint.\n+fn lint_chars_next(cx: &LateContext, expr: &Expr, chain: &Expr, other: &Expr, eq: bool) -> bool {\n+    if_let_chain! {[\n+        let Some(args) = method_chain_args(chain, &[\"chars\", \"next\"]),\n+        let ExprCall(ref fun, ref arg_char) = other.node,\n+        arg_char.len() == 1,\n+        let ExprPath(None, ref path) = fun.node,\n+        path.segments.len() == 1 && path.segments[0].identifier.name.as_str() == \"Some\"\n+    ], {\n+        let self_ty = walk_ptrs_ty(cx.tcx.expr_ty_adjusted(&args[0][0]));\n+\n+        if self_ty.sty != ty::TyStr {\n+            return false;\n+        }\n+\n+        span_lint_and_then(cx,\n+                           CHARS_NEXT_CMP,\n+                           expr.span,\n+                           \"you should use the `starts_with` method\",\n+                           |db| {\n+                               let sugg = format!(\"{}{}.starts_with({})\",\n+                                                  if eq { \"\" } else { \"!\" },\n+                                                  snippet(cx, args[0][0].span, \"_\"),\n+                                                  snippet(cx, arg_char[0].span, \"_\")\n+                                                  );\n+\n+                               db.span_suggestion(expr.span, \"like this\", sugg);\n+                           });\n+\n+        return true;\n+    }}\n+\n+    false\n+}\n+\n // Given a `Result<T, E>` type, return its error type (`E`)\n fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     if !match_type(cx, ty, &RESULT_PATH) {"}, {"sha": "4b6170cf16437fe83e20cfac714796ae3495497f", "filename": "src/misc.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c570fc60790289148b5f1dfba87c3e730c45ab51/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c570fc60790289148b5f1dfba87c3e730c45ab51/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=c570fc60790289148b5f1dfba87c3e730c45ab51", "patch": "@@ -389,13 +389,14 @@ impl LateLintPass for UsedUnderscoreBinding {\n                                 .last()\n                                 .expect(\"path should always have at least one segment\")\n                                 .identifier;\n-                ident.name.as_str().chars().next() == Some('_') && // starts with '_'\n-                ident.name.as_str().chars().skip(1).next() != Some('_') &&  // doesn't start with \"__\"\n-                ident.name != ident.unhygienic_name && is_used(cx, expr) // not in bang macro\n+                ident.name.as_str().starts_with('_') &&\n+                !ident.name.as_str().starts_with(\"__\") &&\n+                ident.name != ident.unhygienic_name &&\n+                is_used(cx, expr) // not in bang macro\n             }\n             ExprField(_, spanned) => {\n                 let name = spanned.node.as_str();\n-                name.chars().next() == Some('_') && name.chars().skip(1).next() != Some('_')\n+                name.starts_with('_') && !name.starts_with(\"__\")\n             }\n             _ => false,\n         };"}, {"sha": "535e8cc4a26c6b8ae3e1fce7df48a4dd47801012", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c570fc60790289148b5f1dfba87c3e730c45ab51/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c570fc60790289148b5f1dfba87c3e730c45ab51/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=c570fc60790289148b5f1dfba87c3e730c45ab51", "patch": "@@ -292,3 +292,15 @@ struct MyError(()); // doesn't implement Debug\n struct MyErrorWithParam<T> {\n     x: T\n }\n+\n+fn starts_with() {\n+    \"\".chars().next() == Some(' ');\n+    //~^ ERROR starts_with\n+    //~| HELP like this\n+    //~| SUGGESTION \"\".starts_with(' ')\n+\n+    Some(' ') != \"\".chars().next();\n+    //~^ ERROR starts_with\n+    //~| HELP like this\n+    //~| SUGGESTION !\"\".starts_with(' ')\n+}"}]}