{"sha": "6480a00222bf67f928e305bf9967302eb6ae6b3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ODBhMDAyMjJiZjY3ZjkyOGUzMDViZjk5NjczMDJlYjZhZTZiM2E=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-20T00:51:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-20T00:51:07Z"}, "message": "Rollup merge of #40398 - eddyb:struct-hint, r=nikomatsakis\n\nPropagate expected type hints through struct literals.\n\nPartial fix for #31260 to maximize backwards-compatibility, i.e. the hint is provided but not coerced to.\n\nThe added test works because `{...; x}` with a hint of `T` coerces `x` to `T`, and the reasoning why that is slightly different has to do with DSTs: `&Struct { tail: [x] }: &Struct<[T]>` has a hint of `[T]` for `[x]`, but the inferred type should be `[T; 1]` to succeed later, so `[x]` shouldn't be *forced* to be `[T]`.\n\n*However*, implementing that complete behavior in a backwards-compatible way may be non-trivial, and has not yet been fully investigated, while this PR fixes #40355 and can be backported.\n\nr? @nikomatsakis", "tree": {"sha": "1c21f54549f98c18d89c3b04dae02404592f5cca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c21f54549f98c18d89c3b04dae02404592f5cca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6480a00222bf67f928e305bf9967302eb6ae6b3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6480a00222bf67f928e305bf9967302eb6ae6b3a", "html_url": "https://github.com/rust-lang/rust/commit/6480a00222bf67f928e305bf9967302eb6ae6b3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6480a00222bf67f928e305bf9967302eb6ae6b3a/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "573e906594fdf7824f49789f24fdadb4496d7368", "url": "https://api.github.com/repos/rust-lang/rust/commits/573e906594fdf7824f49789f24fdadb4496d7368", "html_url": "https://github.com/rust-lang/rust/commit/573e906594fdf7824f49789f24fdadb4496d7368"}, {"sha": "50aee36d26dd78ddc78670b2ad63d276c5faa646", "url": "https://api.github.com/repos/rust-lang/rust/commits/50aee36d26dd78ddc78670b2ad63d276c5faa646", "html_url": "https://github.com/rust-lang/rust/commit/50aee36d26dd78ddc78670b2ad63d276c5faa646"}], "stats": {"total": 73, "additions": 53, "deletions": 20}, "files": [{"sha": "529ee107c46cee8db04acf0ff6f9ba53801b757a", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6480a00222bf67f928e305bf9967302eb6ae6b3a/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6480a00222bf67f928e305bf9967302eb6ae6b3a/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=6480a00222bf67f928e305bf9967302eb6ae6b3a", "patch": "@@ -254,7 +254,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Call the generic checker.\n         let expected_arg_tys =\n-            self.expected_types_for_fn_args(call_expr.span,\n+            self.expected_inputs_for_expected_output(call_expr.span,\n                                             expected,\n                                             fn_sig.output(),\n                                             fn_sig.inputs());\n@@ -280,7 +280,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // do know the types expected for each argument and the return\n         // type.\n \n-        let expected_arg_tys = self.expected_types_for_fn_args(call_expr.span,\n+        let expected_arg_tys = self.expected_inputs_for_expected_output(call_expr.span,\n                                                                expected,\n                                                                fn_sig.output().clone(),\n                                                                fn_sig.inputs());"}, {"sha": "f36254a8a10eaaa3794be3c1a10deaafb1879ac0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6480a00222bf67f928e305bf9967302eb6ae6b3a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6480a00222bf67f928e305bf9967302eb6ae6b3a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6480a00222bf67f928e305bf9967302eb6ae6b3a", "patch": "@@ -2292,7 +2292,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match method_fn_ty.sty {\n                 ty::TyFnDef(def_id, .., ref fty) => {\n                     // HACK(eddyb) ignore self in the definition (see above).\n-                    let expected_arg_tys = self.expected_types_for_fn_args(\n+                    let expected_arg_tys = self.expected_inputs_for_expected_output(\n                         sp,\n                         expected,\n                         fty.0.output(),\n@@ -2645,14 +2645,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         TypeAndSubsts { substs: substs, ty: substd_ty }\n     }\n \n-    /// Unifies the return type with the expected type early, for more coercions\n-    /// and forward type information on the argument expressions.\n-    fn expected_types_for_fn_args(&self,\n-                                  call_span: Span,\n-                                  expected_ret: Expectation<'tcx>,\n-                                  formal_ret: Ty<'tcx>,\n-                                  formal_args: &[Ty<'tcx>])\n-                                  -> Vec<Ty<'tcx>> {\n+    /// Unifies the output type with the expected type early, for more coercions\n+    /// and forward type information on the input expressions.\n+    fn expected_inputs_for_expected_output(&self,\n+                                           call_span: Span,\n+                                           expected_ret: Expectation<'tcx>,\n+                                           formal_ret: Ty<'tcx>,\n+                                           formal_args: &[Ty<'tcx>])\n+                                           -> Vec<Ty<'tcx>> {\n         let expected_args = expected_ret.only_has_type(self).and_then(|ret_ty| {\n             self.fudge_regions_if_ok(&RegionVariableOrigin::Coercion(call_span), || {\n                 // Attempt to apply a subtyping relationship between the formal\n@@ -2675,7 +2675,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }).collect())\n             }).ok()\n         }).unwrap_or(vec![]);\n-        debug!(\"expected_types_for_fn_args(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n+        debug!(\"expected_inputs_for_expected_output(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n                formal_args, formal_ret,\n                expected_args, expected_ret);\n         expected_args\n@@ -3032,14 +3032,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_expr_struct_fields(&self,\n                                 adt_ty: Ty<'tcx>,\n+                                expected: Expectation<'tcx>,\n                                 expr_id: ast::NodeId,\n                                 span: Span,\n                                 variant: &'tcx ty::VariantDef,\n                                 ast_fields: &'gcx [hir::Field],\n                                 check_completeness: bool) {\n         let tcx = self.tcx;\n-        let (substs, adt_kind, kind_name) = match adt_ty.sty {\n-            ty::TyAdt(adt, substs) => (substs, adt.adt_kind(), adt.variant_descr()),\n+\n+        let adt_ty_hint =\n+            self.expected_inputs_for_expected_output(span, expected, adt_ty, &[adt_ty])\n+                .get(0).cloned().unwrap_or(adt_ty);\n+\n+        let (substs, hint_substs, adt_kind, kind_name) = match (&adt_ty.sty, &adt_ty_hint.sty) {\n+            (&ty::TyAdt(adt, substs), &ty::TyAdt(_, hint_substs)) => {\n+                (substs, hint_substs, adt.adt_kind(), adt.variant_descr())\n+            }\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n \n@@ -3054,10 +3062,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Typecheck each field.\n         for field in ast_fields {\n-            let expected_field_type;\n+            let final_field_type;\n+            let field_type_hint;\n \n             if let Some(v_field) = remaining_fields.remove(&field.name.node) {\n-                expected_field_type = self.field_ty(field.span, v_field, substs);\n+                final_field_type = self.field_ty(field.span, v_field, substs);\n+                field_type_hint = self.field_ty(field.span, v_field, hint_substs);\n \n                 seen_fields.insert(field.name.node, field.span);\n \n@@ -3069,7 +3079,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             } else {\n                 error_happened = true;\n-                expected_field_type = tcx.types.err;\n+                final_field_type = tcx.types.err;\n+                field_type_hint = tcx.types.err;\n                 if let Some(_) = variant.find_field_named(field.name.node) {\n                     let mut err = struct_span_err!(self.tcx.sess,\n                                                 field.name.span,\n@@ -3091,7 +3102,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue typechecking\n-            self.check_expr_coercable_to_type(&field.expr, expected_field_type);\n+            let ty = self.check_expr_with_hint(&field.expr, field_type_hint);\n+            self.demand_coerce(&field.expr, ty, final_field_type);\n         }\n \n         // Make sure the programmer specified correct number of fields.\n@@ -3201,6 +3213,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_expr_struct(&self,\n                          expr: &hir::Expr,\n+                         expected: Expectation<'tcx>,\n                          qpath: &hir::QPath,\n                          fields: &'gcx [hir::Field],\n                          base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n@@ -3219,7 +3232,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::QPath::TypeRelative(ref qself, _) => qself.span\n         };\n \n-        self.check_expr_struct_fields(struct_ty, expr.id, path_span, variant, fields,\n+        self.check_expr_struct_fields(struct_ty, expected, expr.id, path_span, variant, fields,\n                                       base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n             self.check_expr_has_type(base_expr, struct_ty);\n@@ -3764,7 +3777,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n           }\n           hir::ExprStruct(ref qpath, ref fields, ref base_expr) => {\n-            self.check_expr_struct(expr, qpath, fields, base_expr)\n+            self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n           }\n           hir::ExprField(ref base, ref field) => {\n             self.check_field(expr, lvalue_pref, &base, field)"}, {"sha": "e771fc7464d00322eb20a142355f61b323a5750c", "filename": "src/test/run-pass/issue-31260.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6480a00222bf67f928e305bf9967302eb6ae6b3a/src%2Ftest%2Frun-pass%2Fissue-31260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6480a00222bf67f928e305bf9967302eb6ae6b3a/src%2Ftest%2Frun-pass%2Fissue-31260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-31260.rs?ref=6480a00222bf67f928e305bf9967302eb6ae6b3a", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct Struct<K: 'static> {\n+    pub field: K,\n+}\n+\n+// Partial fix for #31260, doesn't work without {...}.\n+static STRUCT: Struct<&'static [u8]> = Struct {\n+    field: {&[1]}\n+};\n+\n+fn main() {}"}]}