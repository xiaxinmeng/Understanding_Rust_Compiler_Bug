{"sha": "e33bef685ef43cdefad624e73536927e766dec1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzM2JlZjY4NWVmNDNjZGVmYWQ2MjRlNzM1MzY5MjdlNzY2ZGVjMWU=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-31T09:11:51Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-31T09:26:41Z"}, "message": "lifetimes lint: walk type bounds as well as types (fixes #253, again)", "tree": {"sha": "f60c2599b8fd7b16e474de7b07be3c2af9a061f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f60c2599b8fd7b16e474de7b07be3c2af9a061f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e33bef685ef43cdefad624e73536927e766dec1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e33bef685ef43cdefad624e73536927e766dec1e", "html_url": "https://github.com/rust-lang/rust/commit/e33bef685ef43cdefad624e73536927e766dec1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e33bef685ef43cdefad624e73536927e766dec1e/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d49cc51679fc0a301de79a91fb2ebfadc317b5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d49cc51679fc0a301de79a91fb2ebfadc317b5a", "html_url": "https://github.com/rust-lang/rust/commit/9d49cc51679fc0a301de79a91fb2ebfadc317b5a"}], "stats": {"total": 60, "additions": 47, "deletions": 13}, "files": [{"sha": "de7a39fdb3b6681c1627e56b328c14b77ed9b035", "filename": "src/lifetimes.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e33bef685ef43cdefad624e73536927e766dec1e/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33bef685ef43cdefad624e73536927e766dec1e/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=e33bef685ef43cdefad624e73536927e766dec1e", "patch": "@@ -1,7 +1,7 @@\n use syntax::ast::*;\n use rustc::lint::*;\n use syntax::codemap::Span;\n-use syntax::visit::{Visitor, walk_ty};\n+use syntax::visit::{Visitor, walk_ty, walk_ty_param_bound};\n use std::collections::HashSet;\n \n use utils::{in_external_macro, span_lint};\n@@ -68,14 +68,7 @@ fn could_use_elision(func: &FnDecl, slf: Option<&ExplicitSelf>,\n     // level of the current item.\n \n     // check named LTs\n-    let mut allowed_lts = HashSet::new();\n-    for lt in named_lts {\n-        if lt.bounds.is_empty() {\n-            allowed_lts.insert(Named(lt.lifetime.name));\n-        }\n-    }\n-    allowed_lts.insert(Unnamed);\n-    allowed_lts.insert(Static);\n+    let allowed_lts = allowed_lts_from(named_lts);\n \n     // these will collect all the lifetimes for references in arg/return types\n     let mut input_visitor = RefVisitor(Vec::new());\n@@ -142,6 +135,18 @@ fn could_use_elision(func: &FnDecl, slf: Option<&ExplicitSelf>,\n     false\n }\n \n+fn allowed_lts_from(named_lts: &[LifetimeDef]) -> HashSet<RefLt> {\n+    let mut allowed_lts = HashSet::new();\n+    for lt in named_lts {\n+        if lt.bounds.is_empty() {\n+            allowed_lts.insert(Named(lt.lifetime.name));\n+        }\n+    }\n+    allowed_lts.insert(Unnamed);\n+    allowed_lts.insert(Static);\n+    allowed_lts\n+}\n+\n /// Number of unique lifetimes in the given vector.\n fn unique_lifetimes(lts: &[RefLt]) -> usize {\n     lts.iter().collect::<HashSet<_>>().len()\n@@ -186,17 +191,34 @@ impl<'v> Visitor<'v> for RefVisitor {\n /// Are any lifetimes mentioned in the `where` clause? If yes, we don't try to\n /// reason about elision.\n fn has_where_lifetimes(where_clause: &WhereClause) -> bool {\n-    let mut where_visitor = RefVisitor(Vec::new());\n     for predicate in &where_clause.predicates {\n         match *predicate {\n             WherePredicate::RegionPredicate(..) => return true,\n             WherePredicate::BoundPredicate(ref pred) => {\n-                walk_ty(&mut where_visitor, &pred.bounded_ty);\n+                // a predicate like F: Trait or F: for<'a> Trait<'a>\n+                let mut visitor = RefVisitor(Vec::new());\n+                // walk the type F, it may not contain LT refs\n+                walk_ty(&mut visitor, &pred.bounded_ty);\n+                if !visitor.0.is_empty() { return true; }\n+                // if the bounds define new lifetimes, they are fine to occur\n+                let allowed_lts = allowed_lts_from(&pred.bound_lifetimes);\n+                // now walk the bounds\n+                for bound in pred.bounds.iter() {\n+                    walk_ty_param_bound(&mut visitor, bound);\n+                }\n+                // and check that all lifetimes are allowed\n+                for lt in visitor.into_vec() {\n+                    if !allowed_lts.contains(&lt) {\n+                        return true;\n+                    }\n+                }\n             }\n             WherePredicate::EqPredicate(ref pred) => {\n-                walk_ty(&mut where_visitor, &pred.ty);\n+                let mut visitor = RefVisitor(Vec::new());\n+                walk_ty(&mut visitor, &pred.ty);\n+                if !visitor.0.is_empty() { return true; }\n             }\n         }\n     }\n-    !where_visitor.into_vec().is_empty()\n+    false\n }"}, {"sha": "0b24ca65241e92fe5f7147b9dcfe6905d3513f69", "filename": "tests/compile-fail/lifetimes.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e33bef685ef43cdefad624e73536927e766dec1e/tests%2Fcompile-fail%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33bef685ef43cdefad624e73536927e766dec1e/tests%2Fcompile-fail%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Flifetimes.rs?ref=e33bef685ef43cdefad624e73536927e766dec1e", "patch": "@@ -46,6 +46,18 @@ fn lifetime_param_3<'a, 'b: 'a>(_x: Ref<'a>, _y: &'b u8) { } // no error, bounde\n \n fn lifetime_param_4<'a, 'b>(_x: Ref<'a>, _y: &'b u8) where 'b: 'a { } // no error, bounded lifetime\n \n+struct Lt<'a, I: 'static> {\n+    x: &'a I\n+}\n+\n+fn fn_bound<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n+    where F: Fn(Lt<'a, I>) -> Lt<'a, I>  // no error, fn bound references 'a\n+{ unreachable!() }\n+\n+fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>  //~ERROR explicit lifetimes given\n+    where for<'x> F: Fn(Lt<'x, I>) -> Lt<'x, I>\n+{ unreachable!() }\n+\n struct X {\n     x: u8,\n }"}]}