{"sha": "6e5af8996d748fe9e75c53d9ae83c7a8cd6b317f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNWFmODk5NmQ3NDhmZTllNzVjNTNkOWFlODNjN2E4Y2Q2YjMxN2Y=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-18T23:31:23Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-18T23:31:23Z"}, "message": "Get rid of equal_type_structures. Closes #514.", "tree": {"sha": "45dece09df2526b924f89db48187b3b3c3c91b8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45dece09df2526b924f89db48187b3b3c3c91b8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e5af8996d748fe9e75c53d9ae83c7a8cd6b317f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e5af8996d748fe9e75c53d9ae83c7a8cd6b317f", "html_url": "https://github.com/rust-lang/rust/commit/6e5af8996d748fe9e75c53d9ae83c7a8cd6b317f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e5af8996d748fe9e75c53d9ae83c7a8cd6b317f/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddc2076902c7286c3766c406e17d63a1eac90098", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddc2076902c7286c3766c406e17d63a1eac90098", "html_url": "https://github.com/rust-lang/rust/commit/ddc2076902c7286c3766c406e17d63a1eac90098"}], "stats": {"total": 185, "additions": 1, "deletions": 184}, "files": [{"sha": "aa527ed0bfd93b074a12e9628b794db0eb8d8c3c", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 184, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/6e5af8996d748fe9e75c53d9ae83c7a8cd6b317f/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e5af8996d748fe9e75c53d9ae83c7a8cd6b317f/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6e5af8996d748fe9e75c53d9ae83c7a8cd6b317f", "patch": "@@ -1568,191 +1568,8 @@ fn constrs_eq(cs: &[@constr], ds: &[@constr]) -> bool {\n     ret true;\n }\n \n-fn equal_type_structures(a: &sty, b: &sty) -> bool {\n-    fn equal_mt(a: &mt, b: &mt) -> bool {\n-        ret a.mut == b.mut && eq_ty(a.ty, b.ty);\n-    }\n-    fn equal_fn(args_a: &[arg], rty_a: &t, args_b: &[arg], rty_b: &t) ->\n-       bool {\n-        if !eq_ty(rty_a, rty_b) { ret false; }\n-        let len = vec::len::<arg>(args_a);\n-        if len != vec::len::<arg>(args_b) { ret false; }\n-        let i = 0u;\n-        while i < len {\n-            let arg_a = args_a.(i);\n-            let arg_b = args_b.(i);\n-            if arg_a.mode != arg_b.mode { ret false; }\n-            if !eq_ty(arg_a.ty, arg_b.ty) { ret false; }\n-            i += 1u;\n-        }\n-        ret true;\n-    }\n-    fn equal_def(did_a: &ast::def_id, did_b: &ast::def_id) -> bool {\n-        ret did_a.crate == did_b.crate && did_a.node == did_b.node;\n-    }\n-    alt a {\n-      ty_nil. { alt b { ty_nil. { ret true; } _ { ret false; } } }\n-      ty_bot. { alt b { ty_bot. { ret true; } _ { ret false; } } }\n-      ty_bool. { alt b { ty_bool. { ret true; } _ { ret false; } } }\n-      ty_int. { alt b { ty_int. { ret true; } _ { ret false; } } }\n-      ty_float. { alt b { ty_float. { ret true; } _ { ret false; } } }\n-      ty_uint. { alt b { ty_uint. { ret true; } _ { ret false; } } }\n-      ty_machine(tm_a) {\n-        alt b {\n-          ty_machine(tm_b) {\n-            ret hash_type_structure(a) == hash_type_structure(b);\n-          }\n-          _ { ret false; }\n-        }\n-      }\n-      ty_char. { alt b { ty_char. { ret true; } _ { ret false; } } }\n-      ty_str. { alt b { ty_str. { ret true; } _ { ret false; } } }\n-      ty_istr. { alt b { ty_istr. { ret true; } _ { ret false; } } }\n-      ty_tag(id_a, tys_a) {\n-        alt b {\n-          ty_tag(id_b, tys_b) {\n-            if !equal_def(id_a, id_b) { ret false; }\n-            let len = vec::len::<t>(tys_a);\n-            if len != vec::len::<t>(tys_b) { ret false; }\n-            let i = 0u;\n-            while i < len {\n-                if !eq_ty(tys_a.(i), tys_b.(i)) { ret false; }\n-                i += 1u;\n-            }\n-            ret true;\n-          }\n-          _ { ret false; }\n-        }\n-      }\n-      ty_box(mt_a) {\n-        alt b { ty_box(mt_b) { ret equal_mt(mt_a, mt_b); } _ { ret false; } }\n-      }\n-      ty_vec(mt_a) {\n-        alt b { ty_vec(mt_b) { ret equal_mt(mt_a, mt_b); } _ { ret false; } }\n-      }\n-      ty_ptr(mt_a) {\n-        alt b { ty_ptr(mt_b) { ret equal_mt(mt_a, mt_b); } _ { ret false; } }\n-      }\n-      ty_rec(flds_a) {\n-        alt b {\n-          ty_rec(flds_b) {\n-            let len = vec::len::<field>(flds_a);\n-            if len != vec::len::<field>(flds_b) { ret false; }\n-            let i = 0u;\n-            while i < len {\n-                let fld_a = flds_a.(i);\n-                let fld_b = flds_b.(i);\n-                if !str::eq(fld_a.ident, fld_b.ident) ||\n-                       !equal_mt(fld_a.mt, fld_b.mt) {\n-                    ret false;\n-                }\n-                i += 1u;\n-            }\n-            ret true;\n-          }\n-          _ { ret false; }\n-        }\n-      }\n-      ty_tup(ts_a) {\n-        alt (b) {\n-          ty_tup(ts_b) {\n-            let len = vec::len(ts_a);\n-            if len != vec::len(ts_b) { ret false; }\n-            let i = 0u;\n-            while i < len {\n-                if !eq_ty(ts_a.(i), ts_b.(i)) { ret false; }\n-                i += 1u;\n-            }\n-            ret true;\n-          }\n-          _ { ret false; }\n-        }\n-      }\n-\n-      ty_fn(p_a, args_a, rty_a, cf_a, constrs_a) {\n-        alt b {\n-          ty_fn(p_b, args_b, rty_b, cf_b, constrs_b) {\n-            ret p_a == p_b && cf_a == cf_b && constrs_eq(constrs_a, constrs_b)\n-                    && equal_fn(args_a, rty_a, args_b, rty_b);\n-          }\n-          _ { ret false; }\n-        }\n-      }\n-      ty_native_fn(abi_a, args_a, rty_a) {\n-        alt b {\n-          ty_native_fn(abi_b, args_b, rty_b) {\n-            ret abi_a == abi_b && equal_fn(args_a, rty_a, args_b, rty_b);\n-          }\n-          _ { ret false; }\n-        }\n-      }\n-      ty_obj(methods_a) {\n-        alt b {\n-          ty_obj(methods_b) {\n-            let len = vec::len::<method>(methods_a);\n-            if len != vec::len::<method>(methods_b) { ret false; }\n-            let i = 0u;\n-            while i < len {\n-                let m_a = methods_a.(i);\n-                let m_b = methods_b.(i);\n-                if m_a.proto != m_b.proto || !str::eq(m_a.ident, m_b.ident) ||\n-                       !equal_fn(m_a.inputs, m_a.output, m_b.inputs,\n-                                 m_b.output) {\n-                    ret false;\n-                }\n-                i += 1u;\n-            }\n-            ret true;\n-          }\n-          _ { ret false; }\n-        }\n-      }\n-      ty_res(id_a, inner_a, tps_a) {\n-        alt b {\n-          ty_res(id_b, inner_b, tps_b) {\n-            if !equal_def(id_a, id_b) || !eq_ty(inner_a, inner_b) {\n-                ret false;\n-            }\n-            let i = 0u;\n-            for tp_a: t in tps_a {\n-                if !eq_ty(tp_a, tps_b.(i)) { ret false; }\n-                i += 1u;\n-            }\n-            ret true;\n-          }\n-          _ { ret false; }\n-        }\n-      }\n-      ty_var(v_a) {\n-        alt b { ty_var(v_b) { ret v_a == v_b; } _ { ret false; } }\n-      }\n-      ty_param(pid_a,k_a) {\n-        alt b { ty_param(pid_b,k_b) { ret pid_a == pid_b && k_a == k_b; }\n-               _ { ret false; } }\n-      }\n-      ty_type. { alt b { ty_type. { ret true; } _ { ret false; } } }\n-      ty_native(a_id) {\n-        alt b {\n-          ty_native(b_id) {\n-            ret a_id.crate == b_id.crate && a_id.node == b_id.node;\n-          }\n-          _ { ret false; }\n-        }\n-      }\n-      ty_uniq(t_a) {\n-        alt b {\n-          ty_uniq(t_b) { ret t_a == t_b; }\n-          _ { ret false; }\n-        }\n-      }\n-    }\n-}\n-\n-\n // An expensive type equality function. This function is private to this\n // module.\n-//\n-// FIXME: Use structural comparison, but this loops forever and segfaults.\n fn eq_raw_ty(a: &@raw_t, b: &@raw_t) -> bool {\n     // Check hashes (fast path).\n \n@@ -1770,7 +1587,7 @@ fn eq_raw_ty(a: &@raw_t, b: &@raw_t) -> bool {\n     }\n     // Check structures.\n \n-    ret equal_type_structures(a.struct, b.struct);\n+    ret a.struct == b.struct;\n }\n \n "}]}