{"sha": "d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "node_id": "C_kwDOAAsO6NoAKGQ3ZGQwMWZlOGIwNzE2MDI1MTBlYWFjOWY2NzZhY2MwZTNjZjhlNGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-19T11:12:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-19T11:12:10Z"}, "message": "Auto merge of #103228 - Dylan-DPC:rollup-31yiauw, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #102863 (Standardize \"use parentheses to call\" suggestions between typeck and trait selection)\n - #103034 (Let expressions on RHS shouldn't be terminating scopes)\n - #103127 (Make transpose const and inline)\n - #103153 (Allow `Vec::leak` when using `no_global_oom_handling`)\n - #103182 (Clean up query descriptions)\n - #103216 (Consider patterns in fn params in an `Elided(Infer)` lifetime rib.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "85d7503010195d972b60fdbae9277584b67983a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85d7503010195d972b60fdbae9277584b67983a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "html_url": "https://github.com/rust-lang/rust/commit/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5605ed85363345f3def5da6b1ead2ac0b803bfe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5605ed85363345f3def5da6b1ead2ac0b803bfe7", "html_url": "https://github.com/rust-lang/rust/commit/5605ed85363345f3def5da6b1ead2ac0b803bfe7"}, {"sha": "32159e3fa4bc9940f96bfb5fb30120c509ab259a", "url": "https://api.github.com/repos/rust-lang/rust/commits/32159e3fa4bc9940f96bfb5fb30120c509ab259a", "html_url": "https://github.com/rust-lang/rust/commit/32159e3fa4bc9940f96bfb5fb30120c509ab259a"}], "stats": {"total": 641, "additions": 417, "deletions": 224}, "files": [{"sha": "088de1979babe5cf7a4423276d42bd8b99c1bfdc", "filename": "compiler/rustc_hir_analysis/src/check/callee.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -1,6 +1,6 @@\n use super::method::probe::{IsSuggestion, Mode, ProbeScope};\n use super::method::MethodCallee;\n-use super::{DefIdOrName, Expectation, FnCtxt, TupleArgumentsFlag};\n+use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n use crate::type_error_struct;\n \n use rustc_ast::util::parser::PREC_POSTFIX;\n@@ -27,6 +27,7 @@ use rustc_span::Span;\n use rustc_target::spec::abi;\n use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n use std::iter;"}, {"sha": "08b21b82faf5a0b47e8224039be9c5cecf27d290", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -2,7 +2,6 @@ use super::FnCtxt;\n use crate::astconv::AstConv;\n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n-use hir::def_id::DefId;\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n@@ -19,6 +18,7 @@ use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -90,7 +90,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             if ty.is_suggestable(self.tcx, false) {\n                                 format!(\"/* {ty} */\")\n                             } else {\n-                                \"\".to_string()\n+                                \"/* value */\".to_string()\n                             }\n                         })\n                         .collect::<Vec<_>>()\n@@ -102,10 +102,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let msg = match def_id_or_name {\n                 DefIdOrName::DefId(def_id) => match self.tcx.def_kind(def_id) {\n-                    DefKind::Ctor(CtorOf::Struct, _) => \"instantiate this tuple struct\".to_string(),\n-                    DefKind::Ctor(CtorOf::Variant, _) => {\n-                        \"instantiate this tuple variant\".to_string()\n-                    }\n+                    DefKind::Ctor(CtorOf::Struct, _) => \"construct this tuple struct\".to_string(),\n+                    DefKind::Ctor(CtorOf::Variant, _) => \"construct this tuple variant\".to_string(),\n                     kind => format!(\"call this {}\", kind.descr(def_id)),\n                 },\n                 DefIdOrName::Name(name) => format!(\"call this {name}\"),\n@@ -1209,8 +1207,3 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n-\n-pub enum DefIdOrName {\n-    DefId(DefId),\n-    Name(&'static str),\n-}"}, {"sha": "ff32329e431b699eccdd4b7c393a0b9de36de9e5", "filename": "compiler/rustc_hir_analysis/src/check/region.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -252,9 +252,13 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             ) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n-                terminating(r.hir_id.local_id);\n-            }\n \n+                // `Let` expressions (in a let-chain) shouldn't be terminating, as their temporaries\n+                // should live beyond the immediate expression\n+                if !matches!(r.kind, hir::ExprKind::Let(_)) {\n+                    terminating(r.hir_id.local_id);\n+                }\n+            }\n             hir::ExprKind::If(_, ref then, Some(ref otherwise)) => {\n                 terminating(then.hir_id.local_id);\n                 terminating(otherwise.hir_id.local_id);"}, {"sha": "ef2c7a003fafad373a8d6f5a408b20a12baea667", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 92, "deletions": 89, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -20,27 +20,27 @@ use rustc_span::def_id::LOCAL_CRATE;\n // as they will raise an fatal error on query cycles instead.\n rustc_queries! {\n     query trigger_delay_span_bug(key: DefId) -> () {\n-        desc { \"trigger a delay span bug\" }\n+        desc { \"triggering a delay span bug\" }\n     }\n \n     query resolutions(_: ()) -> &'tcx ty::ResolverOutputs {\n         eval_always\n         no_hash\n-        desc { \"get the resolver outputs\" }\n+        desc { \"getting the resolver outputs\" }\n     }\n \n     query resolver_for_lowering(_: ()) -> &'tcx Steal<ty::ResolverAstLowering> {\n         eval_always\n         no_hash\n-        desc { \"get the resolver for lowering\" }\n+        desc { \"getting the resolver for lowering\" }\n     }\n \n     /// Return the span for a definition.\n     /// Contrary to `def_span` below, this query returns the full absolute span of the definition.\n     /// This span is meant for dep-tracking rather than diagnostics. It should not be used outside\n     /// of rustc_middle::hir::source_map.\n     query source_span(key: LocalDefId) -> Span {\n-        desc { \"get the source span\" }\n+        desc { \"getting the source span\" }\n     }\n \n     /// Represents crate as a whole (as distinct from the top-level crate module).\n@@ -52,14 +52,14 @@ rustc_queries! {\n     query hir_crate(key: ()) -> Crate<'tcx> {\n         arena_cache\n         eval_always\n-        desc { \"get the crate HIR\" }\n+        desc { \"getting the crate HIR\" }\n     }\n \n     /// All items in the crate.\n     query hir_crate_items(_: ()) -> rustc_middle::hir::ModuleItems {\n         arena_cache\n         eval_always\n-        desc { \"get HIR crate items\" }\n+        desc { \"getting HIR crate items\" }\n     }\n \n     /// The items in a module.\n@@ -68,7 +68,7 @@ rustc_queries! {\n     /// Avoid calling this query directly.\n     query hir_module_items(key: LocalDefId) -> rustc_middle::hir::ModuleItems {\n         arena_cache\n-        desc { |tcx| \"HIR module items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting HIR module items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }\n \n@@ -77,39 +77,39 @@ rustc_queries! {\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n     query hir_owner(key: hir::OwnerId) -> Option<crate::hir::Owner<'tcx>> {\n-        desc { |tcx| \"HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Gives access to the HIR ID for the given `LocalDefId` owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n     query local_def_id_to_hir_id(key: LocalDefId) -> hir::HirId {\n-        desc { |tcx| \"HIR ID of `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting HIR ID of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Gives access to the HIR node's parent for the HIR owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n     query hir_owner_parent(key: hir::OwnerId) -> hir::HirId {\n-        desc { |tcx| \"HIR parent of `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting HIR parent of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Gives access to the HIR nodes and bodies inside the HIR owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n     query hir_owner_nodes(key: hir::OwnerId) -> hir::MaybeOwner<&'tcx hir::OwnerNodes<'tcx>> {\n-        desc { |tcx| \"HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Gives access to the HIR attributes inside the HIR owner `key`.\n     ///\n     /// This can be conveniently accessed by methods on `tcx.hir()`.\n     /// Avoid calling this query directly.\n     query hir_attrs(key: hir::OwnerId) -> &'tcx hir::AttributeMap<'tcx> {\n-        desc { |tcx| \"HIR owner attributes in `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting HIR owner attributes in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     /// Computes the `DefId` of the corresponding const parameter in case the `key` is a\n@@ -138,7 +138,7 @@ rustc_queries! {\n     /// Given the def_id of a const-generic parameter, computes the associated default const\n     /// parameter. e.g. `fn example<const N: usize=3>` called on `N` would return `3`.\n     query const_param_default(param: DefId) -> ty::Const<'tcx> {\n-        desc { |tcx| \"compute const default for a given parameter `{}`\", tcx.def_path_str(param)  }\n+        desc { |tcx| \"computing const default for a given parameter `{}`\", tcx.def_path_str(param)  }\n         cache_on_disk_if { param.is_local() }\n         separate_provide_extern\n     }\n@@ -167,7 +167,7 @@ rustc_queries! {\n     query collect_trait_impl_trait_tys(key: DefId)\n         -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed>\n     {\n-        desc { \"compare an impl and trait method signature, inferring any hidden `impl Trait` types in the process\" }\n+        desc { \"comparing an impl and trait method signature, inferring any hidden `impl Trait` types in the process\" }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n@@ -290,11 +290,11 @@ rustc_queries! {\n \n     query parent_module_from_def_id(key: LocalDefId) -> LocalDefId {\n         eval_always\n-        desc { |tcx| \"parent module of `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"getting the parent module of `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n     query expn_that_defined(key: DefId) -> rustc_span::ExpnId {\n-        desc { |tcx| \"expansion that defined `{}`\", tcx.def_path_str(key) }\n+        desc { |tcx| \"getting the expansion that defined `{}`\", tcx.def_path_str(key) }\n         separate_provide_extern\n     }\n \n@@ -306,7 +306,7 @@ rustc_queries! {\n \n     /// Checks whether a type is representable or infinitely sized\n     query representability(_: LocalDefId) -> rustc_middle::ty::Representability {\n-        desc { \"checking if {:?} is representable\", tcx.def_path_str(key.to_def_id()) }\n+        desc { \"checking if `{}` is representable\", tcx.def_path_str(key.to_def_id()) }\n         // infinitely sized types will cause a cycle\n         cycle_delay_bug\n         // we don't want recursive representability calls to be forced with\n@@ -317,7 +317,7 @@ rustc_queries! {\n \n     /// An implementation detail for the `representability` query\n     query representability_adt_ty(_: Ty<'tcx>) -> rustc_middle::ty::Representability {\n-        desc { \"checking if {:?} is representable\", key }\n+        desc { \"checking if `{}` is representable\", key }\n         cycle_delay_bug\n         anon\n     }\n@@ -383,7 +383,7 @@ rustc_queries! {\n     /// See the README for the `mir` module for details.\n     query mir_const(key: ty::WithOptConstParam<LocalDefId>) -> &'tcx Steal<mir::Body<'tcx>> {\n         desc {\n-            |tcx| \"processing MIR for {}`{}`\",\n+            |tcx| \"preparing {}`{}` for borrow checking\",\n             if key.const_param_did.is_some() { \"the const argument \" } else { \"\" },\n             tcx.def_path_str(key.did.to_def_id()),\n         }\n@@ -395,7 +395,7 @@ rustc_queries! {\n         key: DefId\n     ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n         desc {\n-            |tcx| \"building an abstract representation for {}\", tcx.def_path_str(key),\n+            |tcx| \"building an abstract representation for `{}`\", tcx.def_path_str(key),\n         }\n         separate_provide_extern\n     }\n@@ -405,7 +405,7 @@ rustc_queries! {\n     ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n         desc {\n             |tcx|\n-            \"building an abstract representation for the const argument {}\",\n+            \"building an abstract representation for the const argument `{}`\",\n             tcx.def_path_str(key.0.to_def_id()),\n         }\n     }\n@@ -414,7 +414,7 @@ rustc_queries! {\n         ty::ParamEnvAnd<'tcx, (ty::UnevaluatedConst<'tcx>, ty::UnevaluatedConst<'tcx>\n     )>) -> bool {\n         desc {\n-            |tcx| \"trying to unify the generic constants {} and {}\",\n+            |tcx| \"trying to unify the generic constants `{}` and `{}`\",\n             tcx.def_path_str(key.value.0.def.did), tcx.def_path_str(key.value.1.def.did)\n         }\n     }\n@@ -436,7 +436,7 @@ rustc_queries! {\n \n     query mir_for_ctfe_of_const_arg(key: (LocalDefId, DefId)) -> &'tcx mir::Body<'tcx> {\n         desc {\n-            |tcx| \"MIR for CTFE of the const argument `{}`\",\n+            |tcx| \"caching MIR for CTFE of the const argument `{}`\",\n             tcx.def_path_str(key.0.to_def_id())\n         }\n     }\n@@ -448,7 +448,7 @@ rustc_queries! {\n         ) {\n         no_hash\n         desc {\n-            |tcx| \"processing {}`{}`\",\n+            |tcx| \"processing MIR for {}`{}`\",\n             if key.const_param_did.is_some() { \"the const argument \" } else { \"\" },\n             tcx.def_path_str(key.did.to_def_id()),\n         }\n@@ -459,7 +459,7 @@ rustc_queries! {\n     ) -> Vec<rustc_span::Symbol> {\n         arena_cache\n         desc {\n-            |tcx| \"symbols for captures of closure `{}` in `{}`\",\n+            |tcx| \"finding symbols for captures of closure `{}` in `{}`\",\n             tcx.def_path_str(key.1.to_def_id()),\n             tcx.def_path_str(key.0.to_def_id())\n         }\n@@ -521,12 +521,12 @@ rustc_queries! {\n         // queries). Making it anonymous avoids hashing the result, which\n         // may save a bit of time.\n         anon\n-        desc { \"erasing regions from `{:?}`\", ty }\n+        desc { \"erasing regions from `{}`\", ty }\n     }\n \n     query wasm_import_module_map(_: CrateNum) -> FxHashMap<DefId, String> {\n         arena_cache\n-        desc { \"wasm import module map\" }\n+        desc { \"getting wasm import module map\" }\n     }\n \n     /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n@@ -706,7 +706,7 @@ rustc_queries! {\n     /// Collects the associated items defined on a trait or impl.\n     query associated_items(key: DefId) -> ty::AssocItems<'tcx> {\n         arena_cache\n-        desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n+        desc { |tcx| \"collecting associated items of `{}`\", tcx.def_path_str(key) }\n     }\n \n     /// Maps from associated items on a trait to the corresponding associated\n@@ -732,7 +732,7 @@ rustc_queries! {\n     ///`{ trait_f: impl_f, trait_g: impl_g }`\n     query impl_item_implementor_ids(impl_id: DefId) -> FxHashMap<DefId, DefId> {\n         arena_cache\n-        desc { |tcx| \"comparing impl items against trait for {}\", tcx.def_path_str(impl_id) }\n+        desc { |tcx| \"comparing impl items against trait for `{}`\", tcx.def_path_str(impl_id) }\n     }\n \n     /// Given an `impl_id`, return the trait it implements.\n@@ -804,7 +804,7 @@ rustc_queries! {\n     /// Note that we've liberated the late bound regions of function signatures, so\n     /// this can not be used to check whether these types are well formed.\n     query assumed_wf_types(key: DefId) -> &'tcx ty::List<Ty<'tcx>> {\n-        desc { |tcx| \"computing the implied bounds of {}\", tcx.def_path_str(key) }\n+        desc { |tcx| \"computing the implied bounds of `{}`\", tcx.def_path_str(key) }\n     }\n \n     /// Computes the signature of the function.\n@@ -853,7 +853,7 @@ rustc_queries! {\n     }\n \n     query check_liveness(key: DefId) {\n-        desc { |tcx| \"checking liveness of variables in {}\", tcx.def_path_str(key) }\n+        desc { |tcx| \"checking liveness of variables in `{}`\", tcx.def_path_str(key) }\n     }\n \n     /// Return the live symbols in the crate for dead code check.\n@@ -865,7 +865,7 @@ rustc_queries! {\n         FxHashMap<LocalDefId, Vec<(DefId, DefId)>>\n     ) {\n         arena_cache\n-        desc { \"find live symbols in crate\" }\n+        desc { \"finding live symbols in crate\" }\n     }\n \n     query check_mod_deathness(key: LocalDefId) -> () {\n@@ -913,7 +913,7 @@ rustc_queries! {\n     }\n \n     query used_trait_imports(key: LocalDefId) -> &'tcx FxHashSet<LocalDefId> {\n-        desc { |tcx| \"used_trait_imports `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"finding used_trait_imports `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }\n \n@@ -942,7 +942,7 @@ rustc_queries! {\n     /// Not meant to be used directly outside of coherence.\n     query crate_inherent_impls(k: ()) -> CrateInherentImpls {\n         arena_cache\n-        desc { \"all inherent impls defined in crate\" }\n+        desc { \"finding all inherent impls defined in crate\" }\n     }\n \n     /// Checks all types in the crate for overlap in their inherent impls. Reports errors.\n@@ -1032,7 +1032,7 @@ rustc_queries! {\n     query try_destructure_mir_constant(\n         key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>\n     ) -> Option<mir::DestructuredConstant<'tcx>> {\n-        desc { \"destructuring mir constant\"}\n+        desc { \"destructuring MIR constant\"}\n         remap_env_constness\n     }\n \n@@ -1041,12 +1041,12 @@ rustc_queries! {\n     query deref_mir_constant(\n         key: ty::ParamEnvAnd<'tcx, mir::ConstantKind<'tcx>>\n     ) -> mir::ConstantKind<'tcx> {\n-        desc { \"dereferencing mir constant\" }\n+        desc { \"dereferencing MIR constant\" }\n         remap_env_constness\n     }\n \n     query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n-        desc { \"get a &core::panic::Location referring to a span\" }\n+        desc { \"getting a &core::panic::Location referring to a span\" }\n     }\n \n     // FIXME get rid of this with valtrees\n@@ -1068,7 +1068,7 @@ rustc_queries! {\n     /// Performs part of the privacy check and computes \"access levels\".\n     query privacy_access_levels(_: ()) -> &'tcx AccessLevels {\n         eval_always\n-        desc { \"privacy access levels\" }\n+        desc { \"checking privacy access levels\" }\n     }\n     query check_private_in_public(_: ()) -> () {\n         eval_always\n@@ -1196,29 +1196,29 @@ rustc_queries! {\n     }\n \n     query is_ctfe_mir_available(key: DefId) -> bool {\n-        desc { |tcx| \"checking if item has ctfe mir available: `{}`\", tcx.def_path_str(key) }\n+        desc { |tcx| \"checking if item has CTFE MIR available: `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n     query is_mir_available(key: DefId) -> bool {\n-        desc { |tcx| \"checking if item has mir available: `{}`\", tcx.def_path_str(key) }\n+        desc { |tcx| \"checking if item has MIR available: `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n \n     query own_existential_vtable_entries(\n         key: ty::PolyExistentialTraitRef<'tcx>\n     ) -> &'tcx [DefId] {\n-        desc { |tcx| \"finding all existential vtable entries for trait {}\", tcx.def_path_str(key.def_id()) }\n+        desc { |tcx| \"finding all existential vtable entries for trait `{}`\", tcx.def_path_str(key.def_id()) }\n     }\n \n     query vtable_entries(key: ty::PolyTraitRef<'tcx>)\n                         -> &'tcx [ty::VtblEntry<'tcx>] {\n-        desc { |tcx| \"finding all vtable entries for trait {}\", tcx.def_path_str(key.def_id()) }\n+        desc { |tcx| \"finding all vtable entries for trait `{}`\", tcx.def_path_str(key.def_id()) }\n     }\n \n     query vtable_trait_upcasting_coercion_new_vptr_slot(key: (Ty<'tcx>, Ty<'tcx>)) -> Option<usize> {\n-        desc { |tcx| \"finding the slot within vtable for trait object {} vtable ptr during trait upcasting coercion from {} vtable\",\n+        desc { |tcx| \"finding the slot within vtable for trait object `{}` vtable ptr during trait upcasting coercion from `{}` vtable\",\n             key.1, key.0 }\n     }\n \n@@ -1238,13 +1238,13 @@ rustc_queries! {\n \n     /// Return all `impl` blocks in the current crate.\n     query all_local_trait_impls(_: ()) -> &'tcx rustc_data_structures::fx::FxIndexMap<DefId, Vec<LocalDefId>> {\n-        desc { \"local trait impls\" }\n+        desc { \"finding local trait impls\" }\n     }\n \n     /// Given a trait `trait_id`, return all known `impl` blocks.\n     query trait_impls_of(trait_id: DefId) -> ty::trait_def::TraitImpls {\n         arena_cache\n-        desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(trait_id) }\n+        desc { |tcx| \"finding trait impls of `{}`\", tcx.def_path_str(trait_id) }\n     }\n \n     query specialization_graph_of(trait_id: DefId) -> specialization_graph::Graph {\n@@ -1253,7 +1253,7 @@ rustc_queries! {\n         cache_on_disk_if { true }\n     }\n     query object_safety_violations(trait_id: DefId) -> &'tcx [traits::ObjectSafetyViolation] {\n-        desc { |tcx| \"determine object safety of trait `{}`\", tcx.def_path_str(trait_id) }\n+        desc { |tcx| \"determining object safety of trait `{}`\", tcx.def_path_str(trait_id) }\n     }\n \n     /// Gets the ParameterEnvironment for a given item; this environment\n@@ -1311,7 +1311,7 @@ rustc_queries! {\n     /// correctly.\n     query has_structural_eq_impls(ty: Ty<'tcx>) -> bool {\n         desc {\n-            \"computing whether `{:?}` implements `PartialStructuralEq` and `StructuralEq`\",\n+            \"computing whether `{}` implements `PartialStructuralEq` and `StructuralEq`\",\n             ty\n         }\n     }\n@@ -1370,13 +1370,13 @@ rustc_queries! {\n \n     query dylib_dependency_formats(_: CrateNum)\n                                     -> &'tcx [(CrateNum, LinkagePreference)] {\n-        desc { \"dylib dependency formats of crate\" }\n+        desc { \"getting dylib dependency formats of crate\" }\n         separate_provide_extern\n     }\n \n     query dependency_formats(_: ()) -> Lrc<crate::middle::dependency_format::Dependencies> {\n         arena_cache\n-        desc { \"get the linkage format of all dependencies\" }\n+        desc { \"getting the linkage format of all dependencies\" }\n     }\n \n     query is_compiler_builtins(_: CrateNum) -> bool {\n@@ -1398,31 +1398,31 @@ rustc_queries! {\n     }\n     query is_profiler_runtime(_: CrateNum) -> bool {\n         fatal_cycle\n-        desc { \"query a crate is `#![profiler_runtime]`\" }\n+        desc { \"checking if a crate is `#![profiler_runtime]`\" }\n         separate_provide_extern\n     }\n     query has_ffi_unwind_calls(key: LocalDefId) -> bool {\n-        desc { |tcx| \"check if `{}` contains FFI-unwind calls\", tcx.def_path_str(key.to_def_id()) }\n+        desc { |tcx| \"checking if `{}` contains FFI-unwind calls\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }\n     query required_panic_strategy(_: CrateNum) -> Option<PanicStrategy> {\n         fatal_cycle\n-        desc { \"query a crate's required panic strategy\" }\n+        desc { \"getting a crate's required panic strategy\" }\n         separate_provide_extern\n     }\n     query panic_in_drop_strategy(_: CrateNum) -> PanicStrategy {\n         fatal_cycle\n-        desc { \"query a crate's configured panic-in-drop strategy\" }\n+        desc { \"getting a crate's configured panic-in-drop strategy\" }\n         separate_provide_extern\n     }\n     query is_no_builtins(_: CrateNum) -> bool {\n         fatal_cycle\n-        desc { \"test whether a crate has `#![no_builtins]`\" }\n+        desc { \"getting whether a crate has `#![no_builtins]`\" }\n         separate_provide_extern\n     }\n     query symbol_mangling_version(_: CrateNum) -> SymbolManglingVersion {\n         fatal_cycle\n-        desc { \"query a crate's symbol mangling version\" }\n+        desc { \"getting a crate's symbol mangling version\" }\n         separate_provide_extern\n     }\n \n@@ -1437,7 +1437,7 @@ rustc_queries! {\n     }\n     query in_scope_traits_map(_: hir::OwnerId)\n         -> Option<&'tcx FxHashMap<ItemLocalId, Box<[TraitCandidate]>>> {\n-        desc { \"traits in scope at a block\" }\n+        desc { \"getting traits in scope at a block\" }\n     }\n \n     query module_reexports(def_id: LocalDefId) -> Option<&'tcx [ModChild]> {\n@@ -1588,17 +1588,17 @@ rustc_queries! {\n     }\n \n     query is_dllimport_foreign_item(def_id: DefId) -> bool {\n-        desc { |tcx| \"is_dllimport_foreign_item({})\", tcx.def_path_str(def_id) }\n+        desc { |tcx| \"checking if `{}` is a a dylib\", tcx.def_path_str(def_id) }\n     }\n     query is_statically_included_foreign_item(def_id: DefId) -> bool {\n-        desc { |tcx| \"is_statically_included_foreign_item({})\", tcx.def_path_str(def_id) }\n+        desc { |tcx| \"checking if `{}` is a staticlib\", tcx.def_path_str(def_id) }\n     }\n     query native_library_kind(def_id: DefId)\n         -> Option<NativeLibKind> {\n-        desc { |tcx| \"native_library_kind({})\", tcx.def_path_str(def_id) }\n+        desc { |tcx| \"getting the native library kind of `{}`\", tcx.def_path_str(def_id) }\n     }\n     query native_library(def_id: DefId) -> Option<&'tcx NativeLib> {\n-        desc { |tcx| \"native_library({})\", tcx.def_path_str(def_id) }\n+        desc { |tcx| \"getting the native library for `{}`\", tcx.def_path_str(def_id) }\n     }\n \n     /// Does lifetime resolution, but does not descend into trait items. This\n@@ -1659,7 +1659,7 @@ rustc_queries! {\n     query type_uninhabited_from(\n         key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n     ) -> ty::inhabitedness::DefIdForest<'tcx> {\n-        desc { \"computing the inhabitedness of `{:?}`\", key }\n+        desc { \"computing the inhabitedness of `{}`\", key.value }\n         remap_env_constness\n     }\n \n@@ -1698,7 +1698,7 @@ rustc_queries! {\n     }\n     /// Whether the function is an intrinsic\n     query is_intrinsic(def_id: DefId) -> bool {\n-        desc { |tcx| \"is_intrinsic({})\", tcx.def_path_str(def_id) }\n+        desc { |tcx| \"checking whether `{}` is an intrinsic\", tcx.def_path_str(def_id) }\n         separate_provide_extern\n     }\n     /// Returns the lang items defined in another crate by loading it from metadata.\n@@ -1765,12 +1765,12 @@ rustc_queries! {\n     /// is marked as a private dependency\n     query is_private_dep(c: CrateNum) -> bool {\n         eval_always\n-        desc { \"check whether crate {} is a private dependency\", c }\n+        desc { \"checking whether crate `{}` is a private dependency\", c }\n         separate_provide_extern\n     }\n     query allocator_kind(_: ()) -> Option<AllocatorKind> {\n         eval_always\n-        desc { \"allocator kind for the current crate\" }\n+        desc { \"getting the allocator kind for the current crate\" }\n     }\n \n     query upvars_mentioned(def_id: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n@@ -1783,7 +1783,7 @@ rustc_queries! {\n         desc { \"looking up all possibly unused extern crates\" }\n     }\n     query names_imported_by_glob_use(def_id: LocalDefId) -> &'tcx FxHashSet<Symbol> {\n-        desc { |tcx| \"names_imported_by_glob_use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n+        desc { |tcx| \"finding names imported by glob use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n \n     query stability_index(_: ()) -> stability::Index {\n@@ -1809,7 +1809,7 @@ rustc_queries! {\n     ///   correspond to a publicly visible symbol in `cnum` machine code.\n     /// - The `exported_symbols` sets of different crates do not intersect.\n     query exported_symbols(cnum: CrateNum) -> &'tcx [(ExportedSymbol<'tcx>, SymbolExportInfo)] {\n-        desc { \"exported_symbols\" }\n+        desc { \"collecting exported symbols for crate `{}`\", cnum}\n         cache_on_disk_if { *cnum == LOCAL_CRATE }\n         separate_provide_extern\n     }\n@@ -1818,19 +1818,21 @@ rustc_queries! {\n         eval_always\n         desc { \"collect_and_partition_mono_items\" }\n     }\n+\n     query is_codegened_item(def_id: DefId) -> bool {\n         desc { |tcx| \"determining whether `{}` needs codegen\", tcx.def_path_str(def_id) }\n     }\n \n     /// All items participating in code generation together with items inlined into them.\n     query codegened_and_inlined_items(_: ()) -> &'tcx DefIdSet {\n         eval_always\n-       desc { \"codegened_and_inlined_items\" }\n+        desc { \"collecting codegened and inlined items\" }\n     }\n \n-    query codegen_unit(_: Symbol) -> &'tcx CodegenUnit<'tcx> {\n-        desc { \"codegen_unit\" }\n+    query codegen_unit(sym: Symbol) -> &'tcx CodegenUnit<'tcx> {\n+        desc { \"getting codegen unit `{sym}`\" }\n     }\n+\n     query unused_generic_params(key: ty::InstanceDef<'tcx>) -> FiniteBitSet<u32> {\n         cache_on_disk_if { key.def_id().is_local() }\n         desc {\n@@ -1839,6 +1841,7 @@ rustc_queries! {\n         }\n         separate_provide_extern\n     }\n+\n     query backend_optimization_level(_: ()) -> OptLevel {\n         desc { \"optimization level used by backend\" }\n     }\n@@ -1849,7 +1852,7 @@ rustc_queries! {\n     /// has been destroyed.\n     query output_filenames(_: ()) -> &'tcx Arc<OutputFilenames> {\n         eval_always\n-        desc { \"output_filenames\" }\n+        desc { \"getting output filenames\" }\n     }\n \n     /// Do not call this query directly: invoke `normalize` instead.\n@@ -1859,7 +1862,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>,\n         NoSolution,\n     > {\n-        desc { \"normalizing `{:?}`\", goal }\n+        desc { \"normalizing `{}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -1877,7 +1880,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n         NoSolution,\n     > {\n-        desc { \"computing implied outlives bounds for `{:?}`\", goal }\n+        desc { \"computing implied outlives bounds for `{}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -1889,7 +1892,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>,\n         NoSolution,\n     > {\n-        desc { \"computing dropck types for `{:?}`\", goal }\n+        desc { \"computing dropck types for `{}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -1917,7 +1920,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n         NoSolution,\n     > {\n-        desc { \"evaluating `type_op_ascribe_user_type` `{:?}`\", goal }\n+        desc { \"evaluating `type_op_ascribe_user_type` `{:?}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -1928,7 +1931,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n         NoSolution,\n     > {\n-        desc { \"evaluating `type_op_eq` `{:?}`\", goal }\n+        desc { \"evaluating `type_op_eq` `{:?}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -1939,7 +1942,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n         NoSolution,\n     > {\n-        desc { \"evaluating `type_op_subtype` `{:?}`\", goal }\n+        desc { \"evaluating `type_op_subtype` `{:?}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -1950,7 +1953,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n         NoSolution,\n     > {\n-        desc { \"evaluating `type_op_prove_predicate` `{:?}`\", goal }\n+        desc { \"evaluating `type_op_prove_predicate` `{:?}`\", goal.value.value }\n     }\n \n     /// Do not call this query directly: part of the `Normalize` type-op\n@@ -1960,7 +1963,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Ty<'tcx>>>,\n         NoSolution,\n     > {\n-        desc { \"normalizing `{:?}`\", goal }\n+        desc { \"normalizing `{}`\", goal.value.value.value }\n         remap_env_constness\n     }\n \n@@ -1971,7 +1974,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::Predicate<'tcx>>>,\n         NoSolution,\n     > {\n-        desc { \"normalizing `{:?}`\", goal }\n+        desc { \"normalizing `{:?}`\", goal.value.value.value }\n         remap_env_constness\n     }\n \n@@ -1982,7 +1985,7 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::PolyFnSig<'tcx>>>,\n         NoSolution,\n     > {\n-        desc { \"normalizing `{:?}`\", goal }\n+        desc { \"normalizing `{:?}`\", goal.value.value.value }\n         remap_env_constness\n     }\n \n@@ -1993,20 +1996,20 @@ rustc_queries! {\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::FnSig<'tcx>>>,\n         NoSolution,\n     > {\n-        desc { \"normalizing `{:?}`\", goal }\n+        desc { \"normalizing `{:?}`\", goal.value.value.value }\n         remap_env_constness\n     }\n \n     query subst_and_check_impossible_predicates(key: (DefId, SubstsRef<'tcx>)) -> bool {\n         desc { |tcx|\n-            \"impossible substituted predicates:`{}`\",\n+            \"checking impossible substituted predicates: `{}`\",\n             tcx.def_path_str(key.0)\n         }\n     }\n \n     query is_impossible_method(key: (DefId, DefId)) -> bool {\n         desc { |tcx|\n-            \"checking if {} is impossible to call within {}\",\n+            \"checking if `{}` is impossible to call within `{}`\",\n             tcx.def_path_str(key.1),\n             tcx.def_path_str(key.0),\n         }\n@@ -2015,7 +2018,7 @@ rustc_queries! {\n     query method_autoderef_steps(\n         goal: CanonicalTyGoal<'tcx>\n     ) -> MethodAutoderefStepsResult<'tcx> {\n-        desc { \"computing autoderef types for `{:?}`\", goal }\n+        desc { \"computing autoderef types for `{}`\", goal.value.value }\n         remap_env_constness\n     }\n \n@@ -2063,7 +2066,7 @@ rustc_queries! {\n     }\n \n     query normalize_opaque_types(key: &'tcx ty::List<ty::Predicate<'tcx>>) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n-        desc { \"normalizing opaque types in {:?}\", key }\n+        desc { \"normalizing opaque types in `{:?}`\", key }\n     }\n \n     /// Checks whether a type is definitely uninhabited. This is\n@@ -2073,7 +2076,7 @@ rustc_queries! {\n     /// will be `Abi::Uninhabited`. (Note that uninhabited types may have nonzero\n     /// size, to account for partial initialisation. See #49298 for details.)\n     query conservative_is_privately_uninhabited(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-        desc { \"conservatively checking if {:?} is privately uninhabited\", key }\n+        desc { \"conservatively checking if `{}` is privately uninhabited\", key.value }\n         remap_env_constness\n     }\n \n@@ -2093,7 +2096,7 @@ rustc_queries! {\n         arena_cache\n         eval_always\n         no_hash\n-        desc { \"performing HIR wf-checking for predicate {:?} at item {:?}\", key.0, key.1 }\n+        desc { \"performing HIR wf-checking for predicate `{:?}` at item `{:?}`\", key.0, key.1 }\n     }\n \n \n@@ -2112,11 +2115,11 @@ rustc_queries! {\n     }\n \n     query permits_uninit_init(key: TyAndLayout<'tcx>) -> bool {\n-        desc { \"checking to see if {:?} permits being left uninit\", key.ty }\n+        desc { \"checking to see if `{}` permits being left uninit\", key.ty }\n     }\n \n     query permits_zero_init(key: TyAndLayout<'tcx>) -> bool {\n-        desc { \"checking to see if {:?} permits being left zeroed\", key.ty }\n+        desc { \"checking to see if `{}` permits being left zeroed\", key.ty }\n     }\n \n     query compare_assoc_const_impl_item_with_trait_item("}, {"sha": "59efb5aff7531d2fb7c09e4577345aa930d13890", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -1862,9 +1862,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n         for (index, (pat, ty)) in inputs.enumerate() {\n             debug!(?pat, ?ty);\n-            if let Some(pat) = pat {\n-                self.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n-            }\n+            self.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n+                if let Some(pat) = pat {\n+                    this.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n+                }\n+            });\n             self.visit_ty(ty);\n \n             if let Some(ref candidates) = self.lifetime_elision_candidates {\n@@ -2834,10 +2836,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n     fn resolve_params(&mut self, params: &'ast [Param]) {\n         let mut bindings = smallvec![(PatBoundCtx::Product, Default::default())];\n-        for Param { pat, ty, .. } in params {\n-            self.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n+        self.with_lifetime_rib(LifetimeRibKind::Elided(LifetimeRes::Infer), |this| {\n+            for Param { pat, .. } in params {\n+                this.resolve_pattern(pat, PatternSource::FnParam, &mut bindings);\n+            }\n+        });\n+        for Param { ty, .. } in params {\n             self.visit_ty(ty);\n-            debug!(\"(resolving function / closure) recorded parameter\");\n         }\n     }\n "}, {"sha": "b7e6a564f3953f5c113706bf4b9d5bae37f600f8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -2,10 +2,10 @@ pub mod on_unimplemented;\n pub mod suggestions;\n \n use super::{\n-    EvaluationResult, FulfillmentContext, FulfillmentError, FulfillmentErrorCode,\n-    MismatchedProjectionTypes, Obligation, ObligationCause, ObligationCauseCode,\n-    OnUnimplementedDirective, OnUnimplementedNote, OutputTypeParameterMismatch, Overflow,\n-    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n+    FulfillmentContext, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n+    Obligation, ObligationCause, ObligationCauseCode, OnUnimplementedDirective,\n+    OnUnimplementedNote, OutputTypeParameterMismatch, Overflow, PredicateObligation,\n+    SelectionContext, SelectionError, TraitNotObjectSafe,\n };\n \n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n@@ -2796,3 +2796,8 @@ impl<'tcx> ty::TypeVisitor<'tcx> for HasNumericInferVisitor {\n         }\n     }\n }\n+\n+pub enum DefIdOrName {\n+    DefId(DefId),\n+    Name(&'static str),\n+}"}, {"sha": "8c41d9d240c704c00ee77240a97ab3ca1e0a9cef", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 153, "deletions": 64, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -1,12 +1,13 @@\n use super::{\n-    EvaluationResult, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation,\n+    DefIdOrName, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation,\n     SelectionContext,\n };\n \n use crate::autoderef::Autoderef;\n use crate::infer::InferCtxt;\n use crate::traits::normalize_to;\n \n+use hir::def::CtorOf;\n use hir::HirId;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -22,14 +23,15 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::hir::map;\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n     GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, IsSuggestable,\n     ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use std::fmt;\n@@ -812,74 +814,136 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n-        // Skipping binder here, remapping below\n-        let self_ty = trait_pred.self_ty().skip_binder();\n-\n-        let (def_id, output_ty, callable) = match *self_ty.kind() {\n-            ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig().output(), \"closure\"),\n-            ty::FnDef(def_id, _) => (def_id, self_ty.fn_sig(self.tcx).output(), \"function\"),\n-            _ => return false,\n-        };\n-        let msg = format!(\"use parentheses to call the {}\", callable);\n+        if let ty::PredicateKind::Trait(trait_pred) = obligation.predicate.kind().skip_binder()\n+            && Some(trait_pred.def_id()) == self.tcx.lang_items().sized_trait()\n+        {\n+            // Don't suggest calling to turn an unsized type into a sized type\n+            return false;\n+        }\n \n-        // \"We should really create a single list of bound vars from the combined vars\n-        // from the predicate and function, but instead we just liberate the function bound vars\"\n-        let output_ty = self.tcx.liberate_late_bound_regions(def_id, output_ty);\n+        // This is duplicated from `extract_callable_info` in typeck, which\n+        // relies on autoderef, so we can't use it here.\n+        let found = trait_pred.self_ty().skip_binder().peel_refs();\n+        let Some((def_id_or_name, output, inputs)) = (match *found.kind()\n+        {\n+            ty::FnPtr(fn_sig) => {\n+                Some((DefIdOrName::Name(\"function pointer\"), fn_sig.output(), fn_sig.inputs()))\n+            }\n+            ty::FnDef(def_id, _) => {\n+                let fn_sig = found.fn_sig(self.tcx);\n+                Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs()))\n+            }\n+            ty::Closure(def_id, substs) => {\n+                let fn_sig = substs.as_closure().sig();\n+                Some((\n+                    DefIdOrName::DefId(def_id),\n+                    fn_sig.output(),\n+                    fn_sig.inputs().map_bound(|inputs| &inputs[1..]),\n+                ))\n+            }\n+            ty::Opaque(def_id, substs) => {\n+                self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n+                    if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                    && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                    // args tuple will always be substs[1]\n+                    && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                    {\n+                        Some((\n+                            DefIdOrName::DefId(def_id),\n+                            pred.kind().rebind(proj.term.ty().unwrap()),\n+                            pred.kind().rebind(args.as_slice()),\n+                        ))\n+                    } else {\n+                        None\n+                    }\n+                })\n+            }\n+            ty::Dynamic(data, _, ty::Dyn) => {\n+                data.iter().find_map(|pred| {\n+                    if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n+                    && Some(proj.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                    // for existential projection, substs are shifted over by 1\n+                    && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n+                    {\n+                        Some((\n+                            DefIdOrName::Name(\"trait object\"),\n+                            pred.rebind(proj.term.ty().unwrap()),\n+                            pred.rebind(args.as_slice()),\n+                        ))\n+                    } else {\n+                        None\n+                    }\n+                })\n+            }\n+            ty::Param(_) => {\n+                obligation.param_env.caller_bounds().iter().find_map(|pred| {\n+                    if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                    && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                    && proj.projection_ty.self_ty() == found\n+                    // args tuple will always be substs[1]\n+                    && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                    {\n+                        Some((\n+                            DefIdOrName::Name(\"type parameter\"),\n+                            pred.kind().rebind(proj.term.ty().unwrap()),\n+                            pred.kind().rebind(args.as_slice()),\n+                        ))\n+                    } else {\n+                        None\n+                    }\n+                })\n+            }\n+            _ => None,\n+        }) else { return false; };\n+        let output = self.replace_bound_vars_with_fresh_vars(\n+            obligation.cause.span,\n+            LateBoundRegionConversionTime::FnCall,\n+            output,\n+        );\n+        let inputs = inputs.skip_binder().iter().map(|ty| {\n+            self.replace_bound_vars_with_fresh_vars(\n+                obligation.cause.span,\n+                LateBoundRegionConversionTime::FnCall,\n+                inputs.rebind(*ty),\n+            )\n+        });\n \n         // Remapping bound vars here\n-        let trait_pred_and_self = trait_pred.map_bound(|trait_pred| (trait_pred, output_ty));\n+        let trait_pred_and_self = trait_pred.map_bound(|trait_pred| (trait_pred, output));\n \n         let new_obligation =\n             self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_pred_and_self);\n-\n-        match self.evaluate_obligation(&new_obligation) {\n-            Ok(\n-                EvaluationResult::EvaluatedToOk\n-                | EvaluationResult::EvaluatedToOkModuloRegions\n-                | EvaluationResult::EvaluatedToOkModuloOpaqueTypes\n-                | EvaluationResult::EvaluatedToAmbig,\n-            ) => {}\n-            _ => return false,\n+        if !self.predicate_must_hold_modulo_regions(&new_obligation) {\n+            return false;\n         }\n-        let hir = self.tcx.hir();\n+\n         // Get the name of the callable and the arguments to be used in the suggestion.\n-        let (snippet, sugg) = match hir.get_if_local(def_id) {\n-            Some(hir::Node::Expr(hir::Expr {\n-                kind: hir::ExprKind::Closure(hir::Closure { fn_decl, fn_decl_span, .. }),\n-                ..\n-            })) => {\n-                err.span_label(*fn_decl_span, \"consider calling this closure\");\n-                let Some(name) = self.get_closure_name(def_id, err, &msg) else {\n-                    return false;\n-                };\n-                let args = fn_decl.inputs.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n-                let sugg = format!(\"({})\", args);\n-                (format!(\"{}{}\", name, sugg), sugg)\n-            }\n-            Some(hir::Node::Item(hir::Item {\n-                ident,\n-                kind: hir::ItemKind::Fn(.., body_id),\n-                ..\n-            })) => {\n-                err.span_label(ident.span, \"consider calling this function\");\n-                let body = hir.body(*body_id);\n-                let args = body\n-                    .params\n-                    .iter()\n-                    .map(|arg| match &arg.pat.kind {\n-                        hir::PatKind::Binding(_, _, ident, None)\n-                        // FIXME: provide a better suggestion when encountering `SelfLower`, it\n-                        // should suggest a method call.\n-                        if ident.name != kw::SelfLower => ident.to_string(),\n-                        _ => \"_\".to_string(),\n-                    })\n-                    .collect::<Vec<_>>()\n-                    .join(\", \");\n-                let sugg = format!(\"({})\", args);\n-                (format!(\"{}{}\", ident, sugg), sugg)\n-            }\n-            _ => return false,\n+        let hir = self.tcx.hir();\n+\n+        let msg = match def_id_or_name {\n+            DefIdOrName::DefId(def_id) => match self.tcx.def_kind(def_id) {\n+                DefKind::Ctor(CtorOf::Struct, _) => {\n+                    \"use parentheses to construct this tuple struct\".to_string()\n+                }\n+                DefKind::Ctor(CtorOf::Variant, _) => {\n+                    \"use parentheses to construct this tuple variant\".to_string()\n+                }\n+                kind => format!(\"use parentheses to call this {}\", kind.descr(def_id)),\n+            },\n+            DefIdOrName::Name(name) => format!(\"use parentheses to call this {name}\"),\n         };\n+\n+        let args = inputs\n+            .map(|ty| {\n+                if ty.is_suggestable(self.tcx, false) {\n+                    format!(\"/* {ty} */\")\n+                } else {\n+                    \"/* value */\".to_string()\n+                }\n+            })\n+            .collect::<Vec<_>>()\n+            .join(\", \");\n+\n         if matches!(obligation.cause.code(), ObligationCauseCode::FunctionArgumentObligation { .. })\n             && obligation.cause.span.can_be_used_for_suggestions()\n         {\n@@ -890,11 +954,36 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             err.span_suggestion_verbose(\n                 obligation.cause.span.shrink_to_hi(),\n                 &msg,\n-                sugg,\n+                format!(\"({args})\"),\n                 Applicability::HasPlaceholders,\n             );\n-        } else {\n-            err.help(&format!(\"{}: `{}`\", msg, snippet));\n+        } else if let DefIdOrName::DefId(def_id) = def_id_or_name {\n+            let name = match hir.get_if_local(def_id) {\n+                Some(hir::Node::Expr(hir::Expr {\n+                    kind: hir::ExprKind::Closure(hir::Closure { fn_decl_span, .. }),\n+                    ..\n+                })) => {\n+                    err.span_label(*fn_decl_span, \"consider calling this closure\");\n+                    let Some(name) = self.get_closure_name(def_id, err, &msg) else {\n+                        return false;\n+                    };\n+                    name.to_string()\n+                }\n+                Some(hir::Node::Item(hir::Item { ident, kind: hir::ItemKind::Fn(..), .. })) => {\n+                    err.span_label(ident.span, \"consider calling this function\");\n+                    ident.to_string()\n+                }\n+                Some(hir::Node::Ctor(..)) => {\n+                    let name = self.tcx.def_path_str(def_id);\n+                    err.span_label(\n+                        self.tcx.def_span(def_id),\n+                        format!(\"consider calling the constructor for `{}`\", name),\n+                    );\n+                    name\n+                }\n+                _ => return false,\n+            };\n+            err.help(&format!(\"{msg}: `{name}({args})`\"));\n         }\n         true\n     }"}, {"sha": "b5b2eb0ece0ee4fbac7bfa81dd0904cfdd58a70b", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -2193,7 +2193,6 @@ impl<T, A: Allocator> Vec<T, A> {\n     /// static_ref[0] += 1;\n     /// assert_eq!(static_ref, &[2, 2, 3]);\n     /// ```\n-    #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"vec_leak\", since = \"1.47.0\")]\n     #[inline]\n     pub fn leak<'a>(self) -> &'a mut [T]"}, {"sha": "2fd8180f8b2a29a829c028a03dfe02fad512b1f4", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -217,6 +217,7 @@\n #![feature(unboxed_closures)]\n #![feature(unsized_fn_params)]\n #![feature(asm_const)]\n+#![feature(const_transmute_copy)]\n //\n // Target features:\n #![feature(arm_target_feature)]"}, {"sha": "efad9a9391b4c1713679a1360bf5cdee72a2b2c8", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -1297,7 +1297,8 @@ impl<T, const N: usize> MaybeUninit<[T; N]> {\n     /// let data: [MaybeUninit<u8>; 1000] = MaybeUninit::uninit().transpose();\n     /// ```\n     #[unstable(feature = \"maybe_uninit_uninit_array_transpose\", issue = \"96097\")]\n-    pub fn transpose(self) -> [MaybeUninit<T>; N] {\n+    #[inline]\n+    pub const fn transpose(self) -> [MaybeUninit<T>; N] {\n         // SAFETY: T and MaybeUninit<T> have the same layout\n         unsafe { super::transmute_copy(&ManuallyDrop::new(self)) }\n     }\n@@ -1316,7 +1317,8 @@ impl<T, const N: usize> [MaybeUninit<T>; N] {\n     /// let data: MaybeUninit<[u8; 1000]> = data.transpose();\n     /// ```\n     #[unstable(feature = \"maybe_uninit_uninit_array_transpose\", issue = \"96097\")]\n-    pub fn transpose(self) -> MaybeUninit<[T; N]> {\n+    #[inline]\n+    pub const fn transpose(self) -> MaybeUninit<[T; N]> {\n         // SAFETY: T and MaybeUninit<T> have the same layout\n         unsafe { super::transmute_copy(&ManuallyDrop::new(self)) }\n     }"}, {"sha": "c5bd520aaea0d98c95938cb75ceb05288cdc19cc", "filename": "src/test/ui/async-await/no-const-async.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -18,7 +18,7 @@ note: ...which requires borrow-checking `x`...\n    |\n LL | pub const async fn x() {}\n    | ^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `x`...\n+note: ...which requires processing MIR for `x`...\n   --> $DIR/no-const-async.rs:4:1\n    |\n LL | pub const async fn x() {}"}, {"sha": "263a35d9829114aacec90478a2e3e59ec34ad791", "filename": "src/test/ui/binop/issue-77910-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -19,7 +19,7 @@ LL |     assert_eq!(foo, y);\n    |     ^^^^^^^^^^^^^^^^^^ `for<'a> fn(&'a i32) -> &'a i32 {foo}` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n    |\n    = help: the trait `Debug` is not implemented for fn item `for<'a> fn(&'a i32) -> &'a i32 {foo}`\n-   = help: use parentheses to call the function: `foo(s)`\n+   = help: use parentheses to call this function: `foo(/* &i32 */)`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors"}, {"sha": "8ad8273fc2b9b483df2f3fca1bf33ee759cd677e", "filename": "src/test/ui/closures/closure-bounds-subtype.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fclosures%2Fclosure-bounds-subtype.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fclosures%2Fclosure-bounds-subtype.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-bounds-subtype.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -11,6 +11,10 @@ note: required by a bound in `take_const_owned`\n    |\n LL | fn take_const_owned<F>(_: F) where F: FnOnce() + Sync + Send {\n    |                                                  ^^^^ required by this bound in `take_const_owned`\n+help: use parentheses to call this type parameter\n+   |\n+LL |     take_const_owned(f());\n+   |                       ++\n help: consider further restricting this bound\n    |\n LL | fn give_owned<F>(f: F) where F: FnOnce() + Send + std::marker::Sync {"}, {"sha": "a7d891d77908c15f1e626428513ec49395b6295e", "filename": "src/test/ui/const-generics/generic_const_exprs/closures.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fclosures.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -1,4 +1,4 @@\n-error[E0391]: cycle detected when building an abstract representation for test::{constant#0}\n+error[E0391]: cycle detected when building an abstract representation for `test::{constant#0}`\n   --> $DIR/closures.rs:3:35\n    |\n LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n@@ -14,7 +14,7 @@ note: ...which requires type-checking `test::{constant#0}`...\n    |\n LL | fn test<const N: usize>() -> [u8; N + (|| 42)()] {}\n    |                                   ^^^^^^^^^^^^^\n-   = note: ...which again requires building an abstract representation for test::{constant#0}, completing the cycle\n+   = note: ...which again requires building an abstract representation for `test::{constant#0}`, completing the cycle\n note: cycle used when checking that `test` is well-formed\n   --> $DIR/closures.rs:3:1\n    |"}, {"sha": "42385216ae7656d1f135c0a33013b7ab451180ad", "filename": "src/test/ui/drop/drop_order.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -129,10 +129,10 @@ impl DropOrderCollector {\n         // take the \"else\" branch\n         if self.option_loud_drop(6).is_some() // 2\n             && self.option_loud_drop(5).is_some() // 1\n-            && let None = self.option_loud_drop(7) { // 3\n+            && let None = self.option_loud_drop(8) { // 4\n             unreachable!();\n         } else {\n-            self.print(8); // 4\n+            self.print(7); // 3\n         }\n \n         // let exprs interspersed"}, {"sha": "6401a8d14810005df90692b2486d8b7fffa0e435", "filename": "src/test/ui/drop/issue-100276.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fdrop%2Fissue-100276.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fdrop%2Fissue-100276.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fissue-100276.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+// compile-flags: -Z validate-mir\n+#![feature(let_chains)]\n+\n+fn let_chains(entry: std::io::Result<std::fs::DirEntry>) {\n+    if let Ok(entry) = entry\n+        && let Some(s) = entry.file_name().to_str()\n+        && s.contains(\"\")\n+    {}\n+}\n+\n+fn main() {}"}, {"sha": "feedfc40aaf4944a747f2add2a0d05a6f78a1a24", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -9,12 +9,12 @@ note: ...which requires borrow-checking `cycle1`...\n    |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle1`...\n+note: ...which requires processing MIR for `cycle1`...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing MIR for `cycle1`...\n+note: ...which requires preparing `cycle1` for borrow checking...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n LL | fn cycle1() -> impl Clone {\n@@ -50,12 +50,12 @@ note: ...which requires borrow-checking `cycle2`...\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `cycle2`...\n+note: ...which requires processing MIR for `cycle2`...\n   --> $DIR/auto-trait-leak.rs:19:1\n    |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing MIR for `cycle2`...\n+note: ...which requires preparing `cycle2` for borrow checking...\n   --> $DIR/auto-trait-leak.rs:19:1\n    |\n LL | fn cycle2() -> impl Clone {"}, {"sha": "42a78ed97e02524c9f0b710bfe5b9d4559d0f855", "filename": "src/test/ui/issues/issue-35241.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -11,7 +11,7 @@ LL | fn test() -> Foo { Foo }\n    |\n    = note: expected struct `Foo`\n              found fn item `fn(u32) -> Foo {Foo}`\n-help: use parentheses to instantiate this tuple struct\n+help: use parentheses to construct this tuple struct\n    |\n LL | fn test() -> Foo { Foo(/* u32 */) }\n    |                       +++++++++++"}, {"sha": "b30bcfb776c8c415cfd1277644bfac5856eba06a", "filename": "src/test/ui/issues/issue-70724-add_type_neq_err_label-unwrap.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -29,7 +29,7 @@ LL |     assert_eq!(a, 0);\n    |     ^^^^^^^^^^^^^^^^ `fn() -> i32 {a}` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n    |\n    = help: the trait `Debug` is not implemented for fn item `fn() -> i32 {a}`\n-   = help: use parentheses to call the function: `a()`\n+   = help: use parentheses to call this function: `a()`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 3 previous errors"}, {"sha": "c1425fa4243d5687a27f69315d345b198651ecd9", "filename": "src/test/ui/lifetimes/elided-lifetime-in-param-pat.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Flifetimes%2Felided-lifetime-in-param-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Flifetimes%2Felided-lifetime-in-param-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Felided-lifetime-in-param-pat.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+struct S<T> {\n+    _t: T,\n+}\n+\n+fn f(S::<&i8> { .. }: S<&i8>) {}\n+\n+fn main() {\n+    f(S { _t: &42_i8 });\n+}"}, {"sha": "6471553e93fd1168ecac4a52a49e608eb3ae041c", "filename": "src/test/ui/mir/mir_let_chains_drop_order.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fmir%2Fmir_let_chains_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fmir%2Fmir_let_chains_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_let_chains_drop_order.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -12,7 +12,7 @@ use std::panic;\n pub struct DropLogger<'a, T> {\n     extra: T,\n     id: usize,\n-    log: &'a panic::AssertUnwindSafe<RefCell<Vec<usize>>>\n+    log: &'a panic::AssertUnwindSafe<RefCell<Vec<usize>>>,\n }\n \n impl<'a, T> Drop for DropLogger<'a, T> {\n@@ -55,9 +55,9 @@ fn main() {\n             else {\n                 // 10 is not constructed\n                 d(10, None)\n-            }\n+            },\n         );\n-        assert_eq!(get(), vec![3, 8, 7, 1, 2]);\n+        assert_eq!(get(), vec![8, 7, 1, 3, 2]);\n     }\n     assert_eq!(get(), vec![0, 4, 6, 9, 5]);\n \n@@ -89,5 +89,5 @@ fn main() {\n             panic::panic_any(InjectedFailure)\n         );\n     });\n-    assert_eq!(get(), vec![14, 19, 20, 17, 15, 11, 18, 16, 12, 13]);\n+    assert_eq!(get(), vec![20, 17, 15, 11, 19, 18, 16, 12, 14, 13]);\n }"}, {"sha": "038fdfb2d51b2a4fd5258fe7cc7104e51c8f86f3", "filename": "src/test/ui/parser/fn-header-semantic-fail.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -199,7 +199,7 @@ note: ...which requires borrow-checking `main::ff5`...\n    |\n LL |     const async unsafe extern \"C\" fn ff5() {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `main::ff5`...\n+note: ...which requires processing MIR for `main::ff5`...\n   --> $DIR/fn-header-semantic-fail.rs:12:5\n    |\n LL |     const async unsafe extern \"C\" fn ff5() {}\n@@ -235,7 +235,7 @@ note: ...which requires borrow-checking `main::<impl at $DIR/fn-header-semantic-\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 28:17>::ft5`...\n+note: ...which requires processing MIR for `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 28:17>::ft5`...\n   --> $DIR/fn-header-semantic-fail.rs:33:9\n    |\n LL |         const async unsafe extern \"C\" fn ft5() {}\n@@ -271,7 +271,7 @@ note: ...which requires borrow-checking `main::<impl at $DIR/fn-header-semantic-\n    |\n LL |         const async unsafe extern \"C\" fn fi5() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires processing `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 40:11>::fi5`...\n+note: ...which requires processing MIR for `main::<impl at $DIR/fn-header-semantic-fail.rs:40:5: 40:11>::fi5`...\n   --> $DIR/fn-header-semantic-fail.rs:45:9\n    |\n LL |         const async unsafe extern \"C\" fn fi5() {}"}, {"sha": "82a4211f08ac35fe6a5387a4e47552f0d2bf82a7", "filename": "src/test/ui/resolve/privacy-enum-ctor.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -327,7 +327,7 @@ LL |         let _: Z = Z::Fn;\n    |\n    = note: expected enum `Z`\n            found fn item `fn(u8) -> Z {Z::Fn}`\n-help: use parentheses to instantiate this tuple variant\n+help: use parentheses to construct this tuple variant\n    |\n LL |         let _: Z = Z::Fn(/* u8 */);\n    |                         ++++++++++\n@@ -362,7 +362,7 @@ LL |     let _: E = m::E::Fn;\n    |\n    = note: expected enum `E`\n            found fn item `fn(u8) -> E {E::Fn}`\n-help: use parentheses to instantiate this tuple variant\n+help: use parentheses to construct this tuple variant\n    |\n LL |     let _: E = m::E::Fn(/* u8 */);\n    |                        ++++++++++\n@@ -397,7 +397,7 @@ LL |     let _: E = E::Fn;\n    |\n    = note: expected enum `E`\n            found fn item `fn(u8) -> E {E::Fn}`\n-help: use parentheses to instantiate this tuple variant\n+help: use parentheses to construct this tuple variant\n    |\n LL |     let _: E = E::Fn(/* u8 */);\n    |                     ++++++++++"}, {"sha": "8ed62f854f09636e6ddae724fce92c10f4c1a02d", "filename": "src/test/ui/suggestions/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fasync-fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -1,9 +1,6 @@\n error[E0277]: `fn() -> impl Future<Output = ()> {foo}` is not a future\n   --> $DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:10:9\n    |\n-LL | async fn foo() {}\n-   |          --- consider calling this function\n-...\n LL |     bar(foo);\n    |     --- ^^^ `fn() -> impl Future<Output = ()> {foo}` is not a future\n    |     |\n@@ -16,16 +13,14 @@ note: required by a bound in `bar`\n    |\n LL | fn bar(f: impl Future<Output=()>) {}\n    |                ^^^^^^^^^^^^^^^^^ required by this bound in `bar`\n-help: use parentheses to call the function\n+help: use parentheses to call this function\n    |\n LL |     bar(foo());\n    |            ++\n \n error[E0277]: `[closure@$DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:11:25: 11:33]` is not a future\n   --> $DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:12:9\n    |\n-LL |     let async_closure = async || ();\n-   |                         -------- consider calling this closure\n LL |     bar(async_closure);\n    |     --- ^^^^^^^^^^^^^ `[closure@$DIR/async-fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:11:25: 11:33]` is not a future\n    |     |\n@@ -38,7 +33,7 @@ note: required by a bound in `bar`\n    |\n LL | fn bar(f: impl Future<Output=()>) {}\n    |                ^^^^^^^^^^^^^^^^^ required by this bound in `bar`\n-help: use parentheses to call the closure\n+help: use parentheses to call this closure\n    |\n LL |     bar(async_closure());\n    |                      ++"}, {"sha": "5f811044eb349a14105043175417716b2314d646", "filename": "src/test/ui/suggestions/call-on-unimplemented-ctor.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-unimplemented-ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-unimplemented-ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-unimplemented-ctor.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -0,0 +1,17 @@\n+fn main() {\n+    insert_resource(Marker);\n+    insert_resource(Time);\n+    //~^ ERROR the trait bound `fn(u32) -> Time {Time}: Resource` is not satisfied\n+    //~| HELP use parentheses to construct this tuple struct\n+}\n+\n+trait Resource {}\n+\n+fn insert_resource<R: Resource>(resource: R) {}\n+\n+struct Marker;\n+impl Resource for Marker {}\n+\n+struct Time(u32);\n+\n+impl Resource for Time {}"}, {"sha": "58612cbfb239e317f910b8df890cf75ac8147d8d", "filename": "src/test/ui/suggestions/call-on-unimplemented-ctor.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-unimplemented-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-unimplemented-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-unimplemented-ctor.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -0,0 +1,21 @@\n+error[E0277]: the trait bound `fn(u32) -> Time {Time}: Resource` is not satisfied\n+  --> $DIR/call-on-unimplemented-ctor.rs:3:21\n+   |\n+LL |     insert_resource(Time);\n+   |     --------------- ^^^^ the trait `Resource` is not implemented for fn item `fn(u32) -> Time {Time}`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `insert_resource`\n+  --> $DIR/call-on-unimplemented-ctor.rs:10:23\n+   |\n+LL | fn insert_resource<R: Resource>(resource: R) {}\n+   |                       ^^^^^^^^ required by this bound in `insert_resource`\n+help: use parentheses to construct this tuple struct\n+   |\n+LL |     insert_resource(Time(/* u32 */));\n+   |                         +++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "86490c724e0183627edac8e71b62e8a17ccd2eb0", "filename": "src/test/ui/suggestions/call-on-unimplemented-fn-ptr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-unimplemented-fn-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-unimplemented-fn-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-unimplemented-fn-ptr.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -0,0 +1,15 @@\n+struct Foo;\n+\n+trait Bar {}\n+\n+impl Bar for Foo {}\n+\n+fn needs_bar<T: Bar>(_: T) {}\n+\n+fn blah(f: fn() -> Foo) {\n+    needs_bar(f);\n+    //~^ ERROR the trait bound `fn() -> Foo: Bar` is not satisfied\n+    //~| HELP use parentheses to call this function pointer\n+}\n+\n+fn main() {}"}, {"sha": "167f7e592a97c362db75e54517122458728f5633", "filename": "src/test/ui/suggestions/call-on-unimplemented-fn-ptr.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-unimplemented-fn-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-unimplemented-fn-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-unimplemented-fn-ptr.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -0,0 +1,21 @@\n+error[E0277]: the trait bound `fn() -> Foo: Bar` is not satisfied\n+  --> $DIR/call-on-unimplemented-fn-ptr.rs:10:15\n+   |\n+LL |     needs_bar(f);\n+   |     --------- ^ the trait `Bar` is not implemented for `fn() -> Foo`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `needs_bar`\n+  --> $DIR/call-on-unimplemented-fn-ptr.rs:7:17\n+   |\n+LL | fn needs_bar<T: Bar>(_: T) {}\n+   |                 ^^^ required by this bound in `needs_bar`\n+help: use parentheses to call this function pointer\n+   |\n+LL |     needs_bar(f());\n+   |                ++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "955148315baefe01231f163e4b6e8232c4583954", "filename": "src/test/ui/suggestions/fn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-ctor-passed-as-arg-where-it-should-have-been-called.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -1,9 +1,6 @@\n error[E0277]: the trait bound `fn() -> impl T<O = ()> {foo}: T` is not satisfied\n   --> $DIR/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:17:9\n    |\n-LL | fn foo() -> impl T<O=()> { S }\n-   |    --- consider calling this function\n-...\n LL |     bar(foo);\n    |     --- ^^^ the trait `T` is not implemented for fn item `fn() -> impl T<O = ()> {foo}`\n    |     |\n@@ -14,16 +11,14 @@ note: required by a bound in `bar`\n    |\n LL | fn bar(f: impl T<O=()>) {}\n    |                ^^^^^^^ required by this bound in `bar`\n-help: use parentheses to call the function\n+help: use parentheses to call this function\n    |\n LL |     bar(foo());\n    |            ++\n \n error[E0277]: the trait bound `[closure@$DIR/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:18:19: 18:21]: T` is not satisfied\n   --> $DIR/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:19:9\n    |\n-LL |     let closure = || S;\n-   |                   -- consider calling this closure\n LL |     bar(closure);\n    |     --- ^^^^^^^ the trait `T` is not implemented for closure `[closure@$DIR/fn-ctor-passed-as-arg-where-it-should-have-been-called.rs:18:19: 18:21]`\n    |     |\n@@ -34,7 +29,7 @@ note: required by a bound in `bar`\n    |\n LL | fn bar(f: impl T<O=()>) {}\n    |                ^^^^^^^ required by this bound in `bar`\n-help: use parentheses to call the closure\n+help: use parentheses to call this closure\n    |\n LL |     bar(closure());\n    |                ++"}, {"sha": "597dc61c3f7e2e501dd977370bc3c421929cf5b0", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-without-args.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -49,7 +49,7 @@ LL |     let _: S = S;\n    |\n    = note: expected struct `S`\n              found fn item `fn(usize, usize) -> S {S}`\n-help: use parentheses to instantiate this tuple struct\n+help: use parentheses to construct this tuple struct\n    |\n LL |     let _: S = S(/* usize */, /* usize */);\n    |                 ++++++++++++++++++++++++++\n@@ -85,7 +85,7 @@ LL |     let _: V = V;\n    |\n    = note: expected struct `V`\n              found fn item `fn() -> V {V}`\n-help: use parentheses to instantiate this tuple struct\n+help: use parentheses to construct this tuple struct\n    |\n LL |     let _: V = V();\n    |                 ++\n@@ -139,7 +139,7 @@ LL |     let _: E = E::A;\n    |\n    = note: expected enum `E`\n            found fn item `fn(usize) -> E {E::A}`\n-help: use parentheses to instantiate this tuple variant\n+help: use parentheses to construct this tuple variant\n    |\n LL |     let _: E = E::A(/* usize */);\n    |                    +++++++++++++"}, {"sha": "832afddf89147d68058a7b73853551d9042d0df6", "filename": "src/test/ui/treat-err-as-bug/delay_span_bug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.rs?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -1,7 +1,7 @@\n // compile-flags: -Ztreat-err-as-bug\n // failure-status: 101\n // error-pattern: aborting due to `-Z treat-err-as-bug=1`\n-// error-pattern: [trigger_delay_span_bug] trigger a delay span bug\n+// error-pattern: [trigger_delay_span_bug] triggering a delay span bug\n // normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n // normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n // rustc-env:RUST_BACKTRACE=0"}, {"sha": "e9457c8faff4d349bad987563af0f9862c163cbc", "filename": "src/test/ui/treat-err-as-bug/delay_span_bug.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftreat-err-as-bug%2Fdelay_span_bug.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -7,5 +7,5 @@ LL | fn main() {}\n error: internal compiler error: unexpected panic\n \n query stack during panic:\n-#0 [trigger_delay_span_bug] trigger a delay span bug\n+#0 [trigger_delay_span_bug] triggering a delay span bug\n end of query stack"}, {"sha": "23e7b7cc363fec81063cda1ae800da5b0c3c159e", "filename": "src/test/ui/typeck/issue-87181/empty-tuple-method.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -4,7 +4,7 @@ error[E0599]: no method named `foo` found for fn item `fn() -> Foo {Foo}` in the\n LL |     thing.bar.foo();\n    |               ^^^ method not found in `fn() -> Foo {Foo}`\n    |\n-help: use parentheses to instantiate this tuple struct\n+help: use parentheses to construct this tuple struct\n    |\n LL |     (thing.bar)().foo();\n    |     +         +++"}, {"sha": "2247ea27021f45e1559f54adfcc2121157d49365", "filename": "src/test/ui/typeck/issue-87181/enum-variant.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -4,7 +4,7 @@ error[E0599]: no method named `foo` found for fn item `fn() -> Foo {Foo::Tup}` i\n LL |     thing.bar.foo();\n    |               ^^^ method not found in `fn() -> Foo {Foo::Tup}`\n    |\n-help: use parentheses to instantiate this tuple variant\n+help: use parentheses to construct this tuple variant\n    |\n LL |     (thing.bar)().foo();\n    |     +         +++"}, {"sha": "0a7d30b615a635990599586121124f374557db29", "filename": "src/test/ui/typeck/issue-87181/tuple-field.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d7dd01fe8b071602510eaac9f676acc0e3cf8e4a/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.stderr?ref=d7dd01fe8b071602510eaac9f676acc0e3cf8e4a", "patch": "@@ -4,7 +4,7 @@ error[E0609]: no field `0` on type `fn(char, u16) -> Foo {Foo}`\n LL |     thing.bar.0;\n    |               ^\n    |\n-help: use parentheses to instantiate this tuple struct\n+help: use parentheses to construct this tuple struct\n    |\n LL |     (thing.bar)(/* char */, /* u16 */).0;\n    |     +         ++++++++++++++++++++++++"}]}