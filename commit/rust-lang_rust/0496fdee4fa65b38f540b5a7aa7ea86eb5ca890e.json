{"sha": "0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0OTZmZGVlNGZhNjViMzhmNTQwYjVhN2FhN2VhODZlYjVjYTg5MGU=", "commit": {"author": {"name": "William Bain", "email": "bain.william.a@gmail.com", "date": "2020-12-29T05:10:13Z"}, "committer": {"name": "William Bain", "email": "bain.william.a@gmail.com", "date": "2021-01-11T00:47:57Z"}, "message": "Note inference failures using `?` conversion", "tree": {"sha": "e2901044d22af6f689d998a9d362429bb0e9d7b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2901044d22af6f689d998a9d362429bb0e9d7b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "html_url": "https://github.com/rust-lang/rust/commit/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/comments", "author": {"login": "wabain", "id": 7651435, "node_id": "MDQ6VXNlcjc2NTE0MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7651435?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wabain", "html_url": "https://github.com/wabain", "followers_url": "https://api.github.com/users/wabain/followers", "following_url": "https://api.github.com/users/wabain/following{/other_user}", "gists_url": "https://api.github.com/users/wabain/gists{/gist_id}", "starred_url": "https://api.github.com/users/wabain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wabain/subscriptions", "organizations_url": "https://api.github.com/users/wabain/orgs", "repos_url": "https://api.github.com/users/wabain/repos", "events_url": "https://api.github.com/users/wabain/events{/privacy}", "received_events_url": "https://api.github.com/users/wabain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wabain", "id": 7651435, "node_id": "MDQ6VXNlcjc2NTE0MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7651435?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wabain", "html_url": "https://github.com/wabain", "followers_url": "https://api.github.com/users/wabain/followers", "following_url": "https://api.github.com/users/wabain/following{/other_user}", "gists_url": "https://api.github.com/users/wabain/gists{/gist_id}", "starred_url": "https://api.github.com/users/wabain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wabain/subscriptions", "organizations_url": "https://api.github.com/users/wabain/orgs", "repos_url": "https://api.github.com/users/wabain/repos", "events_url": "https://api.github.com/users/wabain/events{/privacy}", "received_events_url": "https://api.github.com/users/wabain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c97f11af7bc4a6d3578f6a953be04ab2449a5728", "url": "https://api.github.com/repos/rust-lang/rust/commits/c97f11af7bc4a6d3578f6a953be04ab2449a5728", "html_url": "https://github.com/rust-lang/rust/commit/c97f11af7bc4a6d3578f6a953be04ab2449a5728"}], "stats": {"total": 283, "additions": 239, "deletions": 44}, "files": [{"sha": "7b0a91986b3a3382f462aa252beb35cefc7216e6", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "patch": "@@ -69,7 +69,7 @@ use rustc_middle::ty::{\n     subst::{Subst, SubstsRef},\n     Region, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_span::{BytePos, DesugaringKind, Pos, Span};\n+use rustc_span::{sym, BytePos, DesugaringKind, Pos, Span};\n use rustc_target::spec::abi;\n use std::ops::ControlFlow;\n use std::{cmp, fmt};\n@@ -2282,6 +2282,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.note_region_origin(&mut err, &sub_origin);\n         err.emit();\n     }\n+\n+    /// Determine whether an error associated with the given span and definition\n+    /// should be treated as being caused by the implicit `From` conversion\n+    /// within `?` desugaring.\n+    pub fn is_try_conversion(&self, span: Span, trait_def_id: DefId) -> bool {\n+        span.is_desugaring(DesugaringKind::QuestionMark)\n+            && self.tcx.is_diagnostic_item(sym::from_trait, trait_def_id)\n+    }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {"}, {"sha": "0e236853ae83614e4e7d32f997b455a323bb98f5", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 159, "deletions": 29, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "patch": "@@ -3,6 +3,7 @@ use crate::infer::InferCtxt;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace};\n+use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Body, Expr, ExprKind, FnRetTy, HirId, Local, Pat};\n use rustc_middle::hir::map::Map;\n@@ -25,6 +26,7 @@ struct FindHirNodeVisitor<'a, 'tcx> {\n     found_closure: Option<&'tcx Expr<'tcx>>,\n     found_method_call: Option<&'tcx Expr<'tcx>>,\n     found_exact_method_call: Option<&'tcx Expr<'tcx>>,\n+    found_use_diagnostic: Option<UseDiagnostic<'tcx>>,\n }\n \n impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n@@ -39,34 +41,43 @@ impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n             found_closure: None,\n             found_method_call: None,\n             found_exact_method_call: None,\n+            found_use_diagnostic: None,\n         }\n     }\n \n-    fn node_ty_contains_target(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n-        self.infcx\n-            .in_progress_typeck_results\n-            .and_then(|typeck_results| typeck_results.borrow().node_type_opt(hir_id))\n-            .map(|ty| self.infcx.resolve_vars_if_possible(ty))\n-            .filter(|ty| {\n-                ty.walk().any(|inner| {\n-                    inner == self.target\n-                        || match (inner.unpack(), self.target.unpack()) {\n-                            (GenericArgKind::Type(inner_ty), GenericArgKind::Type(target_ty)) => {\n-                                use ty::{Infer, TyVar};\n-                                match (inner_ty.kind(), target_ty.kind()) {\n-                                    (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => self\n-                                        .infcx\n-                                        .inner\n-                                        .borrow_mut()\n-                                        .type_variables()\n-                                        .sub_unified(a_vid, b_vid),\n-                                    _ => false,\n-                                }\n+    fn node_type_opt(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n+        self.infcx.in_progress_typeck_results?.borrow().node_type_opt(hir_id)\n+    }\n+\n+    fn node_ty_contains_target(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n+        self.node_type_opt(hir_id).map(|ty| self.infcx.resolve_vars_if_possible(ty)).filter(|ty| {\n+            ty.walk().any(|inner| {\n+                inner == self.target\n+                    || match (inner.unpack(), self.target.unpack()) {\n+                        (GenericArgKind::Type(inner_ty), GenericArgKind::Type(target_ty)) => {\n+                            use ty::{Infer, TyVar};\n+                            match (inner_ty.kind(), target_ty.kind()) {\n+                                (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => self\n+                                    .infcx\n+                                    .inner\n+                                    .borrow_mut()\n+                                    .type_variables()\n+                                    .sub_unified(a_vid, b_vid),\n+                                _ => false,\n                             }\n-                            _ => false,\n                         }\n-                })\n+                        _ => false,\n+                    }\n             })\n+        })\n+    }\n+\n+    /// Determine whether the expression, assumed to be the callee within a `Call`,\n+    /// corresponds to the `From::from` emitted in desugaring of the `?` operator.\n+    fn is_try_conversion(&self, callee: &Expr<'tcx>) -> bool {\n+        self.infcx\n+            .trait_def_from_hir_fn(callee.hir_id)\n+            .map_or(false, |def_id| self.infcx.is_try_conversion(callee.span, def_id))\n     }\n }\n \n@@ -119,17 +130,91 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n         // are handled specially, but instead they should be handled in `annotate_method_call`,\n         // which currently doesn't work because this evaluates to `false` for const arguments.\n         // See https://github.com/rust-lang/rust/pull/77758 for more details.\n-        if self.node_ty_contains_target(expr.hir_id).is_some() {\n+        if let Some(ty) = self.node_ty_contains_target(expr.hir_id) {\n             match expr.kind {\n                 ExprKind::Closure(..) => self.found_closure = Some(&expr),\n                 ExprKind::MethodCall(..) => self.found_method_call = Some(&expr),\n+\n+                // If the given expression falls within the target span and is a\n+                // `From::from(e)` call emitted during desugaring of the `?` operator,\n+                // extract the types inferred before and after the call\n+                ExprKind::Call(callee, [arg])\n+                    if self.target_span.contains(expr.span)\n+                        && self.found_use_diagnostic.is_none()\n+                        && self.is_try_conversion(callee) =>\n+                {\n+                    self.found_use_diagnostic = self.node_type_opt(arg.hir_id).map(|pre_ty| {\n+                        UseDiagnostic::TryConversion { pre_ty, post_ty: ty, span: callee.span }\n+                    });\n+                }\n                 _ => {}\n             }\n         }\n         intravisit::walk_expr(self, expr);\n     }\n }\n \n+/// An observation about the use site of a type to be emitted as an additional\n+/// note in an inference failure error.\n+enum UseDiagnostic<'tcx> {\n+    /// Records the types inferred before and after `From::from` is called on the\n+    /// error value within the desugaring of the `?` operator.\n+    TryConversion { pre_ty: Ty<'tcx>, post_ty: Ty<'tcx>, span: Span },\n+}\n+\n+impl UseDiagnostic<'_> {\n+    /// Return a descriptor of the value at the use site\n+    fn descr(&self) -> &'static str {\n+        match self {\n+            Self::TryConversion { .. } => \"`?` error\",\n+        }\n+    }\n+\n+    /// Return a descriptor of the type at the use site\n+    fn type_descr(&self) -> &'static str {\n+        match self {\n+            Self::TryConversion { .. } => \"`?` error type\",\n+        }\n+    }\n+\n+    fn applies_to(&self, span: Span) -> bool {\n+        match *self {\n+            // In some cases the span for an inference failure due to try\n+            // conversion contains the antecedent expression as well as the `?`\n+            Self::TryConversion { span: s, .. } => span.contains(s) && span.hi() == s.hi(),\n+        }\n+    }\n+\n+    fn attach_note(&self, err: &mut DiagnosticBuilder<'_>) {\n+        match *self {\n+            Self::TryConversion { pre_ty, post_ty, .. } => {\n+                let pre_ty = pre_ty.to_string();\n+                let post_ty = post_ty.to_string();\n+\n+                let intro = \"the `?` operation implicitly converts the error value\";\n+\n+                let msg = match (pre_ty.as_str(), post_ty.as_str()) {\n+                    (\"_\", \"_\") => format!(\"{} using the `From` trait\", intro),\n+                    (_, \"_\") => {\n+                        format!(\"{} into a type implementing `From<{}>`\", intro, pre_ty)\n+                    }\n+                    (\"_\", _) => {\n+                        format!(\"{} into `{}` using the `From` trait\", intro, post_ty)\n+                    }\n+                    (_, _) => {\n+                        format!(\n+                            \"{} into `{}` using its implementation of `From<{}>`\",\n+                            intro, post_ty, pre_ty\n+                        )\n+                    }\n+                };\n+\n+                err.note(&msg);\n+            }\n+        }\n+    }\n+}\n+\n /// Suggest giving an appropriate return type to a closure expression.\n fn closure_return_type_suggestion(\n     span: Span,\n@@ -139,6 +224,7 @@ fn closure_return_type_suggestion(\n     descr: &str,\n     name: &str,\n     ret: &str,\n+    use_diag: Option<&UseDiagnostic<'_>>,\n     parent_name: Option<String>,\n     parent_descr: Option<&str>,\n ) {\n@@ -160,7 +246,15 @@ fn closure_return_type_suggestion(\n     );\n     err.span_label(\n         span,\n-        InferCtxt::cannot_infer_msg(\"type\", &name, &descr, parent_name, parent_descr),\n+        InferCtxt::cannot_infer_msg(\n+            span,\n+            \"type\",\n+            &name,\n+            &descr,\n+            use_diag,\n+            parent_name,\n+            parent_descr,\n+        ),\n     );\n }\n \n@@ -420,7 +514,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         // When `arg_data.name` corresponds to a type argument, show the path of the full type we're\n         // trying to infer. In the following example, `ty_msg` contains\n-        // \" in `std::result::Result<i32, E>`\":\n+        // \" for `std::result::Result<i32, E>`\":\n         // ```\n         // error[E0282]: type annotations needed for `std::result::Result<i32, E>`\n         //  --> file.rs:L:CC\n@@ -438,6 +532,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             error_code,\n         );\n \n+        let use_diag = local_visitor.found_use_diagnostic.as_ref();\n+        if let Some(use_diag) = use_diag {\n+            if use_diag.applies_to(err_span) {\n+                use_diag.attach_note(&mut err);\n+            }\n+        }\n+\n         let suffix = match local_visitor.found_node_ty {\n             Some(ty) if ty.is_closure() => {\n                 let substs =\n@@ -460,6 +561,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         &arg_data.description,\n                         &arg_data.name,\n                         &ret,\n+                        use_diag,\n                         arg_data.parent_name,\n                         arg_data.parent_description,\n                     );\n@@ -634,9 +736,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             err.span_label(\n                 span,\n                 InferCtxt::cannot_infer_msg(\n+                    span,\n                     kind_str,\n                     &arg_data.name,\n                     &arg_data.description,\n+                    use_diag,\n                     arg_data.parent_name,\n                     arg_data.parent_description,\n                 ),\n@@ -646,6 +750,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err\n     }\n \n+    fn trait_def_from_hir_fn(&self, hir_id: hir::HirId) -> Option<DefId> {\n+        // The DefId will be the method's trait item ID unless this is an inherent impl\n+        if let Some((DefKind::AssocFn, def_id)) =\n+            self.in_progress_typeck_results?.borrow().type_dependent_def(hir_id)\n+        {\n+            return self\n+                .tcx\n+                .parent(def_id)\n+                .filter(|&parent_def_id| self.tcx.is_trait(parent_def_id));\n+        }\n+\n+        None\n+    }\n+\n     /// If the `FnSig` for the method call can be found and type arguments are identified as\n     /// needed, suggest annotating the call, otherwise point out the resulting type of the call.\n     fn annotate_method_call(\n@@ -711,9 +829,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err.span_label(\n             span,\n             InferCtxt::cannot_infer_msg(\n+                span,\n                 \"type\",\n                 &data.name,\n                 &data.description,\n+                None,\n                 data.parent_name,\n                 data.parent_description,\n             ),\n@@ -722,25 +842,35 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     fn cannot_infer_msg(\n+        span: Span,\n         kind_str: &str,\n         type_name: &str,\n         descr: &str,\n+        use_diag: Option<&UseDiagnostic<'_>>,\n         parent_name: Option<String>,\n         parent_descr: Option<&str>,\n     ) -> String {\n+        let use_diag = use_diag.filter(|d| d.applies_to(span));\n+\n         if type_name == \"_\" {\n-            format!(\"cannot infer {}\", kind_str)\n+            if let Some(use_diag) = use_diag {\n+                format!(\"cannot infer {} of {}\", kind_str, use_diag.descr())\n+            } else {\n+                format!(\"cannot infer {}\", kind_str)\n+            }\n         } else {\n-            let parent_desc = if let Some(parent_name) = parent_name {\n+            let extra_descr = if let Some(parent_name) = parent_name {\n                 let parent_type_descr = if let Some(parent_descr) = parent_descr {\n                     format!(\" the {}\", parent_descr)\n                 } else {\n                     \"\".into()\n                 };\n \n                 format!(\" declared on{} `{}`\", parent_type_descr, parent_name)\n+            } else if let Some(use_diag) = use_diag {\n+                format!(\" in {}\", use_diag.type_descr())\n             } else {\n-                \"\".to_string()\n+                \"\".into()\n             };\n \n             // FIXME: We really shouldn't be dealing with strings here\n@@ -749,7 +879,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // For example: \"cannot infer type for type parameter `T`\"\n             format!(\n                 \"cannot infer {} {} {} `{}`{}\",\n-                kind_str, preposition, descr, type_name, parent_desc\n+                kind_str, preposition, descr, type_name, extra_descr\n             )\n         }\n     }"}, {"sha": "0186d164a4c53f12af08a16d31d83ab1cc66f56b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "patch": "@@ -280,18 +280,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         let OnUnimplementedNote { message, label, note, enclosing_scope } =\n                             self.on_unimplemented_note(trait_ref, obligation);\n                         let have_alt_message = message.is_some() || label.is_some();\n-                        let is_try = self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .span_to_snippet(span)\n-                            .map(|s| &s == \"?\")\n-                            .unwrap_or(false);\n-                        let is_from = self.tcx.get_diagnostic_item(sym::from_trait)\n-                            == Some(trait_ref.def_id());\n+                        let is_try_conversion = self.is_try_conversion(span, trait_ref.def_id());\n                         let is_unsize =\n                             { Some(trait_ref.def_id()) == self.tcx.lang_items().unsize_trait() };\n-                        let (message, note) = if is_try && is_from {\n+                        let (message, note) = if is_try_conversion {\n                             (\n                                 Some(format!(\n                                     \"`?` couldn't convert the error to `{}`\",\n@@ -319,7 +311,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             ))\n                         );\n \n-                        if is_try && is_from {\n+                        if is_try_conversion {\n                             let none_error = self\n                                 .tcx\n                                 .get_diagnostic_item(sym::none_error)"}, {"sha": "de15d472d056d26867cee44ae3e8d2d9111f4b73", "filename": "src/test/ui/inference/cannot-infer-async-enabled-impl-trait-bindings.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr?ref=0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "patch": "@@ -13,7 +13,9 @@ error[E0282]: type annotations needed for `impl Future`\n LL |     let fut = async {\n    |         --- consider giving `fut` the explicit type `impl Future`, with the type parameters specified\n LL |         make_unit()?;\n-   |                    ^ cannot infer type\n+   |                    ^ cannot infer type of `?` error\n+   |\n+   = note: the `?` operation implicitly converts the error value into a type implementing `From<std::io::Error>`\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "d5cccc7a9482a63fff7106219c0b12cb13a46426", "filename": "src/test/ui/inference/cannot-infer-async.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr?ref=0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "patch": "@@ -4,7 +4,9 @@ error[E0282]: type annotations needed\n LL |     let fut = async {\n    |         --- consider giving `fut` a type\n LL |         make_unit()?;\n-   |                    ^ cannot infer type\n+   |                    ^ cannot infer type of `?` error\n+   |\n+   = note: the `?` operation implicitly converts the error value into a type implementing `From<std::io::Error>`\n \n error: aborting due to previous error\n "}, {"sha": "a3b957179b1b1540235013a13e119027f3f6332c", "filename": "src/test/ui/inference/cannot-infer-closure-circular.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.rs?ref=0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "patch": "@@ -0,0 +1,14 @@\n+fn main() {\n+    // Below we call the closure with its own return as the argument, unifying\n+    // its inferred input and return types. We want to make sure that the generated\n+    // error handles this gracefully, and in particular doesn't generate an extra\n+    // note about the `?` operator in the closure body, which isn't relevant to\n+    // the inference.\n+    let x = |r| {\n+        //~^ ERROR type annotations needed\n+        let v = r?;\n+        Ok(v)\n+    };\n+\n+    let _ = x(x(Ok(())));\n+}"}, {"sha": "5efb400a4c7a51cb341df2846aca4a2a8dd33a82", "filename": "src/test/ui/inference/cannot-infer-closure-circular.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure-circular.stderr?ref=0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed for `std::result::Result<(), E>`\n+  --> $DIR/cannot-infer-closure-circular.rs:7:14\n+   |\n+LL |     let x = |r| {\n+   |              ^ consider giving this closure parameter the explicit type `std::result::Result<(), E>`, with the type parameters specified\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "c083f2b686eff625e017b1b3a3da475448865bcd", "filename": "src/test/ui/inference/cannot-infer-closure.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr?ref=0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "patch": "@@ -2,8 +2,9 @@ error[E0282]: type annotations needed for the closure `fn((), ()) -> std::result\n   --> $DIR/cannot-infer-closure.rs:3:15\n    |\n LL |         Err(a)?;\n-   |               ^ cannot infer type\n+   |               ^ cannot infer type of `?` error\n    |\n+   = note: the `?` operation implicitly converts the error value into a type implementing `From<()>`\n help: give this closure an explicit return type without `_` placeholders\n    |\n LL |     let x = |a: (), b: ()| -> std::result::Result<(), _> {"}, {"sha": "e1058e96cef4b1a8bf6de7ef471be2fbed8a58ab", "filename": "src/test/ui/inference/cannot-infer-partial-try-return.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.rs?ref=0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "patch": "@@ -0,0 +1,22 @@\n+struct QualifiedError<E>(E);\n+\n+impl<E, T> From<E> for QualifiedError<T>\n+where\n+    E: std::error::Error,\n+    T: From<E>,\n+{\n+    fn from(e: E) -> QualifiedError<T> {\n+        QualifiedError(e.into())\n+    }\n+}\n+\n+fn infallible() -> Result<(), std::convert::Infallible> {\n+    Ok(())\n+}\n+\n+fn main() {\n+    let x = || -> Result<_, QualifiedError<_>> {\n+        infallible()?; //~ERROR type annotations needed\n+        Ok(())\n+    };\n+}"}, {"sha": "d4223bfc155c2e63445b80d8c1714c521943da5f", "filename": "src/test/ui/inference/cannot-infer-partial-try-return.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-partial-try-return.stderr?ref=0496fdee4fa65b38f540b5a7aa7ea86eb5ca890e", "patch": "@@ -0,0 +1,15 @@\n+error[E0282]: type annotations needed for the closure `fn() -> std::result::Result<(), QualifiedError<_>>`\n+  --> $DIR/cannot-infer-partial-try-return.rs:19:9\n+   |\n+LL |         infallible()?;\n+   |         ^^^^^^^^^^^^^ cannot infer type of `?` error\n+   |\n+   = note: the `?` operation implicitly converts the error value into `QualifiedError<_>` using its implementation of `From<Infallible>`\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let x = || -> std::result::Result<(), QualifiedError<_>> {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}]}