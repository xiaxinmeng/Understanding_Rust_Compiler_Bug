{"sha": "cc74068642d288534df0d6c2a454663920c5e97d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNzQwNjg2NDJkMjg4NTM0ZGYwZDZjMmE0NTQ2NjM5MjBjNWU5N2Q=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-19T05:55:28Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-21T09:00:56Z"}, "message": "Remove `Rc` from the interner.", "tree": {"sha": "f4e7aceb006421c4733f8ed8c40a5e734b4af0f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4e7aceb006421c4733f8ed8c40a5e734b4af0f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc74068642d288534df0d6c2a454663920c5e97d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc74068642d288534df0d6c2a454663920c5e97d", "html_url": "https://github.com/rust-lang/rust/commit/cc74068642d288534df0d6c2a454663920c5e97d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc74068642d288534df0d6c2a454663920c5e97d/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36c8f6b0d3f38904459f40496af36d36e9cc0fac", "url": "https://api.github.com/repos/rust-lang/rust/commits/36c8f6b0d3f38904459f40496af36d36e9cc0fac", "html_url": "https://github.com/rust-lang/rust/commit/36c8f6b0d3f38904459f40496af36d36e9cc0fac"}], "stats": {"total": 87, "additions": 36, "deletions": 51}, "files": [{"sha": "3a9729d5d45c10dba7fbe3c13c9a06e9b30dbd3b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc74068642d288534df0d6c2a454663920c5e97d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc74068642d288534df0d6c2a454663920c5e97d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=cc74068642d288534df0d6c2a454663920c5e97d", "patch": "@@ -1355,11 +1355,3 @@ pub fn build_output_filenames(input: &Input,\n         }\n     }\n }\n-\n-// For use by the `rusti` project (https://github.com/murarth/rusti).\n-pub fn reset_thread_local_state() {\n-    // These may be left in an incoherent state after a previous compile.\n-    syntax::ext::hygiene::reset_hygiene_data();\n-    // `clear_interner` can be used to free memory, but it does not restore the initial state.\n-    symbol::reset_interner();\n-}"}, {"sha": "5d01ca892b316c4c9849cacafb0c79f84e0937f1", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cc74068642d288534df0d6c2a454663920c5e97d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc74068642d288534df0d6c2a454663920c5e97d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=cc74068642d288534df0d6c2a454663920c5e97d", "patch": "@@ -44,7 +44,6 @@ use std::ffi::CString;\n use std::fmt::Write;\n use std::path::Path;\n use std::ptr;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::symbol::{Interner, InternedString};\n use syntax_pos::{self, Span};\n@@ -116,9 +115,8 @@ impl<'tcx> TypeMap<'tcx> {\n                                         unique_type_id: UniqueTypeId,\n                                         metadata: DIType) {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n-            let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n             bug!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                 &unique_type_id_str[..]);\n+                 self.get_unique_type_id_as_string(unique_type_id));\n         }\n     }\n \n@@ -132,7 +130,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n     // Get the string representation of a UniqueTypeId. This method will fail if\n     // the id is unknown.\n-    fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> Rc<str> {\n+    fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> &str {\n         let UniqueTypeId(interner_key) = unique_type_id;\n         self.unique_id_interner.get(interner_key)\n     }\n@@ -181,7 +179,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                               -> UniqueTypeId {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n         let enum_variant_type_id = format!(\"{}::{}\",\n-                                           &self.get_unique_type_id_as_string(enum_type_id),\n+                                           self.get_unique_type_id_as_string(enum_type_id),\n                                            variant_name);\n         let interner_key = self.unique_id_interner.intern(&enum_variant_type_id);\n         UniqueTypeId(interner_key)\n@@ -622,29 +620,25 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n                 Some(metadata) => metadata,\n                 None => {\n-                    let unique_type_id_str =\n-                        type_map.get_unique_type_id_as_string(unique_type_id);\n                     span_bug!(usage_site_span,\n                               \"Expected type metadata for unique \\\n                                type id '{}' to already be in \\\n                                the debuginfo::TypeMap but it \\\n                                was not. (Ty = {})\",\n-                              &unique_type_id_str[..],\n+                              type_map.get_unique_type_id_as_string(unique_type_id),\n                               t);\n                 }\n             };\n \n             match type_map.find_metadata_for_type(t) {\n                 Some(metadata) => {\n                     if metadata != metadata_for_uid {\n-                        let unique_type_id_str =\n-                            type_map.get_unique_type_id_as_string(unique_type_id);\n                         span_bug!(usage_site_span,\n                                   \"Mismatch between Ty and \\\n                                    UniqueTypeId maps in \\\n                                    debuginfo::TypeMap. \\\n                                    UniqueTypeId={}, Ty={}\",\n-                                  &unique_type_id_str[..],\n+                                  type_map.get_unique_type_id_as_string(unique_type_id),\n                                   t);\n                     }\n                 }\n@@ -1525,13 +1519,10 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let enum_llvm_type = type_of::type_of(cx, enum_type);\n     let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n \n-    let unique_type_id_str = debug_context(cx)\n-                             .type_map\n-                             .borrow()\n-                             .get_unique_type_id_as_string(unique_type_id);\n-\n     let enum_name = CString::new(enum_name).unwrap();\n-    let unique_type_id_str = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let unique_type_id_str = CString::new(\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id).as_bytes()\n+    ).unwrap();\n     let enum_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateUnionType(\n         DIB(cx),\n@@ -1668,11 +1659,10 @@ fn create_struct_stub(cx: &CrateContext,\n                    -> DICompositeType {\n     let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n \n-    let unique_type_id_str = debug_context(cx).type_map\n-                                              .borrow()\n-                                              .get_unique_type_id_as_string(unique_type_id);\n     let name = CString::new(struct_type_name).unwrap();\n-    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let unique_type_id = CString::new(\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id).as_bytes()\n+    ).unwrap();\n     let metadata_stub = unsafe {\n         // LLVMRustDIBuilderCreateStructType() wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n@@ -1706,11 +1696,10 @@ fn create_union_stub(cx: &CrateContext,\n                    -> DICompositeType {\n     let (union_size, union_align) = size_and_align_of(cx, union_llvm_type);\n \n-    let unique_type_id_str = debug_context(cx).type_map\n-                                              .borrow()\n-                                              .get_unique_type_id_as_string(unique_type_id);\n     let name = CString::new(union_type_name).unwrap();\n-    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let unique_type_id = CString::new(\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id).as_bytes()\n+    ).unwrap();\n     let metadata_stub = unsafe {\n         // LLVMRustDIBuilderCreateUnionType() wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions"}, {"sha": "5a1b0d4005e17e12f14303a9dfe0e2b08dcc4dfb", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc74068642d288534df0d6c2a454663920c5e97d/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc74068642d288534df0d6c2a454663920c5e97d/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=cc74068642d288534df0d6c2a454663920c5e97d", "patch": "@@ -27,6 +27,7 @@\n #![feature(associated_consts)]\n #![feature(const_fn)]\n #![feature(libc)]\n+#![feature(optin_builtin_traits)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(str_escape)]"}, {"sha": "fe9a176179ce67aebc42f13398c418b104c7f4cd", "filename": "src/libsyntax/symbol.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cc74068642d288534df0d6c2a454663920c5e97d/src%2Flibsyntax%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc74068642d288534df0d6c2a454663920c5e97d/src%2Flibsyntax%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsymbol.rs?ref=cc74068642d288534df0d6c2a454663920c5e97d", "patch": "@@ -16,12 +16,14 @@ use serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::cell::RefCell;\n use std::collections::HashMap;\n use std::fmt;\n-use std::rc::Rc;\n \n /// A symbol is an interned or gensymed string.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Symbol(u32);\n \n+// The interner in thread-local, so `Symbol` shouldn't move between threads.\n+impl !Send for Symbol { }\n+\n impl Symbol {\n     /// Maps a string to its interned representation.\n     pub fn intern(string: &str) -> Self {\n@@ -34,7 +36,11 @@ impl Symbol {\n     }\n \n     pub fn as_str(self) -> InternedString {\n-        with_interner(|interner| InternedString { string: interner.get(self) })\n+        with_interner(|interner| unsafe {\n+            InternedString {\n+                string: ::std::mem::transmute::<&str, &str>(interner.get(self))\n+            }\n+        })\n     }\n \n     pub fn as_u32(self) -> u32 {\n@@ -74,8 +80,8 @@ impl<'a> PartialEq<&'a str> for Symbol {\n \n #[derive(Default)]\n pub struct Interner {\n-    names: HashMap<Rc<str>, Symbol>,\n-    strings: Vec<Rc<str>>,\n+    names: HashMap<Box<str>, Symbol>,\n+    strings: Vec<Box<str>>,\n }\n \n impl Interner {\n@@ -97,7 +103,7 @@ impl Interner {\n         }\n \n         let name = Symbol(self.strings.len() as u32);\n-        let string = Rc::__from_str(string);\n+        let string = string.to_string().into_boxed_str();\n         self.strings.push(string.clone());\n         self.names.insert(string, name);\n         name\n@@ -106,12 +112,12 @@ impl Interner {\n     fn gensym(&mut self, string: &str) -> Symbol {\n         let gensym = Symbol(self.strings.len() as u32);\n         // leave out of `names` to avoid colliding\n-        self.strings.push(Rc::__from_str(string));\n+        self.strings.push(string.to_string().into_boxed_str());\n         gensym\n     }\n \n-    pub fn get(&self, name: Symbol) -> Rc<str> {\n-        self.strings[name.0 as usize].clone()\n+    pub fn get(&self, name: Symbol) -> &str {\n+        &self.strings[name.0 as usize]\n     }\n }\n \n@@ -225,11 +231,6 @@ fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {\n     INTERNER.with(|interner| f(&mut *interner.borrow_mut()))\n }\n \n-/// Reset the ident interner to its initial state.\n-pub fn reset_interner() {\n-    with_interner(|interner| *interner = Interner::fresh());\n-}\n-\n /// Represents a string stored in the thread-local interner. Because the\n /// interner lives for the life of the thread, this can be safely treated as an\n /// immortal string, as long as it never crosses between threads.\n@@ -241,23 +242,25 @@ pub fn reset_interner() {\n /// somehow.\n #[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n pub struct InternedString {\n-    string: Rc<str>,\n+    string: &'static str,\n }\n \n+impl !Send for InternedString { }\n+\n impl ::std::ops::Deref for InternedString {\n     type Target = str;\n-    fn deref(&self) -> &str { &self.string }\n+    fn deref(&self) -> &str { self.string }\n }\n \n impl fmt::Debug for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.string, f)\n+        fmt::Debug::fmt(self.string, f)\n     }\n }\n \n impl fmt::Display for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.string, f)\n+        fmt::Display::fmt(self.string, f)\n     }\n }\n \n@@ -269,7 +272,7 @@ impl Decodable for InternedString {\n \n impl Encodable for InternedString {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.string)\n+        s.emit_str(self.string)\n     }\n }\n "}]}