{"sha": "6d97d02c52a3d1f49b5c8617c1999bf2542ee98e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkOTdkMDJjNTJhM2QxZjQ5YjVjODYxN2MxOTk5YmYyNTQyZWU5OGU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-10T08:33:05Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-10T08:34:09Z"}, "message": "autogenerate markdown for rustc test suite result", "tree": {"sha": "90c1c26385a4cf2296be3a52d4249799a2d6927c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90c1c26385a4cf2296be3a52d4249799a2d6927c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d97d02c52a3d1f49b5c8617c1999bf2542ee98e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlidewEACgkQpp+NIls6\n19lNOw//YF+xhx7U8gzBUY62A6nJb2t8k2gcCSeZ4xAe/RPXY89aWOYariz9Wr+g\nARnN1mvTa/qmVXaGHjX4DVLH7HH+uu+qnACJLAY5fKsePihRy31MdpYASq1NpRds\nvZjyfbyKaOyl+yLRsG0uup7uxhgsnw8mHxzCS+aZVBZ9SKMQ/0QVcXa9r7LeOnab\nO7Mqi5HnsXaV3t4IwHKAZVfDn789eUg4wtx+J8IKoKKMXLeYg2nP48ZDufPpH65V\nGDFb1+ak0uqr/VIaKKSqItu/ckGGQC7FqOiE1KU+uzH2aEwHPJnRIYG3U/1Vmli+\nWd8dm19MHLhJPgka9Lmo3HqfCFQt/hpK6SngP61xoSm/VjNzu4Wb5esHYV2xCvkt\nGWusPr7v1W9liP1CvE3e47cI4aWqSiUj7qgGQxKyUerQmmcpFPPNh626nUoLJEcF\nL2uA38rMvmS/Hi9Drj9LV+n3LbJ9QmFfBS6ZPyQOJ6ROVpKELCnb6w/8cYuVnus1\nIt0OuMnHcFFKyXlMc6/F0DqBBoiTwYleI0CVaV2cvMr9p6A97hmJxlRmi67PVPcv\np7G8a43JIGVUO8SfPsHbo8Nmz4IDbo4u5mz3+ttWBunEtttq2HuCho3HvorIaVTF\npgRkjdd1+CSnOBWyFpvThlR2AhLNaeGWp3JsGS/txdGm1o0m8/0=\n=hQUI\n-----END PGP SIGNATURE-----", "payload": "tree 90c1c26385a4cf2296be3a52d4249799a2d6927c\nparent 333264c956cc4d2d821b8707abc5657a0f1e1369\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1486715585 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1486715649 +0100\n\nautogenerate markdown for rustc test suite result"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d97d02c52a3d1f49b5c8617c1999bf2542ee98e", "html_url": "https://github.com/rust-lang/rust/commit/6d97d02c52a3d1f49b5c8617c1999bf2542ee98e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d97d02c52a3d1f49b5c8617c1999bf2542ee98e/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "333264c956cc4d2d821b8707abc5657a0f1e1369", "url": "https://api.github.com/repos/rust-lang/rust/commits/333264c956cc4d2d821b8707abc5657a0f1e1369", "html_url": "https://github.com/rust-lang/rust/commit/333264c956cc4d2d821b8707abc5657a0f1e1369"}], "stats": {"total": 100, "additions": 92, "deletions": 8}, "files": [{"sha": "100b79401dfbb1918e73c349e8aa728c2017489d", "filename": "tests/compiletest.rs", "status": "modified", "additions": 92, "deletions": 8, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6d97d02c52a3d1f49b5c8617c1999bf2542ee98e/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d97d02c52a3d1f49b5c8617c1999bf2542ee98e/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=6d97d02c52a3d1f49b5c8617c1999bf2542ee98e", "patch": "@@ -83,10 +83,15 @@ fn compile_test() {\n     let host = host.split(\"\\n\").next().expect(\"no \\n after host\");\n \n     if let Ok(path) = std::env::var(\"MIRI_RUSTC_TEST\") {\n-        let mut mir_not_found = 0;\n-        let mut crate_not_found = 0;\n+        let mut mir_not_found = Vec::new();\n+        let mut crate_not_found = Vec::new();\n         let mut success = 0;\n-        let mut failed = 0;\n+        let mut failed = Vec::new();\n+        let mut c_abi_fns = Vec::new();\n+        let mut abi = Vec::new();\n+        let mut unsupported = Vec::new();\n+        let mut unimplemented_intrinsic = Vec::new();\n+        let mut limits = Vec::new();\n         for file in std::fs::read_dir(path).unwrap() {\n             let file = file.unwrap();\n             let path = file.path();\n@@ -110,15 +115,37 @@ fn compile_test() {\n                 Ok(output) => {\n                     let output_err = std::str::from_utf8(&output.stderr).unwrap();\n                     if let Some(text) = output_err.splitn(2, \"no mir for `\").nth(1) {\n-                        mir_not_found += 1;\n                         let end = text.find('`').unwrap();\n+                        mir_not_found.push(text[..end].to_string());\n                         writeln!(stderr.lock(), \"NO MIR FOR `{}`\", &text[..end]).unwrap();\n                     } else if let Some(text) = output_err.splitn(2, \"can't find crate for `\").nth(1) {\n-                        crate_not_found += 1;\n                         let end = text.find('`').unwrap();\n+                        crate_not_found.push(text[..end].to_string());\n                         writeln!(stderr.lock(), \"CAN'T FIND CRATE FOR `{}`\", &text[..end]).unwrap();\n                     } else {\n-                        failed += 1;\n+                        for text in output_err.split(\"error: \").skip(1) {\n+                            let end = text.find('\\n').unwrap_or(text.len());\n+                            let c_abi = \"can't call C ABI function: \";\n+                            let unimplemented_intrinsic_s = \"unimplemented intrinsic: \";\n+                            let unsupported_s = \"miri does not support \";\n+                            let abi_s = \"can't handle function with \";\n+                            let limit_s = \"reached the configured maximum \";\n+                            if text.starts_with(c_abi) {\n+                                c_abi_fns.push(text[c_abi.len()..end].to_string());\n+                            } else if text.starts_with(unimplemented_intrinsic_s) {\n+                                unimplemented_intrinsic.push(text[unimplemented_intrinsic_s.len()..end].to_string());\n+                            } else if text.starts_with(unsupported_s) {\n+                                unsupported.push(text[unsupported_s.len()..end].to_string());\n+                            } else if text.starts_with(abi_s) {\n+                                abi.push(text[abi_s.len()..end].to_string());\n+                            } else if text.starts_with(limit_s) {\n+                                limits.push(text[limit_s.len()..end].to_string());\n+                            } else {\n+                                if text.find(\"aborting\").is_none() {\n+                                    failed.push(text[..end].to_string());\n+                                }\n+                            }\n+                        }\n                         writeln!(stderr.lock(), \"FAILED with exit code {:?}\", output.status.code()).unwrap();\n                         writeln!(stderr.lock(), \"stdout: \\n {}\", std::str::from_utf8(&output.stdout).unwrap()).unwrap();\n                         writeln!(stderr.lock(), \"stderr: \\n {}\", output_err).unwrap();\n@@ -131,8 +158,34 @@ fn compile_test() {\n             }\n         }\n         let stderr = std::io::stderr();\n-        writeln!(stderr.lock(), \"{} success, {} mir not found, {} crate not found, {} failed\", success, mir_not_found, crate_not_found, failed).unwrap();\n-        assert_eq!(failed, 0, \"some tests failed\");\n+        let mut stderr = stderr.lock();\n+        writeln!(stderr, \"{} success, {} no mir, {} crate not found, {} failed, \\\n+                          {} C fn, {} ABI, {} unsupported, {} intrinsic\",\n+                          success, mir_not_found.len(), crate_not_found.len(), failed.len(),\n+                          c_abi_fns.len(), abi.len(), unsupported.len(), unimplemented_intrinsic.len()).unwrap();\n+        writeln!(stderr, \"# The \\\"other reasons\\\" errors\").unwrap();\n+        writeln!(stderr, \"(sorted, deduplicated)\").unwrap();\n+        print_vec(&mut stderr, failed);\n+\n+        writeln!(stderr, \"# can't call C ABI function\").unwrap();\n+        print_vec(&mut stderr, c_abi_fns);\n+\n+        writeln!(stderr, \"# unsupported ABI\").unwrap();\n+        print_vec(&mut stderr, abi);\n+\n+        writeln!(stderr, \"# unsupported\").unwrap();\n+        print_vec(&mut stderr, unsupported);\n+\n+        writeln!(stderr, \"# unimplemented intrinsics\").unwrap();\n+        print_vec(&mut stderr, unimplemented_intrinsic);\n+\n+        writeln!(stderr, \"# mir not found\").unwrap();\n+        print_vec(&mut stderr, mir_not_found);\n+\n+        writeln!(stderr, \"# crate not found\").unwrap();\n+        print_vec(&mut stderr, crate_not_found);\n+\n+        panic!(\"ran miri on rustc test suite. Test failing for convenience\");\n     } else {\n         run_pass();\n         for_all_targets(&sysroot, |target| {\n@@ -141,3 +194,34 @@ fn compile_test() {\n         compile_fail(&sysroot);\n     }\n }\n+\n+fn print_vec<W: std::io::Write>(stderr: &mut W, v: Vec<String>) {\n+    writeln!(stderr, \"```\").unwrap();\n+    for (n, s) in vec_to_hist(v).into_iter().rev() {\n+        writeln!(stderr, \"{:4} {}\", n, s).unwrap();\n+    }\n+    writeln!(stderr, \"```\").unwrap();\n+}\n+\n+fn vec_to_hist<T: PartialEq + Ord>(mut v: Vec<T>) -> Vec<(usize, T)> {\n+    v.sort();\n+    let mut v = v.into_iter();\n+    let mut result = Vec::new();\n+    let mut current = v.next();\n+    'outer: while let Some(current_val) = current {\n+        let mut n = 1;\n+        while let Some(next) = v.next() {\n+            if next == current_val {\n+                n += 1;\n+            } else {\n+                result.push((n, current_val));\n+                current = Some(next);\n+                continue 'outer;\n+            }\n+        }\n+        result.push((n, current_val));\n+        break;\n+    }\n+    result.sort();\n+    result\n+}"}]}