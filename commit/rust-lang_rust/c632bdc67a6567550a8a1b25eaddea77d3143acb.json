{"sha": "c632bdc67a6567550a8a1b25eaddea77d3143acb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MzJiZGM2N2E2NTY3NTUwYThhMWIyNWVhZGRlYTc3ZDMxNDNhY2I=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-25T02:54:25Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-25T02:54:25Z"}, "message": "Rollup merge of #24736 - steveklabnik:doc_mutability, r=alexcrichton\n\nOkay, last chapter other than ownership stuff. :confetti_ball:", "tree": {"sha": "45236304e47ef4a16731b0a0ed2f63380cffc0ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45236304e47ef4a16731b0a0ed2f63380cffc0ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c632bdc67a6567550a8a1b25eaddea77d3143acb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c632bdc67a6567550a8a1b25eaddea77d3143acb", "html_url": "https://github.com/rust-lang/rust/commit/c632bdc67a6567550a8a1b25eaddea77d3143acb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c632bdc67a6567550a8a1b25eaddea77d3143acb/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8", "html_url": "https://github.com/rust-lang/rust/commit/3c6c16e00f63a822f6bd2b2e00104864cd1c5dc8"}, {"sha": "e715205606340b96708c789bfb9308d5304a197b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e715205606340b96708c789bfb9308d5304a197b", "html_url": "https://github.com/rust-lang/rust/commit/e715205606340b96708c789bfb9308d5304a197b"}], "stats": {"total": 178, "additions": 177, "deletions": 1}, "files": [{"sha": "e7506dfe4fd7dc5c850c59c1c5f07843f800b1e3", "filename": "src/doc/trpl/mutability.md", "status": "modified", "additions": 177, "deletions": 1, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/c632bdc67a6567550a8a1b25eaddea77d3143acb/src%2Fdoc%2Ftrpl%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/c632bdc67a6567550a8a1b25eaddea77d3143acb/src%2Fdoc%2Ftrpl%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmutability.md?ref=c632bdc67a6567550a8a1b25eaddea77d3143acb", "patch": "@@ -1,3 +1,179 @@\n % Mutability\n \n-Coming Soon\n+Mutability, the ability to change something, works a bit differently in Rust\n+than in other languages. The first aspect of mutability is its non-default\n+status:\n+\n+```rust,ignore\n+let x = 5;\n+x = 6; // error!\n+```\n+\n+We can introduce mutability with the `mut` keyword:\n+\n+```rust\n+let mut x = 5;\n+\n+x = 6; // no problem!\n+```\n+\n+This is a mutable [variable binding][vb]. When a binding is mutable, it means\n+you\u2019re allowed to change what the binding points to. So in the above example,\n+it\u2019s not so much that the value at `x` is changing, but that the binding\n+changed from one `i32` to another.\n+\n+[vb]: variable-bindings.html\n+\n+If you want to change what the binding points to, you\u2019ll need a [mutable reference][mr]:\n+\n+```rust\n+let mut x = 5;\n+let y = &mut x;\n+```\n+\n+[mr]: references-and-borrowing.html\n+\n+`y` is an immutable binding to a mutable reference, which means that you can\u2019t\n+bind `y` to something else (`y = &mut z`), but you can mutate the thing that\u2019s\n+bound to `y`. (`*y = 5`) A subtle distinction.\n+\n+Of course, if you need both:\n+\n+```rust\n+let mut x = 5;\n+let mut y = &mut x;\n+```\n+\n+Now `y` can be bound to another value, and the value it\u2019s referencing can be\n+changed.\n+\n+It\u2019s important to note that `mut` is part of a [pattern][pattern], so you\n+can do things like this:\n+\n+```rust\n+let (mut x, y) = (5, 6);\n+\n+fn foo(mut x: i32) {\n+# }\n+```\n+\n+[pattern]: patterns.html\n+\n+# Interior vs. Exterior Mutability\n+\n+However, when we say something is \u2018immutable\u2019 in Rust, that doesn\u2019t mean that\n+it\u2019s not able to be changed: We mean something has \u2018exterior mutability\u2019. Consider,\n+for example, [`Arc<T>`][arc]:\n+\n+```rust\n+use std::sync::Arc;\n+\n+let x = Arc::new(5);\n+let y = x.clone();\n+```\n+\n+[arc]: ../std/sync/struct.Arc.html\n+\n+When we call `clone()`, the `Arc<T>` needs to update the reference count. Yet\n+we\u2019ve not used any `mut`s here, `x` is an immutable binding, and we didn\u2019t take\n+`&mut 5` or anything. So what gives?\n+\n+To this, we have to go back to the core of Rust\u2019s guiding philosophy, memory\n+safety, and the mechanism by which Rust guarantees it, the\n+[ownership][ownership] system, and more specifically, [borrowing][borrowing]:\n+\n+> You may have one or the other of these two kinds of borrows, but not both at\n+> the same time:\n+> \n+> * 0 to N references (`&T`) to a resource.\n+> * exactly one mutable reference (`&mut T`)\n+\n+[ownership]: ownership.html\n+[borrowing]: borrowing.html#The-Rules\n+\n+So, that\u2019s the real definition of \u2018immutability\u2019: is this safe to have two\n+pointers to? In `Arc<T>`\u2019s case, yes: the mutation is entirely contained inside\n+the structure itself. It\u2019s not user facing. For this reason, it hands out `&T`\n+with `clone()`. If it handed out `&mut T`s, though, that would be a problem.\n+\n+Other types, like the ones in the [`std::cell`][stdcell] module, have the\n+opposite: interior mutability. For example:\n+\n+```rust\n+use std::cell::RefCell;\n+\n+let x = RefCell::new(42);\n+\n+let y = x.borrow_mut();\n+```\n+\n+[stdcell]: ../std/cell/index.html\n+\n+RefCell hands out `&mut` references to what\u2019s inside of it with the\n+`borrow_mut()` method. Isn\u2019t that dangerous? What if we do:\n+\n+```rust,ignore\n+use std::cell::RefCell;\n+\n+let x = RefCell::new(42);\n+\n+let y = x.borrow_mut();\n+let z = x.borrow_mut();\n+# (y, z);\n+```\n+\n+This will in fact panic, at runtime. This is what `RefCell` does: it enforces\n+Rust\u2019s borrowing rules at runtime, and `panic!`s if they\u2019re violated. This\n+allows us to get around another aspect of Rust\u2019s mutability rules. Let\u2019s talk\n+about it first.\n+\n+## Field-level mutability\n+\n+Mutabilty is a property of either a borrow (`&mut`) or a binding (`let mut`).\n+This means that, for example, you cannot have a [`struct`][struct] with\n+some fields mutable and some immutable:\n+\n+```rust,ignore\n+struct Point {\n+    x: i32,\n+    mut y: i32, // nope\n+}\n+```\n+\n+The mutability of a struct is in its binding:\n+\n+```rust,ignore\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+let mut a = Point { x: 5, y: 6 };\n+\n+a.x = 10;\n+\n+let b = Point { x: 5, y: 6};\n+\n+b.x = 10; // error: cannot assign to immutable field `b.x`\n+```\n+\n+[struct]: structs.html\n+\n+However, by using `Cell<T>`, you can emulate field-level mutability:\n+\n+```\n+use std::cell::Cell;\n+\n+struct Point {\n+    x: i32,\n+    y: Cell<i32>,\n+}\n+\n+let mut point = Point { x: 5, y: Cell::new(6) };\n+\n+point.y.set(7);\n+\n+println!(\"y: {:?}\", point.y);\n+```\n+\n+This will print `y: Cell { value: 7 }`. We\u2019ve successfully updated `y`."}]}