{"sha": "a3ea65c2d9bc52f308745ae488435388fce753a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZWE2NWMyZDliYzUyZjMwODc0NWFlNDg4NDM1Mzg4ZmNlNzUzYTI=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-06-15T09:21:56Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-08-16T18:27:22Z"}, "message": "Implement new lint", "tree": {"sha": "9b9aeed7502369225e897c319cdf25f7ae0a3ccc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b9aeed7502369225e897c319cdf25f7ae0a3ccc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3ea65c2d9bc52f308745ae488435388fce753a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3ea65c2d9bc52f308745ae488435388fce753a2", "html_url": "https://github.com/rust-lang/rust/commit/a3ea65c2d9bc52f308745ae488435388fce753a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3ea65c2d9bc52f308745ae488435388fce753a2/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bd98895f13112912df3a7f23923470b07d53a09", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd98895f13112912df3a7f23923470b07d53a09", "html_url": "https://github.com/rust-lang/rust/commit/3bd98895f13112912df3a7f23923470b07d53a09"}], "stats": {"total": 495, "additions": 494, "deletions": 1}, "files": [{"sha": "c21190e9b9c5e0c9761de34b1e8efaaf4fa3d1cb", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea65c2d9bc52f308745ae488435388fce753a2/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea65c2d9bc52f308745ae488435388fce753a2/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=a3ea65c2d9bc52f308745ae488435388fce753a2", "patch": "@@ -1646,6 +1646,7 @@ Released 2018-09-13\n [`option_map_or_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_or_none\n [`option_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unit_fn\n [`option_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_option\n+[`option_unwrap_or_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_unwrap_or_else\n [`or_fun_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#or_fun_call\n [`out_of_bounds_indexing`]: https://rust-lang.github.io/rust-clippy/master/index.html#out_of_bounds_indexing\n [`overflow_check_conditional`]: https://rust-lang.github.io/rust-clippy/master/index.html#overflow_check_conditional"}, {"sha": "cb29f71387bb7cfb5c21027c4b27b2117fefc429", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea65c2d9bc52f308745ae488435388fce753a2/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea65c2d9bc52f308745ae488435388fce753a2/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a3ea65c2d9bc52f308745ae488435388fce753a2", "patch": "@@ -672,6 +672,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::OK_EXPECT,\n         &methods::OPTION_AS_REF_DEREF,\n         &methods::OPTION_MAP_OR_NONE,\n+        &methods::UNNECESSARY_LAZY_EVALUATION,\n         &methods::OR_FUN_CALL,\n         &methods::RESULT_MAP_OR_INTO_OPTION,\n         &methods::SEARCH_IS_SOME,\n@@ -1360,6 +1361,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::UNINIT_ASSUMED_INIT),\n         LintId::of(&methods::UNNECESSARY_FILTER_MAP),\n         LintId::of(&methods::UNNECESSARY_FOLD),\n+        LintId::of(&methods::UNNECESSARY_LAZY_EVALUATION),\n         LintId::of(&methods::USELESS_ASREF),\n         LintId::of(&methods::WRONG_SELF_CONVENTION),\n         LintId::of(&methods::ZST_OFFSET),\n@@ -1610,6 +1612,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::FILTER_NEXT),\n         LintId::of(&methods::FLAT_MAP_IDENTITY),\n         LintId::of(&methods::OPTION_AS_REF_DEREF),\n+        LintId::of(&methods::UNNECESSARY_LAZY_EVALUATION),\n         LintId::of(&methods::SEARCH_IS_SOME),\n         LintId::of(&methods::SKIP_WHILE_NEXT),\n         LintId::of(&methods::SUSPICIOUS_MAP),"}, {"sha": "61b7f2647ee72c390c23e986cfd4fd99ac93c807", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea65c2d9bc52f308745ae488435388fce753a2/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea65c2d9bc52f308745ae488435388fce753a2/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=a3ea65c2d9bc52f308745ae488435388fce753a2", "patch": "@@ -1329,6 +1329,32 @@ declare_clippy_lint! {\n     \"`push_str()` used with a single-character string literal as parameter\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Looks for unnecessary lazily evaluated closures on `Option` and `Result`.\n+    ///\n+    /// **Why is this bad?** Using eager evaluation is shorter and simpler in some cases.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // example code where clippy issues a warning\n+    /// let opt: Option<u32> = None;\n+    ///\n+    /// opt.unwrap_or_else(|| 42);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let opt: Option<u32> = None;\n+    ///\n+    /// opt.unwrap_or(42);\n+    /// ```\n+    pub UNNECESSARY_LAZY_EVALUATION,\n+    style,\n+    \"using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\"\n+}\n+\n declare_lint_pass!(Methods => [\n     UNWRAP_USED,\n     EXPECT_USED,\n@@ -1378,6 +1404,7 @@ declare_lint_pass!(Methods => [\n     ZST_OFFSET,\n     FILETYPE_IS_FILE,\n     OPTION_AS_REF_DEREF,\n+    UNNECESSARY_LAZY_EVALUATION,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Methods {\n@@ -1398,13 +1425,18 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"expect\", \"ok\"] => lint_ok_expect(cx, expr, arg_lists[1]),\n             [\"expect\", ..] => lint_expect(cx, expr, arg_lists[0]),\n             [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0], method_spans[1]),\n-            [\"unwrap_or_else\", \"map\"] => lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"unwrap_or_else\", \"map\"] => {\n+                lint_lazy_eval(cx, expr, arg_lists[0], true, \"unwrap_or\");\n+                lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]);\n+            },\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n             [\"and_then\", ..] => {\n+                lint_lazy_eval(cx, expr, arg_lists[0], false, \"and\");\n                 bind_instead_of_map::OptionAndThenSome::lint(cx, expr, arg_lists[0]);\n                 bind_instead_of_map::ResultAndThenOk::lint(cx, expr, arg_lists[0]);\n             },\n             [\"or_else\", ..] => {\n+                lint_lazy_eval(cx, expr, arg_lists[0], false, \"or\");\n                 bind_instead_of_map::ResultOrElseErrInfo::lint(cx, expr, arg_lists[0]);\n             },\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n@@ -1448,6 +1480,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"is_file\", ..] => lint_filetype_is_file(cx, expr, arg_lists[0]),\n             [\"map\", \"as_ref\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], false),\n             [\"map\", \"as_mut\"] => lint_option_as_ref_deref(cx, expr, arg_lists[1], arg_lists[0], true),\n+            [\"unwrap_or_else\", ..] => lint_lazy_eval(cx, expr, arg_lists[0], true, \"unwrap_or\"),\n+            [\"get_or_insert_with\", ..] => lint_lazy_eval(cx, expr, arg_lists[0], true, \"get_or_insert\"),\n+            [\"ok_or_else\", ..] => lint_lazy_eval(cx, expr, arg_lists[0], true, \"ok_or\"),\n             _ => {},\n         }\n \n@@ -2663,6 +2698,99 @@ fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map\n     }\n }\n \n+/// lint use of `<fn>_else(simple closure)` for `Option`s and `Result`s that can be\n+/// replaced with `<fn>(return value of simple closure)`\n+fn lint_lazy_eval<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    args: &'tcx [hir::Expr<'_>],\n+    allow_variant_calls: bool,\n+    simplify_using: &str,\n+) {\n+    let is_option = is_type_diagnostic_item(cx, cx.tables.expr_ty(&args[0]), sym!(option_type));\n+    let is_result = is_type_diagnostic_item(cx, cx.tables.expr_ty(&args[0]), sym!(result_type));\n+\n+    if !is_option && !is_result {\n+        return;\n+    }\n+\n+    // Return true if the expression is an accessor of any of the arguments\n+    fn expr_uses_argument(expr: &hir::Expr<'_>, params: &[hir::Param<'_>]) -> bool {\n+        params.iter().any(|arg| {\n+            if_chain! {\n+                if let hir::PatKind::Binding(_, _, ident, _) = arg.pat.kind;\n+                if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = expr.kind;\n+                if let [p, ..] = path.segments;\n+                then {\n+                    ident.name == p.ident.name\n+                } else {\n+                    false\n+                }\n+            }\n+        })\n+    }\n+\n+    fn match_any_qpath(path: &hir::QPath<'_>, paths: &[&[&str]]) -> bool {\n+        paths.iter().any(|candidate| match_qpath(path, candidate))\n+    }\n+\n+    if let hir::ExprKind::Closure(_, _, eid, _, _) = args[1].kind {\n+        let body = cx.tcx.hir().body(eid);\n+        let ex = &body.value;\n+        let params = &body.params;\n+\n+        let simplify = match ex.kind {\n+            // Closures returning literals can be unconditionally simplified\n+            hir::ExprKind::Lit(_) => true,\n+\n+            // Reading fields can be simplified if the object is not an argument of the closure\n+            hir::ExprKind::Field(ref object, _) => !expr_uses_argument(object, params),\n+\n+            // Paths can be simplified if the root is not the argument, this also covers None\n+            hir::ExprKind::Path(_) => !expr_uses_argument(ex, params),\n+\n+            // Calls to Some, Ok, Err can be considered literals if they don't derive an argument\n+            hir::ExprKind::Call(ref func, ref args) => if_chain! {\n+                if allow_variant_calls; // Disable lint when rules conflict with bind_instead_of_map\n+                if let hir::ExprKind::Path(ref path) = func.kind;\n+                if match_any_qpath(path, &[&[\"Some\"], &[\"Ok\"], &[\"Err\"]]);\n+                then {\n+                    !args.iter().any(|arg| expr_uses_argument(arg, params))\n+                } else {\n+                    false\n+                }\n+            },\n+\n+            // For anything more complex than the above, a closure is probably the right solution,\n+            // or the case is handled by an other lint\n+            _ => false,\n+        };\n+\n+        if simplify {\n+            let msg = if is_option {\n+                \"unnecessary closure used to substitute value for `Option::None`\"\n+            } else {\n+                \"unnecessary closure used to substitute value for `Result::Err`\"\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_LAZY_EVALUATION,\n+                expr.span,\n+                msg,\n+                &format!(\"Use `{}` instead\", simplify_using),\n+                format!(\n+                    \"{0}.{1}({2})\",\n+                    snippet(cx, args[0].span, \"..\"),\n+                    simplify_using,\n+                    snippet(cx, ex.span, \"..\"),\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n /// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n fn lint_map_unwrap_or_else<'tcx>(\n     cx: &LateContext<'tcx>,"}, {"sha": "1e76163f946cd700ff04fd84b72bf3b81b9d057b", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea65c2d9bc52f308745ae488435388fce753a2/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea65c2d9bc52f308745ae488435388fce753a2/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=a3ea65c2d9bc52f308745ae488435388fce753a2", "patch": "@@ -2383,6 +2383,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"unnecessary_lazy_eval\",\n+        group: \"style\",\n+        desc: \"using unnecessary lazy evaluation, which can be replaced with simpler eager evaluation\",\n+        deprecation: None,\n+        module: \"methods\",\n+    },\n     Lint {\n         name: \"unnecessary_mut_passed\",\n         group: \"style\","}, {"sha": "fcfa6dfe12d5f4092c07339ffe319ab086a0b8c2", "filename": "tests/ui/unnecessary_lazy_eval.fixed", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea65c2d9bc52f308745ae488435388fce753a2/tests%2Fui%2Funnecessary_lazy_eval.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea65c2d9bc52f308745ae488435388fce753a2/tests%2Fui%2Funnecessary_lazy_eval.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.fixed?ref=a3ea65c2d9bc52f308745ae488435388fce753a2", "patch": "@@ -0,0 +1,105 @@\n+// run-rustfix\n+#![warn(clippy::unnecessary_lazy_evaluation)]\n+#![allow(clippy::redundant_closure)]\n+#![allow(clippy::bind_instead_of_map)]\n+\n+struct Deep(Option<u32>);\n+\n+#[derive(Copy, Clone)]\n+struct SomeStruct {\n+    some_field: u32,\n+}\n+\n+impl SomeStruct {\n+    fn return_some_field(&self) -> u32 {\n+        self.some_field\n+    }\n+}\n+\n+fn some_call<T: Default>() -> T {\n+    T::default()\n+}\n+\n+fn main() {\n+    let astronomers_pi = 10;\n+    let ext_str = SomeStruct { some_field: 10 };\n+\n+    // Should lint - Option\n+    let mut opt = Some(42);\n+    let ext_opt = Some(42);\n+    let _ = opt.unwrap_or(2);\n+    let _ = opt.unwrap_or(astronomers_pi);\n+    let _ = opt.unwrap_or(ext_str.some_field);\n+    let _ = opt.and(ext_opt);\n+    let _ = opt.or(ext_opt);\n+    let _ = opt.or(None);\n+    let _ = opt.get_or_insert(2);\n+    let _ = opt.ok_or(2);\n+\n+    // Cases when unwrap is not called on a simple variable\n+    let _ = Some(10).unwrap_or(2);\n+    let _ = Some(10).and(ext_opt);\n+    let _: Option<u32> = None.or(ext_opt);\n+    let _ = None.get_or_insert(2);\n+    let _: Result<u32, u32> = None.ok_or(2);\n+    let _: Option<u32> = None.or(None);\n+\n+    let mut deep = Deep(Some(42));\n+    let _ = deep.0.unwrap_or(2);\n+    let _ = deep.0.and(ext_opt);\n+    let _ = deep.0.or(None);\n+    let _ = deep.0.get_or_insert(2);\n+    let _ = deep.0.ok_or(2);\n+\n+    // Should not lint - Option\n+    let _ = opt.unwrap_or_else(|| ext_str.return_some_field());\n+    let _ = opt.or_else(some_call);\n+    let _ = opt.or_else(|| some_call());\n+    let _: Result<u32, u32> = opt.ok_or_else(|| some_call());\n+    let _: Result<u32, u32> = opt.ok_or_else(some_call);\n+    let _ = deep.0.get_or_insert_with(|| some_call());\n+    let _ = deep.0.or_else(some_call);\n+    let _ = deep.0.or_else(|| some_call());\n+\n+    // These are handled by bind_instead_of_map\n+    let _: Option<u32> = None.or_else(|| Some(3));\n+    let _ = deep.0.or_else(|| Some(3));\n+    let _ = opt.or_else(|| Some(3));\n+\n+    // Should lint - Result\n+    let res: Result<u32, u32> = Err(5);\n+    let res2: Result<u32, SomeStruct> = Err(SomeStruct { some_field: 5 });\n+\n+    let _ = res2.unwrap_or(2);\n+    let _ = res2.unwrap_or(astronomers_pi);\n+    let _ = res2.unwrap_or(ext_str.some_field);\n+\n+    // Should not lint - Result\n+    let _ = res.unwrap_or_else(|err| err);\n+    let _ = res2.unwrap_or_else(|err| err.some_field);\n+    let _ = res2.unwrap_or_else(|err| err.return_some_field());\n+    let _ = res2.unwrap_or_else(|_| ext_str.return_some_field());\n+\n+    let _: Result<u32, u32> = res.and_then(|x| Ok(x));\n+    let _: Result<u32, u32> = res.and_then(|x| Err(x));\n+\n+    let _: Result<u32, u32> = res.or_else(|err| Ok(err));\n+    let _: Result<u32, u32> = res.or_else(|err| Err(err));\n+\n+    // These are handled by bind_instead_of_map\n+    let _: Result<u32, u32> = res.and_then(|_| Ok(2));\n+    let _: Result<u32, u32> = res.and_then(|_| Ok(astronomers_pi));\n+    let _: Result<u32, u32> = res.and_then(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<u32, u32> = res.and_then(|_| Err(2));\n+    let _: Result<u32, u32> = res.and_then(|_| Err(astronomers_pi));\n+    let _: Result<u32, u32> = res.and_then(|_| Err(ext_str.some_field));\n+\n+    let _: Result<u32, u32> = res.or_else(|_| Ok(2));\n+    let _: Result<u32, u32> = res.or_else(|_| Ok(astronomers_pi));\n+    let _: Result<u32, u32> = res.or_else(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<u32, u32> = res.or_else(|_| Err(2));\n+    let _: Result<u32, u32> = res.or_else(|_| Err(astronomers_pi));\n+    let _: Result<u32, u32> = res.or_else(|_| Err(ext_str.some_field));\n+}"}, {"sha": "04b3c8ae1e253ebda3ab6329f0f66f019fefac2c", "filename": "tests/ui/unnecessary_lazy_eval.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea65c2d9bc52f308745ae488435388fce753a2/tests%2Fui%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea65c2d9bc52f308745ae488435388fce753a2/tests%2Fui%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.rs?ref=a3ea65c2d9bc52f308745ae488435388fce753a2", "patch": "@@ -0,0 +1,105 @@\n+// run-rustfix\n+#![warn(clippy::unnecessary_lazy_eval)]\n+#![allow(clippy::redundant_closure)]\n+#![allow(clippy::bind_instead_of_map)]\n+\n+struct Deep(Option<u32>);\n+\n+#[derive(Copy, Clone)]\n+struct SomeStruct {\n+    some_field: u32,\n+}\n+\n+impl SomeStruct {\n+    fn return_some_field(&self) -> u32 {\n+        self.some_field\n+    }\n+}\n+\n+fn some_call<T: Default>() -> T {\n+    T::default()\n+}\n+\n+fn main() {\n+    let astronomers_pi = 10;\n+    let ext_str = SomeStruct { some_field: 10 };\n+\n+    // Should lint - Option\n+    let mut opt = Some(42);\n+    let ext_opt = Some(42);\n+    let _ = opt.unwrap_or_else(|| 2);\n+    let _ = opt.unwrap_or_else(|| astronomers_pi);\n+    let _ = opt.unwrap_or_else(|| ext_str.some_field);\n+    let _ = opt.and_then(|_| ext_opt);\n+    let _ = opt.or_else(|| ext_opt);\n+    let _ = opt.or_else(|| None);\n+    let _ = opt.get_or_insert_with(|| 2);\n+    let _ = opt.ok_or_else(|| 2);\n+\n+    // Cases when unwrap is not called on a simple variable\n+    let _ = Some(10).unwrap_or_else(|| 2);\n+    let _ = Some(10).and_then(|_| ext_opt);\n+    let _: Option<u32> = None.or_else(|| ext_opt);\n+    let _ = None.get_or_insert_with(|| 2);\n+    let _: Result<u32, u32> = None.ok_or_else(|| 2);\n+    let _: Option<u32> = None.or_else(|| None);\n+\n+    let mut deep = Deep(Some(42));\n+    let _ = deep.0.unwrap_or_else(|| 2);\n+    let _ = deep.0.and_then(|_| ext_opt);\n+    let _ = deep.0.or_else(|| None);\n+    let _ = deep.0.get_or_insert_with(|| 2);\n+    let _ = deep.0.ok_or_else(|| 2);\n+\n+    // Should not lint - Option\n+    let _ = opt.unwrap_or_else(|| ext_str.return_some_field());\n+    let _ = opt.or_else(some_call);\n+    let _ = opt.or_else(|| some_call());\n+    let _: Result<u32, u32> = opt.ok_or_else(|| some_call());\n+    let _: Result<u32, u32> = opt.ok_or_else(some_call);\n+    let _ = deep.0.get_or_insert_with(|| some_call());\n+    let _ = deep.0.or_else(some_call);\n+    let _ = deep.0.or_else(|| some_call());\n+\n+    // These are handled by bind_instead_of_map\n+    let _: Option<u32> = None.or_else(|| Some(3));\n+    let _ = deep.0.or_else(|| Some(3));\n+    let _ = opt.or_else(|| Some(3));\n+\n+    // Should lint - Result\n+    let res: Result<u32, u32> = Err(5);\n+    let res2: Result<u32, SomeStruct> = Err(SomeStruct { some_field: 5 });\n+\n+    let _ = res2.unwrap_or_else(|_| 2);\n+    let _ = res2.unwrap_or_else(|_| astronomers_pi);\n+    let _ = res2.unwrap_or_else(|_| ext_str.some_field);\n+\n+    // Should not lint - Result\n+    let _ = res.unwrap_or_else(|err| err);\n+    let _ = res2.unwrap_or_else(|err| err.some_field);\n+    let _ = res2.unwrap_or_else(|err| err.return_some_field());\n+    let _ = res2.unwrap_or_else(|_| ext_str.return_some_field());\n+\n+    let _: Result<u32, u32> = res.and_then(|x| Ok(x));\n+    let _: Result<u32, u32> = res.and_then(|x| Err(x));\n+\n+    let _: Result<u32, u32> = res.or_else(|err| Ok(err));\n+    let _: Result<u32, u32> = res.or_else(|err| Err(err));\n+\n+    // These are handled by bind_instead_of_map\n+    let _: Result<u32, u32> = res.and_then(|_| Ok(2));\n+    let _: Result<u32, u32> = res.and_then(|_| Ok(astronomers_pi));\n+    let _: Result<u32, u32> = res.and_then(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<u32, u32> = res.and_then(|_| Err(2));\n+    let _: Result<u32, u32> = res.and_then(|_| Err(astronomers_pi));\n+    let _: Result<u32, u32> = res.and_then(|_| Err(ext_str.some_field));\n+\n+    let _: Result<u32, u32> = res.or_else(|_| Ok(2));\n+    let _: Result<u32, u32> = res.or_else(|_| Ok(astronomers_pi));\n+    let _: Result<u32, u32> = res.or_else(|_| Ok(ext_str.some_field));\n+\n+    let _: Result<u32, u32> = res.or_else(|_| Err(2));\n+    let _: Result<u32, u32> = res.or_else(|_| Err(astronomers_pi));\n+    let _: Result<u32, u32> = res.or_else(|_| Err(ext_str.some_field));\n+}"}, {"sha": "b941bf842469e431ec2dcc9c9dab5fa01b29cb47", "filename": "tests/ui/unnecessary_lazy_eval.stderr", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/a3ea65c2d9bc52f308745ae488435388fce753a2/tests%2Fui%2Funnecessary_lazy_eval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3ea65c2d9bc52f308745ae488435388fce753a2/tests%2Fui%2Funnecessary_lazy_eval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_lazy_eval.stderr?ref=a3ea65c2d9bc52f308745ae488435388fce753a2", "patch": "@@ -0,0 +1,144 @@\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:30:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(2)`\n+   |\n+   = note: `-D clippy::unnecessary-lazy-evaluation` implied by `-D warnings`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:31:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| astronomers_pi);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(astronomers_pi)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:32:13\n+   |\n+LL |     let _ = opt.unwrap_or_else(|| ext_str.some_field);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `opt.unwrap_or(ext_str.some_field)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:33:13\n+   |\n+LL |     let _ = opt.and_then(|_| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `opt.and(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:34:13\n+   |\n+LL |     let _ = opt.or_else(|| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:35:13\n+   |\n+LL |     let _ = opt.or_else(|| None);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `opt.or(None)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:36:13\n+   |\n+LL |     let _ = opt.get_or_insert_with(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `opt.get_or_insert(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:37:13\n+   |\n+LL |     let _ = opt.ok_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `opt.ok_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:40:13\n+   |\n+LL |     let _ = Some(10).unwrap_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `Some(10).unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:41:13\n+   |\n+LL |     let _ = Some(10).and_then(|_| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `Some(10).and(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:42:26\n+   |\n+LL |     let _: Option<u32> = None.or_else(|| ext_opt);\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:43:13\n+   |\n+LL |     let _ = None.get_or_insert_with(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `None.get_or_insert(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:44:31\n+   |\n+LL |     let _: Result<u32, u32> = None.ok_or_else(|| 2);\n+   |                               ^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `None.ok_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:45:26\n+   |\n+LL |     let _: Option<u32> = None.or_else(|| None);\n+   |                          ^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `None.or(None)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:48:13\n+   |\n+LL |     let _ = deep.0.unwrap_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `deep.0.unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:49:13\n+   |\n+LL |     let _ = deep.0.and_then(|_| ext_opt);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `and` instead: `deep.0.and(ext_opt)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:50:13\n+   |\n+LL |     let _ = deep.0.or_else(|| None);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `or` instead: `deep.0.or(None)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:51:13\n+   |\n+LL |     let _ = deep.0.get_or_insert_with(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `get_or_insert` instead: `deep.0.get_or_insert(2)`\n+\n+error: unnecessary closure used to substitute value for `Option::None`\n+  --> $DIR/unnecessary_lazy_eval.rs:52:13\n+   |\n+LL |     let _ = deep.0.ok_or_else(|| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: Use `ok_or` instead: `deep.0.ok_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:73:13\n+   |\n+LL |     let _ = res2.unwrap_or_else(|_| 2);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(2)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:74:13\n+   |\n+LL |     let _ = res2.unwrap_or_else(|_| astronomers_pi);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(astronomers_pi)`\n+\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:75:13\n+   |\n+LL |     let _ = res2.unwrap_or_else(|_| ext_str.some_field);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: Use `unwrap_or` instead: `res2.unwrap_or(ext_str.some_field)`\n+\n+error: unknown clippy lint: clippy::unnecessary_lazy_eval\n+  --> $DIR/unnecessary_lazy_eval.rs:2:9\n+   |\n+LL | #![warn(clippy::unnecessary_lazy_eval)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: did you mean: `clippy::unnecessary_lazy_evaluation`\n+   |\n+   = note: `-D clippy::unknown-clippy-lints` implied by `-D warnings`\n+\n+error: aborting due to 23 previous errors\n+"}]}