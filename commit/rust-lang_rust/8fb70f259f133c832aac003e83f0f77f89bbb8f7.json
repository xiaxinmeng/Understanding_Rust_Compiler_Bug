{"sha": "8fb70f259f133c832aac003e83f0f77f89bbb8f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmYjcwZjI1OWYxMzNjODMyYWFjMDAzZTgzZjBmNzdmODliYmI4Zjc=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-06-11T14:41:40Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-06-11T14:41:40Z"}, "message": "Move layout out of the enum for CValue", "tree": {"sha": "b5660ffc1eb8e217db8799329788d39d0925cc05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5660ffc1eb8e217db8799329788d39d0925cc05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fb70f259f133c832aac003e83f0f77f89bbb8f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fb70f259f133c832aac003e83f0f77f89bbb8f7", "html_url": "https://github.com/rust-lang/rust/commit/8fb70f259f133c832aac003e83f0f77f89bbb8f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fb70f259f133c832aac003e83f0f77f89bbb8f7/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "089e75ec420912d0381c885a6fbe8137a910e617", "url": "https://api.github.com/repos/rust-lang/rust/commits/089e75ec420912d0381c885a6fbe8137a910e617", "html_url": "https://github.com/rust-lang/rust/commit/089e75ec420912d0381c885a6fbe8137a910e617"}], "stats": {"total": 86, "additions": 43, "deletions": 43}, "files": [{"sha": "3c83220b0250de7261db528337a1fe1e0e2d7d40", "filename": "src/value_and_place.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/8fb70f259f133c832aac003e83f0f77f89bbb8f7/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fb70f259f133c832aac003e83f0f77f89bbb8f7/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=8fb70f259f133c832aac003e83f0f77f89bbb8f7", "patch": "@@ -20,40 +20,40 @@ fn codegen_field<'a, 'tcx: 'a>(\n \n /// A read-only value\n #[derive(Debug, Copy, Clone)]\n-pub enum CValue<'tcx> {\n-    ByRef(Value, TyLayout<'tcx>),\n-    ByVal(Value, TyLayout<'tcx>),\n-    ByValPair(Value, Value, TyLayout<'tcx>),\n+pub struct CValue<'tcx>(CValueInner, TyLayout<'tcx>);\n+\n+#[derive(Debug, Copy, Clone)]\n+enum CValueInner {\n+    ByRef(Value),\n+    ByVal(Value),\n+    ByValPair(Value, Value),\n }\n \n impl<'tcx> CValue<'tcx> {\n     pub fn by_ref(value: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n-        CValue::ByRef(value, layout)\n+        CValue(CValueInner::ByRef(value), layout)\n     }\n \n     pub fn by_val(value: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n-        CValue::ByVal(value, layout)\n+        CValue(CValueInner::ByVal(value), layout)\n     }\n \n     pub fn by_val_pair(value: Value, extra: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n-        CValue::ByValPair(value, extra, layout)\n+        CValue(CValueInner::ByValPair(value, extra), layout)\n     }\n \n     pub fn layout(&self) -> TyLayout<'tcx> {\n-        match *self {\n-            CValue::ByRef(_, layout)\n-            | CValue::ByVal(_, layout)\n-            | CValue::ByValPair(_, _, layout) => layout,\n-        }\n+        self.1\n     }\n \n     pub fn force_stack<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> Value\n     where\n         'tcx: 'a,\n     {\n-        match self {\n-            CValue::ByRef(value, _layout) => value,\n-            CValue::ByVal(value, layout) => {\n+        let layout = self.1;\n+        match self.0 {\n+            CValueInner::ByRef(value) => value,\n+            CValueInner::ByVal(value) => {\n                 let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n                     kind: StackSlotKind::ExplicitSlot,\n                     size: layout.size.bytes() as u32,\n@@ -63,7 +63,7 @@ impl<'tcx> CValue<'tcx> {\n                 fx.bcx.ins().store(MemFlags::new(), value, addr, 0);\n                 addr\n             }\n-            CValue::ByValPair(value, extra, layout) => {\n+            CValueInner::ByValPair(value, extra) => {\n                 let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n                     kind: StackSlotKind::ExplicitSlot,\n                     size: layout.size.bytes() as u32,\n@@ -84,17 +84,18 @@ impl<'tcx> CValue<'tcx> {\n     where\n         'tcx: 'a,\n     {\n-        match self {\n-            CValue::ByRef(addr, layout) => {\n+        let layout = self.1;\n+        match self.0 {\n+            CValueInner::ByRef(addr) => {\n                 let scalar = match layout.abi {\n                     layout::Abi::Scalar(ref scalar) => scalar.clone(),\n                     _ => unreachable!(),\n                 };\n                 let clif_ty = scalar_to_clif_type(fx.tcx, scalar);\n                 fx.bcx.ins().load(clif_ty, MemFlags::new(), addr, 0)\n             }\n-            CValue::ByVal(value, _layout) => value,\n-            CValue::ByValPair(_, _, _layout) => bug!(\"Please use load_scalar_pair for ByValPair\"),\n+            CValueInner::ByVal(value) => value,\n+            CValueInner::ByValPair(_, _) => bug!(\"Please use load_scalar_pair for ByValPair\"),\n         }\n     }\n \n@@ -103,8 +104,9 @@ impl<'tcx> CValue<'tcx> {\n     where\n         'tcx: 'a,\n     {\n-        match self {\n-            CValue::ByRef(addr, layout) => {\n+        let layout = self.1;\n+        match self.0 {\n+            CValueInner::ByRef(addr) => {\n                 let (a, b) = match &layout.abi {\n                     layout::Abi::ScalarPair(a, b) => (a.clone(), b.clone()),\n                     _ => unreachable!(),\n@@ -120,8 +122,8 @@ impl<'tcx> CValue<'tcx> {\n                 );\n                 (val1, val2)\n             }\n-            CValue::ByVal(_, _layout) => bug!(\"Please use load_scalar for ByVal\"),\n-            CValue::ByValPair(val1, val2, _layout) => (val1, val2),\n+            CValueInner::ByVal(_) => bug!(\"Please use load_scalar for ByVal\"),\n+            CValueInner::ByValPair(val1, val2) => (val1, val2),\n         }\n     }\n \n@@ -133,13 +135,14 @@ impl<'tcx> CValue<'tcx> {\n     where\n         'tcx: 'a,\n     {\n-        let (base, layout) = match self {\n-            CValue::ByRef(addr, layout) => (addr, layout),\n+        let layout = self.1;\n+        let base = match self.0 {\n+            CValueInner::ByRef(addr) => addr,\n             _ => bug!(\"place_field for {:?}\", self),\n         };\n \n         let (field_ptr, field_layout) = codegen_field(fx, base, layout, field);\n-        CValue::ByRef(field_ptr, field_layout)\n+        CValue::by_ref(field_ptr, field_layout)\n     }\n \n     pub fn unsize_value<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n@@ -156,15 +159,11 @@ impl<'tcx> CValue<'tcx> {\n     {\n         let clif_ty = fx.clif_type(ty).unwrap();\n         let layout = fx.layout_of(ty);\n-        CValue::ByVal(fx.bcx.ins().iconst(clif_ty, const_val), layout)\n+        CValue::by_val(fx.bcx.ins().iconst(clif_ty, const_val), layout)\n     }\n \n     pub fn unchecked_cast_to(self, layout: TyLayout<'tcx>) -> Self {\n-        match self {\n-            CValue::ByRef(addr, _) => CValue::ByRef(addr, layout),\n-            CValue::ByVal(val, _) => CValue::ByVal(val, layout),\n-            CValue::ByValPair(val, extra, _) => CValue::ByValPair(val, extra, layout),\n-        }\n+        CValue(self.0, layout)\n     }\n }\n \n@@ -229,16 +228,16 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n \n     pub fn to_cvalue(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>) -> CValue<'tcx> {\n         match self {\n-            CPlace::Var(var, layout) => CValue::ByVal(fx.bcx.use_var(mir_var(var)), layout),\n+            CPlace::Var(var, layout) => CValue::by_val(fx.bcx.use_var(mir_var(var)), layout),\n             CPlace::Addr(addr, extra, layout) => {\n                 assert!(extra.is_none(), \"unsized values are not yet supported\");\n-                CValue::ByRef(addr, layout)\n+                CValue::by_ref(addr, layout)\n             }\n-            CPlace::Stack(stack_slot, layout) => CValue::ByRef(\n+            CPlace::Stack(stack_slot, layout) => CValue::by_ref(\n                 fx.bcx.ins().stack_addr(fx.pointer_type, stack_slot, 0),\n                 layout,\n             ),\n-            CPlace::NoPlace(layout) => CValue::ByRef(\n+            CPlace::NoPlace(layout) => CValue::by_ref(\n                 fx.bcx\n                     .ins()\n                     .iconst(fx.pointer_type, fx.pointer_type.bytes() as i64),\n@@ -353,24 +352,25 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n             CPlace::Addr(_, _, _) => bug!(\"Can't write value to unsized place {:?}\", self),\n         };\n \n-        match from {\n-            CValue::ByVal(val, _src_layout) => {\n+        match from.0 {\n+            CValueInner::ByVal(val) => {\n                 fx.bcx.ins().store(MemFlags::new(), val, addr, 0);\n             }\n-            CValue::ByValPair(val1, val2, _src_layout) => {\n+            CValueInner::ByValPair(val1, val2) => {\n                 let val1_offset = dst_layout.fields.offset(0).bytes() as i32;\n                 let val2_offset = dst_layout.fields.offset(1).bytes() as i32;\n                 fx.bcx.ins().store(MemFlags::new(), val1, addr, val1_offset);\n                 fx.bcx.ins().store(MemFlags::new(), val2, addr, val2_offset);\n             }\n-            CValue::ByRef(from, src_layout) => {\n+            CValueInner::ByRef(from_addr) => {\n+                let src_layout = from.1;\n                 let size = dst_layout.size.bytes();\n                 let src_align = src_layout.align.abi.bytes() as u8;\n                 let dst_align = dst_layout.align.abi.bytes() as u8;\n                 fx.bcx.emit_small_memcpy(\n                     fx.module.target_config(),\n                     addr,\n-                    from,\n+                    from_addr,\n                     size,\n                     dst_align,\n                     src_align,\n@@ -446,7 +446,7 @@ impl<'a, 'tcx: 'a> CPlace<'tcx> {\n \n     pub fn write_place_ref(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n         if !self.layout().is_unsized() {\n-            let ptr = CValue::ByVal(self.to_addr(fx), dest.layout());\n+            let ptr = CValue::by_val(self.to_addr(fx), dest.layout());\n             dest.write_cvalue(fx, ptr);\n         } else {\n             let (value, extra) = self.to_addr_maybe_unsized(fx);"}]}