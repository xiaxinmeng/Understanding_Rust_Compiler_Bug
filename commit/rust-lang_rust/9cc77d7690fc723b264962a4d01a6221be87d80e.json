{"sha": "9cc77d7690fc723b264962a4d01a6221be87d80e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYzc3ZDc2OTBmYzcyM2IyNjQ5NjJhNGQwMWE2MjIxYmU4N2Q4MGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-22T14:17:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-22T14:17:36Z"}, "message": "Auto merge of #41464 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 3 pull requests\n\n- Successful merges: #41077, #41355, #41450\n- Failed merges:", "tree": {"sha": "35ab2d0889884041c889373f21e2347ef1de18a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35ab2d0889884041c889373f21e2347ef1de18a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cc77d7690fc723b264962a4d01a6221be87d80e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc77d7690fc723b264962a4d01a6221be87d80e", "html_url": "https://github.com/rust-lang/rust/commit/9cc77d7690fc723b264962a4d01a6221be87d80e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cc77d7690fc723b264962a4d01a6221be87d80e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d841da4a0d7629f826117f99052e3d4a7997a7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d841da4a0d7629f826117f99052e3d4a7997a7e", "html_url": "https://github.com/rust-lang/rust/commit/6d841da4a0d7629f826117f99052e3d4a7997a7e"}, {"sha": "b37163c81c44fa51f630adebec33aa90e2f2e432", "url": "https://api.github.com/repos/rust-lang/rust/commits/b37163c81c44fa51f630adebec33aa90e2f2e432", "html_url": "https://github.com/rust-lang/rust/commit/b37163c81c44fa51f630adebec33aa90e2f2e432"}], "stats": {"total": 994, "additions": 579, "deletions": 415}, "files": [{"sha": "8326a3683a9045d825e4fdc4021af340ee3b3755", "filename": "cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -1 +1 @@\n-Subproject commit c416fb60b11ecfd2a1ba0fb8567c9a92590b5d28\n+Subproject commit 8326a3683a9045d825e4fdc4021af340ee3b3755"}, {"sha": "12daa24e857fcbfa62a4f292c1aab804936a57d9", "filename": "src/doc/grammar.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -781,10 +781,11 @@ never_type : \"!\" ;\n ### Type parameter bounds\n \n ```antlr\n+bound-list := bound | bound '+' bound-list '+' ?\n bound := ty_bound | lt_bound\n lt_bound := lifetime\n-ty_bound := [?] [ for<lt_param_defs> ] simple_path\n-bound-list := bound | bound '+' bound-list '+' ?\n+ty_bound := ty_bound_noparen | (ty_bound_noparen)\n+ty_bound_noparen := [?] [ for<lt_param_defs> ] simple_path\n ```\n \n ### Self types"}, {"sha": "224e9751e73d0e9d3b55d728c999fee1137946be", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -88,6 +88,7 @@ pub enum DepNode<D: Clone + Debug> {\n     // predicates for an item wind up in `ItemSignature`).\n     AssociatedItems(D),\n     ItemSignature(D),\n+    IsForeignItem(D),\n     TypeParamPredicates((D, D)),\n     SizedConstraint(D),\n     AdtDestructor(D),\n@@ -171,6 +172,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransCrateItem,\n             AssociatedItems,\n             ItemSignature,\n+            IsForeignItem,\n             AssociatedItemDefIds,\n             InherentImpls,\n             TypeckTables,\n@@ -221,6 +223,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n+            IsForeignItem(ref d) => op(d).map(IsForeignItem),\n             TypeParamPredicates((ref item, ref param)) => {\n                 Some(TypeParamPredicates((try_opt!(op(item)), try_opt!(op(param)))))\n             }"}, {"sha": "be4ec16cd63aab3038176482046aa024893b9564", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -18,6 +18,7 @@\n use hir::map as hir_map;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n+use std::rc::Rc;\n use ty::{self, TyCtxt};\n use ty::maps::Providers;\n use middle::privacy;\n@@ -362,11 +363,11 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n     }\n }\n \n-pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> NodeSet {\n+pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Rc<NodeSet> {\n     ty::queries::reachable_set::get(tcx, DUMMY_SP, LOCAL_CRATE)\n }\n \n-fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> NodeSet {\n+fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> Rc<NodeSet> {\n     debug_assert!(crate_num == LOCAL_CRATE);\n \n     let access_levels = &ty::queries::privacy_access_levels::get(tcx, DUMMY_SP, LOCAL_CRATE);\n@@ -411,7 +412,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     reachable_context.propagate();\n \n     // Return the set of reachable symbols.\n-    reachable_context.reachable_symbols\n+    Rc::new(reachable_context.reachable_symbols)\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "18f0a749f701853e3a694786ed6452cd9a79503c", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -55,6 +55,7 @@ mod object_safety;\n mod select;\n mod specialize;\n mod structural_impls;\n+pub mod trans;\n mod util;\n \n /// An `Obligation` represents some trait reference (e.g. `int:Eq`) for"}, {"sha": "e38306aed2a91b9e7a0ffeac8bbe57bf32547ef1", "filename": "src/librustc/traits/trans/mod.rs", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -0,0 +1,212 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file contains various trait resolution methods used by trans.\n+// They all assume regions can be erased and monomorphic types.  It\n+// seems likely that they should eventually be merged into more\n+// general routines.\n+\n+use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n+use hir::def_id::DefId;\n+use infer::TransNormalize;\n+use std::cell::RefCell;\n+use std::marker::PhantomData;\n+use syntax::ast;\n+use syntax_pos::Span;\n+use traits::{FulfillmentContext, Obligation, ObligationCause, Reveal, SelectionContext, Vtable};\n+use ty::{self, Ty, TyCtxt};\n+use ty::subst::{Subst, Substs};\n+use ty::fold::{TypeFoldable, TypeFolder};\n+use util::common::MemoizationMap;\n+\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+    /// Attempts to resolve an obligation to a vtable.. The result is\n+    /// a shallow vtable resolution -- meaning that we do not\n+    /// (necessarily) resolve all nested obligations on the impl. Note\n+    /// that type check should guarantee to us that all nested\n+    /// obligations *could be* resolved if we wanted to.\n+    pub fn trans_fulfill_obligation(self,\n+                                    span: Span,\n+                                    trait_ref: ty::PolyTraitRef<'tcx>)\n+                                    -> Vtable<'tcx, ()>\n+    {\n+        // Remove any references to regions; this helps improve caching.\n+        let trait_ref = self.erase_regions(&trait_ref);\n+\n+        self.trans_trait_caches.trait_cache.memoize(trait_ref, || {\n+            debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n+                   trait_ref, trait_ref.def_id());\n+\n+            // Do the initial selection for the obligation. This yields the\n+            // shallow result we are looking for -- that is, what specific impl.\n+            self.infer_ctxt((), Reveal::All).enter(|infcx| {\n+                let mut selcx = SelectionContext::new(&infcx);\n+\n+                let obligation_cause = ObligationCause::misc(span,\n+                                                             ast::DUMMY_NODE_ID);\n+                let obligation = Obligation::new(obligation_cause,\n+                                                 trait_ref.to_poly_trait_predicate());\n+\n+                let selection = match selcx.select(&obligation) {\n+                    Ok(Some(selection)) => selection,\n+                    Ok(None) => {\n+                        // Ambiguity can happen when monomorphizing during trans\n+                        // expands to some humongo type that never occurred\n+                        // statically -- this humongo type can then overflow,\n+                        // leading to an ambiguous result. So report this as an\n+                        // overflow bug, since I believe this is the only case\n+                        // where ambiguity can result.\n+                        debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n+                                presuming due to overflow\",\n+                               trait_ref);\n+                        self.sess.span_fatal(span,\n+                                            \"reached the recursion limit during monomorphization \\\n+                                             (selection ambiguity)\");\n+                    }\n+                    Err(e) => {\n+                        span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n+                                  e, trait_ref)\n+                    }\n+                };\n+\n+                debug!(\"fulfill_obligation: selection={:?}\", selection);\n+\n+                // Currently, we use a fulfillment context to completely resolve\n+                // all nested obligations. This is because they can inform the\n+                // inference of the impl's type parameters.\n+                let mut fulfill_cx = FulfillmentContext::new();\n+                let vtable = selection.map(|predicate| {\n+                    debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n+                    fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+                });\n+                let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n+\n+                info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n+                vtable\n+            })\n+        })\n+    }\n+\n+    /// Monomorphizes a type from the AST by first applying the in-scope\n+    /// substitutions and then normalizing any associated types.\n+    pub fn trans_apply_param_substs<T>(self,\n+                                       param_substs: &Substs<'tcx>,\n+                                       value: &T)\n+                                       -> T\n+        where T: TransNormalize<'tcx>\n+    {\n+        debug!(\"apply_param_substs(param_substs={:?}, value={:?})\", param_substs, value);\n+        let substituted = value.subst(self, param_substs);\n+        let substituted = self.erase_regions(&substituted);\n+        AssociatedTypeNormalizer::new(self).fold(&substituted)\n+    }\n+}\n+\n+struct AssociatedTypeNormalizer<'a, 'gcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+}\n+\n+impl<'a, 'gcx> AssociatedTypeNormalizer<'a, 'gcx> {\n+    fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>) -> Self {\n+        AssociatedTypeNormalizer { tcx }\n+    }\n+\n+    fn fold<T:TypeFoldable<'gcx>>(&mut self, value: &T) -> T {\n+        if !value.has_projection_types() {\n+            value.clone()\n+        } else {\n+            value.fold_with(self)\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'gcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'gcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'gcx>) -> Ty<'gcx> {\n+        if !ty.has_projection_types() {\n+            ty\n+        } else {\n+            self.tcx.trans_trait_caches.project_cache.memoize(ty, || {\n+                debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n+                self.tcx.normalize_associated_type(&ty)\n+            })\n+        }\n+    }\n+}\n+\n+/// Specializes caches used in trans -- in particular, they assume all\n+/// types are fully monomorphized and that free regions can be erased.\n+pub struct TransTraitCaches<'tcx> {\n+    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n+    project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n+}\n+\n+impl<'tcx> TransTraitCaches<'tcx> {\n+    pub fn new(graph: DepGraph) -> Self {\n+        TransTraitCaches {\n+            trait_cache: RefCell::new(DepTrackingMap::new(graph.clone())),\n+            project_cache: RefCell::new(DepTrackingMap::new(graph)),\n+        }\n+    }\n+}\n+\n+// Implement DepTrackingMapConfig for `trait_cache`\n+pub struct TraitSelectionCache<'tcx> {\n+    data: PhantomData<&'tcx ()>\n+}\n+\n+impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n+    type Key = ty::PolyTraitRef<'tcx>;\n+    type Value = Vtable<'tcx, ()>;\n+    fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode<DefId> {\n+        key.to_poly_trait_predicate().dep_node()\n+    }\n+}\n+\n+// # Global Cache\n+\n+pub struct ProjectionCache<'gcx> {\n+    data: PhantomData<&'gcx ()>\n+}\n+\n+impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n+    type Key = Ty<'gcx>;\n+    type Value = Ty<'gcx>;\n+    fn to_dep_node(key: &Self::Key) -> DepNode<DefId> {\n+        // Ideally, we'd just put `key` into the dep-node, but we\n+        // can't put full types in there. So just collect up all the\n+        // def-ids of structs/enums as well as any traits that we\n+        // project out of. It doesn't matter so much what we do here,\n+        // except that if we are too coarse, we'll create overly\n+        // coarse edges between impls and the trans. For example, if\n+        // we just used the def-id of things we are projecting out of,\n+        // then the key for `<Foo as SomeTrait>::T` and `<Bar as\n+        // SomeTrait>::T` would both share a dep-node\n+        // (`TraitSelect(SomeTrait)`), and hence the impls for both\n+        // `Foo` and `Bar` would be considered inputs. So a change to\n+        // `Bar` would affect things that just normalized `Foo`.\n+        // Anyway, this heuristic is not ideal, but better than\n+        // nothing.\n+        let def_ids: Vec<DefId> =\n+            key.walk()\n+               .filter_map(|t| match t.sty {\n+                   ty::TyAdt(adt_def, _) => Some(adt_def.did),\n+                   ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n+                   _ => None,\n+               })\n+               .collect();\n+\n+        DepNode::ProjectionCache { def_ids: def_ids }\n+    }\n+}\n+"}, {"sha": "e836bf23a5a81f8766aaecb6e7a26963ccc3f3b5", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -407,6 +407,8 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub specializes_cache: RefCell<traits::SpecializesCache>,\n \n+    pub trans_trait_caches: traits::trans::TransTraitCaches<'tcx>,\n+\n     pub dep_graph: DepGraph,\n \n     /// Common types, pre-interned for your convenience.\n@@ -689,6 +691,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         providers[LOCAL_CRATE] = local_providers;\n         tls::enter_global(GlobalCtxt {\n             sess: s,\n+            trans_trait_caches: traits::trans::TransTraitCaches::new(dep_graph.clone()),\n             specializes_cache: RefCell::new(traits::SpecializesCache::new()),\n             global_arenas: arenas,\n             global_interners: interners,"}, {"sha": "648923d6f04e581e7c66988dfe0da9fb38164e9c", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -380,6 +380,9 @@ define_maps! { <'tcx>\n     pub adt_destructor: AdtDestructor(DefId) -> Option<ty::Destructor>,\n     pub adt_sized_constraint: SizedConstraint(DefId) -> Ty<'tcx>,\n \n+    /// True if this is a foreign item (i.e., linked via `extern { ... }`).\n+    pub is_foreign_item: IsForeignItem(DefId) -> bool,\n+\n     /// Maps from def-id of a type or region parameter to its\n     /// (inferred) variance.\n     pub variances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>>,\n@@ -448,7 +451,7 @@ define_maps! { <'tcx>\n     /// Performs the privacy check and computes \"access levels\".\n     pub privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n \n-    pub reachable_set: reachability_dep_node(CrateNum) -> NodeSet,\n+    pub reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n     pub mir_shims: mir_shim(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>\n }"}, {"sha": "649298abed51aaf24d887e69ffe1ae61d1ed8586", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -115,7 +115,7 @@ mod sty;\n #[derive(Clone)]\n pub struct CrateAnalysis {\n     pub access_levels: Rc<AccessLevels>,\n-    pub reachable: NodeSet,\n+    pub reachable: Rc<NodeSet>,\n     pub name: String,\n     pub glob_map: Option<hir::GlobMap>,\n }"}, {"sha": "ac4e2bd5c1038a71aaa3cd90bf688e8d0d3c987b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -810,7 +810,7 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         defs: resolver.definitions,\n         analysis: ty::CrateAnalysis {\n             access_levels: Rc::new(AccessLevels::default()),\n-            reachable: NodeSet(),\n+            reachable: Rc::new(NodeSet()),\n             name: crate_name.to_string(),\n             glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n         },\n@@ -889,9 +889,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     let index = stability::Index::new(&hir_map);\n \n     let mut local_providers = ty::maps::Providers::default();\n+    borrowck::provide(&mut local_providers);\n     mir::provide(&mut local_providers);\n+    reachable::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n-    borrowck::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);"}, {"sha": "3cff063a8f56812c3465a8e32217d556042c3a6b", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -111,6 +111,7 @@ provide! { <'tcx> tcx, def_id, cdata\n     closure_kind => { cdata.closure_kind(def_id.index) }\n     closure_type => { cdata.closure_ty(def_id.index, tcx) }\n     inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n+    is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n }\n \n impl CrateStore for cstore::CStore {"}, {"sha": "221c52141a8323de0193f3d2a926599df704a5b9", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -53,7 +53,7 @@ impl ExportedSymbols {\n                 scx.tcx().hir.local_def_id(node_id)\n             })\n             .map(|def_id| {\n-                let name = symbol_for_def_id(scx, def_id, symbol_map);\n+                let name = symbol_for_def_id(scx.tcx(), def_id, symbol_map);\n                 let export_level = export_level(scx, def_id);\n                 debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n                 (name, export_level)\n@@ -108,7 +108,7 @@ impl ExportedSymbols {\n                 .exported_symbols(cnum)\n                 .iter()\n                 .map(|&def_id| {\n-                    let name = symbol_name(Instance::mono(scx.tcx(), def_id), scx);\n+                    let name = symbol_name(Instance::mono(scx.tcx(), def_id), scx.tcx());\n                     let export_level = if special_runtime_crate {\n                         // We can probably do better here by just ensuring that\n                         // it has hidden visibility rather than public\n@@ -214,21 +214,21 @@ pub fn is_below_threshold(level: SymbolExportLevel,\n     }\n }\n \n-fn symbol_for_def_id<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn symbol_for_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                def_id: DefId,\n                                symbol_map: &SymbolMap<'tcx>)\n                                -> String {\n     // Just try to look things up in the symbol map. If nothing's there, we\n     // recompute.\n-    if let Some(node_id) = scx.tcx().hir.as_local_node_id(def_id) {\n+    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n         if let Some(sym) = symbol_map.get(TransItem::Static(node_id)) {\n             return sym.to_owned();\n         }\n     }\n \n-    let instance = Instance::mono(scx.tcx(), def_id);\n+    let instance = Instance::mono(tcx, def_id);\n \n     symbol_map.get(TransItem::Fn(instance))\n               .map(str::to_owned)\n-              .unwrap_or_else(|| symbol_name(instance, scx))\n+              .unwrap_or_else(|| symbol_name(instance, tcx))\n }"}, {"sha": "61b95f098adbd2e325c2ae168d4e95f8e055fb4b", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -97,13 +97,12 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use common::SharedCrateContext;\n use monomorphize::Instance;\n \n use rustc::middle::weak_lang_items;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::ty::subst::Substs;\n@@ -113,7 +112,7 @@ use rustc::util::common::record_time;\n use syntax::attr;\n use syntax::symbol::{Symbol, InternedString};\n \n-fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                              // the DefId of the item this name is for\n                              def_id: Option<DefId>,\n@@ -130,8 +129,6 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                              -> String {\n     debug!(\"get_symbol_hash(def_id={:?}, parameters={:?})\", def_id, substs);\n \n-    let tcx = scx.tcx();\n-\n     let mut hasher = ty::util::TypeIdHasher::<u64>::new(tcx);\n \n     record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n@@ -157,8 +154,8 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             // in case the same instances is emitted in two crates of the same\n             // project.\n             if substs.types().next().is_some() {\n-                hasher.hash(scx.tcx().crate_name.as_str());\n-                hasher.hash(scx.sess().local_crate_disambiguator().as_str());\n+                hasher.hash(tcx.crate_name.as_str());\n+                hasher.hash(tcx.sess.local_crate_disambiguator().as_str());\n             }\n         }\n     });\n@@ -168,37 +165,37 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n }\n \n pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n-                             scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+                             tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n     debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n            def_id, substs);\n \n-    let node_id = scx.tcx().hir.as_local_node_id(def_id);\n+    let node_id = tcx.hir.as_local_node_id(def_id);\n \n     if let Some(id) = node_id {\n-        if scx.sess().plugin_registrar_fn.get() == Some(id) {\n+        if tcx.sess.plugin_registrar_fn.get() == Some(id) {\n             let idx = def_id.index;\n-            let disambiguator = scx.sess().local_crate_disambiguator();\n-            return scx.sess().generate_plugin_registrar_symbol(disambiguator, idx);\n+            let disambiguator = tcx.sess.local_crate_disambiguator();\n+            return tcx.sess.generate_plugin_registrar_symbol(disambiguator, idx);\n         }\n-        if scx.sess().derive_registrar_fn.get() == Some(id) {\n+        if tcx.sess.derive_registrar_fn.get() == Some(id) {\n             let idx = def_id.index;\n-            let disambiguator = scx.sess().local_crate_disambiguator();\n-            return scx.sess().generate_derive_registrar_symbol(disambiguator, idx);\n+            let disambiguator = tcx.sess.local_crate_disambiguator();\n+            return tcx.sess.generate_derive_registrar_symbol(disambiguator, idx);\n         }\n     }\n \n     // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n-    let attrs = scx.tcx().get_attrs(def_id);\n+    let attrs = tcx.get_attrs(def_id);\n     let is_foreign = if let Some(id) = node_id {\n-        match scx.tcx().hir.get(id) {\n+        match tcx.hir.get(id) {\n             hir_map::NodeForeignItem(_) => true,\n             _ => false\n         }\n     } else {\n-        scx.sess().cstore.is_foreign_item(def_id)\n+        tcx.sess.cstore.is_foreign_item(def_id)\n     };\n \n     if let Some(name) = weak_lang_items::link_name(&attrs) {\n@@ -210,17 +207,17 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n             return name.to_string();\n         }\n         // Don't mangle foreign items.\n-        return scx.tcx().item_name(def_id).as_str().to_string();\n+        return tcx.item_name(def_id).as_str().to_string();\n     }\n \n-    if let Some(name) = attr::find_export_name_attr(scx.sess().diagnostic(), &attrs) {\n+    if let Some(name) = attr::find_export_name_attr(tcx.sess.diagnostic(), &attrs) {\n         // Use provided name\n         return name.to_string();\n     }\n \n     if attr::contains_name(&attrs, \"no_mangle\") {\n         // Don't mangle\n-        return scx.tcx().item_name(def_id).as_str().to_string();\n+        return tcx.item_name(def_id).as_str().to_string();\n     }\n \n     // We want to compute the \"type\" of this item. Unfortunately, some\n@@ -230,11 +227,11 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n     let mut ty_def_id = def_id;\n     let instance_ty;\n     loop {\n-        let key = scx.tcx().def_key(ty_def_id);\n+        let key = tcx.def_key(ty_def_id);\n         match key.disambiguated_data.data {\n             DefPathData::TypeNs(_) |\n             DefPathData::ValueNs(_) => {\n-                instance_ty = scx.tcx().item_type(ty_def_id);\n+                instance_ty = tcx.item_type(ty_def_id);\n                 break;\n             }\n             _ => {\n@@ -251,16 +248,16 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n \n     // Erase regions because they may not be deterministic when hashed\n     // and should not matter anyhow.\n-    let instance_ty = scx.tcx().erase_regions(&instance_ty);\n+    let instance_ty = tcx.erase_regions(&instance_ty);\n \n-    let hash = get_symbol_hash(scx, Some(def_id), instance_ty, Some(substs));\n+    let hash = get_symbol_hash(tcx, Some(def_id), instance_ty, Some(substs));\n \n     let mut buffer = SymbolPathBuffer {\n         names: Vec::new()\n     };\n \n     item_path::with_forced_absolute_paths(|| {\n-        scx.tcx().push_item_path(&mut buffer, def_id);\n+        tcx.push_item_path(&mut buffer, def_id);\n     });\n \n     mangle(buffer.names.into_iter(), &hash)\n@@ -281,11 +278,11 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     }\n }\n \n-pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+pub fn exported_name_from_type_and_prefix<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     t: Ty<'tcx>,\n                                                     prefix: &str)\n                                                     -> String {\n-    let hash = get_symbol_hash(scx, None, t, None);\n+    let hash = get_symbol_hash(tcx, None, t, None);\n     let path = [Symbol::intern(prefix).as_str()];\n     mangle(path.iter().cloned(), &hash)\n }"}, {"sha": "ba119bd9ef069b01be558592183d795bacca7e73", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -65,6 +65,7 @@ use meth;\n use mir;\n use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit};\n+use symbol_cache::SymbolCache;\n use symbol_map::SymbolMap;\n use symbol_names_test;\n use trans_item::{TransItem, DefPathBasedNames};\n@@ -75,7 +76,6 @@ use util::nodemap::{NodeSet, FxHashMap, FxHashSet};\n \n use libc::c_uint;\n use std::ffi::{CStr, CString};\n-use std::rc::Rc;\n use std::str;\n use std::i32;\n use syntax_pos::Span;\n@@ -802,6 +802,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n /// in any other compilation unit.  Give these symbols internal linkage.\n fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                                  scx: &SharedCrateContext<'a, 'tcx>,\n+                                 translation_items: &FxHashSet<TransItem<'tcx>>,\n                                  llvm_modules: &[ModuleLlvm],\n                                  symbol_map: &SymbolMap<'tcx>,\n                                  exported_symbols: &ExportedSymbols) {\n@@ -854,7 +855,7 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n             let mut locally_defined_symbols = FxHashSet();\n             let mut linkage_fixed_explicitly = FxHashSet();\n \n-            for trans_item in scx.translation_items().borrow().iter() {\n+            for trans_item in translation_items {\n                 let symbol_name = symbol_map.get_or_compute(scx, *trans_item);\n                 if trans_item.explicit_linkage(tcx).is_some() {\n                     linkage_fixed_explicitly.insert(symbol_name.clone());\n@@ -1011,8 +1012,8 @@ fn iter_functions(llmod: llvm::ModuleRef) -> ValueIter {\n ///\n /// This list is later used by linkers to determine the set of symbols needed to\n /// be exposed from a dynamic library and it's also encoded into the metadata.\n-pub fn find_exported_symbols(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n-    reachable.into_iter().filter(|&id| {\n+pub fn find_exported_symbols(tcx: TyCtxt, reachable: &NodeSet) -> NodeSet {\n+    reachable.iter().cloned().filter(|&id| {\n         // Next, we want to ignore some FFI functions that are not exposed from\n         // this crate. Reachable FFI functions can be lumped into two\n         // categories:\n@@ -1064,7 +1065,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let krate = tcx.hir.krate();\n \n     let ty::CrateAnalysis { reachable, .. } = analysis;\n-    let exported_symbols = find_exported_symbols(tcx, reachable);\n+    let exported_symbols = find_exported_symbols(tcx, &reachable);\n \n     let check_overflow = tcx.sess.overflow_checks();\n \n@@ -1109,9 +1110,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Run the translation item collector and partition the collected items into\n     // codegen units.\n-    let (codegen_units, symbol_map) = collect_and_partition_translation_items(&shared_ccx);\n-\n-    let symbol_map = Rc::new(symbol_map);\n+    let (translation_items, codegen_units, symbol_map) =\n+        collect_and_partition_translation_items(&shared_ccx);\n \n     let mut all_stats = Stats::default();\n     let modules: Vec<ModuleTranslation> = codegen_units\n@@ -1121,7 +1121,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let (stats, module) =\n                 tcx.dep_graph.with_task(dep_node,\n                                         AssertDepGraphSafe(&shared_ccx),\n-                                        AssertDepGraphSafe((cgu, symbol_map.clone())),\n+                                        AssertDepGraphSafe(cgu),\n                                         module_translation);\n             all_stats.extend(stats);\n             module\n@@ -1130,16 +1130,17 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     fn module_translation<'a, 'tcx>(\n         scx: AssertDepGraphSafe<&SharedCrateContext<'a, 'tcx>>,\n-        args: AssertDepGraphSafe<(CodegenUnit<'tcx>, Rc<SymbolMap<'tcx>>)>)\n+        args: AssertDepGraphSafe<CodegenUnit<'tcx>>)\n         -> (Stats, ModuleTranslation)\n     {\n         // FIXME(#40304): We ought to be using the id as a key and some queries, I think.\n         let AssertDepGraphSafe(scx) = scx;\n-        let AssertDepGraphSafe((cgu, symbol_map)) = args;\n+        let AssertDepGraphSafe(cgu) = args;\n \n         let cgu_name = String::from(cgu.name());\n         let cgu_id = cgu.work_product_id();\n-        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &symbol_map);\n+        let symbol_cache = SymbolCache::new(scx.tcx());\n+        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &symbol_cache);\n \n         // Check whether there is a previous work-product we can\n         // re-use.  Not only must the file exist, and the inputs not\n@@ -1174,11 +1175,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Instantiate translation items without filling out definitions yet...\n-        let lcx = LocalCrateContext::new(scx, cgu, symbol_map.clone());\n+        let lcx = LocalCrateContext::new(scx, cgu, &symbol_cache);\n         let module = {\n             let ccx = CrateContext::new(scx, &lcx);\n             let trans_items = ccx.codegen_unit()\n-                                 .items_in_deterministic_order(ccx.tcx(), &symbol_map);\n+                                 .items_in_deterministic_order(ccx.tcx(), &symbol_cache);\n             for &(trans_item, linkage) in &trans_items {\n                 trans_item.predefine(&ccx, linkage);\n             }\n@@ -1238,7 +1239,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     assert_module_sources::assert_module_sources(tcx, &modules);\n \n-    symbol_names_test::report_symbol_names(&shared_ccx);\n+    symbol_names_test::report_symbol_names(tcx);\n \n     if shared_ccx.sess().trans_stats() {\n         println!(\"--- trans stats ---\");\n@@ -1289,6 +1290,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n         internalize_symbols(sess,\n                             &shared_ccx,\n+                            &translation_items,\n                             &llvm_modules,\n                             &symbol_map,\n                             &exported_symbols);\n@@ -1517,7 +1519,9 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n }\n \n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n-                                                     -> (Vec<CodegenUnit<'tcx>>, SymbolMap<'tcx>) {\n+                                                     -> (FxHashSet<TransItem<'tcx>>,\n+                                                         Vec<CodegenUnit<'tcx>>,\n+                                                         SymbolMap<'tcx>) {\n     let time_passes = scx.sess().time_passes();\n \n     let collection_mode = match scx.sess().opts.debugging_opts.print_trans_items {\n@@ -1563,13 +1567,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n     assert!(scx.tcx().sess.opts.cg.codegen_units == codegen_units.len() ||\n             scx.tcx().sess.opts.debugging_opts.incremental.is_some());\n \n-    {\n-        let mut ccx_map = scx.translation_items().borrow_mut();\n-\n-        for trans_item in items.iter().cloned() {\n-            ccx_map.insert(trans_item);\n-        }\n-    }\n+    let translation_items: FxHashSet<TransItem<'tcx>> = items.iter().cloned().collect();\n \n     if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n         let mut item_to_cgus = FxHashMap();\n@@ -1624,5 +1622,5 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         }\n     }\n \n-    (codegen_units, symbol_map)\n+    (translation_items, codegen_units, symbol_map)\n }"}, {"sha": "264e26e4594ca04c88baf6a33cb2c8fd7a09a401", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -14,18 +14,18 @@\n //! and methods are represented as just a fn ptr and not a full\n //! closure.\n \n-use llvm::{self, ValueRef};\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::Substs;\n use attributes;\n use common::{self, CrateContext};\n-use monomorphize;\n use consts;\n use declare;\n-use monomorphize::Instance;\n+use llvm::{self, ValueRef};\n+use monomorphize::{self, Instance};\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::subst::Substs;\n+use syntax_pos::DUMMY_SP;\n use trans_item::TransItem;\n use type_of;\n-use rustc::ty::TypeFoldable;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n@@ -51,8 +51,7 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let sym = ccx.symbol_map().get_or_compute(ccx.shared(),\n-                                              TransItem::Fn(instance));\n+    let sym = ccx.symbol_cache().get(TransItem::Fn(instance));\n     debug!(\"get_fn({:?}: {:?}) => {}\", instance, fn_ty, sym);\n \n     // This is subtle and surprising, but sometimes we have to bitcast\n@@ -102,15 +101,17 @@ pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let attrs = instance.def.attrs(ccx.tcx());\n         attributes::from_fn_attrs(ccx, &attrs, llfn);\n \n-        let is_local_def = ccx.shared().translation_items().borrow()\n-                              .contains(&TransItem::Fn(instance));\n-        if is_local_def {\n-            // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n+        // Perhaps questionable, but we assume that anything defined\n+        // *in Rust code* may unwind. Foreign items like `extern \"C\" {\n+        // fn foo(); }` are assumed not to unwind **unless** they have\n+        // a `#[unwind]` attribute.\n+        if !ty::queries::is_foreign_item::get(tcx, DUMMY_SP, instance.def_id()) {\n             attributes::unwind(llfn, true);\n             unsafe {\n                 llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::ExternalLinkage);\n             }\n         }\n+\n         if ccx.use_dll_storage_attrs() &&\n             ccx.sess().cstore.is_dllimport_foreign_item(instance.def_id())\n         {"}, {"sha": "13bb0d371250f98b5490b9c0696db0cc2548adff", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -467,13 +467,11 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             // have to instantiate all methods of the trait being cast to, so we\n             // can build the appropriate vtable.\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, target_ty) => {\n-                let target_ty = monomorphize::apply_param_substs(self.scx,\n-                                                                 self.param_substs,\n-                                                                 &target_ty);\n+                let target_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n+                                                                        &target_ty);\n                 let source_ty = operand.ty(self.mir, self.scx.tcx());\n-                let source_ty = monomorphize::apply_param_substs(self.scx,\n-                                                                 self.param_substs,\n-                                                                 &source_ty);\n+                let source_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n+                                                                        &source_ty);\n                 let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.scx,\n                                                                             source_ty,\n                                                                             target_ty);\n@@ -489,10 +487,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             }\n             mir::Rvalue::Cast(mir::CastKind::ReifyFnPointer, ref operand, _) => {\n                 let fn_ty = operand.ty(self.mir, self.scx.tcx());\n-                let fn_ty = monomorphize::apply_param_substs(\n-                    self.scx,\n-                    self.param_substs,\n-                    &fn_ty);\n+                let fn_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n+                                                                    &fn_ty);\n                 visit_fn_use(self.scx, fn_ty, false, &mut self.output);\n             }\n             mir::Rvalue::Cast(mir::CastKind::ClosureFnPointer, ref operand, _) => {\n@@ -534,9 +530,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         }\n \n         if let mir::Literal::Item { def_id, substs } = constant.literal {\n-            let substs = monomorphize::apply_param_substs(self.scx,\n-                                                          self.param_substs,\n-                                                          &substs);\n+            let substs = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n+                                                                 &substs);\n             let instance = monomorphize::resolve(self.scx, def_id, substs);\n             collect_neighbours(self.scx, instance, self.output);\n         }\n@@ -552,17 +547,14 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         match *kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n                 let callee_ty = func.ty(self.mir, tcx);\n-                let callee_ty = monomorphize::apply_param_substs(\n-                    self.scx, self.param_substs, &callee_ty);\n+                let callee_ty = tcx.trans_apply_param_substs(self.param_substs, &callee_ty);\n                 visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n                 let ty = location.ty(self.mir, self.scx.tcx())\n                     .to_ty(self.scx.tcx());\n-                let ty = monomorphize::apply_param_substs(self.scx,\n-                                                          self.param_substs,\n-                                                          &ty);\n+                let ty = tcx.trans_apply_param_substs(self.param_substs, &ty);\n                 visit_drop_use(self.scx, ty, true, self.output);\n             }\n             mir::TerminatorKind::Goto { .. } |"}, {"sha": "648ea92c8437601d22f7dd62d6c068dc1adea136", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -564,7 +564,7 @@ pub fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                         -> Ty<'tcx>\n {\n     let ty = shared.tcx().item_type(def_id);\n-    monomorphize::apply_param_substs(shared, substs, &ty)\n+    shared.tcx().trans_apply_param_substs(substs, &ty)\n }\n \n /// Return the substituted type of an instance.\n@@ -573,5 +573,5 @@ pub fn instance_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n                              -> Ty<'tcx>\n {\n     let ty = instance.def.def_ty(shared.tcx());\n-    monomorphize::apply_param_substs(shared, instance.substs, &ty)\n+    shared.tcx().trans_apply_param_substs(instance.substs, &ty)\n }"}, {"sha": "3d614cfbcbf3c5c5f961a0d8b5b361c2df6274e2", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -93,28 +93,27 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let sym = ccx.symbol_map()\n-                             .get(TransItem::Static(id))\n-                             .expect(\"Local statics should always be in the SymbolMap\");\n+                let sym = ccx.symbol_cache()\n+                             .get(TransItem::Static(id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()\n                                                          .contains_key(&TransItem::Static(id));\n                 assert!(!defined_in_current_codegen_unit);\n \n-                if declare::get_declared_value(ccx, sym).is_some() {\n+                if declare::get_declared_value(ccx, &sym[..]).is_some() {\n                     span_bug!(span, \"trans: Conflicting symbol names for static?\");\n                 }\n \n-                let g = declare::define_global(ccx, sym, llty).unwrap();\n+                let g = declare::define_global(ccx, &sym[..], llty).unwrap();\n \n                 (g, attrs)\n             }\n \n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let sym = symbol_names::symbol_name(instance, ccx.shared());\n+                let sym = symbol_names::symbol_name(instance, ccx.tcx());\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -174,7 +173,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n         g\n     } else {\n-        let sym = symbol_names::symbol_name(instance, ccx.shared());\n+        let sym = symbol_names::symbol_name(instance, ccx.tcx());\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global"}, {"sha": "ceb292c13c12aaacdb7c163d2236131a2ee5ea3f", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 20, "deletions": 96, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -10,7 +10,7 @@\n \n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef};\n-use rustc::dep_graph::{DepGraph, DepGraphSafe, DepNode, DepTrackingMap, DepTrackingMapConfig};\n+use rustc::dep_graph::{DepGraph, DepGraphSafe};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n@@ -21,7 +21,6 @@ use declare;\n use monomorphize::Instance;\n \n use partitioning::CodegenUnit;\n-use trans_item::TransItem;\n use type_::Type;\n use rustc_data_structures::base_n;\n use rustc::ty::subst::Substs;\n@@ -30,15 +29,13 @@ use rustc::ty::layout::{LayoutTyper, TyLayout};\n use session::config::NoDebugInfo;\n use session::Session;\n use session::config;\n-use symbol_map::SymbolMap;\n-use util::nodemap::{NodeSet, DefIdMap, FxHashMap, FxHashSet};\n+use symbol_cache::SymbolCache;\n+use util::nodemap::{NodeSet, DefIdMap, FxHashMap};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n-use std::marker::PhantomData;\n use std::ptr;\n use std::iter;\n-use std::rc::Rc;\n use std::str;\n use syntax::ast;\n use syntax::symbol::InternedString;\n@@ -86,17 +83,13 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     check_overflow: bool,\n \n     use_dll_storage_attrs: bool,\n-\n-    translation_items: RefCell<FxHashSet<TransItem<'tcx>>>,\n-    trait_cache: RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>>,\n-    project_cache: RefCell<DepTrackingMap<ProjectionCache<'tcx>>>,\n }\n \n /// The local portion of a `CrateContext`.  There is one `LocalCrateContext`\n /// per compilation unit.  Each one has its own LLVM `ContextRef` so that\n /// several compilation units may be optimized in parallel.  All other LLVM\n /// data structures in the `LocalCrateContext` are tied to that `ContextRef`.\n-pub struct LocalCrateContext<'tcx> {\n+pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     stats: Stats,\n@@ -168,73 +161,23 @@ pub struct LocalCrateContext<'tcx> {\n     /// Depth of the current type-of computation - used to bail out\n     type_of_depth: Cell<usize>,\n \n-    symbol_map: Rc<SymbolMap<'tcx>>,\n-\n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n-}\n-\n-// Implement DepTrackingMapConfig for `trait_cache`\n-pub struct TraitSelectionCache<'tcx> {\n-    data: PhantomData<&'tcx ()>\n-}\n-\n-impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n-    type Key = ty::PolyTraitRef<'tcx>;\n-    type Value = traits::Vtable<'tcx, ()>;\n-    fn to_dep_node(key: &ty::PolyTraitRef<'tcx>) -> DepNode<DefId> {\n-        key.to_poly_trait_predicate().dep_node()\n-    }\n-}\n-\n-// # Global Cache\n-\n-pub struct ProjectionCache<'gcx> {\n-    data: PhantomData<&'gcx ()>\n-}\n \n-impl<'gcx> DepTrackingMapConfig for ProjectionCache<'gcx> {\n-    type Key = Ty<'gcx>;\n-    type Value = Ty<'gcx>;\n-    fn to_dep_node(key: &Self::Key) -> DepNode<DefId> {\n-        // Ideally, we'd just put `key` into the dep-node, but we\n-        // can't put full types in there. So just collect up all the\n-        // def-ids of structs/enums as well as any traits that we\n-        // project out of. It doesn't matter so much what we do here,\n-        // except that if we are too coarse, we'll create overly\n-        // coarse edges between impls and the trans. For example, if\n-        // we just used the def-id of things we are projecting out of,\n-        // then the key for `<Foo as SomeTrait>::T` and `<Bar as\n-        // SomeTrait>::T` would both share a dep-node\n-        // (`TraitSelect(SomeTrait)`), and hence the impls for both\n-        // `Foo` and `Bar` would be considered inputs. So a change to\n-        // `Bar` would affect things that just normalized `Foo`.\n-        // Anyway, this heuristic is not ideal, but better than\n-        // nothing.\n-        let def_ids: Vec<DefId> =\n-            key.walk()\n-               .filter_map(|t| match t.sty {\n-                   ty::TyAdt(adt_def, _) => Some(adt_def.did),\n-                   ty::TyProjection(ref proj) => Some(proj.trait_ref.def_id),\n-                   _ => None,\n-               })\n-               .collect();\n-\n-        DepNode::ProjectionCache { def_ids: def_ids }\n-    }\n+    symbol_cache: &'a SymbolCache<'a, 'tcx>,\n }\n \n /// A CrateContext value binds together one LocalCrateContext with the\n /// SharedCrateContext. It exists as a convenience wrapper, so we don't have to\n /// pass around (SharedCrateContext, LocalCrateContext) tuples all over trans.\n pub struct CrateContext<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n-    local_ccx: &'a LocalCrateContext<'tcx>,\n+    local_ccx: &'a LocalCrateContext<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     pub fn new(shared: &'a SharedCrateContext<'a, 'tcx>,\n-               local_ccx: &'a LocalCrateContext<'tcx>)\n+               local_ccx: &'a LocalCrateContext<'a, 'tcx>)\n                -> Self {\n         CrateContext { shared, local_ccx }\n     }\n@@ -385,9 +328,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             tcx: tcx,\n             check_overflow: check_overflow,\n             use_dll_storage_attrs: use_dll_storage_attrs,\n-            translation_items: RefCell::new(FxHashSet()),\n-            trait_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n-            project_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n         }\n     }\n \n@@ -407,14 +347,6 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.exported_symbols\n     }\n \n-    pub fn trait_cache(&self) -> &RefCell<DepTrackingMap<TraitSelectionCache<'tcx>>> {\n-        &self.trait_cache\n-    }\n-\n-    pub fn project_cache(&self) -> &RefCell<DepTrackingMap<ProjectionCache<'tcx>>> {\n-        &self.project_cache\n-    }\n-\n     pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n     }\n@@ -430,17 +362,13 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn use_dll_storage_attrs(&self) -> bool {\n         self.use_dll_storage_attrs\n     }\n-\n-    pub fn translation_items(&self) -> &RefCell<FxHashSet<TransItem<'tcx>>> {\n-        &self.translation_items\n-    }\n }\n \n-impl<'tcx> LocalCrateContext<'tcx> {\n-    pub fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n-                   codegen_unit: CodegenUnit<'tcx>,\n-                   symbol_map: Rc<SymbolMap<'tcx>>)\n-                   -> LocalCrateContext<'tcx> {\n+impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n+    pub fn new(shared: &SharedCrateContext<'a, 'tcx>,\n+               codegen_unit: CodegenUnit<'tcx>,\n+               symbol_cache: &'a SymbolCache<'a, 'tcx>)\n+               -> LocalCrateContext<'a, 'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n             //\n@@ -494,8 +422,8 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 rust_try_fn: Cell::new(None),\n                 intrinsics: RefCell::new(FxHashMap()),\n                 type_of_depth: Cell::new(0),\n-                symbol_map: symbol_map,\n                 local_gen_sym_counter: Cell::new(0),\n+                symbol_cache: symbol_cache,\n             };\n \n             let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n@@ -529,9 +457,9 @@ impl<'tcx> LocalCrateContext<'tcx> {\n     /// This is used in the `LocalCrateContext` constructor to allow calling\n     /// functions that expect a complete `CrateContext`, even before the local\n     /// portion is fully initialized and attached to the `SharedCrateContext`.\n-    fn dummy_ccx<'a>(shared: &'a SharedCrateContext<'a, 'tcx>,\n-                     local_ccxs: &'a [LocalCrateContext<'tcx>])\n-                     -> CrateContext<'a, 'tcx> {\n+    fn dummy_ccx(shared: &'a SharedCrateContext<'a, 'tcx>,\n+                 local_ccxs: &'a [LocalCrateContext<'a, 'tcx>])\n+                 -> CrateContext<'a, 'tcx> {\n         assert!(local_ccxs.len() == 1);\n         CrateContext {\n             shared: shared,\n@@ -549,7 +477,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared\n     }\n \n-    fn local(&self) -> &'b LocalCrateContext<'tcx> {\n+    fn local(&self) -> &'b LocalCrateContext<'b, 'tcx> {\n         self.local_ccx\n     }\n \n@@ -716,12 +644,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.use_dll_storage_attrs()\n     }\n \n-    pub fn symbol_map(&self) -> &SymbolMap<'tcx> {\n-        &*self.local().symbol_map\n-    }\n-\n-    pub fn translation_items(&self) -> &RefCell<FxHashSet<TransItem<'tcx>>> {\n-        &self.shared.translation_items\n+    pub fn symbol_cache(&self) -> &'b SymbolCache<'b, 'tcx> {\n+        self.local().symbol_cache\n     }\n \n     /// Given the def-id of some item that has no type parameters, make\n@@ -867,7 +791,7 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n     }\n }\n \n-pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'tcx>);\n+pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'a, 'tcx>);\n \n impl<'a, 'tcx> Drop for TypeOfDepthLock<'a, 'tcx> {\n     fn drop(&mut self) {"}, {"sha": "117d8568500b8a61176374b31d56aa5cc49d64b5", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -124,6 +124,7 @@ mod meth;\n mod mir;\n mod monomorphize;\n mod partitioning;\n+mod symbol_cache;\n mod symbol_map;\n mod symbol_names_test;\n mod trans_item;"}, {"sha": "dbae79e034daa7a5ef343e17deb83005ff810402", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -260,9 +260,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n-        monomorphize::apply_param_substs(self.ccx.shared(),\n-                                         self.substs,\n-                                         value)\n+        self.ccx.tcx().trans_apply_param_substs(self.substs, value)\n     }\n \n     fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {"}, {"sha": "af0e27c8ca391e69823b80d7f1e07432acb2b5ee", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -22,7 +22,7 @@ use base;\n use builder::Builder;\n use common::{self, CrateContext, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n-use monomorphize::{self, Instance};\n+use monomorphize::Instance;\n use abi::FnType;\n use type_of;\n \n@@ -102,8 +102,9 @@ pub struct MirContext<'a, 'tcx:'a> {\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n-        where T: TransNormalize<'tcx> {\n-        monomorphize::apply_param_substs(self.ccx.shared(), self.param_substs, value)\n+        where T: TransNormalize<'tcx>\n+    {\n+        self.ccx.tcx().trans_apply_param_substs(self.param_substs, value)\n     }\n \n     pub fn set_debug_loc(&mut self, bcx: &Builder, source_info: mir::SourceInfo) {"}, {"sha": "d27eeb2b64667b712d8f1939cae832eb3a828dab", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 126, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -13,17 +13,13 @@ use common::*;\n use glue;\n \n use rustc::hir::def_id::DefId;\n-use rustc::infer::TransNormalize;\n use rustc::middle::lang_items::DropInPlaceFnLangItem;\n-use rustc::traits::{self, SelectionContext, Reveal};\n+use rustc::traits;\n use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::ty::fold::{TypeFolder, TypeFoldable};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::util::common::MemoizationMap;\n \n-use syntax::ast;\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::codemap::DUMMY_SP;\n \n pub use rustc::ty::Instance;\n \n@@ -104,73 +100,6 @@ pub fn resolve_closure<'a, 'tcx> (\n     }\n }\n \n-/// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n-/// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n-/// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n-fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                span: Span,\n-                                trait_ref: ty::PolyTraitRef<'tcx>)\n-                                -> traits::Vtable<'tcx, ()>\n-{\n-    let tcx = scx.tcx();\n-\n-    // Remove any references to regions; this helps improve caching.\n-    let trait_ref = tcx.erase_regions(&trait_ref);\n-\n-    scx.trait_cache().memoize(trait_ref, || {\n-        debug!(\"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-               trait_ref, trait_ref.def_id());\n-\n-        // Do the initial selection for the obligation. This yields the\n-        // shallow result we are looking for -- that is, what specific impl.\n-        tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n-            let mut selcx = SelectionContext::new(&infcx);\n-\n-            let obligation_cause = traits::ObligationCause::misc(span,\n-                                                             ast::DUMMY_NODE_ID);\n-            let obligation = traits::Obligation::new(obligation_cause,\n-                                                     trait_ref.to_poly_trait_predicate());\n-\n-            let selection = match selcx.select(&obligation) {\n-                Ok(Some(selection)) => selection,\n-                Ok(None) => {\n-                    // Ambiguity can happen when monomorphizing during trans\n-                    // expands to some humongo type that never occurred\n-                    // statically -- this humongo type can then overflow,\n-                    // leading to an ambiguous result. So report this as an\n-                    // overflow bug, since I believe this is the only case\n-                    // where ambiguity can result.\n-                    debug!(\"Encountered ambiguity selecting `{:?}` during trans, \\\n-                            presuming due to overflow\",\n-                           trait_ref);\n-                    tcx.sess.span_fatal(span,\n-                        \"reached the recursion limit during monomorphization \\\n-                         (selection ambiguity)\");\n-                }\n-                Err(e) => {\n-                    span_bug!(span, \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                              e, trait_ref)\n-                }\n-            };\n-\n-            debug!(\"fulfill_obligation: selection={:?}\", selection);\n-\n-            // Currently, we use a fulfillment context to completely resolve\n-            // all nested obligations. This is because they can inform the\n-            // inference of the impl's type parameters.\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n-            let vtable = selection.map(|predicate| {\n-                debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n-                fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-            });\n-            let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n-\n-            info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n-            vtable\n-        })\n-    })\n-}\n-\n fn resolve_associated_item<'a, 'tcx>(\n     scx: &SharedCrateContext<'a, 'tcx>,\n     trait_item: &ty::AssociatedItem,\n@@ -185,7 +114,7 @@ fn resolve_associated_item<'a, 'tcx>(\n            def_id, trait_id, rcvr_substs);\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = fulfill_obligation(scx, DUMMY_SP, ty::Binder(trait_ref));\n+    let vtbl = tcx.trans_fulfill_obligation(DUMMY_SP, ty::Binder(trait_ref));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -285,7 +214,7 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n         substs: scx.tcx().mk_substs_trait(source_ty, &[target_ty])\n     });\n \n-    match fulfill_obligation(scx, DUMMY_SP, trait_ref) {\n+    match scx.tcx().trans_fulfill_obligation(DUMMY_SP, trait_ref) {\n         traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {\n             scx.tcx().coerce_unsized_info(impl_def_id).custom_kind.unwrap()\n         }\n@@ -295,21 +224,6 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n     }\n }\n \n-/// Monomorphizes a type from the AST by first applying the in-scope\n-/// substitutions and then normalizing any associated types.\n-pub fn apply_param_substs<'a, 'tcx, T>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                       param_substs: &Substs<'tcx>,\n-                                       value: &T)\n-                                       -> T\n-    where T: TransNormalize<'tcx>\n-{\n-    let tcx = scx.tcx();\n-    debug!(\"apply_param_substs(param_substs={:?}, value={:?})\", param_substs, value);\n-    let substituted = value.subst(tcx, param_substs);\n-    let substituted = scx.tcx().erase_regions(&substituted);\n-    AssociatedTypeNormalizer::new(scx).fold(&substituted)\n-}\n-\n /// Returns the normalized type of a struct field\n pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_substs: &Substs<'tcx>,\n@@ -319,39 +233,3 @@ pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.normalize_associated_type(&f.ty(tcx, param_substs))\n }\n \n-struct AssociatedTypeNormalizer<'a, 'b: 'a, 'gcx: 'b> {\n-    shared: &'a SharedCrateContext<'b, 'gcx>,\n-}\n-\n-impl<'a, 'b, 'gcx> AssociatedTypeNormalizer<'a, 'b, 'gcx> {\n-    fn new(shared: &'a SharedCrateContext<'b, 'gcx>) -> Self {\n-        AssociatedTypeNormalizer {\n-            shared: shared,\n-        }\n-    }\n-\n-    fn fold<T:TypeFoldable<'gcx>>(&mut self, value: &T) -> T {\n-        if !value.has_projection_types() {\n-            value.clone()\n-        } else {\n-            value.fold_with(self)\n-        }\n-    }\n-}\n-\n-impl<'a, 'b, 'gcx> TypeFolder<'gcx, 'gcx> for AssociatedTypeNormalizer<'a, 'b, 'gcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'gcx> {\n-        self.shared.tcx()\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'gcx>) -> Ty<'gcx> {\n-        if !ty.has_projection_types() {\n-            ty\n-        } else {\n-            self.shared.project_cache().memoize(ty, || {\n-                debug!(\"AssociatedTypeNormalizer: ty={:?}\", ty);\n-                self.shared.tcx().normalize_associated_type(&ty)\n-            })\n-        }\n-    }\n-}"}, {"sha": "6b89d11cfb68f161e9356ba6934a46e943f306bc", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -116,7 +116,7 @@ use rustc_incremental::IchHasher;\n use std::cmp::Ordering;\n use std::hash::Hash;\n use std::sync::Arc;\n-use symbol_map::SymbolMap;\n+use symbol_cache::SymbolCache;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n use trans_item::{TransItem, InstantiationMode};\n@@ -174,14 +174,15 @@ impl<'tcx> CodegenUnit<'tcx> {\n         DepNode::WorkProduct(self.work_product_id())\n     }\n \n-    pub fn compute_symbol_name_hash(&self,\n-                                    scx: &SharedCrateContext,\n-                                    symbol_map: &SymbolMap) -> u64 {\n+    pub fn compute_symbol_name_hash<'a>(&self,\n+                                        scx: &SharedCrateContext<'a, 'tcx>,\n+                                        symbol_cache: &SymbolCache<'a, 'tcx>)\n+                                        -> u64 {\n         let mut state = IchHasher::new();\n         let exported_symbols = scx.exported_symbols();\n-        let all_items = self.items_in_deterministic_order(scx.tcx(), symbol_map);\n+        let all_items = self.items_in_deterministic_order(scx.tcx(), symbol_cache);\n         for (item, _) in all_items {\n-            let symbol_name = symbol_map.get(item).unwrap();\n+            let symbol_name = symbol_cache.get(item);\n             symbol_name.len().hash(&mut state);\n             symbol_name.hash(&mut state);\n             let exported = match item {\n@@ -201,10 +202,10 @@ impl<'tcx> CodegenUnit<'tcx> {\n         state.finish().to_smaller_hash()\n     }\n \n-    pub fn items_in_deterministic_order(&self,\n-                                        tcx: TyCtxt,\n-                                        symbol_map: &SymbolMap)\n-                                        -> Vec<(TransItem<'tcx>, llvm::Linkage)> {\n+    pub fn items_in_deterministic_order<'a>(&self,\n+                                            tcx: TyCtxt,\n+                                            symbol_cache: &SymbolCache<'a, 'tcx>)\n+                                            -> Vec<(TransItem<'tcx>, llvm::Linkage)> {\n         let mut items: Vec<(TransItem<'tcx>, llvm::Linkage)> =\n             self.items.iter().map(|(item, linkage)| (*item, *linkage)).collect();\n \n@@ -216,9 +217,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n \n             match (node_id1, node_id2) {\n                 (None, None) => {\n-                    let symbol_name1 = symbol_map.get(trans_item1).unwrap();\n-                    let symbol_name2 = symbol_map.get(trans_item2).unwrap();\n-                    symbol_name1.cmp(symbol_name2)\n+                    let symbol_name1 = symbol_cache.get(trans_item1);\n+                    let symbol_name2 = symbol_cache.get(trans_item2);\n+                    symbol_name1.cmp(&symbol_name2)\n                 }\n                 // In the following two cases we can avoid looking up the symbol\n                 (None, Some(_)) => Ordering::Less,\n@@ -230,9 +231,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n                         return ordering;\n                     }\n \n-                    let symbol_name1 = symbol_map.get(trans_item1).unwrap();\n-                    let symbol_name2 = symbol_map.get(trans_item2).unwrap();\n-                    symbol_name1.cmp(symbol_name2)\n+                    let symbol_name1 = symbol_cache.get(trans_item1);\n+                    let symbol_name2 = symbol_cache.get(trans_item2);\n+                    symbol_name1.cmp(&symbol_name2)\n                 }\n             }\n         });\n@@ -271,14 +272,14 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let mut initial_partitioning = place_root_translation_items(scx,\n                                                                 trans_items);\n \n-    debug_dump(scx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n+    debug_dump(tcx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n \n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n         merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name.as_str());\n \n-        debug_dump(scx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n+        debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n \n     // In the next step, we use the inlining map to determine which addtional\n@@ -288,7 +289,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let post_inlining = place_inlined_translation_items(initial_partitioning,\n                                                         inlining_map);\n \n-    debug_dump(scx, \"POST INLINING:\", post_inlining.0.iter());\n+    debug_dump(tcx, \"POST INLINING:\", post_inlining.0.iter());\n \n     // Finally, sort by codegen unit name, so that we get deterministic results\n     let mut result = post_inlining.0;\n@@ -528,28 +529,26 @@ fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString\n     Symbol::intern(&format!(\"{}{}{}\", crate_name, NUMBERED_CODEGEN_UNIT_MARKER, index)).as_str()\n }\n \n-fn debug_dump<'a, 'b, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                label: &str,\n                                cgus: I)\n     where I: Iterator<Item=&'b CodegenUnit<'tcx>>,\n           'tcx: 'a + 'b\n {\n     if cfg!(debug_assertions) {\n         debug!(\"{}\", label);\n+        let symbol_cache = SymbolCache::new(tcx);\n         for cgu in cgus {\n-            let symbol_map = SymbolMap::build(scx, cgu.items\n-                                                      .iter()\n-                                                      .map(|(&trans_item, _)| trans_item));\n             debug!(\"CodegenUnit {}:\", cgu.name);\n \n             for (trans_item, linkage) in &cgu.items {\n-                let symbol_name = symbol_map.get_or_compute(scx, *trans_item);\n+                let symbol_name = symbol_cache.get(*trans_item);\n                 let symbol_hash_start = symbol_name.rfind('h');\n                 let symbol_hash = symbol_hash_start.map(|i| &symbol_name[i ..])\n                                                    .unwrap_or(\"<no hash>\");\n \n                 debug!(\" - {} [{:?}] [{}]\",\n-                       trans_item.to_string(scx.tcx()),\n+                       trans_item.to_string(tcx),\n                        linkage,\n                        symbol_hash);\n             }"}, {"sha": "ddc1ef537a55fcdd4fd575579758efee882301f9", "filename": "src/librustc_trans/symbol_cache.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fsymbol_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fsymbol_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_cache.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TyCtxt;\n+use std::cell::RefCell;\n+use syntax_pos::symbol::{InternedString, Symbol};\n+use trans_item::TransItem;\n+use util::nodemap::FxHashMap;\n+\n+// In the SymbolCache we collect the symbol names of translation items\n+// and cache them for later reference. This is just a performance\n+// optimization and the cache is populated lazilly; symbol names of\n+// translation items are deterministic and fully defined by the item.\n+// Thus they can always be recomputed if needed.\n+\n+pub struct SymbolCache<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    index: RefCell<FxHashMap<TransItem<'tcx>, Symbol>>,\n+}\n+\n+impl<'a, 'tcx> SymbolCache<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+        SymbolCache {\n+            tcx: tcx,\n+            index: RefCell::new(FxHashMap())\n+        }\n+    }\n+\n+    pub fn get(&self, trans_item: TransItem<'tcx>) -> InternedString {\n+        let mut index = self.index.borrow_mut();\n+        index.entry(trans_item)\n+             .or_insert_with(|| Symbol::intern(&trans_item.compute_symbol_name(self.tcx)))\n+             .as_str()\n+    }\n+}"}, {"sha": "9d3e62888a2df1fadb22b8088c4d2a2de74875a2", "filename": "src/librustc_trans/symbol_map.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -34,8 +34,9 @@ impl<'tcx> SymbolMap<'tcx> {\n         where I: Iterator<Item=TransItem<'tcx>>\n     {\n         // Check for duplicate symbol names\n+        let tcx = scx.tcx();\n         let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n-            (trans_item, trans_item.compute_symbol_name(scx))\n+            (trans_item, trans_item.compute_symbol_name(tcx))\n         }).collect();\n \n         (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n@@ -124,7 +125,7 @@ impl<'tcx> SymbolMap<'tcx> {\n         if let Some(sym) = self.get(trans_item) {\n             Cow::from(sym)\n         } else {\n-            Cow::from(trans_item.compute_symbol_name(scx))\n+            Cow::from(trans_item.compute_symbol_name(scx.tcx()))\n         }\n     }\n }"}, {"sha": "fd817cb94c1c1db1251d73e7ea84c6832a300d47", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -17,43 +17,42 @@\n use back::symbol_names;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::ty::TyCtxt;\n use syntax::ast;\n \n-use common::SharedCrateContext;\n use monomorphize::Instance;\n \n const SYMBOL_NAME: &'static str = \"rustc_symbol_name\";\n const ITEM_PATH: &'static str = \"rustc_item_path\";\n \n-pub fn report_symbol_names(scx: &SharedCrateContext) {\n+pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the\n     // attributes we are interested in cannot be present anyway, so\n     // skip the walk.\n-    let tcx = scx.tcx();\n     if !tcx.sess.features.borrow().rustc_attrs {\n         return;\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    let mut visitor = SymbolNamesTest { scx: scx };\n+    let mut visitor = SymbolNamesTest { tcx: tcx };\n     // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n     tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n \n struct SymbolNamesTest<'a, 'tcx:'a> {\n-    scx: &'a SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n     fn process_attrs(&mut self,\n                      node_id: ast::NodeId) {\n-        let tcx = self.scx.tcx();\n+        let tcx = self.tcx;\n         let def_id = tcx.hir.local_def_id(node_id);\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n                 let instance = Instance::mono(tcx, def_id);\n-                let name = symbol_names::symbol_name(instance, self.scx);\n+                let name = symbol_names::symbol_name(instance, self.tcx);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {\n                 let path = tcx.item_path_str(def_id);"}, {"sha": "de35d1b7dd4c96330d46d06e479386e179c27a32", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -18,7 +18,7 @@ use asm;\n use attributes;\n use base;\n use consts;\n-use context::{CrateContext, SharedCrateContext};\n+use context::CrateContext;\n use common;\n use declare;\n use llvm;\n@@ -118,8 +118,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                self.to_raw_string(),\n                ccx.codegen_unit().name());\n \n-        let symbol_name = ccx.symbol_map()\n-                             .get_or_compute(ccx.shared(), *self);\n+        let symbol_name = ccx.symbol_cache().get(*self);\n \n         debug!(\"symbol {}\", &symbol_name);\n \n@@ -185,16 +184,15 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         ccx.instances().borrow_mut().insert(instance, lldecl);\n     }\n \n-    pub fn compute_symbol_name(&self,\n-                               scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+    pub fn compute_symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n         match *self {\n-            TransItem::Fn(instance) => symbol_names::symbol_name(instance, scx),\n+            TransItem::Fn(instance) => symbol_names::symbol_name(instance, tcx),\n             TransItem::Static(node_id) => {\n-                let def_id = scx.tcx().hir.local_def_id(node_id);\n-                symbol_names::symbol_name(Instance::mono(scx.tcx(), def_id), scx)\n+                let def_id = tcx.hir.local_def_id(node_id);\n+                symbol_names::symbol_name(Instance::mono(tcx, def_id), tcx)\n             }\n             TransItem::GlobalAsm(node_id) => {\n-                let def_id = scx.tcx().hir.local_def_id(node_id);\n+                let def_id = tcx.hir.local_def_id(node_id);\n                 format!(\"global_asm_{:?}\", def_id)\n             }\n         }"}, {"sha": "855d156f6f26ac0d29c38ae8d5e3d513741439e6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -99,6 +99,7 @@ pub fn provide(providers: &mut Providers) {\n         trait_def,\n         adt_def,\n         impl_trait_ref,\n+        is_foreign_item,\n         ..*providers\n     };\n }\n@@ -1530,3 +1531,13 @@ fn compute_type_of_foreign_fn_decl<'a, 'tcx>(\n     let substs = Substs::identity_for_item(tcx, def_id);\n     tcx.mk_fn_def(def_id, substs, fty)\n }\n+\n+fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             def_id: DefId)\n+                             -> bool {\n+    match tcx.hir.get_if_local(def_id) {\n+        Some(hir_map::NodeForeignItem(..)) => true,\n+        Some(_) => false,\n+        _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id)\n+    }\n+}"}, {"sha": "1baf0d1b54ce1f7530dd6ab9736134be4661c80d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -152,6 +152,7 @@ fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n enum PrevTokenKind {\n     DocComment,\n     Comma,\n+    Plus,\n     Interpolated,\n     Eof,\n     Other,\n@@ -1061,6 +1062,7 @@ impl<'a> Parser<'a> {\n         self.prev_token_kind = match self.token {\n             token::DocComment(..) => PrevTokenKind::DocComment,\n             token::Comma => PrevTokenKind::Comma,\n+            token::BinOp(token::Plus) => PrevTokenKind::Plus,\n             token::Interpolated(..) => PrevTokenKind::Interpolated,\n             token::Eof => PrevTokenKind::Eof,\n             _ => PrevTokenKind::Other,\n@@ -1354,20 +1356,26 @@ impl<'a> Parser<'a> {\n                     break;\n                 }\n             }\n+            let trailing_plus = self.prev_token_kind == PrevTokenKind::Plus;\n             self.expect(&token::CloseDelim(token::Paren))?;\n \n             if ts.len() == 1 && !last_comma {\n                 let ty = ts.into_iter().nth(0).unwrap().unwrap();\n+                let maybe_bounds = allow_plus && self.token == token::BinOp(token::Plus);\n                 match ty.node {\n-                    // Accept `(Trait1) + Trait2 + 'a` for backward compatibility (#39318).\n-                    TyKind::Path(None, ref path)\n-                            if allow_plus && self.token == token::BinOp(token::Plus) => {\n-                        self.bump(); // `+`\n-                        let pt = PolyTraitRef::new(Vec::new(), path.clone(), lo.to(self.prev_span));\n-                        let mut bounds = vec![TraitTyParamBound(pt, TraitBoundModifier::None)];\n-                        bounds.append(&mut self.parse_ty_param_bounds()?);\n-                        TyKind::TraitObject(bounds)\n+                    // `(TY_BOUND_NOPAREN) + BOUND + ...`.\n+                    TyKind::Path(None, ref path) if maybe_bounds => {\n+                        self.parse_remaining_bounds(Vec::new(), path.clone(), lo, true)?\n                     }\n+                    TyKind::TraitObject(ref bounds)\n+                            if maybe_bounds && bounds.len() == 1 && !trailing_plus => {\n+                        let path = match bounds[0] {\n+                            TraitTyParamBound(ref pt, ..) => pt.trait_ref.path.clone(),\n+                            _ => self.bug(\"unexpected lifetime bound\"),\n+                        };\n+                        self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n+                    }\n+                    // `(TYPE)`\n                     _ => TyKind::Paren(P(ty))\n                 }\n             } else {\n@@ -1418,11 +1426,8 @@ impl<'a> Parser<'a> {\n                 // Just a type path or bound list (trait object type) starting with a trait.\n                 //   `Type`\n                 //   `Trait1 + Trait2 + 'a`\n-                if allow_plus && self.eat(&token::BinOp(token::Plus)) {\n-                    let poly_trait = PolyTraitRef::new(Vec::new(), path, lo.to(self.prev_span));\n-                    let mut bounds = vec![TraitTyParamBound(poly_trait, TraitBoundModifier::None)];\n-                    bounds.append(&mut self.parse_ty_param_bounds()?);\n-                    TyKind::TraitObject(bounds)\n+                if allow_plus && self.check(&token::BinOp(token::Plus)) {\n+                    self.parse_remaining_bounds(Vec::new(), path, lo, true)?\n                 } else {\n                     TyKind::Path(None, path)\n                 }\n@@ -1440,12 +1445,8 @@ impl<'a> Parser<'a> {\n                 self.parse_ty_bare_fn(lifetime_defs)?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;\n-                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n-                let mut bounds = vec![TraitTyParamBound(poly_trait, TraitBoundModifier::None)];\n-                if allow_plus && self.eat(&token::BinOp(token::Plus)) {\n-                    bounds.append(&mut self.parse_ty_param_bounds()?)\n-                }\n-                TyKind::TraitObject(bounds)\n+                let parse_plus = allow_plus && self.check(&token::BinOp(token::Plus));\n+                self.parse_remaining_bounds(lifetime_defs, path, lo, parse_plus)?\n             }\n         } else if self.eat_keyword(keywords::Impl) {\n             // FIXME: figure out priority of `+` in `impl Trait1 + Trait2` (#34511).\n@@ -1468,6 +1469,17 @@ impl<'a> Parser<'a> {\n         Ok(P(ty))\n     }\n \n+    fn parse_remaining_bounds(&mut self, lifetime_defs: Vec<LifetimeDef>, path: ast::Path,\n+                              lo: Span, parse_plus: bool) -> PResult<'a, TyKind> {\n+        let poly_trait_ref = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n+        let mut bounds = vec![TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)];\n+        if parse_plus {\n+            self.bump(); // `+`\n+            bounds.append(&mut self.parse_ty_param_bounds()?);\n+        }\n+        Ok(TyKind::TraitObject(bounds))\n+    }\n+\n     fn maybe_recover_from_bad_type_plus(&mut self, allow_plus: bool, ty: &Ty) -> PResult<'a, ()> {\n         // Do not add `+` to expected tokens.\n         if !allow_plus || self.token != token::BinOp(token::Plus) {\n@@ -4070,28 +4082,43 @@ impl<'a> Parser<'a> {\n     // Parse bounds of a type parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n     // BOUND = TY_BOUND | LT_BOUND\n     // LT_BOUND = LIFETIME (e.g. `'a`)\n-    // TY_BOUND = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g. `?for<'a: 'b> m::Trait<'a>`)\n+    // TY_BOUND = TY_BOUND_NOPAREN | (TY_BOUND_NOPAREN)\n+    // TY_BOUND_NOPAREN = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g. `?for<'a: 'b> m::Trait<'a>`)\n     fn parse_ty_param_bounds_common(&mut self, allow_plus: bool) -> PResult<'a, TyParamBounds> {\n         let mut bounds = Vec::new();\n         loop {\n-            let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n-            if self.check_lifetime() {\n-                if let Some(question_span) = question {\n-                    self.span_err(question_span,\n-                                  \"`?` may only modify trait bounds, not lifetime bounds\");\n-                }\n-                bounds.push(RegionTyParamBound(self.expect_lifetime()));\n-            } else if self.check_keyword(keywords::For) || self.check_path() {\n-                let lo = self.span;\n-                let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-                let path = self.parse_path(PathStyle::Type)?;\n-                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n-                let modifier = if question.is_some() {\n-                    TraitBoundModifier::Maybe\n+            let is_bound_start = self.check_path() || self.check_lifetime() ||\n+                                 self.check(&token::Question) ||\n+                                 self.check_keyword(keywords::For) ||\n+                                 self.check(&token::OpenDelim(token::Paren));\n+            if is_bound_start {\n+                let has_parens = self.eat(&token::OpenDelim(token::Paren));\n+                let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n+                if self.token.is_lifetime() {\n+                    if let Some(question_span) = question {\n+                        self.span_err(question_span,\n+                                      \"`?` may only modify trait bounds, not lifetime bounds\");\n+                    }\n+                    bounds.push(RegionTyParamBound(self.expect_lifetime()));\n                 } else {\n-                    TraitBoundModifier::None\n-                };\n-                bounds.push(TraitTyParamBound(poly_trait, modifier));\n+                    let lo = self.span;\n+                    let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+                    let path = self.parse_path(PathStyle::Type)?;\n+                    let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo.to(self.prev_span));\n+                    let modifier = if question.is_some() {\n+                        TraitBoundModifier::Maybe\n+                    } else {\n+                        TraitBoundModifier::None\n+                    };\n+                    bounds.push(TraitTyParamBound(poly_trait, modifier));\n+                }\n+                if has_parens {\n+                    self.expect(&token::CloseDelim(token::Paren))?;\n+                    if let Some(&RegionTyParamBound(..)) = bounds.last() {\n+                        self.span_err(self.prev_span,\n+                                      \"parenthesized lifetime bounds are not supported\");\n+                    }\n+                }\n             } else {\n                 break\n             }"}, {"sha": "9dde5268c0878b0f0caa475b9bdc2635cc38b097", "filename": "src/test/parse-fail/bound-single-question-mark.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Ftest%2Fparse-fail%2Fbound-single-question-mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Ftest%2Fparse-fail%2Fbound-single-question-mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbound-single-question-mark.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn f<T: ?>() {} //~ ERROR expected identifier, found `>`"}, {"sha": "a44c0c3f32fef0b46b8d3f4e8b6f697cb9abd6ca", "filename": "src/test/parse-fail/trait-object-bad-parens.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Ftest%2Fparse-fail%2Ftrait-object-bad-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Ftest%2Fparse-fail%2Ftrait-object-bad-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-object-bad-parens.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n+\n+fn main() {\n+    let _: Box<((Copy)) + Copy>;\n+    //~^ ERROR expected a path on the left-hand side of `+`, not `((Copy))`\n+    let _: Box<(Copy + Copy) + Copy>;\n+    //~^ ERROR expected a path on the left-hand side of `+`, not `( Copy + Copy)`\n+    let _: Box<(Copy +) + Copy>;\n+    //~^ ERROR expected a path on the left-hand side of `+`, not `( Copy)`\n+}"}, {"sha": "6be62d966eb9490232aaeacb5c71713db222cdba", "filename": "src/test/parse-fail/trait-object-lifetime-parens.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Ftest%2Fparse-fail%2Ftrait-object-lifetime-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Ftest%2Fparse-fail%2Ftrait-object-lifetime-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-object-lifetime-parens.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n+\n+fn f<T: Copy + ('a)>() {} //~ ERROR parenthesized lifetime bounds are not supported\n+\n+fn main() {\n+    let _: Box<Copy + ('a)>; //~ ERROR parenthesized lifetime bounds are not supported\n+    let _: Box<('a) + Copy>; //~ ERROR expected type, found `'a`\n+}"}, {"sha": "dc44f4f3fb1353db6bd3acad024a71655ffc528c", "filename": "src/test/parse-fail/trait-object-trait-parens.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Ftest%2Fparse-fail%2Ftrait-object-trait-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc77d7690fc723b264962a4d01a6221be87d80e/src%2Ftest%2Fparse-fail%2Ftrait-object-trait-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-object-trait-parens.rs?ref=9cc77d7690fc723b264962a4d01a6221be87d80e", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+fn f<T: (Copy) + (?Sized) + (for<'a> Trait<'a>)>() {}\n+\n+fn main() {\n+    let _: Box<(Copy) + (?Sized) + (for<'a> Trait<'a>)>;\n+    let _: Box<(?Sized) + (for<'a> Trait<'a>) + (Copy)>;\n+    let _: Box<(for<'a> Trait<'a>) + (Copy) + (?Sized)>;\n+}\n+\n+FAIL //~ ERROR"}]}