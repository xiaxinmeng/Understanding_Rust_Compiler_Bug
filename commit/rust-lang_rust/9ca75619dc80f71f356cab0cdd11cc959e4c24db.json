{"sha": "9ca75619dc80f71f356cab0cdd11cc959e4c24db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYTc1NjE5ZGM4MGY3MWYzNTZjYWIwY2RkMTFjYzk1OWU0YzI0ZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-15T00:55:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-15T00:55:41Z"}, "message": "Auto merge of #30652 - aturon:specialization, r=nikomatsakis\n\nImplement RFC 1210: impl specialization\n\nThis PR implements [impl specialization](https://github.com/rust-lang/rfcs/pull/1210),\ncarefully following the proposal laid out in the RFC.\n\nThe implementation covers the bulk of the RFC. The remaining gaps I know of are:\n\n- no checking for lifetime-dependent specialization (a soundness hole);\n- no `default impl` yet;\n- no support for `default` with associated consts;\n\nI plan to cover these gaps in follow-up PRs, as per @nikomatsakis's preference.\n\nThe basic strategy is to build up a *specialization graph* during\ncoherence checking. Insertion into the graph locates the right place\nto put an impl in the specialization hierarchy; if there is no right\nplace (due to partial overlap but no containment), you get an overlap\nerror. Specialization is consulted when selecting an impl (of course),\nand the graph is consulted when propagating defaults down the\nspecialization hierarchy.\n\nYou might expect that the specialization graph would be used during\nselection -- i.e., when actually performing specialization. This is\nnot done for two reasons:\n\n- It's merely an optimization: given a set of candidates that apply,\n  we can determine the most specialized one by comparing them directly\n  for specialization, rather than consulting the graph. Given that we\n  also cache the results of selection, the benefit of this\n  optimization is questionable.\n\n- To build the specialization graph in the first place, we need to use\n  selection (because we need to determine whether one impl specializes\n  another). Dealing with this reentrancy would require some additional\n  mode switch for selection. Given that there seems to be no strong\n  reason to use the graph anyway, we stick with a simpler approach in\n  selection, and use the graph only for propagating default\n  implementations.\n\nTrait impl selection can succeed even when multiple impls can apply,\nas long as they are part of the same specialization family. In that\ncase, it returns a *single* impl on success -- this is the most\nspecialized impl *known* to apply. However, if there are any inference\nvariables in play, the returned impl may not be the actual impl we\nwill use at trans time. Thus, we take special care to avoid projecting\nassociated types unless either (1) the associated type does not use\n`default` and thus cannot be overridden or (2) all input types are\nknown concretely.\n\nr? @nikomatsakis", "tree": {"sha": "2b3d421cd75d435b7ddb4ea2f1a1e089195a12e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b3d421cd75d435b7ddb4ea2f1a1e089195a12e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ca75619dc80f71f356cab0cdd11cc959e4c24db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ca75619dc80f71f356cab0cdd11cc959e4c24db", "html_url": "https://github.com/rust-lang/rust/commit/9ca75619dc80f71f356cab0cdd11cc959e4c24db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ca75619dc80f71f356cab0cdd11cc959e4c24db/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d215fe04ce3f638d717d7fcea95c40d0a655ff9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d215fe04ce3f638d717d7fcea95c40d0a655ff9", "html_url": "https://github.com/rust-lang/rust/commit/6d215fe04ce3f638d717d7fcea95c40d0a655ff9"}, {"sha": "6562eeb05396be4ee4d4f413ac3e0f9f1afcc536", "url": "https://api.github.com/repos/rust-lang/rust/commits/6562eeb05396be4ee4d4f413ac3e0f9f1afcc536", "html_url": "https://github.com/rust-lang/rust/commit/6562eeb05396be4ee4d4f413ac3e0f9f1afcc536"}], "stats": {"total": 3649, "additions": 3029, "deletions": 620}, "files": [{"sha": "ece5819829baa67b05adbca4f30a3375dfeda7a7", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -51,7 +51,7 @@ could invalidate work done for other items. So, for example:\n    not shared state, because if it changes it does not itself\n    invalidate other functions (though it may be that it causes new\n    monomorphizations to occur, but that's handled independently).\n-   \n+\n Put another way: if the HIR for an item changes, we are going to\n recompile that item for sure. But we need the dep tracking map to tell\n us what *else* we have to recompile. Shared state is anything that is\n@@ -177,7 +177,7 @@ reads from `item`, there would be missing edges in the graph:\n       |                                 ^\n       |                                 |\n       +---------------------------------+ // added by `visit_all_items_in_krate`\n-    \n+\n In particular, the edge from `Hir(X)` to `ItemSignature(X)` is only\n present because we called `read` ourselves when entering the `ItemSignature(X)`\n task.\n@@ -273,8 +273,8 @@ should not exist.  In contrast, using the memoized helper, you get:\n     ... -> MapVariant(key) -> A\n                  |\n                  +----------> B\n-                 \n-which is much cleaner.                 \n+\n+which is much cleaner.\n \n **Be aware though that the closure is executed with `MapVariant(key)`\n pushed onto the stack as the current task!** That means that you must\n@@ -387,4 +387,3 @@ RUST_DEP_GRAPH_FILTER='Hir&foo -> TypeckItemBody & bar'\n This will dump out all the nodes that lead from `Hir(foo)` to\n `TypeckItemBody(bar)`, from which you can (hopefully) see the source\n of the erroneous edge.\n-"}, {"sha": "89b57e0d90a007031169310e143c2d72d4c0bc6b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -25,6 +25,7 @@ use middle::expr_use_visitor as euv;\n use middle::infer;\n use middle::mem_categorization::{cmt};\n use middle::pat_util::*;\n+use middle::traits::ProjectionMode;\n use middle::ty::*;\n use middle::ty;\n use std::cmp::Ordering;\n@@ -1101,7 +1102,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                         //FIXME: (@jroesch) this code should be floated up as well\n                         let infcx = infer::new_infer_ctxt(cx.tcx,\n                                                           &cx.tcx.tables,\n-                                                          Some(cx.param_env.clone()));\n+                                                          Some(cx.param_env.clone()),\n+                                                          ProjectionMode::AnyFinal);\n                         if infcx.type_moves_by_default(pat_ty, pat.span) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n@@ -1133,7 +1135,8 @@ fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n \n     let infcx = infer::new_infer_ctxt(cx.tcx,\n                                       &cx.tcx.tables,\n-                                      Some(checker.cx.param_env.clone()));\n+                                      Some(checker.cx.param_env.clone()),\n+                                      ProjectionMode::AnyFinal);\n \n     let mut visitor = ExprUseVisitor::new(&mut checker, &infcx);\n     visitor.walk_expr(guard);"}, {"sha": "8a1a0080eb0c27adf0d8c293fca452342cdd2a2e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -24,6 +24,7 @@ use middle::def_id::DefId;\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::ty::util::IntTypeExt;\n+use middle::traits::ProjectionMode;\n use middle::astconv_util::ast_ty_to_prim_ty;\n use util::nodemap::NodeMap;\n \n@@ -1049,7 +1050,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n            trait_ref);\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n \n     let mut selcx = traits::SelectionContext::new(&infcx);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n@@ -1067,6 +1068,11 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n         }\n     };\n \n+    // NOTE: this code does not currently account for specialization, but when\n+    // it does so, it should hook into the ProjectionMode to determine when the\n+    // constant should resolve; this will also require plumbing through to this\n+    // function whether we are in \"trans mode\" to pick the right ProjectionMode\n+    // when constructing the inference context above.\n     match selection {\n         traits::VtableImpl(ref impl_data) => {\n             match tcx.associated_consts(impl_data.impl_def_id)"}, {"sha": "6a4680ecbaf31a082b4d44b251319afc02e7b792", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -176,6 +176,7 @@ pub trait CrateStore<'tcx> : Any {\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>;\n     fn associated_consts(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n                          -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n+    fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n     fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n@@ -346,6 +347,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         { unimplemented!() }\n     fn associated_consts(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n                          -> Vec<Rc<ty::AssociatedConst<'tcx>>> { unimplemented!() }\n+    fn impl_parent(&self, def: DefId) -> Option<DefId> { unimplemented!() }\n \n     // trait/impl-item info\n     fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)"}, {"sha": "4ff1de422117b2852576828f49634cd790dfc7f5", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -27,7 +27,7 @@ use middle::region::CodeExtent;\n use middle::subst;\n use middle::subst::Substs;\n use middle::subst::Subst;\n-use middle::traits;\n+use middle::traits::{self, ProjectionMode};\n use middle::ty::adjustment;\n use middle::ty::{TyVid, IntVid, FloatVid};\n use middle::ty::{self, Ty, TyCtxt};\n@@ -99,6 +99,11 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n     // directly.\n     normalize: bool,\n \n+    // Sadly, the behavior of projection varies a bit depending on the\n+    // stage of compilation. The specifics are given in the\n+    // documentation for `ProjectionMode`.\n+    projection_mode: ProjectionMode,\n+\n     err_count_on_creation: usize,\n }\n \n@@ -354,7 +359,8 @@ pub fn fixup_err_to_string(f: FixupError) -> String {\n \n pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a TyCtxt<'tcx>,\n                                 tables: &'a RefCell<ty::Tables<'tcx>>,\n-                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>)\n+                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>,\n+                                projection_mode: ProjectionMode)\n                                 -> InferCtxt<'a, 'tcx> {\n     InferCtxt {\n         tcx: tcx,\n@@ -366,14 +372,16 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a TyCtxt<'tcx>,\n         parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n         reported_trait_errors: RefCell::new(FnvHashSet()),\n         normalize: false,\n+        projection_mode: projection_mode,\n         err_count_on_creation: tcx.sess.err_count()\n     }\n }\n \n pub fn normalizing_infer_ctxt<'a, 'tcx>(tcx: &'a TyCtxt<'tcx>,\n-                                        tables: &'a RefCell<ty::Tables<'tcx>>)\n+                                        tables: &'a RefCell<ty::Tables<'tcx>>,\n+                                        projection_mode: ProjectionMode)\n                                         -> InferCtxt<'a, 'tcx> {\n-    let mut infcx = new_infer_ctxt(tcx, tables, None);\n+    let mut infcx = new_infer_ctxt(tcx, tables, None, projection_mode);\n     infcx.normalize = true;\n     infcx\n }\n@@ -514,6 +522,7 @@ pub struct CombinedSnapshot {\n     region_vars_snapshot: RegionSnapshot,\n }\n \n+// NOTE: Callable from trans only!\n pub fn normalize_associated_type<'tcx,T>(tcx: &TyCtxt<'tcx>, value: &T) -> T\n     where T : TypeFoldable<'tcx>\n {\n@@ -525,7 +534,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &TyCtxt<'tcx>, value: &T) -> T\n         return value;\n     }\n \n-    let infcx = new_infer_ctxt(tcx, &tcx.tables, None);\n+    let infcx = new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::Any);\n     let mut selcx = traits::SelectionContext::new(&infcx);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: result, obligations } =\n@@ -593,6 +602,10 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    pub fn projection_mode(&self) -> ProjectionMode {\n+        self.projection_mode\n+    }\n+\n     pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n     }\n@@ -1025,8 +1038,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                               substs: &mut Substs<'tcx>,\n                               defs: &[ty::TypeParameterDef<'tcx>]) {\n \n-        let mut vars = Vec::with_capacity(defs.len());\n-\n         for def in defs.iter() {\n             let default = def.default.map(|default| {\n                 type_variable::Default {\n@@ -1038,7 +1049,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             let ty_var = self.next_ty_var_with_default(default);\n             substs.types.push(space, ty_var);\n-            vars.push(ty_var)\n         }\n     }\n "}, {"sha": "510a3dd454b95fcf3307ae9d0d065c9f2fc0b6b9", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -160,6 +160,15 @@ impl<'tcx> Substs<'tcx> {\n         Substs { types: types, regions: regions }\n     }\n \n+    pub fn with_method_from_subst(self, other: &Substs<'tcx>) -> Substs<'tcx> {\n+        let Substs { types, regions } = self;\n+        let types = types.with_slice(FnSpace, other.types.get_slice(FnSpace));\n+        let regions = regions.map(|r| {\n+            r.with_slice(FnSpace, other.regions().get_slice(FnSpace))\n+        });\n+        Substs { types: types, regions: regions }\n+    }\n+\n     /// Creates a trait-ref out of this substs, ignoring the FnSpace substs\n     pub fn to_trait_ref(&self, tcx: &TyCtxt<'tcx>, trait_id: DefId)\n                         -> ty::TraitRef<'tcx> {"}, {"sha": "ff72f9dd07e36096819e2244644099a136cc63c4", "filename": "src/librustc/middle/traits/README.md", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -428,3 +428,43 @@ We used to try and draw finer-grained distinctions, but that led to a\n serious of annoying and weird bugs like #22019 and #18290. This simple\n rule seems to be pretty clearly safe and also still retains a very\n high hit rate (~95% when compiling rustc).\n+\n+# Specialization\n+\n+Defined in the `specialize` module.\n+\n+The basic strategy is to build up a *specialization graph* during\n+coherence checking. Insertion into the graph locates the right place\n+to put an impl in the specialization hierarchy; if there is no right\n+place (due to partial overlap but no containment), you get an overlap\n+error. Specialization is consulted when selecting an impl (of course),\n+and the graph is consulted when propagating defaults down the\n+specialization hierarchy.\n+\n+You might expect that the specialization graph would be used during\n+selection -- i.e., when actually performing specialization. This is\n+not done for two reasons:\n+\n+- It's merely an optimization: given a set of candidates that apply,\n+  we can determine the most specialized one by comparing them directly\n+  for specialization, rather than consulting the graph. Given that we\n+  also cache the results of selection, the benefit of this\n+  optimization is questionable.\n+\n+- To build the specialization graph in the first place, we need to use\n+  selection (because we need to determine whether one impl specializes\n+  another). Dealing with this reentrancy would require some additional\n+  mode switch for selection. Given that there seems to be no strong\n+  reason to use the graph anyway, we stick with a simpler approach in\n+  selection, and use the graph only for propagating default\n+  implementations.\n+\n+Trait impl selection can succeed even when multiple impls can apply,\n+as long as they are part of the same specialization family. In that\n+case, it returns a *single* impl on success -- this is the most\n+specialized impl *known* to apply. However, if there are any inference\n+variables in play, the returned impl may not be the actual impl we\n+will use at trans time. Thus, we take special care to avoid projecting\n+associated types unless either (1) the associated type does not use\n+`default` and thus cannot be overridden or (2) all input types are\n+known concretely."}, {"sha": "64d1c992cbf1d475928d82c2a49a6720abdf946b", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -10,8 +10,7 @@\n \n //! See `README.md` for high-level documentation\n \n-use super::{SelectionContext};\n-use super::{Obligation, ObligationCause};\n+use super::{SelectionContext, Obligation, ObligationCause};\n \n use middle::cstore::LOCAL_CRATE;\n use middle::def_id::DefId;\n@@ -23,8 +22,8 @@ use syntax::codemap::DUMMY_SP;\n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n \n-/// If there are types that satisfy both impls, returns an `ImplTy`\n-/// with those types substituted (by updating the given `infcx`)\n+/// If there are types that satisfy both impls, returns a suitably-freshened\n+/// `ImplHeader` with those types substituted\n pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n                                     impl1_def_id: DefId,\n                                     impl2_def_id: DefId)"}, {"sha": "5f66e9e6344ad76d6034043ca1d9047c12c4b0de", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -36,20 +36,18 @@ pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n-pub use self::project::MismatchedProjectionTypes;\n-pub use self::project::normalize;\n-pub use self::project::Normalized;\n+pub use self::project::{MismatchedProjectionTypes, ProjectionMode};\n+pub use self::project::{normalize, Normalized};\n pub use self::object_safety::is_object_safe;\n pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::object_safety_violations;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::is_vtable_safe_method;\n-pub use self::select::EvaluationCache;\n-pub use self::select::SelectionContext;\n-pub use self::select::SelectionCache;\n+pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n+pub use self::specialize::{Overlap, specialization_graph, specializes, translate_substs};\n pub use self::util::elaborate_predicates;\n pub use self::util::get_vtable_index_of_object_method;\n pub use self::util::trait_ref_for_builtin_bound;\n@@ -67,6 +65,7 @@ mod fulfill;\n mod project;\n mod object_safety;\n mod select;\n+mod specialize;\n mod structural_impls;\n mod util;\n \n@@ -434,7 +433,10 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env));\n+    let infcx = infer::new_infer_ctxt(tcx,\n+                                      &tcx.tables,\n+                                      Some(elaborated_env),\n+                                      ProjectionMode::AnyFinal);\n     let predicates = match fully_normalize(&infcx,\n                                            cause,\n                                            &infcx.parameter_environment.caller_bounds) {"}, {"sha": "e86f3ed01a49d6c8ceb0558259edc58072983417", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 214, "deletions": 33, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -12,6 +12,8 @@\n \n use super::elaborate_predicates;\n use super::report_overflow_error;\n+use super::specialization_graph;\n+use super::translate_substs;\n use super::Obligation;\n use super::ObligationCause;\n use super::PredicateObligation;\n@@ -21,13 +23,103 @@ use super::VtableClosureData;\n use super::VtableImplData;\n use super::util;\n \n+use middle::def_id::DefId;\n use middle::infer::{self, TypeOrigin};\n use middle::subst::Subst;\n use middle::ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use middle::ty::fold::{TypeFoldable, TypeFolder};\n use syntax::parse::token;\n+use syntax::ast;\n use util::common::FN_OUTPUT_NAME;\n \n+use std::rc::Rc;\n+\n+/// Depending on the stage of compilation, we want projection to be\n+/// more or less conservative.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum ProjectionMode {\n+    /// FIXME (#32205)\n+    /// At coherence-checking time, we're still constructing the\n+    /// specialization graph, and thus we only project project\n+    /// non-`default` associated types that are defined directly in\n+    /// the applicable impl. (This behavior should be improved over\n+    /// time, to allow for successful projections modulo cycles\n+    /// between different impls).\n+    ///\n+    /// Here's an example that will fail due to the restriction:\n+    ///\n+    /// ```\n+    /// trait Assoc {\n+    ///     type Output;\n+    /// }\n+    ///\n+    /// impl<T> Assoc for T {\n+    ///     type Output = bool;\n+    /// }\n+    ///\n+    /// impl Assoc for u8 {} // <- inherits the non-default type from above\n+    ///\n+    /// trait Foo {}\n+    /// impl Foo for u32 {}\n+    /// impl Foo for <u8 as Assoc>::Output {}  // <- this projection will fail\n+    /// ```\n+    ///\n+    /// The projection would succeed if `Output` had been defined\n+    /// directly in the impl for `u8`.\n+    Topmost,\n+\n+    /// At type-checking time, we refuse to project any associated\n+    /// type that is marked `default`. Non-`default` (\"final\") types\n+    /// are always projected. This is necessary in general for\n+    /// soundness of specialization. However, we *could* allow\n+    /// projections in fully-monomorphic cases. We choose not to,\n+    /// because we prefer for `default type` to force the type\n+    /// definition to be treated abstractly by any consumers of the\n+    /// impl. Concretely, that means that the following example will\n+    /// fail to compile:\n+    ///\n+    /// ```\n+    /// trait Assoc {\n+    ///     type Output;\n+    /// }\n+    ///\n+    /// impl<T> Assoc for T {\n+    ///     default type Output = bool;\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let <() as Assoc>::Output = true;\n+    /// }\n+    AnyFinal,\n+\n+    /// At trans time, all projections will succeed.\n+    Any,\n+}\n+\n+impl ProjectionMode {\n+    pub fn is_topmost(&self) -> bool {\n+        match *self {\n+            ProjectionMode::Topmost => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_any_final(&self) -> bool {\n+        match *self {\n+            ProjectionMode::AnyFinal => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_any(&self) -> bool {\n+        match *self {\n+            ProjectionMode::Any => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+\n pub type PolyProjectionObligation<'tcx> =\n     Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n \n@@ -566,7 +658,76 @@ fn project_type<'cx,'tcx>(\n \n     assert!(candidates.vec.len() <= 1);\n \n-    match candidates.vec.pop() {\n+    let possible_candidate = candidates.vec.pop().and_then(|candidate| {\n+        // In Any (i.e. trans) mode, all projections succeed;\n+        // otherwise, we need to be sensitive to `default` and\n+        // specialization.\n+        if !selcx.projection_mode().is_any() {\n+            if let ProjectionTyCandidate::Impl(ref impl_data) = candidate {\n+                if let Some(node_item) = assoc_ty_def(selcx,\n+                                                      impl_data.impl_def_id,\n+                                                      obligation.predicate.item_name) {\n+                    if node_item.node.is_from_trait() {\n+                        if node_item.item.ty.is_some() {\n+                            // If the associated type has a default from the\n+                            // trait, that should be considered `default` and\n+                            // hence not projected.\n+                            //\n+                            // Note, however, that we allow a projection from\n+                            // the trait specifically in the case that the trait\n+                            // does *not* give a default. This is purely to\n+                            // avoid spurious errors: the situation can only\n+                            // arise when *no* impl in the specialization chain\n+                            // has provided a definition for the type. When we\n+                            // confirm the candidate, we'll turn the projection\n+                            // into a TyError, since the actual error will be\n+                            // reported in `check_impl_items_against_trait`.\n+                            return None;\n+                        }\n+                    } else if node_item.item.defaultness.is_default() {\n+                        return None;\n+                    }\n+                } else {\n+                    // Normally this situation could only arise througha\n+                    // compiler bug, but at coherence-checking time we only look\n+                    // at the topmost impl (we don't even consider the trait\n+                    // itself) for the definition -- so we can fail to find a\n+                    // definition of the type even if it exists.\n+\n+                    // For now, we just unconditionally ICE, because otherwise,\n+                    // examples like the following will succeed:\n+                    //\n+                    // ```\n+                    // trait Assoc {\n+                    //     type Output;\n+                    // }\n+                    //\n+                    // impl<T> Assoc for T {\n+                    //     default type Output = bool;\n+                    // }\n+                    //\n+                    // impl Assoc for u8 {}\n+                    // impl Assoc for u16 {}\n+                    //\n+                    // trait Foo {}\n+                    // impl Foo for <u8 as Assoc>::Output {}\n+                    // impl Foo for <u16 as Assoc>::Output {}\n+                    //     return None;\n+                    // }\n+                    // ```\n+                    //\n+                    // The essential problem here is that the projection fails,\n+                    // leaving two unnormalized types, which appear not to unify\n+                    // -- so the overlap check succeeds, when it should fail.\n+                    selcx.tcx().sess.bug(\"Tried to project an inherited associated type during \\\n+                                          coherence checking, which is currently not supported.\");\n+                }\n+            }\n+        }\n+        Some(candidate)\n+    });\n+\n+    match possible_candidate {\n         Some(candidate) => {\n             let (ty, obligations) = confirm_candidate(selcx, obligation, candidate);\n             Ok(ProjectedTy::Progress(ty, obligations))\n@@ -941,43 +1102,63 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n-    // there don't seem to be nicer accessors to these:\n-    let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n-\n-    // Look for the associated type in the impl\n-    for impl_item in &selcx.tcx().impl_items.borrow()[&impl_vtable.impl_def_id] {\n-        if let ty::TypeTraitItem(ref assoc_ty) = impl_or_trait_items_map[&impl_item.def_id()] {\n-            if assoc_ty.name == obligation.predicate.item_name {\n-                return (assoc_ty.ty.unwrap().subst(selcx.tcx(), impl_vtable.substs),\n-                        impl_vtable.nested);\n-            }\n+    let VtableImplData { substs, nested, impl_def_id } = impl_vtable;\n+\n+    let tcx = selcx.tcx();\n+    let trait_ref = obligation.predicate.trait_ref;\n+    let assoc_ty = assoc_ty_def(selcx, impl_def_id, obligation.predicate.item_name);\n+\n+    match assoc_ty {\n+        Some(node_item) => {\n+            let ty = node_item.item.ty.unwrap_or_else(|| {\n+                // This means that the impl is missing a definition for the\n+                // associated type. This error will be reported by the type\n+                // checker method `check_impl_items_against_trait`, so here we\n+                // just return TyError.\n+                debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n+                       node_item.item.name,\n+                       obligation.predicate.trait_ref);\n+                tcx.types.err\n+            });\n+            let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n+            (ty.subst(tcx, substs), nested)\n+        }\n+        None => {\n+            tcx.sess.span_bug(obligation.cause.span,\n+                              &format!(\"No associated type for {:?}\", trait_ref));\n         }\n     }\n+}\n \n-    // It is not in the impl - get the default from the trait.\n-    let trait_ref = obligation.predicate.trait_ref;\n-    for trait_item in selcx.tcx().trait_items(trait_ref.def_id).iter() {\n-        if let &ty::TypeTraitItem(ref assoc_ty) = trait_item {\n-            if assoc_ty.name == obligation.predicate.item_name {\n-                if let Some(ty) = assoc_ty.ty {\n-                    return (ty.subst(selcx.tcx(), trait_ref.substs),\n-                            impl_vtable.nested);\n-                } else {\n-                    // This means that the impl is missing a\n-                    // definition for the associated type. This error\n-                    // ought to be reported by the type checker method\n-                    // `check_impl_items_against_trait`, so here we\n-                    // just return TyError.\n-                    debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n-                           assoc_ty.name,\n-                           trait_ref);\n-                    return (selcx.tcx().types.err, vec!());\n+/// Locate the definition of an associated type in the specialization hierarchy,\n+/// starting from the given impl.\n+///\n+/// Based on the \"projection mode\", this lookup may in fact only examine the\n+/// topmost impl. See the comments for `ProjectionMode` for more details.\n+fn assoc_ty_def<'cx, 'tcx>(selcx: &SelectionContext<'cx, 'tcx>,\n+                           impl_def_id: DefId,\n+                           assoc_ty_name: ast::Name)\n+                           -> Option<specialization_graph::NodeItem<Rc<ty::AssociatedType<'tcx>>>>\n+{\n+    let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n+\n+    if selcx.projection_mode().is_topmost() {\n+        let impl_node = specialization_graph::Node::Impl(impl_def_id);\n+        for item in impl_node.items(selcx.tcx()) {\n+            if let ty::TypeTraitItem(assoc_ty) = item {\n+                if assoc_ty.name == assoc_ty_name {\n+                    return Some(specialization_graph::NodeItem {\n+                        node: specialization_graph::Node::Impl(impl_def_id),\n+                        item: assoc_ty,\n+                    });\n                 }\n             }\n         }\n+        None\n+    } else {\n+        selcx.tcx().lookup_trait_def(trait_def_id)\n+            .ancestors(impl_def_id)\n+            .type_defs(selcx.tcx(), assoc_ty_name)\n+            .next()\n     }\n-\n-    selcx.tcx().sess.span_bug(obligation.cause.span,\n-                              &format!(\"No associated type for {:?}\",\n-                                       trait_ref));\n }"}, {"sha": "3ef163f225c4aa956c5a7abeab396c79448b7a59", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 81, "deletions": 46, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -25,6 +25,7 @@ use super::report_overflow_error;\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n use super::{ObjectCastObligation, Obligation};\n+use super::ProjectionMode;\n use super::TraitNotObjectSafe;\n use super::Selection;\n use super::SelectionResult;\n@@ -40,6 +41,7 @@ use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener, TypeOrigin};\n use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use middle::traits;\n use middle::ty::fast_reject;\n use middle::ty::relate::TypeRelation;\n \n@@ -75,7 +77,6 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n     /// other words, we consider `$0 : Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n-\n     intercrate: bool,\n }\n \n@@ -224,6 +225,12 @@ struct SelectionCandidateSet<'tcx> {\n     ambiguous: bool,\n }\n \n+#[derive(PartialEq,Eq,Debug,Clone)]\n+struct EvaluatedCandidate<'tcx> {\n+    candidate: SelectionCandidate<'tcx>,\n+    evaluation: EvaluationResult,\n+}\n+\n enum BuiltinBoundConditions<'tcx> {\n     If(ty::Binder<Vec<Ty<'tcx>>>),\n     ParameterBuiltin,\n@@ -251,17 +258,15 @@ pub struct EvaluationCache<'tcx> {\n }\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n-    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>)\n-               -> SelectionContext<'cx, 'tcx> {\n+    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n             intercrate: false,\n         }\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>)\n-                      -> SelectionContext<'cx, 'tcx> {\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n@@ -285,6 +290,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx\n     }\n \n+    pub fn projection_mode(&self) -> ProjectionMode {\n+        self.infcx.projection_mode()\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -558,7 +567,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // this crate, perhaps the type would be unified with\n         // something from another crate that does provide an impl.\n         //\n-        // In intracrate mode, we must still be conservative. The reason is\n+        // In intra mode, we must still be conservative. The reason is\n         // that we want to avoid cycles. Imagine an impl like:\n         //\n         //     impl<T:Eq> Eq for Vec<T>\n@@ -746,6 +755,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidate\n     }\n \n+    // Treat negative impls as unimplemented\n+    fn filter_negative_impls(&self, candidate: SelectionCandidate<'tcx>)\n+                             -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        if let ImplCandidate(def_id) = candidate {\n+            if self.tcx().trait_impl_polarity(def_id) == Some(hir::ImplPolarity::Negative) {\n+                return Err(Unimplemented)\n+            }\n+        }\n+        Ok(Some(candidate))\n+    }\n+\n     fn candidate_from_obligation_no_cache<'o>(&mut self,\n                                               stack: &TraitObligationStack<'o, 'tcx>)\n                                               -> SelectionResult<'tcx, SelectionCandidate<'tcx>>\n@@ -762,7 +782,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         if !self.is_knowable(stack) {\n-            debug!(\"intercrate not knowable\");\n+            debug!(\"coherence stage: not knowable\");\n             return Ok(None);\n         }\n \n@@ -803,12 +823,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // we were to winnow, we'd wind up with zero candidates.\n         // Instead, we select the right impl now but report `Bar does\n         // not implement Clone`.\n-        if candidates.len() > 1 {\n-            candidates.retain(|c| self.evaluate_candidate(stack, c).may_apply())\n-        }\n+        if candidates.len() == 1 {\n+            return self.filter_negative_impls(candidates.pop().unwrap());\n+        }\n+\n+        // Winnow, but record the exact outcome of evaluation, which\n+        // is needed for specialization.\n+        let mut candidates: Vec<_> = candidates.into_iter().filter_map(|c| {\n+            let eval = self.evaluate_candidate(stack, &c);\n+            if eval.may_apply() {\n+                Some(EvaluatedCandidate {\n+                    candidate: c,\n+                    evaluation: eval,\n+                })\n+            } else {\n+                None\n+            }\n+        }).collect();\n \n-        // If there are STILL multiple candidate, we can further reduce\n-        // the list by dropping duplicates.\n+        // If there are STILL multiple candidate, we can further\n+        // reduce the list by dropping duplicates -- including\n+        // resolving specializations.\n         if candidates.len() > 1 {\n             let mut i = 0;\n             while i < candidates.len() {\n@@ -836,8 +871,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(None);\n         }\n \n-\n-        // If there are *NO* candidates, that there are no impls --\n+        // If there are *NO* candidates, then there are no impls --\n         // that we know of, anyway. Note that in the case where there\n         // are unbound type variables within the obligation, it might\n         // be the case that you could still satisfy the obligation\n@@ -851,19 +885,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // Just one candidate left.\n-        let candidate = candidates.pop().unwrap();\n-\n-        match candidate {\n-            ImplCandidate(def_id) => {\n-                match self.tcx().trait_impl_polarity(def_id) {\n-                    Some(hir::ImplPolarity::Negative) => return Err(Unimplemented),\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        Ok(Some(candidate))\n+        self.filter_negative_impls(candidates.pop().unwrap().candidate)\n     }\n \n     fn is_knowable<'o>(&mut self,\n@@ -1565,41 +1587,54 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// candidates and prefer where-clause candidates.\n     ///\n     /// See the comment for \"SelectionCandidate\" for more details.\n-    fn candidate_should_be_dropped_in_favor_of<'o>(&mut self,\n-                                                   victim: &SelectionCandidate<'tcx>,\n-                                                   other: &SelectionCandidate<'tcx>)\n-                                                   -> bool\n+    fn candidate_should_be_dropped_in_favor_of<'o>(\n+        &mut self,\n+        victim: &EvaluatedCandidate<'tcx>,\n+        other: &EvaluatedCandidate<'tcx>)\n+        -> bool\n     {\n-        if victim == other {\n+        if victim.candidate == other.candidate {\n             return true;\n         }\n \n-        match other {\n-            &ObjectCandidate |\n-            &ParamCandidate(_) | &ProjectionCandidate => match victim {\n-                &DefaultImplCandidate(..) => {\n+        match other.candidate {\n+            ObjectCandidate |\n+            ParamCandidate(_) | ProjectionCandidate => match victim.candidate {\n+                DefaultImplCandidate(..) => {\n                     self.tcx().sess.bug(\n                         \"default implementations shouldn't be recorded \\\n                          when there are other valid candidates\");\n                 }\n-                &ImplCandidate(..) |\n-                &ClosureCandidate(..) |\n-                &FnPointerCandidate |\n-                &BuiltinObjectCandidate |\n-                &BuiltinUnsizeCandidate |\n-                &DefaultImplObjectCandidate(..) |\n-                &BuiltinCandidate(..) => {\n+                ImplCandidate(..) |\n+                ClosureCandidate(..) |\n+                FnPointerCandidate |\n+                BuiltinObjectCandidate |\n+                BuiltinUnsizeCandidate |\n+                DefaultImplObjectCandidate(..) |\n+                BuiltinCandidate(..) => {\n                     // We have a where-clause so don't go around looking\n                     // for impls.\n                     true\n                 }\n-                &ObjectCandidate |\n-                &ProjectionCandidate => {\n+                ObjectCandidate |\n+                ProjectionCandidate => {\n                     // Arbitrarily give param candidates priority\n                     // over projection and object candidates.\n                     true\n                 },\n-                &ParamCandidate(..) => false,\n+                ParamCandidate(..) => false,\n+            },\n+            ImplCandidate(other_def) => {\n+                // See if we can toss out `victim` based on specialization.\n+                // This requires us to know *for sure* that the `other` impl applies\n+                // i.e. EvaluatedToOk:\n+                if other.evaluation == EvaluatedToOk {\n+                    if let ImplCandidate(victim_def) = victim.candidate {\n+                        return traits::specializes(self.tcx(), other_def, victim_def);\n+                    }\n+                }\n+\n+                false\n             },\n             _ => false\n         }"}, {"sha": "a692fe55a77899e79d5b27a19b8b17280d39cbc0", "filename": "src/librustc/middle/traits/specialize/mod.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,229 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Logic and data structures related to impl specialization, explained in\n+// greater detail below.\n+//\n+// At the moment, this implementation support only the simple \"chain\" rule:\n+// If any two impls overlap, one must be a strict subset of the other.\n+//\n+// See traits/README.md for a bit more detail on how specialization\n+// fits together with the rest of the trait machinery.\n+\n+use super::{SelectionContext, FulfillmentContext};\n+use super::util::{fresh_type_vars_for_impl, impl_trait_ref_and_oblig};\n+\n+use middle::cstore::CrateStore;\n+use middle::def_id::DefId;\n+use middle::infer::{self, InferCtxt, TypeOrigin};\n+use middle::region;\n+use middle::subst::{Subst, Substs};\n+use middle::traits::{self, ProjectionMode, ObligationCause, Normalized};\n+use middle::ty::{self, TyCtxt};\n+use syntax::codemap::DUMMY_SP;\n+\n+pub mod specialization_graph;\n+\n+/// Information pertinent to an overlapping impl error.\n+pub struct Overlap<'a, 'tcx: 'a> {\n+    pub in_context: InferCtxt<'a, 'tcx>,\n+    pub with_impl: DefId,\n+    pub on_trait_ref: ty::TraitRef<'tcx>,\n+}\n+\n+/// Given a subst for the requested impl, translate it to a subst\n+/// appropriate for the actual item definition (whether it be in that impl,\n+/// a parent impl, or the trait).\n+/// When we have selected one impl, but are actually using item definitions from\n+/// a parent impl providing a default, we need a way to translate between the\n+/// type parameters of the two impls. Here the `source_impl` is the one we've\n+/// selected, and `source_substs` is a substitution of its generics (and\n+/// possibly some relevant `FnSpace` variables as well). And `target_node` is\n+/// the impl/trait we're actually going to get the definition from. The resulting\n+/// substitution will map from `target_node`'s generics to `source_impl`'s\n+/// generics as instantiated by `source_subst`.\n+///\n+/// For example, consider the following scenario:\n+///\n+/// ```rust\n+/// trait Foo { ... }\n+/// impl<T, U> Foo for (T, U) { ... }  // target impl\n+/// impl<V> Foo for (V, V) { ... }     // source impl\n+/// ```\n+///\n+/// Suppose we have selected \"source impl\" with `V` instantiated with `u32`.\n+/// This function will produce a substitution with `T` and `U` both mapping to `u32`.\n+///\n+/// Where clauses add some trickiness here, because they can be used to \"define\"\n+/// an argument indirectly:\n+///\n+/// ```rust\n+/// impl<'a, I, T: 'a> Iterator for Cloned<I>\n+///    where I: Iterator<Item=&'a T>, T: Clone\n+/// ```\n+///\n+/// In a case like this, the substitution for `T` is determined indirectly,\n+/// through associated type projection. We deal with such cases by using\n+/// *fulfillment* to relate the two impls, requiring that all projections are\n+/// resolved.\n+pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                  source_impl: DefId,\n+                                  source_substs: &'tcx Substs<'tcx>,\n+                                  target_node: specialization_graph::Node)\n+                                  -> &'tcx Substs<'tcx> {\n+    let source_trait_ref = infcx.tcx\n+                                .impl_trait_ref(source_impl)\n+                                .unwrap()\n+                                .subst(infcx.tcx, &source_substs);\n+\n+    // translate the Self and TyParam parts of the substitution, since those\n+    // vary across impls\n+    let target_substs = match target_node {\n+        specialization_graph::Node::Impl(target_impl) => {\n+            // no need to translate if we're targetting the impl we started with\n+            if source_impl == target_impl {\n+                return source_substs;\n+            }\n+\n+            fulfill_implication(infcx, source_trait_ref, target_impl).unwrap_or_else(|_| {\n+                infcx.tcx\n+                     .sess\n+                     .bug(\"When translating substitutions for specialization, the expected \\\n+                           specializaiton failed to hold\")\n+            })\n+        }\n+        specialization_graph::Node::Trait(..) => source_trait_ref.substs.clone(),\n+    };\n+\n+    // retain erasure mode\n+    // NB: this must happen before inheriting method generics below\n+    let target_substs = if source_substs.regions.is_erased() {\n+        target_substs.erase_regions()\n+    } else {\n+        target_substs\n+    };\n+\n+    // directly inherent the method generics, since those do not vary across impls\n+    infcx.tcx.mk_substs(target_substs.with_method_from_subst(source_substs))\n+}\n+\n+/// Is impl1 a specialization of impl2?\n+///\n+/// Specialization is determined by the sets of types to which the impls apply;\n+/// impl1 specializes impl2 if it applies to a subset of the types impl2 applies\n+/// to.\n+pub fn specializes(tcx: &TyCtxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n+    // The feature gate should prevent introducing new specializations, but not\n+    // taking advantage of upstream ones.\n+    if !tcx.sess.features.borrow().specialization &&\n+        (impl1_def_id.is_local() || impl2_def_id.is_local()) {\n+        return false;\n+    }\n+\n+    // We determine whether there's a subset relationship by:\n+    //\n+    // - skolemizing impl1,\n+    // - assuming the where clauses for impl1,\n+    // - instantiating impl2 with fresh inference variables,\n+    // - unifying,\n+    // - attempting to prove the where clauses for impl2\n+    //\n+    // The last three steps are encapsulated in `fulfill_implication`.\n+    //\n+    // See RFC 1210 for more details and justification.\n+\n+    // Currently we do not allow e.g. a negative impl to specialize a positive one\n+    if tcx.trait_impl_polarity(impl1_def_id) != tcx.trait_impl_polarity(impl2_def_id) {\n+        return false;\n+    }\n+\n+    let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Topmost);\n+\n+    // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n+    let scheme = tcx.lookup_item_type(impl1_def_id);\n+    let predicates = tcx.lookup_predicates(impl1_def_id);\n+    let mut penv = tcx.construct_parameter_environment(DUMMY_SP,\n+                                                       &scheme.generics,\n+                                                       &predicates,\n+                                                       region::DUMMY_CODE_EXTENT);\n+    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id)\n+                             .unwrap()\n+                             .subst(tcx, &penv.free_substs);\n+\n+    // Normalize the trait reference, adding any obligations that arise into the impl1 assumptions\n+    let Normalized { value: impl1_trait_ref, obligations: normalization_obligations } = {\n+        let selcx = &mut SelectionContext::new(&infcx);\n+        traits::normalize(selcx, ObligationCause::dummy(), &impl1_trait_ref)\n+    };\n+    penv.caller_bounds.extend(normalization_obligations.into_iter().map(|o| o.predicate));\n+\n+    // Install the parameter environment, taking the predicates of impl1 as assumptions:\n+    infcx.parameter_environment = penv;\n+\n+    // Attempt to prove that impl2 applies, given all of the above.\n+    fulfill_implication(&infcx, impl1_trait_ref, impl2_def_id).is_ok()\n+}\n+\n+/// Attempt to fulfill all obligations of `target_impl` after unification with\n+/// `source_trait_ref`. If successful, returns a substitution for *all* the\n+/// generics of `target_impl`, including both those needed to unify with\n+/// `source_trait_ref` and those whose identity is determined via a where\n+/// clause in the impl.\n+fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                 source_trait_ref: ty::TraitRef<'tcx>,\n+                                 target_impl: DefId)\n+                                 -> Result<Substs<'tcx>, ()> {\n+    infcx.commit_if_ok(|_| {\n+        let selcx = &mut SelectionContext::new(&infcx);\n+        let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);\n+        let (target_trait_ref, obligations) = impl_trait_ref_and_oblig(selcx,\n+                                                                       target_impl,\n+                                                                       &target_substs);\n+\n+        // do the impls unify? If not, no specialization.\n+        if let Err(_) = infer::mk_eq_trait_refs(&infcx,\n+                                                true,\n+                                                TypeOrigin::Misc(DUMMY_SP),\n+                                                source_trait_ref,\n+                                                target_trait_ref) {\n+            debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n+                   source_trait_ref,\n+                   target_trait_ref);\n+            return Err(());\n+        }\n+\n+        // attempt to prove all of the predicates for impl2 given those for impl1\n+        // (which are packed up in penv)\n+\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        for oblig in obligations.into_iter() {\n+            fulfill_cx.register_predicate_obligation(&infcx, oblig);\n+        }\n+\n+        if let Err(errors) = infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()) {\n+            // no dice!\n+            debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n+                    {:?}\",\n+                   source_trait_ref,\n+                   target_trait_ref,\n+                   errors,\n+                   infcx.parameter_environment.caller_bounds);\n+            Err(())\n+        } else {\n+            debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n+                   source_trait_ref,\n+                   target_trait_ref);\n+\n+            // Now resolve the *substitution* we built for the target earlier, replacing\n+            // the inference variables inside with whatever we got from fulfillment.\n+            Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+        }\n+    })\n+}"}, {"sha": "f2170f75a11fe5cc19d353282d3a0f0ada0a4d60", "filename": "src/librustc/middle/traits/specialize/specialization_graph.rs", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,393 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell;\n+use std::rc::Rc;\n+\n+use super::{Overlap, specializes};\n+\n+use middle::cstore::CrateStore;\n+use middle::def_id::DefId;\n+use middle::infer;\n+use middle::traits::{self, ProjectionMode};\n+use middle::ty::{self, TyCtxt, ImplOrTraitItem, TraitDef, TypeFoldable};\n+use syntax::ast::Name;\n+use util::nodemap::DefIdMap;\n+\n+/// A per-trait graph of impls in specialization order. At the moment, this\n+/// graph forms a tree rooted with the trait itself, with all other nodes\n+/// representing impls, and parent-child relationships representing\n+/// specializations.\n+///\n+/// The graph provides two key services:\n+///\n+/// - Construction, which implicitly checks for overlapping impls (i.e., impls\n+///   that overlap but where neither specializes the other -- an artifact of the\n+///   simple \"chain\" rule.\n+///\n+/// - Parent extraction. In particular, the graph can give you the *immediate*\n+///   parents of a given specializing impl, which is needed for extracting\n+///   default items amongst other thigns. In the simple \"chain\" rule, every impl\n+///   has at most one parent.\n+pub struct Graph {\n+    // all impls have a parent; the \"root\" impls have as their parent the def_id\n+    // of the trait\n+    parent: DefIdMap<DefId>,\n+\n+    // the \"root\" impls are found by looking up the trait's def_id.\n+    children: DefIdMap<Vec<DefId>>,\n+}\n+\n+impl Graph {\n+    pub fn new() -> Graph {\n+        Graph {\n+            parent: Default::default(),\n+            children: Default::default(),\n+        }\n+    }\n+\n+    /// Insert a local impl into the specialization graph. If an existing impl\n+    /// conflicts with it (has overlap, but neither specializes the other),\n+    /// information about the area of overlap is returned in the `Err`.\n+    pub fn insert<'a, 'tcx>(&mut self,\n+                            tcx: &'a TyCtxt<'tcx>,\n+                            impl_def_id: DefId)\n+                            -> Result<(), Overlap<'a, 'tcx>> {\n+        assert!(impl_def_id.is_local());\n+\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        let trait_def_id = trait_ref.def_id;\n+\n+        debug!(\"insert({:?}): inserting TraitRef {:?} into specialization graph\",\n+               impl_def_id, trait_ref);\n+\n+        // if the reference itself contains an earlier error (e.g., due to a\n+        // resolution failure), then we just insert the impl at the top level of\n+        // the graph and claim that there's no overlap (in order to supress\n+        // bogus errors).\n+        if trait_ref.references_error() {\n+            debug!(\"insert: inserting dummy node for erroneous TraitRef {:?}, \\\n+                    impl_def_id={:?}, trait_def_id={:?}\",\n+                   trait_ref, impl_def_id, trait_def_id);\n+\n+            self.parent.insert(impl_def_id, trait_def_id);\n+            self.children.entry(trait_def_id).or_insert(vec![]).push(impl_def_id);\n+            return Ok(());\n+        }\n+\n+        let mut parent = trait_def_id;\n+\n+        // Ugly hack around borrowck limitations. Assigned only in the case\n+        // where we bump downward an existing node in the graph.\n+        let child_to_insert;\n+\n+        'descend: loop {\n+            let mut possible_siblings = self.children.entry(parent).or_insert(vec![]);\n+\n+            for slot in possible_siblings.iter_mut() {\n+                let possible_sibling = *slot;\n+\n+                let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::Topmost);\n+                let overlap = traits::overlapping_impls(&infcx, possible_sibling, impl_def_id);\n+\n+                if let Some(impl_header) = overlap {\n+                    let le = specializes(tcx, impl_def_id, possible_sibling);\n+                    let ge = specializes(tcx, possible_sibling, impl_def_id);\n+\n+                    if le && !ge {\n+                        debug!(\"descending as child of TraitRef {:?}\",\n+                               tcx.impl_trait_ref(possible_sibling).unwrap());\n+\n+                        // the impl specializes possible_sibling\n+                        parent = possible_sibling;\n+                        continue 'descend;\n+                    } else if ge && !le {\n+                        debug!(\"placing as parent of TraitRef {:?}\",\n+                               tcx.impl_trait_ref(possible_sibling).unwrap());\n+\n+                        // possible_sibling specializes the impl\n+                        *slot = impl_def_id;\n+                        self.parent.insert(impl_def_id, parent);\n+                        self.parent.insert(possible_sibling, impl_def_id);\n+                        // we have to defer the insertion, because we can't\n+                        // relinquish the borrow of `self.children`\n+                        child_to_insert = possible_sibling;\n+                        break 'descend;\n+                    } else {\n+                        // overlap, but no specialization; error out\n+                        return Err(Overlap {\n+                            with_impl: possible_sibling,\n+                            on_trait_ref: impl_header.trait_ref.unwrap(),\n+                            in_context: infcx,\n+                        });\n+                    }\n+                }\n+            }\n+\n+            // no overlap with any potential siblings, so add as a new sibling\n+            debug!(\"placing as new sibling\");\n+            self.parent.insert(impl_def_id, parent);\n+            possible_siblings.push(impl_def_id);\n+            return Ok(());\n+        }\n+\n+        self.children.insert(impl_def_id, vec![child_to_insert]);\n+        Ok(())\n+    }\n+\n+    /// Insert cached metadata mapping from a child impl back to its parent.\n+    pub fn record_impl_from_cstore(&mut self, parent: DefId, child: DefId) {\n+        if self.parent.insert(child, parent).is_some() {\n+            panic!(\"When recording an impl from the crate store, information about its parent \\\n+                    was already present.\");\n+        }\n+\n+        self.children.entry(parent).or_insert(vec![]).push(child);\n+    }\n+\n+    /// The parent of a given impl, which is the def id of the trait when the\n+    /// impl is a \"specialization root\".\n+    pub fn parent(&self, child: DefId) -> DefId {\n+        *self.parent.get(&child).unwrap()\n+    }\n+}\n+\n+/// A node in the specialization graph is either an impl or a trait\n+/// definition; either can serve as a source of item definitions.\n+/// There is always exactly one trait definition node: the root.\n+#[derive(Debug, Copy, Clone)]\n+pub enum Node {\n+    Impl(DefId),\n+    Trait(DefId),\n+}\n+\n+impl Node {\n+    pub fn is_from_trait(&self) -> bool {\n+        match *self {\n+            Node::Trait(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Iterate over the items defined directly by the given (impl or trait) node.\n+    pub fn items<'a, 'tcx>(&self, tcx: &'a TyCtxt<'tcx>) -> NodeItems<'a, 'tcx> {\n+        match *self {\n+            Node::Impl(impl_def_id) => {\n+                NodeItems::Impl {\n+                    tcx: tcx,\n+                    items: cell::Ref::map(tcx.impl_items.borrow(),\n+                                          |impl_items| &impl_items[&impl_def_id]),\n+                    idx: 0,\n+                }\n+            }\n+            Node::Trait(trait_def_id) => {\n+                NodeItems::Trait {\n+                    items: tcx.trait_items(trait_def_id).clone(),\n+                    idx: 0,\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn def_id(&self) -> DefId {\n+        match *self {\n+            Node::Impl(did) => did,\n+            Node::Trait(did) => did,\n+        }\n+    }\n+}\n+\n+/// An iterator over the items defined within a trait or impl.\n+pub enum NodeItems<'a, 'tcx: 'a> {\n+    Impl {\n+        tcx: &'a TyCtxt<'tcx>,\n+        items: cell::Ref<'a, Vec<ty::ImplOrTraitItemId>>,\n+        idx: usize,\n+    },\n+    Trait {\n+        items: Rc<Vec<ImplOrTraitItem<'tcx>>>,\n+        idx: usize,\n+    },\n+}\n+\n+impl<'a, 'tcx> Iterator for NodeItems<'a, 'tcx> {\n+    type Item = ImplOrTraitItem<'tcx>;\n+    fn next(&mut self) -> Option<ImplOrTraitItem<'tcx>> {\n+        match *self {\n+            NodeItems::Impl { tcx, ref items, ref mut idx } => {\n+                let items_table = tcx.impl_or_trait_items.borrow();\n+                if *idx < items.len() {\n+                    let item_def_id = items[*idx].def_id();\n+                    let item = items_table[&item_def_id].clone();\n+                    *idx += 1;\n+                    Some(item)\n+                } else {\n+                    None\n+                }\n+            }\n+            NodeItems::Trait { ref items, ref mut idx } => {\n+                if *idx < items.len() {\n+                    let item = items[*idx].clone();\n+                    *idx += 1;\n+                    Some(item)\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub struct Ancestors<'a, 'tcx: 'a> {\n+    trait_def: &'a TraitDef<'tcx>,\n+    current_source: Option<Node>,\n+}\n+\n+impl<'a, 'tcx> Iterator for Ancestors<'a, 'tcx> {\n+    type Item = Node;\n+    fn next(&mut self) -> Option<Node> {\n+        let cur = self.current_source.take();\n+        if let Some(Node::Impl(cur_impl)) = cur {\n+            let parent = self.trait_def.specialization_graph.borrow().parent(cur_impl);\n+            if parent == self.trait_def.def_id() {\n+                self.current_source = Some(Node::Trait(parent));\n+            } else {\n+                self.current_source = Some(Node::Impl(parent));\n+            }\n+        }\n+        cur\n+    }\n+}\n+\n+pub struct NodeItem<T> {\n+    pub node: Node,\n+    pub item: T,\n+}\n+\n+impl<T> NodeItem<T> {\n+    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> NodeItem<U> {\n+        NodeItem {\n+            node: self.node,\n+            item: f(self.item),\n+        }\n+    }\n+}\n+\n+pub struct TypeDefs<'a, 'tcx: 'a> {\n+    // generally only invoked once or twice, so the box doesn't hurt\n+    iter: Box<Iterator<Item = NodeItem<Rc<ty::AssociatedType<'tcx>>>> + 'a>,\n+}\n+\n+impl<'a, 'tcx> Iterator for TypeDefs<'a, 'tcx> {\n+    type Item = NodeItem<Rc<ty::AssociatedType<'tcx>>>;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.iter.next()\n+    }\n+}\n+\n+pub struct FnDefs<'a, 'tcx: 'a> {\n+    // generally only invoked once or twice, so the box doesn't hurt\n+    iter: Box<Iterator<Item = NodeItem<Rc<ty::Method<'tcx>>>> + 'a>,\n+}\n+\n+impl<'a, 'tcx> Iterator for FnDefs<'a, 'tcx> {\n+    type Item = NodeItem<Rc<ty::Method<'tcx>>>;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.iter.next()\n+    }\n+}\n+\n+pub struct ConstDefs<'a, 'tcx: 'a> {\n+    // generally only invoked once or twice, so the box doesn't hurt\n+    iter: Box<Iterator<Item = NodeItem<Rc<ty::AssociatedConst<'tcx>>>> + 'a>,\n+}\n+\n+impl<'a, 'tcx> Iterator for ConstDefs<'a, 'tcx> {\n+    type Item = NodeItem<Rc<ty::AssociatedConst<'tcx>>>;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.iter.next()\n+    }\n+}\n+\n+impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n+    /// Search the items from the given ancestors, returning each type definition\n+    /// with the given name.\n+    pub fn type_defs(self, tcx: &'a TyCtxt<'tcx>, name: Name) -> TypeDefs<'a, 'tcx> {\n+        let iter = self.flat_map(move |node| {\n+            node.items(tcx)\n+                .filter_map(move |item| {\n+                    if let ty::TypeTraitItem(assoc_ty) = item {\n+                        if assoc_ty.name == name {\n+                            return Some(NodeItem {\n+                                node: node,\n+                                item: assoc_ty,\n+                            });\n+                        }\n+                    }\n+                    None\n+                })\n+\n+        });\n+        TypeDefs { iter: Box::new(iter) }\n+    }\n+\n+    /// Search the items from the given ancestors, returning each fn definition\n+    /// with the given name.\n+    pub fn fn_defs(self, tcx: &'a TyCtxt<'tcx>, name: Name) -> FnDefs<'a, 'tcx> {\n+        let iter = self.flat_map(move |node| {\n+            node.items(tcx)\n+                .filter_map(move |item| {\n+                    if let ty::MethodTraitItem(method) = item {\n+                        if method.name == name {\n+                            return Some(NodeItem {\n+                                node: node,\n+                                item: method,\n+                            });\n+                        }\n+                    }\n+                    None\n+                })\n+\n+        });\n+        FnDefs { iter: Box::new(iter) }\n+    }\n+\n+    /// Search the items from the given ancestors, returning each const\n+    /// definition with the given name.\n+    pub fn const_defs(self, tcx: &'a TyCtxt<'tcx>, name: Name) -> ConstDefs<'a, 'tcx> {\n+        let iter = self.flat_map(move |node| {\n+            node.items(tcx)\n+                .filter_map(move |item| {\n+                    if let ty::ConstTraitItem(konst) = item {\n+                        if konst.name == name {\n+                            return Some(NodeItem {\n+                                node: node,\n+                                item: konst,\n+                            });\n+                        }\n+                    }\n+                    None\n+                })\n+\n+        });\n+        ConstDefs { iter: Box::new(iter) }\n+    }\n+}\n+\n+/// Walk up the specialization ancestors of a given impl, starting with that\n+/// impl itself.\n+pub fn ancestors<'a, 'tcx>(trait_def: &'a TraitDef<'tcx>,\n+                           start_from_impl: DefId)\n+                           -> Ancestors<'a, 'tcx> {\n+    Ancestors {\n+        trait_def: trait_def,\n+        current_source: Some(Node::Impl(start_from_impl)),\n+    }\n+}"}, {"sha": "1e37600bc0449cacec00743c0963f4926539c23b", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -10,13 +10,13 @@\n \n use middle::def_id::DefId;\n use middle::infer::InferCtxt;\n-use middle::subst::Substs;\n+use middle::subst::{Subst, Substs};\n use middle::ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n use syntax::codemap::Span;\n use util::common::ErrorReported;\n use util::nodemap::FnvHashSet;\n \n-use super::{Obligation, ObligationCause, PredicateObligation};\n+use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n struct PredicateSet<'a,'tcx:'a> {\n     tcx: &'a TyCtxt<'tcx>,\n@@ -299,6 +299,38 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n // Other\n ///////////////////////////////////////////////////////////////////////////\n \n+/// Instantiate all bound parameters of the impl with the given substs,\n+/// returning the resulting trait ref and all obligations that arise.\n+/// The obligations are closed under normalization.\n+pub fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                                         impl_def_id: DefId,\n+                                         impl_substs: &Substs<'tcx>)\n+                                         -> (ty::TraitRef<'tcx>,\n+                                             Vec<PredicateObligation<'tcx>>)\n+{\n+    let impl_trait_ref =\n+        selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n+    let impl_trait_ref =\n+        impl_trait_ref.subst(selcx.tcx(), impl_substs);\n+    let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n+        super::normalize(selcx, ObligationCause::dummy(), &impl_trait_ref);\n+\n+    let predicates = selcx.tcx().lookup_predicates(impl_def_id);\n+    let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n+    let Normalized { value: predicates, obligations: normalization_obligations2 } =\n+        super::normalize(selcx, ObligationCause::dummy(), &predicates);\n+    let impl_obligations =\n+        predicates_for_generics(ObligationCause::dummy(), 0, &predicates);\n+\n+    let impl_obligations: Vec<_> =\n+        impl_obligations.into_iter()\n+        .chain(normalization_obligations1)\n+        .chain(normalization_obligations2)\n+        .collect();\n+\n+    (impl_trait_ref, impl_obligations)\n+}\n+\n // determine the `self` type, using fresh variables for all variables\n // declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n@@ -349,7 +381,6 @@ pub fn trait_ref_for_builtin_bound<'tcx>(\n     }\n }\n \n-\n pub fn predicate_for_trait_ref<'tcx>(\n     cause: ObligationCause<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,"}, {"sha": "081196835936cbb3a3b1462f6366d3ee62d06dde", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -281,6 +281,7 @@ pub struct Method<'tcx> {\n     pub fty: BareFnTy<'tcx>,\n     pub explicit_self: ExplicitSelfCategory,\n     pub vis: hir::Visibility,\n+    pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n }\n@@ -292,16 +293,18 @@ impl<'tcx> Method<'tcx> {\n                fty: BareFnTy<'tcx>,\n                explicit_self: ExplicitSelfCategory,\n                vis: hir::Visibility,\n+               defaultness: hir::Defaultness,\n                def_id: DefId,\n                container: ImplOrTraitItemContainer)\n                -> Method<'tcx> {\n-       Method {\n+        Method {\n             name: name,\n             generics: generics,\n             predicates: predicates,\n             fty: fty,\n             explicit_self: explicit_self,\n             vis: vis,\n+            defaultness: defaultness,\n             def_id: def_id,\n             container: container,\n         }\n@@ -334,6 +337,7 @@ pub struct AssociatedConst<'tcx> {\n     pub name: Name,\n     pub ty: Ty<'tcx>,\n     pub vis: hir::Visibility,\n+    pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n     pub has_value: bool\n@@ -344,6 +348,7 @@ pub struct AssociatedType<'tcx> {\n     pub name: Name,\n     pub ty: Option<Ty<'tcx>>,\n     pub vis: hir::Visibility,\n+    pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n }\n@@ -2451,8 +2456,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         for impl_def_id in self.sess.cstore.implementations_of_trait(trait_id) {\n             let impl_items = self.sess.cstore.impl_items(impl_def_id);\n             let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n+\n             // Record the trait->implementation mapping.\n-            def.record_impl(self, impl_def_id, trait_ref);\n+            if let Some(parent) = self.sess.cstore.impl_parent(impl_def_id) {\n+                def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n+            } else {\n+                def.record_remote_impl(self, impl_def_id, trait_ref, trait_id);\n+            }\n \n             // For any methods that use a default implementation, add them to\n             // the map. This is a bit unfortunate.\n@@ -2660,14 +2670,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n \n-\n     pub fn visit_all_items_in_krate<V,F>(&self,\n                                          dep_node_fn: F,\n                                          visitor: &mut V)\n         where F: FnMut(DefId) -> DepNode, V: Visitor<'tcx>\n     {\n         dep_graph::visit_all_items_in_krate(self, dep_node_fn, visitor);\n     }\n+    /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n+    /// with the name of the crate containing the impl.\n+    pub fn span_of_impl(&self, impl_did: DefId) -> Result<Span, String> {\n+        if impl_did.is_local() {\n+            let node_id = self.map.as_local_node_id(impl_did).unwrap();\n+            Ok(self.map.span(node_id))\n+        } else {\n+            Err(self.sess.cstore.crate_name(impl_did.krate))\n+        }\n+    }\n }\n \n /// The category of explicit self.\n@@ -2709,28 +2728,4 @@ impl<'tcx> TyCtxt<'tcx> {\n             Some(d) => f(&d[..])\n         }\n     }\n-\n-    pub fn make_substs_for_receiver_types(&self,\n-                                          trait_ref: &ty::TraitRef<'tcx>,\n-                                          method: &ty::Method<'tcx>)\n-                                          -> subst::Substs<'tcx>\n-    {\n-        /*!\n-         * Substitutes the values for the receiver's type parameters\n-         * that are found in method, leaving the method's type parameters\n-         * intact.\n-         */\n-\n-        let meth_tps: Vec<Ty> =\n-            method.generics.types.get_slice(subst::FnSpace)\n-                  .iter()\n-                  .map(|def| self.mk_param_from_def(def))\n-                  .collect();\n-        let meth_regions: Vec<ty::Region> =\n-            method.generics.regions.get_slice(subst::FnSpace)\n-                  .iter()\n-                  .map(|def| def.to_early_bound_region())\n-                  .collect();\n-        trait_ref.substs.clone().with_method(meth_tps, meth_regions)\n-    }\n }"}, {"sha": "bbc5948f2cac71f5eff6c444a3f5aa29868ea8ba", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -1106,6 +1106,13 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    pub fn has_concrete_skeleton(&self) -> bool {\n+        match self.sty {\n+            TyParam(_) | TyInfer(_) | TyError => false,\n+            _ => true,\n+        }\n+    }\n+\n     // Returns the type and mutability of *ty.\n     //\n     // The parameter `explicit` indicates if this is an *explicit* dereference."}, {"sha": "3d7b3bf2634254649f068af19e18b8a00a92da6f", "filename": "src/librustc/middle/ty/trait_def.rs", "status": "modified", "additions": 68, "deletions": 12, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -10,9 +10,10 @@\n \n use dep_graph::DepNode;\n use middle::def_id::DefId;\n+use middle::traits::{self, specialization_graph};\n use middle::ty;\n use middle::ty::fast_reject;\n-use middle::ty::{Ty, TyCtxt};\n+use middle::ty::{Ty, TyCtxt, TraitRef};\n use std::borrow::{Borrow};\n use std::cell::{Cell, Ref, RefCell};\n use syntax::ast::Name;\n@@ -59,6 +60,9 @@ pub struct TraitDef<'tcx> {\n     /// Blanket impls associated with the trait.\n     blanket_impls: RefCell<Vec<DefId>>,\n \n+    /// The specialization order for impls of this trait.\n+    pub specialization_graph: RefCell<traits::specialization_graph::Graph>,\n+\n     /// Various flags\n     pub flags: Cell<TraitFlags>\n }\n@@ -78,7 +82,8 @@ impl<'tcx> TraitDef<'tcx> {\n             associated_type_names: associated_type_names,\n             nonblanket_impls: RefCell::new(FnvHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n-            flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n+            flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n+            specialization_graph: RefCell::new(traits::specialization_graph::Graph::new()),\n         }\n     }\n \n@@ -114,11 +119,14 @@ impl<'tcx> TraitDef<'tcx> {\n         tcx.dep_graph.read(DepNode::TraitImpls(self.trait_ref.def_id));\n     }\n \n-    /// Records a trait-to-implementation mapping.\n-    pub fn record_impl(&self,\n-                       tcx: &TyCtxt<'tcx>,\n-                       impl_def_id: DefId,\n-                       impl_trait_ref: ty::TraitRef<'tcx>) {\n+    /// Records a basic trait-to-implementation mapping.\n+    ///\n+    /// Returns `true` iff the impl has not previously been recorded.\n+    fn record_impl(&self,\n+                   tcx: &TyCtxt<'tcx>,\n+                   impl_def_id: DefId,\n+                   impl_trait_ref: TraitRef<'tcx>)\n+                   -> bool {\n         debug!(\"TraitDef::record_impl for {:?}, from {:?}\",\n                self, impl_trait_ref);\n \n@@ -134,22 +142,71 @@ impl<'tcx> TraitDef<'tcx> {\n                                                       impl_trait_ref.self_ty(), false) {\n             if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n                 if is.contains(&impl_def_id) {\n-                    return // duplicate - skip\n+                    return false; // duplicate - skip\n                 }\n             }\n \n             self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n         } else {\n             if self.blanket_impls.borrow().contains(&impl_def_id) {\n-                return // duplicate - skip\n+                return false; // duplicate - skip\n             }\n             self.blanket_impls.borrow_mut().push(impl_def_id)\n         }\n+\n+        true\n     }\n \n-    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &TyCtxt<'tcx>, mut f: F)  {\n-        self.read_trait_impls(tcx);\n+    /// Records a trait-to-implementation mapping for a crate-local impl.\n+    pub fn record_local_impl(&self,\n+                             tcx: &TyCtxt<'tcx>,\n+                             impl_def_id: DefId,\n+                             impl_trait_ref: TraitRef<'tcx>) {\n+        assert!(impl_def_id.is_local());\n+        let was_new = self.record_impl(tcx, impl_def_id, impl_trait_ref);\n+        assert!(was_new);\n+    }\n+\n+    /// Records a trait-to-implementation mapping for a non-local impl.\n+    ///\n+    /// The `parent_impl` is the immediately-less-specialized impl, or the\n+    /// trait's def ID if the impl is is not a specialization -- information that\n+    /// should be pulled from the metadata.\n+    pub fn record_remote_impl(&self,\n+                              tcx: &TyCtxt<'tcx>,\n+                              impl_def_id: DefId,\n+                              impl_trait_ref: TraitRef<'tcx>,\n+                              parent_impl: DefId) {\n+        assert!(!impl_def_id.is_local());\n+\n+        // if the impl has not previously been recorded\n+        if self.record_impl(tcx, impl_def_id, impl_trait_ref) {\n+            // if the impl is non-local, it's placed directly into the\n+            // specialization graph using parent information drawn from metadata.\n+            self.specialization_graph.borrow_mut()\n+                .record_impl_from_cstore(parent_impl, impl_def_id)\n+        }\n+    }\n+\n+    /// Adds a local impl into the specialization graph, returning an error with\n+    /// overlap information if the impl overlaps but does not specialize an\n+    /// existing impl.\n+    pub fn add_impl_for_specialization<'a>(&self,\n+                                           tcx: &'a TyCtxt<'tcx>,\n+                                           impl_def_id: DefId)\n+                                           -> Result<(), traits::Overlap<'a, 'tcx>> {\n+        assert!(impl_def_id.is_local());\n+\n+        self.specialization_graph.borrow_mut()\n+            .insert(tcx, impl_def_id)\n+    }\n \n+    pub fn ancestors<'a>(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a, 'tcx> {\n+        specialization_graph::ancestors(self, of_impl)\n+    }\n+\n+        pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &TyCtxt<'tcx>, mut f: F)  {\n+            self.read_trait_impls(tcx);\n         tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n \n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n@@ -223,4 +280,3 @@ bitflags! {\n         const IMPLS_VALID           = 1 << 3,\n     }\n }\n-"}, {"sha": "5af40a3675ff7c199b7498ed3ca489e9a4b4b699", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 10, "deletions": 57, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -14,10 +14,10 @@ use back::svh::Svh;\n use middle::const_eval::{self, ConstVal, ErrKind};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n use middle::def_id::DefId;\n-use middle::subst::{self, Subst, Substs};\n+use middle::subst;\n use middle::infer;\n use middle::pat_util;\n-use middle::traits;\n+use middle::traits::{self, ProjectionMode};\n use middle::ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use middle::ty::{Disr, ParameterEnvironment};\n use middle::ty::TypeVariants::*;\n@@ -26,7 +26,6 @@ use rustc_const_eval::{ConstInt, ConstIsize, ConstUsize};\n \n use std::cmp;\n use std::hash::{Hash, SipHasher, Hasher};\n-use std::rc::Rc;\n use syntax::ast::{self, Name};\n use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n@@ -131,7 +130,10 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n         let tcx = self.tcx;\n \n         // FIXME: (@jroesch) float this code up\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(self.clone()));\n+        let infcx = infer::new_infer_ctxt(tcx,\n+                                          &tcx.tables,\n+                                          Some(self.clone()),\n+                                          ProjectionMode::AnyFinal);\n \n         let adt = match self_type.sty {\n             ty::TyStruct(struct_def, substs) => {\n@@ -536,66 +538,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct ImplMethod<'tcx> {\n-    pub method: Rc<ty::Method<'tcx>>,\n-    pub substs: &'tcx Substs<'tcx>,\n-    pub is_provided: bool\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn get_impl_method(&self,\n-                           impl_def_id: DefId,\n-                           substs: &'tcx Substs<'tcx>,\n-                           name: Name)\n-                           -> ImplMethod<'tcx>\n-    {\n-        // there don't seem to be nicer accessors to these:\n-        let impl_or_trait_items_map = self.impl_or_trait_items.borrow();\n-\n-        for impl_item in &self.impl_items.borrow()[&impl_def_id] {\n-            if let ty::MethodTraitItem(ref meth) =\n-                impl_or_trait_items_map[&impl_item.def_id()] {\n-                if meth.name == name {\n-                    return ImplMethod {\n-                        method: meth.clone(),\n-                        substs: substs,\n-                        is_provided: false\n-                    }\n-                }\n-            }\n-        }\n-\n-        // It is not in the impl - get the default from the trait.\n-        let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n-        for trait_item in self.trait_items(trait_ref.def_id).iter() {\n-            if let &ty::MethodTraitItem(ref meth) = trait_item {\n-                if meth.name == name {\n-                    let impl_to_trait_substs = self\n-                        .make_substs_for_receiver_types(&trait_ref, meth);\n-                    let substs = impl_to_trait_substs.subst(self, substs);\n-                    return ImplMethod {\n-                        method: meth.clone(),\n-                        substs: self.mk_substs(substs),\n-                        is_provided: true\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.sess.bug(&format!(\"method {:?} not found in {:?}\",\n-                               name, impl_def_id))\n-    }\n-}\n-\n impl<'tcx> ty::TyS<'tcx> {\n     fn impls_bound<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n                        bound: ty::BuiltinBound,\n                        span: Span)\n                        -> bool\n     {\n         let tcx = param_env.tcx;\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()));\n+        let infcx = infer::new_infer_ctxt(tcx,\n+                                          &tcx.tables,\n+                                          Some(param_env.clone()),\n+                                          ProjectionMode::AnyFinal);\n \n         let is_impld = traits::type_known_to_meet_builtin_bound(&infcx,\n                                                                 self, bound, span);"}, {"sha": "9186765e6d02c0c49f9cf0f84dd7cc45a551e865", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -27,6 +27,7 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::middle::ty::{self, TyCtxt};\n+use rustc::middle::traits::ProjectionMode;\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc_front::hir;\n@@ -202,7 +203,10 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     debug!(\"check_loans(body id={})\", body.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env));\n+    let infcx = infer::new_infer_ctxt(bccx.tcx,\n+                                      &bccx.tcx.tables,\n+                                      Some(param_env),\n+                                      ProjectionMode::AnyFinal);\n \n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,"}, {"sha": "2d255c054548f42e8c0a6e06710d5b4ea8f8433a", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -24,6 +24,7 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::middle::ty::{self, TyCtxt};\n+use rustc::middle::traits::ProjectionMode;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -55,7 +56,10 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env));\n+    let infcx = infer::new_infer_ctxt(bccx.tcx,\n+                                      &bccx.tcx.tables,\n+                                      Some(param_env),\n+                                      ProjectionMode::AnyFinal);\n     {\n         let mut euv = euv::ExprUseVisitor::new(&mut glcx, &infcx);\n         euv.walk_fn(decl, body);\n@@ -525,7 +529,10 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let infcx = infer::new_infer_ctxt(self.bccx.tcx, &self.bccx.tcx.tables, None);\n+            let infcx = infer::new_infer_ctxt(self.bccx.tcx,\n+                                              &self.bccx.tcx.tables,\n+                                              None,\n+                                              ProjectionMode::AnyFinal);\n             let mc = mc::MemCategorizationContext::new(&infcx);\n             let base_cmt = mc.cat_expr(&base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);"}, {"sha": "982a2bacce1648459cffea4dc3cde3e83d0fb5b2", "filename": "src/librustc_data_structures/obligation_forest/README.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -60,7 +60,7 @@ which includes three bits of information:\n   `process_obligations` would simply yield back further ambiguous\n   results. This is used by the `FulfillmentContext` to decide when it\n   has reached a steady state.\n-  \n+\n #### Snapshots\n \n The `ObligationForest` supports a limited form of snapshots; see\n@@ -79,5 +79,3 @@ parent and (for convenience) its root (which may be itself). It also\n has a current state, described by `NodeState`. After each\n processing step, we compress the vector to remove completed and error\n nodes, which aren't needed anymore.\n-\n-  "}, {"sha": "1a5e7cb54f2e3a0bb60a29bdbe5e706130330c5d", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -22,6 +22,7 @@ use rustc_typeck::middle::resolve_lifetime;\n use rustc_typeck::middle::stability;\n use rustc_typeck::middle::subst;\n use rustc_typeck::middle::subst::Subst;\n+use rustc_typeck::middle::traits::ProjectionMode;\n use rustc_typeck::middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_typeck::middle::ty::relate::TypeRelation;\n use rustc_typeck::middle::infer::{self, TypeOrigin};\n@@ -146,7 +147,10 @@ fn test_env<F>(source_string: &str,\n                                lang_items,\n                                index,\n                                |tcx| {\n-                                   let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+                                   let infcx = infer::new_infer_ctxt(tcx,\n+                                                                     &tcx.tables,\n+                                                                     None,\n+                                                                     ProjectionMode::AnyFinal);\n                                    body(Env { infcx: &infcx });\n                                    let free_regions = FreeRegionMap::new();\n                                    infcx.resolve_regions_and_report_errors(&free_regions,"}, {"sha": "6ae59122f71c49a85525eb8534972ecfa41eca3c", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -839,6 +839,7 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T) -> ImplItem {\n         name: folder.fold_name(i.name),\n         attrs: fold_attrs(i.attrs, folder),\n         vis: i.vis,\n+        defaultness: i.defaultness,\n         node: match i.node {\n             ImplItemKind::Const(ty, expr) => {\n                 ImplItemKind::Const(folder.fold_ty(ty), folder.fold_expr(expr))"}, {"sha": "0b1418fc878452b83ecb51a054e6a3f47abe1b7e", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -864,10 +864,10 @@ pub struct MethodSig {\n     pub explicit_self: ExplicitSelf,\n }\n \n-/// Represents a method declaration in a trait declaration, possibly including\n-/// a default implementation A trait method is either required (meaning it\n-/// doesn't have an implementation, just a signature) or provided (meaning it\n-/// has a default implementation).\n+/// Represents an item declaration within a trait declaration,\n+/// possibly including a default implementation. A trait item is\n+/// either required (meaning it doesn't have an implementation, just a\n+/// signature) or provided (meaning it has a default implementation).\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitItem {\n     pub id: NodeId,\n@@ -889,6 +889,7 @@ pub struct ImplItem {\n     pub id: NodeId,\n     pub name: Name,\n     pub vis: Visibility,\n+    pub defaultness: Defaultness,\n     pub attrs: HirVec<Attribute>,\n     pub node: ImplItemKind,\n     pub span: Span,\n@@ -1046,6 +1047,22 @@ pub enum Constness {\n     NotConst,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum Defaultness {\n+    Default,\n+    Final,\n+}\n+\n+impl Defaultness {\n+    pub fn is_final(&self) -> bool {\n+        *self == Defaultness::Final\n+    }\n+\n+    pub fn is_default(&self) -> bool {\n+        *self == Defaultness::Default\n+    }\n+}\n+\n impl fmt::Display for Unsafety {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(match *self {"}, {"sha": "825ab3fbd4c8227107c4c71846e79b5bb3972b5d", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -756,6 +756,7 @@ pub fn lower_impl_item(lctx: &LoweringContext, i: &ImplItem) -> hir::ImplItem {\n         name: i.ident.name,\n         attrs: lower_attrs(lctx, &i.attrs),\n         vis: lower_visibility(lctx, i.vis),\n+        defaultness: lower_defaultness(lctx, i.defaultness),\n         node: match i.node {\n             ImplItemKind::Const(ref ty, ref expr) => {\n                 hir::ImplItemKind::Const(lower_ty(lctx, ty), lower_expr(lctx, expr))\n@@ -1707,6 +1708,13 @@ pub fn lower_visibility(_lctx: &LoweringContext, v: Visibility) -> hir::Visibili\n     }\n }\n \n+pub fn lower_defaultness(_lctx: &LoweringContext, d: Defaultness) -> hir::Defaultness {\n+    match d {\n+        Defaultness::Default => hir::Defaultness::Default,\n+        Defaultness::Final => hir::Defaultness::Final,\n+    }\n+}\n+\n pub fn lower_block_check_mode(lctx: &LoweringContext, b: &BlockCheckMode) -> hir::BlockCheckMode {\n     match *b {\n         BlockCheckMode::Default => hir::DefaultBlock,"}, {"sha": "1100f084454c729747c50c057819d5e80acbecda", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -1014,6 +1014,11 @@ impl<'a> State<'a> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(ii.span.lo));\n         try!(self.print_outer_attributes(&ii.attrs));\n+\n+        if let hir::Defaultness::Default = ii.defaultness {\n+            try!(self.word_nbsp(\"default\"));\n+        }\n+\n         match ii.node {\n             hir::ImplItemKind::Const(ref ty, ref expr) => {\n                 try!(self.print_associated_const(ii.name, &ty, Some(&expr), ii.vis));"}, {"sha": "88027931022e755824cee9766c6c91b3e63509f1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -35,6 +35,7 @@ use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::ty::adjustment;\n+use middle::traits::ProjectionMode;\n use rustc::front::map as hir_map;\n use util::nodemap::{NodeSet};\n use lint::{Level, LateContext, LintContext, LintArray, Lint};\n@@ -868,7 +869,10 @@ impl LateLintPass for UnconditionalRecursion {\n                     let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n \n                     let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n-                    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n+                    let infcx = infer::new_infer_ctxt(tcx,\n+                                                      &tcx.tables,\n+                                                      Some(param_env),\n+                                                      ProjectionMode::AnyFinal);\n                     let mut selcx = traits::SelectionContext::new(&infcx);\n                     match selcx.select(&obligation) {\n                         // The method comes from a `T: Trait` bound."}, {"sha": "a0cbba279acc05e3bf88f440f085c425e3a96266", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -241,6 +241,10 @@ pub const tag_items_data_item_constness: usize = 0xa6;\n \n pub const tag_items_data_item_deprecation: usize = 0xa7;\n \n+pub const tag_items_data_item_defaultness: usize = 0xa8;\n+\n+pub const tag_items_data_parent_impl: usize = 0xa9;\n+\n pub const tag_rustc_version: usize = 0x10f;\n pub fn rustc_version() -> String {\n     format!("}, {"sha": "2cd119cfc48be081d444945fe539524976ad2a06", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -225,6 +225,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_associated_consts(self.intr.clone(), &cdata, def.index, tcx)\n     }\n \n+    fn impl_parent(&self, impl_def: DefId) -> Option<DefId> {\n+        let cdata = self.get_crate_data(impl_def.krate);\n+        decoder::get_parent_impl(&*cdata, impl_def.index)\n+    }\n+\n     fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId) -> Option<DefId>\n     {\n         let cdata = self.get_crate_data(def_id.krate);"}, {"sha": "38a2a7794bcbd5a01768c343efc2bb65384855f3", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -165,6 +165,19 @@ fn fn_constness(item: rbml::Doc) -> hir::Constness {\n     }\n }\n \n+fn item_defaultness(item: rbml::Doc) -> hir::Defaultness {\n+    match reader::maybe_get_doc(item, tag_items_data_item_defaultness) {\n+        None => hir::Defaultness::Default, // should occur only for default impls on traits\n+        Some(defaultness_doc) => {\n+            match reader::doc_as_u8(defaultness_doc) as char {\n+                'd' => hir::Defaultness::Default,\n+                'f' => hir::Defaultness::Final,\n+                _ => panic!(\"unknown defaultness character\")\n+            }\n+        }\n+    }\n+}\n+\n fn item_sort(item: rbml::Doc) -> Option<char> {\n     reader::tagged_docs(item, tag_item_trait_item_sort).nth(0).map(|doc| {\n         doc.as_str_slice().as_bytes()[0] as char\n@@ -551,6 +564,13 @@ pub fn get_visibility(cdata: Cmd, id: DefIndex) -> hir::Visibility {\n     item_visibility(cdata.lookup_item(id))\n }\n \n+pub fn get_parent_impl(cdata: Cmd, id: DefIndex) -> Option<DefId> {\n+    let item = cdata.lookup_item(id);\n+    reader::maybe_get_doc(item, tag_items_data_parent_impl).map(|doc| {\n+        translated_def_id(cdata, doc)\n+    })\n+}\n+\n pub fn get_repr_attrs(cdata: Cmd, id: DefIndex) -> Vec<attr::ReprAttr> {\n     let item = cdata.lookup_item(id);\n     match reader::maybe_get_doc(item, tag_items_data_item_repr).map(|doc| {\n@@ -976,6 +996,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n \n     let name = item_name(&intr, item_doc);\n     let vis = item_visibility(item_doc);\n+    let defaultness = item_defaultness(item_doc);\n \n     match item_sort(item_doc) {\n         sort @ Some('C') | sort @ Some('c') => {\n@@ -984,6 +1005,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                 name: name,\n                 ty: ty,\n                 vis: vis,\n+                defaultness: defaultness,\n                 def_id: def_id,\n                 container: container,\n                 has_value: sort == Some('C')\n@@ -1007,6 +1029,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                                                         fty,\n                                                         explicit_self,\n                                                         vis,\n+                                                        defaultness,\n                                                         def_id,\n                                                         container)))\n         }\n@@ -1016,6 +1039,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n                 name: name,\n                 ty: ty,\n                 vis: vis,\n+                defaultness: defaultness,\n                 def_id: def_id,\n                 container: container,\n             }))"}, {"sha": "41baa0b159148798edff3d086a15d0bf5d2a05c0", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -25,6 +25,7 @@ use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n use middle::stability;\n use middle::subst;\n+use middle::traits::specialization_graph;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::ty::util::IntTypeExt;\n \n@@ -451,6 +452,14 @@ fn encode_constness(rbml_w: &mut Encoder, constness: hir::Constness) {\n     rbml_w.end_tag();\n }\n \n+fn encode_defaultness(rbml_w: &mut Encoder, defaultness: hir::Defaultness) {\n+    let ch = match defaultness {\n+        hir::Defaultness::Default => 'd',\n+        hir::Defaultness::Final => 'f',\n+    };\n+    rbml_w.wr_tagged_u8(tag_items_data_item_defaultness, ch as u8);\n+}\n+\n fn encode_explicit_self(rbml_w: &mut Encoder,\n                         explicit_self: &ty::ExplicitSelfCategory) {\n     let tag = tag_item_trait_method_explicit_self;\n@@ -674,6 +683,7 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n+        encode_defaultness(rbml_w, ii.defaultness);\n         encode_inlined_item(ecx,\n                             rbml_w,\n                             InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n@@ -725,6 +735,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                                              impl_item));\n             }\n             encode_constness(rbml_w, sig.constness);\n+            encode_defaultness(rbml_w, impl_item.defaultness);\n             if !any_types {\n                 let m_id = ecx.local_id(m.def_id);\n                 encode_symbol(ecx, rbml_w, m_id);\n@@ -767,6 +778,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n+        encode_defaultness(rbml_w, ii.defaultness);\n     } else {\n         encode_predicates(rbml_w, ecx, index,\n                           &ecx.tcx.lookup_predicates(associated_type.def_id),\n@@ -873,6 +885,12 @@ fn encode_deprecation(rbml_w: &mut Encoder, depr_opt: Option<attr::Deprecation>)\n     });\n }\n \n+fn encode_parent_impl(rbml_w: &mut Encoder, parent_opt: Option<DefId>) {\n+    parent_opt.map(|parent| {\n+        rbml_w.wr_tagged_u64(tag_items_data_parent_impl, def_to_u64(parent));\n+    });\n+}\n+\n fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n                           xrefs: FnvHashMap<XRef<'tcx>, u32>)\n@@ -1150,8 +1168,19 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             }\n             rbml_w.end_tag();\n         }\n-        if let Some(trait_ref) = tcx.impl_trait_ref(ecx.tcx.map.local_def_id(item.id)) {\n+        let did = ecx.tcx.map.local_def_id(item.id);\n+        if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n             encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n+\n+            let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n+            let parent = trait_def.ancestors(did)\n+                .skip(1)\n+                .next()\n+                .and_then(|node| match node {\n+                    specialization_graph::Node::Impl(parent) => Some(parent),\n+                    _ => None,\n+                });\n+            encode_parent_impl(rbml_w, parent);\n         }\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);"}, {"sha": "13521de78af28edd54fe9ca4440d04740887c7ce", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -27,6 +27,7 @@ use hair::cx::Cx;\n use rustc::mir::mir_map::MirMap;\n use rustc::middle::infer;\n use rustc::middle::region::CodeExtentData;\n+use rustc::middle::traits::ProjectionMode;\n use rustc::middle::ty::{self, Ty, TyCtxt};\n use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n@@ -137,7 +138,11 @@ impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n         };\n \n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env));\n+        let infcx = infer::new_infer_ctxt(self.tcx,\n+                                          &self.tcx.tables,\n+                                          Some(param_env),\n+                                          ProjectionMode::AnyFinal);\n+\n         match build_mir(Cx::new(&infcx), implicit_arg_tys, id, span, decl, body) {\n             Ok(mir) => assert!(self.map.map.insert(id, mir).is_none()),\n             Err(ErrorReported) => {}"}, {"sha": "d99e6ff4bf55de40e53fd87fe34b594b44a8d795", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -13,7 +13,7 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::middle::infer::{self, InferCtxt};\n-use rustc::middle::traits;\n+use rustc::middle::traits::{self, ProjectionMode};\n use rustc::middle::ty::fold::TypeFoldable;\n use rustc::middle::ty::{self, Ty, TyCtxt};\n use rustc::mir::repr::*;\n@@ -582,7 +582,10 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n         }\n         let _task = tcx.dep_graph.in_task(DepNode::MirTypeck(id));\n         let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n+        let infcx = infer::new_infer_ctxt(tcx,\n+                                          &tcx.tables,\n+                                          Some(param_env),\n+                                          ProjectionMode::AnyFinal);\n         let mut checker = TypeChecker::new(&infcx);\n         {\n             let mut verifier = TypeVerifier::new(&mut checker, mir);"}, {"sha": "6be7f6c200247a01abd0fefdb2bd35d62a5cefe5", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -35,8 +35,8 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n-use rustc::middle::traits;\n use rustc::middle::ty::{self, Ty, TyCtxt};\n+use rustc::middle::traits::{self, ProjectionMode};\n use rustc::util::nodemap::NodeMap;\n use rustc::middle::const_qualif::ConstQualif;\n use rustc::lint::builtin::CONST_ERR;\n@@ -92,7 +92,10 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             None => self.tcx.empty_parameter_environment()\n         };\n \n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env));\n+        let infcx = infer::new_infer_ctxt(self.tcx,\n+                                          &self.tcx.tables,\n+                                          Some(param_env),\n+                                          ProjectionMode::AnyFinal);\n \n         f(&mut euv::ExprUseVisitor::new(self, &infcx))\n     }\n@@ -247,7 +250,10 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     fn check_static_type(&self, e: &hir::Expr) {\n         let ty = self.tcx.node_id_to_type(e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n+        let infcx = infer::new_infer_ctxt(self.tcx,\n+                                          &self.tcx.tables,\n+                                          None,\n+                                          ProjectionMode::AnyFinal);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n         fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);"}, {"sha": "88048b514e1f50784c5f0f5b9840ac93a52fa729", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -16,6 +16,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::ty::{self, TyCtxt, ParameterEnvironment};\n+use rustc::middle::traits::ProjectionMode;\n \n use rustc_front::hir;\n use rustc_front::intravisit;\n@@ -43,7 +44,8 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n             let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n             let infcx = infer::new_infer_ctxt(self.tcx,\n                                               &self.tcx.tables,\n-                                              Some(param_env.clone()));\n+                                              Some(param_env.clone()),\n+                                              ProjectionMode::AnyFinal);\n             let mut delegate = RvalueContextDelegate { tcx: self.tcx, param_env: &param_env };\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n             euv.walk_fn(fd, b);"}, {"sha": "f5fbec0b1879e65653e4e9e4660e73f7d4781aca", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -217,6 +217,7 @@ use trans::tvec;\n use trans::type_of;\n use trans::Disr;\n use middle::ty::{self, Ty, TyCtxt};\n+use middle::traits::ProjectionMode;\n use session::config::NoDebugInfo;\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n@@ -1475,7 +1476,9 @@ fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool\n         reassigned: false\n     };\n     {\n-        let infcx = infer::normalizing_infer_ctxt(bcx.tcx(), &bcx.tcx().tables);\n+        let infcx = infer::normalizing_infer_ctxt(bcx.tcx(),\n+                                                  &bcx.tcx().tables,\n+                                                  ProjectionMode::Any);\n         let mut visitor = euv::ExprUseVisitor::new(&mut rc, &infcx);\n         visitor.walk_expr(body);\n     }"}, {"sha": "d93d32f8e0d068b327fc411d397372d3cb800403", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -13,6 +13,7 @@ use libc::{c_uint, c_ulonglong};\n use llvm::{self, ValueRef, AttrHelper};\n use middle::ty;\n use middle::infer;\n+use middle::traits::ProjectionMode;\n use session::config::NoDebugInfo;\n use syntax::abi::Abi;\n pub use syntax::attr::InlineAttr;\n@@ -133,7 +134,9 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n     let (fn_sig, abi, env_ty) = match fn_type.sty {\n         ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => (&f.sig, f.abi, None),\n         ty::TyClosure(closure_did, ref substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(),\n+                                                      &ccx.tcx().tables,\n+                                                      ProjectionMode::Any);\n             function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n             (&function_type.sig, Abi::RustCall, Some(self_type))"}, {"sha": "11c03fe7a7dc7b87eeb4637191671925009f96fd", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -13,6 +13,7 @@ use back::link::{self, mangle_internal_name_by_path_and_seq};\n use llvm::{ValueRef, get_params};\n use middle::def_id::DefId;\n use middle::infer;\n+use middle::traits::ProjectionMode;\n use trans::adt;\n use trans::attributes;\n use trans::base::*;\n@@ -206,7 +207,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // this function (`trans_closure`) is invoked at the point\n     // of the closure expression.\n \n-    let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+    let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables, ProjectionMode::Any);\n     let function_type = infcx.closure_type(closure_def_id, closure_substs);\n \n     let freevars: Vec<ty::Freevar> =\n@@ -329,7 +330,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n            ccx.tn().val_to_string(llreffn));\n \n     let tcx = ccx.tcx();\n-    let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+    let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables, ProjectionMode::Any);\n \n     // Find a version of the closure type. Substitute static for the\n     // region since it doesn't really matter."}, {"sha": "cea97c1a1e77fc854cdc006a3a64f22580b90863", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -819,10 +819,11 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             nested: _ }) =>\n         {\n             let callee_substs = impl_substs.with_method_from(&rcvr_substs);\n-            let impl_method = tcx.get_impl_method(impl_did,\n-                                                  tcx.mk_substs(callee_substs),\n-                                                  trait_method.name);\n-            Some((impl_method.method.def_id, impl_method.substs))\n+            let impl_method = meth::get_impl_method(tcx,\n+                                                    impl_did,\n+                                                    tcx.mk_substs(callee_substs),\n+                                                    trait_method.name);\n+            Some((impl_method.method.def_id, &impl_method.substs))\n         }\n         // If we have a closure or a function pointer, we will also encounter\n         // the concrete closure/function somewhere else (during closure or fn\n@@ -982,7 +983,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             if can_have_local_instance(ccx, impl_method.method.def_id) {\n                                 Some(create_fn_trans_item(ccx,\n                                                           impl_method.method.def_id,\n-                                                          impl_method.substs,\n+                                                          &impl_method.substs,\n                                                           &Substs::trans_empty()))\n                             } else {\n                                 None\n@@ -1160,13 +1161,14 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n                     // The substitutions we have are on the impl, so we grab\n                     // the method type from the impl to substitute into.\n-                    let mth = tcx.get_impl_method(impl_def_id,\n-                                                  callee_substs,\n-                                                  default_impl.name);\n+                    let mth = meth::get_impl_method(tcx,\n+                                                    impl_def_id,\n+                                                    callee_substs,\n+                                                    default_impl.name);\n \n                     assert!(mth.is_provided);\n \n-                    let predicates = mth.method.predicates.predicates.subst(tcx, mth.substs);\n+                    let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n                     if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                         continue;\n                     }"}, {"sha": "0aa69dec253a1b7eb6713059788ab7b587abddae", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -37,8 +37,8 @@ use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n-use middle::traits;\n use middle::ty::{self, Ty, TyCtxt};\n+use middle::traits::{self, SelectionContext, ProjectionMode};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use rustc_front::hir;\n use rustc::mir::repr::Mir;\n@@ -1137,8 +1137,8 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n-    let mut selcx = traits::SelectionContext::new(&infcx);\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n+    let mut selcx = SelectionContext::new(&infcx);\n \n     let obligation =\n         traits::Obligation::new(traits::ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n@@ -1198,8 +1198,8 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            predicates);\n \n     let tcx = ccx.tcx();\n-    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n-    let mut selcx = traits::SelectionContext::new(&infcx);\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n+    let mut selcx = SelectionContext::new(&infcx);\n     let mut fulfill_cx = traits::FulfillmentContext::new();\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: predicates, obligations } ="}, {"sha": "0c512200ff3d560ad19708b950e7978896340568", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -22,6 +22,7 @@\n use llvm::{self, ValueRef};\n use middle::ty;\n use middle::infer;\n+use middle::traits::ProjectionMode;\n use syntax::abi::Abi;\n use trans::attributes;\n use trans::base;\n@@ -111,7 +112,9 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n             (&f.sig, f.abi, None)\n         }\n         ty::TyClosure(closure_did, ref substs) => {\n-            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n+            let infcx = infer::normalizing_infer_ctxt(ccx.tcx(),\n+                                                      &ccx.tcx().tables,\n+                                                      ProjectionMode::Any);\n             function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);\n             let llenvironment_type = type_of::type_of_explicit_arg(ccx, self_type);"}, {"sha": "7397ccc2505f173a3d984591ad7f9ad5645fdfc4", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -8,14 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::rc::Rc;\n+\n use arena::TypedArena;\n use back::link;\n use llvm::{ValueRef, get_params};\n use middle::def_id::DefId;\n use middle::infer;\n use middle::subst::{Subst, Substs};\n use middle::subst;\n-use middle::traits;\n+use middle::traits::{self, ProjectionMode};\n use trans::base::*;\n use trans::build::*;\n use trans::callee::{Callee, Virtual, ArgVals,\n@@ -31,9 +33,9 @@ use trans::glue;\n use trans::machine;\n use trans::type_::Type;\n use trans::type_of::*;\n-use middle::ty::{self, Ty, TyCtxt};\n+use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n-use syntax::ast;\n+use syntax::ast::{self, Name};\n use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n \n@@ -107,7 +109,7 @@ pub fn callee_for_trait_impl<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // those from the impl and those from the method:\n             let impl_substs = vtable_impl.substs.with_method_from(&substs);\n             let substs = ccx.tcx().mk_substs(impl_substs);\n-            let mth = ccx.tcx().get_impl_method(impl_did, substs, mname);\n+            let mth = get_impl_method(ccx.tcx(), impl_did, substs, mname);\n \n             // Translate the function, bypassing Callee::def.\n             // That is because default methods have the same ID as the\n@@ -315,7 +317,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 trans_fn_ref_with_substs(ccx,\n                                                          mth.method.def_id,\n                                                          None,\n-                                                         mth.substs).val\n+                                                         &mth.substs).val\n                             }\n                             None => nullptr\n                         }\n@@ -378,7 +380,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     impl_id: DefId,\n                                     substs: &'tcx subst::Substs<'tcx>)\n-                                    -> Vec<Option<ty::util::ImplMethod<'tcx>>>\n+                                    -> Vec<Option<ImplMethod<'tcx>>>\n {\n     let tcx = ccx.tcx();\n \n@@ -428,7 +430,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             // The substitutions we have are on the impl, so we grab\n             // the method type from the impl to substitute into.\n-            let mth = tcx.get_impl_method(impl_id, substs, name);\n+            let mth = get_impl_method(tcx, impl_id, substs, name);\n \n             debug!(\"get_vtable_methods: mth={:?}\", mth);\n \n@@ -438,7 +440,7 @@ pub fn get_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // method could then never be called, so we do not want to\n             // try and trans it, in that case. Issue #23435.\n             if mth.is_provided {\n-                let predicates = mth.method.predicates.predicates.subst(tcx, mth.substs);\n+                let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n                 if !normalize_and_test_predicates(ccx, predicates.into_vec()) {\n                     debug!(\"get_vtable_methods: predicates do not hold\");\n                     return None;\n@@ -466,3 +468,37 @@ fn opaque_method_ty<'tcx>(tcx: &TyCtxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n         }),\n     })\n }\n+\n+#[derive(Debug)]\n+pub struct ImplMethod<'tcx> {\n+    pub method: Rc<ty::Method<'tcx>>,\n+    pub substs: &'tcx Substs<'tcx>,\n+    pub is_provided: bool\n+}\n+\n+/// Locates the applicable definition of a method, given its name.\n+pub fn get_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n+                             impl_def_id: DefId,\n+                             substs: &'tcx Substs<'tcx>,\n+                             name: Name)\n+                             -> ImplMethod<'tcx>\n+{\n+    assert!(!substs.types.needs_infer());\n+\n+    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+    let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Any);\n+\n+    match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n+        Some(node_item) => {\n+            ImplMethod {\n+                method: node_item.item,\n+                substs: traits::translate_substs(&infcx, impl_def_id, substs, node_item.node),\n+                is_provided: node_item.node.is_from_trait(),\n+            }\n+        }\n+        None => {\n+            tcx.sess.bug(&format!(\"method {:?} not found in {:?}\", name, impl_def_id))\n+        }\n+    }\n+}"}, {"sha": "899f79b3dff94f1dd1729ee231d2f9001b27484a", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -10,8 +10,8 @@\n \n use middle::free_region::FreeRegionMap;\n use middle::infer::{self, TypeOrigin};\n-use middle::traits;\n use middle::ty::{self, TyCtxt};\n+use middle::traits::{self, ProjectionMode};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace};\n \n use syntax::ast;\n@@ -42,7 +42,7 @@ pub fn compare_impl_method<'tcx>(tcx: &TyCtxt<'tcx>,\n     debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n            impl_trait_ref);\n \n-    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n@@ -416,7 +416,7 @@ pub fn compare_const_impl<'tcx>(tcx: &TyCtxt<'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n     // The below is for the most part highly similar to the procedure"}, {"sha": "4ed1bab46b2d9664be25848b6434d736ff6fe5f6", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -15,8 +15,8 @@ use middle::free_region::FreeRegionMap;\n use middle::infer;\n use middle::region;\n use middle::subst::{self, Subst};\n-use middle::traits;\n use middle::ty::{self, Ty, TyCtxt};\n+use middle::traits::{self, ProjectionMode};\n use util::nodemap::FnvHashSet;\n \n use syntax::ast;\n@@ -82,7 +82,10 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     // check that the impl type can be made to match the trait type.\n \n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(impl_param_env));\n+    let infcx = infer::new_infer_ctxt(tcx,\n+                                      &tcx.tables,\n+                                      Some(impl_param_env),\n+                                      ProjectionMode::AnyFinal);\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n     let named_type = tcx.lookup_item_type(self_type_did).ty;"}, {"sha": "0d5e25efd68c91b93f88f37c0ba5c03d4e470e55", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 94, "deletions": 49, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -92,7 +92,7 @@ use middle::infer;\n use middle::infer::{TypeOrigin, TypeTrace, type_variable};\n use middle::pat_util::{self, pat_id_map};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n-use middle::traits::{self, report_fulfillment_errors};\n+use middle::traits::{self, report_fulfillment_errors, ProjectionMode};\n use middle::ty::{GenericPredicates, TypeScheme};\n use middle::ty::{ParamTy, ParameterEnvironment};\n use middle::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n@@ -307,7 +307,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n            -> Inherited<'a, 'tcx> {\n \n         Inherited {\n-            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env)),\n+            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env), ProjectionMode::AnyFinal),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n             locals: RefCell::new(NodeMap()),\n             tables: tables,\n@@ -672,10 +672,12 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemFn(..) => {} // entirely within check_item_body\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n-          match ccx.tcx.impl_trait_ref(ccx.tcx.map.local_def_id(it.id)) {\n+          let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n+          match ccx.tcx.impl_trait_ref(impl_def_id) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n                                                it.span,\n+                                               impl_def_id,\n                                                &impl_trait_ref,\n                                                impl_items);\n               }\n@@ -862,12 +864,71 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n }\n \n+fn report_forbidden_specialization(tcx: &TyCtxt,\n+                                   impl_item: &hir::ImplItem,\n+                                   parent_impl: DefId)\n+{\n+    let mut err = struct_span_err!(\n+        tcx.sess, impl_item.span, E0520,\n+        \"item `{}` is provided by an `impl` that specializes \\\n+         another, but the item in the parent `impl` is not \\\n+         marked `default` and so it cannot be specialized.\",\n+        impl_item.name);\n+\n+    match tcx.span_of_impl(parent_impl) {\n+        Ok(span) => {\n+            err.span_note(span, \"parent implementation is here:\");\n+        }\n+        Err(cname) => {\n+            err.note(&format!(\"parent implementation is in crate `{}`\", cname));\n+        }\n+    }\n+\n+    err.emit();\n+}\n+\n+fn check_specialization_validity<'tcx>(tcx: &TyCtxt<'tcx>, trait_def: &ty::TraitDef<'tcx>,\n+                                       impl_id: DefId, impl_item: &hir::ImplItem)\n+{\n+    let ancestors = trait_def.ancestors(impl_id);\n+\n+    let parent = match impl_item.node {\n+        hir::ImplItemKind::Const(..) => {\n+            ancestors.const_defs(tcx, impl_item.name).skip(1).next()\n+                .map(|node_item| node_item.map(|parent| parent.defaultness))\n+        }\n+        hir::ImplItemKind::Method(..) => {\n+            ancestors.fn_defs(tcx, impl_item.name).skip(1).next()\n+                .map(|node_item| node_item.map(|parent| parent.defaultness))\n+\n+        }\n+        hir::ImplItemKind::Type(_) => {\n+            ancestors.type_defs(tcx, impl_item.name).skip(1).next()\n+                .map(|node_item| node_item.map(|parent| parent.defaultness))\n+        }\n+    };\n+\n+    if let Some(parent) = parent {\n+        if parent.item.is_final() {\n+            report_forbidden_specialization(tcx, impl_item, parent.node.def_id());\n+        }\n+    }\n+\n+}\n+\n fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n+                                            impl_id: DefId,\n                                             impl_trait_ref: &ty::TraitRef<'tcx>,\n                                             impl_items: &[hir::ImplItem]) {\n-    // Locate trait methods\n+    // If the trait reference itself is erroneous (so the compilation is going\n+    // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n+    // isn't populated for such impls.\n+    if impl_trait_ref.references_error() { return; }\n+\n+    // Locate trait definition and items\n     let tcx = ccx.tcx;\n+    let trait_def = tcx.lookup_trait_def(impl_trait_ref.def_id);\n     let trait_items = tcx.trait_items(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n@@ -878,6 +939,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let ty_trait_item = trait_items.iter()\n             .find(|ac| ac.name() == ty_impl_item.name());\n \n+        // Check that impl definition matches trait definition\n         if let Some(ty_trait_item) = ty_trait_item {\n             match impl_item.node {\n                 hir::ImplItemKind::Const(..) => {\n@@ -944,6 +1006,8 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 }\n             }\n         }\n+\n+        check_specialization_validity(tcx, trait_def, impl_id, impl_item);\n     }\n \n     // Check for missing items from trait\n@@ -952,63 +1016,44 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let mut invalidated_items = Vec::new();\n     let associated_type_overridden = overridden_associated_type.is_some();\n     for trait_item in trait_items.iter() {\n+        let is_implemented;\n+        let is_provided;\n+\n         match *trait_item {\n             ty::ConstTraitItem(ref associated_const) => {\n-                let is_implemented = impl_items.iter().any(|ii| {\n+                is_provided = associated_const.has_value;\n+                is_implemented = impl_items.iter().any(|ii| {\n                     match ii.node {\n                         hir::ImplItemKind::Const(..) => {\n                             ii.name == associated_const.name\n                         }\n                         _ => false,\n                     }\n                 });\n-                let is_provided = associated_const.has_value;\n-\n-                if !is_implemented {\n-                    if !is_provided {\n-                        missing_items.push(associated_const.name);\n-                    } else if associated_type_overridden {\n-                        invalidated_items.push(associated_const.name);\n-                    }\n-                }\n             }\n             ty::MethodTraitItem(ref trait_method) => {\n-                let is_implemented =\n-                    impl_items.iter().any(|ii| {\n-                        match ii.node {\n-                            hir::ImplItemKind::Method(..) => {\n-                                ii.name == trait_method.name\n-                            }\n-                            _ => false,\n-                        }\n-                    });\n-                let is_provided =\n-                    provided_methods.iter().any(|m| m.name == trait_method.name);\n-                if !is_implemented {\n-                    if !is_provided {\n-                        missing_items.push(trait_method.name);\n-                    } else if associated_type_overridden {\n-                        invalidated_items.push(trait_method.name);\n-                    }\n-                }\n+                is_provided = provided_methods.iter().any(|m| m.name == trait_method.name);\n+                is_implemented = trait_def.ancestors(impl_id)\n+                    .fn_defs(tcx, trait_method.name)\n+                    .next()\n+                    .map(|node_item| !node_item.node.is_from_trait())\n+                    .unwrap_or(false);\n             }\n-            ty::TypeTraitItem(ref associated_type) => {\n-                let is_implemented = impl_items.iter().any(|ii| {\n-                    match ii.node {\n-                        hir::ImplItemKind::Type(_) => {\n-                            ii.name == associated_type.name\n-                        }\n-                        _ => false,\n-                    }\n-                });\n-                let is_provided = associated_type.ty.is_some();\n-                if !is_implemented {\n-                    if !is_provided {\n-                        missing_items.push(associated_type.name);\n-                    } else if associated_type_overridden {\n-                        invalidated_items.push(associated_type.name);\n-                    }\n-                }\n+            ty::TypeTraitItem(ref trait_assoc_ty) => {\n+                is_provided = trait_assoc_ty.ty.is_some();\n+                is_implemented = trait_def.ancestors(impl_id)\n+                    .type_defs(tcx, trait_assoc_ty.name)\n+                    .next()\n+                    .map(|node_item| !node_item.node.is_from_trait())\n+                    .unwrap_or(false);\n+            }\n+        }\n+\n+        if !is_implemented {\n+            if !is_provided {\n+                missing_items.push(trait_item.name());\n+            } else if associated_type_overridden {\n+                invalidated_items.push(trait_item.name());\n             }\n         }\n     }"}, {"sha": "278d4d8b5b44a41fa378e5e0602babfd408d7821", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -15,12 +15,11 @@\n // done by the orphan and overlap modules. Then we build up various\n // mappings. That mapping code resides here.\n \n-\n use middle::def_id::DefId;\n use middle::lang_items::UnsizeTraitLangItem;\n use middle::subst::{self, Subst};\n-use middle::traits;\n use middle::ty::{self, TyCtxt, TypeFoldable};\n+use middle::traits::{self, ProjectionMode};\n use middle::ty::{ImplOrTraitItemId, ConstTraitItemId};\n use middle::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n use middle::ty::{Ty, TyBool, TyChar, TyEnum, TyError};\n@@ -197,7 +196,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n                impl_trait_ref, impl_def_id);\n         let trait_def = self.crate_context.tcx.lookup_trait_def(impl_trait_ref.def_id);\n-        trait_def.record_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n+        trait_def.record_local_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n \n     // Converts an implementation in the AST to a vector of items.\n@@ -385,7 +384,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n                    source, target);\n \n-            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n+            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env), ProjectionMode::Topmost);\n \n             let origin = TypeOrigin::Misc(span);\n             let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>, mt_b: ty::TypeAndMut<'tcx>,\n@@ -530,7 +529,10 @@ pub fn report_duplicate_item<'tcx>(tcx: &TyCtxt<'tcx>, sp: Span, name: ast::Name\n \n pub fn check_coherence(crate_context: &CrateCtxt) {\n     let _task = crate_context.tcx.dep_graph.in_task(DepNode::Coherence);\n-    let infcx = new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None);\n+    let infcx = new_infer_ctxt(crate_context.tcx,\n+                               &crate_context.tcx.tables,\n+                               None,\n+                               ProjectionMode::Topmost);\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: infcx,"}, {"sha": "f7fa3e1b1429aa0c02773cfe70ef9f7732f90fd5", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 79, "deletions": 166, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -12,21 +12,20 @@\n //! same type. Likewise, no two inherent impls for a given type\n //! constructor provide a method with the same name.\n \n-use middle::cstore::{CrateStore, LOCAL_CRATE};\n+use middle::cstore::CrateStore;\n use middle::def_id::DefId;\n-use middle::traits;\n-use middle::ty::{self, TyCtxt};\n+use middle::traits::{self, ProjectionMode};\n use middle::infer;\n+use middle::ty::{self, TyCtxt};\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc::dep_graph::DepNode;\n use rustc_front::hir;\n use rustc_front::intravisit;\n-use util::nodemap::{DefIdMap, DefIdSet};\n+use util::nodemap::DefIdMap;\n \n pub fn check(tcx: &TyCtxt) {\n     let mut overlap = OverlapChecker { tcx: tcx,\n-                                       traits_checked: DefIdSet(),\n                                        default_impls: DefIdMap() };\n \n     // this secondary walk specifically checks for some other cases,\n@@ -37,134 +36,11 @@ pub fn check(tcx: &TyCtxt) {\n struct OverlapChecker<'cx, 'tcx:'cx> {\n     tcx: &'cx TyCtxt<'tcx>,\n \n-    // The set of traits where we have checked for overlap.  This is\n-    // used to avoid checking the same trait twice.\n-    //\n-    // NB. It's ok to skip tracking this set because we fully\n-    // encapsulate it, and we always create a task\n-    // (`CoherenceOverlapCheck`) corresponding to each entry.\n-    traits_checked: DefIdSet,\n-\n     // maps from a trait def-id to an impl id\n     default_impls: DefIdMap<ast::NodeId>,\n }\n \n impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n-    fn check_for_overlapping_impls_of_trait(&mut self, trait_def_id: DefId) {\n-        debug!(\"check_for_overlapping_impls_of_trait(trait_def_id={:?})\",\n-               trait_def_id);\n-\n-        let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n-        if !self.traits_checked.insert(trait_def_id) {\n-            return;\n-        }\n-\n-        let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n-        self.tcx.populate_implementations_for_trait_if_necessary(\n-            trait_def.trait_ref.def_id);\n-\n-        // We should already know all impls of this trait, so these\n-        // borrows are safe.\n-        let (blanket_impls, nonblanket_impls) = trait_def.borrow_impl_lists(self.tcx);\n-\n-        // Conflicts can only occur between a blanket impl and another impl,\n-        // or between 2 non-blanket impls of the same kind.\n-\n-        for (i, &impl1_def_id) in blanket_impls.iter().enumerate() {\n-            for &impl2_def_id in &blanket_impls[(i+1)..] {\n-                self.check_if_impls_overlap(impl1_def_id,\n-                                            impl2_def_id);\n-            }\n-\n-            for v in nonblanket_impls.values() {\n-                for &impl2_def_id in v {\n-                    self.check_if_impls_overlap(impl1_def_id,\n-                                                impl2_def_id);\n-                }\n-            }\n-        }\n-\n-        for impl_group in nonblanket_impls.values() {\n-            for (i, &impl1_def_id) in impl_group.iter().enumerate() {\n-                for &impl2_def_id in &impl_group[(i+1)..] {\n-                    self.check_if_impls_overlap(impl1_def_id,\n-                                                impl2_def_id);\n-                }\n-            }\n-        }\n-    }\n-\n-    // We need to coherently pick which impl will be displayed\n-    // as causing the error message, and it must be the in the current\n-    // crate. Just pick the smaller impl in the file.\n-    fn order_impls(&self, impl1_def_id: DefId, impl2_def_id: DefId)\n-            -> Option<(DefId, DefId)> {\n-        if impl1_def_id.krate != LOCAL_CRATE {\n-            if impl2_def_id.krate != LOCAL_CRATE {\n-                // we don't need to check impls if both are external;\n-                // that's the other crate's job.\n-                None\n-            } else {\n-                Some((impl2_def_id, impl1_def_id))\n-            }\n-        } else if impl2_def_id.krate != LOCAL_CRATE {\n-            Some((impl1_def_id, impl2_def_id))\n-        } else if impl1_def_id < impl2_def_id {\n-            Some((impl1_def_id, impl2_def_id))\n-        } else {\n-            Some((impl2_def_id, impl1_def_id))\n-        }\n-    }\n-\n-    fn check_if_impls_overlap(&self,\n-                              impl1_def_id: DefId,\n-                              impl2_def_id: DefId)\n-    {\n-        if let Some((impl1_def_id, impl2_def_id)) = self.order_impls(\n-            impl1_def_id, impl2_def_id)\n-        {\n-            debug!(\"check_if_impls_overlap({:?}, {:?})\",\n-                   impl1_def_id,\n-                   impl2_def_id);\n-\n-            let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n-            if let Some(header) = traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n-                self.report_overlap_error(impl1_def_id, impl2_def_id, header.trait_ref.unwrap());\n-            }\n-        }\n-    }\n-\n-    fn report_overlap_error(&self,\n-                            impl1: DefId,\n-                            impl2: DefId,\n-                            trait_ref: ty::TraitRef)\n-    {\n-        // only print the Self type if it's concrete; otherwise, it's not adding much information.\n-        let self_type = {\n-            trait_ref.substs.self_ty().and_then(|ty| {\n-                if let ty::TyInfer(_) = ty.sty {\n-                    None\n-                } else {\n-                    Some(format!(\" for type `{}`\", ty))\n-                }\n-            }).unwrap_or(String::new())\n-        };\n-\n-        let mut err = struct_span_err!(self.tcx.sess, self.span_of_def_id(impl1), E0119,\n-                                       \"conflicting implementations of trait `{}`{}:\",\n-                                       trait_ref,\n-                                       self_type);\n-\n-        if impl2.is_local() {\n-            span_note!(&mut err, self.span_of_def_id(impl2),\n-                       \"conflicting implementation is here:\");\n-        } else {\n-            let cname = self.tcx.sess.cstore.crate_name(impl2.krate);\n-            err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n-        }\n-        err.emit();\n-    }\n-\n     fn span_of_def_id(&self, did: DefId) -> Span {\n         let node_id = self.tcx.map.as_local_node_id(did).unwrap();\n         self.tcx.map.span(node_id)\n@@ -213,7 +89,10 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i+1)..] {\n-                let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n+                let infcx = infer::new_infer_ctxt(self.tcx,\n+                                                  &self.tcx.tables,\n+                                                  None,\n+                                                  ProjectionMode::Topmost);\n                 if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n                     self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n                 }\n@@ -222,15 +101,9 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     }\n }\n \n-\n impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemTrait(..) => {\n-                let trait_def_id = self.tcx.map.local_def_id(item.id);\n-                self.check_for_overlapping_impls_of_trait(trait_def_id);\n-            }\n-\n             hir::ItemEnum(..) | hir::ItemStruct(..) => {\n                 let type_def_id = self.tcx.map.local_def_id(item.id);\n                 self.check_for_overlapping_inherent_impls(type_def_id);\n@@ -243,50 +116,90 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 let impl_def_id = self.tcx.map.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n \n-                self.check_for_overlapping_impls_of_trait(trait_ref.def_id);\n-\n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n-                match prev_default_impl {\n-                    Some(prev_id) => {\n-                        self.report_overlap_error(impl_def_id,\n-                                                  self.tcx.map.local_def_id(prev_id),\n-                                                  trait_ref);\n-                    }\n-                    None => { }\n+                if let Some(prev_id) = prev_default_impl {\n+                    let mut err = struct_span_err!(\n+                        self.tcx.sess,\n+                        self.tcx.span_of_impl(impl_def_id).unwrap(), E0521,\n+                        \"redundant default implementations of trait `{}`:\",\n+                        trait_ref);\n+                    err.span_note(self.tcx.span_of_impl(self.tcx.map.local_def_id(prev_id))\n+                                      .unwrap(),\n+                                  \"redundant implementation is here:\");\n+                    err.emit();\n                 }\n             }\n             hir::ItemImpl(_, _, _, Some(_), _, _) => {\n                 let impl_def_id = self.tcx.map.local_def_id(item.id);\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n-                self.check_for_overlapping_impls_of_trait(trait_def_id);\n-                match trait_ref.self_ty().sty {\n-                    ty::TyTrait(ref data) => {\n-                        // This is something like impl Trait1 for Trait2. Illegal\n-                        // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n-                        if !traits::is_object_safe(self.tcx, data.principal_def_id()) {\n-                            // This is an error, but it will be\n-                            // reported by wfcheck.  Ignore it\n-                            // here. This is tested by\n-                            // `coherence-impl-trait-for-trait-object-safe.rs`.\n-                        } else {\n-                            let mut supertrait_def_ids =\n-                                traits::supertrait_def_ids(self.tcx, data.principal_def_id());\n-                            if supertrait_def_ids.any(|d| d == trait_def_id) {\n-                                span_err!(self.tcx.sess, item.span, E0371,\n-                                          \"the object type `{}` automatically \\\n-                                           implements the trait `{}`\",\n-                                          trait_ref.self_ty(),\n-                                          self.tcx.item_path_str(trait_def_id));\n+                let _task = self.tcx.dep_graph.in_task(\n+                    DepNode::CoherenceOverlapCheck(trait_def_id));\n+\n+                let def = self.tcx.lookup_trait_def(trait_def_id);\n+\n+                // attempt to insert into the specialization graph\n+                let insert_result = def.add_impl_for_specialization(self.tcx, impl_def_id);\n+\n+                // insertion failed due to overlap\n+                if let Err(overlap) = insert_result {\n+                    // only print the Self type if it has at least some outer\n+                    // concrete shell; otherwise, it's not adding much\n+                    // information.\n+                    let self_type = {\n+                        overlap.on_trait_ref.substs.self_ty().and_then(|ty| {\n+                            if ty.has_concrete_skeleton() {\n+                                Some(format!(\" for type `{}`\", ty))\n+                            } else {\n+                                None\n                             }\n+                        }).unwrap_or(String::new())\n+                    };\n+\n+                    let mut err = struct_span_err!(\n+                        self.tcx.sess, self.tcx.span_of_impl(impl_def_id).unwrap(), E0119,\n+                        \"conflicting implementations of trait `{}`{}:\",\n+                        overlap.on_trait_ref,\n+                        self_type);\n+\n+                    match self.tcx.span_of_impl(overlap.with_impl) {\n+                        Ok(span) => {\n+                            err.span_note(span, \"conflicting implementation is here:\");\n+                        }\n+                        Err(cname) => {\n+                            err.note(&format!(\"conflicting implementation in crate `{}`\",\n+                                              cname));\n+                        }\n+                    }\n+\n+                    err.emit();\n+                }\n+\n+                // check for overlap with the automatic `impl Trait for Trait`\n+                if let ty::TyTrait(ref data) = trait_ref.self_ty().sty {\n+                    // This is something like impl Trait1 for Trait2. Illegal\n+                    // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n+\n+                    if !traits::is_object_safe(self.tcx, data.principal_def_id()) {\n+                        // This is an error, but it will be\n+                        // reported by wfcheck.  Ignore it\n+                        // here. This is tested by\n+                        // `coherence-impl-trait-for-trait-object-safe.rs`.\n+                    } else {\n+                        let mut supertrait_def_ids =\n+                            traits::supertrait_def_ids(self.tcx, data.principal_def_id());\n+                        if supertrait_def_ids.any(|d| d == trait_def_id) {\n+                            span_err!(self.tcx.sess, item.span, E0371,\n+                                      \"the object type `{}` automatically \\\n+                                       implements the trait `{}`\",\n+                                      trait_ref.self_ty(),\n+                                      self.tcx.item_path_str(trait_def_id));\n                         }\n                     }\n-                    _ => { }\n                 }\n             }\n-            _ => {\n-            }\n+            _ => {}\n         }\n     }\n }"}, {"sha": "0f88640b629510040efdab8a9fa7c1c9638a7f17", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -533,6 +533,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             id: ast::NodeId,\n                             vis: hir::Visibility,\n                             sig: &hir::MethodSig,\n+                            defaultness: hir::Defaultness,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n                             rcvr_ty_generics: &ty::Generics<'tcx>,\n                             rcvr_ty_predicates: &ty::GenericPredicates<'tcx>) {\n@@ -554,6 +555,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     fty,\n                                     explicit_self_category,\n                                     vis,\n+                                    defaultness,\n                                     def_id,\n                                     container);\n \n@@ -600,6 +602,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                       name: ast::Name,\n                                       id: ast::NodeId,\n                                       vis: hir::Visibility,\n+                                      defaultness: hir::Defaultness,\n                                       ty: ty::Ty<'tcx>,\n                                       has_value: bool)\n {\n@@ -611,6 +614,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let associated_const = Rc::new(ty::AssociatedConst {\n         name: name,\n         vis: vis,\n+        defaultness: defaultness,\n         def_id: ccx.tcx.map.local_def_id(id),\n         container: container,\n         ty: ty,\n@@ -625,11 +629,13 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      name: ast::Name,\n                                      id: ast::NodeId,\n                                      vis: hir::Visibility,\n+                                     defaultness: hir::Defaultness,\n                                      ty: Option<Ty<'tcx>>)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: name,\n         vis: vis,\n+        defaultness: defaultness,\n         ty: ty,\n         def_id: ccx.tcx.map.local_def_id(id),\n         container: container\n@@ -767,6 +773,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     convert_associated_const(ccx, ImplContainer(def_id),\n                                              impl_item.name, impl_item.id,\n                                              impl_item.vis.inherit_from(parent_visibility),\n+                                             impl_item.defaultness,\n                                              ty, true /* has_value */);\n                 }\n             }\n@@ -783,7 +790,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     convert_associated_type(ccx, ImplContainer(def_id),\n                                             impl_item.name, impl_item.id, impl_item.vis,\n-                                            Some(typ));\n+                                            impl_item.defaultness, Some(typ));\n                 }\n             }\n \n@@ -797,7 +804,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                     convert_method(ccx, ImplContainer(def_id),\n                                    impl_item.name, impl_item.id, method_vis,\n-                                   sig, selfty, &ty_generics, &ty_predicates);\n+                                   sig, impl_item.defaultness, selfty, &ty_generics,\n+                                   &ty_predicates);\n                 }\n             }\n \n@@ -831,6 +839,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                              trait_item.name,\n                                              trait_item.id,\n                                              hir::Public,\n+                                             hir::Defaultness::Default,\n                                              ty,\n                                              default.is_some())\n                 }\n@@ -848,6 +857,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                             trait_item.name,\n                                             trait_item.id,\n                                             hir::Public,\n+                                            hir::Defaultness::Default,\n                                             typ);\n                 }\n             }\n@@ -861,6 +871,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                    trait_item.id,\n                                    hir::Inherited,\n                                    sig,\n+                                   hir::Defaultness::Default,\n                                    tcx.mk_self_type(),\n                                    &trait_def.generics,\n                                    &trait_predicates);"}, {"sha": "19cfc13ea615c03ca237e15bd951107693a11d05", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -3695,5 +3695,7 @@ register_diagnostics! {\n     E0399, // trait items need to be implemented because the associated\n            // type `{}` was overridden\n     E0436, // functional record update requires a struct\n-    E0513  // no type for local variable ..\n+    E0513, // no type for local variable ..\n+    E0520, // cannot specialize non-default item\n+    E0521  // redundant default implementations of trait\n }"}, {"sha": "936be8091940679db53387c4537e2612cfc93b20", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -106,6 +106,7 @@ use middle::def::Def;\n use middle::infer::{self, TypeOrigin};\n use middle::subst::Substs;\n use middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use middle::traits::ProjectionMode;\n use session::{config, CompileResult};\n use util::common::time;\n use rustc_front::hir;\n@@ -196,7 +197,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &TyCtxt<'tcx>,\n {\n     let result = match maybe_infcx {\n         None => {\n-            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n             infer::mk_eqty(&infcx, t1_is_expected, TypeOrigin::Misc(span), t1, t2)\n         }\n         Some(infcx) => {"}, {"sha": "c830fed5db9a71a0c70a87a500cc784c114cba52", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -1328,10 +1328,10 @@ pub struct MethodSig {\n     pub explicit_self: ExplicitSelf,\n }\n \n-/// Represents a method declaration in a trait declaration, possibly including\n-/// a default implementation. A trait method is either required (meaning it\n-/// doesn't have an implementation, just a signature) or provided (meaning it\n-/// has a default implementation).\n+/// Represents an item declaration within a trait declaration,\n+/// possibly including a default implementation. A trait item is\n+/// either required (meaning it doesn't have an implementation, just a\n+/// signature) or provided (meaning it has a default implementation).\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitItem {\n     pub id: NodeId,\n@@ -1353,6 +1353,7 @@ pub struct ImplItem {\n     pub id: NodeId,\n     pub ident: Ident,\n     pub vis: Visibility,\n+    pub defaultness: Defaultness,\n     pub attrs: Vec<Attribute>,\n     pub node: ImplItemKind,\n     pub span: Span,\n@@ -1654,6 +1655,12 @@ pub enum Constness {\n     NotConst,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum Defaultness {\n+    Default,\n+    Final,\n+}\n+\n impl fmt::Display for Unsafety {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(match *self {"}, {"sha": "5bfdab791d638a0b4d72e8324fcec42423fcaecc", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -1061,6 +1061,7 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n             ident: ii.ident,\n             attrs: ii.attrs,\n             vis: ii.vis,\n+            defaultness: ii.defaultness,\n             node: match ii.node  {\n                 ast::ImplItemKind::Method(sig, body) => {\n                     let (sig, body) = expand_and_rename_method(sig, body, fld);"}, {"sha": "fbaf28332c42c5dd475910ca8f99759052a8581c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -247,7 +247,10 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n     (\"inclusive_range_syntax\", \"1.7.0\", Some(28237), Active),\n \n     // `expr?`\n-    (\"question_mark\", \"1.9.0\", Some(31436), Active)\n+    (\"question_mark\", \"1.9.0\", Some(31436), Active),\n+\n+    // impl specialization (RFC 1210)\n+    (\"specialization\", \"1.7.0\", Some(31844), Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -574,6 +577,7 @@ pub struct Features {\n     pub stmt_expr_attributes: bool,\n     pub deprecated: bool,\n     pub question_mark: bool,\n+    pub specialization: bool,\n }\n \n impl Features {\n@@ -608,6 +612,7 @@ impl Features {\n             stmt_expr_attributes: false,\n             deprecated: false,\n             question_mark: false,\n+            specialization: false,\n         }\n     }\n }\n@@ -1102,6 +1107,12 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n+        if ii.defaultness == ast::Defaultness::Default {\n+            self.gate_feature(\"specialization\",\n+                              ii.span,\n+                              \"specialization is unstable\");\n+        }\n+\n         match ii.node {\n             ast::ImplItemKind::Const(..) => {\n                 self.gate_feature(\"associated_consts\",\n@@ -1212,6 +1223,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n         stmt_expr_attributes: cx.has_feature(\"stmt_expr_attributes\"),\n         deprecated: cx.has_feature(\"deprecated\"),\n         question_mark: cx.has_feature(\"question_mark\"),\n+        specialization: cx.has_feature(\"specialization\"),\n     }\n }\n "}, {"sha": "cd8998a211ae7491e37448ace64086a0609b136e", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -993,6 +993,7 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)\n         ident: folder.fold_ident(i.ident),\n         attrs: fold_attrs(i.attrs, folder),\n         vis: i.vis,\n+        defaultness: i.defaultness,\n         node: match i.node  {\n             ast::ImplItemKind::Const(ty, expr) => {\n                 ast::ImplItemKind::Const(folder.fold_ty(ty), folder.fold_expr(expr))"}, {"sha": "6839f11cd709d1113009b818ac3fb53b548cc886", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -18,7 +18,7 @@ use ast::{Mod, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n use ast::Block;\n use ast::{BlockCheckMode, CaptureBy};\n use ast::{Constness, Crate, CrateConfig};\n-use ast::{Decl, DeclKind};\n+use ast::{Decl, DeclKind, Defaultness};\n use ast::{EMPTY_CTXT, EnumDef, ExplicitSelf};\n use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n@@ -644,6 +644,25 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    pub fn check_contextual_keyword(&mut self, ident: Ident) -> bool {\n+        let tok = token::Ident(ident, token::Plain);\n+        self.expected_tokens.push(TokenType::Token(tok));\n+        if let token::Ident(ref cur_ident, _) = self.token {\n+            cur_ident.name == ident.name\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub fn eat_contextual_keyword(&mut self, ident: Ident) -> bool {\n+        if self.check_contextual_keyword(ident) {\n+            self.bump();\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// If the given word is not a keyword, signal an error.\n     /// If the next token is not the given word, signal an error.\n     /// Otherwise, eat it.\n@@ -705,7 +724,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-\n     /// Attempt to consume a `<`. If `<<` is seen, replace it with a single\n     /// `<` and continue. If a `<` is not seen, return false.\n     ///\n@@ -4846,6 +4864,7 @@ impl<'a> Parser<'a> {\n         let mut attrs = try!(self.parse_outer_attributes());\n         let lo = self.span.lo;\n         let vis = try!(self.parse_visibility());\n+        let defaultness = try!(self.parse_defaultness());\n         let (name, node) = if self.eat_keyword(keywords::Type) {\n             let name = try!(self.parse_ident());\n             try!(self.expect(&token::Eq));\n@@ -4872,6 +4891,7 @@ impl<'a> Parser<'a> {\n             span: mk_sp(lo, self.last_span.hi),\n             ident: name,\n             vis: vis,\n+            defaultness: defaultness,\n             attrs: attrs,\n             node: node\n         })\n@@ -5208,6 +5228,15 @@ impl<'a> Parser<'a> {\n         else { Ok(Visibility::Inherited) }\n     }\n \n+    /// Parse defaultness: DEFAULT or nothing\n+    fn parse_defaultness(&mut self) -> PResult<'a, Defaultness> {\n+        if self.eat_contextual_keyword(special_idents::DEFAULT) {\n+            Ok(Defaultness::Default)\n+        } else {\n+            Ok(Defaultness::Final)\n+        }\n+    }\n+\n     /// Given a termination token, parse all of the items in a module\n     fn parse_mod_items(&mut self, term: &token::Token, inner_lo: BytePos) -> PResult<'a, Mod> {\n         let mut items = vec![];"}, {"sha": "033ac9440bcecbc0e7802db682862155d5d74ebc", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -545,66 +545,67 @@ declare_special_idents_and_keywords! {\n         (9,                          __unused1,              \"<__unused1>\");\n         (super::SELF_TYPE_KEYWORD_NAME_NUM, type_self,       \"Self\");\n         (11,                         prelude_import,         \"prelude_import\");\n+        (12,                         DEFAULT,                \"default\");\n     }\n \n     pub mod keywords {\n         // These ones are variants of the Keyword enum\n \n         'strict:\n-        (12,                         As,         \"as\");\n-        (13,                         Break,      \"break\");\n-        (14,                         Crate,      \"crate\");\n-        (15,                         Else,       \"else\");\n-        (16,                         Enum,       \"enum\");\n-        (17,                         Extern,     \"extern\");\n-        (18,                         False,      \"false\");\n-        (19,                         Fn,         \"fn\");\n-        (20,                         For,        \"for\");\n-        (21,                         If,         \"if\");\n-        (22,                         Impl,       \"impl\");\n-        (23,                         In,         \"in\");\n-        (24,                         Let,        \"let\");\n-        (25,                         Loop,       \"loop\");\n-        (26,                         Match,      \"match\");\n-        (27,                         Mod,        \"mod\");\n-        (28,                         Move,       \"move\");\n-        (29,                         Mut,        \"mut\");\n-        (30,                         Pub,        \"pub\");\n-        (31,                         Ref,        \"ref\");\n-        (32,                         Return,     \"return\");\n+        (13,                         As,         \"as\");\n+        (14,                         Break,      \"break\");\n+        (15,                         Crate,      \"crate\");\n+        (16,                         Else,       \"else\");\n+        (17,                         Enum,       \"enum\");\n+        (18,                         Extern,     \"extern\");\n+        (19,                         False,      \"false\");\n+        (20,                         Fn,         \"fn\");\n+        (21,                         For,        \"for\");\n+        (22,                         If,         \"if\");\n+        (23,                         Impl,       \"impl\");\n+        (24,                         In,         \"in\");\n+        (25,                         Let,        \"let\");\n+        (26,                         Loop,       \"loop\");\n+        (27,                         Match,      \"match\");\n+        (28,                         Mod,        \"mod\");\n+        (29,                         Move,       \"move\");\n+        (30,                         Mut,        \"mut\");\n+        (31,                         Pub,        \"pub\");\n+        (32,                         Ref,        \"ref\");\n+        (33,                         Return,     \"return\");\n         // Static and Self are also special idents (prefill de-dupes)\n         (super::STATIC_KEYWORD_NAME_NUM, Static, \"static\");\n         (super::SELF_KEYWORD_NAME_NUM, SelfValue, \"self\");\n         (super::SELF_TYPE_KEYWORD_NAME_NUM, SelfType, \"Self\");\n-        (33,                         Struct,     \"struct\");\n+        (34,                         Struct,     \"struct\");\n         (super::SUPER_KEYWORD_NAME_NUM, Super,   \"super\");\n-        (34,                         True,       \"true\");\n-        (35,                         Trait,      \"trait\");\n-        (36,                         Type,       \"type\");\n-        (37,                         Unsafe,     \"unsafe\");\n-        (38,                         Use,        \"use\");\n-        (39,                         While,      \"while\");\n-        (40,                         Continue,   \"continue\");\n-        (41,                         Box,        \"box\");\n-        (42,                         Const,      \"const\");\n-        (43,                         Where,      \"where\");\n+        (35,                         True,       \"true\");\n+        (36,                         Trait,      \"trait\");\n+        (37,                         Type,       \"type\");\n+        (38,                         Unsafe,     \"unsafe\");\n+        (39,                         Use,        \"use\");\n+        (40,                         While,      \"while\");\n+        (41,                         Continue,   \"continue\");\n+        (42,                         Box,        \"box\");\n+        (43,                         Const,      \"const\");\n+        (44,                         Where,      \"where\");\n         'reserved:\n-        (44,                         Virtual,    \"virtual\");\n-        (45,                         Proc,       \"proc\");\n-        (46,                         Alignof,    \"alignof\");\n-        (47,                         Become,     \"become\");\n-        (48,                         Offsetof,   \"offsetof\");\n-        (49,                         Priv,       \"priv\");\n-        (50,                         Pure,       \"pure\");\n-        (51,                         Sizeof,     \"sizeof\");\n-        (52,                         Typeof,     \"typeof\");\n-        (53,                         Unsized,    \"unsized\");\n-        (54,                         Yield,      \"yield\");\n-        (55,                         Do,         \"do\");\n-        (56,                         Abstract,   \"abstract\");\n-        (57,                         Final,      \"final\");\n-        (58,                         Override,   \"override\");\n-        (59,                         Macro,      \"macro\");\n+        (45,                         Virtual,    \"virtual\");\n+        (46,                         Proc,       \"proc\");\n+        (47,                         Alignof,    \"alignof\");\n+        (48,                         Become,     \"become\");\n+        (49,                         Offsetof,   \"offsetof\");\n+        (50,                         Priv,       \"priv\");\n+        (51,                         Pure,       \"pure\");\n+        (52,                         Sizeof,     \"sizeof\");\n+        (53,                         Typeof,     \"typeof\");\n+        (54,                         Unsized,    \"unsized\");\n+        (55,                         Yield,      \"yield\");\n+        (56,                         Do,         \"do\");\n+        (57,                         Abstract,   \"abstract\");\n+        (58,                         Final,      \"final\");\n+        (59,                         Override,   \"override\");\n+        (60,                         Macro,      \"macro\");\n     }\n }\n "}, {"sha": "533487ae1c547cb59fa0e613a43e38df08f195b5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -1582,6 +1582,9 @@ impl<'a> State<'a> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(ii.span.lo));\n         try!(self.print_outer_attributes(&ii.attrs));\n+        if let ast::Defaultness::Default = ii.defaultness {\n+            try!(self.word_nbsp(\"default\"));\n+        }\n         match ii.node {\n             ast::ImplItemKind::Const(ref ty, ref expr) => {\n                 try!(self.print_associated_const(ii.ident, &ty, Some(&expr), ii.vis));"}, {"sha": "937055fcfa6724f55d6456893bc76f7a05f4ed9f", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -476,6 +476,7 @@ impl<'a> TraitDef<'a> {\n                 span: self.span,\n                 ident: ident,\n                 vis: ast::Visibility::Inherited,\n+                defaultness: ast::Defaultness::Final,\n                 attrs: Vec::new(),\n                 node: ast::ImplItemKind::Type(type_def.to_ty(cx,\n                     self.span,\n@@ -893,6 +894,7 @@ impl<'a> MethodDef<'a> {\n             attrs: self.attributes.clone(),\n             span: trait_.span,\n             vis: ast::Visibility::Inherited,\n+            defaultness: ast::Defaultness::Final,\n             ident: method_ident,\n             node: ast::ImplItemKind::Method(ast::MethodSig {\n                 generics: fn_generics,"}, {"sha": "044bb606b40e224b15a0dd6766a72f4e1fec9155", "filename": "src/test/auxiliary/go_trait.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fauxiliary%2Fgo_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fauxiliary%2Fgo_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fgo_trait.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(specialization)]\n+\n // Common code used for tests that model the Fn/FnMut/FnOnce hierarchy.\n \n pub trait Go {\n@@ -37,15 +39,15 @@ pub fn go_once<G:GoOnce>(this: G, arg: isize) {\n impl<G> GoMut for G\n     where G : Go\n {\n-    fn go_mut(&mut self, arg: isize) {\n+    default fn go_mut(&mut self, arg: isize) {\n         go(&*self, arg)\n     }\n }\n \n impl<G> GoOnce for G\n     where G : GoMut\n {\n-    fn go_once(mut self, arg: isize) {\n+    default fn go_once(mut self, arg: isize) {\n         go_mut(&mut self, arg)\n     }\n }"}, {"sha": "1d235336de82183ea2671862f8e01548ef595550", "filename": "src/test/auxiliary/specialization_cross_crate.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fauxiliary%2Fspecialization_cross_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fauxiliary%2Fspecialization_cross_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fspecialization_cross_crate.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+pub trait Foo {\n+    fn foo(&self) -> &'static str;\n+}\n+\n+impl<T> Foo for T {\n+    default fn foo(&self) -> &'static str {\n+        \"generic\"\n+    }\n+}\n+\n+impl<T: Clone> Foo for T {\n+    default fn foo(&self) -> &'static str {\n+        \"generic Clone\"\n+    }\n+}\n+\n+impl<T, U> Foo for (T, U) where T: Clone, U: Clone {\n+    default fn foo(&self) -> &'static str {\n+        \"generic pair\"\n+    }\n+}\n+\n+impl<T: Clone> Foo for (T, T) {\n+    default fn foo(&self) -> &'static str {\n+        \"generic uniform pair\"\n+    }\n+}\n+\n+impl Foo for (u8, u32) {\n+    default fn foo(&self) -> &'static str {\n+        \"(u8, u32)\"\n+    }\n+}\n+\n+impl Foo for (u8, u8) {\n+    default fn foo(&self) -> &'static str {\n+        \"(u8, u8)\"\n+    }\n+}\n+\n+impl<T: Clone> Foo for Vec<T> {\n+    default fn foo(&self) -> &'static str {\n+        \"generic Vec\"\n+    }\n+}\n+\n+impl Foo for Vec<i32> {\n+    fn foo(&self) -> &'static str {\n+        \"Vec<i32>\"\n+    }\n+}\n+\n+impl Foo for String {\n+    fn foo(&self) -> &'static str {\n+        \"String\"\n+    }\n+}\n+\n+impl Foo for i32 {\n+    fn foo(&self) -> &'static str {\n+        \"i32\"\n+    }\n+}\n+\n+pub trait MyMarker {}\n+impl<T: Clone + MyMarker> Foo for T {\n+    default fn foo(&self) -> &'static str {\n+        \"generic Clone + MyMarker\"\n+    }\n+}"}, {"sha": "b62d80b589fda548e3ac21eca0dfc8bcc4a809ac", "filename": "src/test/auxiliary/specialization_cross_crate_defaults.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fauxiliary%2Fspecialization_cross_crate_defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fauxiliary%2Fspecialization_cross_crate_defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fspecialization_cross_crate_defaults.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![feature(specialization)]\n+\n+// First, test only use of explicit `default` items:\n+\n+pub trait Foo {\n+    fn foo(&self) -> bool;\n+}\n+\n+impl<T> Foo for T {\n+    default fn foo(&self) -> bool { false }\n+}\n+\n+impl Foo for i32 {}\n+\n+impl Foo for i64 {\n+    fn foo(&self) -> bool { true }\n+}\n+\n+// Next, test mixture of explicit `default` and provided methods:\n+\n+pub trait Bar {\n+    fn bar(&self) -> i32 { 0 }\n+}\n+\n+impl<T> Bar for T {} // use the provided method\n+\n+impl Bar for i32 {\n+    fn bar(&self) -> i32 { 1 }\n+}\n+impl<'a> Bar for &'a str {}\n+\n+impl<T> Bar for Vec<T> {\n+    default fn bar(&self) -> i32 { 2 }\n+}\n+impl Bar for Vec<i32> {}\n+impl Bar for Vec<i64> {\n+    fn bar(&self) -> i32 { 3 }\n+}"}, {"sha": "6779438c67226783e1d63bf6095cb790be532578", "filename": "src/test/auxiliary/xcrate_associated_type_defaults.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fauxiliary%2Fxcrate_associated_type_defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fauxiliary%2Fxcrate_associated_type_defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_associated_type_defaults.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -10,9 +10,13 @@\n \n #![feature(associated_type_defaults)]\n \n-pub trait Foo {\n-    type Input = usize;\n-    fn bar(&self, _: Self::Input) {}\n+pub trait Foo<T: Default + ToString> {\n+    type Out: Default + ToString = T;\n }\n \n-impl Foo for () {}\n+impl Foo<u32> for () {\n+}\n+\n+impl Foo<u64> for () {\n+    type Out = bool;\n+}"}, {"sha": "786a25500a886284c4b1bcd9fa4a9ca7f9fcb361", "filename": "src/test/compile-fail/associated-types-coherence-failure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-coherence-failure.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -22,21 +22,21 @@ pub trait IntoCow<'a, B: ?Sized> {\n     fn into_cow(self) -> Cow<'a, B>;\n }\n \n-impl<'a, B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n-//~^ ERROR E0119\n+impl<'a, B: ?Sized> IntoCow<'a, B> for <B as ToOwned>::Owned where B: ToOwned {\n     fn into_cow(self) -> Cow<'a, B> {\n-        self\n+        Cow(PhantomData)\n     }\n }\n \n-impl<'a, B: ?Sized> IntoCow<'a, B> for <B as ToOwned>::Owned where B: ToOwned {\n+impl<'a, B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n //~^ ERROR E0119\n     fn into_cow(self) -> Cow<'a, B> {\n-        Cow(PhantomData)\n+        self\n     }\n }\n \n impl<'a, B: ?Sized> IntoCow<'a, B> for &'a B where B: ToOwned {\n+//~^ ERROR E0119\n     fn into_cow(self) -> Cow<'a, B> {\n         Cow(PhantomData)\n     }"}, {"sha": "434d77828b44ae203c3632f44b7a384c8d22b9a1", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-blanket-implemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-implemented.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -27,11 +27,11 @@ impl Even for isize { }\n \n impl Odd for usize { }\n \n-impl<T:Even> MyTrait for T { //~ ERROR E0119\n+impl<T:Even> MyTrait for T {\n     fn get(&self) -> usize { 0 }\n }\n \n-impl<T:Odd> MyTrait for T {\n+impl<T:Odd> MyTrait for T { //~ ERROR E0119\n     fn get(&self) -> usize { 0 }\n }\n "}, {"sha": "7ad5cd71ca8c2a0e343db9a8bed5998ee7ba60d1", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-blanket-unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-blanket-unimplemented.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -23,11 +23,11 @@ trait Even {}\n \n trait Odd {}\n \n-impl<T:Even> MyTrait for T { //~ ERROR E0119\n+impl<T:Even> MyTrait for T {\n     fn get(&self) -> usize { 0 }\n }\n \n-impl<T:Odd> MyTrait for T {\n+impl<T:Odd> MyTrait for T { //~ ERROR E0119\n     fn get(&self) -> usize { 0 }\n }\n "}, {"sha": "1defe6c8b20e3e16a53ca178db9e42e59a39729c", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-specific-multidispatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-multidispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-multidispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-multidispatch.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -18,7 +18,7 @@ trait MyTrait<T> {\n     fn get(&self) -> T;\n }\n \n-impl<T> MyTrait<T> for T { //~ ERROR E0119\n+impl<T> MyTrait<T> for T {\n     fn get(&self) -> T {\n         panic!()\n     }\n@@ -29,7 +29,7 @@ struct MyType {\n     dummy: usize\n }\n \n-impl MyTrait<MyType> for MyType {\n+impl MyTrait<MyType> for MyType { //~ ERROR E0119\n     fn get(&self) -> usize { (*self).clone() }\n }\n "}, {"sha": "5c5c4d32d675cd7ac1a4c37a180198ffa0771676", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-specific-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific-trait.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -19,15 +19,15 @@ trait MyTrait {\n     fn get(&self) -> usize;\n }\n \n-impl<T:OtherTrait> MyTrait for T { //~ ERROR E0119\n+impl<T:OtherTrait> MyTrait for T {\n     fn get(&self) -> usize { 0 }\n }\n \n struct MyType {\n     dummy: usize\n }\n \n-impl MyTrait for MyType {\n+impl MyTrait for MyType { //~ ERROR E0119\n     fn get(&self) -> usize { self.dummy }\n }\n "}, {"sha": "57d71b44b0f6b29aa5452a08183ed5bddecad80d", "filename": "src/test/compile-fail/coherence-blanket-conflicts-with-specific.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-blanket-conflicts-with-specific.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -18,15 +18,15 @@ trait MyTrait {\n     fn get(&self) -> usize;\n }\n \n-impl<T> MyTrait for T { //~ ERROR E0119\n+impl<T> MyTrait for T {\n     fn get(&self) -> usize { 0 }\n }\n \n struct MyType {\n     dummy: usize\n }\n \n-impl MyTrait for MyType {\n+impl MyTrait for MyType { //~ ERROR E0119\n     fn get(&self) -> usize { self.dummy }\n }\n "}, {"sha": "c123e381ab7d733fd02efc7a9d5d3feff217e6c3", "filename": "src/test/compile-fail/coherence-conflicting-negative-trait-impl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-conflicting-negative-trait-impl.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -15,8 +15,6 @@ trait MyTrait {}\n struct TestType<T>(::std::marker::PhantomData<T>);\n \n unsafe impl<T: MyTrait+'static> Send for TestType<T> {}\n-//~^ ERROR conflicting implementations of trait `core::marker::Send`\n-//~^^ ERROR conflicting implementations of trait `core::marker::Send`\n \n impl<T: MyTrait> !Send for TestType<T> {}\n //~^ ERROR conflicting implementations of trait `core::marker::Send`"}, {"sha": "9f74afbb2b3b5493ba7b30472b627a51e7685f18", "filename": "src/test/compile-fail/coherence-cross-crate-conflict.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cross-crate-conflict.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -8,16 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Regression test for #3512 - conflicting trait impls in different crates should give a\n-// 'conflicting implementations' error message.\n+// The error here is strictly due to orphan rules; the impl here\n+// generalizes the one upstream\n \n // aux-build:trait_impl_conflict.rs\n extern crate trait_impl_conflict;\n use trait_impl_conflict::Foo;\n \n impl<A> Foo for A {\n     //~^ ERROR type parameter `A` must be used as the type parameter for some local type\n-    //~^^ ERROR E0119\n }\n \n fn main() {"}, {"sha": "3d109de76ccd1c21908c0ff5a46dbef64fd0a072", "filename": "src/test/compile-fail/coherence-default-trait-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -15,7 +15,7 @@ trait MyTrait {}\n impl MyTrait for .. {}\n \n impl MyTrait for .. {}\n-//~^ ERROR conflicting implementations of trait `MyTrait`\n+//~^ ERROR redundant default implementations of trait `MyTrait`\n \n trait MySafeTrait {}\n "}, {"sha": "6de338f1db0fae9b781d5ed1e412899dd08d75cc", "filename": "src/test/compile-fail/coherence-no-direct-lifetime-dispatch.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-no-direct-lifetime-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-no-direct-lifetime-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-no-direct-lifetime-dispatch.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that you cannot *directly* dispatch on lifetime requirements\n+\n+trait MyTrait {}\n+\n+impl<T> MyTrait for T {}\n+impl<T: 'static> MyTrait for T {} //~ ERROR E0119\n+\n+fn main() {}"}, {"sha": "928ba7a36db266ddb3534eba302fbff8125d4013", "filename": "src/test/compile-fail/coherence-overlap-all-t-and-tuple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-all-t-and-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-all-t-and-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-all-t-and-tuple.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -19,10 +19,10 @@\n trait From<U> {\n }\n \n-impl <T> From<T> for T { //~ ERROR E0119\n+impl <T> From<T> for T {\n }\n \n-impl <T11, U11> From<(U11,)> for (T11,) {\n+impl <T11, U11> From<(U11,)> for (T11,) { //~ ERROR E0119\n }\n \n fn main() { }"}, {"sha": "51d7c3e8b4cb17962f0809276d5abf49b84a85af", "filename": "src/test/compile-fail/coherence-overlap-issue-23516.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -14,6 +14,6 @@\n \n pub trait Sugar { fn dummy(&self) { } }\n pub trait Sweet { fn dummy(&self) { } }\n-impl<T:Sugar> Sweet for T { } //~ ERROR E0119\n-impl<U:Sugar> Sweet for Box<U> { }\n+impl<T:Sugar> Sweet for T { }\n+impl<U:Sugar> Sweet for Box<U> { } //~ ERROR E0119\n fn main() { }"}, {"sha": "0ae8135221c21fc9a54f3094a711234c17ce9bff", "filename": "src/test/compile-fail/coherence-overlap-messages.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-messages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-messages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-messages.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -10,33 +10,23 @@\n \n trait Foo {}\n \n-impl<T> Foo for T {} //~ ERROR conflicting implementations of trait `Foo`:\n-impl<U> Foo for U {}\n+impl<T> Foo for T {}\n+impl<U> Foo for U {} //~ ERROR conflicting implementations of trait `Foo`:\n \n trait Bar {}\n \n-impl<T> Bar for T {} //~ ERROR conflicting implementations of trait `Bar` for type `u8`:\n-impl Bar for u8 {}\n+impl<T> Bar for (T, u8) {}\n+impl<T> Bar for (u8, T) {} //~ ERROR conflicting implementations of trait `Bar` for type `(u8, u8)`:\n \n trait Baz<T> {}\n \n-impl<T, U> Baz<U> for T {} //~ ERROR conflicting implementations of trait `Baz<_>` for type `u8`:\n-impl<T> Baz<T> for u8 {}\n+impl<T> Baz<u8> for T {}\n+impl<T> Baz<T> for u8 {} //~ ERROR conflicting implementations of trait `Baz<u8>` for type `u8`:\n \n-trait Quux<T> {}\n+trait Quux<U, V> {}\n \n-impl<T, U> Quux<U> for T {} //~ ERROR conflicting implementations of trait `Quux<_>`:\n-impl<T> Quux<T> for T {}\n-\n-trait Qaar<T> {}\n-\n-impl<T, U> Qaar<U> for T {} //~ ERROR conflicting implementations of trait `Qaar<u8>`:\n-impl<T> Qaar<u8> for T {}\n-\n-trait Qaax<T> {}\n-\n-impl<T, U> Qaax<U> for T {}\n-//~^ ERROR conflicting implementations of trait `Qaax<u8>` for type `u32`:\n-impl Qaax<u8> for u32 {}\n+impl<T, U, V> Quux<U, V> for T {}\n+impl<T, U> Quux<U, U> for T {} //~ ERROR conflicting implementations of trait `Quux<_, _>`:\n+impl<T, V> Quux<T, V> for T {} //~ ERROR conflicting implementations of trait `Quux<_, _>`:\n \n fn main() {}"}, {"sha": "3ed3549de89aaa214b9191d281a47429c741af58", "filename": "src/test/compile-fail/coherence-projection-conflict-orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-orphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-orphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-orphan.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -21,8 +21,8 @@ pub trait Bar {\n     type Output: 'static;\n }\n \n-impl Foo<i32> for i32 { } //~ ERROR E0119\n+impl Foo<i32> for i32 { }\n \n-impl<A:Iterator> Foo<A::Item> for A { }\n+impl<A:Iterator> Foo<A::Item> for A { }  //~ ERROR E0119\n \n fn main() {}"}, {"sha": "f04902a70f68c20e490b1719efaefe4b58d38096", "filename": "src/test/compile-fail/coherence-projection-conflict-ty-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-ty-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-ty-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict-ty-param.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -15,8 +15,8 @@ use std::marker::PhantomData;\n \n pub trait Foo<P> {}\n \n-impl <P, T: Foo<P>> Foo<P> for Option<T> {} //~ ERROR E0119\n+impl <P, T: Foo<P>> Foo<P> for Option<T> {}\n \n-impl<T, U> Foo<T> for Option<U> { }\n+impl<T, U> Foo<T> for Option<U> { } //~ ERROR E0119\n \n fn main() {}"}, {"sha": "6d3ab32f06f43d08327af11f3d2088ae8c643935", "filename": "src/test/compile-fail/coherence-projection-conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-projection-conflict.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -16,9 +16,9 @@ pub trait Bar {\n     type Output: 'static;\n }\n \n-impl Foo<i32> for i32 { } //~ ERROR E0119\n+impl Foo<i32> for i32 { }\n \n-impl<A:Bar> Foo<A::Output> for A { }\n+impl<A:Bar> Foo<A::Output> for A { } //~ ERROR E0119\n \n impl Bar for i32 {\n     type Output = i32;"}, {"sha": "7807f93df1a673d8810010f82c027e0d014dd49a", "filename": "src/test/compile-fail/coherence-tuple-conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-tuple-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence-tuple-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-tuple-conflict.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -18,11 +18,11 @@ trait MyTrait {\n     fn get(&self) -> usize;\n }\n \n-impl<T> MyTrait for (T,T) { //~ ERROR E0119\n+impl<T> MyTrait for (T,T) {\n     fn get(&self) -> usize { 0 }\n }\n \n-impl<A,B> MyTrait for (A,B) {\n+impl<A,B> MyTrait for (A,B) { //~ ERROR E0119\n     fn get(&self) -> usize { self.dummy }\n }\n "}, {"sha": "8e3e3f31cb5f1434356b5b9aa5bfd199a475cf8f", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct_tuple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -21,10 +21,10 @@ struct MyType { x: i32 }\n \n trait MyTrait { }\n \n-impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n+impl<T: lib::MyCopy> MyTrait for T { }\n \n // Tuples are not fundamental.\n-impl MyTrait for lib::MyFundamentalStruct<(MyType,)> { }\n+impl MyTrait for lib::MyFundamentalStruct<(MyType,)> { } //~ ERROR E0119\n \n #[rustc_error]\n fn main() { }"}, {"sha": "35bc17b8e887036a93bb4e1675aca4786795e1d8", "filename": "src/test/compile-fail/coherence_copy_like_err_struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -18,14 +18,14 @@ extern crate coherence_copy_like_lib as lib;\n struct MyType { x: i32 }\n \n trait MyTrait { }\n-impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n+impl<T: lib::MyCopy> MyTrait for T { }\n \n // `MyStruct` is not declared fundamental, therefore this would\n // require that\n //\n //     MyStruct<MyType>: !MyTrait\n //\n // which we cannot approve.\n-impl MyTrait for lib::MyStruct<MyType> { }\n+impl MyTrait for lib::MyStruct<MyType> { } //~ ERROR E0119\n \n fn main() { }"}, {"sha": "a70cc92955fb0d6a76e0a5672e0d4764a976d470", "filename": "src/test/compile-fail/coherence_copy_like_err_tuple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -18,13 +18,13 @@ extern crate coherence_copy_like_lib as lib;\n struct MyType { x: i32 }\n \n trait MyTrait { }\n-impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n+impl<T: lib::MyCopy> MyTrait for T { }\n \n // Tuples are not fundamental, therefore this would require that\n //\n //     (MyType,): !MyTrait\n //\n // which we cannot approve.\n-impl MyTrait for (MyType,) { }\n+impl MyTrait for (MyType,) { } //~ ERROR E0119\n \n fn main() { }"}, {"sha": "7c051784f61a7dbbf253550c40cb03dffad0dcee", "filename": "src/test/compile-fail/issue-28568.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fissue-28568.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fissue-28568.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28568.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -11,12 +11,12 @@\n struct MyStruct;\n \n impl Drop for MyStruct {\n-//~^ ERROR conflicting implementations of trait\n+//~^ NOTE conflicting implementation is here\n     fn drop(&mut self) { }\n }\n \n impl Drop for MyStruct {\n-//~^ NOTE conflicting implementation is here\n+//~^ ERROR conflicting implementations of trait\n     fn drop(&mut self) { }\n }\n "}, {"sha": "b9d632a8cf07e6ce33dcbcd4271e05758769b5d0", "filename": "src/test/compile-fail/private-in-public-warn.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -198,9 +198,11 @@ mod aliases_pub {\n     use self::m::PubTr as PrivUseAliasTr;\n     type PrivAlias = m::Pub2;\n     trait PrivTr {\n+        type AssocAlias;\n+    }\n+    impl PrivTr for Priv {\n         type AssocAlias = m::Pub3;\n     }\n-    impl PrivTr for Priv {}\n \n     pub fn f1(arg: PrivUseAlias) {} // OK\n \n@@ -245,9 +247,11 @@ mod aliases_priv {\n     use self::PrivTr1 as PrivUseAliasTr;\n     type PrivAlias = Priv2;\n     trait PrivTr {\n+        type AssocAlias;\n+    }\n+    impl PrivTr for Priv {\n         type AssocAlias = Priv3;\n     }\n-    impl PrivTr for Priv {}\n \n     pub trait Tr1: PrivUseAliasTr {} //~ WARN private trait in public interface\n         //~^ WARNING hard error"}, {"sha": "f2b4bf946c53702024908a5ff1d6c5a243941272", "filename": "src/test/compile-fail/specialization/README.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2FREADME.md?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,21 @@\n+This directory contains the test for incorrect usage of specialization that\n+should lead to compile failure. Those tests break down into a few categories:\n+\n+- Feature gating\n+  - [On use of the `default` keyword](specialization-feature-gate-default.rs)\n+  - [On overlapping impls](specialization-feature-gate-overlap.rs)\n+\n+- Overlap checking with specialization enabled\n+  - [Basic overlap scenarios](specialization-overlap.rs)\n+    - Includes purely structural overlap\n+    - Includes purely trait-based overlap\n+    - Includes mix\n+  - [Overlap with differing polarity](specialization-overlap-negative.rs)\n+\n+- [Attempt to specialize without using `default`](specialization-no-default.rs)\n+\n+- [Attempt to change impl polarity in a specialization](specialization-polarity.rs)\n+\n+- Attempt to rely on projection of a `default` type\n+  - [Rely on it externally in both generic and monomorphic contexts](specialization-default-projection.rs)\n+  - [Rely on it both within an impl and outside it](specialization-default-types.rs)"}, {"sha": "96cbd7a485251540515849e3c6d08f64e75f121d", "filename": "src/test/compile-fail/specialization/specialization-default-projection.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-default-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-default-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-default-projection.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+// Make sure we can't project defaulted associated types\n+\n+trait Foo {\n+    type Assoc;\n+}\n+\n+impl<T> Foo for T {\n+    default type Assoc = ();\n+}\n+\n+impl Foo for u8 {\n+    type Assoc = String;\n+}\n+\n+fn generic<T>() -> <T as Foo>::Assoc {\n+    // `T` could be some downstream crate type that specializes (or,\n+    // for that matter, `u8`).\n+\n+    () //~ ERROR mismatched types\n+}\n+\n+fn monomorphic() -> () {\n+    // Even though we know that `()` is not specialized in a\n+    // downstream crate, typeck refuses to project here.\n+\n+    generic::<()>() //~ ERROR mismatched types\n+}\n+\n+fn main() {\n+    // No error here, we CAN project from `u8`, as there is no `default`\n+    // in that impl.\n+    let s: String = generic::<u8>();\n+    println!(\"{}\", s); // bad news if this all compiles\n+}"}, {"sha": "18acecb42296a56f2c36630fe41285507b2fa914", "filename": "src/test/compile-fail/specialization/specialization-default-types.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-default-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-default-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-default-types.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// It should not be possible to use the concrete value of a defaulted\n+// associated type in the impl defining it -- otherwise, what happens\n+// if it's overridden?\n+\n+#![feature(specialization)]\n+\n+trait Example {\n+    type Output;\n+    fn generate(self) -> Self::Output;\n+}\n+\n+impl<T> Example for T {\n+    default type Output = Box<T>;\n+    default fn generate(self) -> Self::Output {\n+        Box::new(self) //~ ERROR mismatched types\n+    }\n+}\n+\n+impl Example for bool {\n+    type Output = bool;\n+    fn generate(self) -> bool { self }\n+}\n+\n+fn trouble<T>(t: T) -> Box<T> {\n+    Example::generate(t) //~ ERROR mismatched types\n+}\n+\n+fn weaponize() -> bool {\n+    let b: Box<bool> = trouble(true);\n+    *b\n+}\n+\n+fn main() {\n+    weaponize();\n+}"}, {"sha": "e7c194ce84df95620c2cbe4750eb3489695390bf", "filename": "src/test/compile-fail/specialization/specialization-feature-gate-default.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-feature-gate-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-feature-gate-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-feature-gate-default.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that specialization must be ungated to use the `default` keyword\n+\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+impl<T> Foo for T {\n+    default fn foo(&self) {} //~ ERROR specialization is unstable\n+}\n+\n+fn main() {}"}, {"sha": "d11ab56ff7e871d5f22839aed780f7e92117f472", "filename": "src/test/compile-fail/specialization/specialization-feature-gate-overlap.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-feature-gate-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-feature-gate-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-feature-gate-overlap.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that writing an overlapping impl is not allow unless specialization is ungated.\n+\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+impl<T> Foo for T {\n+    fn foo(&self) {}\n+}\n+\n+impl Foo for u8 { //~ ERROR E0119\n+    fn foo(&self) {}\n+}\n+\n+fn main() {}"}, {"sha": "961561685437a97eddd96739974f14ae71b327c1", "filename": "src/test/compile-fail/specialization/specialization-no-default.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-no-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-no-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-no-default.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+// Check a number of scenarios in which one impl tries to override another,\n+// without correctly using `default`.\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Test 1: one layer of specialization, multiple methods, missing `default`\n+////////////////////////////////////////////////////////////////////////////////\n+\n+trait Foo {\n+    fn foo(&self);\n+    fn bar(&self);\n+}\n+\n+impl<T> Foo for T {\n+    fn foo(&self) {}\n+    fn bar(&self) {}\n+}\n+\n+impl Foo for u8 {}\n+impl Foo for u16 {\n+    fn foo(&self) {} //~ ERROR E0520\n+}\n+impl Foo for u32 {\n+    fn bar(&self) {} //~ ERROR E0520\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Test 2: one layer of specialization, missing `default` on associated type\n+////////////////////////////////////////////////////////////////////////////////\n+\n+trait Bar {\n+    type T;\n+}\n+\n+impl<T> Bar for T {\n+    type T = u8;\n+}\n+\n+impl Bar for u8 {\n+    type T = (); //~ ERROR E0520\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Test 3a: multiple layers of specialization, missing interior `default`\n+////////////////////////////////////////////////////////////////////////////////\n+\n+trait Baz {\n+    fn baz(&self);\n+}\n+\n+impl<T> Baz for T {\n+    default fn baz(&self) {}\n+}\n+\n+impl<T: Clone> Baz for T {\n+    fn baz(&self) {}\n+}\n+\n+impl Baz for i32 {\n+    fn baz(&self) {} //~ ERROR E0520\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Test 3b: multiple layers of specialization, missing interior `default`,\n+// redundant `default` in bottom layer.\n+////////////////////////////////////////////////////////////////////////////////\n+\n+trait Redundant {\n+    fn redundant(&self);\n+}\n+\n+impl<T> Redundant for T {\n+    default fn redundant(&self) {}\n+}\n+\n+impl<T: Clone> Redundant for T {\n+    fn redundant(&self) {}\n+}\n+\n+impl Redundant for i32 {\n+    default fn redundant(&self) {} //~ ERROR E0520\n+}\n+\n+fn main() {}"}, {"sha": "62a6d8d9b5031208d4c19851bfe448e84c430b21", "filename": "src/test/compile-fail/specialization/specialization-overlap-negative.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-overlap-negative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-overlap-negative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-overlap-negative.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+#![feature(specialization)]\n+\n+trait MyTrait {}\n+\n+struct TestType<T>(::std::marker::PhantomData<T>);\n+\n+unsafe impl<T: Clone> Send for TestType<T> {}\n+impl<T: MyTrait> !Send for TestType<T> {} //~ ERROR E0119\n+\n+fn main() {}"}, {"sha": "f579817100107c88452fd1b64800b50b8ca8efd6", "filename": "src/test/compile-fail/specialization/specialization-overlap.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-overlap.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+trait Foo {}\n+impl<T: Clone> Foo for T {}\n+impl<T> Foo for Vec<T> {} //~ ERROR E0119\n+\n+trait Bar {}\n+impl<T> Bar for (T, u8) {}\n+impl<T> Bar for (u8, T) {} //~ ERROR E0119\n+\n+trait Baz<U> {}\n+impl<T> Baz<T> for u8 {}\n+impl<T> Baz<u8> for T {} //~ ERROR E0119\n+\n+trait Qux {}\n+impl<T: Clone> Qux for T {}\n+impl<T: Eq> Qux for T {} //~ ERROR E0119\n+\n+fn main() {}"}, {"sha": "27a3e31491b823307c28469f58929e2a9cbf9987", "filename": "src/test/compile-fail/specialization/specialization-polarity.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-polarity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-polarity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization%2Fspecialization-polarity.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure specialization cannot change impl polarity\n+\n+#![feature(optin_builtin_traits)]\n+#![feature(specialization)]\n+\n+trait Foo {}\n+\n+impl Foo for .. {}\n+\n+impl<T> Foo for T {}\n+impl !Foo for u8 {} //~ ERROR E0119\n+\n+trait Bar {}\n+\n+impl Bar for .. {}\n+\n+impl<T> !Bar for T {}\n+impl Bar for u8 {} //~ ERROR E0119\n+\n+fn main() {}"}, {"sha": "d18401e67646c7f69e214f3b63d101553a82e133", "filename": "src/test/parse-fail/default.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fparse-fail%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fparse-fail%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fdefault.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z parse-only\n+\n+// Test successful and unsucessful parsing of the `default` contextual keyword\n+\n+trait Foo {\n+    fn foo<T: Default>() -> T;\n+}\n+\n+impl Foo for u8 {\n+    default fn foo<T: Default>() -> T {\n+        T::default()\n+    }\n+}\n+\n+impl Foo for u16 {\n+    pub default fn foo<T: Default>() -> T {\n+        T::default()\n+    }\n+}\n+\n+impl Foo for u32 {\n+    default pub fn foo<T: Default>() -> T { T::default() } //~ ERROR expected one of\n+}\n+\n+fn main() {}"}, {"sha": "a489864e3f7370cb8ae0b6b8321106f2a2c2176b", "filename": "src/test/parse-fail/issue-20711-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fparse-fail%2Fissue-20711-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fparse-fail%2Fissue-20711-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-20711-2.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -16,6 +16,6 @@ impl Foo {\n     fn foo() {}\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `const`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n+} //~ ERROR expected one of `const`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`\n \n fn main() {}"}, {"sha": "d9789d55a6faf51d160a585d0645ca7c2ce7dfa3", "filename": "src/test/parse-fail/issue-20711.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fparse-fail%2Fissue-20711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fparse-fail%2Fissue-20711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-20711.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -14,6 +14,6 @@ struct Foo;\n \n impl Foo {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-} //~ ERROR expected one of `const`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `}`\n+} //~ ERROR expected one of `const`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`\n \n fn main() {}"}, {"sha": "b4c25a75c9086b4f2ef118c8038097fb7fe7a609", "filename": "src/test/parse-fail/removed-syntax-static-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fparse-fail%2Fremoved-syntax-static-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Fparse-fail%2Fremoved-syntax-static-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-static-fn.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -15,4 +15,4 @@ struct S;\n impl S {\n     static fn f() {}\n }\n-//~^^ ERROR expected one of `const`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `static`\n+//~^^ ERROR expected one of `const`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`"}, {"sha": "ed55d5c8b171e6180b0296c4201e2b80796fbb0b", "filename": "src/test/run-pass/default-associated-types.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fdefault-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fdefault-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault-associated-types.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -10,23 +10,22 @@\n \n #![feature(associated_type_defaults)]\n \n-trait Foo<T> {\n-    type Out = T;\n-    fn foo(&self) -> Self::Out;\n+trait Foo<T: Default + ToString> {\n+    type Out: Default + ToString = T;\n }\n \n impl Foo<u32> for () {\n-    fn foo(&self) -> u32 {\n-        4u32\n-    }\n }\n \n-impl Foo<u64> for bool {\n-    type Out = ();\n-    fn foo(&self) {}\n+impl Foo<u64> for () {\n+    type Out = bool;\n }\n \n fn main() {\n-    assert_eq!(<() as Foo<u32>>::foo(&()), 4u32);\n-    assert_eq!(<bool as Foo<u64>>::foo(&true), ());\n+    assert_eq!(\n+        <() as Foo<u32>>::Out::default().to_string(),\n+        \"0\");\n+    assert_eq!(\n+        <() as Foo<u64>>::Out::default().to_string(),\n+        \"false\");\n }"}, {"sha": "1373a2cf81b3a1f427f0564175a92f4039e05b42", "filename": "src/test/run-pass/specialization/README.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2FREADME.md?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,37 @@\n+Tests that specialization is working correctly:\n+\n+- Dispatch\n+  - [On methods](specialization-basics.rs), includes:\n+    - Specialization via adding a trait bound\n+      - Including both remote and local traits\n+    - Specialization via pure structure (e.g. `(T, U)` vs `(T, T)`)\n+    - Specialization via concrete types vs unknown types\n+      - In top level of the trait reference\n+      - Embedded within another type (`Vec<T>` vs `Vec<i32>`)\n+  - [Specialization based on super trait relationships](specialization-super-traits.rs)\n+  - [On assoc fns](specialization-assoc-fns.rs)\n+  - [Ensure that impl order doesn't matter](specialization-out-of-order.rs)\n+\n+- Item inheritance\n+  - [Correct default cascading for methods](specialization-default-methods.rs)\n+  - Inheritance works across impls with varying generics\n+    - [With projections](specialization-translate-projections.rs)\n+    - [With projections that involve input types](specialization-translate-projections-with-params.rs)\n+\n+- Normalization issues\n+  - [Non-default assoc types can be projected](specialization-projection.rs)\n+    - Including non-specialized cases\n+    - Including specialized cases\n+  - [Specialized Impls can happen on projections](specialization-on-projection.rs)\n+  - [Projections and aliases play well together](specialization-projection-alias.rs)\n+  - [Projections involving specialization allowed in the trait ref for impls, and overlap can still be determined](specialization-overlap-projection.rs)\n+    - Only works for the simple case where the most specialized impl directly\n+      provides a non-`default` associated type\n+\n+- Across crates\n+  - [For traits defined in upstream crate](specialization-allowed-cross-crate.rs)\n+  - [Full method dispatch tests, drawing from upstream crate](specialization-cross-crate.rs)\n+    - Including *additional* local specializations\n+  - [Full method dispatch tests, *without* turning on specialization in local crate](specialization-cross-crate-no-gate.rs)\n+  - [Test that defaults cascade correctly from upstream crates](specialization-cross-crate-defaults.rs)\n+    - Including *additional* local use of defaults"}, {"sha": "6b999f3835835af47943f4f065fafc89bca17aed", "filename": "src/test/run-pass/specialization/specialization-allowed-cross-crate.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-allowed-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-allowed-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-allowed-cross-crate.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:go_trait.rs\n+\n+#![feature(specialization)]\n+\n+extern crate go_trait;\n+\n+use go_trait::{Go,GoMut};\n+use std::fmt::Debug;\n+use std::default::Default;\n+\n+struct MyThingy;\n+\n+impl Go for MyThingy {\n+    fn go(&self, arg: isize) { }\n+}\n+\n+impl GoMut for MyThingy {\n+    fn go_mut(&mut self, arg: isize) { }\n+}\n+\n+fn main() { }"}, {"sha": "577f217862da3ee9f78c7217b69f11e6d5281de6", "filename": "src/test/run-pass/specialization/specialization-assoc-fns.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-assoc-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-assoc-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-assoc-fns.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that non-method associated functions can be specialized\n+\n+#![feature(specialization)]\n+\n+trait Foo {\n+    fn mk() -> Self;\n+}\n+\n+impl<T: Default> Foo for T {\n+    default fn mk() -> T {\n+        T::default()\n+    }\n+}\n+\n+impl Foo for Vec<u8> {\n+    fn mk() -> Vec<u8> {\n+        vec![0]\n+    }\n+}\n+\n+fn main() {\n+    let v1: Vec<i32> = Foo::mk();\n+    let v2: Vec<u8> = Foo::mk();\n+\n+    assert!(v1.len() == 0);\n+    assert!(v2.len() == 1);\n+}"}, {"sha": "b11495e9edf1af24e99e011661d32fe2e97afdec", "filename": "src/test/run-pass/specialization/specialization-basics.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-basics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-basics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-basics.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+// Tests a variety of basic specialization scenarios and method\n+// dispatch for them.\n+\n+trait Foo {\n+    fn foo(&self) -> &'static str;\n+}\n+\n+impl<T> Foo for T {\n+    default fn foo(&self) -> &'static str {\n+        \"generic\"\n+    }\n+}\n+\n+impl<T: Clone> Foo for T {\n+    default fn foo(&self) -> &'static str {\n+        \"generic Clone\"\n+    }\n+}\n+\n+impl<T, U> Foo for (T, U) where T: Clone, U: Clone {\n+    default fn foo(&self) -> &'static str {\n+        \"generic pair\"\n+    }\n+}\n+\n+impl<T: Clone> Foo for (T, T) {\n+    default fn foo(&self) -> &'static str {\n+        \"generic uniform pair\"\n+    }\n+}\n+\n+impl Foo for (u8, u32) {\n+    default fn foo(&self) -> &'static str {\n+        \"(u8, u32)\"\n+    }\n+}\n+\n+impl Foo for (u8, u8) {\n+    default fn foo(&self) -> &'static str {\n+        \"(u8, u8)\"\n+    }\n+}\n+\n+impl<T: Clone> Foo for Vec<T> {\n+    default fn foo(&self) -> &'static str {\n+        \"generic Vec\"\n+    }\n+}\n+\n+impl Foo for Vec<i32> {\n+    fn foo(&self) -> &'static str {\n+        \"Vec<i32>\"\n+    }\n+}\n+\n+impl Foo for String {\n+    fn foo(&self) -> &'static str {\n+        \"String\"\n+    }\n+}\n+\n+impl Foo for i32 {\n+    fn foo(&self) -> &'static str {\n+        \"i32\"\n+    }\n+}\n+\n+struct NotClone;\n+\n+trait MyMarker {}\n+impl<T: Clone + MyMarker> Foo for T {\n+    default fn foo(&self) -> &'static str {\n+        \"generic Clone + MyMarker\"\n+    }\n+}\n+\n+#[derive(Clone)]\n+struct MarkedAndClone;\n+impl MyMarker for MarkedAndClone {}\n+\n+fn  main() {\n+    assert!(NotClone.foo() == \"generic\");\n+    assert!(0u8.foo() == \"generic Clone\");\n+    assert!(vec![NotClone].foo() == \"generic\");\n+    assert!(vec![0u8].foo() == \"generic Vec\");\n+    assert!(vec![0i32].foo() == \"Vec<i32>\");\n+    assert!(0i32.foo() == \"i32\");\n+    assert!(String::new().foo() == \"String\");\n+    assert!(((), 0).foo() == \"generic pair\");\n+    assert!(((), ()).foo() == \"generic uniform pair\");\n+    assert!((0u8, 0u32).foo() == \"(u8, u32)\");\n+    assert!((0u8, 0u8).foo() == \"(u8, u8)\");\n+    assert!(MarkedAndClone.foo() == \"generic Clone + MyMarker\");\n+}"}, {"sha": "bc695ea821d0a1c2d02040e50b18f3e8fc5a54bd", "filename": "src/test/run-pass/specialization/specialization-cross-crate-defaults.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-cross-crate-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-cross-crate-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-cross-crate-defaults.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:specialization_cross_crate_defaults.rs\n+\n+#![feature(specialization)]\n+\n+extern crate specialization_cross_crate_defaults;\n+\n+use specialization_cross_crate_defaults::*;\n+\n+struct LocalDefault;\n+struct LocalOverride;\n+\n+impl Foo for LocalDefault {}\n+\n+impl Foo for LocalOverride {\n+    fn foo(&self) -> bool { true }\n+}\n+\n+fn test_foo() {\n+    assert!(0i8.foo() == false);\n+    assert!(0i32.foo() == false);\n+    assert!(0i64.foo() == true);\n+\n+    assert!(LocalDefault.foo() == false);\n+    assert!(LocalOverride.foo() == true);\n+}\n+\n+fn test_bar() {\n+    assert!(0u8.bar() == 0);\n+    assert!(0i32.bar() == 1);\n+    assert!(\"hello\".bar() == 0);\n+    assert!(vec![()].bar() == 2);\n+    assert!(vec![0i32].bar() == 2);\n+    assert!(vec![0i64].bar() == 3);\n+}\n+\n+fn main() {\n+    test_foo();\n+    test_bar();\n+}"}, {"sha": "b9548539e16490b1fea6deae8f68531571cd8809", "filename": "src/test/run-pass/specialization/specialization-cross-crate-no-gate.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-cross-crate-no-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-cross-crate-no-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-cross-crate-no-gate.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that specialization works even if only the upstream crate enables it\n+\n+// aux-build:specialization_cross_crate.rs\n+\n+extern crate specialization_cross_crate;\n+\n+use specialization_cross_crate::*;\n+\n+fn  main() {\n+    assert!(0u8.foo() == \"generic Clone\");\n+    assert!(vec![0u8].foo() == \"generic Vec\");\n+    assert!(vec![0i32].foo() == \"Vec<i32>\");\n+    assert!(0i32.foo() == \"i32\");\n+    assert!(String::new().foo() == \"String\");\n+    assert!(((), 0).foo() == \"generic pair\");\n+    assert!(((), ()).foo() == \"generic uniform pair\");\n+    assert!((0u8, 0u32).foo() == \"(u8, u32)\");\n+    assert!((0u8, 0u8).foo() == \"(u8, u8)\");\n+}"}, {"sha": "7593ac4fb1dd29bbc95dddc367e2691a8a42596e", "filename": "src/test/run-pass/specialization/specialization-cross-crate.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-cross-crate.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:specialization_cross_crate.rs\n+\n+#![feature(specialization)]\n+\n+extern crate specialization_cross_crate;\n+\n+use specialization_cross_crate::*;\n+\n+struct NotClone;\n+\n+#[derive(Clone)]\n+struct MarkedAndClone;\n+impl MyMarker for MarkedAndClone {}\n+\n+struct MyType<T>(T);\n+impl<T> Foo for MyType<T> {\n+    default fn foo(&self) -> &'static str {\n+        \"generic MyType\"\n+    }\n+}\n+\n+impl Foo for MyType<u8> {\n+    fn foo(&self) -> &'static str {\n+        \"MyType<u8>\"\n+    }\n+}\n+\n+struct MyOtherType;\n+impl Foo for MyOtherType {}\n+\n+fn  main() {\n+    assert!(NotClone.foo() == \"generic\");\n+    assert!(0u8.foo() == \"generic Clone\");\n+    assert!(vec![NotClone].foo() == \"generic\");\n+    assert!(vec![0u8].foo() == \"generic Vec\");\n+    assert!(vec![0i32].foo() == \"Vec<i32>\");\n+    assert!(0i32.foo() == \"i32\");\n+    assert!(String::new().foo() == \"String\");\n+    assert!(((), 0).foo() == \"generic pair\");\n+    assert!(((), ()).foo() == \"generic uniform pair\");\n+    assert!((0u8, 0u32).foo() == \"(u8, u32)\");\n+    assert!((0u8, 0u8).foo() == \"(u8, u8)\");\n+    assert!(MarkedAndClone.foo() == \"generic Clone + MyMarker\");\n+\n+    assert!(MyType(()).foo() == \"generic MyType\");\n+    assert!(MyType(0u8).foo() == \"MyType<u8>\");\n+    assert!(MyOtherType.foo() == \"generic\");\n+}"}, {"sha": "3f0f21ff03f27948c3b958ddd2ab4ed1f23774d9", "filename": "src/test/run-pass/specialization/specialization-default-methods.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-default-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-default-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-default-methods.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+// Test that default methods are cascaded correctly\n+\n+// First, test only use of explicit `default` items:\n+\n+trait Foo {\n+    fn foo(&self) -> bool;\n+}\n+\n+// Specialization tree for Foo:\n+//\n+//        T\n+//       / \\\n+//    i32   i64\n+\n+impl<T> Foo for T {\n+    default fn foo(&self) -> bool { false }\n+}\n+\n+impl Foo for i32 {}\n+\n+impl Foo for i64 {\n+    fn foo(&self) -> bool { true }\n+}\n+\n+fn test_foo() {\n+    assert!(0i8.foo() == false);\n+    assert!(0i32.foo() == false);\n+    assert!(0i64.foo() == true);\n+}\n+\n+// Next, test mixture of explicit `default` and provided methods:\n+\n+trait Bar {\n+    fn bar(&self) -> i32 { 0 }\n+}\n+\n+// Specialization tree for Bar.\n+// Uses of $ designate that method is provided\n+//\n+//           $Bar   (the trait)\n+//             |\n+//             T\n+//            /|\\\n+//           / | \\\n+//          /  |  \\\n+//         /   |   \\\n+//        /    |    \\\n+//       /     |     \\\n+//     $i32   &str  $Vec<T>\n+//                    /\\\n+//                   /  \\\n+//            Vec<i32>  $Vec<i64>\n+\n+// use the provided method\n+impl<T> Bar for T {}\n+\n+impl Bar for i32 {\n+    fn bar(&self) -> i32 { 1 }\n+}\n+impl<'a> Bar for &'a str {}\n+\n+impl<T> Bar for Vec<T> {\n+    default fn bar(&self) -> i32 { 2 }\n+}\n+impl Bar for Vec<i32> {}\n+impl Bar for Vec<i64> {\n+    fn bar(&self) -> i32 { 3 }\n+}\n+\n+fn test_bar() {\n+    assert!(0u8.bar() == 0);\n+    assert!(0i32.bar() == 1);\n+    assert!(\"hello\".bar() == 0);\n+    assert!(vec![()].bar() == 2);\n+    assert!(vec![0i32].bar() == 2);\n+    assert!(vec![0i64].bar() == 3);\n+}\n+\n+fn main() {\n+    test_foo();\n+    test_bar();\n+}"}, {"sha": "acf78def1b96795b76d51cd9bbd6176baac58cf8", "filename": "src/test/run-pass/specialization/specialization-on-projection.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-on-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-on-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-on-projection.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+// Ensure that specialization works for impls defined directly on a projection\n+\n+trait Foo<T> {}\n+\n+trait Assoc {\n+    type Item;\n+}\n+\n+impl<T: Assoc> Foo<T::Item> for T {}\n+\n+struct Struct;\n+\n+impl Assoc for Struct {\n+    type Item = u8;\n+}\n+\n+impl Foo<u8> for Struct {}\n+\n+fn main() {}"}, {"sha": "2d293f494a3479945b60e5ab21fb9bf8be32e785", "filename": "src/test/run-pass/specialization/specialization-out-of-order.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-out-of-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-out-of-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-out-of-order.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that you can list the more specific impl before the more general one.\n+\n+#![feature(specialization)]\n+\n+trait Foo {\n+    type Out;\n+}\n+\n+impl Foo for bool {\n+    type Out = ();\n+}\n+\n+impl<T> Foo for T {\n+    default type Out = bool;\n+}\n+\n+fn main() {}"}, {"sha": "20046ee66b0e24868e8d4e2b658663e814823e0d", "filename": "src/test/run-pass/specialization/specialization-overlap-projection.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-overlap-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-overlap-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-overlap-projection.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that impls on projected self types can resolve overlap, even when the\n+// projections involve specialization, so long as the associated type is\n+// provided by the most specialized impl.\n+\n+#![feature(specialization)]\n+\n+trait Assoc {\n+    type Output;\n+}\n+\n+impl<T> Assoc for T {\n+    default type Output = bool;\n+}\n+\n+impl Assoc for u8 { type Output = u8; }\n+impl Assoc for u16 { type Output = u16; }\n+\n+trait Foo {}\n+impl Foo for u32 {}\n+impl Foo for <u8 as Assoc>::Output {}\n+impl Foo for <u16 as Assoc>::Output {}\n+\n+fn main() {}"}, {"sha": "7fce1cca582c15a6f1c186462bf5e3c132ae880b", "filename": "src/test/run-pass/specialization/specialization-projection-alias.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-projection-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-projection-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-projection-alias.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+// Regression test for ICE when combining specialized associated types and type\n+// aliases\n+\n+trait Id_ {\n+    type Out;\n+}\n+\n+type Id<T> = <T as Id_>::Out;\n+\n+impl<T> Id_ for T {\n+    default type Out = T;\n+}\n+\n+fn test_proection() {\n+    let x: Id<bool> = panic!();\n+}\n+\n+fn main() {\n+\n+}"}, {"sha": "4e0bdec297fe2b26b5aa1f7d68c239dcd3e9cc52", "filename": "src/test/run-pass/specialization/specialization-projection.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-projection.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+// Make sure we *can* project non-defaulted associated types\n+// cf compile-fail/specialization-default-projection.rs\n+\n+// First, do so without any use of specialization\n+\n+trait Foo {\n+    type Assoc;\n+}\n+\n+impl<T> Foo for T {\n+    type Assoc = ();\n+}\n+\n+fn generic_foo<T>() -> <T as Foo>::Assoc {\n+    ()\n+}\n+\n+// Next, allow for one layer of specialization\n+\n+trait Bar {\n+    type Assoc;\n+}\n+\n+impl<T> Bar for T {\n+    default type Assoc = ();\n+}\n+\n+impl<T: Clone> Bar for T {\n+    type Assoc = u8;\n+}\n+\n+fn generic_bar_clone<T: Clone>() -> <T as Bar>::Assoc {\n+    0u8\n+}\n+\n+fn main() {\n+}"}, {"sha": "a9b3bfca53d1862c35b6b1f3fdfa85f78761ab41", "filename": "src/test/run-pass/specialization/specialization-super-traits.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-super-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-super-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-super-traits.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+// Test that you can specialize via an explicit trait hierarchy\n+\n+// FIXME: this doesn't work yet...\n+\n+trait Parent {}\n+trait Child: Parent {}\n+\n+trait Foo {}\n+\n+impl<T: Parent> Foo for T {}\n+impl<T: Child> Foo for T {}\n+\n+fn main() {}"}, {"sha": "647d5523c376c5956876b8f46b521fec0ab50895", "filename": "src/test/run-pass/specialization/specialization-translate-projections-with-params.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-translate-projections-with-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-translate-projections-with-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-translate-projections-with-params.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that provided items are inherited properly even when impls vary in\n+// type parameters *and* rely on projections, and the type parameters are input\n+// types on the trait.\n+\n+#![feature(specialization)]\n+\n+trait Trait<T> {\n+    fn convert(&self) -> T;\n+}\n+trait WithAssoc {\n+    type Item;\n+    fn as_item(&self) -> &Self::Item;\n+}\n+\n+impl<T, U> Trait<U> for T where T: WithAssoc<Item=U>, U: Clone {\n+    fn convert(&self) -> U {\n+        self.as_item().clone()\n+    }\n+}\n+\n+impl WithAssoc for u8 {\n+    type Item = u8;\n+    fn as_item(&self) -> &u8 { self }\n+}\n+\n+impl Trait<u8> for u8 {}\n+\n+fn main() {\n+    assert!(3u8.convert() == 3u8);\n+}"}, {"sha": "11e1d997fdda07e230148064ec536d16d4b3ba39", "filename": "src/test/run-pass/specialization/specialization-translate-projections.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-translate-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-translate-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fspecialization-translate-projections.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Ensure that provided items are inherited properly even when impls vary in\n+// type parameters *and* rely on projections.\n+\n+#![feature(specialization)]\n+\n+use std::convert::Into;\n+\n+trait Trait {\n+    fn to_u8(&self) -> u8;\n+}\n+trait WithAssoc {\n+    type Item;\n+    fn to_item(&self) -> Self::Item;\n+}\n+\n+impl<T, U> Trait for T where T: WithAssoc<Item=U>, U: Into<u8> {\n+    fn to_u8(&self) -> u8 {\n+        self.to_item().into()\n+    }\n+}\n+\n+impl WithAssoc for u8 {\n+    type Item = u8;\n+    fn to_item(&self) -> u8 { *self }\n+}\n+\n+impl Trait for u8 {}\n+\n+fn main() {\n+    assert!(3u8.to_u8() == 3u8);\n+}"}, {"sha": "2dacbe0966ee37b68d6b7299b4737b2d0001ccf5", "filename": "src/test/run-pass/xcrate-associated-type-defaults.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fxcrate-associated-type-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ca75619dc80f71f356cab0cdd11cc959e4c24db/src%2Ftest%2Frun-pass%2Fxcrate-associated-type-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-associated-type-defaults.rs?ref=9ca75619dc80f71f356cab0cdd11cc959e4c24db", "patch": "@@ -13,6 +13,26 @@\n extern crate xcrate_associated_type_defaults;\n use xcrate_associated_type_defaults::Foo;\n \n+struct LocalDefault;\n+impl Foo<u32> for LocalDefault {}\n+\n+struct LocalOverride;\n+impl Foo<u64> for LocalOverride {\n+    type Out = bool;\n+}\n+\n fn main() {\n-    ().bar(5);\n+    assert_eq!(\n+        <() as Foo<u32>>::Out::default().to_string(),\n+        \"0\");\n+    assert_eq!(\n+        <() as Foo<u64>>::Out::default().to_string(),\n+        \"false\");\n+\n+    assert_eq!(\n+        <LocalDefault as Foo<u32>>::Out::default().to_string(),\n+        \"0\");\n+    assert_eq!(\n+        <LocalOverride as Foo<u64>>::Out::default().to_string(),\n+        \"false\");\n }"}]}