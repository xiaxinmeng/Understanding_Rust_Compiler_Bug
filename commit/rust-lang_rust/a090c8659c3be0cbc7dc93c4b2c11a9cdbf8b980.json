{"sha": "a090c8659c3be0cbc7dc93c4b2c11a9cdbf8b980", "node_id": "C_kwDOAAsO6NoAKGEwOTBjODY1OWMzYmUwY2JjN2RjOTNjNGIyYzExYTljZGJmOGI5ODA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-16T07:58:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-16T07:58:36Z"}, "message": "Auto merge of #91527 - the8472:retain-opt, r=dtolnay\n\nOptimize `vec::retain` performance\n\nThis simply moves the loops into the inner function which leads to better results.\n\n```\nold:\n\ntest vec::bench_retain_100000                            ... bench:     203,828 ns/iter (+/- 2,101)\ntest vec::bench_retain_iter_100000                       ... bench:      63,324 ns/iter (+/- 12,305)\ntest vec::bench_retain_whole_100000                      ... bench:      42,989 ns/iter (+/- 291)\n\nnew:\n\ntest vec::bench_retain_100000                            ... bench:      42,180 ns/iter (+/- 451)\ntest vec::bench_retain_iter_100000                       ... bench:      65,167 ns/iter (+/- 11,971)\ntest vec::bench_retain_whole_100000                      ... bench:      33,736 ns/iter (+/- 12,404)\n```\n\nMeasured on x86_64-unknown-linux-gnu, Zen2\n\nFixes #91497", "tree": {"sha": "51187e7cb6ee1c308e65f0ea8494c212091fa39f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51187e7cb6ee1c308e65f0ea8494c212091fa39f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a090c8659c3be0cbc7dc93c4b2c11a9cdbf8b980", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a090c8659c3be0cbc7dc93c4b2c11a9cdbf8b980", "html_url": "https://github.com/rust-lang/rust/commit/a090c8659c3be0cbc7dc93c4b2c11a9cdbf8b980", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a090c8659c3be0cbc7dc93c4b2c11a9cdbf8b980/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e1aff82e696c0edb568656ae6b509a9ab4d6c92", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e1aff82e696c0edb568656ae6b509a9ab4d6c92", "html_url": "https://github.com/rust-lang/rust/commit/9e1aff82e696c0edb568656ae6b509a9ab4d6c92"}, {"sha": "67180ef056b76f5d90c2164895adbe88fa056332", "url": "https://api.github.com/repos/rust-lang/rust/commits/67180ef056b76f5d90c2164895adbe88fa056332", "html_url": "https://github.com/rust-lang/rust/commit/67180ef056b76f5d90c2164895adbe88fa056332"}], "stats": {"total": 80, "additions": 46, "deletions": 34}, "files": [{"sha": "0da4886278e396bc497491882544d8a2870fbfb8", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a090c8659c3be0cbc7dc93c4b2c11a9cdbf8b980/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a090c8659c3be0cbc7dc93c4b2c11a9cdbf8b980/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=a090c8659c3be0cbc7dc93c4b2c11a9cdbf8b980", "patch": "@@ -733,11 +733,26 @@ fn bench_flat_map_collect(b: &mut Bencher) {\n     b.iter(|| v.iter().flat_map(|color| color.rotate_left(8).to_be_bytes()).collect::<Vec<_>>());\n }\n \n+/// Reference benchmark that `retain` has to compete with.\n+#[bench]\n+fn bench_retain_iter_100000(b: &mut Bencher) {\n+    let mut v = Vec::with_capacity(100000);\n+\n+    b.iter(|| {\n+        let mut tmp = std::mem::take(&mut v);\n+        tmp.clear();\n+        tmp.extend(black_box(1..=100000));\n+        v = tmp.into_iter().filter(|x| x & 1 == 0).collect();\n+    });\n+}\n+\n #[bench]\n fn bench_retain_100000(b: &mut Bencher) {\n-    let v = (1..=100000).collect::<Vec<u32>>();\n+    let mut v = Vec::with_capacity(100000);\n+\n     b.iter(|| {\n-        let mut v = v.clone();\n+        v.clear();\n+        v.extend(black_box(1..=100000));\n         v.retain(|x| x & 1 == 0)\n     });\n }"}, {"sha": "d24b4bdffdefcd61d8e94284eb2ae5ef9a032806", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a090c8659c3be0cbc7dc93c4b2c11a9cdbf8b980/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a090c8659c3be0cbc7dc93c4b2c11a9cdbf8b980/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=a090c8659c3be0cbc7dc93c4b2c11a9cdbf8b980", "patch": "@@ -1520,49 +1520,46 @@ impl<T, A: Allocator> Vec<T, A> {\n \n         let mut g = BackshiftOnDrop { v: self, processed_len: 0, deleted_cnt: 0, original_len };\n \n-        // process_one return a bool indicates whether the processing element should be retained.\n-        #[inline(always)]\n-        fn process_one<F, T, A: Allocator, const DELETED: bool>(\n+        fn process_loop<F, T, A: Allocator, const DELETED: bool>(\n+            original_len: usize,\n             f: &mut F,\n             g: &mut BackshiftOnDrop<'_, T, A>,\n-        ) -> bool\n-        where\n+        ) where\n             F: FnMut(&mut T) -> bool,\n         {\n-            // SAFETY: Unchecked element must be valid.\n-            let cur = unsafe { &mut *g.v.as_mut_ptr().add(g.processed_len) };\n-            if !f(cur) {\n-                // Advance early to avoid double drop if `drop_in_place` panicked.\n-                g.processed_len += 1;\n-                g.deleted_cnt += 1;\n-                // SAFETY: We never touch this element again after dropped.\n-                unsafe { ptr::drop_in_place(cur) };\n-                // We already advanced the counter.\n-                return false;\n-            }\n-            if DELETED {\n-                // SAFETY: `deleted_cnt` > 0, so the hole slot must not overlap with current element.\n-                // We use copy for move, and never touch this element again.\n-                unsafe {\n-                    let hole_slot = g.v.as_mut_ptr().add(g.processed_len - g.deleted_cnt);\n-                    ptr::copy_nonoverlapping(cur, hole_slot, 1);\n+            while g.processed_len != original_len {\n+                // SAFETY: Unchecked element must be valid.\n+                let cur = unsafe { &mut *g.v.as_mut_ptr().add(g.processed_len) };\n+                if !f(cur) {\n+                    // Advance early to avoid double drop if `drop_in_place` panicked.\n+                    g.processed_len += 1;\n+                    g.deleted_cnt += 1;\n+                    // SAFETY: We never touch this element again after dropped.\n+                    unsafe { ptr::drop_in_place(cur) };\n+                    // We already advanced the counter.\n+                    if DELETED {\n+                        continue;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                if DELETED {\n+                    // SAFETY: `deleted_cnt` > 0, so the hole slot must not overlap with current element.\n+                    // We use copy for move, and never touch this element again.\n+                    unsafe {\n+                        let hole_slot = g.v.as_mut_ptr().add(g.processed_len - g.deleted_cnt);\n+                        ptr::copy_nonoverlapping(cur, hole_slot, 1);\n+                    }\n                 }\n+                g.processed_len += 1;\n             }\n-            g.processed_len += 1;\n-            return true;\n         }\n \n         // Stage 1: Nothing was deleted.\n-        while g.processed_len != original_len {\n-            if !process_one::<F, T, A, false>(&mut f, &mut g) {\n-                break;\n-            }\n-        }\n+        process_loop::<F, T, A, false>(original_len, &mut f, &mut g);\n \n         // Stage 2: Some elements were deleted.\n-        while g.processed_len != original_len {\n-            process_one::<F, T, A, true>(&mut f, &mut g);\n-        }\n+        process_loop::<F, T, A, true>(original_len, &mut f, &mut g);\n \n         // All item are processed. This can be optimized to `set_len` by LLVM.\n         drop(g);"}]}