{"sha": "6b5efe5bdab160278469417734f4bb619c7bac61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiNWVmZTViZGFiMTYwMjc4NDY5NDE3NzM0ZjRiYjYxOWM3YmFjNjE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-21T13:46:15Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-22T23:08:03Z"}, "message": "Refactor Chalk integration some more", "tree": {"sha": "a1b398f6ace8141cabb01c0cc569983bd1213474", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1b398f6ace8141cabb01c0cc569983bd1213474"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b5efe5bdab160278469417734f4bb619c7bac61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b5efe5bdab160278469417734f4bb619c7bac61", "html_url": "https://github.com/rust-lang/rust/commit/6b5efe5bdab160278469417734f4bb619c7bac61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b5efe5bdab160278469417734f4bb619c7bac61/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67a2555f6d4c3914742fd42645ca043cf56f358b", "url": "https://api.github.com/repos/rust-lang/rust/commits/67a2555f6d4c3914742fd42645ca043cf56f358b", "html_url": "https://github.com/rust-lang/rust/commit/67a2555f6d4c3914742fd42645ca043cf56f358b"}], "stats": {"total": 162, "additions": 83, "deletions": 79}, "files": [{"sha": "fbab609251d69e43f12dec126fba248312c4f270", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b5efe5bdab160278469417734f4bb619c7bac61/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b5efe5bdab160278469417734f4bb619c7bac61/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=6b5efe5bdab160278469417734f4bb619c7bac61", "patch": "@@ -1,7 +1,7 @@\n //! Trait solving using Chalk.\n use std::sync::{Arc, Mutex};\n \n-use chalk_ir::{cast::Cast, family::ChalkIr};\n+use chalk_ir::cast::Cast;\n use hir_def::{expr::ExprId, DefWithBodyId, ImplId, TraitId, TypeAliasId};\n use log::debug;\n use ra_db::{impl_intern_key, salsa, CrateId};\n@@ -12,15 +12,15 @@ use crate::db::HirDatabase;\n \n use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n \n-use self::chalk::{from_chalk, ToChalk};\n+use self::chalk::{from_chalk, ToChalk, TypeFamily};\n \n pub(crate) mod chalk;\n mod builtin;\n \n #[derive(Debug, Clone)]\n pub struct TraitSolver {\n     krate: CrateId,\n-    inner: Arc<Mutex<chalk_solve::Solver<ChalkIr>>>,\n+    inner: Arc<Mutex<chalk_solve::Solver<TypeFamily>>>,\n }\n \n /// We need eq for salsa\n@@ -36,8 +36,8 @@ impl TraitSolver {\n     fn solve(\n         &self,\n         db: &impl HirDatabase,\n-        goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal<ChalkIr>>>,\n-    ) -> Option<chalk_solve::Solution<ChalkIr>> {\n+        goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal<TypeFamily>>>,\n+    ) -> Option<chalk_solve::Solution<TypeFamily>> {\n         let context = ChalkContext { db, krate: self.krate };\n         debug!(\"solve goal: {:?}\", goal);\n         let mut solver = match self.inner.lock() {\n@@ -201,9 +201,9 @@ pub(crate) fn trait_solve_query(\n \n fn solution_from_chalk(\n     db: &impl HirDatabase,\n-    solution: chalk_solve::Solution<ChalkIr>,\n+    solution: chalk_solve::Solution<TypeFamily>,\n ) -> Solution {\n-    let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution<ChalkIr>>| {\n+    let convert_subst = |subst: chalk_ir::Canonical<chalk_ir::Substitution<TypeFamily>>| {\n         let value = subst\n             .value\n             .parameters"}, {"sha": "d53d3fdebd32144002dd54a5dd8b8a9e80a57522", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 76, "deletions": 72, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/6b5efe5bdab160278469417734f4bb619c7bac61/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b5efe5bdab160278469417734f4bb619c7bac61/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=6b5efe5bdab160278469417734f4bb619c7bac61", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n \n use log::debug;\n \n-use chalk_ir::{cast::Cast, family::ChalkIr, Parameter, PlaceholderIndex, TypeName, UniverseIndex};\n+use chalk_ir::{cast::Cast, Parameter, PlaceholderIndex, TypeName, UniverseIndex};\n \n use hir_def::{AssocContainerId, AssocItemId, GenericDefId, HasModule, Lookup, TypeAliasId};\n use ra_db::{\n@@ -17,7 +17,7 @@ use crate::{\n     ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n-pub type TypeFamily = chalk_ir::family::ChalkIr; // TODO use everywhere\n+pub type TypeFamily = chalk_ir::family::ChalkIr;\n pub type AssocTypeId = chalk_ir::AssocTypeId<TypeFamily>;\n pub type AssociatedTyDatum = chalk_rust_ir::AssociatedTyDatum<TypeFamily>;\n pub type TraitId = chalk_ir::TraitId<TypeFamily>;\n@@ -46,21 +46,11 @@ where\n }\n \n impl ToChalk for Ty {\n-    type Chalk = chalk_ir::Ty<ChalkIr>;\n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Ty<ChalkIr> {\n+    type Chalk = chalk_ir::Ty<TypeFamily>;\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Ty<TypeFamily> {\n         match self {\n             Ty::Apply(apply_ty) => {\n-                let name = match apply_ty.ctor {\n-                    TypeCtor::AssociatedType(type_alias) => {\n-                        let type_id = type_alias.to_chalk(db);\n-                        TypeName::AssociatedType(type_id)\n-                    }\n-                    _ => {\n-                        // other TypeCtors get interned and turned into a chalk StructId\n-                        let struct_id = apply_ty.ctor.to_chalk(db);\n-                        TypeName::Struct(struct_id.into())\n-                    }\n-                };\n+                let name = apply_ty.ctor.to_chalk(db);\n                 let parameters = apply_ty.parameters.to_chalk(db);\n                 chalk_ir::ApplicationTy { name, parameters }.cast().intern()\n             }\n@@ -70,7 +60,8 @@ impl ToChalk for Ty {\n                 chalk_ir::ProjectionTy { associated_ty_id, parameters }.cast().intern()\n             }\n             Ty::Param { idx, .. } => {\n-                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }.to_ty::<ChalkIr>()\n+                PlaceholderIndex { ui: UniverseIndex::ROOT, idx: idx as usize }\n+                    .to_ty::<TypeFamily>()\n             }\n             Ty::Bound(idx) => chalk_ir::TyData::BoundVar(idx as usize).intern(),\n             Ty::Infer(_infer_ty) => panic!(\"uncanonicalized infer ty\"),\n@@ -91,24 +82,16 @@ impl ToChalk for Ty {\n             }\n         }\n     }\n-    fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty<ChalkIr>) -> Self {\n+    fn from_chalk(db: &impl HirDatabase, chalk: chalk_ir::Ty<TypeFamily>) -> Self {\n         match chalk.data().clone() {\n-            chalk_ir::TyData::Apply(apply_ty) => {\n-                // TODO clean this up now that Placeholder isn't in TypeName anymore\n-                match apply_ty.name {\n-                    TypeName::Struct(struct_id) => {\n-                        let ctor = from_chalk(db, struct_id);\n-                        let parameters = from_chalk(db, apply_ty.parameters);\n-                        Ty::Apply(ApplicationTy { ctor, parameters })\n-                    }\n-                    TypeName::AssociatedType(type_id) => {\n-                        let ctor = TypeCtor::AssociatedType(from_chalk(db, type_id));\n-                        let parameters = from_chalk(db, apply_ty.parameters);\n-                        Ty::Apply(ApplicationTy { ctor, parameters })\n-                    }\n-                    TypeName::Error => Ty::Unknown,\n+            chalk_ir::TyData::Apply(apply_ty) => match apply_ty.name {\n+                TypeName::Error => Ty::Unknown,\n+                _ => {\n+                    let ctor = from_chalk(db, apply_ty.name);\n+                    let parameters = from_chalk(db, apply_ty.parameters);\n+                    Ty::Apply(ApplicationTy { ctor, parameters })\n                 }\n-            }\n+            },\n             chalk_ir::TyData::Placeholder(idx) => {\n                 assert_eq!(idx.ui, UniverseIndex::ROOT);\n                 Ty::Param { idx: idx.idx as u32, name: crate::Name::missing() }\n@@ -138,13 +121,16 @@ impl ToChalk for Ty {\n }\n \n impl ToChalk for Substs {\n-    type Chalk = Vec<chalk_ir::Parameter<ChalkIr>>;\n+    type Chalk = Vec<chalk_ir::Parameter<TypeFamily>>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> Vec<Parameter<ChalkIr>> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> Vec<Parameter<TypeFamily>> {\n         self.iter().map(|ty| ty.clone().to_chalk(db).cast()).collect()\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, parameters: Vec<chalk_ir::Parameter<ChalkIr>>) -> Substs {\n+    fn from_chalk(\n+        db: &impl HirDatabase,\n+        parameters: Vec<chalk_ir::Parameter<TypeFamily>>,\n+    ) -> Substs {\n         let tys = parameters\n             .into_iter()\n             .map(|p| match p.ty() {\n@@ -157,15 +143,15 @@ impl ToChalk for Substs {\n }\n \n impl ToChalk for TraitRef {\n-    type Chalk = chalk_ir::TraitRef<ChalkIr>;\n+    type Chalk = chalk_ir::TraitRef<TypeFamily>;\n \n-    fn to_chalk(self: TraitRef, db: &impl HirDatabase) -> chalk_ir::TraitRef<ChalkIr> {\n+    fn to_chalk(self: TraitRef, db: &impl HirDatabase) -> chalk_ir::TraitRef<TypeFamily> {\n         let trait_id = self.trait_.to_chalk(db);\n         let parameters = self.substs.to_chalk(db);\n         chalk_ir::TraitRef { trait_id, parameters }\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, trait_ref: chalk_ir::TraitRef<ChalkIr>) -> Self {\n+    fn from_chalk(db: &impl HirDatabase, trait_ref: chalk_ir::TraitRef<TypeFamily>) -> Self {\n         let trait_ = from_chalk(db, trait_ref.trait_id);\n         let substs = from_chalk(db, trait_ref.parameters);\n         TraitRef { trait_, substs }\n@@ -185,14 +171,31 @@ impl ToChalk for hir_def::TraitId {\n }\n \n impl ToChalk for TypeCtor {\n-    type Chalk = StructId;\n+    type Chalk = TypeName<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> StructId {\n-        db.intern_type_ctor(self).into()\n+    fn to_chalk(self, db: &impl HirDatabase) -> TypeName<TypeFamily> {\n+        match self {\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let type_id = type_alias.to_chalk(db);\n+                TypeName::AssociatedType(type_id)\n+            }\n+            _ => {\n+                // other TypeCtors get interned and turned into a chalk StructId\n+                let struct_id = db.intern_type_ctor(self).into();\n+                TypeName::Struct(struct_id)\n+            }\n+        }\n     }\n \n-    fn from_chalk(db: &impl HirDatabase, struct_id: StructId) -> TypeCtor {\n-        db.lookup_intern_type_ctor(struct_id.into())\n+    fn from_chalk(db: &impl HirDatabase, type_name: TypeName<TypeFamily>) -> TypeCtor {\n+        match type_name {\n+            TypeName::Struct(struct_id) => db.lookup_intern_type_ctor(struct_id.into()),\n+            TypeName::AssociatedType(type_id) => TypeCtor::AssociatedType(from_chalk(db, type_id)),\n+            TypeName::Error => {\n+                // this should not be reached, since we don't represent TypeName::Error with TypeCtor\n+                unreachable!()\n+            }\n+        }\n     }\n }\n \n@@ -233,9 +236,9 @@ impl ToChalk for AssocTyValue {\n }\n \n impl ToChalk for GenericPredicate {\n-    type Chalk = chalk_ir::QuantifiedWhereClause<ChalkIr>;\n+    type Chalk = chalk_ir::QuantifiedWhereClause<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::QuantifiedWhereClause<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::QuantifiedWhereClause<TypeFamily> {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => {\n                 make_binders(chalk_ir::WhereClause::Implemented(trait_ref.to_chalk(db)), 0)\n@@ -259,7 +262,7 @@ impl ToChalk for GenericPredicate {\n \n     fn from_chalk(\n         db: &impl HirDatabase,\n-        where_clause: chalk_ir::QuantifiedWhereClause<ChalkIr>,\n+        where_clause: chalk_ir::QuantifiedWhereClause<TypeFamily>,\n     ) -> GenericPredicate {\n         match where_clause.value {\n             chalk_ir::WhereClause::Implemented(tr) => {\n@@ -279,9 +282,9 @@ impl ToChalk for GenericPredicate {\n }\n \n impl ToChalk for ProjectionTy {\n-    type Chalk = chalk_ir::ProjectionTy<ChalkIr>;\n+    type Chalk = chalk_ir::ProjectionTy<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ProjectionTy<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::ProjectionTy<TypeFamily> {\n         chalk_ir::ProjectionTy {\n             associated_ty_id: self.associated_ty.to_chalk(db),\n             parameters: self.parameters.to_chalk(db),\n@@ -290,7 +293,7 @@ impl ToChalk for ProjectionTy {\n \n     fn from_chalk(\n         db: &impl HirDatabase,\n-        projection_ty: chalk_ir::ProjectionTy<ChalkIr>,\n+        projection_ty: chalk_ir::ProjectionTy<TypeFamily>,\n     ) -> ProjectionTy {\n         ProjectionTy {\n             associated_ty: from_chalk(db, projection_ty.associated_ty_id),\n@@ -300,31 +303,31 @@ impl ToChalk for ProjectionTy {\n }\n \n impl ToChalk for super::ProjectionPredicate {\n-    type Chalk = chalk_ir::Normalize<ChalkIr>;\n+    type Chalk = chalk_ir::Normalize<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Normalize<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Normalize<TypeFamily> {\n         chalk_ir::Normalize {\n             projection: self.projection_ty.to_chalk(db),\n             ty: self.ty.to_chalk(db),\n         }\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, _normalize: chalk_ir::Normalize<ChalkIr>) -> Self {\n+    fn from_chalk(_db: &impl HirDatabase, _normalize: chalk_ir::Normalize<TypeFamily>) -> Self {\n         unimplemented!()\n     }\n }\n \n impl ToChalk for Obligation {\n-    type Chalk = chalk_ir::DomainGoal<ChalkIr>;\n+    type Chalk = chalk_ir::DomainGoal<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::DomainGoal<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::DomainGoal<TypeFamily> {\n         match self {\n             Obligation::Trait(tr) => tr.to_chalk(db).cast(),\n             Obligation::Projection(pr) => pr.to_chalk(db).cast(),\n         }\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, _goal: chalk_ir::DomainGoal<ChalkIr>) -> Self {\n+    fn from_chalk(_db: &impl HirDatabase, _goal: chalk_ir::DomainGoal<TypeFamily>) -> Self {\n         unimplemented!()\n     }\n }\n@@ -348,32 +351,33 @@ where\n }\n \n impl ToChalk for Arc<super::TraitEnvironment> {\n-    type Chalk = chalk_ir::Environment<ChalkIr>;\n+    type Chalk = chalk_ir::Environment<TypeFamily>;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Environment<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Environment<TypeFamily> {\n         let mut clauses = Vec::new();\n         for pred in &self.predicates {\n             if pred.is_error() {\n                 // for env, we just ignore errors\n                 continue;\n             }\n-            let program_clause: chalk_ir::ProgramClause<ChalkIr> = pred.clone().to_chalk(db).cast();\n+            let program_clause: chalk_ir::ProgramClause<TypeFamily> =\n+                pred.clone().to_chalk(db).cast();\n             clauses.push(program_clause.into_from_env_clause());\n         }\n         chalk_ir::Environment::new().add_clauses(clauses)\n     }\n \n     fn from_chalk(\n         _db: &impl HirDatabase,\n-        _env: chalk_ir::Environment<ChalkIr>,\n+        _env: chalk_ir::Environment<TypeFamily>,\n     ) -> Arc<super::TraitEnvironment> {\n         unimplemented!()\n     }\n }\n \n impl<T: ToChalk> ToChalk for super::InEnvironment<T>\n where\n-    T::Chalk: chalk_ir::family::HasTypeFamily<TypeFamily = ChalkIr>,\n+    T::Chalk: chalk_ir::family::HasTypeFamily<TypeFamily = TypeFamily>,\n {\n     type Chalk = chalk_ir::InEnvironment<T::Chalk>;\n \n@@ -396,9 +400,9 @@ where\n }\n \n impl ToChalk for builtin::BuiltinImplData {\n-    type Chalk = chalk_rust_ir::ImplDatum<ChalkIr>;\n+    type Chalk = ImplDatum;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_rust_ir::ImplDatum<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> ImplDatum {\n         let impl_type = chalk_rust_ir::ImplType::External;\n         let where_clauses = self.where_clauses.into_iter().map(|w| w.to_chalk(db)).collect();\n \n@@ -414,15 +418,15 @@ impl ToChalk for builtin::BuiltinImplData {\n         }\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, _data: chalk_rust_ir::ImplDatum<ChalkIr>) -> Self {\n+    fn from_chalk(_db: &impl HirDatabase, _data: ImplDatum) -> Self {\n         unimplemented!()\n     }\n }\n \n impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n-    type Chalk = chalk_rust_ir::AssociatedTyValue<ChalkIr>;\n+    type Chalk = AssociatedTyValue;\n \n-    fn to_chalk(self, db: &impl HirDatabase) -> chalk_rust_ir::AssociatedTyValue<ChalkIr> {\n+    fn to_chalk(self, db: &impl HirDatabase) -> AssociatedTyValue {\n         let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: self.value.to_chalk(db) };\n \n         chalk_rust_ir::AssociatedTyValue {\n@@ -434,7 +438,7 @@ impl ToChalk for builtin::BuiltinImplAssocTyValueData {\n \n     fn from_chalk(\n         _db: &impl HirDatabase,\n-        _data: chalk_rust_ir::AssociatedTyValue<ChalkIr>,\n+        _data: AssociatedTyValue,\n     ) -> builtin::BuiltinImplAssocTyValueData {\n         unimplemented!()\n     }\n@@ -451,7 +455,7 @@ fn convert_where_clauses(\n     db: &impl HirDatabase,\n     def: GenericDefId,\n     substs: &Substs,\n-) -> Vec<chalk_ir::QuantifiedWhereClause<ChalkIr>> {\n+) -> Vec<chalk_ir::QuantifiedWhereClause<TypeFamily>> {\n     let generic_predicates = db.generic_predicates(def);\n     let mut result = Vec::with_capacity(generic_predicates.len());\n     for pred in generic_predicates.iter() {\n@@ -465,7 +469,7 @@ fn convert_where_clauses(\n     result\n }\n \n-impl<'a, DB> chalk_solve::RustIrDatabase<ChalkIr> for ChalkContext<'a, DB>\n+impl<'a, DB> chalk_solve::RustIrDatabase<TypeFamily> for ChalkContext<'a, DB>\n where\n     DB: HirDatabase,\n {\n@@ -516,7 +520,7 @@ where\n     fn associated_ty_value(&self, id: AssociatedTyValueId) -> Arc<AssociatedTyValue> {\n         self.db.associated_ty_value(self.krate.into(), id)\n     }\n-    fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<ChalkIr>> {\n+    fn custom_clauses(&self) -> Vec<chalk_ir::ProgramClause<TypeFamily>> {\n         vec![]\n     }\n     fn local_impls_to_coherence_check(&self, _trait_id: TraitId) -> Vec<ImplId> {\n@@ -613,7 +617,7 @@ pub(crate) fn struct_datum_query(\n     struct_id: StructId,\n ) -> Arc<StructDatum> {\n     debug!(\"struct_datum {:?}\", struct_id);\n-    let type_ctor: TypeCtor = from_chalk(db, struct_id);\n+    let type_ctor: TypeCtor = from_chalk(db, TypeName::Struct(struct_id));\n     debug!(\"struct {:?} = {:?}\", struct_id, type_ctor);\n     let num_params = type_ctor.num_ty_params(db);\n     let upstream = type_ctor.krate(db) != Some(krate);\n@@ -733,8 +737,8 @@ fn invalid_impl_datum() -> Arc<ImplDatum> {\n pub(crate) fn associated_ty_value_query(\n     db: &impl HirDatabase,\n     krate: CrateId,\n-    id: chalk_rust_ir::AssociatedTyValueId,\n-) -> Arc<chalk_rust_ir::AssociatedTyValue<ChalkIr>> {\n+    id: AssociatedTyValueId,\n+) -> Arc<AssociatedTyValue> {\n     let data: AssocTyValue = from_chalk(db, id);\n     match data {\n         AssocTyValue::TypeAlias(type_alias) => {"}]}