{"sha": "986b3a07c27a78ddb380178546a69f40c2fc1f77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NmIzYTA3YzI3YTc4ZGRiMzgwMTc4NTQ2YTY5ZjQwYzJmYzFmNzc=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-11-17T16:23:40Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-11-18T09:38:07Z"}, "message": "layout computation can fail, make it fail with a miri error", "tree": {"sha": "303ce396f4d1b99d70ed78e120dc95e956fe3329", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/303ce396f4d1b99d70ed78e120dc95e956fe3329"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/986b3a07c27a78ddb380178546a69f40c2fc1f77", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYLsv/AAoJEFbW7qD8Z6xGMSwP/ibSIWnu3Whka6dMRbQQ3242\nniDl1rHEaS4ojM3+/SLTOYXACJnBf2zZTxXCfoLV8MAS+iYWjtQD1sAAl6/Fbzm8\nbZBC2/a/UTow747AQk02KSyUdJ3xIPHcC6219UL8u3ObzrwvLIcXmdxSfLw3JUrr\nq1ZFIyq6/oG/SuK3WZ7jKDEfosi/utsHXTOGvtO+ptOvyKozgZUY7DHJ5Chdtm1N\nAGOLoh9MS0Xl1omhFxBIxtiJEizSXqjgzhkhrKFO56ZqjUCeim5eG9tPSAB0gSjB\n7+8MrZETHBzha7T/fPF2smi3ozBWuTwGpZil/xt1rw7B6nqlk49py2tPqNXXl8k0\nb5EXQsF9UcmG9rrxHj15MfNMtuMwcj+CfHmimSAqGhpXvKJ2izVCceVtIhzhO5li\noA83m4ojweQ/ZGqZHc+UfWqxhWJX/FcdPULIII64Y+3/NvC3ZbVLKR/yeptMbwOh\nKVGTa4B26PPqr+rDM5RGmhxWehrI7HVBau9ovy06kuh7g3236ObSMm9Z14YuMmM+\nuOm+8cErhBvS/ztzgMhn0EpUbysJa1lbwb3/2Fi8PTvTcwOPWC/mDj6leZ4N+k62\nzZ37lR+iK570S1W9hyTRc/LaW6C81hvvB3CCoORUOo1vvzRSRRhWMg+cZZOqeOeb\nDo9xBe6CPWRAE+/X+Xnx\n=AR1x\n-----END PGP SIGNATURE-----", "payload": "tree 303ce396f4d1b99d70ed78e120dc95e956fe3329\nparent 26ccc1e4bc48e54cf39b1c762dec4252520835a5\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1479399820 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1479461887 +0100\n\nlayout computation can fail, make it fail with a miri error"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/986b3a07c27a78ddb380178546a69f40c2fc1f77", "html_url": "https://github.com/rust-lang/rust/commit/986b3a07c27a78ddb380178546a69f40c2fc1f77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/986b3a07c27a78ddb380178546a69f40c2fc1f77/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26ccc1e4bc48e54cf39b1c762dec4252520835a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/26ccc1e4bc48e54cf39b1c762dec4252520835a5", "html_url": "https://github.com/rust-lang/rust/commit/26ccc1e4bc48e54cf39b1c762dec4252520835a5"}], "stats": {"total": 131, "additions": 71, "deletions": 60}, "files": [{"sha": "65cbcc97015637bedb405a97409309e66e5d09aa", "filename": "src/error.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/986b3a07c27a78ddb380178546a69f40c2fc1f77/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986b3a07c27a78ddb380178546a69f40c2fc1f77/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=986b3a07c27a78ddb380178546a69f40c2fc1f77", "patch": "@@ -1,13 +1,13 @@\n use std::error::Error;\n use std::fmt;\n use rustc::mir;\n-use rustc::ty::{BareFnTy, Ty, FnSig};\n+use rustc::ty::{BareFnTy, Ty, FnSig, layout};\n use syntax::abi::Abi;\n use memory::Pointer;\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug)]\n pub enum EvalError<'tcx> {\n     FunctionPointerTyMismatch(Abi, &'tcx FnSig<'tcx>, &'tcx BareFnTy<'tcx>),\n     NoMirFor(String),\n@@ -50,6 +50,7 @@ pub enum EvalError<'tcx> {\n     TypeNotPrimitive(Ty<'tcx>),\n     ReallocatedFrozenMemory,\n     DeallocatedFrozenMemory,\n+    Layout(layout::LayoutError<'tcx>),\n }\n \n pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n@@ -116,6 +117,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"tried to reallocate frozen memory\",\n             EvalError::DeallocatedFrozenMemory =>\n                 \"tried to deallocate frozen memory\",\n+            EvalError::Layout(_) =>\n+                \"rustc layout computation failed\",\n         }\n     }\n \n@@ -146,6 +149,8 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                       has, required),\n             EvalError::TypeNotPrimitive(ref ty) =>\n                 write!(f, \"expected primitive type, got {}\", ty),\n+            EvalError::Layout(ref err) =>\n+                write!(f, \"rustc layout computation failed: {:?}\", err),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "ca443472156fad4724db1bf9e364b13c324a3480", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/986b3a07c27a78ddb380178546a69f40c2fc1f77/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986b3a07c27a78ddb380178546a69f40c2fc1f77/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=986b3a07c27a78ddb380178546a69f40c2fc1f77", "patch": "@@ -188,8 +188,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ty: Ty<'tcx>,\n         substs: &'tcx Substs<'tcx>\n     ) -> EvalResult<'tcx, Pointer> {\n-        let size = self.type_size_with_substs(ty, substs).expect(\"cannot alloc memory for unsized type\");\n-        let align = self.type_align_with_substs(ty, substs);\n+        let size = self.type_size_with_substs(ty, substs)?.expect(\"cannot alloc memory for unsized type\");\n+        let align = self.type_align_with_substs(ty, substs)?;\n         self.memory.allocate(size, align)\n     }\n \n@@ -292,38 +292,38 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.tcx.normalize_associated_type(&substituted)\n     }\n \n-    fn type_size(&self, ty: Ty<'tcx>) -> Option<usize> {\n+    fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<usize>> {\n         self.type_size_with_substs(ty, self.substs())\n     }\n \n-    fn type_align(&self, ty: Ty<'tcx>) -> usize {\n+    fn type_align(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, usize> {\n         self.type_align_with_substs(ty, self.substs())\n     }\n \n-    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<usize> {\n-        let layout = self.type_layout_with_substs(ty, substs);\n+    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, Option<usize>> {\n+        let layout = self.type_layout_with_substs(ty, substs)?;\n         if layout.is_unsized() {\n-            None\n+            Ok(None)\n         } else {\n-            Some(layout.size(&self.tcx.data_layout).bytes() as usize)\n+            Ok(Some(layout.size(&self.tcx.data_layout).bytes() as usize))\n         }\n     }\n \n-    fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n-        self.type_layout_with_substs(ty, substs).align(&self.tcx.data_layout).abi() as usize\n+    fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, usize> {\n+        self.type_layout_with_substs(ty, substs).map(|layout| layout.align(&self.tcx.data_layout).abi() as usize)\n     }\n \n-    fn type_layout(&self, ty: Ty<'tcx>) -> &'tcx Layout {\n+    fn type_layout(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n         self.type_layout_with_substs(ty, self.substs())\n     }\n \n-    fn type_layout_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> &'tcx Layout {\n+    fn type_layout_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n         // TODO(solson): Is this inefficient? Needs investigation.\n         let ty = self.monomorphize(ty, substs);\n \n         self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n             // TODO(solson): Report this error properly.\n-            ty.layout(&infcx).unwrap()\n+            ty.layout(&infcx).map_err(EvalError::Layout)\n         })\n     }\n \n@@ -482,7 +482,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, ()> {\n         let dest = self.eval_lvalue(lvalue)?;\n         let dest_ty = self.lvalue_ty(lvalue);\n-        let dest_layout = self.type_layout(dest_ty);\n+        let dest_layout = self.type_layout(dest_ty)?;\n \n         use rustc::mir::Rvalue::*;\n         match *rvalue {\n@@ -516,7 +516,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     Array { .. } => {\n                         let elem_size = match dest_ty.sty {\n-                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty).expect(\"array elements are sized\") as u64,\n+                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty)?.expect(\"array elements are sized\") as u64,\n                             _ => bug!(\"tried to assign {:?} to non-array type {:?}\", kind, dest_ty),\n                         };\n                         let offsets = (0..).map(|i| i * elem_size);\n@@ -556,9 +556,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 if let Some(operand) = operands.get(0) {\n                                     assert_eq!(operands.len(), 1);\n                                     let operand_ty = self.operand_ty(operand);\n-                                    assert_eq!(self.type_size(operand_ty), Some(0));\n+                                    assert_eq!(self.type_size(operand_ty)?, Some(0));\n                                 }\n-                                let value_size = self.type_size(dest_ty).expect(\"pointer types are sized\");\n+                                let value_size = self.type_size(dest_ty)?.expect(\"pointer types are sized\");\n                                 let zero = PrimVal::from_int_with_size(0, value_size);\n                                 self.write_primval(dest, zero)?;\n                             }\n@@ -575,15 +575,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             } else {\n                                 for operand in operands {\n                                     let operand_ty = self.operand_ty(operand);\n-                                    assert_eq!(self.type_size(operand_ty), Some(0));\n+                                    assert_eq!(self.type_size(operand_ty)?, Some(0));\n                                 }\n                                 let (offset, ty) = self.nonnull_offset_and_ty(dest_ty, nndiscr, discrfield)?;\n \n                                 // FIXME(solson)\n                                 let dest = self.force_allocation(dest)?.to_ptr();\n \n                                 let dest = dest.offset(offset.bytes() as isize);\n-                                let dest_size = self.type_size(ty).expect(\"bad StructWrappedNullablePointer discrfield\");\n+                                let dest_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n                                 try!(self.memory.write_int(dest, 0, dest_size));\n                             }\n                         } else {\n@@ -625,8 +625,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     ty::TyArray(elem_ty, n) => (elem_ty, n),\n                     _ => bug!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n                 };\n-                let elem_size = self.type_size(elem_ty).expect(\"repeat element type must be sized\");\n                 self.inc_step_counter_and_check_limit(length as u64)?;\n+                let elem_size = self.type_size(elem_ty)?.expect(\"repeat element type must be sized\");\n                 let value = self.eval_operand(operand)?;\n \n                 // FIXME(solson)\n@@ -797,7 +797,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<'tcx, Size> {\n-        let layout = self.type_layout(ty);\n+        let layout = self.type_layout(ty)?;\n \n         use rustc::ty::layout::Layout::*;\n         match *layout {\n@@ -816,7 +816,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn get_field_count(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, usize> {\n-        let layout = self.type_layout(ty);\n+        let layout = self.type_layout(ty)?;\n \n         use rustc::ty::layout::Layout::*;\n         match *layout {\n@@ -944,7 +944,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         let base = self.eval_lvalue(&proj.base)?;\n         let base_ty = self.lvalue_ty(&proj.base);\n-        let base_layout = self.type_layout(base_ty);\n+        let base_layout = self.type_layout(base_ty)?;\n \n         use rustc::mir::ProjectionElem::*;\n         let (ptr, extra) = match proj.elem {\n@@ -1043,7 +1043,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n \n                 let (elem_ty, len) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\");\n+                let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 let n_ptr = self.eval_operand(operand)?;\n                 let usize = self.tcx.types.usize;\n                 let n = self.value_to_primval(n_ptr, usize)?\n@@ -1059,7 +1059,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty).expect(\"sequence element must be sized\");\n+                let elem_size = self.type_size(elem_ty)?.expect(\"sequence element must be sized\");\n                 assert!(n >= min_length as u64);\n \n                 let index = if from_end {\n@@ -1078,7 +1078,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let (base_ptr, _) = base.to_ptr_and_extra();\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n-                let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\");\n+                let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 assert!((from as u64) <= n - (to as u64));\n                 let ptr = base_ptr.offset(from as isize * elem_size as isize);\n                 let extra = LvalueExtra::Length(n - to as u64 - from as u64);\n@@ -1098,8 +1098,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn copy(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, ()> {\n-        let size = self.type_size(ty).expect(\"cannot copy from an unsized type\");\n-        let align = self.type_align(ty);\n+        let size = self.type_size(ty)?.expect(\"cannot copy from an unsized type\");\n+        let align = self.type_align(ty)?;\n         self.memory.copy(src, dest, size, align)?;\n         Ok(())\n     }\n@@ -1368,7 +1368,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             ty::TyAdt(..) => {\n                 use rustc::ty::layout::Layout::*;\n-                if let CEnum { discr, signed, .. } = *self.type_layout(ty) {\n+                if let CEnum { discr, signed, .. } = *self.type_layout(ty)? {\n                     let size = discr.size().bytes() as usize;\n                     if signed {\n                         PrimValKind::from_int_size(size)\n@@ -1464,7 +1464,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             ty::TyAdt(..) => {\n                 use rustc::ty::layout::Layout::*;\n-                if let CEnum { discr, signed, .. } = *self.type_layout(ty) {\n+                if let CEnum { discr, signed, .. } = *self.type_layout(ty)? {\n                     let size = discr.size().bytes() as usize;\n                     if signed {\n                         let n = self.memory.read_int(ptr, size)?;\n@@ -1564,7 +1564,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 for (i, (src_f, dst_f)) in iter {\n                     let src_fty = monomorphize_field_ty(self.tcx, src_f, substs_a);\n                     let dst_fty = monomorphize_field_ty(self.tcx, dst_f, substs_b);\n-                    if self.type_size(dst_fty) == Some(0) {\n+                    if self.type_size(dst_fty)? == Some(0) {\n                         continue;\n                     }\n                     let src_field_offset = self.get_field_offset(src_ty, i)?.bytes() as isize;"}, {"sha": "013bacc30d2ffd98b1d445857a662a0dc851fc67", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/986b3a07c27a78ddb380178546a69f40c2fc1f77/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986b3a07c27a78ddb380178546a69f40c2fc1f77/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=986b3a07c27a78ddb380178546a69f40c2fc1f77", "patch": "@@ -144,8 +144,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"copy_nonoverlapping\" => {\n                 // FIXME: check whether overlapping occurs\n                 let elem_ty = substs.type_at(0);\n-                let elem_size = self.type_size(elem_ty).expect(\"cannot copy unsized value\");\n-                let elem_align = self.type_align(elem_ty);\n+                let elem_size = self.type_size(elem_ty)?.expect(\"cannot copy unsized value\");\n+                let elem_align = self.type_align(elem_ty)?;\n                 let src = arg_vals[0].read_ptr(&self.memory)?;\n                 let dest = arg_vals[1].read_ptr(&self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?\n@@ -252,14 +252,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n-                let elem_align = self.type_align(elem_ty);\n+                let elem_align = self.type_align(elem_ty)?;\n                 let align_val = self.usize_primval(elem_align as u64);\n                 self.write_primval(dest, align_val)?;\n             }\n \n             \"pref_align_of\" => {\n                 let ty = substs.type_at(0);\n-                let layout = self.type_layout(ty);\n+                let layout = self.type_layout(ty)?;\n                 let align = layout.align(&self.tcx.data_layout).pref();\n                 let align_val = self.usize_primval(align);\n                 self.write_primval(dest, align_val)?;\n@@ -280,7 +280,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"offset\" => {\n                 let pointee_ty = substs.type_at(0);\n-                let pointee_size = self.type_size(pointee_ty).expect(\"cannot offset a pointer to an unsized type\") as isize;\n+                let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as isize;\n                 let offset = self.value_to_primval(arg_vals[1], isize)?\n                     .expect_int(\"offset second arg not isize\");\n \n@@ -335,7 +335,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // `size_of_val` intrinsic, then change this back to\n                 // .expect(\"size_of intrinsic called on unsized value\")\n                 // see https://github.com/rust-lang/rust/pull/37708\n-                let size = self.type_size(ty).unwrap_or(!0) as u64;\n+                let size = self.type_size(ty)?.unwrap_or(!0) as u64;\n                 let size_val = self.usize_primval(size);\n                 self.write_primval(dest, size_val)?;\n             }\n@@ -414,8 +414,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         value: Value,\n     ) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n-        if let Some(size) = self.type_size(ty) {\n-            Ok((size as u64, self.type_align(ty) as u64))\n+        if let Some(size) = self.type_size(ty)? {\n+            Ok((size as u64, self.type_align(ty)? as u64))\n         } else {\n             match ty.sty {\n                 ty::TyAdt(def, substs) => {\n@@ -424,7 +424,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     // and it also rounds up to alignment, which we want to avoid,\n                     // as the unsized field's alignment could be smaller.\n                     assert!(!ty.is_simd());\n-                    let layout = self.type_layout(ty);\n+                    let layout = self.type_layout(ty)?;\n                     debug!(\"DST {} layout: {:?}\", ty, layout);\n \n                     let (sized_size, sized_align) = match *layout {\n@@ -489,9 +489,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 ty::TySlice(_) | ty::TyStr => {\n                     let elem_ty = ty.sequence_element_type(self.tcx);\n-                    let elem_size = self.type_size(elem_ty).expect(\"slice element must be sized\") as u64;\n+                    let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as u64;\n                     let (_, len) = value.expect_slice(&self.memory)?;\n-                    let align = self.type_align(elem_ty);\n+                    let align = self.type_align(elem_ty)?;\n                     Ok((len * elem_size, align as u64))\n                 }\n "}, {"sha": "ad0e139e6e1f41cd6a537f4a457c8b112ceb0c8a", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/986b3a07c27a78ddb380178546a69f40c2fc1f77/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986b3a07c27a78ddb380178546a69f40c2fc1f77/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=986b3a07c27a78ddb380178546a69f40c2fc1f77", "patch": "@@ -183,15 +183,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match fn_ty.abi {\n             Abi::RustIntrinsic => {\n                 let ty = fn_ty.sig.0.output;\n-                let layout = self.type_layout(ty);\n+                let layout = self.type_layout(ty)?;\n                 let (ret, target) = destination.unwrap();\n                 self.call_intrinsic(def_id, substs, arg_operands, ret, ty, layout, target)?;\n                 Ok(())\n             }\n \n             Abi::C => {\n                 let ty = fn_ty.sig.0.output;\n-                let size = self.type_size(ty).expect(\"function return type cannot be unsized\");\n+                let size = self.type_size(ty)?.expect(\"function return type cannot be unsized\");\n                 let (ret, target) = destination.unwrap();\n                 self.call_c_abi(def_id, arg_operands, ret, size)?;\n                 self.goto_block(target);\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n         use rustc::ty::layout::Layout::*;\n-        let adt_layout = self.type_layout(adt_ty);\n+        let adt_layout = self.type_layout(adt_ty)?;\n         trace!(\"read_discriminant_value {:?}\", adt_layout);\n \n         let discr_val = match *adt_layout {\n@@ -273,7 +273,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let nonnull = adt_ptr.offset(offset.bytes() as isize);\n                 trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization\n-                let discr_size = self.type_size(ty).expect(\"bad StructWrappedNullablePointer discrfield\");\n+                let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n                 self.read_nonnull_discriminant_value(nonnull, nndiscr, discr_size)?\n             }\n \n@@ -402,9 +402,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         })\n     }\n \n-    fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) {\n+    fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) -> EvalResult<'tcx, ()> {\n         if let Some((last, last_ty)) = args.pop() {\n-            let last_layout = self.type_layout(last_ty);\n+            let last_layout = self.type_layout(last_ty)?;\n             match (&last_ty.sty, last_layout) {\n                 (&ty::TyTuple(fields),\n                  &Layout::Univariant { ref variant, .. }) => {\n@@ -421,6 +421,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 ty => bug!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n             }\n         }\n+        Ok(())\n     }\n \n     /// Trait method, which has to be resolved to an impl method.\n@@ -452,7 +453,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     .expect(\"The substitutions should have no type parameters remaining after passing through fulfill_obligation\");\n                 let closure_kind = self.tcx.closure_kind(vtable_closure.closure_def_id);\n                 trace!(\"closures {:?}, {:?}\", closure_kind, trait_closure_kind);\n-                self.unpack_fn_args(args);\n+                self.unpack_fn_args(args)?;\n                 match (closure_kind, trait_closure_kind) {\n                     (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n                     (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n@@ -487,7 +488,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             traits::VtableFnPointer(vtable_fn_ptr) => {\n                 if let ty::TyFnDef(did, ref substs, _) = vtable_fn_ptr.fn_ty.sty {\n                     args.remove(0);\n-                    self.unpack_fn_args(args);\n+                    self.unpack_fn_args(args)?;\n                     Ok((did, substs))\n                 } else {\n                     bug!(\"VtableFnPointer did not contain a concrete function: {:?}\", vtable_fn_ptr)\n@@ -583,7 +584,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if let Some(drop_def_id) = adt_def.destructor() {\n                     drop.push((drop_def_id, Value::ByVal(PrimVal::from_ptr(adt_ptr)), substs));\n                 }\n-                let layout = self.type_layout(ty);\n+                let layout = self.type_layout(ty)?;\n                 let fields = match *layout {\n                     Layout::Univariant { ref variant, .. } => {\n                         adt_def.struct_variant().fields.iter().zip(&variant.offsets)\n@@ -630,7 +631,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 )?;\n             },\n             ty::TyTuple(fields) => {\n-                let offsets = match *self.type_layout(ty) {\n+                let offsets = match *self.type_layout(ty)? {\n                     Layout::Univariant { ref variant, .. } => &variant.offsets,\n                     _ => bug!(\"tuples must be univariant\"),\n                 };\n@@ -658,7 +659,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len as isize),\n                     _ => bug!(\"expected an lvalue with a length\"),\n                 };\n-                let size = self.type_size(elem_ty).expect(\"slice element must be sized\") as isize;\n+                let size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as isize;\n                 // FIXME: this creates a lot of stack frames if the element type has\n                 // a drop impl\n                 for i in 0..len {\n@@ -671,7 +672,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Lvalue::Ptr { ptr, extra } => (ptr, extra),\n                     _ => bug!(\"expected an lvalue with optional extra data\"),\n                 };\n-                let size = self.type_size(elem_ty).expect(\"array element cannot be unsized\") as isize;\n+                let size = self.type_size(elem_ty)?.expect(\"array element cannot be unsized\") as isize;\n                 // FIXME: this creates a lot of stack frames if the element type has\n                 // a drop impl\n                 for i in 0..len {"}, {"sha": "920e57a1f3413528a352d9af5d27e92e22361e98", "filename": "src/interpreter/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/986b3a07c27a78ddb380178546a69f40c2fc1f77/src%2Finterpreter%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986b3a07c27a78ddb380178546a69f40c2fc1f77/src%2Finterpreter%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvtable.rs?ref=986b3a07c27a78ddb380178546a69f40c2fc1f77", "patch": "@@ -80,8 +80,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }).collect();\n \n-        let size = self.type_size(trait_ref.self_ty()).expect(\"can't create a vtable for an unsized type\");\n-        let align = self.type_align(trait_ref.self_ty());\n+        let size = self.type_size(trait_ref.self_ty())?.expect(\"can't create a vtable for an unsized type\");\n+        let align = self.type_align(trait_ref.self_ty())?;\n \n         let ptr_size = self.memory.pointer_size();\n         let vtable = self.memory.allocate(ptr_size * (3 + methods.len()), ptr_size)?;"}, {"sha": "af10ce4352ccc5244fabbe3fa354efc97b823629", "filename": "src/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/986b3a07c27a78ddb380178546a69f40c2fc1f77/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986b3a07c27a78ddb380178546a69f40c2fc1f77/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=986b3a07c27a78ddb380178546a69f40c2fc1f77", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if ptr.points_to_zst() {\n             return self.allocate(new_size, align);\n         }\n-        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable) == Ok(true) {\n+        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable).ok() == Some(true) {\n             return Err(EvalError::ReallocatedFrozenMemory);\n         }\n \n@@ -245,7 +245,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n-        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable) == Ok(true) {\n+        if self.get(ptr.alloc_id).map(|alloc| alloc.immutable).ok() == Some(true) {\n             return Err(EvalError::DeallocatedFrozenMemory);\n         }\n "}, {"sha": "70d26a68592201d6f310d576a28f991c351a3553", "filename": "tests/compile-fail/repeat.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/986b3a07c27a78ddb380178546a69f40c2fc1f77/tests%2Fcompile-fail%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986b3a07c27a78ddb380178546a69f40c2fc1f77/tests%2Fcompile-fail%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frepeat.rs?ref=986b3a07c27a78ddb380178546a69f40c2fc1f77", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let data: [u8; std::isize::MAX as usize] = [42; std::isize::MAX as usize];\n+    //~^ ERROR: rustc layout computation failed: SizeOverflow([u8;\n+    assert_eq!(data.len(), 1024);\n+}"}]}