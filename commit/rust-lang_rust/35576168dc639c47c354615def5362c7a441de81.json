{"sha": "35576168dc639c47c354615def5362c7a441de81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NTc2MTY4ZGM2MzljNDdjMzU0NjE1ZGVmNTM2MmM3YTQ0MWRlODE=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-24T05:14:43Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-25T19:12:25Z"}, "message": "Added a benchmark of bounded vs unbounded. Bounded is 8-12% faster. The macros currently don't work without pretty printing first.", "tree": {"sha": "7f7903bb09aa7f0591d10d2509904aab58297c62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f7903bb09aa7f0591d10d2509904aab58297c62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35576168dc639c47c354615def5362c7a441de81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35576168dc639c47c354615def5362c7a441de81", "html_url": "https://github.com/rust-lang/rust/commit/35576168dc639c47c354615def5362c7a441de81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35576168dc639c47c354615def5362c7a441de81/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f5f1f90a06961b769162c437681194900ef3b7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5f1f90a06961b769162c437681194900ef3b7e", "html_url": "https://github.com/rust-lang/rust/commit/7f5f1f90a06961b769162c437681194900ef3b7e"}], "stats": {"total": 174, "additions": 161, "deletions": 13}, "files": [{"sha": "24eedf947461b20f30496b60c37354921c557388", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/35576168dc639c47c354615def5362c7a441de81/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35576168dc639c47c354615def5362c7a441de81/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=35576168dc639c47c354615def5362c7a441de81", "patch": "@@ -273,15 +273,15 @@ class buffer_resource<T: send> {\n     let buffer: ~buffer<T>;\n     new(+b: ~buffer<T>) {\n         let p = ptr::addr_of(*b);\n-        #error(\"take %?\", p);\n+        //#error(\"take %?\", p);\n         atomic_add_acq(b.header.ref_count, 1);\n         self.buffer = b;\n     }\n \n     drop unsafe {\n         let b = move!{self.buffer};\n         let p = ptr::addr_of(*b);\n-        #error(\"drop %?\", p);\n+        //#error(\"drop %?\", p);\n         let old_count = atomic_sub_rel(b.header.ref_count, 1);\n         //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n         if old_count == 1 {\n@@ -363,7 +363,7 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n           full {\n             let mut payload = none;\n             payload <-> p.payload;\n-            p.header.state = terminated;\n+            p.header.state = empty;\n             ret some(option::unwrap(payload))\n           }\n           terminated {\n@@ -560,10 +560,10 @@ class send_packet_buffered<T: send, Tbuffer: send> {\n             p <-> self.p;\n             sender_terminate(option::unwrap(p))\n         }\n-        unsafe { #error(\"send_drop: %?\",\n-                        if self.buffer == none {\n-                            \"none\"\n-                        } else { \"some\" }); }\n+        //unsafe { #error(\"send_drop: %?\",\n+        //                if self.buffer == none {\n+        //                    \"none\"\n+        //                } else { \"some\" }); }\n     }\n     fn unwrap() -> *packet<T> {\n         let mut p = none;\n@@ -586,7 +586,7 @@ class send_packet_buffered<T: send, Tbuffer: send> {\n     }\n \n     fn reuse_buffer() -> buffer_resource<Tbuffer> {\n-        #error(\"send reuse_buffer\");\n+        //#error(\"send reuse_buffer\");\n         let mut tmp = none;\n         tmp <-> self.buffer;\n         option::unwrap(tmp)\n@@ -620,10 +620,10 @@ class recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n             p <-> self.p;\n             receiver_terminate(option::unwrap(p))\n         }\n-        unsafe { #error(\"recv_drop: %?\",\n-                        if self.buffer == none {\n-                            \"none\"\n-                        } else { \"some\" }); }\n+        //unsafe { #error(\"recv_drop: %?\",\n+        //                if self.buffer == none {\n+        //                    \"none\"\n+        //                } else { \"some\" }); }\n     }\n     fn unwrap() -> *packet<T> {\n         let mut p = none;\n@@ -646,7 +646,7 @@ class recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n     }\n \n     fn reuse_buffer() -> buffer_resource<Tbuffer> {\n-        #error(\"recv reuse_buffer\");\n+        //#error(\"recv reuse_buffer\");\n         let mut tmp = none;\n         tmp <-> self.buffer;\n         option::unwrap(tmp)"}, {"sha": "1c06062122088ef4ad477fda96ad7ed0faacb829", "filename": "src/test/bench/pingpong.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/35576168dc639c47c354615def5362c7a441de81/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35576168dc639c47c354615def5362c7a441de81/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=35576168dc639c47c354615def5362c7a441de81", "patch": "@@ -0,0 +1,148 @@\n+// Compare bounded and unbounded protocol performance.\n+\n+// xfail-test\n+// xfail-pretty\n+\n+use std;\n+\n+import pipes::{spawn_service, recv};\n+import std::time::precise_time_s;\n+\n+proto! pingpong {\n+    ping: send {\n+        ping -> pong\n+    }\n+    \n+    pong: recv {\n+        pong -> ping\n+    }\n+}\n+\n+proto! pingpong_unbounded {\n+    ping: send {\n+        ping -> pong\n+    }\n+    \n+    pong: recv {\n+        pong -> ping\n+    }\n+\n+    you_will_never_catch_me: send {\n+        never_ever_ever -> you_will_never_catch_me\n+    }\n+}\n+\n+// This stuff should go in libcore::pipes\n+macro_rules! move {\n+    { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n+}\n+\n+macro_rules! follow {\n+    { \n+        $($message:path($($x: ident),+) -> $next:ident $e:expr)+\n+    } => (\n+        |m| alt move(m) {\n+          $(some($message($($x,)* next)) {\n+            let $next = move!{next};\n+            $e })+\n+          _ { fail }\n+        }\n+    );\n+\n+    { \n+        $($message:path -> $next:ident $e:expr)+\n+    } => (\n+        |m| alt move(m) {\n+            $(some($message(next)) {\n+                let $next = move!{next};\n+                $e })+\n+                _ { fail }\n+        } \n+    )\n+}\n+\n+fn switch<T: send, Tb: send, U>(+endp: pipes::recv_packet_buffered<T, Tb>,\n+                      f: fn(+option<T>) -> U) -> U {\n+    f(pipes::try_recv(endp))\n+}\n+\n+fn move<T>(-x: T) -> T { x }\n+\n+// Here's the benchmark\n+\n+fn bounded(count: uint) {\n+    import pingpong::*;\n+\n+    let mut ch = do spawn_service(init) |ch| {\n+        let mut count = count;\n+        let mut ch = ch;\n+        while count > 0 {\n+            ch = switch(ch, follow! {\n+                ping -> next { server::pong(next) }\n+            });\n+\n+            count -= 1;\n+        }\n+    };\n+\n+    let mut count = count;\n+    while count > 0 {\n+        let ch_ = client::ping(ch);\n+\n+        ch = switch(ch_, follow! {\n+            pong -> next { next }\n+        });\n+\n+        count -= 1;\n+    }\n+}\n+\n+fn unbounded(count: uint) {\n+    import pingpong_unbounded::*;\n+\n+    let mut ch = do spawn_service(init) |ch| {\n+        let mut count = count;\n+        let mut ch = ch;\n+        while count > 0 {\n+            ch = switch(ch, follow! {\n+                ping -> next { server::pong(next) }\n+            });\n+\n+            count -= 1;\n+        }\n+    };\n+\n+    let mut count = count;\n+    while count > 0 {\n+        let ch_ = client::ping(ch);\n+\n+        ch = switch(ch_, follow! {\n+            pong -> next { next }\n+        });\n+\n+        count -= 1;\n+    }\n+}\n+\n+fn timeit(f: fn()) -> float {\n+    let start = precise_time_s();\n+    f();\n+    let stop = precise_time_s();\n+    stop - start\n+}\n+\n+fn main() {\n+    let count = 1000000;\n+    let bounded = do timeit { bounded(count) };\n+    let unbounded = do timeit { unbounded(count) };\n+\n+    io::println(#fmt(\"count: %?\\n\", count));\n+    io::println(#fmt(\"bounded: %? s\\t(%? \u03bcs/message)\",\n+                     bounded, bounded * 1000000. / (count as float)));\n+    io::println(#fmt(\"unbounded: %? s\\t(%? \u03bcs/message)\",\n+                     unbounded, unbounded * 1000000. / (count as float)));\n+\n+    io::println(#fmt(\"\\n\\\n+                      bounded is %?%% faster\",\n+                     (unbounded - bounded) / bounded * 100.));\n+}"}]}