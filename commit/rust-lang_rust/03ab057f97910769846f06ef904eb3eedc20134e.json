{"sha": "03ab057f97910769846f06ef904eb3eedc20134e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYWIwNTdmOTc5MTA3Njk4NDZmMDZlZjkwNGViM2VlZGMyMDEzNGU=", "commit": {"author": {"name": "Leo Testard", "email": "leo.testard@gmail.com", "date": "2016-04-06T22:43:03Z"}, "committer": {"name": "Leo Testard", "email": "leo.testard@gmail.com", "date": "2016-04-21T23:40:33Z"}, "message": "Remove the MacroVisitor pass.\nThis pass was supposed to check use of gated features before\n`#[cfg]`-stripping but this was not the case since it in fact happens\nafter. Checks that are actually important and must be done before macro\nexpansion are now made where the features are actually used. Close #32648.\nAlso ensure that attributes on macro-generated macro invocations are\nchecked as well. Close #32782 and #32655.", "tree": {"sha": "27f3eeed5037072895a75545c64501c93893d979", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27f3eeed5037072895a75545c64501c93893d979"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03ab057f97910769846f06ef904eb3eedc20134e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03ab057f97910769846f06ef904eb3eedc20134e", "html_url": "https://github.com/rust-lang/rust/commit/03ab057f97910769846f06ef904eb3eedc20134e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03ab057f97910769846f06ef904eb3eedc20134e/comments", "author": {"login": "LeoTestard", "id": 907750, "node_id": "MDQ6VXNlcjkwNzc1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/907750?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeoTestard", "html_url": "https://github.com/LeoTestard", "followers_url": "https://api.github.com/users/LeoTestard/followers", "following_url": "https://api.github.com/users/LeoTestard/following{/other_user}", "gists_url": "https://api.github.com/users/LeoTestard/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeoTestard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeoTestard/subscriptions", "organizations_url": "https://api.github.com/users/LeoTestard/orgs", "repos_url": "https://api.github.com/users/LeoTestard/repos", "events_url": "https://api.github.com/users/LeoTestard/events{/privacy}", "received_events_url": "https://api.github.com/users/LeoTestard/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeoTestard", "id": 907750, "node_id": "MDQ6VXNlcjkwNzc1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/907750?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeoTestard", "html_url": "https://github.com/LeoTestard", "followers_url": "https://api.github.com/users/LeoTestard/followers", "following_url": "https://api.github.com/users/LeoTestard/following{/other_user}", "gists_url": "https://api.github.com/users/LeoTestard/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeoTestard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeoTestard/subscriptions", "organizations_url": "https://api.github.com/users/LeoTestard/orgs", "repos_url": "https://api.github.com/users/LeoTestard/repos", "events_url": "https://api.github.com/users/LeoTestard/events{/privacy}", "received_events_url": "https://api.github.com/users/LeoTestard/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11f1eb0c4e2ff7e43052b4b847fb4dffaeea46b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/11f1eb0c4e2ff7e43052b4b847fb4dffaeea46b7", "html_url": "https://github.com/rust-lang/rust/commit/11f1eb0c4e2ff7e43052b4b847fb4dffaeea46b7"}], "stats": {"total": 406, "additions": 207, "deletions": 199}, "files": [{"sha": "bda905f3555f538c34cdc4120596e3e14a58b816", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03ab057f97910769846f06ef904eb3eedc20134e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab057f97910769846f06ef904eb3eedc20134e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=03ab057f97910769846f06ef904eb3eedc20134e", "patch": "@@ -512,19 +512,13 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n     });\n \n-    time(time_passes, \"gated macro checking\", || {\n-        sess.track_errors(|| {\n-            let features =\n-              syntax::feature_gate::check_crate_macros(sess.codemap(),\n-                                                       &sess.parse_sess.span_diagnostic,\n-                                                       &krate);\n-\n-            // these need to be set \"early\" so that expansion sees `quote` if enabled.\n-            *sess.features.borrow_mut() = features;\n-        })\n+    // these need to be set \"early\" so that expansion sees `quote` if enabled.\n+    sess.track_errors(|| {\n+        *sess.features.borrow_mut() =\n+            syntax::feature_gate::get_features(&sess.parse_sess.span_diagnostic,\n+                                               &krate);\n     })?;\n \n-\n     krate = time(time_passes, \"crate injection\", || {\n         syntax::std_inject::maybe_inject_crates_ref(krate, sess.opts.alt_std_name.clone())\n     });"}, {"sha": "036e46c380398650385e9565e8ab9a719c1336a4", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/03ab057f97910769846f06ef904eb3eedc20134e/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab057f97910769846f06ef904eb3eedc20134e/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=03ab057f97910769846f06ef904eb3eedc20134e", "patch": "@@ -51,27 +51,32 @@ pub fn load_plugins(sess: &Session,\n                     addl_plugins: Option<Vec<String>>) -> Vec<PluginRegistrar> {\n     let mut loader = PluginLoader::new(sess, cstore, crate_name);\n \n-    for attr in &krate.attrs {\n-        if !attr.check_name(\"plugin\") {\n-            continue;\n-        }\n-\n-        let plugins = match attr.meta_item_list() {\n-            Some(xs) => xs,\n-            None => {\n-                call_malformed_plugin_attribute(sess, attr.span);\n+    // do not report any error now. since crate attributes are\n+    // not touched by expansion, every use of plugin without\n+    // the feature enabled will result in an error later...\n+    if sess.features.borrow().plugin {\n+        for attr in &krate.attrs {\n+            if !attr.check_name(\"plugin\") {\n                 continue;\n             }\n-        };\n \n-        for plugin in plugins {\n-            if plugin.value_str().is_some() {\n-                call_malformed_plugin_attribute(sess, attr.span);\n-                continue;\n+            let plugins = match attr.meta_item_list() {\n+                Some(xs) => xs,\n+                None => {\n+                    call_malformed_plugin_attribute(sess, attr.span);\n+                    continue;\n+                }\n+            };\n+\n+            for plugin in plugins {\n+                if plugin.value_str().is_some() {\n+                    call_malformed_plugin_attribute(sess, attr.span);\n+                    continue;\n+                }\n+\n+                let args = plugin.meta_item_list().map(ToOwned::to_owned).unwrap_or_default();\n+                loader.load_plugin(plugin.span, &plugin.name(), args);\n             }\n-\n-            let args = plugin.meta_item_list().map(ToOwned::to_owned).unwrap_or_default();\n-            loader.load_plugin(plugin.span, &plugin.name(), args);\n         }\n     }\n "}, {"sha": "16b465ba36eb67d740831e1bdcc9e8bf91512676", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/03ab057f97910769846f06ef904eb3eedc20134e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab057f97910769846f06ef904eb3eedc20134e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=03ab057f97910769846f06ef904eb3eedc20134e", "patch": "@@ -35,13 +35,26 @@ use std_inject;\n use std::collections::HashSet;\n use std::env;\n \n+// this function is called to detect use of feature-gated or invalid attributes\n+// on macro invoations since they will not be detected after macro expansion\n+fn check_attributes(attrs: &[ast::Attribute], fld: &MacroExpander) {\n+    for attr in attrs.iter() {\n+        feature_gate::check_attribute(&attr, &fld.cx.parse_sess.span_diagnostic,\n+                                      &fld.cx.parse_sess.codemap(),\n+                                      &fld.cx.ecfg.features.unwrap());\n+    }\n+}\n+\n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     let expr_span = e.span;\n     return e.and_then(|ast::Expr {id, node, span, attrs}| match node {\n \n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprKind::Mac(mac) => {\n+            if let Some(ref attrs) = attrs {\n+                check_attributes(attrs, fld);\n+            }\n \n             // Assert that we drop any macro attributes on the floor here\n             drop(attrs);\n@@ -367,6 +380,8 @@ pub fn expand_item_mac(it: P<ast::Item>,\n         _ => fld.cx.span_bug(it.span, \"invalid item macro invocation\")\n     });\n \n+    check_attributes(&attrs, fld);\n+\n     let fm = fresh_mark();\n     let items = {\n         let expanded = match fld.cx.syntax_env.find(extname) {\n@@ -441,18 +456,6 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     let allow_internal_unstable = attr::contains_name(&attrs,\n                                                                       \"allow_internal_unstable\");\n \n-                    // ensure any #[allow_internal_unstable]s are\n-                    // detected (including nested macro definitions\n-                    // etc.)\n-                    if allow_internal_unstable && !fld.cx.ecfg.enable_allow_internal_unstable() {\n-                        feature_gate::emit_feature_err(\n-                            &fld.cx.parse_sess.span_diagnostic,\n-                            \"allow_internal_unstable\",\n-                            span,\n-                            feature_gate::GateIssue::Language,\n-                            feature_gate::EXPLAIN_ALLOW_INTERNAL_UNSTABLE)\n-                    }\n-\n                     let export = attr::contains_name(&attrs, \"macro_export\");\n                     let def = ast::MacroDef {\n                         ident: ident,\n@@ -516,6 +519,10 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n         _ => return expand_non_macro_stmt(stmt, fld)\n     };\n \n+    if let Some(ref attrs) = attrs {\n+        check_attributes(attrs, fld);\n+    }\n+\n     // Assert that we drop any macro attributes on the floor here\n     drop(attrs);\n \n@@ -1063,7 +1070,7 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n             attrs: ii.attrs,\n             vis: ii.vis,\n             defaultness: ii.defaultness,\n-            node: match ii.node  {\n+            node: match ii.node {\n                 ast::ImplItemKind::Method(sig, body) => {\n                     let (sig, body) = expand_and_rename_method(sig, body, fld);\n                     ast::ImplItemKind::Method(sig, body)\n@@ -1072,13 +1079,11 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n             },\n             span: fld.new_span(ii.span)\n         }),\n-        ast::ImplItemKind::Macro(_) => {\n-            let (span, mac) = match ii.node {\n-                ast::ImplItemKind::Macro(mac) => (ii.span, mac),\n-                _ => unreachable!()\n-            };\n+        ast::ImplItemKind::Macro(mac) => {\n+            check_attributes(&ii.attrs, fld);\n+\n             let maybe_new_items =\n-                expand_mac_invoc(mac, span,\n+                expand_mac_invoc(mac, ii.span,\n                                  |r| r.make_impl_items(),\n                                  |meths, mark| meths.move_map(|m| mark_impl_item(m, mark)),\n                                  fld);"}, {"sha": "63fc33e48727d21c9cf46ad7cc652bac441099ab", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 27, "deletions": 90, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/03ab057f97910769846f06ef904eb3eedc20134e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab057f97910769846f06ef904eb3eedc20134e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=03ab057f97910769846f06ef904eb3eedc20134e", "patch": "@@ -688,7 +688,7 @@ pub fn check_for_pushpop_syntax(f: Option<&Features>, diag: &Handler, span: Span\n }\n \n struct Context<'a> {\n-    features: Features,\n+    features: &'a Features,\n     span_handler: &'a Handler,\n     cm: &'a CodeMap,\n     plugin_attributes: &'a [(String, AttributeType)],\n@@ -739,9 +739,7 @@ impl<'a> Context<'a> {\n                            with the prefix `rustc_` \\\n                            are reserved for internal compiler diagnostics\");\n         } else if name.starts_with(\"derive_\") {\n-            gate_feature!(self, custom_derive, attr.span,\n-                          \"attributes of the form `#[derive_*]` are reserved \\\n-                           for the compiler\");\n+            gate_feature!(self, custom_derive, attr.span, EXPLAIN_DERIVE_UNDERSCORE);\n         } else {\n             // Only run the custom attribute lint during regular\n             // feature gate checking. Macro gating runs\n@@ -759,6 +757,15 @@ impl<'a> Context<'a> {\n     }\n }\n \n+pub fn check_attribute(attr: &ast::Attribute, handler: &Handler,\n+                       cm: &CodeMap, features: &Features) {\n+    let cx = Context {\n+        features: features, span_handler: handler,\n+        cm: cm, plugin_attributes: &[]\n+    };\n+    cx.check_attribute(attr, true);\n+}\n+\n fn find_lang_feature_issue(feature: &str) -> Option<u32> {\n     if let Some(info) = ACTIVE_FEATURES.iter().find(|t| t.0 == feature) {\n         let issue = info.2;\n@@ -819,64 +826,8 @@ pub const EXPLAIN_ALLOW_INTERNAL_UNSTABLE: &'static str =\n pub const EXPLAIN_CUSTOM_DERIVE: &'static str =\n     \"`#[derive]` for custom traits is not stable enough for use and is subject to change\";\n \n-struct MacroVisitor<'a> {\n-    context: &'a Context<'a>\n-}\n-\n-impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n-    fn visit_mac(&mut self, mac: &ast::Mac) {\n-        let path = &mac.node.path;\n-        let name = path.segments.last().unwrap().identifier.name.as_str();\n-\n-        // Issue 22234: If you add a new case here, make sure to also\n-        // add code to catch the macro during or after expansion.\n-        //\n-        // We still keep this MacroVisitor (rather than *solely*\n-        // relying on catching cases during or after expansion) to\n-        // catch uses of these macros within conditionally-compiled\n-        // code, e.g. `#[cfg]`-guarded functions.\n-\n-        if name == \"asm\" {\n-            gate_feature!(self.context, asm, path.span, EXPLAIN_ASM);\n-        }\n-\n-        else if name == \"log_syntax\" {\n-            gate_feature!(self.context, log_syntax, path.span, EXPLAIN_LOG_SYNTAX);\n-        }\n-\n-        else if name == \"trace_macros\" {\n-            gate_feature!(self.context, trace_macros, path.span, EXPLAIN_TRACE_MACROS);\n-        }\n-\n-        else if name == \"concat_idents\" {\n-            gate_feature!(self.context, concat_idents, path.span, EXPLAIN_CONCAT_IDENTS);\n-        }\n-    }\n-\n-    fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n-        self.context.check_attribute(attr, true);\n-    }\n-\n-    fn visit_expr(&mut self, e: &ast::Expr) {\n-        // Issue 22181: overloaded-`box` and placement-`in` are\n-        // implemented via a desugaring expansion, so their feature\n-        // gates go into MacroVisitor since that works pre-expansion.\n-        //\n-        // Issue 22234: we also check during expansion as well.\n-        // But we keep these checks as a pre-expansion check to catch\n-        // uses in e.g. conditionalized code.\n-\n-        if let ast::ExprKind::Box(_) = e.node {\n-            gate_feature!(self.context, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n-        }\n-\n-        if let ast::ExprKind::InPlace(..) = e.node {\n-            gate_feature!(self.context, placement_in_syntax, e.span, EXPLAIN_PLACEMENT_IN);\n-        }\n-\n-        visit::walk_expr(self, e);\n-    }\n-}\n+pub const EXPLAIN_DERIVE_UNDERSCORE: &'static str =\n+    \"attributes of the form `#[derive_*]` are reserved for the compiler\";\n \n struct PostExpansionVisitor<'a> {\n     context: &'a Context<'a>,\n@@ -1177,13 +1128,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n }\n \n-fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n-                        krate: &ast::Crate,\n-                        plugin_attributes: &[(String, AttributeType)],\n-                        check: F)\n-                       -> Features\n-    where F: FnOnce(&mut Context, &ast::Crate)\n-{\n+pub fn get_features(span_handler: &Handler, krate: &ast::Crate) -> Features {\n     let mut features = Features::new();\n \n     for attr in &krate.attrs {\n@@ -1226,32 +1171,24 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n         }\n     }\n \n-    let mut cx = Context {\n-        features: features,\n-        span_handler: span_handler,\n-        cm: cm,\n-        plugin_attributes: plugin_attributes,\n-    };\n-\n-    check(&mut cx, krate);\n-    cx.features\n-}\n-\n-pub fn check_crate_macros(cm: &CodeMap, span_handler: &Handler, krate: &ast::Crate)\n--> Features {\n-    check_crate_inner(cm, span_handler, krate, &[] as &'static [_],\n-                      |ctx, krate| visit::walk_crate(&mut MacroVisitor { context: ctx }, krate))\n+    features\n }\n \n pub fn check_crate(cm: &CodeMap, span_handler: &Handler, krate: &ast::Crate,\n                    plugin_attributes: &[(String, AttributeType)],\n-                   unstable: UnstableFeatures) -> Features\n-{\n+                   unstable: UnstableFeatures) -> Features {\n     maybe_stage_features(span_handler, krate, unstable);\n-\n-    check_crate_inner(cm, span_handler, krate, plugin_attributes,\n-                      |ctx, krate| visit::walk_crate(&mut PostExpansionVisitor { context: ctx },\n-                                                     krate))\n+    let features = get_features(span_handler, krate);\n+    {\n+        let ctx = Context {\n+            features: &features,\n+            span_handler: span_handler,\n+            cm: cm,\n+            plugin_attributes: plugin_attributes,\n+        };\n+        visit::walk_crate(&mut PostExpansionVisitor { context: &ctx }, krate);\n+    }\n+    features\n }\n \n #[derive(Clone, Copy)]"}, {"sha": "4ca3196b9c5ecd6001cbca3fbf6544f6b2dfb752", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 64, "deletions": 30, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/03ab057f97910769846f06ef904eb3eedc20134e/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab057f97910769846f06ef904eb3eedc20134e/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=03ab057f97910769846f06ef904eb3eedc20134e", "patch": "@@ -96,6 +96,36 @@ fn expand_derive(cx: &mut ExtCtxt,\n             let mut found_partial_eq = false;\n             let mut found_eq = false;\n \n+            // This span is **very** sensitive and crucial to\n+            // getting the stability behavior we want. What we are\n+            // doing is marking the generated `#[derive_*]` with the\n+            // span of the `#[deriving(...)]` attribute (the\n+            // entire attribute, not just the `PartialEq` or `Eq`\n+            // part), but with the current backtrace. The current\n+            // backtrace will contain a topmost entry that IS this\n+            // `#[deriving(...)]` attribute and with the\n+            // \"allow-unstable\" flag set to true.\n+            //\n+            // Note that we do NOT use the span of the `Eq`\n+            // text itself. You might think this is\n+            // equivalent, because the `Eq` appears within the\n+            // `#[deriving(Eq)]` attribute, and hence we would\n+            // inherit the \"allows unstable\" from the\n+            // backtrace.  But in fact this is not always the\n+            // case. The actual source text that led to\n+            // deriving can be `#[$attr]`, for example, where\n+            // `$attr == deriving(Eq)`. In that case, the\n+            // \"#[derive_*]\" would be considered to\n+            // originate not from the deriving call but from\n+            // text outside the deriving call, and hence would\n+            // be forbidden from using unstable\n+            // content.\n+            //\n+            // See tests src/run-pass/rfc1445 for\n+            // examples. --nmatsakis\n+            let span = Span { expn_id: cx.backtrace(), .. span };\n+            assert!(cx.parse_sess.codemap().span_allows_unstable(span));\n+\n             for titem in traits.iter().rev() {\n                 let tname = match titem.node {\n                     MetaItemKind::Word(ref tname) => tname,\n@@ -121,42 +151,13 @@ fn expand_derive(cx: &mut ExtCtxt,\n                 }\n \n                 // #[derive(Foo, Bar)] expands to #[derive_Foo] #[derive_Bar]\n-                item.attrs.push(cx.attribute(titem.span, cx.meta_word(titem.span,\n+                item.attrs.push(cx.attribute(span, cx.meta_word(titem.span,\n                     intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n             }\n \n             // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n             // `#[structural_match]` attribute.\n             if found_partial_eq && found_eq {\n-                // This span is **very** sensitive and crucial to\n-                // getting the stability behavior we want. What we are\n-                // doing is marking `#[structural_match]` with the\n-                // span of the `#[deriving(...)]` attribute (the\n-                // entire attribute, not just the `PartialEq` or `Eq`\n-                // part), but with the current backtrace. The current\n-                // backtrace will contain a topmost entry that IS this\n-                // `#[deriving(...)]` attribute and with the\n-                // \"allow-unstable\" flag set to true.\n-                //\n-                // Note that we do NOT use the span of the `Eq`\n-                // text itself. You might think this is\n-                // equivalent, because the `Eq` appears within the\n-                // `#[deriving(Eq)]` attribute, and hence we would\n-                // inherit the \"allows unstable\" from the\n-                // backtrace.  But in fact this is not always the\n-                // case. The actual source text that led to\n-                // deriving can be `#[$attr]`, for example, where\n-                // `$attr == deriving(Eq)`. In that case, the\n-                // \"#[structural_match]\" would be considered to\n-                // originate not from the deriving call but from\n-                // text outside the deriving call, and hence would\n-                // be forbidden from using unstable\n-                // content.\n-                //\n-                // See tests src/run-pass/rfc1445 for\n-                // examples. --nmatsakis\n-                let span = Span { expn_id: cx.backtrace(), .. span };\n-                assert!(cx.parse_sess.codemap().span_allows_unstable(span));\n                 debug!(\"inserting structural_match with span {:?}\", span);\n                 let structural_match = intern_and_get_ident(\"structural_match\");\n                 item.attrs.push(cx.attribute(span,\n@@ -188,6 +189,39 @@ macro_rules! derive_traits {\n                               mitem: &MetaItem,\n                               annotatable: &Annotatable,\n                               push: &mut FnMut(Annotatable)) {\n+                        if !ecx.parse_sess.codemap().span_allows_unstable(sp)\n+                            && !ecx.ecfg.features.unwrap().custom_derive {\n+                            // FIXME:\n+                            // https://github.com/rust-lang/rust/pull/32671#issuecomment-206245303\n+                            // This is just to avoid breakage with syntex.\n+                            // Remove that to spawn an error instead.\n+                            let cm = ecx.parse_sess.codemap();\n+                            let parent = cm.with_expn_info(ecx.backtrace(),\n+                                                           |info| info.unwrap().call_site.expn_id);\n+                            cm.with_expn_info(parent, |info| {\n+                                if info.is_some() {\n+                                    let mut w = ecx.parse_sess.span_diagnostic.struct_span_warn(\n+                                        sp, feature_gate::EXPLAIN_DERIVE_UNDERSCORE,\n+                                    );\n+                                    if option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_none() {\n+                                        w.fileline_help(\n+                                            sp, &format!(\"add #![feature(custom_derive)] to \\\n+                                                          the crate attributes to enable\")\n+                                        );\n+                                    }\n+                                    w.emit();\n+                                } else {\n+                                    feature_gate::emit_feature_err(\n+                                        &ecx.parse_sess.span_diagnostic,\n+                                        \"custom_derive\", sp, feature_gate::GateIssue::Language,\n+                                        feature_gate::EXPLAIN_DERIVE_UNDERSCORE\n+                                    );\n+\n+                                    return;\n+                                }\n+                            })\n+                        }\n+\n                         warn_if_deprecated(ecx, sp, $name);\n                         $func(ecx, sp, mitem, annotatable, push);\n                     }"}, {"sha": "9ebf8a9b74a6c07efd6550dabfcac4f041e6100d", "filename": "src/test/compile-fail/feature-gate-allow-internal-unstable-nested-macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03ab057f97910769846f06ef904eb3eedc20134e/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-nested-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab057f97910769846f06ef904eb3eedc20134e/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-nested-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-nested-macro.rs?ref=03ab057f97910769846f06ef904eb3eedc20134e", "patch": "@@ -11,8 +11,8 @@\n macro_rules! bar {\n     () => {\n         // more layers don't help:\n-        #[allow_internal_unstable]\n-        macro_rules! baz { //~ ERROR allow_internal_unstable side-steps\n+        #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n+        macro_rules! baz {\n             () => {}\n         }\n     }"}, {"sha": "b186278ef8b7b200d5909b880d5c910a95a34c61", "filename": "src/test/compile-fail/feature-gate-allow-internal-unstable-struct.rs", "status": "renamed", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03ab057f97910769846f06ef904eb3eedc20134e/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab057f97910769846f06ef904eb3eedc20134e/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-struct.rs?ref=03ab057f97910769846f06ef904eb3eedc20134e", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that the trace_macros feature gate is on.\n+// checks that this attribute is caught on non-macro items.\n+// this needs a different test since this is done after expansion\n \n-fn main() {\n-    // (Infrastructure does not attempt to detect uses in macro definitions.)\n-    macro_rules! expando {\n-        ($x: ident) => { trace_macros!($x) }\n-    }\n+#[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n+struct S;\n \n-    expando!(true); //~ ERROR `trace_macros` is not stable\n-}\n+fn main() {}", "previous_filename": "src/test/compile-fail/trace_macros-gate2.rs"}, {"sha": "edd7fe4a1e588a098db660ec0666eb1c45146391", "filename": "src/test/compile-fail/issue-32655.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/03ab057f97910769846f06ef904eb3eedc20134e/src%2Ftest%2Fcompile-fail%2Fissue-32655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab057f97910769846f06ef904eb3eedc20134e/src%2Ftest%2Fcompile-fail%2Fissue-32655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32655.rs?ref=03ab057f97910769846f06ef904eb3eedc20134e", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+#![feature(rustc_attrs)]\n+\n+macro_rules! foo (\n+    () => (\n+        #[derive_Clone] //~ WARN attributes of the form\n+        struct T;\n+    );\n+);\n+\n+macro_rules! bar (\n+    ($e:item) => ($e)\n+);\n+\n+foo!();\n+\n+bar!(\n+    #[derive_Clone] //~ WARN attributes of the form\n+    struct S;\n+);\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "696ea0ef5473b72083b7455b3da49b41b2c7001a", "filename": "src/test/compile-fail/issue-32782.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/03ab057f97910769846f06ef904eb3eedc20134e/src%2Ftest%2Fcompile-fail%2Fissue-32782.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab057f97910769846f06ef904eb3eedc20134e/src%2Ftest%2Fcompile-fail%2Fissue-32782.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-32782.rs?ref=03ab057f97910769846f06ef904eb3eedc20134e", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! bar (\n+    () => ()\n+);\n+\n+macro_rules! foo (\n+    () => (\n+        #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n+        bar!();\n+    );\n+);\n+\n+foo!();\n+fn main() {}"}, {"sha": "d627de24d679451b66a8d9778720593479bc886b", "filename": "src/test/compile-fail/trace_macros-gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03ab057f97910769846f06ef904eb3eedc20134e/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03ab057f97910769846f06ef904eb3eedc20134e/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate.rs?ref=03ab057f97910769846f06ef904eb3eedc20134e", "patch": "@@ -26,5 +26,5 @@ fn main() {\n         ($x: ident) => { trace_macros!($x) }\n     }\n \n-    expando!(true);\n+    expando!(true); //~ ERROR `trace_macros` is not stable\n }"}, {"sha": "66d03cf9d8046fd32b598e797b768c5d71541a21", "filename": "src/test/compile-fail/trace_macros-gate3.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/11f1eb0c4e2ff7e43052b4b847fb4dffaeea46b7/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11f1eb0c4e2ff7e43052b4b847fb4dffaeea46b7/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrace_macros-gate3.rs?ref=11f1eb0c4e2ff7e43052b4b847fb4dffaeea46b7", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that the trace_macros feature gate is on.\n-\n-pub fn main() {\n-    println!(\"arg: {}\", trace_macros!()); //~ ERROR `trace_macros` is not stable\n-    println!(\"arg: {}\", trace_macros!(1)); //~ ERROR `trace_macros` is not stable\n-    println!(\"arg: {}\", trace_macros!(ident)); //~ ERROR `trace_macros` is not stable\n-    println!(\"arg: {}\", trace_macros!(for)); //~ ERROR `trace_macros` is not stable\n-    println!(\"arg: {}\", trace_macros!(true,)); //~ ERROR `trace_macros` is not stable\n-    println!(\"arg: {}\", trace_macros!(false 1)); //~ ERROR `trace_macros` is not stable\n-}"}]}