{"sha": "83f780eabfdaf37cb50c10c79af87506f2cc2afe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzZjc4MGVhYmZkYWYzN2NiNTBjMTBjNzlhZjg3NTA2ZjJjYzJhZmU=", "commit": {"author": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-03T03:08:44Z"}, "committer": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-22T20:47:31Z"}, "message": "return Declaration from classify_name", "tree": {"sha": "d5bbaec54f17df66f26aad023e5e37729a4853c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5bbaec54f17df66f26aad023e5e37729a4853c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83f780eabfdaf37cb50c10c79af87506f2cc2afe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83f780eabfdaf37cb50c10c79af87506f2cc2afe", "html_url": "https://github.com/rust-lang/rust/commit/83f780eabfdaf37cb50c10c79af87506f2cc2afe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83f780eabfdaf37cb50c10c79af87506f2cc2afe/comments", "author": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b5d0a41fde1ae03bc6643dad3b904f579f716b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b5d0a41fde1ae03bc6643dad3b904f579f716b5", "html_url": "https://github.com/rust-lang/rust/commit/0b5d0a41fde1ae03bc6643dad3b904f579f716b5"}], "stats": {"total": 95, "additions": 59, "deletions": 36}, "files": [{"sha": "5dc6b1a1310c1102b0ec5d06f18009e1b4388638", "filename": "crates/ra_ide_api/src/name_kind.rs", "status": "modified", "additions": 58, "deletions": 35, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/83f780eabfdaf37cb50c10c79af87506f2cc2afe/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f780eabfdaf37cb50c10c79af87506f2cc2afe/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs?ref=83f780eabfdaf37cb50c10c79af87506f2cc2afe", "patch": "@@ -1,13 +1,19 @@\n //! FIXME: write short doc here\n \n-use hir::{Either, FromSource};\n+use hir::{Either, FromSource, HasSource};\n use ra_db::FileId;\n-use ra_syntax::{ast, AstNode, AstPtr};\n+use ra_syntax::{ast, ast::VisibilityOwner, AstNode, AstPtr};\n use test_utils::tested_by;\n \n use crate::db::RootDatabase;\n \n-pub enum NameKind {\n+pub(crate) struct Declaration {\n+    visibility: Option<ast::Visibility>,\n+    container: hir::ModuleSource,\n+    pub item: NameKind,\n+}\n+\n+pub(crate) enum NameKind {\n     Macro(hir::MacroDef),\n     FieldAccess(hir::StructField),\n     AssocItem(hir::AssocItem),\n@@ -96,7 +102,7 @@ pub(crate) fn classify_name(\n     db: &RootDatabase,\n     file_id: FileId,\n     name: &ast::Name,\n-) -> Option<NameKind> {\n+) -> Option<Declaration> {\n     use NameKind::*;\n \n     let parent = name.syntax().parent()?;\n@@ -105,89 +111,106 @@ pub(crate) fn classify_name(\n     macro_rules! match_ast {\n         (match $node:ident {\n             $( ast::$ast:ident($it:ident) => $res:block, )*\n-            _ => $catch_all:expr,\n+            _ => $catch_all:block,\n         }) => {{\n             $( if let Some($it) = ast::$ast::cast($node.clone()) $res else )*\n-            { $catch_all }\n+            $catch_all\n         }};\n     }\n \n+    let container = parent.ancestors().find_map(|n| {\n+        match_ast! {\n+            match n {\n+                ast::Module(it) => { Some(hir::ModuleSource::Module(it)) },\n+                ast::SourceFile(it) => { Some(hir::ModuleSource::SourceFile(it)) },\n+                _ => { None },\n+            }\n+        }\n+    })?;\n+\n     // FIXME: add ast::MacroCall(it)\n-    match_ast! {\n+    let (item, visibility) = match_ast! {\n         match parent {\n             ast::BindPat(it) => {\n                 let pat = AstPtr::new(&it);\n-                Some(Pat(pat))\n+                (Pat(pat), None)\n             },\n             ast::RecordFieldDef(it) => {\n                 let src = hir::Source { file_id, ast: hir::FieldSource::Named(it) };\n                 let field = hir::StructField::from_source(db, src)?;\n-                Some(FieldAccess(field))\n+                let visibility = match field.parent_def(db) {\n+                    hir::VariantDef::Struct(s) => s.source(db).ast.visibility(),\n+                    hir::VariantDef::EnumVariant(e) => e.source(db).ast.parent_enum().visibility(),\n+                };\n+                (FieldAccess(field), visibility)\n             },\n             ast::FnDef(it) => {\n                 if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    let src = hir::Source { file_id, ast: ast::ImplItem::from(it) };\n+                    let src = hir::Source { file_id, ast: ast::ImplItem::from(it.clone()) };\n                     let item = hir::AssocItem::from_source(db, src)?;\n-                    Some(AssocItem(item))\n+                    (AssocItem(item), it.visibility())\n                 } else {\n-                    let src = hir::Source { file_id, ast: it };\n+                    let src = hir::Source { file_id, ast: it.clone() };\n                     let def = hir::Function::from_source(db, src)?;\n-                    Some(Def(def.into()))\n+                    (Def(def.into()), it.visibility())\n                 }\n             },\n             ast::ConstDef(it) => {\n                 if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    let src = hir::Source { file_id, ast: ast::ImplItem::from(it) };\n+                    let src = hir::Source { file_id, ast: ast::ImplItem::from(it.clone()) };\n                     let item = hir::AssocItem::from_source(db, src)?;\n-                    Some(AssocItem(item))\n+                    (AssocItem(item), it.visibility())\n                 } else {\n-                    let src = hir::Source { file_id, ast: it };\n+                    let src = hir::Source { file_id, ast: it.clone() };\n                     let def = hir::Const::from_source(db, src)?;\n-                    Some(Def(def.into()))\n+                    (Def(def.into()), it.visibility())\n                 }\n             },\n             ast::TypeAliasDef(it) => {\n                 if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    let src = hir::Source { file_id, ast: ast::ImplItem::from(it) };\n+                    let src = hir::Source { file_id, ast: ast::ImplItem::from(it.clone()) };\n                     let item = hir::AssocItem::from_source(db, src)?;\n-                    Some(AssocItem(item))\n+                    (AssocItem(item), it.visibility())\n                 } else {\n-                    let src = hir::Source { file_id, ast: it };\n+                    let src = hir::Source { file_id, ast: it.clone() };\n                     let def = hir::TypeAlias::from_source(db, src)?;\n-                    Some(Def(def.into()))\n+                    (Def(def.into()), it.visibility())\n                 }\n             },\n             ast::Module(it) => {\n-                let src = hir::Source { file_id, ast: hir::ModuleSource::Module(it) };\n+                let src = hir::Source { file_id, ast: hir::ModuleSource::Module(it.clone()) };\n                 let def = hir::Module::from_definition(db, src)?;\n-                Some(Def(def.into()))\n+                (Def(def.into()), it.visibility())\n             },\n             ast::StructDef(it) => {\n-                let src = hir::Source { file_id, ast: it };\n+                let src = hir::Source { file_id, ast: it.clone() };\n                 let def = hir::Struct::from_source(db, src)?;\n-                Some(Def(def.into()))\n+                (Def(def.into()), it.visibility())\n             },\n             ast::EnumDef(it) => {\n-                let src = hir::Source { file_id, ast: it };\n+                let src = hir::Source { file_id, ast: it.clone() };\n                 let def = hir::Enum::from_source(db, src)?;\n-                Some(Def(def.into()))\n+                (Def(def.into()), it.visibility())\n             },\n             ast::TraitDef(it) => {\n-                let src = hir::Source { file_id, ast: it };\n+                let src = hir::Source { file_id, ast: it.clone() };\n                 let def = hir::Trait::from_source(db, src)?;\n-                Some(Def(def.into()))\n+                (Def(def.into()), it.visibility())\n             },\n             ast::StaticDef(it) => {\n-                let src = hir::Source { file_id, ast: it };\n+                let src = hir::Source { file_id, ast: it.clone() };\n                 let def = hir::Static::from_source(db, src)?;\n-                Some(Def(def.into()))\n+                (Def(def.into()), it.visibility())\n             },\n             ast::EnumVariant(it) => {\n-                let src = hir::Source { file_id, ast: it };\n+                let src = hir::Source { file_id, ast: it.clone() };\n                 let def = hir::EnumVariant::from_source(db, src)?;\n-                Some(Def(def.into()))\n+                (Def(def.into()), it.parent_enum().visibility())\n+            },\n+            _ => {\n+                return None;\n             },\n-            _ => None,\n         }\n-    }\n+    };\n+    Some(Declaration { item, container, visibility })\n }"}, {"sha": "6777aa5f390a9c845c1c6d8c6e1ef4eb77e15b23", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83f780eabfdaf37cb50c10c79af87506f2cc2afe/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83f780eabfdaf37cb50c10c79af87506f2cc2afe/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=83f780eabfdaf37cb50c10c79af87506f2cc2afe", "patch": "@@ -92,7 +92,7 @@ pub(crate) fn find_all_refs(\n     ) -> Option<RangeInfo<(hir::SourceAnalyzer, NameKind)>> {\n         if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n             let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name.syntax(), None);\n-            let name_kind = classify_name(db, position.file_id, &name)?;\n+            let name_kind = classify_name(db, position.file_id, &name)?.item;\n             let range = name.syntax().text_range();\n             return Some(RangeInfo::new(range, (analyzer, name_kind)));\n         }"}]}