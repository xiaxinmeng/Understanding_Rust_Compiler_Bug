{"sha": "f7bbe537c11b83c529d755622bc7fdb831d751cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YmJlNTM3YzExYjgzYzUyOWQ3NTU2MjJiYzdmZGI4MzFkNzUxY2Q=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-29T01:50:33Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-29T03:30:07Z"}, "message": "Allow explicit self-calls within classes\n\nAllow writing self.f() within a class that has a method f. In a future\ncommit, this syntax will be required. For now, you can write either\nself.f() or f().\n\nI added a \"privacy\" field to all methods (whether class methods or not),\nwhich allowed me to refactor the AST somewhat (getting rid of the\nclass_item type; now there's just class_member).", "tree": {"sha": "6a822e808ac48046ab8932dbacf802036bb31150", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a822e808ac48046ab8932dbacf802036bb31150"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7bbe537c11b83c529d755622bc7fdb831d751cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7bbe537c11b83c529d755622bc7fdb831d751cd", "html_url": "https://github.com/rust-lang/rust/commit/f7bbe537c11b83c529d755622bc7fdb831d751cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7bbe537c11b83c529d755622bc7fdb831d751cd/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe610f04d89ae30e7ad68b9b519aa8461cd8d0fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe610f04d89ae30e7ad68b9b519aa8461cd8d0fb", "html_url": "https://github.com/rust-lang/rust/commit/fe610f04d89ae30e7ad68b9b519aa8461cd8d0fb"}], "stats": {"total": 401, "additions": 202, "deletions": 199}, "files": [{"sha": "fab2c48dda93296e0e917c0a44c78da3a312a82d", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -218,10 +218,9 @@ fn visit_ids(item: ast::inlined_item, vfn: fn@(ast::node_id)) {\n             }\n         },\n \n-        visit_class_item: fn@(_s: span, _p: ast::privacy,\n-                              c: ast::class_member) {\n-            alt c {\n-              ast::instance_var(_, _, _, id) {\n+        visit_class_item: fn@(c: @ast::class_member) {\n+            alt c.node {\n+              ast::instance_var(_, _, _, id,_) {\n                 vfn(id)\n               }\n               ast::class_method(_) {"}, {"sha": "2c881260ffdcb510b4f9a580dd744783c9f821b5", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -431,7 +431,7 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n                       'u' { ast::unsafe_fn }\n                       'f' { ast::impure_fn }\n                       'p' { ast::pure_fn }\n-                    }}];\n+                    }, privacy: ast::pub}];\n     }\n     @result\n }"}, {"sha": "e8b127631609dac8b606826f8635bd3f2733ef46", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -83,13 +83,13 @@ fn encode_native_module_item_paths(ebml_w: ebml::writer, nmod: native_mod,\n }\n \n fn encode_class_item_paths(ebml_w: ebml::writer,\n-     items: [@class_item], path: [str], &index: [entry<str>]) {\n+     items: [@class_member], path: [str], &index: [entry<str>]) {\n     for it in items {\n-       alt it.node.privacy {\n+     alt ast_util::class_member_privacy(it) {\n           priv { cont; }\n           pub {\n-              let (id, ident) = alt it.node.decl {\n-                 instance_var(v, _, _, vid) { (vid, v) }\n+              let (id, ident) = alt it.node {\n+                 instance_var(v, _, _, vid, _) { (vid, v) }\n                  class_method(it) { (it.id, it.ident) }\n               };\n               add_to_index(ebml_w, path, index, ident);\n@@ -368,20 +368,20 @@ fn encode_privacy(ebml_w: ebml::writer, privacy: privacy) {\n /* Returns an index of items in this class */\n fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                          id: node_id, path: ast_map::path,\n-                         items: [@class_item],\n+                         items: [@class_member],\n                          global_index: @mut[entry<int>])\n  -> [entry<int>] {\n     let index = @mut [];\n     let tcx = ecx.ccx.tcx;\n     for ci in items {\n      /* We encode both private and public fields -- need to include\n         private fields to get the offsets right */\n-      alt ci.node.decl {\n-        instance_var(nm, _, mt, id) {\n+      alt ci.node {\n+        instance_var(nm, _, mt, id, pr) {\n           *index += [{val: id, pos: ebml_w.writer.tell()}];\n           ebml_w.start_tag(tag_items_data_item);\n           #debug(\"encode_info_for_class: doing %s %d\", nm, id);\n-          encode_privacy(ebml_w, ci.node.privacy);\n+          encode_privacy(ebml_w, pr);\n           encode_name(ebml_w, nm);\n           encode_path(ebml_w, path, ast_map::path_name(nm));\n           encode_type(ecx, ebml_w, node_id_to_type(tcx, id));\n@@ -390,18 +390,23 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n           ebml_w.end_tag();\n         }\n         class_method(m) {\n-          *index += [{val: m.id, pos: ebml_w.writer.tell()}];\n-          /* Not sure whether we really need to have two indices,\n-             but it works for now -- tjc */\n-          *global_index += [{val: m.id, pos: ebml_w.writer.tell()}];\n-          let impl_path = path + [ast_map::path_name(m.ident)];\n-          /*\n-            Recall methods are (currently) monomorphic, and we don't\n-            repeat the class's ty params in the method decl\n-          */\n-          #debug(\"encode_info_for_class: doing %s %d\", m.ident, m.id);\n-          encode_info_for_method(ecx, ebml_w, impl_path,\n-                                 should_inline(m.attrs), id, m, []);\n+           alt m.privacy {\n+              pub {\n+                *index += [{val: m.id, pos: ebml_w.writer.tell()}];\n+                /* Not sure whether we really need to have two indices,\n+                   but it works for now -- tjc */\n+                *global_index += [{val: m.id, pos: ebml_w.writer.tell()}];\n+                let impl_path = path + [ast_map::path_name(m.ident)];\n+                /*\n+                  Recall methods are (currently) monomorphic, and we don't\n+                  repeat the class's ty params in the method decl\n+                */\n+                #debug(\"encode_info_for_class: doing %s %d\", m.ident, m.id);\n+                encode_info_for_method(ecx, ebml_w, impl_path,\n+                                       should_inline(m.attrs), id, m, []);\n+            }\n+            _ { /* don't encode private methods */ }\n+          }\n         }\n       }\n     }\n@@ -581,11 +586,10 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n            encode_def_id(ebml_w, local_def(f.id));\n            ebml_w.end_tag();\n         }\n-        for mt in ms {\n-           alt mt.privacy {\n+        for m in ms {\n+           alt m.privacy {\n               priv { /* do nothing */ }\n               pub {\n-                let m = mt.meth;\n                 ebml_w.start_tag(tag_item_method);\n                 #debug(\"Writing %s %d\", m.ident, m.id);\n                 encode_family(ebml_w, purity_fn_family(m.decl.purity));"}, {"sha": "ee91b573daa6b9f802056e282a1e0db052328985", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -182,10 +182,8 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n           let p = extend(cx, i.ident);\n           for ci in items {\n            // only need to handle methods\n-           alt ci.node.decl {\n-             class_method(m) {\n-               map_method(d_id, p, m, cx);\n-             }\n+           alt ci.node {\n+             class_method(m) { map_method(d_id, p, m, cx); }\n              _ {}\n            }\n           }"}, {"sha": "45751bd4cfbf1a29b33922a20006eea54f0783e7", "filename": "src/rustc/middle/mutbl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmutbl.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -216,9 +216,8 @@ fn visit_item(item: @item, &&cx: @ctx, v: visit::vt<@ctx>) {\n     alt item.node {\n             item_class(tps, items, ctor) {\n                 v.visit_ty_params(tps, cx, v);\n-                vec::map::<@class_item, ()>(items,\n-                      {|i| v.visit_class_item(i.span,\n-                            i.node.privacy, i.node.decl, cx, v); });\n+                vec::map::<@class_member, ()>(items,\n+                    {|i| v.visit_class_item(i, cx, v); });\n                 v.visit_fn(visit::fk_ctor(item.ident, tps), ctor.node.dec,\n                            ctor.node.body, ctor.span, ctor.node.id,\n                            @{in_ctor: some(ctor.node.self_id) with *cx}, v);"}, {"sha": "7f38205b3843cec4a6a8361b7d9b96416a7c289e", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -89,7 +89,7 @@ enum mod_index_entry {\n     mie_import_ident(node_id, span),\n     mie_item(@ast::item),\n     mie_class_item(node_id, /* parent class name */\n-                   @ast::class_item), /* class member */\n+                   @ast::class_member), /* class member */\n     mie_native_item(@ast::native_item),\n     mie_enum_variant(/* variant index */uint,\n                      /*parts of enum item*/ [variant],\n@@ -533,14 +533,14 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n                             ctor_scope, v);\n         /* visit the items */\n         for cm in members {\n-            alt cm.node.decl {\n+            alt cm.node {\n               class_method(m) {\n                   let msc = cons(scope_method(m.self_id, tps + m.tps),\n                                  @class_scope);\n                   visit_fn_with_scope(e,\n                      visit::fk_item_fn(m.ident, tps), m.decl, m.body,\n                                  m.span, m.id, msc, v); }\n-              instance_var(_,t,_,_) { v.visit_ty(t, class_scope, v); }\n+              instance_var(_,t,_,_,_) { v.visit_ty(t, class_scope, v); }\n             }\n         }\n       }\n@@ -1161,11 +1161,11 @@ fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n    using the mod_index stuff\n  */\n fn lookup_in_class(parent_id: def_id,\n-                   members: [@class_item], name: ident)\n+                   members: [@class_member], name: ident)\n    -> option<def> {\n     for m in members {\n-      alt m.node.decl {\n-        instance_var(v_name,_,_,id) {\n+      alt m.node {\n+        instance_var(v_name,_,_,id,_) {\n             if v_name == name {\n               ret some(def_class_field(parent_id, local_def(id)));\n             }\n@@ -1560,8 +1560,8 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n         }\n       }\n       mie_class_item(parent_id, class_item) {\n-          alt class_item.node.decl {\n-              instance_var(_,_,_,id) {\n+          alt class_item.node {\n+              instance_var(_,_,_,id,_) {\n                   ret some(ast::def_class_field(local_def(parent_id),\n                                                 local_def(id)));\n               }"}, {"sha": "f213519dac3bc3689b5f73211ea3eee91755d71e", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -4368,8 +4368,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n \n         // Translate methods\n         let (_, ms) = ast_util::split_class_items(items);\n-        impl::trans_impl(ccx, *path, item.ident,\n-                         vec::map(ms, {|m| m.meth}), tps);\n+        impl::trans_impl(ccx, *path, item.ident, ms, tps);\n       }\n       _ {/* fall through */ }\n     }"}, {"sha": "ca4ff733716893e09c60cce2cb2d1fe94aed3c23", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -101,7 +101,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n       item_class(tps, items, ctor) {\n         cx.rmap.insert(ctor.node.id, ());\n         for vec::each(items) {|item|\n-            alt item.node.decl {\n+            alt item.node {\n               class_method(m) {\n                 cx.rmap.insert(m.id, ());\n                 if tps.len() > 0u ||"}, {"sha": "7396e54cf77be15b5b74d324d7d84c781190d4cd", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -156,7 +156,8 @@ type param_bounds = @[param_bound];\n type method = {ident: ast::ident,\n                tps: @[param_bounds],\n                fty: fn_ty,\n-               purity: ast::purity};\n+               purity: ast::purity,\n+               privacy: ast::privacy};\n \n type constr_table = hashmap<ast::node_id, [constr]>;\n \n@@ -2165,7 +2166,7 @@ fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n     alt cx.items.find(did.node) {\n        some(ast_map::node_item(@{node: item_class(_,items,_), _}, _)) {\n          let (_,ms) = split_class_items(items);\n-         vec::map(ms, {|m| {name: m.meth.ident, id: m.meth.id,\n+         vec::map(ms, {|m| {name: m.ident, id: m.id,\n                          privacy: m.privacy}})\n        }\n        _ {\n@@ -2176,34 +2177,35 @@ fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n \n /* Given a class def_id and a method name, return the method's\n  def_id. Needed so we can do static dispatch for methods\n- Fails if the requested method is private */\n+ Doesn't care about the method's privacy. (It's assumed that\n+ the caller already checked that.)\n+*/\n fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n                                sp: span) -> def_id {\n     if check is_local(did) {\n        let ms = lookup_class_method_ids(cx, did);\n        for m in ms {\n-         if m.name == name && m.privacy == ast::pub {\n+         if m.name == name {\n              ret ast_util::local_def(m.id);\n          }\n        }\n-       cx.sess.span_fatal(sp, #fmt(\"Class doesn't have a public method \\\n+       cx.sess.span_fatal(sp, #fmt(\"Class doesn't have a method \\\n            named %s\", name));\n     }\n     else {\n       csearch::get_class_method(cx.sess.cstore, did, name)\n     }\n }\n \n-fn class_field_tys(items: [@class_item]) -> [field_ty] {\n+fn class_field_tys(items: [@class_member]) -> [field_ty] {\n     let mut rslt = [];\n     for it in items {\n-       alt it.node.decl {\n-          instance_var(nm, _, cm, id) {\n+       alt it.node {\n+          instance_var(nm, _, cm, id, privacy) {\n               rslt += [{ident: nm, id: ast_util::local_def(id),\n-                          privacy: it.node.privacy, mutability: cm}];\n-          }\n-          class_method(_) {\n+                          privacy: privacy, mutability: cm}];\n           }\n+          class_method(_) { }\n        }\n     }\n     rslt"}, {"sha": "1cf89045a709a132743430f452d915892bf75c52", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 59, "deletions": 37, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -83,6 +83,22 @@ type fn_ctxt =\n      next_region_var_id: @mut int,\n      ccx: @crate_ctxt};\n \n+// Determines whether the given node ID is a use of the def of\n+// the self ID for the current method, if there is one\n+fn self_ref(fcx: @fn_ctxt, id: ast::node_id) -> bool {\n+    let node_def = alt fcx.ccx.tcx.def_map.find(id) {\n+            none { ret false; }\n+            some(d) { d } };\n+    alt get_self_info(fcx.ccx) {\n+       some(self_impl(_, slf_def)) {\n+           alt node_def {\n+                   ast::def_self(slf_actual) { slf_def == slf_actual }\n+                   _ { false }\n+           }\n+       }\n+       none { false }\n+    }\n+}\n \n fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> int {\n     alt fcx.locals.find(id) {\n@@ -709,13 +725,14 @@ fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n fn ty_of_method(tcx: ty::ctxt, mode: mode, m: @ast::method) -> ty::method {\n     {ident: m.ident, tps: ty_param_bounds(tcx, mode, m.tps),\n      fty: ty_of_fn_decl(tcx, mode, ast::proto_bare, m.decl),\n-     purity: m.decl.purity}\n+     purity: m.decl.purity, privacy: m.privacy}\n }\n fn ty_of_ty_method(tcx: ty::ctxt, mode: mode, m: ast::ty_method)\n     -> ty::method {\n     {ident: m.ident, tps: ty_param_bounds(tcx, mode, m.tps),\n      fty: ty_of_fn_decl(tcx, mode, ast::proto_bare, m.decl),\n-     purity: m.decl.purity}\n+    // assume public, because this is only invoked on iface methods\n+     purity: m.decl.purity, privacy: ast::pub}\n }\n \n // A convenience function to use a crate_ctxt to resolve names for\n@@ -939,9 +956,9 @@ mod collect {\n           }\n           ast_map::node_item(@{node: ast::item_class(_,its,_), _}, _) {\n               let (_,ms) = split_class_items(its);\n-              // Only public methods need to be stored\n-              let ps = ast_util::public_methods(ms);\n-              store_methods::<@ast::method>(tcx, id, ps, {|m|\n+              // All methods need to be stored, since lookup_method\n+              // relies on the same method cache for self-calls\n+              store_methods::<@ast::method>(tcx, id, ms, {|m|\n                           ty_of_method(tcx, m_collect, m)});\n           }\n         }\n@@ -1101,8 +1118,7 @@ mod collect {\n                                         mk_ty_params(tcx, tps).params);\n               // Need to convert all methods so we can check internal\n               // references to private methods\n-              convert_methods(tcx, ast_util::ignore_privacy(methods), @[],\n-                              some(selfty));\n+              convert_methods(tcx, methods, @[], some(selfty));\n           }\n           _ {\n             // This call populates the type cache with the converted type\n@@ -2011,9 +2027,10 @@ fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n }\n \n fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n-                 name: ast::ident, ty: ty::t, tps: [ty::t])\n+                 name: ast::ident, ty: ty::t, tps: [ty::t],\n+                 include_private: bool)\n     -> option<method_origin> {\n-    alt lookup_method_inner(fcx, expr, name, ty) {\n+    alt lookup_method_inner(fcx, expr, name, ty, include_private) {\n       some({method_ty: fty, n_tps: method_n_tps, substs, origin, self_sub}) {\n         let tcx = fcx.ccx.tcx;\n         let mut substs = substs;\n@@ -2064,7 +2081,8 @@ enum method_kind {\n }\n \n fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n-    tps: [ty::t], parent: method_kind, name: ast::ident, sp: span)\n+     tps: [ty::t], parent: method_kind, name: ast::ident, sp: span,\n+                        include_private: bool)\n     -> option<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n         origin: method_origin, self_sub: option<self_subst>}> {\n     #debug(\"lookup_method_inner_: %? %? %s\", ms, parent, name);\n@@ -2080,6 +2098,10 @@ fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n                    tcx.sess.span_fatal(\n                         sp, \"can not call a generic method through a \\\n                                     boxed iface\");\n+          } else if m.privacy == ast::priv && !include_private {\n+                   tcx.sess.span_fatal(\n+                        sp, \"Call to private method not allowed outside \\\n+                          its defining class\");\n           }\n           ret some({method_ty: fty,\n                     n_tps: vec::len(*m.tps),\n@@ -2089,7 +2111,7 @@ fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n                         // look up method named <name>\n                         // its id is did\n                         let m_declared = ty::lookup_class_method_by_name(tcx,\n-                                            parent_id, name, sp);\n+                                      parent_id, name, sp);\n                         method_static(m_declared)\n                       }\n                       an_iface(did) { method_iface(did, i) }\n@@ -2102,7 +2124,8 @@ fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n }\n \n fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n-                       name: ast::ident, ty: ty::t)\n+                       name: ast::ident, ty: ty::t,\n+                       include_private: bool)\n     -> option<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n                   origin: method_origin,\n                   self_sub: option<self_subst>}> {\n@@ -2145,14 +2168,14 @@ fn lookup_method_inner(fcx: @fn_ctxt, expr: @ast::expr,\n       }\n       ty::ty_iface(did, tps) {\n         alt lookup_method_inner_(tcx, *ty::iface_methods(tcx, did), tps,\n-                                 an_iface(did), name, expr.span) {\n+              an_iface(did), name, expr.span, include_private) {\n            some(r) { ret some(r); }\n            none {  }\n         }\n       }\n       ty::ty_class(did, tps) {\n         alt lookup_method_inner_(tcx, *ty::iface_methods(tcx, did), tps,\n-                                 cls(did), name, expr.span) {\n+              cls(did), name, expr.span, include_private) {\n           some(r) { ret some(r); }\n           none    { }\n         }\n@@ -2499,7 +2522,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                         opname: str, args: [option<@ast::expr>])\n         -> option<(ty::t, bool)> {\n         let callee_id = ast_util::op_expr_callee_id(op_ex);\n-        alt lookup_method(fcx, op_ex, callee_id, opname, self_t, []) {\n+        alt lookup_method(fcx, op_ex, callee_id, opname, self_t, [], false) {\n           some(origin) {\n             let mut method_ty = ty::node_id_to_type(fcx.ccx.tcx, callee_id);\n             method_ty = universally_quantify_regions(fcx, region_env(),\n@@ -3108,6 +3131,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             }\n           }\n           ty::ty_class(base_id, _params) {\n+              // This is just for fields -- the same code handles\n+              // methods in both classes and ifaces\n+\n               // (1) verify that the class id actually has a field called\n               // field\n               #debug(\"class named %s\", ty_to_str(tcx, base_t));\n@@ -3116,17 +3142,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                 determines whether we look at all fields or only public\n                 ones\n                */\n-              let node_def = lookup_def(fcx, base.span, base.id);\n-              let cls_items = alt get_self_info(fcx.ccx) {\n-                      some(self_impl(_, n_id)) if alt node_def {\n-                          ast::def_self(base_id) { base_id == n_id }\n-                          _ { false }} {\n-                        // base expr is \"self\" -- consider all fields\n-                        ty::lookup_class_fields(tcx, base_id)\n-                      }\n-                      _ { lookup_public_fields(tcx, base_id) }\n+              let cls_items = if self_ref(fcx, base.id) {\n+                  // base expr is \"self\" -- consider all fields\n+                  ty::lookup_class_fields(tcx, base_id)\n+              }\n+              else {\n+                  lookup_public_fields(tcx, base_id)\n               };\n-               alt lookup_field_ty(tcx, base_id, cls_items, field) {\n+              alt lookup_field_ty(tcx, base_id, cls_items, field) {\n                  some(field_ty) {\n                     // (2) look up what field's type is, and return it\n                     // FIXME: actually instantiate any type params\n@@ -3140,7 +3163,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         }\n         if !handled {\n             let tps = vec::map(tys, {|ty| ast_ty_to_ty_crate(fcx.ccx, ty)});\n-            alt lookup_method(fcx, expr, expr.id, field, expr_t, tps) {\n+            alt lookup_method(fcx, expr, expr.id, field, expr_t, tps,\n+                              self_ref(fcx, base.id)) {\n               some(origin) {\n                 fcx.ccx.method_map.insert(id, origin);\n               }\n@@ -3193,7 +3217,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         let p_ty = expr_ty(tcx, p);\n \n-        alt lookup_method(fcx, p, alloc_id, \"alloc\", p_ty, []) {\n+        alt lookup_method(fcx, p, alloc_id, \"alloc\", p_ty, [], false) {\n           some(origin) {\n             fcx.ccx.method_map.insert(alloc_id, origin);\n \n@@ -3665,27 +3689,26 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n              false, none);\n }\n \n-fn class_types(ccx: @crate_ctxt, members: [@ast::class_item]) -> class_map {\n+fn class_types(ccx: @crate_ctxt, members: [@ast::class_member]) -> class_map {\n     let rslt = int_hash::<ty::t>();\n     for m in members {\n-      alt m.node.decl {\n-         ast::instance_var(_,t,_,id) {\n+      alt m.node {\n+         ast::instance_var(_,t,_,id,_) {\n            rslt.insert(id, ast_ty_to_ty(ccx.tcx, m_collect, t));\n          }\n          ast::class_method(mth) {\n              rslt.insert(mth.id, ty::mk_fn(ccx.tcx,\n-                   ty_of_method(ccx.tcx, m_collect, mth).fty));\n+                ty_of_method(ccx.tcx, m_collect, mth).fty));\n          }\n       }\n     }\n     rslt\n }\n \n fn check_class_member(ccx: @crate_ctxt, class_t: ty::t,\n-                      cm: ast::class_member) {\n-    alt cm {\n-      ast::instance_var(_,t,_,_) {\n-      }\n+                      cm: @ast::class_member) {\n+    alt cm.node {\n+      ast::instance_var(_,t,_,_,_) { }\n       ast::class_method(m) {\n           ccx.self_infos += [self_impl(class_t, m.self_id)];\n           check_method(ccx, m);\n@@ -3729,8 +3752,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n                    ctor.node.body, ctor.node.id, false, none);\n           vec::pop(class_ccx.self_infos);\n           // typecheck the members\n-          for m in members { check_class_member(class_ccx, class_t,\n-                                                m.node.decl); }\n+          for m in members { check_class_member(class_ccx, class_t, m); }\n       }\n       _ {/* nothing to do */ }\n     }"}, {"sha": "c88f44d7153463ec233e7721116b25172daec4f0", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -553,7 +553,9 @@ enum ret_style {\n #[auto_serialize]\n type method = {ident: ident, attrs: [attribute],\n                tps: [ty_param], decl: fn_decl, body: blk,\n-               id: node_id, span: span, self_id: node_id};\n+               id: node_id, span: span, self_id: node_id,\n+               privacy: privacy}; // privacy is always public, unless it's a\n+                                  // class method\n \n #[auto_serialize]\n type _mod = {view_items: [@view_item], items: [@item]};\n@@ -649,8 +651,8 @@ enum item_ {\n     item_res(fn_decl /* dtor */, [ty_param], blk,\n              node_id /* dtor id */, node_id /* ctor id */),\n     item_class([ty_param], /* ty params for class */\n-               [@class_item], /* methods, etc. */\n-                             /* (not including ctor) */\n+               [@class_member], /* methods, etc. */\n+                               /* (not including ctor) */\n                class_ctor\n                ),\n     item_iface([ty_param], [ty_method]),\n@@ -659,14 +661,11 @@ enum item_ {\n }\n \n #[auto_serialize]\n-type class_item_ = {privacy: privacy, decl: class_member};\n+type class_member = spanned<class_member_>;\n \n #[auto_serialize]\n-type class_item = spanned<class_item_>;\n-\n-#[auto_serialize]\n-enum class_member {\n-    instance_var(ident, @ty, class_mutability, node_id),\n+enum class_member_ {\n+    instance_var(ident, @ty, class_mutability, node_id, privacy),\n     class_method(@method)\n     // without constrained types, have to duplicate some stuff. or factor out\n     // item to separate out things with type params?"}, {"sha": "bf32bb0ebf38fcaa9af35811916902165339dfcc", "filename": "src/rustc/syntax/ast_util.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast_util.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -262,41 +262,42 @@ pure fn unguarded_pat(a: arm) -> option<[@pat]> {\n // for reserving this id.\n fn op_expr_callee_id(e: @expr) -> node_id { e.id - 1 }\n \n-pure fn class_item_ident(ci: @class_item) -> ident {\n-    alt ci.node.decl {\n-      instance_var(i,_,_,_) { i }\n+pure fn class_item_ident(ci: @class_member) -> ident {\n+    alt ci.node {\n+      instance_var(i,_,_,_,_) { i }\n       class_method(it) { it.ident }\n     }\n }\n \n type ivar = {ident: ident, ty: @ty, cm: class_mutability,\n              id: node_id, privacy: privacy};\n \n-type cmethod = {privacy: privacy, meth: @method};\n-\n-fn public_methods(cms: [cmethod]) -> [@method] {\n-    vec::filter_map(cms, {|cm| alt cm.privacy {\n-                    pub { some(cm.meth) }\n-                    _   { none }}})\n-}\n-\n-fn ignore_privacy(cms: [cmethod]) -> [@method] {\n-    vec::map(cms, {|cm| cm.meth})\n+fn public_methods(ms: [@method]) -> [@method] {\n+    vec::filter(ms, {|m| alt m.privacy {\n+                    pub { true }\n+                    _   { false }}})\n }\n \n-fn split_class_items(cs: [@class_item]) -> ([ivar], [cmethod]) {\n+fn split_class_items(cs: [@class_member]) -> ([ivar], [@method]) {\n     let mut vs = [], ms = [];\n     for c in cs {\n-      alt c.node.decl {\n-        instance_var(i, t, cm, id) {\n-          vs += [{ident: i, ty: t, cm: cm, id: id, privacy: c.node.privacy}];\n+      alt c.node {\n+        instance_var(i, t, cm, id, privacy) {\n+          vs += [{ident: i, ty: t, cm: cm, id: id, privacy: privacy}];\n         }\n-        class_method(m) { ms += [{privacy: c.node.privacy, meth: m}]; }\n+        class_method(m) { ms += [m]; }\n       }\n     }\n     (vs, ms)\n }\n \n+pure fn class_member_privacy(ci: @class_member) -> privacy {\n+  alt ci.node {\n+     instance_var(_, _, _, _, p) { p }\n+     class_method(m) { m.privacy }\n+  }\n+}\n+\n impl inlined_item_methods for inlined_item {\n     fn ident() -> ident {\n         alt self {"}, {"sha": "2cf567d74f1f3955e5a7d259da0ca0a9d23cd346", "filename": "src/rustc/syntax/fold.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Ffold.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -27,7 +27,7 @@ type ast_fold_precursor =\n      fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n      fold_native_item: fn@(&&@native_item, ast_fold) -> @native_item,\n      fold_item: fn@(&&@item, ast_fold) -> @item,\n-     fold_class_item: fn@(&&@class_item, ast_fold) -> @class_item,\n+     fold_class_item: fn@(&&@class_member, ast_fold) -> @class_member,\n      fold_item_underscore: fn@(item_, ast_fold) -> item_,\n      fold_method: fn@(&&@method, ast_fold) -> @method,\n      fold_block: fn@(blk_, span, ast_fold) -> (blk_, span),\n@@ -54,7 +54,7 @@ type a_f =\n      fold_view_item: fn@(&&@view_item) -> @view_item,\n      fold_native_item: fn@(&&@native_item) -> @native_item,\n      fold_item: fn@(&&@item) -> @item,\n-     fold_class_item: fn@(&&@class_item) -> @class_item,\n+     fold_class_item: fn@(&&@class_member) -> @class_member,\n      fold_item_underscore: fn@(item_) -> item_,\n      fold_method: fn@(&&@method) -> @method,\n      fold_block: fn@(blk) -> blk,\n@@ -84,7 +84,7 @@ fn nf_crate_directive_dummy(&&_c: @crate_directive) -> @crate_directive {\n fn nf_view_item_dummy(&&_v: @view_item) -> @view_item { fail; }\n fn nf_native_item_dummy(&&_n: @native_item) -> @native_item { fail; }\n fn nf_item_dummy(&&_i: @item) -> @item { fail; }\n-fn nf_class_item_dummy(&&_ci: @class_item) -> @class_item { fail; }\n+fn nf_class_item_dummy(&&_ci: @class_member) -> @class_member { fail; }\n fn nf_item_underscore_dummy(_i: item_) -> item_ { fail; }\n fn nf_method_dummy(&&_m: @method) -> @method { fail; }\n fn nf_blk_dummy(_b: blk) -> blk { fail; }\n@@ -240,18 +240,15 @@ fn noop_fold_item(&&i: @item, fld: ast_fold) -> @item {\n           span: fld.new_span(i.span)};\n }\n \n-fn noop_fold_class_item(&&ci: @class_item, fld: ast_fold)\n-    -> @class_item {\n-    @{node: {\n-      privacy:ci.node.privacy,\n-            decl:\n-      alt ci.node.decl {\n-        instance_var(ident, t, cm, id) {\n-            instance_var(ident, fld.fold_ty(t), cm, id)\n+fn noop_fold_class_item(&&ci: @class_member, fld: ast_fold)\n+    -> @class_member {\n+    @{node: alt ci.node {\n+        instance_var(ident, t, cm, id, p) {\n+           instance_var(ident, fld.fold_ty(t), cm, id, p)\n         }\n         class_method(m) { class_method(fld.fold_method(m)) }\n-         }},\n-       span: fld.new_span(ci.span)}\n+      },\n+      span: ci.span}\n }\n \n fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n@@ -302,7 +299,8 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n           body: fld.fold_block(m.body),\n           id: fld.new_id(m.id),\n           span: fld.new_span(m.span),\n-          self_id: fld.new_id(m.self_id)};\n+          self_id: fld.new_id(m.self_id),\n+          privacy: m.privacy};\n }\n \n \n@@ -655,19 +653,16 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n         ret afp.fold_item(i, f);\n     }\n     fn f_class_item(afp: ast_fold_precursor, f: ast_fold,\n-                      &&ci: @class_item) -> @class_item {\n-        @{node:\n-         {privacy:ci.node.privacy,\n-               decl:\n-         alt ci.node.decl {\n-           instance_var(nm, t, mt, id) {\n+                      &&ci: @class_member) -> @class_member {\n+        @{node: alt ci.node {\n+           instance_var(nm, t, mt, id, p) {\n                instance_var(nm, f_ty(afp, f, t),\n-                                 mt, id)\n+                            mt, id, p)\n            }\n            class_method(m) {\n                class_method(afp.fold_method(m, f))\n            }\n-            }}, span: afp.new_span(ci.span)}\n+          }, span: afp.new_span(ci.span)}\n     }\n     fn f_item_underscore(afp: ast_fold_precursor, f: ast_fold, i: item_) ->\n        item_ {"}, {"sha": "0ef54e0999310384c1feb6bf72ae51e30598e9d6", "filename": "src/rustc/syntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 36, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fparse%2Fparser.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -1681,7 +1681,7 @@ fn parse_let(p: parser) -> @ast::decl {\n }\n \n /* assumes \"let\" token has already been consumed */\n-fn parse_instance_var(p:parser) -> (ast::class_member, codemap::span) {\n+fn parse_instance_var(p:parser, pr: ast::privacy) -> @ast::class_member {\n     let mut is_mutbl = ast::class_immutable;\n     let lo = p.span.lo;\n     if eat_word(p, \"mut\") || eat_word(p, \"mutable\") {\n@@ -1693,8 +1693,8 @@ fn parse_instance_var(p:parser) -> (ast::class_member, codemap::span) {\n     let name = parse_ident(p);\n     expect(p, token::COLON);\n     let ty = parse_ty(p, false);\n-    ret (ast::instance_var(name, ty, is_mutbl, p.get_id()),\n-         ast_util::mk_sp(lo, p.last_span.hi));\n+    ret @{node: ast::instance_var(name, ty, is_mutbl, p.get_id(), pr),\n+          span: ast_util::mk_sp(lo, p.last_span.hi)};\n }\n \n fn parse_stmt(p: parser, first_item_attrs: [ast::attribute]) -> @ast::stmt {\n@@ -1986,7 +1986,7 @@ fn parse_method_name(p: parser) -> ast::ident {\n     }\n }\n \n-fn parse_method(p: parser) -> @ast::method {\n+fn parse_method(p: parser, pr: ast::privacy) -> @ast::method {\n     let attrs = parse_outer_attributes(p);\n     let lo = p.span.lo, pur = parse_fn_purity(p);\n     let ident = parse_method_name(p);\n@@ -1996,7 +1996,7 @@ fn parse_method(p: parser) -> @ast::method {\n     let attrs = attrs + inner_attrs;\n     @{ident: ident, attrs: attrs, tps: tps, decl: decl, body: body,\n       id: p.get_id(), span: ast_util::mk_sp(lo, body.span.hi),\n-      self_id: p.get_id()}\n+      self_id: p.get_id(), privacy: pr}\n }\n \n fn parse_item_iface(p: parser, attrs: [ast::attribute]) -> @ast::item {\n@@ -2034,7 +2034,7 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let ty = parse_ty(p, false);\n     let mut meths = [];\n     expect(p, token::LBRACE);\n-    while !eat(p, token::RBRACE) { meths += [parse_method(p)]; }\n+    while !eat(p, token::RBRACE) { meths += [parse_method(p, ast::pub)]; }\n     ret mk_item(p, lo, p.last_span.hi, ident,\n                 ast::item_impl(tps, ifce, ty, meths), attrs);\n }\n@@ -2070,32 +2070,23 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let class_path = ident_to_path(p.last_span, class_name);\n     let ty_params = parse_ty_params(p);\n     expect(p, token::LBRACE);\n-    let mut items: [@ast::class_item] = [];\n+    let mut ms: [@ast::class_member] = [];\n     let ctor_id = p.get_id();\n     let mut the_ctor : option<(ast::fn_decl, ast::blk, codemap::span)> = none;\n     while p.token != token::RBRACE {\n         alt parse_class_item(p, class_path) {\n-           ctor_decl(a_fn_decl, blk, s) {\n+            ctor_decl(a_fn_decl, blk, s) {\n                the_ctor = some((a_fn_decl, blk, s));\n             }\n-           plain_decl(a_decl, s) {\n-                items += [@{node: {privacy: ast::pub, decl: a_decl},\n-                            span: s}];\n-            }\n-            priv_decls(some_decls) {\n-                items += vec::map(some_decls, {|p|\n-                            let (d, s) = p;\n-                            @{node: {privacy: ast::priv, decl: d},\n-                                span: s}});\n-            }\n+            members(mms) { ms += mms; }\n        }\n     }\n     p.bump();\n     alt the_ctor {\n       some((ct_d, ct_b, ct_s)) {\n           ret mk_item(p, lo, p.last_span.hi,\n                                              class_name,\n-         ast::item_class(ty_params, items,\n+         ast::item_class(ty_params, ms,\n                          {node: {id: ctor_id,\n                                  self_id: p.get_id(),\n                                  dec: ct_d,\n@@ -2112,16 +2103,10 @@ fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n \n // lets us identify the constructor declaration at\n // parse time\n-// we don't really want just the fn_decl...\n enum class_contents { ctor_decl(ast::fn_decl, ast::blk, codemap::span),\n-                      // assumed to be public\n-                      plain_decl(ast::class_member, codemap::span),\n-                      // contents of a priv section --\n-                      // parse_class_item ensures that\n-                      // none of these are a ctor decl\n-                      priv_decls([(ast::class_member, codemap::span)])}\n-\n-    fn parse_class_item(p:parser, class_name:@ast::path) -> class_contents {\n+                      members([@ast::class_member]) }\n+\n+fn parse_class_item(p:parser, class_name:@ast::path) -> class_contents {\n     if eat_word(p, \"new\") {\n         let lo = p.last_span.lo;\n         // Can ctors have attrs?\n@@ -2140,28 +2125,28 @@ enum class_contents { ctor_decl(ast::fn_decl, ast::blk, codemap::span),\n             let mut results = [];\n             while p.token != token::RBRACE {\n                if eat_word(p, \"let\") {\n-                  let a_var = parse_instance_var(p);\n+                  let a_var = parse_instance_var(p, ast::priv);\n                   expect(p, token::SEMI);\n                   results += [a_var];\n                }\n                else {\n-                   let m = parse_method(p);\n-                   results += [(ast::class_method(m), m.span)];\n+                   let m = parse_method(p, ast::priv);\n+                   results += [@{node: ast::class_method(m), span: m.span}];\n                }\n             }\n             p.bump();\n-            ret priv_decls(results);\n+            ret members(results);\n     }\n     else {\n         // Probably need to parse attrs\n         ret if eat_word(p, \"let\") {\n-             let (a_var, a_span) = parse_instance_var(p);\n+             let ivar = parse_instance_var(p, ast::pub);\n              expect(p, token::SEMI);\n-             plain_decl(a_var, a_span)\n+             members([ivar])\n         }\n         else {\n-            let m = parse_method(p);\n-            plain_decl(ast::class_method(m), m.span)\n+            let m = parse_method(p, ast::pub);\n+            members([@{node: ast::class_method(m), span: m.span}])\n         }\n     }\n }"}, {"sha": "a1c118c314415e68f5b7ed29c9d4bdbe3c8807a4", "filename": "src/rustc/syntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -506,16 +506,17 @@ fn print_item(s: ps, &&item: @ast::item) {\n                    */\n              hardbreak_if_not_bol(s);\n              maybe_print_comment(s, ci.span.lo);\n-             alt ci.node.privacy {\n+             let pr = ast_util::class_member_privacy(ci);\n+             alt pr {\n                 ast::priv {\n                     head(s, \"priv\");\n                     bopen(s);\n                     hardbreak_if_not_bol(s);\n                 }\n                 _ {}\n              }\n-             alt ci.node.decl {\n-                 ast::instance_var(nm, t, mt, _) {\n+             alt ci.node {\n+                ast::instance_var(nm, t, mt, _,_) {\n                     word_nbsp(s, \"let\");\n                     alt mt {\n                       ast::class_mutable { word_nbsp(s, \"mut\"); }\n@@ -530,7 +531,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n                     print_method(s, m);\n                 }\n              }\n-             alt ci.node.privacy {\n+             alt pr {\n                  ast::priv { bclose(s, ci.span); }\n                  _ {}\n              }"}, {"sha": "b4bcb3aaa31bed6b1203d3471dda169dc6a030a1", "filename": "src/rustc/syntax/visit.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Frustc%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fvisit.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -55,7 +55,7 @@ type visitor<E> =\n       visit_ty_params: fn@([ty_param], E, vt<E>),\n       visit_constr: fn@(@path, span, node_id, E, vt<E>),\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n-      visit_class_item: fn@(span, privacy, class_member, E, vt<E>)};\n+      visit_class_item: fn@(@class_member, E, vt<E>)};\n \n fn default_visitor<E>() -> visitor<E> {\n     ret @{visit_mod: bind visit_mod::<E>(_, _, _, _, _),\n@@ -73,7 +73,7 @@ fn default_visitor<E>() -> visitor<E> {\n           visit_ty_params: bind visit_ty_params::<E>(_, _, _),\n           visit_constr: bind visit_constr::<E>(_, _, _, _, _),\n           visit_fn: bind visit_fn::<E>(_, _, _, _, _, _, _),\n-          visit_class_item: bind visit_class_item::<E>(_,_,_,_,_)};\n+          visit_class_item: bind visit_class_item::<E>(_,_,_)};\n }\n \n fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n@@ -139,7 +139,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       item_class(tps, members, ctor) {\n           v.visit_ty_params(tps, e, v);\n           for m in members {\n-             v.visit_class_item(m.span, m.node.privacy, m.node.decl, e, v);\n+             v.visit_class_item(m, e, v);\n           }\n           // make up a fake fn so as to call visit_fn on the ctor\n           v.visit_fn(fk_ctor(i.ident, tps), ctor.node.dec,\n@@ -155,10 +155,9 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_class_item<E>(_s: span, _p: privacy, cm: class_member,\n-                       e:E, v:vt<E>) {\n-    alt cm {\n-        instance_var(ident, t, mt, id) {\n+fn visit_class_item<E>(cm: @class_member, e:E, v:vt<E>) {\n+    alt cm.node {\n+        instance_var(_, t, _, _, _) {\n             v.visit_ty(t, e, v);\n         }\n         class_method(m) {\n@@ -427,7 +426,7 @@ type simple_visitor =\n       visit_ty_params: fn@([ty_param]),\n       visit_constr: fn@(@path, span, node_id),\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id),\n-      visit_class_item: fn@(span, privacy, class_member)};\n+      visit_class_item: fn@(@class_member)};\n \n fn simple_ignore_ty(_t: @ty) {}\n \n@@ -448,7 +447,7 @@ fn default_simple_visitor() -> simple_visitor {\n           visit_constr: fn@(_p: @path, _sp: span, _id: node_id) { },\n           visit_fn: fn@(_fk: fn_kind, _d: fn_decl, _b: blk, _sp: span,\n                         _id: node_id) { },\n-          visit_class_item: fn@(_s: span, _p: privacy, _c: class_member) {}\n+          visit_class_item: fn@(_c: @class_member) {}\n          };\n }\n \n@@ -523,11 +522,11 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     } else {\n         bind v_ty(v.visit_ty, _, _, _)\n     };\n-    fn v_class_item(f: fn@(span, privacy, class_member),\n-                    s:span, p:privacy, cm: class_member, &&e: (),\n+    fn v_class_item(f: fn@(@class_member),\n+                    cm: @class_member, &&e: (),\n                     v: vt<()>) {\n-        f(s, p, cm);\n-        visit_class_item(s, p, cm, e, v);\n+        f(cm);\n+        visit_class_item(cm, e, v);\n     }\n     ret mk_vt(@{visit_mod: bind v_mod(v.visit_mod, _, _, _, _, _),\n                 visit_view_item: bind v_view_item(v.visit_view_item, _, _, _),\n@@ -546,7 +545,7 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n                 visit_constr: bind v_constr(v.visit_constr, _, _, _, _, _),\n                 visit_fn: bind v_fn(v.visit_fn, _, _, _, _, _, _, _),\n                 visit_class_item: bind v_class_item(v.visit_class_item, _, _,\n-                                                    _, _, _)\n+                                                    _)\n                });\n }\n "}, {"sha": "09f0f9b5af5b5ec950441586cb2e649948bb0c2f", "filename": "src/test/compile-fail/private-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-method.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:attempted access of field nap on type\n+// error-pattern:Call to private method not allowed\n class cat {\n   priv {\n     let mut meows : uint;"}, {"sha": "1d062f32b7a19e1e2b2320fa680214a884a9d552", "filename": "src/test/run-pass/private-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7bbe537c11b83c529d755622bc7fdb831d751cd/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivate-method.rs?ref=f7bbe537c11b83c529d755622bc7fdb831d751cd", "patch": "@@ -8,7 +8,7 @@ class cat {\n \n   fn play() {\n     meows += 1u;\n-    nap();\n+    self.nap();\n   }\n   new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n }"}]}