{"sha": "df4b23e7212b8f7a3f62f469f666021226e29c17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNGIyM2U3MjEyYjhmN2EzZjYyZjQ2OWY2NjYwMjEyMjZlMjljMTc=", "commit": {"author": {"name": "Julien Cretin", "email": "cretin@google.com", "date": "2019-07-24T21:32:26Z"}, "committer": {"name": "Julien Cretin", "email": "cretin@google.com", "date": "2019-07-25T21:28:47Z"}, "message": "Implement slow-path for FirstSets::first\n\nWhen 2 or more sequences share the same span, we can't use the precomputed map\nfor their first set. So we compute it recursively.\n\nFixes #62831.", "tree": {"sha": "8f4914767734381100b154b1a33f802727d04271", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f4914767734381100b154b1a33f802727d04271"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df4b23e7212b8f7a3f62f469f666021226e29c17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df4b23e7212b8f7a3f62f469f666021226e29c17", "html_url": "https://github.com/rust-lang/rust/commit/df4b23e7212b8f7a3f62f469f666021226e29c17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df4b23e7212b8f7a3f62f469f666021226e29c17/comments", "author": {"login": "ia0", "id": 969295, "node_id": "MDQ6VXNlcjk2OTI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/969295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ia0", "html_url": "https://github.com/ia0", "followers_url": "https://api.github.com/users/ia0/followers", "following_url": "https://api.github.com/users/ia0/following{/other_user}", "gists_url": "https://api.github.com/users/ia0/gists{/gist_id}", "starred_url": "https://api.github.com/users/ia0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ia0/subscriptions", "organizations_url": "https://api.github.com/users/ia0/orgs", "repos_url": "https://api.github.com/users/ia0/repos", "events_url": "https://api.github.com/users/ia0/events{/privacy}", "received_events_url": "https://api.github.com/users/ia0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ia0", "id": 969295, "node_id": "MDQ6VXNlcjk2OTI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/969295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ia0", "html_url": "https://github.com/ia0", "followers_url": "https://api.github.com/users/ia0/followers", "following_url": "https://api.github.com/users/ia0/following{/other_user}", "gists_url": "https://api.github.com/users/ia0/gists{/gist_id}", "starred_url": "https://api.github.com/users/ia0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ia0/subscriptions", "organizations_url": "https://api.github.com/users/ia0/orgs", "repos_url": "https://api.github.com/users/ia0/repos", "events_url": "https://api.github.com/users/ia0/events{/privacy}", "received_events_url": "https://api.github.com/users/ia0/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eedf6ce4ef54bb03818ab21d714f1b9f13a6b31c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eedf6ce4ef54bb03818ab21d714f1b9f13a6b31c", "html_url": "https://github.com/rust-lang/rust/commit/eedf6ce4ef54bb03818ab21d714f1b9f13a6b31c"}], "stats": {"total": 146, "additions": 119, "deletions": 27}, "files": [{"sha": "1731c0f713bad52c355671f254c2200976a4c3c8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/df4b23e7212b8f7a3f62f469f666021226e29c17/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4b23e7212b8f7a3f62f469f666021226e29c17/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=df4b23e7212b8f7a3f62f469f666021226e29c17", "patch": "@@ -625,38 +625,37 @@ impl FirstSets {\n                     return first;\n                 }\n                 TokenTree::Sequence(sp, ref seq_rep) => {\n-                    match self.first.get(&sp.entire()) {\n-                        Some(&Some(ref subfirst)) => {\n-                            // If the sequence contents can be empty, then the first\n-                            // token could be the separator token itself.\n-\n-                            if let (Some(sep), true) = (&seq_rep.separator, subfirst.maybe_empty) {\n-                                first.add_one_maybe(TokenTree::Token(sep.clone()));\n-                            }\n-\n-                            assert!(first.maybe_empty);\n-                            first.add_all(subfirst);\n-                            if subfirst.maybe_empty\n-                                || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrMore\n-                                || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrOne\n-                            {\n-                                // continue scanning for more first\n-                                // tokens, but also make sure we\n-                                // restore empty-tracking state\n-                                first.maybe_empty = true;\n-                                continue;\n-                            } else {\n-                                return first;\n-                            }\n-                        }\n-\n+                    let subfirst_owned;\n+                    let subfirst = match self.first.get(&sp.entire()) {\n+                        Some(&Some(ref subfirst)) => subfirst,\n                         Some(&None) => {\n-                            panic!(\"assume all sequences have (unique) spans for now\");\n+                            subfirst_owned = self.first(&seq_rep.tts[..]);\n+                            &subfirst_owned\n                         }\n-\n                         None => {\n                             panic!(\"We missed a sequence during FirstSets construction\");\n                         }\n+                    };\n+\n+                    // If the sequence contents can be empty, then the first\n+                    // token could be the separator token itself.\n+                    if let (Some(sep), true) = (&seq_rep.separator, subfirst.maybe_empty) {\n+                        first.add_one_maybe(TokenTree::Token(sep.clone()));\n+                    }\n+\n+                    assert!(first.maybe_empty);\n+                    first.add_all(subfirst);\n+                    if subfirst.maybe_empty\n+                        || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrMore\n+                        || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrOne\n+                    {\n+                        // Continue scanning for more first\n+                        // tokens, but also make sure we\n+                        // restore empty-tracking state.\n+                        first.maybe_empty = true;\n+                        continue;\n+                    } else {\n+                        return first;\n                     }\n                 }\n             }"}, {"sha": "b50ed7ca92ad5e74a29bb53b86f42b52d80d6408", "filename": "src/test/ui/macros/auxiliary/proc_macro_sequence.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/df4b23e7212b8f7a3f62f469f666021226e29c17/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4b23e7212b8f7a3f62f469f666021226e29c17/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fproc_macro_sequence.rs?ref=df4b23e7212b8f7a3f62f469f666021226e29c17", "patch": "@@ -0,0 +1,36 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro_span, proc_macro_hygiene, proc_macro_quote)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{quote, Span, TokenStream};\n+\n+fn assert_same_span(a: Span, b: Span) {\n+    assert_eq!(a.start(), b.start());\n+    assert_eq!(a.end(), b.end());\n+}\n+\n+// This macro generates a macro with the same macro definition as `manual_foo` in\n+// `same-sequence-span.rs` but with the same span for all sequences.\n+#[proc_macro]\n+pub fn make_foo(_: TokenStream) -> TokenStream {\n+    let result = quote! {\n+        macro_rules! generated_foo {\n+            (1 $$x:expr $$($$y:tt,)* $$(= $$z:tt)*) => {};\n+        }\n+    };\n+\n+    // Check that all spans are equal.\n+    let mut span = None;\n+    for tt in result.clone() {\n+        match span {\n+            None => span = Some(tt.span()),\n+            Some(span) => assert_same_span(tt.span(), span),\n+        }\n+    }\n+\n+    result\n+}"}, {"sha": "a4f70b6b68d1ee29d8886ec34a7bcb92ae5264e7", "filename": "src/test/ui/macros/same-sequence-span.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/df4b23e7212b8f7a3f62f469f666021226e29c17/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df4b23e7212b8f7a3f62f469f666021226e29c17/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.rs?ref=df4b23e7212b8f7a3f62f469f666021226e29c17", "patch": "@@ -0,0 +1,23 @@\n+// aux-build:proc_macro_sequence.rs\n+\n+// Regression test for issue #62831: Check that multiple sequences with the same span in the\n+// left-hand side of a macro definition behave as if they had unique spans, and in particular that\n+// they don't crash the compiler.\n+\n+#![feature(proc_macro_hygiene)]\n+#![allow(unused_macros)]\n+\n+extern crate proc_macro_sequence;\n+\n+// When ignoring spans, this macro has the same macro definition as `generated_foo` in\n+// `proc_macro_sequence.rs`.\n+macro_rules! manual_foo {\n+    (1 $x:expr $($y:tt,)*   //~ERROR `$x:expr` may be followed by `$y:tt`\n+               $(= $z:tt)*  //~ERROR `$x:expr` may be followed by `=`\n+    ) => {};\n+}\n+\n+proc_macro_sequence::make_foo!(); //~ERROR `$x:expr` may be followed by `$y:tt`\n+                                  //~^ERROR `$x:expr` may be followed by `=`\n+\n+fn main() {}"}, {"sha": "aee1b4c9c5d99a269b72dc6939b9bbfa45630930", "filename": "src/test/ui/macros/same-sequence-span.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/df4b23e7212b8f7a3f62f469f666021226e29c17/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df4b23e7212b8f7a3f62f469f666021226e29c17/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fsame-sequence-span.stderr?ref=df4b23e7212b8f7a3f62f469f666021226e29c17", "patch": "@@ -0,0 +1,34 @@\n+error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fragments\n+  --> $DIR/same-sequence-span.rs:15:18\n+   |\n+LL |     (1 $x:expr $($y:tt,)*\n+   |                  ^^^^^ not allowed after `expr` fragments\n+   |\n+   = note: allowed there are: `=>`, `,` or `;`\n+\n+error: `$x:expr` may be followed by `=`, which is not allowed for `expr` fragments\n+  --> $DIR/same-sequence-span.rs:16:18\n+   |\n+LL |                $(= $z:tt)*\n+   |                  ^ not allowed after `expr` fragments\n+   |\n+   = note: allowed there are: `=>`, `,` or `;`\n+\n+error: `$x:expr` may be followed by `$y:tt`, which is not allowed for `expr` fragments\n+  --> $DIR/same-sequence-span.rs:20:1\n+   |\n+LL | proc_macro_sequence::make_foo!();\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed after `expr` fragments\n+   |\n+   = note: allowed there are: `=>`, `,` or `;`\n+\n+error: `$x:expr` may be followed by `=`, which is not allowed for `expr` fragments\n+  --> $DIR/same-sequence-span.rs:20:1\n+   |\n+LL | proc_macro_sequence::make_foo!();\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not allowed after `expr` fragments\n+   |\n+   = note: allowed there are: `=>`, `,` or `;`\n+\n+error: aborting due to 4 previous errors\n+"}]}