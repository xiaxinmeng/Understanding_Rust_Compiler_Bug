{"sha": "c77f44eeee81021660c3c2cd86540b7449973417", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3N2Y0NGVlZWU4MTAyMTY2MGMzYzJjZDg2NTQwYjc0NDk5NzM0MTc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-02-14T18:01:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-25T18:07:18Z"}, "message": "Make monomorphized functions use stable symbol names.", "tree": {"sha": "045ae4f95336a504f13da8eaeebf4ad494d9932f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/045ae4f95336a504f13da8eaeebf4ad494d9932f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c77f44eeee81021660c3c2cd86540b7449973417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c77f44eeee81021660c3c2cd86540b7449973417", "html_url": "https://github.com/rust-lang/rust/commit/c77f44eeee81021660c3c2cd86540b7449973417", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c77f44eeee81021660c3c2cd86540b7449973417/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a756fea50382b6beb3b4d2fcc593e59f0eadd8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a756fea50382b6beb3b4d2fcc593e59f0eadd8c", "html_url": "https://github.com/rust-lang/rust/commit/3a756fea50382b6beb3b4d2fcc593e59f0eadd8c"}], "stats": {"total": 265, "additions": 241, "deletions": 24}, "files": [{"sha": "d4af14cf40907a2d5dccffc51a4b66956be84984", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c77f44eeee81021660c3c2cd86540b7449973417/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77f44eeee81021660c3c2cd86540b7449973417/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=c77f44eeee81021660c3c2cd86540b7449973417", "patch": "@@ -2688,7 +2688,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             let node_id = self.map.as_local_node_id(impl_did).unwrap();\n             Ok(self.map.span(node_id))\n         } else {\n-            Err(self.crate_name(impl_did.krate))\n+            Err(self.sess.cstore.crate_name(impl_did.krate))\n         }\n     }\n }"}, {"sha": "de188ec9960ee5b5325bdd085852061329eb62e8", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/c77f44eeee81021660c3c2cd86540b7449973417/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77f44eeee81021660c3c2cd86540b7449973417/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=c77f44eeee81021660c3c2cd86540b7449973417", "patch": "@@ -0,0 +1,223 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The Rust Linkage Model and Symbol Names\n+//! =======================================\n+//!\n+//! The semantic model of Rust linkage is, broadly, that \"there's no global\n+//! namespace\" between crates. Our aim is to preserve the illusion of this\n+//! model despite the fact that it's not *quite* possible to implement on\n+//! modern linkers. We initially didn't use system linkers at all, but have\n+//! been convinced of their utility.\n+//!\n+//! There are a few issues to handle:\n+//!\n+//!  - Linkers operate on a flat namespace, so we have to flatten names.\n+//!    We do this using the C++ namespace-mangling technique. Foo::bar\n+//!    symbols and such.\n+//!\n+//!  - Symbols for distinct items with the same *name* need to get different\n+//!    linkage-names. Examples of this are monomorphizations of functions or\n+//!    items within anonymous scopes that end up having the same path.\n+//!\n+//!  - Symbols in different crates but with same names \"within\" the crate need\n+//!    to get different linkage-names.\n+//!\n+//!  - Symbol names should be deterministic: Two consecutive runs of the\n+//!    compiler over the same code base should produce the same symbol names for\n+//!    the same items.\n+//!\n+//!  - Symbol names should not depend on any global properties of the code base,\n+//!    so that small modifications to the code base do not result in all symbols\n+//!    changing. In previous versions of the compiler, symbol names incorporated\n+//!    the SVH (Stable Version Hash) of the crate. This scheme turned out to be\n+//!    infeasible when used in conjunction with incremental compilation because\n+//!    small code changes would invalidate all symbols generated previously.\n+//!\n+//!  - Even symbols from different versions of the same crate should be able to\n+//!    live next to each other without conflict.\n+//!\n+//! In order to fulfill the above requirements the following scheme is used by\n+//! the compiler:\n+//!\n+//! The main tool for avoiding naming conflicts is the incorporation of a 64-bit\n+//! hash value into every exported symbol name. Anything that makes a difference\n+//! to the symbol being named, but does not show up in the regular path needs to\n+//! be fed into this hash:\n+//!\n+//! - Different monomorphizations of the same item have the same path but differ\n+//!   in their concrete type parameters, so these parameters are part of the\n+//!   data being digested for the symbol hash.\n+//!\n+//! - Rust allows items to be defined in anonymous scopes, such as in\n+//!   `fn foo() { { fn bar() {} } { fn bar() {} } }`. Both `bar` functions have\n+//!   the path `foo::bar`, since the anonymous scopes do not contribute to the\n+//!   path of an item. The compiler already handles this case via so-called\n+//!   disambiguating `DefPaths` which use indices to distinguish items with the\n+//!   same name. The DefPaths of the functions above are thus `foo[0]::bar[0]`\n+//!   and `foo[0]::bar[1]`. In order to incorporate this disambiguation\n+//!   information into the symbol name too, these indices are fed into the\n+//!   symbol hash, so that the above two symbols would end up with different\n+//!   hash values.\n+//!\n+//! The two measures described above suffice to avoid intra-crate conflicts. In\n+//! order to also avoid inter-crate conflicts two more measures are taken:\n+//!\n+//! - The name of the crate containing the symbol is prepended to the symbol\n+//!   name, i.e. symbols are \"crate qualified\". For example, a function `foo` in\n+//!   module `bar` in crate `baz` would get a symbol name like\n+//!   `baz::bar::foo::{hash}` instead of just `bar::foo::{hash}`. This avoids\n+//!   simple conflicts between functions from different crates.\n+//!\n+//! - In order to be able to also use symbols from two versions of the same\n+//!   crate (which naturally also have the same name), a stronger measure is\n+//!   required: The compiler accepts an arbitrary \"salt\" value via the\n+//!   `-C metadata` commandline argument. This salt is then fed into the symbol\n+//!   hash of every exported item. Consequently, the symbols in two identical\n+//!   crates but with different salts are not in conflict with each other. This\n+//!   facility is mainly intended to be used by build tools like Cargo.\n+//!\n+//! A note on symbol name stability\n+//! -------------------------------\n+//! Previous versions of the compiler resorted to feeding NodeIds into the\n+//! symbol hash in order to disambiguate between items with the same path. The\n+//! current version of the name generation algorithm takes great care not to do\n+//! that, since NodeIds are notoriously unstable: A small change to the\n+//! code base will offset all NodeIds after the change and thus, much as using\n+//! the SVH in the hash, invalidate an unbounded number of symbol names. This\n+//! makes re-using previously compiled code for incremental compilation\n+//! virtually impossible. Thus, symbol hash generation exclusively relies on\n+//! DefPaths which are much more robust in the face of changes to the code base.\n+\n+use trans::{CrateContext, Instance};\n+use util::sha2::{Digest, Sha256};\n+\n+use rustc::middle::cstore;\n+use rustc::middle::def_id::DefId;\n+use rustc::middle::ty::{self, TypeFoldable};\n+use rustc::front::map::definitions::DefPath;\n+\n+use std::fmt::Write;\n+use syntax::ast;\n+use syntax::parse::token;\n+use serialize::hex::ToHex;\n+use super::link;\n+\n+pub fn def_id_to_string<'tcx>(tcx: &ty::TyCtxt<'tcx>, def_id: DefId) -> String {\n+\n+    let def_path = tcx.def_path(def_id);\n+    let mut s = String::with_capacity(def_path.len() * 16);\n+\n+    let def_path = if def_id.is_local() {\n+        s.push_str(&tcx.crate_name[..]);\n+        s.push_str(\"/\");\n+        s.push_str(&tcx.sess.crate_disambiguator.borrow()[..]);\n+        &def_path[..]\n+    } else {\n+        s.push_str(&tcx.sess.cstore.crate_name(def_id.krate)[..]);\n+        s.push_str(\"/\");\n+        s.push_str(&tcx.sess.cstore.crate_disambiguator(def_id.krate));\n+        &def_path[1..]\n+    };\n+\n+    for component in def_path {\n+        write!(s,\n+               \"::{}[{}]\",\n+               component.data.as_interned_str(),\n+               component.disambiguator)\n+            .unwrap();\n+    }\n+\n+    s\n+}\n+\n+fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             def_path: &DefPath,\n+                             originating_crate: ast::CrateNum,\n+                             parameters: &[ty::Ty<'tcx>])\n+                             -> String {\n+    let tcx = ccx.tcx();\n+\n+    let mut hash_state = ccx.symbol_hasher().borrow_mut();\n+\n+    hash_state.reset();\n+\n+    if originating_crate == cstore::LOCAL_CRATE {\n+        hash_state.input_str(&tcx.sess.crate_disambiguator.borrow()[..]);\n+    } else {\n+        hash_state.input_str(&tcx.sess.cstore.crate_disambiguator(originating_crate));\n+    }\n+\n+    for component in def_path {\n+        let disambiguator_bytes = [(component.disambiguator >>  0) as u8,\n+                                   (component.disambiguator >>  8) as u8,\n+                                   (component.disambiguator >> 16) as u8,\n+                                   (component.disambiguator >> 24) as u8];\n+        hash_state.input(&disambiguator_bytes);\n+    }\n+\n+    for t in parameters {\n+       assert!(!t.has_erasable_regions());\n+       assert!(!t.needs_subst());\n+       let encoded_type = tcx.sess.cstore.encode_type(tcx, t, def_id_to_string);\n+       hash_state.input(&encoded_type[..]);\n+    }\n+\n+    return format!(\"h{}\", truncated_hash_result(&mut *hash_state));\n+\n+    fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n+        let output = symbol_hasher.result_bytes();\n+        // 64 bits should be enough to avoid collisions.\n+        output[.. 8].to_hex()\n+    }\n+}\n+\n+fn exported_name_with_opt_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                           instance: &Instance<'tcx>,\n+                                           suffix: Option<&str>)\n+                                           -> String {\n+    let &Instance { def: mut def_id, params: parameters } = instance;\n+\n+    if let Some(node_id) = ccx.tcx().map.as_local_node_id(def_id) {\n+        if let Some(&src_def_id) = ccx.external_srcs().borrow().get(&node_id) {\n+            def_id = src_def_id;\n+        }\n+    }\n+\n+    let def_path = ccx.tcx().def_path(def_id);\n+    let hash = get_symbol_hash(ccx, &def_path, def_id.krate, parameters.as_slice());\n+\n+    let mut path = Vec::with_capacity(16);\n+\n+    if def_id.is_local() {\n+        path.push(ccx.tcx().crate_name.clone());\n+    }\n+\n+    path.extend(def_path.into_iter().map(|e| e.data.as_interned_str()));\n+\n+    if let Some(suffix) = suffix {\n+        path.push(token::intern_and_get_ident(suffix));\n+    }\n+\n+    link::mangle(path.into_iter(), Some(&hash[..]))\n+}\n+\n+pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               instance: &Instance<'tcx>)\n+                               -> String {\n+    exported_name_with_opt_suffix(ccx, instance, None)\n+}\n+\n+pub fn exported_name_with_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                           instance: &Instance<'tcx>,\n+                                           suffix: &str)\n+                                           -> String {\n+   exported_name_with_opt_suffix(ccx, instance, Some(suffix))\n+}"}, {"sha": "b9f92bcc4d961381b712c4c0c448e16ce9cb20d6", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c77f44eeee81021660c3c2cd86540b7449973417/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77f44eeee81021660c3c2cd86540b7449973417/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=c77f44eeee81021660c3c2cd86540b7449973417", "patch": "@@ -69,6 +69,7 @@ pub mod back {\n     pub mod linker;\n     pub mod link;\n     pub mod lto;\n+    pub mod symbol_names;\n     pub mod write;\n     pub mod msvc;\n }"}, {"sha": "a3d387afa96f7642b2ecba4e7c3202698f7a9375", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c77f44eeee81021660c3c2cd86540b7449973417/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77f44eeee81021660c3c2cd86540b7449973417/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=c77f44eeee81021660c3c2cd86540b7449973417", "patch": "@@ -25,7 +25,8 @@ use trans::debuginfo;\n use trans::declare;\n use trans::glue::DropGlueKind;\n use trans::mir::CachedMir;\n-use trans::monomorphize::Instance;\n+use trans::Instance;\n+\n use trans::collector::{TransItem, TransItemState};\n use trans::type_::{Type, TypeNames};\n use middle::subst::{Substs, VecPerParamSpace};"}, {"sha": "f77f7c30987c88a84779c4bfa2abd125d64ebac9", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c77f44eeee81021660c3c2cd86540b7449973417/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77f44eeee81021660c3c2cd86540b7449973417/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=c77f44eeee81021660c3c2cd86540b7449973417", "patch": "@@ -15,6 +15,7 @@ pub use self::base::trans_crate;\n pub use self::context::CrateContext;\n pub use self::common::gensym_name;\n pub use self::disr::Disr;\n+pub use self::monomorphize::Instance;\n \n #[macro_use]\n mod macros;"}, {"sha": "6dd8d651012e0b20926ef3a47beb66c28e042e23", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c77f44eeee81021660c3c2cd86540b7449973417/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77f44eeee81021660c3c2cd86540b7449973417/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=c77f44eeee81021660c3c2cd86540b7449973417", "patch": "@@ -8,21 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::link::exported_name;\n+use back::symbol_names;\n use llvm::ValueRef;\n use llvm;\n use middle::def_id::DefId;\n use middle::infer::normalize_associated_type;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n+use middle::ty::{self, Ty, TyCtxt};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use trans::attributes;\n use trans::base::{push_ctxt};\n use trans::base::trans_fn;\n use trans::base;\n use trans::common::*;\n use trans::declare;\n-use middle::ty::{self, Ty, TyCtxt};\n use trans::Disr;\n use rustc::front::map as hir_map;\n use rustc::util::ppaux;\n@@ -33,7 +33,6 @@ use syntax::attr;\n use syntax::errors;\n \n use std::fmt;\n-use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: DefId,\n@@ -90,22 +89,13 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         monomorphizing.insert(fn_id, depth + 1);\n     }\n \n-    let hash;\n-    let s = {\n-        let mut state = SipHasher::new();\n-        instance.hash(&mut state);\n-        mono_ty.hash(&mut state);\n-\n-        hash = format!(\"h{}\", state.finish());\n-        let path = ccx.tcx().map.def_path(fn_id);\n-        exported_name(path, &hash[..])\n-    };\n+    let symbol = symbol_names::exported_name(ccx, &instance);\n \n-    debug!(\"monomorphize_fn mangled to {}\", s);\n-    assert!(declare::get_defined_value(ccx, &s).is_none());\n+    debug!(\"monomorphize_fn mangled to {}\", symbol);\n+    assert!(declare::get_defined_value(ccx, &symbol).is_none());\n \n     // FIXME(nagisa): perhaps needs a more fine grained selection?\n-    let lldecl = declare::define_internal_fn(ccx, &s, mono_ty);\n+    let lldecl = declare::define_internal_fn(ccx, &symbol, mono_ty);\n     // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n     attributes::unwind(lldecl, true);\n \n@@ -137,9 +127,10 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n             attributes::from_fn_attrs(ccx, attrs, lldecl);\n \n-            let is_first = !ccx.available_monomorphizations().borrow().contains(&s);\n+            let is_first = !ccx.available_monomorphizations().borrow()\n+                                                             .contains(&symbol);\n             if is_first {\n-                ccx.available_monomorphizations().borrow_mut().insert(s.clone());\n+                ccx.available_monomorphizations().borrow_mut().insert(symbol.clone());\n             }\n \n             let trans_everywhere = attr::requests_inline(attrs);"}, {"sha": "388d3238d4248960c37b2a317d249fca570f5a69", "filename": "src/test/auxiliary/typeid-intrinsic-aux1.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c77f44eeee81021660c3c2cd86540b7449973417/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic-aux1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77f44eeee81021660c3c2cd86540b7449973417/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic-aux1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic-aux1.rs?ref=c77f44eeee81021660c3c2cd86540b7449973417", "previous_filename": "src/test/auxiliary/typeid-intrinsic.rs"}, {"sha": "3ad307fd3b507b6b3cf199b4abb946227c881beb", "filename": "src/test/auxiliary/typeid-intrinsic-aux2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c77f44eeee81021660c3c2cd86540b7449973417/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic-aux2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77f44eeee81021660c3c2cd86540b7449973417/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic-aux2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftypeid-intrinsic-aux2.rs?ref=c77f44eeee81021660c3c2cd86540b7449973417", "previous_filename": "src/test/auxiliary/typeid-intrinsic2.rs"}, {"sha": "4bd82baafeb100c32897ccf9584969dc98902d2d", "filename": "src/test/run-pass/typeid-intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c77f44eeee81021660c3c2cd86540b7449973417/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77f44eeee81021660c3c2cd86540b7449973417/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeid-intrinsic.rs?ref=c77f44eeee81021660c3c2cd86540b7449973417", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:typeid-intrinsic.rs\n-// aux-build:typeid-intrinsic2.rs\n+// aux-build:typeid-intrinsic-aux1.rs\n+// aux-build:typeid-intrinsic-aux2.rs\n \n #![feature(core_intrinsics)]\n \n-extern crate typeid_intrinsic as other1;\n-extern crate typeid_intrinsic2 as other2;\n+extern crate typeid_intrinsic_aux1 as other1;\n+extern crate typeid_intrinsic_aux2 as other2;\n \n use std::hash::{SipHasher, Hasher, Hash};\n use std::any::TypeId;"}]}