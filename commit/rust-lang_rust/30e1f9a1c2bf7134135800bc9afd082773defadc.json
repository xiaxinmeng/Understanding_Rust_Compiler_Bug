{"sha": "30e1f9a1c2bf7134135800bc9afd082773defadc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZTFmOWExYzJiZjcxMzQxMzU4MDBiYzlhZmQwODI3NzNkZWZhZGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-14T22:07:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-14T22:07:25Z"}, "message": "Auto merge of #23289 - mihneadb:rustdoc-search-by-type, r=alexcrichton\n\nThis adds search by type (for functions/methods) support to Rustdoc. Target issue is at https://github.com/rust-lang/rfcs/issues/658.\r\n\r\nI've described my approach here: https://github.com/rust-lang/rfcs/issues/658#issuecomment-76484200. I'll copy the text in here as well:\r\n\r\n---\r\n\r\nHi, it took me longer than I wished, but I have implemented this in a not-too-complex way that I think can be extended to support more complex features (like the ones mentioned [here](https://github.com/rust-lang/rust/issues/12866#issuecomment-66945317)).\r\n\r\nThe idea is to generate a JSON representation of the types of methods/functions in the existing index, and then make the JS understand when it should look by type (and not by name).\r\n\r\nI tried to come up with a JSON representation that can be extended to support generics, bounds, ref/mut annotations and so on. Here are a few samples:\r\n\r\nFunction:\r\n\r\n```rust\r\nfn to_uppercase(c: char) -> char\r\n```\r\n\r\n```json\r\n{\r\n    \"inputs\": [\r\n        {\"name\": \"char\"}\r\n    ],\r\n    \"output\": {\r\n        \"name\": \"char\",\r\n    }\r\n}\r\n```\r\n\r\nMethod (implemented or defined in trait):\r\n\r\n```rust\r\n// in struct Vec\r\n// self is considered an argument as well\r\nfn capacity(&self) -> usize\r\n```\r\n\r\n```json\r\n{\r\n    \"inputs\": [\r\n        {\"name\": \"vec\"}\r\n    ],\r\n    \"output\": {\r\n        \"name\": \"usize\"\r\n    }\r\n}\r\n```\r\n\r\nThis simple format can be extended by adding more fields, like `generic: bool`, a `bounds` mapping and so on.\r\n\r\nI have a working implementation in https://github.com/rust-lang/rust/compare/master...mihneadb:rustdoc-search-by-type. You can check out a live demo [here](http://data.mihneadb.net/doc/std/index.html?search=charext%20-%3E%20char).\r\n\r\n![screenshot from 2015-02-28 00 54 00](https://cloud.githubusercontent.com/assets/643127/6422722/7e5374ee-bee4-11e4-99a6-9aac3c9d5068.png)\r\n\r\n\r\nThe feature list is not that long:\r\n- search by types (you *can* use generics as well, as long as you use the exact name - e.g. [`vec,t -> `](http://data.mihneadb.net/doc/std/index.html?search=vec%2C%20t%20-%3E))\r\n- order of arguments does not matter\r\n- `self` is took into account as well (e.g. search for `vec -> usize`)\r\n- does not use \"complex\" annotations (e.g. you don't search for `&char -> char` but for `char -> char`)\r\n\r\nMy goal is to get a working, minimal \"base\" merged so that others can build upon it. How should I proceed? Do I open a PR (badly in need of code review since this is my first non \"hello world\"-ish rust code)?\r\n\r\n---", "tree": {"sha": "4be916100bcfe847155d684079aa92cac5af49af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4be916100bcfe847155d684079aa92cac5af49af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30e1f9a1c2bf7134135800bc9afd082773defadc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30e1f9a1c2bf7134135800bc9afd082773defadc", "html_url": "https://github.com/rust-lang/rust/commit/30e1f9a1c2bf7134135800bc9afd082773defadc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30e1f9a1c2bf7134135800bc9afd082773defadc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3400c9ed9f1200a59f6452db5c71af2182db29a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3400c9ed9f1200a59f6452db5c71af2182db29a5", "html_url": "https://github.com/rust-lang/rust/commit/3400c9ed9f1200a59f6452db5c71af2182db29a5"}, {"sha": "7b7b938be1123631fed4e021fd3ef9562cf81b0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7b938be1123631fed4e021fd3ef9562cf81b0c", "html_url": "https://github.com/rust-lang/rust/commit/7b7b938be1123631fed4e021fd3ef9562cf81b0c"}], "stats": {"total": 145, "additions": 142, "deletions": 3}, "files": [{"sha": "4c6341efb72c73430317e35b73411692aee8344b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 107, "deletions": 1, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/30e1f9a1c2bf7134135800bc9afd082773defadc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30e1f9a1c2bf7134135800bc9afd082773defadc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=30e1f9a1c2bf7134135800bc9afd082773defadc", "patch": "@@ -34,6 +34,7 @@\n //! both occur before the crate is rendered.\n pub use self::ExternalLocation::*;\n \n+use std::ascii::OwnedAsciiExt;\n use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::collections::{HashMap, HashSet};\n@@ -239,6 +240,51 @@ struct IndexItem {\n     path: String,\n     desc: String,\n     parent: Option<ast::DefId>,\n+    search_type: Option<IndexItemFunctionType>,\n+}\n+\n+/// A type used for the search index.\n+struct Type {\n+    name: Option<String>,\n+}\n+\n+impl fmt::Display for Type {\n+    /// Formats type as {name: $name}.\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // Wrapping struct fmt should never call us when self.name is None,\n+        // but just to be safe we write `null` in that case.\n+        match self.name {\n+            Some(ref n) => write!(f, \"{{\\\"name\\\":\\\"{}\\\"}}\", n),\n+            None => write!(f, \"null\")\n+        }\n+    }\n+}\n+\n+/// Full type of functions/methods in the search index.\n+struct IndexItemFunctionType {\n+    inputs: Vec<Type>,\n+    output: Option<Type>\n+}\n+\n+impl fmt::Display for IndexItemFunctionType {\n+    /// Formats a full fn type as a JSON {inputs: [Type], outputs: Type/null}.\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // If we couldn't figure out a type, just write `null`.\n+        if self.inputs.iter().any(|ref i| i.name.is_none()) ||\n+           (self.output.is_some() && self.output.as_ref().unwrap().name.is_none()) {\n+            return write!(f, \"null\")\n+        }\n+\n+        let inputs: Vec<String> = self.inputs.iter().map(|ref t| format!(\"{}\", t)).collect();\n+        try!(write!(f, \"{{\\\"inputs\\\":[{}],\\\"output\\\":\", inputs.connect(\",\")));\n+\n+        match self.output {\n+            Some(ref t) => try!(write!(f, \"{}\", t)),\n+            None => try!(write!(f, \"null\"))\n+        };\n+\n+        Ok(try!(write!(f, \"}}\")))\n+    }\n }\n \n // TLS keys used to carry information around during rendering.\n@@ -409,6 +455,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n                         path: fqp[..fqp.len() - 1].connect(\"::\"),\n                         desc: shorter(item.doc_value()).to_string(),\n                         parent: Some(did),\n+                        search_type: None,\n                     });\n                 },\n                 None => {}\n@@ -458,7 +505,11 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n                 let pathid = *nodeid_to_pathid.get(&nodeid).unwrap();\n                 try!(write!(&mut w, \",{}\", pathid));\n             }\n-            None => {}\n+            None => try!(write!(&mut w, \",null\"))\n+        }\n+        match item.search_type {\n+            Some(ref t) => try!(write!(&mut w, \",{}\", t)),\n+            None => try!(write!(&mut w, \",null\"))\n         }\n         try!(write!(&mut w, \"]\"));\n     }\n@@ -872,12 +923,21 @@ impl DocFolder for Cache {\n \n             match parent {\n                 (parent, Some(path)) if is_method || (!self.privmod && !hidden_field) => {\n+                    // Needed to determine `self` type.\n+                    let parent_basename = self.parent_stack.first().and_then(|parent| {\n+                        match self.paths.get(parent) {\n+                            Some(&(ref fqp, _)) => Some(fqp[fqp.len() - 1].clone()),\n+                            _ => None\n+                        }\n+                    });\n+\n                     self.search_index.push(IndexItem {\n                         ty: shortty(&item),\n                         name: s.to_string(),\n                         path: path.connect(\"::\").to_string(),\n                         desc: shorter(item.doc_value()).to_string(),\n                         parent: parent,\n+                        search_type: get_index_search_type(&item, parent_basename),\n                     });\n                 }\n                 (Some(parent), None) if is_method || (!self.privmod && !hidden_field)=> {\n@@ -2307,6 +2367,52 @@ fn make_item_keywords(it: &clean::Item) -> String {\n     format!(\"{}, {}\", get_basic_keywords(), it.name.as_ref().unwrap())\n }\n \n+fn get_index_search_type(item: &clean::Item,\n+                         parent: Option<String>) -> Option<IndexItemFunctionType> {\n+    let decl = match item.inner {\n+        clean::FunctionItem(ref f) => &f.decl,\n+        clean::MethodItem(ref m) => &m.decl,\n+        clean::TyMethodItem(ref m) => &m.decl,\n+        _ => return None\n+    };\n+\n+    let mut inputs = Vec::new();\n+\n+    // Consider `self` an argument as well.\n+    if let Some(name) = parent {\n+        inputs.push(Type { name: Some(name.into_ascii_lowercase()) });\n+    }\n+\n+    inputs.extend(&mut decl.inputs.values.iter().map(|arg| {\n+        get_index_type(&arg.type_)\n+    }));\n+\n+    let output = match decl.output {\n+        clean::FunctionRetTy::Return(ref return_type) => Some(get_index_type(return_type)),\n+        _ => None\n+    };\n+\n+    Some(IndexItemFunctionType { inputs: inputs, output: output })\n+}\n+\n+fn get_index_type(clean_type: &clean::Type) -> Type {\n+    Type { name: get_index_type_name(clean_type).map(|s| s.into_ascii_lowercase()) }\n+}\n+\n+fn get_index_type_name(clean_type: &clean::Type) -> Option<String> {\n+    match *clean_type {\n+        clean::ResolvedPath { ref path, .. } => {\n+            let segments = &path.segments;\n+            Some(segments[segments.len() - 1].name.clone())\n+        },\n+        clean::Generic(ref s) => Some(s.clone()),\n+        clean::Primitive(ref p) => Some(format!(\"{:?}\", p)),\n+        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_),\n+        // FIXME: add all from clean::Type.\n+        _ => None\n+    }\n+}\n+\n pub fn cache() -> Arc<Cache> {\n     CACHE_KEY.with(|c| c.borrow().clone())\n }"}, {"sha": "ca6d9441957777a4e187703df16167fe78a9a84b", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/30e1f9a1c2bf7134135800bc9afd082773defadc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/30e1f9a1c2bf7134135800bc9afd082773defadc/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=30e1f9a1c2bf7134135800bc9afd082773defadc", "patch": "@@ -209,6 +209,33 @@\n                         break;\n                     }\n                 }\n+            // searching by type\n+            } else if (val.search(\"->\") > -1) {\n+                var trimmer = function (s) { return s.trim(); };\n+                var parts = val.split(\"->\").map(trimmer);\n+                var input = parts[0];\n+                // sort inputs so that order does not matter\n+                var inputs = input.split(\",\").map(trimmer).sort();\n+                var output = parts[1];\n+\n+                for (var i = 0; i < nSearchWords; ++i) {\n+                    var type = searchIndex[i].type;\n+                    if (!type) {\n+                        continue;\n+                    }\n+\n+                    // sort index inputs so that order does not matter\n+                    var typeInputs = type.inputs.map(function (input) {\n+                        return input.name;\n+                    }).sort();\n+\n+                    // allow searching for void (no output) functions as well\n+                    var typeOutput = type.output ? type.output.name : \"\";\n+                    if (inputs.toString() === typeInputs.toString() &&\n+                        output == typeOutput) {\n+                        results.push({id: i, index: -1, dontValidate: true});\n+                    }\n+                }\n             } else {\n                 // gather matching search results up to a certain maximum\n                 val = val.replace(/\\_/g, \"\");\n@@ -329,6 +356,11 @@\n                     path = result.item.path.toLowerCase(),\n                     parent = result.item.parent;\n \n+                // this validation does not make sense when searching by types\n+                if (result.dontValidate) {\n+                    continue;\n+                }\n+\n                 var valid = validateResult(name, path, split, parent);\n                 if (!valid) {\n                     result.id = -1;\n@@ -573,7 +605,8 @@\n                 //              (String) name,\n                 //              (String) full path or empty string for previous path,\n                 //              (String) description,\n-                //              (optional Number) the parent path index to `paths`]\n+                //              (Number | null) the parent path index to `paths`]\n+                //              (Object | null) the type of the function (if any)\n                 var items = rawSearchIndex[crate].items;\n                 // an array of [(Number) item type,\n                 //              (String) name]\n@@ -598,7 +631,7 @@\n                     var rawRow = items[i];\n                     var row = {crate: crate, ty: rawRow[0], name: rawRow[1],\n                                path: rawRow[2] || lastPath, desc: rawRow[3],\n-                               parent: paths[rawRow[4]]};\n+                               parent: paths[rawRow[4]], type: rawRow[5]};\n                     searchIndex.push(row);\n                     if (typeof row.name === \"string\") {\n                         var word = row.name.toLowerCase();"}]}