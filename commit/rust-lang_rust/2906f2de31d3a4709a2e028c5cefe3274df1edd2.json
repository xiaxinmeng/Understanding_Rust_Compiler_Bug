{"sha": "2906f2de31d3a4709a2e028c5cefe3274df1edd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MDZmMmRlMzFkM2E0NzA5YTJlMDI4YzVjZWZlMzI3NGRmMWVkZDI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-19T00:34:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-19T02:36:25Z"}, "message": "core: Rename 'unsafe' mod to 'cast'", "tree": {"sha": "608d302d2da9538bc12cdf286437a6cd654c7535", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/608d302d2da9538bc12cdf286437a6cd654c7535"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2906f2de31d3a4709a2e028c5cefe3274df1edd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2906f2de31d3a4709a2e028c5cefe3274df1edd2", "html_url": "https://github.com/rust-lang/rust/commit/2906f2de31d3a4709a2e028c5cefe3274df1edd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2906f2de31d3a4709a2e028c5cefe3274df1edd2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77480e8e44d9c5a6858172faeb291496314cf739", "url": "https://api.github.com/repos/rust-lang/rust/commits/77480e8e44d9c5a6858172faeb291496314cf739", "html_url": "https://github.com/rust-lang/rust/commit/77480e8e44d9c5a6858172faeb291496314cf739"}], "stats": {"total": 436, "additions": 218, "deletions": 218}, "files": [{"sha": "069bc62562375f8e93aa1fef098bf0471f29944a", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -29,7 +29,7 @@ extern mod rusti {\n pure fn capacity<T>(&&v: @[const T]) -> uint {\n     unsafe {\n         let repr: **raw::VecRepr =\n-            ::unsafe::reinterpret_cast(&addr_of(v));\n+            ::cast::reinterpret_cast(&addr_of(v));\n         (**repr).unboxed.alloc / sys::size_of::<T>()\n     }\n }\n@@ -154,13 +154,13 @@ mod raw {\n      */\n     #[inline(always)]\n     unsafe fn set_len<T>(&&v: @[const T], new_len: uint) {\n-        let repr: **VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n+        let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n     #[inline(always)]\n     unsafe fn push<T>(&v: @[const T], +initval: T) {\n-        let repr: **VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n+        let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n             push_fast(v, move initval);\n@@ -172,7 +172,7 @@ mod raw {\n     // This doesn't bother to make sure we have space.\n     #[inline(always)] // really pretty please\n     unsafe fn push_fast<T>(&v: @[const T], +initval: T) {\n-        let repr: **VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n+        let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n         let fill = (**repr).unboxed.fill;\n         (**repr).unboxed.fill += sys::size_of::<T>();\n         let p = ptr::addr_of((**repr).unboxed.data);"}, {"sha": "601eeff696996b853a6852fa789af0cd7a143b2d", "filename": "src/libcore/cast.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "previous_filename": "src/libcore/unsafe.rs"}, {"sha": "35155e683dcafc99360ad738db48d7f4f454ea34", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -2,7 +2,7 @@ use libc::{c_char, c_void, intptr_t, uintptr_t};\n use ptr::{mut_null, null, to_unsafe_ptr};\n use repr::BoxRepr;\n use sys::TypeDesc;\n-use unsafe::transmute;\n+use cast::transmute;\n \n export annihilate;\n "}, {"sha": "c3ed8c8c82c5a9b150d453597a64fbf7a3376082", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -181,7 +181,7 @@ fn send<T: Send>(ch: Chan<T>, +data: T) {\n     let res = rustrt::rust_port_id_send(p, data_ptr);\n     if res != 0 unsafe {\n         // Data sent successfully\n-        unsafe::forget(move data);\n+        cast::forget(move data);\n     }\n     task::yield();\n }"}, {"sha": "e732bcdb2fb7dcd583a7fb0dfa24390e9c2ba425", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -41,7 +41,7 @@ export uint, u8, u16, u32, u64;\n export float, f32, f64;\n export box, char, str, ptr, vec, at_vec, bool;\n export either, option, result, iter;\n-export gc, io, libc, os, run, rand, sys, unsafe, logging;\n+export gc, io, libc, os, run, rand, sys, cast, logging;\n export comm, task, future, pipes;\n export extfmt;\n // The test harness links against core, so don't include runtime in tests.\n@@ -228,7 +228,7 @@ mod path;\n mod rand;\n mod run;\n mod sys;\n-mod unsafe;\n+mod cast;\n mod mutable;\n mod flate;\n mod repr;"}, {"sha": "32c40a3f66ed5ba468f6812e8c6d2e10e0ac7581", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -9,7 +9,7 @@\n //\n // Note that recursive use is not permitted.\n \n-use unsafe::reinterpret_cast;\n+use cast::reinterpret_cast;\n use ptr::null;\n \n export DVec;\n@@ -81,7 +81,7 @@ fn unwrap<A>(+d: DVec<A>) -> ~[A] {\n priv impl<A> DVec<A> {\n     pure fn check_not_borrowed() {\n         unsafe {\n-            let data: *() = unsafe::reinterpret_cast(&self.data);\n+            let data: *() = cast::reinterpret_cast(&self.data);\n             if data.is_null() {\n                 fail ~\"Recursive use of dvec\";\n             }\n@@ -91,9 +91,9 @@ priv impl<A> DVec<A> {\n     #[inline(always)]\n     fn check_out<B>(f: fn(-~[A]) -> B) -> B {\n         unsafe {\n-            let mut data = unsafe::reinterpret_cast(&null::<()>());\n+            let mut data = cast::reinterpret_cast(&null::<()>());\n             data <-> self.data;\n-            let data_ptr: *() = unsafe::reinterpret_cast(&data);\n+            let data_ptr: *() = cast::reinterpret_cast(&data);\n             if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n             return f(move data);\n         }\n@@ -168,9 +168,9 @@ impl<A> DVec<A> {\n     /// Insert a single item at the front of the list\n     fn unshift(-t: A) {\n         unsafe {\n-            let mut data = unsafe::reinterpret_cast(&null::<()>());\n+            let mut data = cast::reinterpret_cast(&null::<()>());\n             data <-> self.data;\n-            let data_ptr: *() = unsafe::reinterpret_cast(&data);\n+            let data_ptr: *() = cast::reinterpret_cast(&data);\n             if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n             log(error, ~\"a\");\n             self.data <- ~[move t];"}, {"sha": "5cd8dd237e06eb003a91ba66c14c713de5e91bda", "filename": "src/libcore/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -17,7 +17,7 @@\n \n use either::Either;\n use pipes::recv;\n-use unsafe::copy_lifetime;\n+use cast::copy_lifetime;\n \n export Future;\n export extensions;"}, {"sha": "b1432bc39f5647e47bdde9416284c13ffcc214f1", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -55,14 +55,14 @@ extern mod rustrt {\n }\n \n unsafe fn bump<T, U>(ptr: *T, count: uint) -> *U {\n-    return unsafe::reinterpret_cast(&ptr::offset(ptr, count));\n+    return cast::reinterpret_cast(&ptr::offset(ptr, count));\n }\n \n unsafe fn align_to_pointer<T>(ptr: *T) -> *T {\n     let align = sys::min_align_of::<*T>();\n-    let ptr: uint = unsafe::reinterpret_cast(&ptr);\n+    let ptr: uint = cast::reinterpret_cast(&ptr);\n     let ptr = (ptr + (align - 1)) & -align;\n-    return unsafe::reinterpret_cast(&ptr);\n+    return cast::reinterpret_cast(&ptr);\n }\n \n unsafe fn get_safe_point_count() -> uint {\n@@ -101,8 +101,8 @@ type Visitor = fn(root: **Word, tydesc: *Word) -> bool;\n // Walks the list of roots for the given safe point, and calls visitor\n // on each root.\n unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n-    let fp_bytes: *u8 = unsafe::reinterpret_cast(&fp);\n-    let sp_meta: *u32 = unsafe::reinterpret_cast(&sp.sp_meta);\n+    let fp_bytes: *u8 = cast::reinterpret_cast(&fp);\n+    let sp_meta: *u32 = cast::reinterpret_cast(&sp.sp_meta);\n \n     let num_stack_roots = *sp_meta as uint;\n     let num_reg_roots = *ptr::offset(sp_meta, 1) as uint;\n@@ -143,9 +143,9 @@ unsafe fn walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) {\n \n // Is fp contained in segment?\n unsafe fn is_frame_in_segment(fp: *Word, segment: *StackSegment) -> bool {\n-    let begin: Word = unsafe::reinterpret_cast(&segment);\n-    let end: Word = unsafe::reinterpret_cast(&(*segment).end);\n-    let frame: Word = unsafe::reinterpret_cast(&fp);\n+    let begin: Word = cast::reinterpret_cast(&segment);\n+    let end: Word = cast::reinterpret_cast(&(*segment).end);\n+    let frame: Word = cast::reinterpret_cast(&fp);\n \n     return begin <= frame && frame <= end;\n }\n@@ -315,7 +315,7 @@ fn cleanup_stack_for_failure() {\n         // own stack roots on the stack anyway.\n         let sentinel_box = ~0;\n         let sentinel: **Word = if expect_sentinel() {\n-            unsafe::reinterpret_cast(&ptr::addr_of(sentinel_box))\n+            cast::reinterpret_cast(&ptr::addr_of(sentinel_box))\n         } else {\n             ptr::null()\n         };"}, {"sha": "54304658fd1ffabc939e7ab416c791966d0467e6", "filename": "src/libcore/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -721,7 +721,7 @@ fn with_str_writer(f: fn(Writer)) -> ~str {\n     vec::push(v, 0);\n     assert str::is_utf8(v);\n \n-    unsafe { move ::unsafe::transmute(v) }\n+    unsafe { move ::cast::transmute(v) }\n }\n \n // Utility functions"}, {"sha": "506da9d3909cb3cbca20488b044f92630e763f91", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -13,7 +13,7 @@ mutation when the data structure should be immutable.\n #[forbid(deprecated_pattern)];\n \n use util::with;\n-use unsafe::transmute_immut;\n+use cast::transmute_immut;\n \n export Mut;\n "}, {"sha": "3a15179e0c6fd8c4b7de70e904cce0b4d4646626", "filename": "src/libcore/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -222,10 +222,10 @@ mod global_env {\n         fn getenv(n: &str) -> Option<~str> {\n             unsafe {\n                 let s = str::as_c_str(n, libc::getenv);\n-                return if ptr::null::<u8>() == unsafe::reinterpret_cast(&s) {\n+                return if ptr::null::<u8>() == cast::reinterpret_cast(&s) {\n                     option::None::<~str>\n                 } else {\n-                    let s = unsafe::reinterpret_cast(&s);\n+                    let s = cast::reinterpret_cast(&s);\n                     option::Some::<~str>(str::raw::from_buf(s))\n                 };\n             }"}, {"sha": "3adb77873c2fbb2d3021df39395187cdd4560671", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -77,7 +77,7 @@ bounded and unbounded protocols allows for less code duplication.\n #[forbid(deprecated_pattern)];\n \n use cmp::Eq;\n-use unsafe::{forget, reinterpret_cast, transmute};\n+use cast::{forget, reinterpret_cast, transmute};\n use either::{Either, Left, Right};\n use option::unwrap;\n "}, {"sha": "a5db84a9b06c3e4b1f232b53b0fa3df799a50a86", "filename": "src/libcore/private.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -89,8 +89,8 @@ unsafe fn chan_from_global_ptr<T: Send>(\n         // Install the channel\n         log(debug,~\"BEFORE COMPARE AND SWAP\");\n         let swapped = compare_and_swap(\n-            unsafe::reinterpret_cast(&global),\n-            0u, unsafe::reinterpret_cast(&ch));\n+            cast::reinterpret_cast(&global),\n+            0u, cast::reinterpret_cast(&ch));\n         log(debug,fmt!(\"AFTER .. swapped? %?\", swapped));\n \n         if swapped {\n@@ -100,11 +100,11 @@ unsafe fn chan_from_global_ptr<T: Send>(\n         } else {\n             // Somebody else got in before we did\n             comm::send(setup_ch, Abort);\n-            unsafe::reinterpret_cast(&*global)\n+            cast::reinterpret_cast(&*global)\n         }\n     } else {\n         log(debug, ~\"global != 0\");\n-        unsafe::reinterpret_cast(&*global)\n+        cast::reinterpret_cast(&*global)\n     }\n }\n \n@@ -211,15 +211,15 @@ unsafe fn weaken_task(f: fn(comm::Port<()>)) {\n     let po = comm::Port();\n     let ch = comm::Chan(po);\n     unsafe {\n-        rustrt::rust_task_weaken(unsafe::reinterpret_cast(&ch));\n+        rustrt::rust_task_weaken(cast::reinterpret_cast(&ch));\n     }\n     let _unweaken = Unweaken(ch);\n     f(po);\n \n     struct Unweaken {\n       ch: comm::Chan<()>,\n       drop unsafe {\n-        rustrt::rust_task_unweaken(unsafe::reinterpret_cast(&self.ch));\n+        rustrt::rust_task_unweaken(cast::reinterpret_cast(&self.ch));\n       }\n     }\n \n@@ -309,7 +309,7 @@ struct ArcDestruct<T> {\n             return; // Happens when destructing an unwrapper's handle.\n         }\n         do task::unkillable {\n-            let data: ~ArcData<T> = unsafe::reinterpret_cast(&self.data);\n+            let data: ~ArcData<T> = cast::reinterpret_cast(&self.data);\n             let new_count = rustrt::rust_atomic_decrement(&mut data.count);\n             assert new_count >= 0;\n             if new_count == 0 {\n@@ -319,22 +319,22 @@ struct ArcDestruct<T> {\n                 // being here means we're the only *awake* task with the data.\n                 if data.unwrapper != 0 {\n                     let p: UnwrapProto =\n-                        unsafe::reinterpret_cast(&data.unwrapper);\n+                        cast::reinterpret_cast(&data.unwrapper);\n                     let (message, response) = option::swap_unwrap(p);\n                     // Send 'ready' and wait for a response.\n                     pipes::send_one(move message, ());\n                     // Unkillable wait. Message guaranteed to come.\n                     if pipes::recv_one(move response) {\n                         // Other task got the data.\n-                        unsafe::forget(move data);\n+                        cast::forget(move data);\n                     } else {\n                         // Other task was killed. drop glue takes over.\n                     }\n                 } else {\n                     // drop glue takes over.\n                 }\n             } else {\n-                unsafe::forget(move data);\n+                cast::forget(move data);\n             }\n         }\n     }\n@@ -359,7 +359,7 @@ unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n                 pipes::send_one(move response, false);\n                 // Either this swap_unwrap or the one below (at \"Got here\")\n                 // ought to run.\n-                unsafe::forget(option::swap_unwrap(&mut self.ptr));\n+                cast::forget(option::swap_unwrap(&mut self.ptr));\n             } else {\n                 assert self.ptr.is_none();\n                 pipes::send_one(move response, true);\n@@ -368,11 +368,11 @@ unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n     }\n \n     do task::unkillable {\n-        let ptr: ~ArcData<T> = unsafe::reinterpret_cast(&rc.data);\n+        let ptr: ~ArcData<T> = cast::reinterpret_cast(&rc.data);\n         let (c1,p1) = pipes::oneshot(); // ()\n         let (c2,p2) = pipes::oneshot(); // bool\n         let server: UnwrapProto = ~mut Some((move c1,move p2));\n-        let serverp: libc::uintptr_t = unsafe::transmute(move server);\n+        let serverp: libc::uintptr_t = cast::transmute(move server);\n         // Try to put our server end in the unwrapper slot.\n         if rustrt::rust_compare_and_swap_ptr(&mut ptr.unwrapper, 0, serverp) {\n             // Got in. Step 0: Tell destructor not to run. We are now it.\n@@ -383,7 +383,7 @@ unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n             if new_count == 0 {\n                 // We were the last owner. Can unwrap immediately.\n                 // Also we have to free the server endpoints.\n-                let _server: UnwrapProto = unsafe::transmute(move serverp);\n+                let _server: UnwrapProto = cast::transmute(move serverp);\n                 option::swap_unwrap(&mut ptr.data)\n                 // drop glue takes over.\n             } else {\n@@ -403,9 +403,9 @@ unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n             }\n         } else {\n             // Somebody else was trying to unwrap. Avoid guaranteed deadlock.\n-            unsafe::forget(move ptr);\n+            cast::forget(move ptr);\n             // Also we have to free the (rejected) server endpoints.\n-            let _server: UnwrapProto = unsafe::transmute(move serverp);\n+            let _server: UnwrapProto = cast::transmute(move serverp);\n             fail ~\"Another task is already unwrapping this ARC!\";\n         }\n     }\n@@ -422,7 +422,7 @@ type SharedMutableState<T: Send> = ArcDestruct<T>;\n unsafe fn shared_mutable_state<T: Send>(+data: T) -> SharedMutableState<T> {\n     let data = ~ArcData { count: 1, unwrapper: 0, data: Some(move data) };\n     unsafe {\n-        let ptr = unsafe::transmute(move data);\n+        let ptr = cast::transmute(move data);\n         ArcDestruct(ptr)\n     }\n }\n@@ -431,34 +431,34 @@ unsafe fn shared_mutable_state<T: Send>(+data: T) -> SharedMutableState<T> {\n unsafe fn get_shared_mutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n         -> &a/mut T {\n     unsafe {\n-        let ptr: ~ArcData<T> = unsafe::reinterpret_cast(&(*rc).data);\n+        let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         assert ptr.count > 0;\n         // Cast us back into the correct region\n-        let r = unsafe::transmute_region(option::get_ref(&ptr.data));\n-        unsafe::forget(move ptr);\n-        return unsafe::transmute_mut(r);\n+        let r = cast::transmute_region(option::get_ref(&ptr.data));\n+        cast::forget(move ptr);\n+        return cast::transmute_mut(r);\n     }\n }\n #[inline(always)]\n unsafe fn get_shared_immutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n         -> &a/T {\n     unsafe {\n-        let ptr: ~ArcData<T> = unsafe::reinterpret_cast(&(*rc).data);\n+        let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         assert ptr.count > 0;\n         // Cast us back into the correct region\n-        let r = unsafe::transmute_region(option::get_ref(&ptr.data));\n-        unsafe::forget(move ptr);\n+        let r = cast::transmute_region(option::get_ref(&ptr.data));\n+        cast::forget(move ptr);\n         return r;\n     }\n }\n \n unsafe fn clone_shared_mutable_state<T: Send>(rc: &SharedMutableState<T>)\n         -> SharedMutableState<T> {\n     unsafe {\n-        let ptr: ~ArcData<T> = unsafe::reinterpret_cast(&(*rc).data);\n+        let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         let new_count = rustrt::rust_atomic_increment(&mut ptr.count);\n         assert new_count >= 2;\n-        unsafe::forget(move ptr);\n+        cast::forget(move ptr);\n     }\n     ArcDestruct((*rc).data)\n }\n@@ -543,7 +543,7 @@ impl<T: Send> Exclusive<T> {\n     #[inline(always)]\n     unsafe fn with_imm<U>(f: fn(x: &T) -> U) -> U {\n         do self.with |x| {\n-            f(unsafe::transmute_immut(x))\n+            f(cast::transmute_immut(x))\n         }\n     }\n }"}, {"sha": "31c52f0b407a4e61490b1597bd5ba5a4c1cb7bc8", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -53,7 +53,7 @@ pure fn addr_of<T>(val: T) -> *T { unsafe { rusti::addr_of(val) } }\n #[inline(always)]\n pure fn mut_addr_of<T>(val: T) -> *mut T {\n     unsafe {\n-        unsafe::reinterpret_cast(&rusti::addr_of(val))\n+        cast::reinterpret_cast(&rusti::addr_of(val))\n     }\n }\n \n@@ -97,11 +97,11 @@ unsafe fn position<T>(buf: *T, f: fn(T) -> bool) -> uint {\n \n /// Create an unsafe null pointer\n #[inline(always)]\n-pure fn null<T>() -> *T { unsafe { unsafe::reinterpret_cast(&0u) } }\n+pure fn null<T>() -> *T { unsafe { cast::reinterpret_cast(&0u) } }\n \n /// Create an unsafe mutable null pointer\n #[inline(always)]\n-pure fn mut_null<T>() -> *mut T { unsafe { unsafe::reinterpret_cast(&0u) } }\n+pure fn mut_null<T>() -> *mut T { unsafe { cast::reinterpret_cast(&0u) } }\n \n /// Returns true if the pointer is equal to the null pointer.\n pure fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n@@ -147,7 +147,7 @@ unsafe fn memset<T>(dst: *mut T, c: int, count: uint)  {\n */\n #[inline(always)]\n fn to_unsafe_ptr<T>(thing: &T) -> *T {\n-    unsafe { unsafe::reinterpret_cast(&thing) }\n+    unsafe { cast::reinterpret_cast(&thing) }\n }\n \n /**\n@@ -157,7 +157,7 @@ fn to_unsafe_ptr<T>(thing: &T) -> *T {\n */\n #[inline(always)]\n fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n-    unsafe { unsafe::reinterpret_cast(&thing) }\n+    unsafe { cast::reinterpret_cast(&thing) }\n }\n \n /**\n@@ -167,7 +167,7 @@ fn to_const_unsafe_ptr<T>(thing: &const T) -> *const T {\n */\n #[inline(always)]\n fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n-    unsafe { unsafe::reinterpret_cast(&thing) }\n+    unsafe { cast::reinterpret_cast(&thing) }\n }\n \n /**\n@@ -179,7 +179,7 @@ fn to_mut_unsafe_ptr<T>(thing: &mut T) -> *mut T {\n */\n #[inline(always)]\n fn to_uint<T>(thing: &T) -> uint unsafe {\n-    unsafe::reinterpret_cast(&thing)\n+    cast::reinterpret_cast(&thing)\n }\n \n /// Determine if two borrowed pointers point to the same thing.\n@@ -205,8 +205,8 @@ impl<T> *T: Ptr {\n // Equality for pointers\n impl<T> *const T : Eq {\n     pure fn eq(&&other: *const T) -> bool unsafe {\n-        let a: uint = unsafe::reinterpret_cast(&self);\n-        let b: uint = unsafe::reinterpret_cast(&other);\n+        let a: uint = cast::reinterpret_cast(&self);\n+        let b: uint = cast::reinterpret_cast(&other);\n         return a == b;\n     }\n     pure fn ne(&&other: *const T) -> bool { !self.eq(other) }\n@@ -215,23 +215,23 @@ impl<T> *const T : Eq {\n // Comparison for pointers\n impl<T> *const T : Ord {\n     pure fn lt(&&other: *const T) -> bool unsafe {\n-        let a: uint = unsafe::reinterpret_cast(&self);\n-        let b: uint = unsafe::reinterpret_cast(&other);\n+        let a: uint = cast::reinterpret_cast(&self);\n+        let b: uint = cast::reinterpret_cast(&other);\n         return a < b;\n     }\n     pure fn le(&&other: *const T) -> bool unsafe {\n-        let a: uint = unsafe::reinterpret_cast(&self);\n-        let b: uint = unsafe::reinterpret_cast(&other);\n+        let a: uint = cast::reinterpret_cast(&self);\n+        let b: uint = cast::reinterpret_cast(&other);\n         return a <= b;\n     }\n     pure fn ge(&&other: *const T) -> bool unsafe {\n-        let a: uint = unsafe::reinterpret_cast(&self);\n-        let b: uint = unsafe::reinterpret_cast(&other);\n+        let a: uint = cast::reinterpret_cast(&self);\n+        let b: uint = cast::reinterpret_cast(&other);\n         return a >= b;\n     }\n     pure fn gt(&&other: *const T) -> bool unsafe {\n-        let a: uint = unsafe::reinterpret_cast(&self);\n-        let b: uint = unsafe::reinterpret_cast(&other);\n+        let a: uint = cast::reinterpret_cast(&self);\n+        let b: uint = cast::reinterpret_cast(&other);\n         return a > b;\n     }\n }\n@@ -256,7 +256,7 @@ fn test() {\n         type Pair = {mut fst: int, mut snd: int};\n         let p = {mut fst: 10, mut snd: 20};\n         let pptr: *mut Pair = mut_addr_of(p);\n-        let iptr: *mut int = unsafe::reinterpret_cast(&pptr);\n+        let iptr: *mut int = cast::reinterpret_cast(&pptr);\n         assert (*iptr == 10);;\n         *iptr = 30;\n         assert (*iptr == 30);"}, {"sha": "55866cbdc52a89b3944445da8a041d55e670ae4e", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -3,7 +3,7 @@ use io::{Writer, WriterUtil};\n use libc::c_void;\n use sys::TypeDesc;\n use to_str::ToStr;\n-use unsafe::transmute;\n+use cast::transmute;\n use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n use reflect::{MovePtr, MovePtrAdaptor};\n use vec::raw::{VecRepr, UnboxedVecRepr, SliceRepr};\n@@ -981,7 +981,7 @@ pub fn write_repr<T>(writer: @Writer, object: &T) {\n     unsafe {\n         let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n         let tydesc = sys::get_type_desc::<T>();\n-        let tydesc = unsafe::transmute(tydesc);\n+        let tydesc = cast::transmute(tydesc);\n \n         let repr_printer = @ReprPrinter {\n             ptr: ptr,"}, {"sha": "cc93d30ecd695c6d56c86914086ddd61a0e4194f", "filename": "src/libcore/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -113,7 +113,7 @@ fn with_envp<T>(env: &Option<~[(~str,~str)]>,\n         }\n         vec::push(ptrs, ptr::null());\n         vec::as_imm_buf(ptrs, |p, _len|\n-            unsafe { cb(::unsafe::reinterpret_cast(&p)) }\n+            unsafe { cb(::cast::reinterpret_cast(&p)) }\n         )\n       }\n       _ => cb(ptr::null())"}, {"sha": "28b36deb1d4726919f0fbb44b988f1ec9abb7cad", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -289,7 +289,7 @@ mod linear {\n                                 // inference stupidly infers a\n                                 // lifetime for `ref bkt` that is\n                                 // shorter than it needs to be.\n-                                unsafe::copy_lifetime(self, &bkt.value)\n+                                cast::copy_lifetime(self, &bkt.value)\n                             };\n                             Some(ptr)\n                         }"}, {"sha": "3a07186b01198e62b0ba796d87b999378be78133", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -1,6 +1,6 @@\n // NB: Don't rely on other core mods here as this has to move into the rt\n \n-use unsafe::reinterpret_cast;\n+use cast::reinterpret_cast;\n use ptr::offset;\n use sys::size_of;\n "}, {"sha": "d785da3a4625154c75d044e0c7e983f61a7e27f5", "filename": "src/libcore/str.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -149,7 +149,7 @@ pure fn from_slice(s: &str) -> ~str {\n  */\n pure fn from_byte(b: u8) -> ~str {\n     assert b < 128u8;\n-    unsafe { ::unsafe::transmute(~[b, 0u8]) }\n+    unsafe { ::cast::transmute(~[b, 0u8]) }\n }\n \n /// Appends a character at the end of a string\n@@ -167,7 +167,7 @@ fn push_char(&s: ~str, ch: char) {\n         reserve_at_least(s, new_len);\n         let off = len;\n         do as_buf(s) |buf, _len| {\n-            let buf: *mut u8 = ::unsafe::reinterpret_cast(&buf);\n+            let buf: *mut u8 = ::cast::reinterpret_cast(&buf);\n             if nb == 1u {\n                 *ptr::mut_offset(buf, off) =\n                     code as u8;\n@@ -250,7 +250,7 @@ fn push_str_no_overallocate(&lhs: ~str, rhs: &str) {\n         do as_buf(lhs) |lbuf, _llen| {\n             do as_buf(rhs) |rbuf, _rlen| {\n                 let dst = ptr::offset(lbuf, llen);\n-                let dst = ::unsafe::transmute_mut_unsafe(dst);\n+                let dst = ::cast::transmute_mut_unsafe(dst);\n                 ptr::memcpy(dst, rbuf, rlen);\n             }\n         }\n@@ -267,7 +267,7 @@ fn push_str(&lhs: ~str, rhs: &str) {\n         do as_buf(lhs) |lbuf, _llen| {\n             do as_buf(rhs) |rbuf, _rlen| {\n                 let dst = ptr::offset(lbuf, llen);\n-                let dst = ::unsafe::transmute_mut_unsafe(dst);\n+                let dst = ::cast::transmute_mut_unsafe(dst);\n                 ptr::memcpy(dst, rbuf, rlen);\n             }\n         }\n@@ -438,7 +438,7 @@ Section: Transforming strings\n  * The result vector is not null-terminated.\n  */\n pure fn to_bytes(s: &str) -> ~[u8] unsafe {\n-    let mut v: ~[u8] = ::unsafe::transmute(from_slice(s));\n+    let mut v: ~[u8] = ::cast::transmute(from_slice(s));\n     vec::raw::set_len(v, len(s));\n     move v\n }\n@@ -1820,7 +1820,7 @@ const tag_six_b: uint = 252u;\n  */\n pure fn as_bytes<T>(s: ~str, f: fn(~[u8]) -> T) -> T {\n     unsafe {\n-        let v: *~[u8] = ::unsafe::reinterpret_cast(&ptr::addr_of(s));\n+        let v: *~[u8] = ::cast::reinterpret_cast(&ptr::addr_of(s));\n         f(*v)\n     }\n }\n@@ -1832,9 +1832,9 @@ pure fn as_bytes<T>(s: ~str, f: fn(~[u8]) -> T) -> T {\n  */\n pure fn as_bytes_slice(s: &a/str) -> &a/[u8] {\n     unsafe {\n-        let (ptr, len): (*u8, uint) = ::unsafe::reinterpret_cast(&s);\n+        let (ptr, len): (*u8, uint) = ::cast::reinterpret_cast(&s);\n         let outgoing_tuple: (*u8, uint) = (ptr, len - 1);\n-        return ::unsafe::reinterpret_cast(&outgoing_tuple);\n+        return ::cast::reinterpret_cast(&outgoing_tuple);\n     }\n }\n \n@@ -1877,7 +1877,7 @@ pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n #[inline(always)]\n pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n     unsafe {\n-        let v : *(*u8,uint) = ::unsafe::reinterpret_cast(&ptr::addr_of(s));\n+        let v : *(*u8,uint) = ::cast::reinterpret_cast(&ptr::addr_of(s));\n         let (buf,len) = *v;\n         f(buf, len)\n     }\n@@ -1901,7 +1901,7 @@ pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n  */\n fn reserve(&s: ~str, n: uint) {\n     unsafe {\n-        let v: *mut ~[u8] = ::unsafe::reinterpret_cast(&ptr::addr_of(s));\n+        let v: *mut ~[u8] = ::cast::reinterpret_cast(&ptr::addr_of(s));\n         vec::reserve(*v, n + 1);\n     }\n }\n@@ -1993,24 +1993,24 @@ mod raw {\n         let mut v: ~[mut u8] = ~[mut];\n         vec::reserve(v, len + 1u);\n         vec::as_imm_buf(v, |vbuf, _len| {\n-            let vbuf = ::unsafe::transmute_mut_unsafe(vbuf);\n+            let vbuf = ::cast::transmute_mut_unsafe(vbuf);\n             ptr::memcpy(vbuf, buf as *u8, len)\n         });\n         vec::raw::set_len(v, len);\n         vec::push(v, 0u8);\n \n         assert is_utf8(v);\n-        return ::unsafe::transmute(move v);\n+        return ::cast::transmute(move v);\n     }\n \n     /// Create a Rust string from a null-terminated C string\n     unsafe fn from_c_str(c_str: *libc::c_char) -> ~str {\n-        from_buf(::unsafe::reinterpret_cast(&c_str))\n+        from_buf(::cast::reinterpret_cast(&c_str))\n     }\n \n     /// Create a Rust string from a `*c_char` buffer of the given length\n     unsafe fn from_c_str_len(c_str: *libc::c_char, len: uint) -> ~str {\n-        from_buf_len(::unsafe::reinterpret_cast(&c_str), len)\n+        from_buf_len(::cast::reinterpret_cast(&c_str), len)\n     }\n \n     /// Converts a vector of bytes to a string.\n@@ -2026,8 +2026,8 @@ mod raw {\n     /// Form a slice from a *u8 buffer of the given length without copying.\n     unsafe fn buf_as_slice<T>(buf: *u8, len: uint, f: fn(&& &str) -> T) -> T {\n         let v = (*buf, len + 1);\n-        assert is_utf8(::unsafe::reinterpret_cast(&v));\n-        f(::unsafe::transmute(move v))\n+        assert is_utf8(::cast::reinterpret_cast(&v));\n+        f(::cast::transmute(move v))\n     }\n \n     /**\n@@ -2049,13 +2049,13 @@ mod raw {\n             vec::reserve(v, end - begin + 1u);\n             unsafe {\n                 do vec::as_imm_buf(v) |vbuf, _vlen| {\n-                    let vbuf = ::unsafe::transmute_mut_unsafe(vbuf);\n+                    let vbuf = ::cast::transmute_mut_unsafe(vbuf);\n                     let src = ptr::offset(sbuf, begin);\n                     ptr::memcpy(vbuf, src, end - begin);\n                 }\n                 vec::raw::set_len(v, end - begin);\n                 vec::push(v, 0u8);\n-                ::unsafe::transmute(move v)\n+                ::cast::transmute(move v)\n             }\n         }\n     }\n@@ -2077,15 +2077,15 @@ mod raw {\n              assert (end <= n);\n \n              let tuple = (ptr::offset(sbuf, begin), end - begin + 1);\n-             ::unsafe::reinterpret_cast(&tuple)\n+             ::cast::reinterpret_cast(&tuple)\n         }\n     }\n \n     /// Appends a byte to a string. (Not UTF-8 safe).\n     unsafe fn push_byte(&s: ~str, b: u8) {\n         reserve_at_least(s, s.len() + 1);\n         do as_buf(s) |buf, len| {\n-            let buf: *mut u8 = ::unsafe::reinterpret_cast(&buf);\n+            let buf: *mut u8 = ::cast::reinterpret_cast(&buf);\n             *ptr::mut_offset(buf, len) = b;\n         }\n         set_len(s, s.len() + 1);\n@@ -2117,7 +2117,7 @@ mod raw {\n \n     /// Sets the length of the string and adds the null terminator\n     unsafe fn set_len(&v: ~str, new_len: uint) {\n-        let repr: *vec::raw::VecRepr = ::unsafe::reinterpret_cast(&v);\n+        let repr: *vec::raw::VecRepr = ::cast::reinterpret_cast(&v);\n         (*repr).unboxed.fill = new_len + 1u;\n         let null = ptr::mut_offset(ptr::mut_addr_of((*repr).unboxed.data),\n                                    new_len);"}, {"sha": "35baa0e6a5a9265acfab4637d612bdf27c77b6ca", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -92,7 +92,7 @@ pure fn pref_align_of<T>() -> uint {\n #[inline(always)]\n pure fn refcount<T>(+t: @T) -> uint {\n     unsafe {\n-        let ref_ptr: *uint = unsafe::reinterpret_cast(&t);\n+        let ref_ptr: *uint = cast::reinterpret_cast(&t);\n         *ref_ptr - 1\n     }\n }\n@@ -160,7 +160,7 @@ mod tests {\n \n         assert f(20) == 30;\n \n-        let original_closure: Closure = unsafe::transmute(f);\n+        let original_closure: Closure = cast::transmute(f);\n \n         let actual_function_pointer = original_closure.code;\n         let environment = original_closure.env;\n@@ -170,7 +170,7 @@ mod tests {\n             env: environment\n         };\n \n-        let new_f: fn(int) -> int = unsafe::transmute(new_closure);\n+        let new_f: fn(int) -> int = cast::transmute(new_closure);\n         assert new_f(20) == 30;\n     }\n }"}, {"sha": "adeebcf344e80197987c37fe09a0293128a15404", "filename": "src/libcore/task.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -1206,7 +1206,7 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n // a proper closure because the #[test]s won't understand. Have to fake it.\n macro_rules! taskgroup_key (\n     // Use a \"code pointer\" value that will never be a real code pointer.\n-    () => (unsafe::transmute((-2 as uint, 0u)))\n+    () => (cast::transmute((-2 as uint, 0u)))\n )\n \n fn gen_child_taskgroup(linked: bool, supervised: bool)\n@@ -1313,13 +1313,13 @@ fn spawn_raw(+opts: TaskOpts, +f: fn~()) {\n             let child_wrapper = make_child_wrapper(new_task, move child_tg,\n                   move ancestors, is_main, move notify_chan, move f);\n             let fptr = ptr::addr_of(child_wrapper);\n-            let closure: *rust_closure = unsafe::reinterpret_cast(&fptr);\n+            let closure: *rust_closure = cast::reinterpret_cast(&fptr);\n \n             // Getting killed between these two calls would free the child's\n             // closure. (Reordering them wouldn't help - then getting killed\n             // between them would leak.)\n             rustrt::start_task(new_task, closure);\n-            unsafe::forget(move child_wrapper);\n+            cast::forget(move child_wrapper);\n         }\n     }\n \n@@ -1466,8 +1466,8 @@ impl<T: Owned> @T: LocalData { }\n \n impl LocalData: Eq {\n     pure fn eq(&&other: LocalData) -> bool unsafe {\n-        let ptr_a: (uint, uint) = unsafe::reinterpret_cast(&self);\n-        let ptr_b: (uint, uint) = unsafe::reinterpret_cast(&other);\n+        let ptr_a: (uint, uint) = cast::reinterpret_cast(&self);\n+        let ptr_b: (uint, uint) = cast::reinterpret_cast(&other);\n         return ptr_a == ptr_b;\n     }\n     pure fn ne(&&other: LocalData) -> bool { !self.eq(other) }\n@@ -1482,7 +1482,7 @@ type TaskLocalMap = @dvec::DVec<Option<TaskLocalElement>>;\n extern fn cleanup_task_local_map(map_ptr: *libc::c_void) unsafe {\n     assert !map_ptr.is_null();\n     // Get and keep the single reference that was created at the beginning.\n-    let _map: TaskLocalMap = unsafe::reinterpret_cast(&map_ptr);\n+    let _map: TaskLocalMap = cast::reinterpret_cast(&map_ptr);\n     // All local_data will be destroyed along with the map.\n }\n \n@@ -1498,14 +1498,14 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n         let map: TaskLocalMap = @dvec::DVec();\n         // Use reinterpret_cast -- transmute would take map away from us also.\n         rustrt::rust_set_task_local_data(\n-            task, unsafe::reinterpret_cast(&map));\n+            task, cast::reinterpret_cast(&map));\n         rustrt::rust_task_local_data_atexit(task, cleanup_task_local_map);\n         // Also need to reference it an extra time to keep it for now.\n-        unsafe::bump_box_refcount(map);\n+        cast::bump_box_refcount(map);\n         map\n     } else {\n-        let map = unsafe::transmute(move map_ptr);\n-        unsafe::bump_box_refcount(map);\n+        let map = cast::transmute(move map_ptr);\n+        cast::bump_box_refcount(map);\n         map\n     }\n }\n@@ -1515,7 +1515,7 @@ unsafe fn key_to_key_value<T: Owned>(\n \n     // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n     // Use reintepret_cast -- transmute would leak (forget) the closure.\n-    let pair: (*libc::c_void, *libc::c_void) = unsafe::reinterpret_cast(&key);\n+    let pair: (*libc::c_void, *libc::c_void) = cast::reinterpret_cast(&key);\n     pair.first()\n }\n \n@@ -1550,8 +1550,8 @@ unsafe fn local_get_helper<T: Owned>(\n         // overwriting the local_data_box we need to give an extra reference.\n         // We must also give an extra reference when not removing.\n         let (index, data_ptr) = result;\n-        let data: @T = unsafe::transmute(move data_ptr);\n-        unsafe::bump_box_refcount(data);\n+        let data: @T = cast::transmute(move data_ptr);\n+        cast::bump_box_refcount(data);\n         if do_pop {\n             (*map).set_elt(index, None);\n         }\n@@ -1584,7 +1584,7 @@ unsafe fn local_set<T: Owned>(\n     // own on it can be dropped when the box is destroyed. The unsafe pointer\n     // does not have a reference associated with it, so it may become invalid\n     // when the box is destroyed.\n-    let data_ptr = unsafe::reinterpret_cast(&data);\n+    let data_ptr = cast::reinterpret_cast(&data);\n     let data_box = data as LocalData;\n     // Construct new entry to store in the map.\n     let new_entry = Some((keyval, data_ptr, data_box));\n@@ -2232,12 +2232,12 @@ fn test_unkillable() {\n     unsafe {\n         do unkillable {\n             let p = ~0;\n-            let pp: *uint = unsafe::transmute(p);\n+            let pp: *uint = cast::transmute(p);\n \n             // If we are killed here then the box will leak\n             po.recv();\n \n-            let _p: ~int = unsafe::transmute(pp);\n+            let _p: ~int = cast::transmute(pp);\n         }\n     }\n \n@@ -2273,12 +2273,12 @@ fn test_unkillable_nested() {\n         do unkillable {\n             do unkillable {} // Here's the difference from the previous test.\n             let p = ~0;\n-            let pp: *uint = unsafe::transmute(p);\n+            let pp: *uint = cast::transmute(p);\n \n             // If we are killed here then the box will leak\n             po.recv();\n \n-            let _p: ~int = unsafe::transmute(pp);\n+            let _p: ~int = cast::transmute(pp);\n         }\n     }\n "}, {"sha": "6ee360e3e1323aab837d14a23713003f73b1adf1", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -168,7 +168,7 @@ fn reserve_at_least<T>(&v: ~[const T], n: uint) {\n #[inline(always)]\n pure fn capacity<T>(&&v: ~[const T]) -> uint {\n     unsafe {\n-        let repr: **raw::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n+        let repr: **raw::VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n         (**repr).unboxed.alloc / sys::size_of::<T>()\n     }\n }\n@@ -271,12 +271,12 @@ pure fn build_sized_opt<A>(size: Option<uint>,\n \n /// Produces a mut vector from an immutable vector.\n pure fn to_mut<T>(+v: ~[T]) -> ~[mut T] {\n-    unsafe { ::unsafe::transmute(move v) }\n+    unsafe { ::cast::transmute(move v) }\n }\n \n /// Produces an immutable vector from a mut vector.\n pure fn from_mut<T>(+v: ~[mut T]) -> ~[T] {\n-    unsafe { ::unsafe::transmute(move v) }\n+    unsafe { ::cast::transmute(move v) }\n }\n \n // Accessors\n@@ -335,7 +335,7 @@ pure fn view<T>(v: &[T], start: uint, end: uint) -> &[T] {\n     assert (end <= len(v));\n     do as_imm_buf(v) |p, _len| {\n         unsafe {\n-            ::unsafe::reinterpret_cast(\n+            ::cast::reinterpret_cast(\n                 &(ptr::offset(p, start),\n                   (end - start) * sys::size_of::<T>()))\n         }\n@@ -348,7 +348,7 @@ pure fn mut_view<T>(v: &[mut T], start: uint, end: uint) -> &[mut T] {\n     assert (end <= len(v));\n     do as_mut_buf(v) |p, _len| {\n         unsafe {\n-            ::unsafe::reinterpret_cast(\n+            ::cast::reinterpret_cast(\n                 &(ptr::mut_offset(p, start),\n                   (end - start) * sys::size_of::<T>()))\n         }\n@@ -361,7 +361,7 @@ pure fn const_view<T>(v: &[const T], start: uint, end: uint) -> &[const T] {\n     assert (end <= len(v));\n     do as_const_buf(v) |p, _len| {\n         unsafe {\n-            ::unsafe::reinterpret_cast(\n+            ::cast::reinterpret_cast(\n                 &(ptr::const_offset(p, start),\n                   (end - start) * sys::size_of::<T>()))\n         }\n@@ -564,7 +564,7 @@ fn swap_remove<T>(&v: ~[const T], index: uint) -> T {\n #[inline(always)]\n fn push<T>(&v: ~[const T], +initval: T) {\n     unsafe {\n-        let repr: **raw::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n+        let repr: **raw::VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n         let fill = (**repr).unboxed.fill;\n         if (**repr).unboxed.alloc > fill {\n             push_fast(v, move initval);\n@@ -578,7 +578,7 @@ fn push<T>(&v: ~[const T], +initval: T) {\n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n unsafe fn push_fast<T>(&v: ~[const T], +initval: T) {\n-    let repr: **raw::VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n+    let repr: **raw::VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n     let fill = (**repr).unboxed.fill;\n     (**repr).unboxed.fill += sys::size_of::<T>();\n     let p = ptr::addr_of((**repr).unboxed.data);\n@@ -1441,7 +1441,7 @@ pure fn as_imm_buf<T,U>(s: &[T], /* NB---this CANNOT be const, see below */\n \n     unsafe {\n         let v : *(*T,uint) =\n-            ::unsafe::reinterpret_cast(&ptr::addr_of(s));\n+            ::cast::reinterpret_cast(&ptr::addr_of(s));\n         let (buf,len) = *v;\n         f(buf, len / sys::size_of::<T>())\n     }\n@@ -1454,7 +1454,7 @@ pure fn as_const_buf<T,U>(s: &[const T],\n \n     unsafe {\n         let v : *(*const T,uint) =\n-            ::unsafe::reinterpret_cast(&ptr::addr_of(s));\n+            ::cast::reinterpret_cast(&ptr::addr_of(s));\n         let (buf,len) = *v;\n         f(buf, len / sys::size_of::<T>())\n     }\n@@ -1467,7 +1467,7 @@ pure fn as_mut_buf<T,U>(s: &[mut T],\n \n     unsafe {\n         let v : *(*mut T,uint) =\n-            ::unsafe::reinterpret_cast(&ptr::addr_of(s));\n+            ::cast::reinterpret_cast(&ptr::addr_of(s));\n         let (buf,len) = *v;\n         f(buf, len / sys::size_of::<T>())\n     }\n@@ -1832,7 +1832,7 @@ mod raw {\n      */\n     #[inline(always)]\n     unsafe fn set_len<T>(&&v: ~[const T], new_len: uint) {\n-        let repr: **VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n+        let repr: **VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n         (**repr).unboxed.fill = new_len * sys::size_of::<T>();\n     }\n \n@@ -1847,22 +1847,22 @@ mod raw {\n      */\n     #[inline(always)]\n     unsafe fn to_ptr<T>(v: &[T]) -> *T {\n-        let repr: **SliceRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n-        return ::unsafe::reinterpret_cast(&addr_of((**repr).data));\n+        let repr: **SliceRepr = ::cast::reinterpret_cast(&addr_of(v));\n+        return ::cast::reinterpret_cast(&addr_of((**repr).data));\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n     unsafe fn to_const_ptr<T>(v: &[const T]) -> *const T {\n-        let repr: **SliceRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n-        return ::unsafe::reinterpret_cast(&addr_of((**repr).data));\n+        let repr: **SliceRepr = ::cast::reinterpret_cast(&addr_of(v));\n+        return ::cast::reinterpret_cast(&addr_of((**repr).data));\n     }\n \n     /** see `to_ptr()` */\n     #[inline(always)]\n     unsafe fn to_mut_ptr<T>(v: &[mut T]) -> *mut T {\n-        let repr: **SliceRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n-        return ::unsafe::reinterpret_cast(&addr_of((**repr).data));\n+        let repr: **SliceRepr = ::cast::reinterpret_cast(&addr_of(v));\n+        return ::cast::reinterpret_cast(&addr_of((**repr).data));\n     }\n \n     /**\n@@ -1873,7 +1873,7 @@ mod raw {\n     unsafe fn form_slice<T,U>(p: *T, len: uint, f: fn(&& &[T]) -> U) -> U {\n         let pair = (p, len * sys::size_of::<T>());\n         let v : *(&blk/[T]) =\n-            ::unsafe::reinterpret_cast(&ptr::addr_of(pair));\n+            ::cast::reinterpret_cast(&ptr::addr_of(pair));\n         f(*v)\n     }\n "}, {"sha": "a50e897358c5b847e017f568489e16284e508b46", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -359,7 +359,7 @@ impl<T: Const Send> &RWARC<T> {\n         // Whatever region the input reference had, it will be safe to use\n         // the same region for the output reference. (The only 'unsafe' part\n         // of this cast is removing the mutability.)\n-        let new_data = unsafe { unsafe::transmute_immut(data) };\n+        let new_data = unsafe { cast::transmute_immut(data) };\n         // Downgrade ensured the token belonged to us. Just a sanity check.\n         assert ptr::ref_eq(&state.data, new_data);\n         // Produce new token\n@@ -390,7 +390,7 @@ fn unwrap_rw_arc<T: Const Send>(+arc: RWARC<T>) -> T {\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n fn borrow_rwlock<T: Const Send>(state: &r/mut RWARCInner<T>) -> &r/RWlock {\n-    unsafe { unsafe::transmute_immut(&mut state.lock) }\n+    unsafe { cast::transmute_immut(&mut state.lock) }\n }\n \n // FIXME (#3154) ice with struct/&<T> prevents these from being structs."}, {"sha": "37fdf4189c906d245e7629b1b0b61fe5f573f845", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -25,7 +25,7 @@\n export Arena, arena_with_size;\n \n use list::{List, Cons, Nil};\n-use unsafe::reinterpret_cast;\n+use cast::reinterpret_cast;\n use sys::TypeDesc;\n use libc::size_t;\n "}, {"sha": "0113634157183d6c986856b9d6ba3286b45d9c27", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -2,7 +2,7 @@\n #[forbid(deprecated_pattern)];\n //! Unsafe debugging functions for inspecting values.\n \n-use unsafe::reinterpret_cast;\n+use cast::reinterpret_cast;\n \n export debug_tydesc;\n export debug_opaque;"}, {"sha": "ae2590f9f8b37bb8946b35cb1de654d3676ef792", "filename": "src/libstd/par.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -48,7 +48,7 @@ fn map_slices<A: Copy Send, B: Copy Send>(\n                                      len * sys::size_of::<A>());\n                         log(info, fmt!(\"pre-slice: %?\", (base, slice)));\n                         let slice : &[A] =\n-                            unsafe::reinterpret_cast(&slice);\n+                            cast::reinterpret_cast(&slice);\n                         log(info, fmt!(\"slice: %?\",\n                                        (base, vec::len(slice), end - base)));\n                         assert(vec::len(slice) == end - base);"}, {"sha": "30698b8db6788892455407314eea4011a6ae496b", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -807,18 +807,18 @@ mod node {\n               option::Some(x) => {\n                 //FIXME (#2744): Replace with memcpy or something similar\n                 let mut local_buf: ~[u8] =\n-                    unsafe::reinterpret_cast(&*x.content);\n+                    cast::reinterpret_cast(&*x.content);\n                 let mut i = x.byte_offset;\n                 while i < x.byte_len {\n                     buf[offset] = local_buf[i];\n                     offset += 1u;\n                     i      += 1u;\n                 }\n-                unsafe::forget(move local_buf);\n+                cast::forget(move local_buf);\n               }\n             }\n         }\n-        return unsafe::transmute(move buf);\n+        return cast::transmute(move buf);\n     }\n \n     /**"}, {"sha": "f5528f7a79c76b851feacaf98ba27037cc779300", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -779,7 +779,7 @@ mod tests {\n         let ptr = ptr::addr_of(*sharedstate);\n         do task::spawn {\n             let sharedstate: &mut int =\n-                unsafe { unsafe::reinterpret_cast(&ptr) };\n+                unsafe { cast::reinterpret_cast(&ptr) };\n             access_shared(sharedstate, m2, 10);\n             c.send(());\n \n@@ -1051,7 +1051,7 @@ mod tests {\n         let ptr = ptr::addr_of(*sharedstate);\n         do task::spawn {\n             let sharedstate: &mut int =\n-                unsafe { unsafe::reinterpret_cast(&ptr) };\n+                unsafe { cast::reinterpret_cast(&ptr) };\n             access_shared(sharedstate, x2, mode1, 10);\n             c.send(());\n         }"}, {"sha": "15b025420db33dbd36282127523a8cda1d490af7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -34,7 +34,7 @@ type spanned<T> = {node: T, span: span};\n /* can't import macros yet, so this is copied from token.rs. See its comment\n  * there. */\n macro_rules! interner_key (\n-    () => (unsafe::transmute::<(uint, uint), &fn(+@@token::ident_interner)>(\n+    () => (cast::transmute::<(uint, uint), &fn(+@@token::ident_interner)>(\n         (-3 as uint, 0u)))\n )\n "}, {"sha": "98a4d97d8d5dcbb52429015f96a39f61ddb7a504", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -330,7 +330,7 @@ type ident_interner = util::interner::interner<@~str>;\n  * so we have to use a unique number. See taskgroup_key! in task.rs\n  * for another case of this. */\n macro_rules! interner_key (\n-    () => (unsafe::transmute::<(uint, uint), &fn(+@@token::ident_interner)>(\n+    () => (cast::transmute::<(uint, uint), &fn(+@@token::ident_interner)>(\n         (-3 as uint, 0u)))\n )\n "}, {"sha": "b9283745107ca25343eb3053aba340e2ac4ac201", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -96,7 +96,7 @@ mod jit {\n                 code: ptr,\n                 env: ptr::null()\n             };\n-            let func: fn(~[~str]) = unsafe::transmute(move closure);\n+            let func: fn(~[~str]) = cast::transmute(move closure);\n \n             func(~[sess.opts.binary]);\n         }"}, {"sha": "592fb5bdf49b64e1eb46c929e67211be2706db11", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -187,7 +187,7 @@ fn get_metadata_section(os: os,\n             let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n             let mut found = None;\n             unsafe {\n-                let cvbuf: *u8 = unsafe::reinterpret_cast(&cbuf);\n+                let cvbuf: *u8 = cast::reinterpret_cast(&cbuf);\n                 let vlen = vec::len(encoder::metadata_encoding_version);\n                 debug!(\"checking %u bytes of metadata-version stamp\",\n                        vlen);"}, {"sha": "acf0fcef966b58197dce6ed475823cb8daf0c407", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -134,7 +134,7 @@ fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n // lot more efficient) than doing str::as_c_str(\"\", ...) every time.\n fn noname() -> *libc::c_char unsafe {\n     const cnull: uint = 0u;\n-    return unsafe::reinterpret_cast(&ptr::addr_of(cnull));\n+    return cast::reinterpret_cast(&ptr::addr_of(cnull));\n }\n \n fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n@@ -629,8 +629,8 @@ fn Phi(cx: block, Ty: TypeRef, vals: ~[ValueRef], bbs: ~[BasicBlockRef])\n fn AddIncomingToPhi(phi: ValueRef, val: ValueRef, bb: BasicBlockRef) {\n     if llvm::LLVMIsUndef(phi) == lib::llvm::True { return; }\n     unsafe {\n-        let valptr = unsafe::reinterpret_cast(&ptr::addr_of(val));\n-        let bbptr = unsafe::reinterpret_cast(&ptr::addr_of(bb));\n+        let valptr = cast::reinterpret_cast(&ptr::addr_of(val));\n+        let bbptr = cast::reinterpret_cast(&ptr::addr_of(bb));\n         llvm::LLVMAddIncoming(phi, valptr, bbptr, 1 as c_uint);\n     }\n }"}, {"sha": "e625677266609fc09ac8fae77b89eec39b24618e", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -1075,13 +1075,13 @@ fn C_array(ty: TypeRef, elts: ~[ValueRef]) -> ValueRef unsafe {\n \n fn C_bytes(bytes: ~[u8]) -> ValueRef unsafe {\n     return llvm::LLVMConstString(\n-        unsafe::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n+        cast::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n         bytes.len() as c_uint, True);\n }\n \n fn C_bytes_plus_null(bytes: ~[u8]) -> ValueRef unsafe {\n     return llvm::LLVMConstString(\n-        unsafe::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n+        cast::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n         bytes.len() as c_uint, False);\n }\n "}, {"sha": "52b843b3fbea2234647f5daeaac2b8ff97e8b121", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -73,7 +73,7 @@ fn llunused() -> ValueRef {\n     lli32(0x0)\n }\n fn llnull() -> ValueRef unsafe {\n-    unsafe::reinterpret_cast(&ptr::null::<ValueRef>())\n+    cast::reinterpret_cast(&ptr::null::<ValueRef>())\n }\n \n fn add_named_metadata(cx: @crate_ctxt, name: ~str, val: ValueRef) {\n@@ -131,7 +131,7 @@ enum debug_metadata {\n \n fn cast_safely<T: Copy, U>(val: T) -> U unsafe {\n     let val2 = val;\n-    return unsafe::transmute(move val2);\n+    return cast::transmute(move val2);\n }\n \n fn md_from_metadata<T>(val: debug_metadata) -> T unsafe {"}, {"sha": "7932474a698af556f1b1cbea5a94c6f6ed3eb3bc", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -382,9 +382,9 @@ enum t_opaque {}\n type t = *t_opaque;\n \n pure fn get(t: t) -> t_box unsafe {\n-    let t2 = unsafe::reinterpret_cast::<t, t_box>(&t);\n+    let t2 = cast::reinterpret_cast::<t, t_box>(&t);\n     let t3 = t2;\n-    unsafe::forget(move t2);\n+    cast::forget(move t2);\n     t3\n }\n \n@@ -886,7 +886,7 @@ fn mk_t(cx: ctxt, +st: sty) -> t { mk_t_with_id(cx, st, None) }\n fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n     let key = {sty: st, o_def_id: o_def_id};\n     match cx.interner.find(key) {\n-      Some(t) => unsafe { return unsafe::reinterpret_cast(&t); },\n+      Some(t) => unsafe { return cast::reinterpret_cast(&t); },\n       _ => ()\n     }\n     let mut flags = 0u;\n@@ -944,7 +944,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n     let t = @{sty: st, id: cx.next_id, flags: flags, o_def_id: o_def_id};\n     cx.interner.insert(key, t);\n     cx.next_id += 1u;\n-    unsafe { unsafe::reinterpret_cast(&t) }\n+    unsafe { cast::reinterpret_cast(&t) }\n }\n \n fn mk_nil(cx: ctxt) -> t { mk_t(cx, ty_nil) }"}, {"sha": "74a89300eb3c0a2a8d09b7e2e70092b0787a7e1b", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -9,7 +9,7 @@ export from_srv, extract, to_str, interner;\n /* can't import macros yet, so this is copied from token.rs. See its comment\n  * there. */\n macro_rules! interner_key (\n-    () => (unsafe::transmute::<(uint, uint),\n+    () => (cast::transmute::<(uint, uint),\n            &fn(+@@syntax::parse::token::ident_interner)>((-3 as uint, 0u)))\n )\n "}, {"sha": "0bea0f934f400f95a2f4836e9857b0a44e6a58db", "filename": "src/test/run-fail/unwind-box-res.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-fail%2Funwind-box-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-box-res.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -7,7 +7,7 @@ fn failfn() {\n struct r {\n   v: *int,\n   drop unsafe {\n-    let _v2: ~int = unsafe::reinterpret_cast(&self.v);\n+    let _v2: ~int = cast::reinterpret_cast(&self.v);\n   }\n }\n \n@@ -19,8 +19,8 @@ fn r(v: *int) -> r {\n \n fn main() unsafe {\n     let i1 = ~0;\n-    let i1p = unsafe::reinterpret_cast(&i1);\n-    unsafe::forget(i1);\n+    let i1p = cast::reinterpret_cast(&i1);\n+    cast::forget(i1);\n     let x = @r(i1p);\n     failfn();\n     log(error, x);"}, {"sha": "55e104b3fa2cad2c8518642baf6442e31b831e64", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -1,7 +1,7 @@\n // Binop corner cases\n \n extern mod std;\n-use unsafe::reinterpret_cast;\n+use cast::reinterpret_cast;\n \n fn test_nil() {\n     assert (() == ());\n@@ -56,9 +56,9 @@ fn test_box() {\n }\n \n fn test_ptr() unsafe {\n-    let p1: *u8 = unsafe::reinterpret_cast(&0);\n-    let p2: *u8 = unsafe::reinterpret_cast(&0);\n-    let p3: *u8 = unsafe::reinterpret_cast(&1);\n+    let p1: *u8 = cast::reinterpret_cast(&0);\n+    let p2: *u8 = cast::reinterpret_cast(&0);\n+    let p3: *u8 = cast::reinterpret_cast(&1);\n \n     assert p1 == p2;\n     assert p1 != p3;\n@@ -102,8 +102,8 @@ fn test_class() {\n   \n   unsafe {\n   error!(\"q = %x, r = %x\",\n-         (unsafe::reinterpret_cast::<*p, uint>(&ptr::addr_of(q))),\n-         (unsafe::reinterpret_cast::<*p, uint>(&ptr::addr_of(r))));\n+         (cast::reinterpret_cast::<*p, uint>(&ptr::addr_of(q))),\n+         (cast::reinterpret_cast::<*p, uint>(&ptr::addr_of(r))));\n   }\n   assert(q == r);\n   r.y = 17;"}, {"sha": "768a828d7a236db6431045a61e114d3d452f0298", "filename": "src/test/run-pass/box-annihilator-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fbox-annihilator-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fbox-annihilator-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-annihilator-shared.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -5,7 +5,7 @@ extern mod rustrt {\n fn main() {\n     unsafe {\n         let x = @3;\n-        let p: *uint = unsafe::transmute(x);\n+        let p: *uint = cast::transmute(x);\n         rustrt::rust_annihilate_box(p);\n     }\n }"}, {"sha": "a01240b01f4fda11891a3663076d4850d34fcf29", "filename": "src/test/run-pass/box-annihilator-unique-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fbox-annihilator-unique-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fbox-annihilator-unique-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-annihilator-unique-vec.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -5,7 +5,7 @@ extern mod rustrt {\n fn main() {\n     unsafe {\n         let x = ~[~\"a\", ~\"b\", ~\"c\"];\n-        let p: *uint = unsafe::transmute(x);\n+        let p: *uint = cast::transmute(x);\n         rustrt::rust_annihilate_box(p);\n     }\n }"}, {"sha": "0198b5b164666963dcbefaab60dedc46fbc16e3b", "filename": "src/test/run-pass/box-annihilator-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fbox-annihilator-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fbox-annihilator-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-annihilator-unique.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -5,7 +5,7 @@ extern mod rustrt {\n fn main() {\n     unsafe {\n         let x = ~3;\n-        let p: *uint = unsafe::transmute(x);\n+        let p: *uint = cast::transmute(x);\n         rustrt::rust_annihilate_box(p);\n     }\n }"}, {"sha": "82678c1c0812f5356918358f0d05546cf3c4b393", "filename": "src/test/run-pass/issue-2214.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fissue-2214.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2214.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -2,7 +2,7 @@ use libc::{c_double, c_int};\n use f64::*;\n \n fn to_c_int(v: &mut int) -> &mut c_int unsafe {\n-    unsafe::reinterpret_cast(&v)\n+    cast::reinterpret_cast(&v)\n }\n \n fn lgamma(n: c_double, value: &mut int) -> c_double {"}, {"sha": "fbae44bf3279cca1290d2ede41dca1ec2054db6c", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -1,5 +1,5 @@\n mod pipes {\n-    use unsafe::{forget, transmute};\n+    use cast::{forget, transmute};\n \n     enum state {\n         empty,\n@@ -22,7 +22,7 @@ mod pipes {\n     };\n \n     fn packet<T: Send>() -> *packet<T> unsafe {\n-        let p: *packet<T> = unsafe::transmute(~{\n+        let p: *packet<T> = cast::transmute(~{\n             mut state: empty,\n             mut blocked_task: None::<task::Task>,\n             mut payload: None::<T>\n@@ -40,7 +40,7 @@ mod pipes {\n     // We should consider moving this to core::unsafe, although I\n     // suspect graydon would want us to use void pointers instead.\n     unsafe fn uniquify<T>(+x: *T) -> ~T {\n-        unsafe { unsafe::transmute(x) }\n+        unsafe { cast::transmute(x) }\n     }\n \n     fn swap_state_acq(+dst: &mut state, src: state) -> state {\n@@ -198,19 +198,19 @@ mod pingpong {\n \n     fn liberate_ping(-p: ping) -> pipes::send_packet<pong> unsafe {\n         let addr : *pipes::send_packet<pong> = match p {\n-          ping(x) => { unsafe::transmute(ptr::addr_of(x)) }\n+          ping(x) => { cast::transmute(ptr::addr_of(x)) }\n         };\n         let liberated_value <- *addr;\n-        unsafe::forget(p);\n+        cast::forget(p);\n         liberated_value\n     }\n \n     fn liberate_pong(-p: pong) -> pipes::send_packet<ping> unsafe {\n         let addr : *pipes::send_packet<ping> = match p {\n-          pong(x) => { unsafe::transmute(ptr::addr_of(x)) }\n+          pong(x) => { cast::transmute(ptr::addr_of(x)) }\n         };\n         let liberated_value <- *addr;\n-        unsafe::forget(p);\n+        cast::forget(p);\n         liberated_value\n     }\n "}, {"sha": "81f47c96d16945560aba82d57ecd1c591aaf9e29", "filename": "src/test/run-pass/regions-mock-trans-impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans-impls.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -1,5 +1,5 @@\n extern mod std;\n-use libc, sys, unsafe;\n+use libc, sys, cast;\n use std::arena::Arena;\n \n type bcx = {"}, {"sha": "ee8f439f708164c799673cc58ff1ed3f38710001", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -1,4 +1,4 @@\n-use libc, sys, unsafe;\n+use libc, sys, cast;\n \n enum arena = ();\n \n@@ -16,7 +16,7 @@ type ccx = {\n };\n \n fn alloc(_bcx : &arena) -> &bcx unsafe {\n-    return unsafe::reinterpret_cast(\n+    return cast::reinterpret_cast(\n         &libc::malloc(sys::size_of::<bcx/&blk>() as libc::size_t));\n }\n \n@@ -28,7 +28,7 @@ fn g(fcx : &fcx) {\n     let bcx = { fcx: fcx };\n     let bcx2 = h(&bcx);\n     unsafe {\n-        libc::free(unsafe::reinterpret_cast(&bcx2));\n+        libc::free(cast::reinterpret_cast(&bcx2));\n     }\n }\n "}, {"sha": "9e0a2c35e2f06d3d957a89f941155c1cc48b0b69", "filename": "src/test/run-pass/resource-cycle.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fresource-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -4,10 +4,10 @@ struct r {\n   v: *int,\n   drop unsafe {\n     debug!(\"r's dtor: self = %x, self.v = %x, self.v's value = %x\",\n-           unsafe::reinterpret_cast::<*r, uint>(&ptr::addr_of(self)),\n-           unsafe::reinterpret_cast::<**int, uint>(&ptr::addr_of(self.v)),\n-           unsafe::reinterpret_cast::<*int, uint>(&self.v));\n-    let v2: ~int = unsafe::reinterpret_cast(&self.v); }\n+           cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(self)),\n+           cast::reinterpret_cast::<**int, uint>(&ptr::addr_of(self.v)),\n+           cast::reinterpret_cast::<*int, uint>(&self.v));\n+    let v2: ~int = cast::reinterpret_cast(&self.v); }\n }\n \n fn r(v: *int) -> r unsafe {\n@@ -23,38 +23,38 @@ enum t = {\n \n fn main() unsafe {\n     let i1 = ~0;\n-    let i1p = unsafe::reinterpret_cast(&i1);\n-    unsafe::forget(i1);\n+    let i1p = cast::reinterpret_cast(&i1);\n+    cast::forget(i1);\n     let i2 = ~0;\n-    let i2p = unsafe::reinterpret_cast(&i2);\n-    unsafe::forget(i2);\n+    let i2p = cast::reinterpret_cast(&i2);\n+    cast::forget(i2);\n \n     let x1 = @t({\n         mut next: None,\n           r: {\n           let rs = r(i1p);\n           debug!(\"r = %x\",\n-                 unsafe::reinterpret_cast::<*r, uint>(&ptr::addr_of(rs)));\n+                 cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(rs)));\n           rs }\n     });\n     \n     debug!(\"x1 = %x, x1.r = %x\",\n-        unsafe::reinterpret_cast::<@t, uint>(&x1),\n-        unsafe::reinterpret_cast::<*r, uint>(&ptr::addr_of(x1.r)));\n+        cast::reinterpret_cast::<@t, uint>(&x1),\n+        cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(x1.r)));\n \n     let x2 = @t({\n         mut next: None,\n           r: {\n           let rs = r(i2p);\n           debug!(\"r2 = %x\",\n-                 unsafe::reinterpret_cast::<*r, uint>(&ptr::addr_of(rs)));\n+                 cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(rs)));\n           rs\n             }\n     });\n     \n     debug!(\"x2 = %x, x2.r = %x\",\n-           unsafe::reinterpret_cast::<@t, uint>(&x2),\n-           unsafe::reinterpret_cast::<*r, uint>(&ptr::addr_of(x2.r)));\n+           cast::reinterpret_cast::<@t, uint>(&x2),\n+           cast::reinterpret_cast::<*r, uint>(&ptr::addr_of(x2.r)));\n \n     x1.next = Some(x2);\n     x2.next = Some(x1);"}, {"sha": "b522808c4947c2d4427db239d8f0be097a13ac7d", "filename": "src/test/run-pass/resource-cycle2.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle2.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -9,7 +9,7 @@ type u = {\n struct r {\n   v: u,\n   drop unsafe {\n-    let v2: ~int = unsafe::reinterpret_cast(&self.v.c);\n+    let v2: ~int = cast::reinterpret_cast(&self.v.c);\n   }\n }\n \n@@ -26,11 +26,11 @@ enum t = {\n \n fn main() unsafe {\n     let i1 = ~0xA;\n-    let i1p = unsafe::reinterpret_cast(&i1);\n-    unsafe::forget(i1);\n+    let i1p = cast::reinterpret_cast(&i1);\n+    cast::forget(i1);\n     let i2 = ~0xA;\n-    let i2p = unsafe::reinterpret_cast(&i2);\n-    unsafe::forget(i2);\n+    let i2p = cast::reinterpret_cast(&i2);\n+    cast::forget(i2);\n \n     let u1 = {a: 0xB, b: 0xC, c: i1p};\n     let u2 = {a: 0xB, b: 0xC, c: i2p};"}, {"sha": "efb1915799c315b16aafd5f56ee097792d263ea7", "filename": "src/test/run-pass/resource-cycle3.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-cycle3.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -13,7 +13,7 @@ struct r {\n   w: int,\n   x: *int,\n   drop unsafe {\n-    let _v2: ~int = unsafe::reinterpret_cast(&self.v.c);\n+    let _v2: ~int = cast::reinterpret_cast(&self.v.c);\n     // let _v3: ~int = unsafe::reinterpret_cast(self.x);\n   }\n }\n@@ -22,7 +22,7 @@ fn r(v: u, w: int, _x: *int) -> r unsafe {\n     r {\n         v: v,\n         w: w,\n-        x: unsafe::reinterpret_cast(&0)\n+        x: cast::reinterpret_cast(&0)\n     }\n }\n \n@@ -33,11 +33,11 @@ enum t = {\n \n fn main() unsafe {\n     let i1 = ~0xA;\n-    let i1p = unsafe::reinterpret_cast(&i1);\n-    unsafe::forget(i1);\n+    let i1p = cast::reinterpret_cast(&i1);\n+    cast::forget(i1);\n     let i2 = ~0xA;\n-    let i2p = unsafe::reinterpret_cast(&i2);\n-    unsafe::forget(i2);\n+    let i2p = cast::reinterpret_cast(&i2);\n+    cast::forget(i2);\n \n     let u1 = {a: 0xB, b: 0xC, c: i1p};\n     let u2 = {a: 0xB, b: 0xC, c: i2p};"}, {"sha": "b96fd5edd921018ac9b88c1a4e04bb43938b0917", "filename": "src/test/run-pass/rt-sched-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-sched-1.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -32,8 +32,8 @@ fn main() unsafe {\n         assert child_sched_id == new_sched_id;\n         comm::send(ch, ());\n     };\n-    let fptr = unsafe::reinterpret_cast(&ptr::addr_of(f));\n+    let fptr = cast::reinterpret_cast(&ptr::addr_of(f));\n     rustrt::start_task(new_task_id, fptr);\n-    unsafe::forget(f);\n+    cast::forget(f);\n     comm::recv(po);\n }"}, {"sha": "0a9c9e11ef56c2bd55c930e3fafd0f85551251da", "filename": "src/test/run-pass/unify-return-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2906f2de31d3a4709a2e028c5cefe3274df1edd2/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funify-return-ty.rs?ref=2906f2de31d3a4709a2e028c5cefe3274df1edd2", "patch": "@@ -3,6 +3,6 @@\n // in that type gets resolved.\n extern mod std;\n \n-fn null<T>() -> *T unsafe { unsafe::reinterpret_cast(&0) }\n+fn null<T>() -> *T unsafe { cast::reinterpret_cast(&0) }\n \n fn main() { null::<int>(); }"}]}