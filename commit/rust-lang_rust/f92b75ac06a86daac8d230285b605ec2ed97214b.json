{"sha": "f92b75ac06a86daac8d230285b605ec2ed97214b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MmI3NWFjMDZhODZkYWFjOGQyMzAyODViNjA1ZWMyZWQ5NzIxNGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-11T20:28:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-11T20:28:38Z"}, "message": "auto merge of #7707 : thestinger/rust/double, r=cmr\n\n00da76d r=cmr\r\n6e75f2d r=cmr\r\n\r\nThis implements the trait for vector iterators, replacing the reverse\r\niterator types. The methods will stay, for implementing the future\r\nreverse Iterable traits and convenience.\r\n\r\nThis can also be trivially implemented for circular buffers and other\r\nvariants of arrays like strings.\r\n\r\nThe `DoubleEndedIterator` trait will allow for implementing algorithms\r\nlike in-place reverse on generic mutable iterators.\r\n\r\nThe naming (`Range` vs. `Iterator`, `Bidirectional` vs. `DoubleEnded`)\r\ncan be bikeshedded in the future.", "tree": {"sha": "876947b173e4c516d2498ad3c53b74eaacfbda6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/876947b173e4c516d2498ad3c53b74eaacfbda6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f92b75ac06a86daac8d230285b605ec2ed97214b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f92b75ac06a86daac8d230285b605ec2ed97214b", "html_url": "https://github.com/rust-lang/rust/commit/f92b75ac06a86daac8d230285b605ec2ed97214b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f92b75ac06a86daac8d230285b605ec2ed97214b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fce8c918ab90aeb1a2932d330396884cf847e9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fce8c918ab90aeb1a2932d330396884cf847e9f", "html_url": "https://github.com/rust-lang/rust/commit/9fce8c918ab90aeb1a2932d330396884cf847e9f"}, {"sha": "6e75f2de9c40e4107069a68c2a7b0cc7dae2b078", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e75f2de9c40e4107069a68c2a7b0cc7dae2b078", "html_url": "https://github.com/rust-lang/rust/commit/6e75f2de9c40e4107069a68c2a7b0cc7dae2b078"}], "stats": {"total": 182, "additions": 119, "deletions": 63}, "files": [{"sha": "063b1152cb2c6d367aef6e60abd542ccbb2df0d7", "filename": "src/etc/vim/ftplugin/rust.vim", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f92b75ac06a86daac8d230285b605ec2ed97214b/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/f92b75ac06a86daac8d230285b605ec2ed97214b/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim?ref=f92b75ac06a86daac8d230285b605ec2ed97214b", "patch": "@@ -1,14 +1,25 @@\n \" Vim syntax file\n \" Language:     Rust\n \" Maintainer:   Chris Morgan <me@chrismorgan.info>\n-\" Last Change:  2013 Jul 6\n+\" Last Change:  2013 Jul 10\n \n if exists(\"b:did_ftplugin\")\n \tfinish\n endif\n let b:did_ftplugin = 1\n \n-setlocal comments=s1:/*,mb:*,ex:*/,:///,://!,://\n+\" The rust source code at present seems to typically omit a leader on /*!\n+\" comments, so we'll use that as our default, but make it easy to switch.\n+\" This does not affect indentation at all (I tested it with and without\n+\" leader), merely whether a leader is inserted by default or not.\n+if exists(\"g:rust_bang_comment_leader\") && g:rust_bang_comment_leader == 1\n+\t\" Why is the `,s0:/*,mb:\\ ,ex:*/` there, you ask? I don't understand why,\n+\t\" but without it, */ gets indented one space even if there were no\n+\t\" leaders. I'm fairly sure that's a Vim bug.\n+\tsetlocal comments=s1:/*,mb:*,ex:*/,s0:/*,mb:\\ ,ex:*/,:///,://!,://\n+else\n+\tsetlocal comments=s0:/*!,m:\\ ,ex:*/,s1:/*,mb:*,ex:*/,:///,://!,://\n+endif\n setlocal commentstring=//%s\n setlocal formatoptions-=t formatoptions+=croqnlj\n "}, {"sha": "ae3ca403aedd8b0f0a5736c386debe876b3c5fee", "filename": "src/etc/vim/indent/rust.vim", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f92b75ac06a86daac8d230285b605ec2ed97214b/src%2Fetc%2Fvim%2Findent%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/f92b75ac06a86daac8d230285b605ec2ed97214b/src%2Fetc%2Fvim%2Findent%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Findent%2Frust.vim?ref=f92b75ac06a86daac8d230285b605ec2ed97214b", "patch": "@@ -10,7 +10,7 @@ endif\n let b:did_indent = 1\n \n setlocal cindent\n-setlocal cinoptions=L0,(0,Ws,JN\n+setlocal cinoptions=L0,(0,Ws,JN,j1\n setlocal cinkeys=0{,0},!^F,o,O,0[,0]\n \" Don't think cinwords will actually do anything at all... never mind\n setlocal cinwords=do,for,if,else,while,loop,impl,mod,unsafe,trait,struct,enum,fn,extern\n@@ -66,12 +66,23 @@ function GetRustIndent(lnum)\n \t\" Starting assumption: cindent (called at the end) will do it right\n \t\" normally. We just want to fix up a few cases.\n \n+\tlet line = getline(a:lnum)\n+\n \tif has('syntax_items')\n-\t\tif synIDattr(synID(a:lnum, 1, 1), \"name\") == \"rustString\"\n+\t\tlet synname = synIDattr(synID(a:lnum, 1, 1), \"name\")\n+\t\tif synname == \"rustString\"\n \t\t\t\" If the start of the line is in a string, don't change the indent\n \t\t\treturn -1\n-\t\telseif synIDattr(synID(a:lnum, 1, 1), \"name\") =~ \"\\\\(Comment\\\\|Todo\\\\)\"\n-\t\t\t\t\t\\ && getline(a:lnum) !~ \"^\\\\s*/\\\\*\"\n+\t\telseif synname =~ \"\\\\(Comment\\\\|Todo\\\\)\"\n+\t\t\t\t\t\\ && line !~ \"^\\\\s*/\\\\*\"  \" not /* opening line\n+\t\t\tif synname =~ \"CommentML\" \" multi-line\n+\t\t\t\tif line !~ \"^\\\\s*\\\\*\" && getline(a:lnum - 1) =~ \"^\\\\s*/\\\\*\"\n+\t\t\t\t\t\" This is (hopefully) the line after a /*, and it has no\n+\t\t\t\t\t\" leader, so the correct indentation is that of the\n+\t\t\t\t\t\" previous line.\n+\t\t\t\t\treturn GetRustIndent(a:lnum - 1)\n+\t\t\t\tendif\n+\t\t\tendif\n \t\t\t\" If it's in a comment, let cindent take care of it now. This is\n \t\t\t\" for cases like \"/*\" where the next line should start \" * \", not\n \t\t\t\" \"* \" as the code below would otherwise cause for module scope\n@@ -114,7 +125,6 @@ function GetRustIndent(lnum)\n \t\" start with these two main cases (square brackets and not returning to\n \t\" column zero)\n \n-\tlet line = getline(a:lnum)\n \tcall cursor(a:lnum, 1)\n \tif searchpair('{\\|(', '', '}\\|)', 'nbW') == 0\n \t\tif searchpair('\\[', '', '\\]', 'nbW') == 0"}, {"sha": "3f654ea903063f2dd1e07e63f8de9d551d50ba60", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f92b75ac06a86daac8d230285b605ec2ed97214b/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/f92b75ac06a86daac8d230285b605ec2ed97214b/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=f92b75ac06a86daac8d230285b605ec2ed97214b", "patch": "@@ -117,9 +117,9 @@ syn match     rustFloat       display \"\\<[0-9][0-9_]*\\.[0-9_]\\+\\%([eE][+-]\\=[0-9\n syn match     rustLifetime    display \"\\'\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\"\n syn match   rustCharacter   \"'\\([^'\\\\]\\|\\\\\\(['nrt\\\\\\\"]\\|x\\x\\{2}\\|u\\x\\{4}\\|U\\x\\{8}\\)\\)'\"\n \n-syn region    rustComment     start=\"/\\*\" end=\"\\*/\" contains=rustTodo\n+syn region    rustCommentML   start=\"/\\*\" end=\"\\*/\" contains=rustTodo\n syn region    rustComment     start=\"//\" skip=\"\\\\$\" end=\"$\" contains=rustTodo keepend\n-syn region    rustCommentDoc  start=\"/\\*\\%(!\\|\\*/\\@!\\)\" end=\"\\*/\" contains=rustTodo\n+syn region    rustCommentMLDoc start=\"/\\*\\%(!\\|\\*/\\@!\\)\" end=\"\\*/\" contains=rustTodo\n syn region    rustCommentDoc  start=\"//[/!]\" skip=\"\\\\$\" end=\"$\" contains=rustTodo keepend\n \n syn keyword rustTodo contained TODO FIXME XXX NB NOTE\n@@ -151,7 +151,9 @@ hi def link rustModPath       Include\n hi def link rustModPathSep    Delimiter\n hi def link rustFuncName      Function\n hi def link rustFuncCall      Function\n+hi def link rustCommentMLDoc  rustCommentDoc\n hi def link rustCommentDoc    SpecialComment\n+hi def link rustCommentML     rustComment\n hi def link rustComment       Comment\n hi def link rustAssert        PreCondit\n hi def link rustFail          PreCondit"}, {"sha": "a17fea24b2c23beefe42618bc3e6f868a479aee6", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f92b75ac06a86daac8d230285b605ec2ed97214b/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92b75ac06a86daac8d230285b605ec2ed97214b/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=f92b75ac06a86daac8d230285b605ec2ed97214b", "patch": "@@ -47,6 +47,49 @@ pub trait Iterator<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n }\n \n+/// A range iterator able to yield elements from both ends\n+pub trait DoubleEndedIterator<A>: Iterator<A> {\n+    /// Yield an element from the end of the range, returning `None` if the range is empty.\n+    fn next_back(&mut self) -> Option<A>;\n+}\n+\n+/// Iterator adaptors provided for every `DoubleEndedIterator` implementation.\n+///\n+/// In the future these will be default methods instead of a utility trait.\n+pub trait DoubleEndedIteratorUtil<A> {\n+    /// Flip the direction of the iterator\n+    fn invert(self) -> InvertIterator<A, Self>;\n+}\n+\n+/// Iterator adaptors provided for every `DoubleEndedIterator` implementation.\n+///\n+/// In the future these will be default methods instead of a utility trait.\n+impl<A, T: DoubleEndedIterator<A>> DoubleEndedIteratorUtil<A> for T {\n+    /// Flip the direction of the iterator\n+    #[inline]\n+    fn invert(self) -> InvertIterator<A, T> {\n+        InvertIterator{iter: self}\n+    }\n+}\n+\n+/// An double-ended iterator with the direction inverted\n+// FIXME #6967: Dummy A parameter to get around type inference bug\n+pub struct InvertIterator<A, T> {\n+    priv iter: T\n+}\n+\n+impl<A, T: DoubleEndedIterator<A>> Iterator<A> for InvertIterator<A, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> { self.iter.next_back() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<A, T: Iterator<A>> DoubleEndedIterator<A> for InvertIterator<A, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> { self.iter.next() }\n+}\n+\n /// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n /// implementations of the `Iterator` trait.\n ///\n@@ -1474,4 +1517,13 @@ mod tests {\n         let xs = [-3, 0, 1, 5, -10];\n         assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     }\n+\n+    #[test]\n+    fn test_invert() {\n+        let xs = [2, 4, 6, 8, 10, 12, 14, 16];\n+        let mut it = xs.iter();\n+        it.next();\n+        it.next();\n+        assert_eq!(it.invert().transform(|&x| x).collect::<~[int]>(), ~[16, 14, 12, 10, 8, 6]);\n+    }\n }"}, {"sha": "89c4b39c4293e2e518bc886da739e18a9a921ae0", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 35, "deletions": 54, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f92b75ac06a86daac8d230285b605ec2ed97214b/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f92b75ac06a86daac8d230285b605ec2ed97214b/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=f92b75ac06a86daac8d230285b605ec2ed97214b", "patch": "@@ -18,7 +18,7 @@ use container::{Container, Mutable};\n use cmp;\n use cmp::{Eq, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use clone::Clone;\n-use iterator::{FromIterator, Iterator, IteratorUtil};\n+use iterator::*;\n use kinds::Copy;\n use libc::c_void;\n use num::Zero;\n@@ -762,12 +762,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n     #[inline]\n     fn rev_iter(self) -> VecRevIterator<'self, T> {\n-        unsafe {\n-            let p = vec::raw::to_ptr(self);\n-            VecRevIterator{ptr: p.offset(self.len() - 1),\n-                           end: p.offset(-1),\n-                           lifetime: cast::transmute(p)}\n-        }\n+        self.iter().invert()\n     }\n \n     /// Returns an iterator over the subslices of the vector which are\n@@ -1143,7 +1138,6 @@ impl<T> OwnedVector<T> for ~[T] {\n      *\n      * * n - The number of elements to reserve space for\n      */\n-    #[inline]\n     #[cfg(stage0)]\n     fn reserve(&mut self, n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n@@ -1177,7 +1171,6 @@ impl<T> OwnedVector<T> for ~[T] {\n      *\n      * * n - The number of elements to reserve space for\n      */\n-    #[inline]\n     #[cfg(not(stage0))]\n     fn reserve(&mut self, n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n@@ -1235,21 +1228,12 @@ impl<T> OwnedVector<T> for ~[T] {\n             let repr: **raw::VecRepr = transmute(&mut *self);\n             let fill = (**repr).unboxed.fill;\n             if (**repr).unboxed.alloc <= fill {\n-                // need more space\n-                reserve_no_inline(self);\n+                let new_len = self.len() + 1;\n+                self.reserve_at_least(new_len);\n             }\n \n             self.push_fast(t);\n         }\n-\n-        // this peculiar function is because reserve_at_least is very\n-        // large (because of reserve), and will be inlined, which\n-        // makes push too large.\n-        #[inline(never)]\n-        fn reserve_no_inline<T>(v: &mut ~[T]) {\n-            let new_len = v.len() + 1;\n-            v.reserve_at_least(new_len);\n-        }\n     }\n \n     // This doesn't bother to make sure we have space.\n@@ -1737,13 +1721,9 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         }\n     }\n \n+    #[inline]\n     fn mut_rev_iter(self) -> VecMutRevIterator<'self, T> {\n-        unsafe {\n-            let p = vec::raw::to_mut_ptr(self);\n-            VecMutRevIterator{ptr: p.offset(self.len() - 1),\n-                              end: p.offset(-1),\n-                              lifetime: cast::transmute(p)}\n-        }\n+        self.mut_iter().invert()\n     }\n \n     /**\n@@ -2103,53 +2083,61 @@ macro_rules! iterator {\n             priv lifetime: $elem // FIXME: #5922\n         }\n     };*/\n-    (impl $name:ident -> $elem:ty, $step:expr) => {\n-        // could be implemented with &[T] with .slice(), but this avoids bounds checks\n+    (impl $name:ident -> $elem:ty) => {\n         impl<'self, T> Iterator<$elem> for $name<'self, T> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n+                // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n                     if self.ptr == self.end {\n                         None\n                     } else {\n                         let old = self.ptr;\n-                        self.ptr = self.ptr.offset($step);\n+                        self.ptr = self.ptr.offset(1);\n                         Some(cast::transmute(old))\n                     }\n                 }\n             }\n \n             #[inline]\n             fn size_hint(&self) -> (uint, Option<uint>) {\n-                let diff = if $step > 0 {\n-                    (self.end as uint) - (self.ptr as uint)\n-                } else {\n-                    (self.ptr as uint) - (self.end as uint)\n-                };\n+                let diff = (self.end as uint) - (self.ptr as uint);\n                 let exact = diff / size_of::<$elem>();\n                 (exact, Some(exact))\n             }\n         }\n     }\n }\n \n+macro_rules! double_ended_iterator {\n+    (impl $name:ident -> $elem:ty) => {\n+        impl<'self, T> DoubleEndedIterator<$elem> for $name<'self, T> {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$elem> {\n+                // could be implemented with slices, but this avoids bounds checks\n+                unsafe {\n+                    if self.end == self.ptr {\n+                        None\n+                    } else {\n+                        self.end = self.end.offset(-1);\n+                        Some(cast::transmute(self.end))\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n //iterator!{struct VecIterator -> *T, &'self T}\n /// An iterator for iterating over a vector.\n pub struct VecIterator<'self, T> {\n     priv ptr: *T,\n     priv end: *T,\n     priv lifetime: &'self T // FIXME: #5922\n }\n-iterator!{impl VecIterator -> &'self T, 1}\n-\n-//iterator!{struct VecRevIterator -> *T, &'self T}\n-/// An iterator for iterating over a vector in reverse.\n-pub struct VecRevIterator<'self, T> {\n-    priv ptr: *T,\n-    priv end: *T,\n-    priv lifetime: &'self T // FIXME: #5922\n-}\n-iterator!{impl VecRevIterator -> &'self T, -1}\n+iterator!{impl VecIterator -> &'self T}\n+double_ended_iterator!{impl VecIterator -> &'self T}\n+pub type VecRevIterator<'self, T> = InvertIterator<&'self T, VecIterator<'self, T>>;\n \n //iterator!{struct VecMutIterator -> *mut T, &'self mut T}\n /// An iterator for mutating the elements of a vector.\n@@ -2158,16 +2146,9 @@ pub struct VecMutIterator<'self, T> {\n     priv end: *mut T,\n     priv lifetime: &'self mut T // FIXME: #5922\n }\n-iterator!{impl VecMutIterator -> &'self mut T, 1}\n-\n-//iterator!{struct VecMutRevIterator -> *mut T, &'self mut T}\n-/// An iterator for mutating the elements of a vector in reverse.\n-pub struct VecMutRevIterator<'self, T> {\n-    priv ptr: *mut T,\n-    priv end: *mut T,\n-    priv lifetime: &'self mut T // FIXME: #5922\n-}\n-iterator!{impl VecMutRevIterator -> &'self mut T, -1}\n+iterator!{impl VecMutIterator -> &'self mut T}\n+double_ended_iterator!{impl VecMutIterator -> &'self mut T}\n+pub type VecMutRevIterator<'self, T> = InvertIterator<&'self mut T, VecMutIterator<'self, T>>;\n \n /// An iterator that moves out of a vector.\n pub struct VecConsumeIterator<T> {"}]}