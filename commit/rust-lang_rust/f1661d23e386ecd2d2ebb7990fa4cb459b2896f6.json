{"sha": "f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNjYxZDIzZTM4NmVjZDJkMmViYjc5OTBmYTRjYjQ1OWIyODk2ZjY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-30T21:08:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-30T21:08:42Z"}, "message": "Rollup merge of #72543 - estebank:opaque-missing-lts-in-fn, r=nikomatsakis\n\nAccount for missing lifetime in opaque and trait object return types\n\nWhen encountering an opaque closure return type that needs to bound a\nlifetime to the function's arguments, including borrows and type params,\nprovide appropriate suggestions that lead to working code.\n\nGet the user from\n\n```rust\nfn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\nwhere\n    G: Get<T>\n{\n    move || {\n        *dest = g.get();\n    }\n}\n```\n\nto\n\n```rust\nfn foo<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() +'a\nwhere\n    G: Get<T>\n{\n    move || {\n        *dest = g.get();\n    }\n}\n```", "tree": {"sha": "80d3c14e31f5f13ff465dc2c09cfee19ed8f7839", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80d3c14e31f5f13ff465dc2c09cfee19ed8f7839"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe0staCRBK7hj4Ov3rIwAAdHIIADziKQewSDQhDPz3eqBu8TSh\n7lBfWfkubDMIu7xoUXWXm+5R4GwdCJI40yDZQiEo7K1vEWduxXPnhd/8MDSRT/fG\nk5HEtYEKOkH+fjOmDsfAUecVewcXmxERER1NR8rQCdcCOua0qRHlY4KUD1Bgei+E\nHlE4A3v3Qm3eF5t2A//vNFwheBwZWUzhFUrZug+zsXqDbmM9nKkwABii0aao+9o0\n142LN1SafBrCAmcxlAbJsDOd4w1B/9InvjCLhXnC4B9VPz5slAXyfXP1s7fLH8kN\ngFer6tUovDf2VA+q4OEc4SOfsnN/Q2UHdOFQ/OzaTeSOFufdHRyFxTk0U/k5C2A=\n=KspM\n-----END PGP SIGNATURE-----\n", "payload": "tree 80d3c14e31f5f13ff465dc2c09cfee19ed8f7839\nparent 74e80468347471779be6060d8d7d6d04e98e467f\nparent 83f6f2235892853c152d08551975525b7ae79914\nauthor Ralf Jung <post@ralfj.de> 1590872922 +0200\ncommitter GitHub <noreply@github.com> 1590872922 +0200\n\nRollup merge of #72543 - estebank:opaque-missing-lts-in-fn, r=nikomatsakis\n\nAccount for missing lifetime in opaque and trait object return types\n\nWhen encountering an opaque closure return type that needs to bound a\nlifetime to the function's arguments, including borrows and type params,\nprovide appropriate suggestions that lead to working code.\n\nGet the user from\n\n```rust\nfn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\nwhere\n    G: Get<T>\n{\n    move || {\n        *dest = g.get();\n    }\n}\n```\n\nto\n\n```rust\nfn foo<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() +'a\nwhere\n    G: Get<T>\n{\n    move || {\n        *dest = g.get();\n    }\n}\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "html_url": "https://github.com/rust-lang/rust/commit/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74e80468347471779be6060d8d7d6d04e98e467f", "url": "https://api.github.com/repos/rust-lang/rust/commits/74e80468347471779be6060d8d7d6d04e98e467f", "html_url": "https://github.com/rust-lang/rust/commit/74e80468347471779be6060d8d7d6d04e98e467f"}, {"sha": "83f6f2235892853c152d08551975525b7ae79914", "url": "https://api.github.com/repos/rust-lang/rust/commits/83f6f2235892853c152d08551975525b7ae79914", "html_url": "https://github.com/rust-lang/rust/commit/83f6f2235892853c152d08551975525b7ae79914"}], "stats": {"total": 1488, "additions": 834, "deletions": 654}, "files": [{"sha": "a59a91e3005aacda59f9429c41b5f6e9e483124b", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 124, "deletions": 46, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -60,7 +60,7 @@ use rustc_errors::{pluralize, struct_span_err};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::Node;\n+use rustc_hir::{Item, ItemKind, Node};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{\n     self,\n@@ -1682,49 +1682,92 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) -> DiagnosticBuilder<'a> {\n+        let hir = &self.tcx.hir();\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n-        let type_param_span = match (self.in_progress_tables, bound_kind) {\n-            (Some(ref table), GenericKind::Param(ref param)) => {\n-                let table_owner = table.borrow().hir_owner;\n-                table_owner.and_then(|table_owner| {\n-                    let generics = self.tcx.generics_of(table_owner.to_def_id());\n-                    // Account for the case where `param` corresponds to `Self`,\n-                    // which doesn't have the expected type argument.\n-                    if !(generics.has_self && param.index == 0) {\n-                        let type_param = generics.type_param(param, self.tcx);\n-                        let hir = &self.tcx.hir();\n-                        type_param.def_id.as_local().map(|def_id| {\n-                            // Get the `hir::Param` to verify whether it already has any bounds.\n-                            // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n-                            // instead we suggest `T: 'a + 'b` in that case.\n-                            let id = hir.as_local_hir_id(def_id);\n-                            let mut has_bounds = false;\n-                            if let Node::GenericParam(param) = hir.get(id) {\n-                                has_bounds = !param.bounds.is_empty();\n-                            }\n-                            let sp = hir.span(id);\n-                            // `sp` only covers `T`, change it so that it covers\n-                            // `T:` when appropriate\n-                            let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n-                            let sp = if has_bounds && !is_impl_trait {\n-                                sp.to(self\n-                                    .tcx\n-                                    .sess\n-                                    .source_map()\n-                                    .next_point(self.tcx.sess.source_map().next_point(sp)))\n-                            } else {\n-                                sp\n-                            };\n-                            (sp, has_bounds, is_impl_trait)\n-                        })\n+        let generics =\n+            self.in_progress_tables.and_then(|table| table.borrow().hir_owner).map(|table_owner| {\n+                let hir_id = hir.as_local_hir_id(table_owner);\n+                let parent_id = hir.get_parent_item(hir_id);\n+                (\n+                    // Parent item could be a `mod`, so we check the HIR before calling:\n+                    if let Some(Node::Item(Item {\n+                        kind: ItemKind::Trait(..) | ItemKind::Impl { .. },\n+                        ..\n+                    })) = hir.find(parent_id)\n+                    {\n+                        Some(self.tcx.generics_of(hir.local_def_id(parent_id).to_def_id()))\n                     } else {\n                         None\n-                    }\n-                })\n+                    },\n+                    self.tcx.generics_of(table_owner.to_def_id()),\n+                )\n+            });\n+        let type_param_span = match (generics, bound_kind) {\n+            (Some((_, ref generics)), GenericKind::Param(ref param)) => {\n+                // Account for the case where `param` corresponds to `Self`,\n+                // which doesn't have the expected type argument.\n+                if !(generics.has_self && param.index == 0) {\n+                    let type_param = generics.type_param(param, self.tcx);\n+                    type_param.def_id.as_local().map(|def_id| {\n+                        // Get the `hir::Param` to verify whether it already has any bounds.\n+                        // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n+                        // instead we suggest `T: 'a + 'b` in that case.\n+                        let id = hir.as_local_hir_id(def_id);\n+                        let mut has_bounds = false;\n+                        if let Node::GenericParam(param) = hir.get(id) {\n+                            has_bounds = !param.bounds.is_empty();\n+                        }\n+                        let sp = hir.span(id);\n+                        // `sp` only covers `T`, change it so that it covers\n+                        // `T:` when appropriate\n+                        let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n+                        let sp = if has_bounds && !is_impl_trait {\n+                            sp.to(self\n+                                .tcx\n+                                .sess\n+                                .source_map()\n+                                .next_point(self.tcx.sess.source_map().next_point(sp)))\n+                        } else {\n+                            sp\n+                        };\n+                        (sp, has_bounds, is_impl_trait)\n+                    })\n+                } else {\n+                    None\n+                }\n             }\n             _ => None,\n         };\n+        let new_lt = generics\n+            .as_ref()\n+            .and_then(|(parent_g, g)| {\n+                let possible: Vec<_> = (b'a'..=b'z').map(|c| format!(\"'{}\", c as char)).collect();\n+                let mut lts_names = g\n+                    .params\n+                    .iter()\n+                    .filter(|p| matches!(p.kind, ty::GenericParamDefKind::Lifetime))\n+                    .map(|p| p.name.as_str())\n+                    .collect::<Vec<_>>();\n+                if let Some(g) = parent_g {\n+                    lts_names.extend(\n+                        g.params\n+                            .iter()\n+                            .filter(|p| matches!(p.kind, ty::GenericParamDefKind::Lifetime))\n+                            .map(|p| p.name.as_str()),\n+                    );\n+                }\n+                let lts = lts_names.iter().map(|s| -> &str { &*s }).collect::<Vec<_>>();\n+                possible.into_iter().find(|candidate| !lts.contains(&candidate.as_str()))\n+            })\n+            .unwrap_or(\"'lt\".to_string());\n+        let add_lt_sugg = generics\n+            .as_ref()\n+            .and_then(|(_, g)| g.params.first())\n+            .and_then(|param| param.def_id.as_local())\n+            .map(|def_id| {\n+                (hir.span(hir.as_local_hir_id(def_id)).shrink_to_lo(), format!(\"{}, \", new_lt))\n+            });\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n@@ -1781,6 +1824,29 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         }\n \n+        let new_binding_suggestion =\n+            |err: &mut DiagnosticBuilder<'tcx>,\n+             type_param_span: Option<(Span, bool, bool)>,\n+             bound_kind: GenericKind<'tcx>| {\n+                let msg = \"consider introducing an explicit lifetime bound\";\n+                if let Some((sp, has_lifetimes, is_impl_trait)) = type_param_span {\n+                    let suggestion = if is_impl_trait {\n+                        (sp.shrink_to_hi(), format!(\" + {}\", new_lt))\n+                    } else {\n+                        let tail = if has_lifetimes { \" +\" } else { \"\" };\n+                        (sp, format!(\"{}: {}{}\", bound_kind, new_lt, tail))\n+                    };\n+                    let mut sugg =\n+                        vec![suggestion, (span.shrink_to_hi(), format!(\" + {}\", new_lt))];\n+                    if let Some(lt) = add_lt_sugg {\n+                        sugg.push(lt);\n+                        sugg.rotate_right(1);\n+                    }\n+                    // `MaybeIncorrect` due to issue #41966.\n+                    err.multipart_suggestion(msg, sugg, Applicability::MaybeIncorrect);\n+                }\n+            };\n+\n         let mut err = match *sub {\n             ty::ReEarlyBound(ty::EarlyBoundRegion { name, .. })\n             | ty::ReFree(ty::FreeRegion { bound_region: ty::BrNamed(_, name), .. }) => {\n@@ -1822,17 +1888,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     \"{} may not live long enough\",\n                     labeled_user_string\n                 );\n-                err.help(&format!(\n-                    \"consider adding an explicit lifetime bound for `{}`\",\n-                    bound_kind\n-                ));\n                 note_and_explain_region(\n                     self.tcx,\n                     &mut err,\n                     &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n                     \"...\",\n                 );\n+                if let Some(infer::RelateParamBound(_, t)) = origin {\n+                    let t = self.resolve_vars_if_possible(&t);\n+                    match t.kind {\n+                        // We've got:\n+                        // fn get_later<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+                        // suggest:\n+                        // fn get_later<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+                        ty::Closure(_, _substs) | ty::Opaque(_, _substs) => {\n+                            new_binding_suggestion(&mut err, type_param_span, bound_kind);\n+                        }\n+                        _ => {\n+                            binding_suggestion(&mut err, type_param_span, bound_kind, new_lt);\n+                        }\n+                    }\n+                }\n                 err\n             }\n         };\n@@ -1861,14 +1938,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             \"...\",\n         );\n \n+        debug!(\"report_sub_sup_conflict: var_origin={:?}\", var_origin);\n+        debug!(\"report_sub_sup_conflict: sub_region={:?}\", sub_region);\n+        debug!(\"report_sub_sup_conflict: sub_origin={:?}\", sub_origin);\n+        debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n+        debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n+\n         if let (&infer::Subtype(ref sup_trace), &infer::Subtype(ref sub_trace)) =\n             (&sup_origin, &sub_origin)\n         {\n-            debug!(\"report_sub_sup_conflict: var_origin={:?}\", var_origin);\n-            debug!(\"report_sub_sup_conflict: sub_region={:?}\", sub_region);\n-            debug!(\"report_sub_sup_conflict: sub_origin={:?}\", sub_origin);\n-            debug!(\"report_sub_sup_conflict: sup_region={:?}\", sup_region);\n-            debug!(\"report_sub_sup_conflict: sup_origin={:?}\", sup_origin);\n             debug!(\"report_sub_sup_conflict: sup_trace={:?}\", sup_trace);\n             debug!(\"report_sub_sup_conflict: sub_trace={:?}\", sub_trace);\n             debug!(\"report_sub_sup_conflict: sup_trace.values={:?}\", sup_trace.values);"}, {"sha": "7ab18e54f7ea2342210629fa6af0286ccbf5f140", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -121,16 +121,14 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             (Some(ret_span), _) => (\n                 ty_sub.span,\n                 ret_span,\n-                \"this parameter and the return type are declared \\\n-                 with different lifetimes...\"\n+                \"this parameter and the return type are declared with different lifetimes...\"\n                     .to_owned(),\n                 format!(\"...but data{} is returned here\", span_label_var1),\n             ),\n             (_, Some(ret_span)) => (\n                 ty_sup.span,\n                 ret_span,\n-                \"this parameter and the return type are declared \\\n-                 with different lifetimes...\"\n+                \"this parameter and the return type are declared with different lifetimes...\"\n                     .to_owned(),\n                 format!(\"...but data{} is returned here\", span_label_var1),\n             ),"}, {"sha": "cc8f1816bc3f4a10ac6fccef165ce0fc55937a70", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -55,9 +55,9 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n                 diag.emit();\n                 ErrorReported\n             })\n+            .or_else(|| self.try_report_impl_not_conforming_to_trait())\n             .or_else(|| self.try_report_anon_anon_conflict())\n             .or_else(|| self.try_report_static_impl_trait())\n-            .or_else(|| self.try_report_impl_not_conforming_to_trait())\n     }\n \n     pub fn regions(&self) -> Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)> {"}, {"sha": "acaf47469927625fb8da0cb7bb7346c4487d5022", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -21,8 +21,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         // where the anonymous region appears (there must always be one; we\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n-        // with the named one.//scope_def_id\n-        let (named, anon, anon_param_info, region_info) = if self.is_named_region(sub)\n+        // with the named one.\n+        let (named, anon, anon_param_info, region_info) = if sub.has_name()\n             && self.tcx().is_suitable_region(sup).is_some()\n             && self.find_param_with_region(sup, sub).is_some()\n         {\n@@ -32,7 +32,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 self.find_param_with_region(sup, sub).unwrap(),\n                 self.tcx().is_suitable_region(sup).unwrap(),\n             )\n-        } else if self.is_named_region(sup)\n+        } else if sup.has_name()\n             && self.tcx().is_suitable_region(sub).is_some()\n             && self.find_param_with_region(sub, sup).is_some()\n         {\n@@ -74,15 +74,21 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         }\n \n         if let Some((_, fndecl)) = self.find_anon_type(anon, &br) {\n-            if self.is_return_type_anon(scope_def_id, br, fndecl).is_some()\n-                || self.is_self_anon(is_first, scope_def_id)\n-            {\n+            let is_self_anon = self.is_self_anon(is_first, scope_def_id);\n+            if is_self_anon {\n                 return None;\n             }\n+\n             if let FnRetTy::Return(ty) = &fndecl.output {\n-                if let (TyKind::Def(_, _), ty::ReStatic) = (&ty.kind, sub) {\n-                    // This is an impl Trait return that evaluates de need of 'static.\n-                    // We handle this case better in `static_impl_trait`.\n+                let mut v = ty::TraitObjectVisitor(vec![]);\n+                rustc_hir::intravisit::walk_ty(&mut v, ty);\n+\n+                debug!(\"try_report_named_anon_conflict: ret ty {:?}\", ty);\n+                if sub == &ty::ReStatic && (matches!(ty.kind, TyKind::Def(_, _)) || v.0.len() == 1)\n+                {\n+                    debug!(\"try_report_named_anon_conflict: impl Trait + 'static\");\n+                    // This is an `impl Trait` or `dyn Trait` return that evaluates de need of\n+                    // `'static`. We handle this case better in `static_impl_trait`.\n                     return None;\n                 }\n             }\n@@ -114,17 +120,4 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         Some(diag)\n     }\n-\n-    // This method returns whether the given Region is Named\n-    pub(super) fn is_named_region(&self, region: ty::Region<'tcx>) -> bool {\n-        match *region {\n-            ty::ReStatic => true,\n-            ty::ReFree(ref free_region) => match free_region.bound_region {\n-                ty::BrNamed(..) => true,\n-                _ => false,\n-            },\n-            ty::ReEarlyBound(ebr) => ebr.has_name(),\n-            _ => false,\n-        }\n-    }\n }"}, {"sha": "f4c86ddae604e2b0297484bb6ee3b53a4505ddea", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -4,7 +4,7 @@ use crate::infer::error_reporting::msg_span_from_free_region;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use rustc_errors::{Applicability, ErrorReported};\n-use rustc_middle::ty::{BoundRegion, FreeRegion, RegionKind};\n+use rustc_middle::ty::RegionKind;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the return type is a static impl Trait.\n@@ -20,48 +20,59 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             ) = error.clone()\n             {\n                 let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n-                let return_ty = self.tcx().return_type_impl_trait(anon_reg_sup.def_id);\n-                if sub_r == &RegionKind::ReStatic && return_ty.is_some() {\n+                let (fn_return_span, is_dyn) =\n+                    self.tcx().return_type_impl_or_dyn_trait(anon_reg_sup.def_id)?;\n+                if sub_r == &RegionKind::ReStatic {\n                     let sp = var_origin.span();\n                     let return_sp = sub_origin.span();\n                     let mut err =\n                         self.tcx().sess.struct_span_err(sp, \"cannot infer an appropriate lifetime\");\n-                    err.span_label(\n-                        return_sp,\n-                        \"this return type evaluates to the `'static` lifetime...\",\n-                    );\n-                    err.span_label(sup_origin.span(), \"...but this borrow...\");\n+                    let param_info = self.find_param_with_region(sup_r, sub_r)?;\n+                    err.span_label(param_info.param_ty_span, \"data with this lifetime...\");\n \n-                    let (lifetime, lt_sp_opt) = msg_span_from_free_region(self.tcx(), sup_r);\n-                    if let Some(lifetime_sp) = lt_sp_opt {\n-                        err.span_note(lifetime_sp, &format!(\"...can't outlive {}\", lifetime));\n-                    }\n-\n-                    let lifetime_name = match sup_r {\n-                        RegionKind::ReFree(FreeRegion {\n-                            bound_region: BoundRegion::BrNamed(_, ref name),\n-                            ..\n-                        }) => name.to_string(),\n-                        _ => \"'_\".to_owned(),\n-                    };\n-                    let fn_return_span = return_ty.unwrap().1;\n-                    if let Ok(snippet) =\n-                        self.tcx().sess.source_map().span_to_snippet(fn_return_span)\n+                    // We try to make the output have fewer overlapping spans if possible.\n+                    if (sp == sup_origin.span() || !return_sp.overlaps(sup_origin.span()))\n+                        && sup_origin.span() != return_sp\n                     {\n-                        // only apply this suggestion onto functions with\n-                        // explicit non-desugar'able return.\n-                        if fn_return_span.desugaring_kind().is_none() {\n-                            err.span_suggestion(\n-                                fn_return_span,\n-                                &format!(\n-                                    \"you can add a bound to the return type to make it last \\\n-                                 less than `'static` and match {}\",\n-                                    lifetime,\n-                                ),\n-                                format!(\"{} + {}\", snippet, lifetime_name),\n-                                Applicability::Unspecified,\n-                            );\n+                        // FIXME: account for `async fn` like in `async-await/issues/issue-62097.rs`\n+\n+                        // Customize the spans and labels depending on their relative order so\n+                        // that split sentences flow correctly.\n+                        if sup_origin.span().shrink_to_hi() <= return_sp.shrink_to_lo() {\n+                            err.span_label(sup_origin.span(), \"...is captured here...\");\n+                            err.span_label(return_sp, \"...and required to be `'static` by this\");\n+                        } else {\n+                            err.span_label(return_sp, \"...is required to be `'static` by this...\");\n+                            err.span_label(sup_origin.span(), \"...and is captured here\");\n                         }\n+                    } else {\n+                        err.span_label(\n+                            return_sp,\n+                            \"...is captured and required to be `'static` here\",\n+                        );\n+                    }\n+\n+                    let (lifetime, _) = msg_span_from_free_region(self.tcx(), sup_r);\n+\n+                    let lifetime_name =\n+                        if sup_r.has_name() { sup_r.to_string() } else { \"'_\".to_owned() };\n+                    // only apply this suggestion onto functions with\n+                    // explicit non-desugar'able return.\n+                    if fn_return_span.desugaring_kind().is_none() {\n+                        let msg = format!(\n+                            \"to permit non-static references in {} `{} Trait` value, you can add \\\n+                             an explicit bound for {}\",\n+                            if is_dyn { \"a\" } else { \"an\" },\n+                            if is_dyn { \"dyn\" } else { \"impl\" },\n+                            lifetime,\n+                        );\n+                        // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n+                        err.span_suggestion_verbose(\n+                            fn_return_span.shrink_to_hi(),\n+                            &msg,\n+                            format!(\" + {}\", lifetime_name),\n+                            Applicability::MaybeIncorrect,\n+                        );\n                     }\n                     err.emit();\n                     return Some(ErrorReported);"}, {"sha": "9ac27030adeeac0a1e1f11ea6ff5c53e612095c7", "filename": "src/librustc_infer/infer/error_reporting/note.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -10,10 +10,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         origin: &SubregionOrigin<'tcx>,\n     ) {\n+        let mut label_or_note = |span, msg| {\n+            let sub_count = err.children.iter().filter(|d| d.span.is_dummy()).count();\n+            let expanded_sub_count = err.children.iter().filter(|d| !d.span.is_dummy()).count();\n+            let span_is_primary = err.span.primary_spans().iter().all(|&sp| sp == span);\n+            if span_is_primary && sub_count == 0 && expanded_sub_count == 0 {\n+                err.span_label(span, msg);\n+            } else if span_is_primary && expanded_sub_count == 0 {\n+                err.note(msg);\n+            } else {\n+                err.span_note(span, msg);\n+            }\n+        };\n         match *origin {\n             infer::Subtype(ref trace) => {\n                 if let Some((expected, found)) = self.values_str(&trace.values) {\n-                    err.span_note(\n+                    label_or_note(\n                         trace.cause.span,\n                         &format!(\"...so that the {}\", trace.cause.as_requirement_str()),\n                     );\n@@ -24,27 +36,27 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // handling of region checking when type errors are present is\n                     // *terrible*.\n \n-                    err.span_note(\n+                    label_or_note(\n                         trace.cause.span,\n                         &format!(\"...so that {}\", trace.cause.as_requirement_str()),\n                     );\n                 }\n             }\n             infer::Reborrow(span) => {\n-                err.span_note(span, \"...so that reference does not outlive borrowed content\");\n+                label_or_note(span, \"...so that reference does not outlive borrowed content\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n-                err.span_note(span, &format!(\"...so that closure can access `{}`\", var_name));\n+                label_or_note(span, &format!(\"...so that closure can access `{}`\", var_name));\n             }\n             infer::RelateObjectBound(span) => {\n-                err.span_note(span, \"...so that it can be closed over into an object\");\n+                label_or_note(span, \"...so that it can be closed over into an object\");\n             }\n             infer::CallReturn(span) => {\n-                err.span_note(span, \"...so that return value is valid for the call\");\n+                label_or_note(span, \"...so that return value is valid for the call\");\n             }\n             infer::DataBorrowed(ty, span) => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n                     &format!(\n                         \"...so that the type `{}` is not borrowed for too long\",\n@@ -53,36 +65,33 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 );\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n                     &format!(\n-                        \"...so that the reference type `{}` does not outlive the \\\n-                                        data it points at\",\n+                        \"...so that the reference type `{}` does not outlive the data it points at\",\n                         self.ty_to_string(ty)\n                     ),\n                 );\n             }\n             infer::RelateParamBound(span, t) => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n                     &format!(\n-                        \"...so that the type `{}` will meet its required \\\n-                                        lifetime bounds\",\n+                        \"...so that the type `{}` will meet its required lifetime bounds\",\n                         self.ty_to_string(t)\n                     ),\n                 );\n             }\n             infer::RelateRegionParamBound(span) => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n                     \"...so that the declared lifetime parameter bounds are satisfied\",\n                 );\n             }\n             infer::CompareImplMethodObligation { span, .. } => {\n-                err.span_note(\n+                label_or_note(\n                     span,\n-                    \"...so that the definition in impl matches the definition from the \\\n-                               trait\",\n+                    \"...so that the definition in impl matches the definition from the trait\",\n                 );\n             }\n         }\n@@ -113,8 +122,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0312,\n-                    \"lifetime of reference outlives lifetime of \\\n-                                                borrowed content...\"\n+                    \"lifetime of reference outlives lifetime of borrowed content...\"\n                 );\n                 note_and_explain_region(\n                     self.tcx,\n@@ -138,8 +146,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0313,\n-                    \"lifetime of borrowed pointer outlives lifetime \\\n-                                                of captured variable `{}`...\",\n+                    \"lifetime of borrowed pointer outlives lifetime of captured variable `{}`...\",\n                     var_name\n                 );\n                 note_and_explain_region(\n@@ -163,8 +170,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0476,\n-                    \"lifetime of the source pointer does not outlive \\\n-                                                lifetime bound of the object type\"\n+                    \"lifetime of the source pointer does not outlive lifetime bound of the \\\n+                     object type\"\n                 );\n                 note_and_explain_region(self.tcx, &mut err, \"object type is valid for \", sub, \"\");\n                 note_and_explain_region(\n@@ -181,8 +188,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0477,\n-                    \"the type `{}` does not fulfill the required \\\n-                                                lifetime\",\n+                    \"the type `{}` does not fulfill the required lifetime\",\n                     self.ty_to_string(ty)\n                 );\n                 match *sub {\n@@ -217,8 +223,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.tcx.sess,\n                     span,\n                     E0482,\n-                    \"lifetime of return value does not outlive the \\\n-                                                function call\"\n+                    \"lifetime of return value does not outlive the function call\"\n                 );\n                 note_and_explain_region(\n                     self.tcx,"}, {"sha": "c9d240a5da91ebb1ebaefb74dbae131e84e1671e", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 74, "deletions": 27, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -1,38 +1,27 @@\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n-use crate::dep_graph::DepGraph;\n-use crate::dep_graph::{self, DepConstructor};\n+use crate::dep_graph::{self, DepConstructor, DepGraph};\n use crate::hir::exports::Export;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n-use crate::lint::LintDiagnosticBuilder;\n-use crate::lint::{struct_lint_level, LintSource};\n+use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintSource};\n use crate::middle;\n-use crate::middle::cstore::CrateStoreDyn;\n-use crate::middle::cstore::EncodedMetadata;\n+use crate::middle::cstore::{CrateStoreDyn, EncodedMetadata};\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::interpret::{Allocation, ConstValue, Scalar};\n-use crate::mir::{interpret, Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n+use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n+use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::traits;\n-use crate::ty::query;\n use crate::ty::steal::Steal;\n-use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n-use crate::ty::subst::{GenericArgKind, UserSubsts};\n-use crate::ty::CanonicalPolyFnSig;\n-use crate::ty::GenericParamDefKind;\n-use crate::ty::RegionKind;\n-use crate::ty::ReprOptions;\n+use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n use crate::ty::TyKind::*;\n-use crate::ty::{self, DefIdTree, Ty, TypeAndMut};\n-use crate::ty::{AdtDef, AdtKind, Const, Region};\n-use crate::ty::{BindingMode, BoundVar};\n-use crate::ty::{ConstVid, FloatVar, FloatVid, IntVar, IntVid, TyVar, TyVid};\n-use crate::ty::{ExistentialPredicate, Predicate, PredicateKind};\n-use crate::ty::{InferConst, ParamConst};\n-use crate::ty::{InferTy, ParamTy, PolyFnSig, ProjectionTy};\n-use crate::ty::{List, TyKind, TyS};\n+use crate::ty::{\n+    self, query, AdtDef, AdtKind, BindingMode, BoundVar, CanonicalPolyFnSig, Const, ConstVid,\n+    DefIdTree, ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy,\n+    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateKind, ProjectionTy,\n+    Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut,\n+};\n use rustc_ast::ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n@@ -48,10 +37,8 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefPathHash, Definitions};\n-use rustc_hir::lang_items;\n-use rustc_hir::lang_items::PanicLocationLangItem;\n-use rustc_hir::{HirId, Node, TraitCandidate};\n-use rustc_hir::{ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet};\n+use rustc_hir::lang_items::{self, PanicLocationLangItem};\n+use rustc_hir::{HirId, ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet, Node, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n@@ -1396,6 +1383,66 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n+    pub fn return_type_impl_or_dyn_trait(&self, scope_def_id: DefId) -> Option<(Span, bool)> {\n+        let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n+        let hir_output = match self.hir().get(hir_id) {\n+            Node::Item(hir::Item {\n+                kind:\n+                    ItemKind::Fn(\n+                        hir::FnSig {\n+                            decl: hir::FnDecl { output: hir::FnRetTy::Return(ty), .. },\n+                            ..\n+                        },\n+                        ..,\n+                    ),\n+                ..\n+            })\n+            | Node::ImplItem(hir::ImplItem {\n+                kind:\n+                    hir::ImplItemKind::Fn(\n+                        hir::FnSig {\n+                            decl: hir::FnDecl { output: hir::FnRetTy::Return(ty), .. },\n+                            ..\n+                        },\n+                        _,\n+                    ),\n+                ..\n+            })\n+            | Node::TraitItem(hir::TraitItem {\n+                kind:\n+                    hir::TraitItemKind::Fn(\n+                        hir::FnSig {\n+                            decl: hir::FnDecl { output: hir::FnRetTy::Return(ty), .. },\n+                            ..\n+                        },\n+                        _,\n+                    ),\n+                ..\n+            }) => ty,\n+            _ => return None,\n+        };\n+\n+        let ret_ty = self.type_of(scope_def_id);\n+        match ret_ty.kind {\n+            ty::FnDef(_, _) => {\n+                let sig = ret_ty.fn_sig(*self);\n+                let output = self.erase_late_bound_regions(&sig.output());\n+                if output.is_impl_trait() {\n+                    let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n+                    Some((fn_decl.output.span(), false))\n+                } else {\n+                    let mut v = TraitObjectVisitor(vec![]);\n+                    rustc_hir::intravisit::walk_ty(&mut v, hir_output);\n+                    if v.0.len() == 1 {\n+                        return Some((v.0[0], true));\n+                    }\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     pub fn return_type_impl_trait(&self, scope_def_id: DefId) -> Option<(Ty<'tcx>, Span)> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n         let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());"}, {"sha": "1403efb745b156bec69771e54a047d2beb50ee5b", "filename": "src/librustc_middle/ty/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -249,3 +249,22 @@ pub fn suggest_constraining_type_param(\n         true\n     }\n }\n+\n+pub struct TraitObjectVisitor(pub Vec<rustc_span::Span>);\n+impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor {\n+    type Map = rustc_hir::intravisit::ErasedMap<'v>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+        if let hir::TyKind::TraitObject(\n+            _,\n+            hir::Lifetime { name: hir::LifetimeName::ImplicitObjectLifetimeDefault, .. },\n+        ) = ty.kind\n+        {\n+            self.0.push(ty.span);\n+        }\n+    }\n+}"}, {"sha": "af8fc2cd2ab459d8bc4b3eda43227db55de77e5c", "filename": "src/test/ui/async-await/issues/issue-62097.stderr", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-62097.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -2,15 +2,12 @@ error: cannot infer an appropriate lifetime\n   --> $DIR/issue-62097.rs:12:31\n    |\n LL |     pub async fn run_dummy_fn(&self) {\n-   |                               ^^^^^ ...but this borrow...\n+   |                               ^^^^^\n+   |                               |\n+   |                               data with this lifetime...\n+   |                               ...is captured here...\n LL |         foo(|| self.bar()).await;\n-   |         --- this return type evaluates to the `'static` lifetime...\n-   |\n-note: ...can't outlive the lifetime `'_` as defined on the method body at 12:31\n-  --> $DIR/issue-62097.rs:12:31\n-   |\n-LL |     pub async fn run_dummy_fn(&self) {\n-   |                               ^\n+   |         --- ...and required to be `'static` by this\n \n error: aborting due to previous error\n "}, {"sha": "2dac4a22ae7136983347e6a7efe0e4fa44805900", "filename": "src/test/ui/builtin-superkinds/builtin-superkinds-self-type.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-self-type.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -2,15 +2,9 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/builtin-superkinds-self-type.rs:10:16\n    |\n LL | impl <T: Sync> Foo for T { }\n-   |       --       ^^^\n+   |       --       ^^^ ...so that the type `T` will meet its required lifetime bounds\n    |       |\n    |       help: consider adding an explicit lifetime bound...: `T: 'static +`\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/builtin-superkinds-self-type.rs:10:16\n-   |\n-LL | impl <T: Sync> Foo for T { }\n-   |                ^^^\n \n error: aborting due to previous error\n "}, {"sha": "2beeba8184a7dfb0b3a7891fa222f6c2819c0ef2", "filename": "src/test/ui/feature-gates/feature-gate-infer_static_outlives_requirements.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-infer_static_outlives_requirements.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-infer_static_outlives_requirements.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-infer_static_outlives_requirements.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -4,13 +4,7 @@ error[E0310]: the parameter type `U` may not live long enough\n LL | struct Foo<U> {\n    |            - help: consider adding an explicit lifetime bound...: `U: 'static`\n LL |     bar: Bar<U>\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `U` will meet its required lifetime bounds\n-  --> $DIR/feature-gate-infer_static_outlives_requirements.rs:5:5\n-   |\n-LL |     bar: Bar<U>\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `U` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "e06977ebbe3df6dbf13b4ee1344f80c6f44fd116", "filename": "src/test/ui/generic-associated-types/impl_bounds.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -5,11 +5,7 @@ LL |     type A<'a> where Self: 'static = (&'a ());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n-note: ...so that the type `Fooy<T>` will meet its required lifetime bounds\n-  --> $DIR/impl_bounds.rs:15:5\n-   |\n-LL |     type A<'a> where Self: 'static = (&'a ());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...so that the type `Fooy<T>` will meet its required lifetime bounds\n \n error[E0478]: lifetime bound not satisfied\n   --> $DIR/impl_bounds.rs:17:5"}, {"sha": "d7dae6a08a7b94b9d17514e79198245d1ee7fa17", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 19, "deletions": 37, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -2,55 +2,43 @@ error: cannot infer an appropriate lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:3:35\n    |\n LL | fn elided(x: &i32) -> impl Copy { x }\n-   |                       ---------   ^ ...but this borrow...\n-   |                       |\n-   |                       this return type evaluates to the `'static` lifetime...\n+   |              ----     ---------   ^ ...and is captured here\n+   |              |        |\n+   |              |        ...is required to be `'static` by this...\n+   |              data with this lifetime...\n    |\n-note: ...can't outlive the anonymous lifetime #1 defined on the function body at 3:1\n-  --> $DIR/must_outlive_least_region_or_bound.rs:3:1\n-   |\n-LL | fn elided(x: &i32) -> impl Copy { x }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: you can add a bound to the return type to make it last less than `'static` and match the anonymous lifetime #1 defined on the function body at 3:1\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 3:1\n    |\n LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n-   |                       ^^^^^^^^^^^^^^\n+   |                                 ^^^^\n \n error: cannot infer an appropriate lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:6:44\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |                                ---------   ^ ...but this borrow...\n-   |                                |\n-   |                                this return type evaluates to the `'static` lifetime...\n+   |                    -------     ---------   ^ ...and is captured here\n+   |                    |           |\n+   |                    |           ...is required to be `'static` by this...\n+   |                    data with this lifetime...\n    |\n-note: ...can't outlive the lifetime `'a` as defined on the function body at 6:13\n-  --> $DIR/must_outlive_least_region_or_bound.rs:6:13\n-   |\n-LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n-   |             ^^\n-help: you can add a bound to the return type to make it last less than `'static` and match the lifetime `'a` as defined on the function body at 6:13\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the function body at 6:13\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n-   |                                ^^^^^^^^^^^^^^\n+   |                                          ^^^^\n \n error: cannot infer an appropriate lifetime\n   --> $DIR/must_outlive_least_region_or_bound.rs:12:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n-   |                                  --------------------------------   ^ ...but this borrow...\n-   |                                  |\n-   |                                  this return type evaluates to the `'static` lifetime...\n-   |\n-note: ...can't outlive the lifetime `'a` as defined on the function body at 12:15\n-  --> $DIR/must_outlive_least_region_or_bound.rs:12:15\n+   |                      -------     --------------------------------   ^ ...and is captured here\n+   |                      |           |\n+   |                      |           ...is required to be `'static` by this...\n+   |                      data with this lifetime...\n    |\n-LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n-   |               ^^\n-help: you can add a bound to the return type to make it last less than `'static` and match the lifetime `'a` as defined on the function body at 12:15\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the function body at 12:15\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static + 'a { x }\n-   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                                                   ^^^^\n \n error[E0623]: lifetime mismatch\n   --> $DIR/must_outlive_least_region_or_bound.rs:17:61\n@@ -65,15 +53,9 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/must_outlive_least_region_or_bound.rs:22:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-   |                                 --                ^^^^^^^^^^^^^^^^^^^^\n+   |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |                                 |\n    |                                 help: consider adding an explicit lifetime bound...: `T: 'static +`\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/must_outlive_least_region_or_bound.rs:22:51\n-   |\n-LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n-   |                                                   ^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "1c3a5979ee55bc74c7038c31c2fcd532996f7e77", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -2,43 +2,35 @@ error: cannot infer an appropriate lifetime\n   --> $DIR/static-return-lifetime-infered.rs:7:16\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                                   ----------------------- this return type evaluates to the `'static` lifetime...\n+   |                         -----     ----------------------- ...is required to be `'static` by this...\n+   |                         |\n+   |                         data with this lifetime...\n LL |         self.x.iter().map(|a| a.0)\n    |         ------ ^^^^\n    |         |\n-   |         ...but this borrow...\n+   |         ...and is captured here\n    |\n-note: ...can't outlive the anonymous lifetime #1 defined on the method body at 6:5\n-  --> $DIR/static-return-lifetime-infered.rs:6:5\n-   |\n-LL | /     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-LL | |         self.x.iter().map(|a| a.0)\n-LL | |     }\n-   | |_____^\n-help: you can add a bound to the return type to make it last less than `'static` and match the anonymous lifetime #1 defined on the method body at 6:5\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the method body at 6:5\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                                           ^^^^\n \n error: cannot infer an appropriate lifetime\n   --> $DIR/static-return-lifetime-infered.rs:11:16\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                                     ----------------------- this return type evaluates to the `'static` lifetime...\n+   |                        --------     ----------------------- ...is required to be `'static` by this...\n+   |                        |\n+   |                        data with this lifetime...\n LL |         self.x.iter().map(|a| a.0)\n    |         ------ ^^^^\n    |         |\n-   |         ...but this borrow...\n-   |\n-note: ...can't outlive the lifetime `'a` as defined on the method body at 10:20\n-  --> $DIR/static-return-lifetime-infered.rs:10:20\n+   |         ...and is captured here\n    |\n-LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n-   |                    ^^\n-help: you can add a bound to the return type to make it last less than `'static` and match the lifetime `'a` as defined on the method body at 10:20\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the lifetime `'a` as defined on the method body at 10:20\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n-   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                                             ^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "40e50b9922f8d2e9f6269cc113ab756df0ec3cc1", "filename": "src/test/ui/impl-trait/type_parameters_captured.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -2,15 +2,9 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/type_parameters_captured.rs:7:20\n    |\n LL | fn foo<T>(x: T) -> impl Any + 'static {\n-   |        -           ^^^^^^^^^^^^^^^^^^\n+   |        -           ^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n    |        |\n    |        help: consider adding an explicit lifetime bound...: `T: 'static`\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/type_parameters_captured.rs:7:20\n-   |\n-LL | fn foo<T>(x: T) -> impl Any + 'static {\n-   |                    ^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "7f4f5b22eb302cb77a3d187fd9241ea6b3441edb", "filename": "src/test/ui/issues/issue-16922.nll.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.nll.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -0,0 +1,10 @@\n+error: lifetime may not live long enough\n+  --> $DIR/issue-16922.rs:4:5\n+   |\n+LL | fn foo<T: Any>(value: &T) -> Box<dyn Any> {\n+   |                       - let's call the lifetime of this reference `'1`\n+LL |     Box::new(value) as Box<dyn Any>\n+   |     ^^^^^^^^^^^^^^^ cast requires that `'1` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "827163ef83cf7cf4c7f3fff461b0d28fce7d2333", "filename": "src/test/ui/issues/issue-16922.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fissues%2Fissue-16922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fissues%2Fissue-16922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.rs?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -2,7 +2,7 @@ use std::any::Any;\n \n fn foo<T: Any>(value: &T) -> Box<dyn Any> {\n     Box::new(value) as Box<dyn Any>\n-    //~^ ERROR explicit lifetime required in the type of `value` [E0621]\n+    //~^ ERROR cannot infer an appropriate lifetime\n }\n \n fn main() {"}, {"sha": "02d33aae023ff27f5c31f28e7b6edfd267523943", "filename": "src/test/ui/issues/issue-16922.stderr", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16922.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -1,11 +1,18 @@\n-error[E0621]: explicit lifetime required in the type of `value`\n-  --> $DIR/issue-16922.rs:4:5\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/issue-16922.rs:4:14\n    |\n LL | fn foo<T: Any>(value: &T) -> Box<dyn Any> {\n-   |                       -- help: add explicit lifetime `'static` to the type of `value`: `&'static T`\n+   |                       -- data with this lifetime...\n LL |     Box::new(value) as Box<dyn Any>\n-   |     ^^^^^^^^^^^^^^^ lifetime `'static` required\n+   |     ---------^^^^^-\n+   |     |        |\n+   |     |        ...and is captured here\n+   |     ...is required to be `'static` by this...\n+   |\n+help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 3:1\n+   |\n+LL | fn foo<T: Any>(value: &T) -> Box<dyn Any + '_> {\n+   |                                          ^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0621`."}, {"sha": "d682478db0eeff8b302d2e0f9e54e44ffb3f3193", "filename": "src/test/ui/lifetimes/lifetime-doesnt-live-long-enough.stderr", "status": "modified", "additions": 7, "deletions": 39, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-doesnt-live-long-enough.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -4,27 +4,15 @@ error[E0310]: the parameter type `T` may not live long enough\n LL | struct Foo<T> {\n    |            - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     foo: &'static T\n-   |     ^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'static T` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:19:5\n-   |\n-LL |     foo: &'static T\n-   |     ^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n \n error[E0309]: the parameter type `K` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:24:19\n    |\n LL | trait X<K>: Sized {\n    |         - help: consider adding an explicit lifetime bound...: `K: 'a`\n LL |     fn foo<'a, L: X<&'a Nested<K>>>();\n-   |                   ^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:24:19\n-   |\n-LL |     fn foo<'a, L: X<&'a Nested<K>>>();\n-   |                   ^^^^^^^^^^^^^^^^\n+   |                   ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n \n error[E0309]: the parameter type `Self` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:28:19\n@@ -33,51 +21,31 @@ LL |     fn bar<'a, L: X<&'a Nested<Self>>>();\n    |                   ^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `Self: 'a`...\n-note: ...so that the reference type `&'a Nested<Self>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:28:19\n-   |\n-LL |     fn bar<'a, L: X<&'a Nested<Self>>>();\n-   |                   ^^^^^^^^^^^^^^^^^^^\n+   = note: ...so that the reference type `&'a Nested<Self>` does not outlive the data it points at\n \n error[E0309]: the parameter type `L` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:32:22\n    |\n LL |     fn baz<'a, L, M: X<&'a Nested<L>>>() {\n-   |                -     ^^^^^^^^^^^^^^^^\n+   |                -     ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<L>` does not outlive the data it points at\n    |                |\n    |                help: consider adding an explicit lifetime bound...: `L: 'a`\n-   |\n-note: ...so that the reference type `&'a Nested<L>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:32:22\n-   |\n-LL |     fn baz<'a, L, M: X<&'a Nested<L>>>() {\n-   |                      ^^^^^^^^^^^^^^^^\n \n error[E0309]: the parameter type `K` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:41:33\n    |\n LL | impl<K> Nested<K> {\n    |      - help: consider adding an explicit lifetime bound...: `K: 'a`\n LL |     fn generic_in_parent<'a, L: X<&'a Nested<K>>>() {\n-   |                                 ^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:41:33\n-   |\n-LL |     fn generic_in_parent<'a, L: X<&'a Nested<K>>>() {\n-   |                                 ^^^^^^^^^^^^^^^^\n+   |                                 ^^^^^^^^^^^^^^^^ ...so that the reference type `&'a Nested<K>` does not outlive the data it points at\n \n error[E0309]: the parameter type `M` may not live long enough\n   --> $DIR/lifetime-doesnt-live-long-enough.rs:44:36\n    |\n LL |     fn generic_in_child<'a, 'b, L: X<&'a Nested<M>>, M: 'b>() {\n    |                                    ^^^^^^^^^^^^^^^^  -- help: consider adding an explicit lifetime bound...: `M: 'a +`\n-   |\n-note: ...so that the reference type `&'a Nested<M>` does not outlive the data it points at\n-  --> $DIR/lifetime-doesnt-live-long-enough.rs:44:36\n-   |\n-LL |     fn generic_in_child<'a, 'b, L: X<&'a Nested<M>>, M: 'b>() {\n-   |                                    ^^^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    ...so that the reference type `&'a Nested<M>` does not outlive the data it points at\n \n error: aborting due to 6 previous errors\n "}, {"sha": "eba00c5a9454e613a5d7cb9cf0ead5d1b6b36d35", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env-wrong-bound.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-bound.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -5,11 +5,7 @@ LL |     bar::<T::Output>()\n    |     ^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as MyTrait<'a>>::Output: 'a`...\n-note: ...so that the type `<T as MyTrait<'a>>::Output` will meet its required lifetime bounds\n-  --> $DIR/projection-where-clause-env-wrong-bound.rs:15:5\n-   |\n-LL |     bar::<T::Output>()\n-   |     ^^^^^^^^^^^^^^^^\n+   = note: ...so that the type `<T as MyTrait<'a>>::Output` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "34b83859a6bd2e346a996f628c8ceb066db44bee", "filename": "src/test/ui/nll/ty-outlives/projection-where-clause-env-wrong-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-where-clause-env-wrong-lifetime.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -5,11 +5,7 @@ LL |     bar::<<T as MyTrait<'a>>::Output>()\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as MyTrait<'a>>::Output: 'a`...\n-note: ...so that the type `<T as MyTrait<'a>>::Output` will meet its required lifetime bounds\n-  --> $DIR/projection-where-clause-env-wrong-lifetime.rs:14:5\n-   |\n-LL |     bar::<<T as MyTrait<'a>>::Output>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...so that the type `<T as MyTrait<'a>>::Output` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "9563c0dff3644468961cfb59f8fc15e96cee8db6", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-box-error.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.nll.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -1,11 +1,11 @@\n-error[E0621]: explicit lifetime required in the type of `ss`\n+error: lifetime may not live long enough\n   --> $DIR/object-lifetime-default-from-box-error.rs:18:5\n    |\n LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait> {\n-   |             --------------- help: add explicit lifetime `'static` to the type of `ss`: `&mut SomeStruct<'static>`\n+   |         -- has type `&mut SomeStruct<'1>`\n ...\n LL |     ss.r\n-   |     ^^^^ lifetime `'static` required\n+   |     ^^^^ returning this value requires that `'1` must outlive `'static`\n \n error[E0507]: cannot move out of `ss.r` which is behind a mutable reference\n   --> $DIR/object-lifetime-default-from-box-error.rs:18:5"}, {"sha": "708ab1cf38297d2d3778de18bf1039063c09453c", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-box-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.rs?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -15,7 +15,7 @@ fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait> {\n     // `Box<SomeTrait>` defaults to a `'static` bound, so this return\n     // is illegal.\n \n-    ss.r //~ ERROR explicit lifetime required in the type of `ss` [E0621]\n+    ss.r //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn store(ss: &mut SomeStruct, b: Box<dyn SomeTrait>) {"}, {"sha": "70a9bf22b8db372779e8bd2efbee667875c49af6", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-box-error.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-box-error.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -1,11 +1,16 @@\n-error[E0621]: explicit lifetime required in the type of `ss`\n+error: cannot infer an appropriate lifetime\n   --> $DIR/object-lifetime-default-from-box-error.rs:18:5\n    |\n LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait> {\n-   |             --------------- help: add explicit lifetime `'static` to the type of `ss`: `&mut SomeStruct<'static>`\n+   |             --------------- data with this lifetime...\n ...\n LL |     ss.r\n-   |     ^^^^ lifetime `'static` required\n+   |     ^^^^ ...is captured and required to be `'static` here\n+   |\n+help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #2 defined on the function body at 14:1\n+   |\n+LL | fn load(ss: &mut SomeStruct) -> Box<dyn SomeTrait + '_> {\n+   |                                                   ^^^^\n \n error[E0621]: explicit lifetime required in the type of `ss`\n   --> $DIR/object-lifetime-default-from-box-error.rs:31:12"}, {"sha": "bf02ba8eb9199d2a4c090f200239d3f11436e8ca", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.nll.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -14,17 +14,17 @@ LL | fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ lifetime `'static` required\n \n-error[E0621]: explicit lifetime required in the type of `v`\n-  --> $DIR/region-object-lifetime-in-coercion.rs:21:5\n+error: lifetime may not live long enough\n+  --> $DIR/region-object-lifetime-in-coercion.rs:20:5\n    |\n LL | fn c(v: &[u8]) -> Box<dyn Foo> {\n-   |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n+   |         - let's call the lifetime of this reference `'1`\n ...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^ lifetime `'static` required\n+   |     ^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/region-object-lifetime-in-coercion.rs:26:5\n+  --> $DIR/region-object-lifetime-in-coercion.rs:24:5\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |      -- -- lifetime `'b` defined here"}, {"sha": "d56eaf77b6646fe2163dd211eb0d5bb31da2d34a", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.rs?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -11,20 +11,17 @@ fn a(v: &[u8]) -> Box<dyn Foo + 'static> {\n }\n \n fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n-    Box::new(v)\n-        //~^ ERROR explicit lifetime required in the type of `v` [E0621]\n+    Box::new(v) //~ ERROR explicit lifetime required in the type of `v` [E0621]\n }\n \n fn c(v: &[u8]) -> Box<dyn Foo> {\n     // same as previous case due to RFC 599\n \n-    Box::new(v)\n-        //~^ ERROR explicit lifetime required in the type of `v` [E0621]\n+    Box::new(v) //~ ERROR cannot infer an appropriate lifetime\n }\n \n fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n-    Box::new(v)\n-        //~^ ERROR cannot infer an appropriate lifetime due to conflicting\n+    Box::new(v) //~ ERROR cannot infer an appropriate lifetime due to conflicting\n }\n \n fn e<'a:'b,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {"}, {"sha": "1462af44cb15a6702f085410026d272bbe4600d2", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.stderr", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -14,40 +14,48 @@ LL | fn b(v: &[u8]) -> Box<dyn Foo + 'static> {\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^ lifetime `'static` required\n \n-error[E0621]: explicit lifetime required in the type of `v`\n-  --> $DIR/region-object-lifetime-in-coercion.rs:21:5\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/region-object-lifetime-in-coercion.rs:20:14\n    |\n LL | fn c(v: &[u8]) -> Box<dyn Foo> {\n-   |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n+   |         ----- data with this lifetime...\n ...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^ lifetime `'static` required\n+   |     ---------^-\n+   |     |        |\n+   |     |        ...and is captured here\n+   |     ...is required to be `'static` by this...\n+   |\n+help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 17:1\n+   |\n+LL | fn c(v: &[u8]) -> Box<dyn Foo + '_> {\n+   |                               ^^^^\n \n error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n-  --> $DIR/region-object-lifetime-in-coercion.rs:26:14\n+  --> $DIR/region-object-lifetime-in-coercion.rs:24:14\n    |\n LL |     Box::new(v)\n    |              ^\n    |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 25:6...\n-  --> $DIR/region-object-lifetime-in-coercion.rs:25:6\n+note: first, the lifetime cannot outlive the lifetime `'a` as defined on the function body at 23:6...\n+  --> $DIR/region-object-lifetime-in-coercion.rs:23:6\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |      ^^\n note: ...so that the expression is assignable\n-  --> $DIR/region-object-lifetime-in-coercion.rs:26:14\n+  --> $DIR/region-object-lifetime-in-coercion.rs:24:14\n    |\n LL |     Box::new(v)\n    |              ^\n    = note: expected `&[u8]`\n               found `&'a [u8]`\n-note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 25:9...\n-  --> $DIR/region-object-lifetime-in-coercion.rs:25:9\n+note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 23:9...\n+  --> $DIR/region-object-lifetime-in-coercion.rs:23:9\n    |\n LL | fn d<'a,'b>(v: &'a [u8]) -> Box<dyn Foo+'b> {\n    |         ^^\n note: ...so that the expression is assignable\n-  --> $DIR/region-object-lifetime-in-coercion.rs:26:5\n+  --> $DIR/region-object-lifetime-in-coercion.rs:24:5\n    |\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^"}, {"sha": "9303e0f8e66432a19d6ba148670cd2be3e65f2b7", "filename": "src/test/ui/regions/regions-close-associated-type-into-object.stderr", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-close-associated-type-into-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-close-associated-type-into-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-associated-type-into-object.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -5,11 +5,7 @@ LL |     Box::new(item)\n    |     ^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as Iter>::Item: 'static`...\n-note: ...so that the type `<T as Iter>::Item` will meet its required lifetime bounds\n-  --> $DIR/regions-close-associated-type-into-object.rs:15:5\n-   |\n-LL |     Box::new(item)\n-   |     ^^^^^^^^^^^^^^\n+   = note: ...so that the type `<T as Iter>::Item` will meet its required lifetime bounds\n \n error[E0310]: the associated type `<T as Iter>::Item` may not live long enough\n   --> $DIR/regions-close-associated-type-into-object.rs:22:5\n@@ -18,11 +14,7 @@ LL |     Box::new(item)\n    |     ^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as Iter>::Item: 'static`...\n-note: ...so that the type `std::boxed::Box<<T as Iter>::Item>` will meet its required lifetime bounds\n-  --> $DIR/regions-close-associated-type-into-object.rs:22:5\n-   |\n-LL |     Box::new(item)\n-   |     ^^^^^^^^^^^^^^\n+   = note: ...so that the type `std::boxed::Box<<T as Iter>::Item>` will meet its required lifetime bounds\n \n error[E0309]: the associated type `<T as Iter>::Item` may not live long enough\n   --> $DIR/regions-close-associated-type-into-object.rs:28:5\n@@ -31,11 +23,7 @@ LL |     Box::new(item)\n    |     ^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as Iter>::Item: 'a`...\n-note: ...so that the type `<T as Iter>::Item` will meet its required lifetime bounds\n-  --> $DIR/regions-close-associated-type-into-object.rs:28:5\n-   |\n-LL |     Box::new(item)\n-   |     ^^^^^^^^^^^^^^\n+   = note: ...so that the type `<T as Iter>::Item` will meet its required lifetime bounds\n \n error[E0309]: the associated type `<T as Iter>::Item` may not live long enough\n   --> $DIR/regions-close-associated-type-into-object.rs:35:5\n@@ -44,11 +32,7 @@ LL |     Box::new(item)\n    |     ^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<T as Iter>::Item: 'a`...\n-note: ...so that the type `std::boxed::Box<<T as Iter>::Item>` will meet its required lifetime bounds\n-  --> $DIR/regions-close-associated-type-into-object.rs:35:5\n-   |\n-LL |     Box::new(item)\n-   |     ^^^^^^^^^^^^^^\n+   = note: ...so that the type `std::boxed::Box<<T as Iter>::Item>` will meet its required lifetime bounds\n \n error: aborting due to 4 previous errors\n "}, {"sha": "e5a80cbd54758c0fd22f4a2eabcec80c1567ea04", "filename": "src/test/ui/regions/regions-close-object-into-object-5.stderr", "status": "modified", "additions": 6, "deletions": 42, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-5.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -5,13 +5,7 @@ LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n-   |     ^^^^^^^^^^\n-   |\n-note: ...so that the type `B<'_, T>` will meet its required lifetime bounds\n-  --> $DIR/regions-close-object-into-object-5.rs:17:5\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |     ^^^^^^^^^^\n+   |     ^^^^^^^^^^ ...so that the type `B<'_, T>` will meet its required lifetime bounds\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:9\n@@ -20,13 +14,7 @@ LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n-   |         ^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-close-object-into-object-5.rs:17:9\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |         ^\n+   |         ^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:9\n@@ -35,13 +23,7 @@ LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n-   |         ^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-close-object-into-object-5.rs:17:9\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |         ^^^^^^\n+   |         ^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:11\n@@ -50,13 +32,7 @@ LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n-   |           ^^^\n-   |\n-note: ...so that the reference type `&dyn A<T>` does not outlive the data it points at\n-  --> $DIR/regions-close-object-into-object-5.rs:17:11\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |           ^^^\n+   |           ^^^ ...so that the reference type `&dyn A<T>` does not outlive the data it points at\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:11\n@@ -65,13 +41,7 @@ LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n-   |           ^^^\n-   |\n-note: ...so that the type `(dyn A<T> + 'static)` is not borrowed for too long\n-  --> $DIR/regions-close-object-into-object-5.rs:17:11\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |           ^^^\n+   |           ^^^ ...so that the type `(dyn A<T> + 'static)` is not borrowed for too long\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-object-into-object-5.rs:17:11\n@@ -80,13 +50,7 @@ LL | fn f<'a, T, U>(v: Box<A<T> + 'static>) -> Box<X + 'static> {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // oh dear!\n LL |     box B(&*v) as Box<X>\n-   |           ^^^\n-   |\n-note: ...so that the type `(dyn A<T> + 'static)` is not borrowed for too long\n-  --> $DIR/regions-close-object-into-object-5.rs:17:11\n-   |\n-LL |     box B(&*v) as Box<X>\n-   |           ^^^\n+   |           ^^^ ...so that the type `(dyn A<T> + 'static)` is not borrowed for too long\n \n error: aborting due to 6 previous errors\n "}, {"sha": "50274b066df60039130b9ba55bd0272b0de0f885", "filename": "src/test/ui/regions/regions-close-over-type-parameter-1.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-1.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -4,27 +4,15 @@ error[E0310]: the parameter type `A` may not live long enough\n LL | fn make_object1<A: SomeTrait>(v: A) -> Box<dyn SomeTrait + 'static> {\n    |                 -- help: consider adding an explicit lifetime bound...: `A: 'static +`\n LL |     box v as Box<dyn SomeTrait + 'static>\n-   |     ^^^^^\n-   |\n-note: ...so that the type `A` will meet its required lifetime bounds\n-  --> $DIR/regions-close-over-type-parameter-1.rs:12:5\n-   |\n-LL |     box v as Box<dyn SomeTrait + 'static>\n-   |     ^^^^^\n+   |     ^^^^^ ...so that the type `A` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `A` may not live long enough\n   --> $DIR/regions-close-over-type-parameter-1.rs:21:5\n    |\n LL | fn make_object3<'a, 'b, A: SomeTrait + 'a>(v: A) -> Box<dyn SomeTrait + 'b> {\n    |                         -- help: consider adding an explicit lifetime bound...: `A: 'b +`\n LL |     box v as Box<dyn SomeTrait + 'b>\n-   |     ^^^^^\n-   |\n-note: ...so that the type `A` will meet its required lifetime bounds\n-  --> $DIR/regions-close-over-type-parameter-1.rs:21:5\n-   |\n-LL |     box v as Box<dyn SomeTrait + 'b>\n-   |     ^^^^^\n+   |     ^^^^^ ...so that the type `A` will meet its required lifetime bounds\n \n error: aborting due to 2 previous errors\n "}, {"sha": "705d21078ecd76032b69eeb80727dba0f32d75b2", "filename": "src/test/ui/regions/regions-close-param-into-object.stderr", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-close-param-into-object.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-close-param-into-object.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-param-into-object.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -5,13 +5,7 @@ LL | fn p1<T>(v: T) -> Box<dyn X + 'static>\n    |       - help: consider adding an explicit lifetime bound...: `T: 'static`\n ...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-close-param-into-object.rs:6:5\n-   |\n-LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:12:5\n@@ -20,13 +14,7 @@ LL | fn p2<T>(v: Box<T>) -> Box<dyn X + 'static>\n    |       - help: consider adding an explicit lifetime bound...: `T: 'static`\n ...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `std::boxed::Box<T>` will meet its required lifetime bounds\n-  --> $DIR/regions-close-param-into-object.rs:12:5\n-   |\n-LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `std::boxed::Box<T>` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:18:5\n@@ -35,13 +23,7 @@ LL | fn p3<'a,T>(v: T) -> Box<dyn X + 'a>\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n ...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-close-param-into-object.rs:18:5\n-   |\n-LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-close-param-into-object.rs:24:5\n@@ -50,13 +32,7 @@ LL | fn p4<'a,T>(v: Box<T>) -> Box<dyn X + 'a>\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n ...\n LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `std::boxed::Box<T>` will meet its required lifetime bounds\n-  --> $DIR/regions-close-param-into-object.rs:24:5\n-   |\n-LL |     Box::new(v)\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `std::boxed::Box<T>` will meet its required lifetime bounds\n \n error: aborting due to 4 previous errors\n "}, {"sha": "e32a36f72cd14b003a9207d88fe5ee514c2a91e1", "filename": "src/test/ui/regions/regions-enum-not-wf.stderr", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-enum-not-wf.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -4,13 +4,7 @@ error[E0309]: the parameter type `T` may not live long enough\n LL | enum Ref1<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     Ref1Variant1(RequireOutlives<'a, T>)\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:18:18\n-   |\n-LL |     Ref1Variant1(RequireOutlives<'a, T>)\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:23:25\n@@ -19,13 +13,7 @@ LL | enum Ref2<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     Ref2Variant1,\n LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:23:25\n-   |\n-LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:35:1\n@@ -37,30 +25,15 @@ LL |   enum RefDouble<'a, 'b, T> {\n LL | |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n LL | |\n LL | | }\n-   | |_^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:35:1\n-   |\n-LL | / enum RefDouble<'a, 'b, T> {\n-LL | |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-LL | |\n-LL | | }\n-   | |_^\n+   | |_^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:36:23\n    |\n LL | enum RefDouble<'a, 'b, T> {\n    |                        - help: consider adding an explicit lifetime bound...: `T: 'b`\n LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:36:23\n-   |\n-LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error: aborting due to 4 previous errors\n "}, {"sha": "ea59ea11a143c6dd70126b373f9637a370340550", "filename": "src/test/ui/regions/regions-implied-bounds-projection-gap-1.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-implied-bounds-projection-gap-1.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -5,13 +5,7 @@ LL | fn func<'x, T:Trait1<'x>>(t: &'x T::Foo)\n    |             -- help: consider adding an explicit lifetime bound...: `T: 'x +`\n LL | {\n LL |     wf::<&'x T>();\n-   |          ^^^^^\n-   |\n-note: ...so that the reference type `&'x T` does not outlive the data it points at\n-  --> $DIR/regions-implied-bounds-projection-gap-1.rs:16:10\n-   |\n-LL |     wf::<&'x T>();\n-   |          ^^^^^\n+   |          ^^^^^ ...so that the reference type `&'x T` does not outlive the data it points at\n \n error: aborting due to previous error\n "}, {"sha": "4ca5ac291d5bef33a6d08e6b3b7edf8638bc378d", "filename": "src/test/ui/regions/regions-infer-bound-from-trait-self.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait-self.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -5,11 +5,7 @@ LL |         check_bound(x, self)\n    |         ^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `Self: 'a`...\n-note: ...so that the type `Self` will meet its required lifetime bounds\n-  --> $DIR/regions-infer-bound-from-trait-self.rs:46:9\n-   |\n-LL |         check_bound(x, self)\n-   |         ^^^^^^^^^^^\n+   = note: ...so that the type `Self` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "196ee8ca7c0b59a43d2afab6939ede59a1664593", "filename": "src/test/ui/regions/regions-infer-bound-from-trait.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-bound-from-trait.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -4,27 +4,15 @@ error[E0309]: the parameter type `A` may not live long enough\n LL | fn bar1<'a,A>(x: Inv<'a>, a: A) {\n    |            - help: consider adding an explicit lifetime bound...: `A: 'a`\n LL |     check_bound(x, a)\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `A` will meet its required lifetime bounds\n-  --> $DIR/regions-infer-bound-from-trait.rs:33:5\n-   |\n-LL |     check_bound(x, a)\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `A` may not live long enough\n   --> $DIR/regions-infer-bound-from-trait.rs:37:5\n    |\n LL | fn bar2<'a,'b,A:Is<'b>>(x: Inv<'a>, y: Inv<'b>, a: A) {\n    |               -- help: consider adding an explicit lifetime bound...: `A: 'a +`\n LL |     check_bound(x, a)\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `A` will meet its required lifetime bounds\n-  --> $DIR/regions-infer-bound-from-trait.rs:37:5\n-   |\n-LL |     check_bound(x, a)\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `A` will meet its required lifetime bounds\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2bb51731583a6ffded7c220c0c825f69638b1999", "filename": "src/test/ui/rfc-2093-infer-outlives/dont-infer-static.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fdont-infer-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fdont-infer-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fdont-infer-static.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -4,13 +4,7 @@ error[E0310]: the parameter type `U` may not live long enough\n LL | struct Foo<U> {\n    |            - help: consider adding an explicit lifetime bound...: `U: 'static`\n LL |     bar: Bar<U>\n-   |     ^^^^^^^^^^^\n-   |\n-note: ...so that the type `U` will meet its required lifetime bounds\n-  --> $DIR/dont-infer-static.rs:8:5\n-   |\n-LL |     bar: Bar<U>\n-   |     ^^^^^^^^^^^\n+   |     ^^^^^^^^^^^ ...so that the type `U` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "e32a36f72cd14b003a9207d88fe5ee514c2a91e1", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-enum-not-wf.stderr", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-enum-not-wf.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -4,13 +4,7 @@ error[E0309]: the parameter type `T` may not live long enough\n LL | enum Ref1<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     Ref1Variant1(RequireOutlives<'a, T>)\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:18:18\n-   |\n-LL |     Ref1Variant1(RequireOutlives<'a, T>)\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:23:25\n@@ -19,13 +13,7 @@ LL | enum Ref2<'a, T> {\n    |               - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     Ref2Variant1,\n LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:23:25\n-   |\n-LL |     Ref2Variant2(isize, RequireOutlives<'a, T>),\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:35:1\n@@ -37,30 +25,15 @@ LL |   enum RefDouble<'a, 'b, T> {\n LL | |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n LL | |\n LL | | }\n-   | |_^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:35:1\n-   |\n-LL | / enum RefDouble<'a, 'b, T> {\n-LL | |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-LL | |\n-LL | | }\n-   | |_^\n+   | |_^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-enum-not-wf.rs:36:23\n    |\n LL | enum RefDouble<'a, 'b, T> {\n    |                        - help: consider adding an explicit lifetime bound...: `T: 'b`\n LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-enum-not-wf.rs:36:23\n-   |\n-LL |     RefDoubleVariant1(&'a RequireOutlives<'b, T>)\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error: aborting due to 4 previous errors\n "}, {"sha": "44812a51778a74d133e47992181a87213bac3e31", "filename": "src/test/ui/rfc-2093-infer-outlives/regions-struct-not-wf.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fregions-struct-not-wf.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -4,27 +4,15 @@ error[E0309]: the parameter type `T` may not live long enough\n LL | impl<'a, T> Trait<'a, T> for usize {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Out = &'a T;\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'a T` does not outlive the data it points at\n-  --> $DIR/regions-struct-not-wf.rs:13:5\n-   |\n-LL |     type Out = &'a T;\n-   |     ^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^ ...so that the reference type `&'a T` does not outlive the data it points at\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/regions-struct-not-wf.rs:21:5\n    |\n LL | impl<'a, T> Trait<'a, T> for u32 {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Out = RefOk<'a, T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/regions-struct-not-wf.rs:21:5\n-   |\n-LL |     type Out = RefOk<'a, T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n \n error[E0491]: in type `&'a &'b T`, reference has a longer lifetime than the data it references\n   --> $DIR/regions-struct-not-wf.rs:25:5"}, {"sha": "1aeabce5e8aaf267fa616f22b6d3ff8bf93f7d68", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -2,15 +2,10 @@ error: cannot infer an appropriate lifetime\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:16\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                ^^^^                 ---------- this return type evaluates to the `'static` lifetime...\n-   |                |\n-   |                ...but this borrow...\n-   |\n-note: ...can't outlive the lifetime `'_` as defined on the method body at 8:26\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait-async.rs:8:26\n-   |\n-LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                          ^\n+   |                ^^^^  ----------     ---------- ...and required to be `'static` by this\n+   |                |     |\n+   |                |     data with this lifetime...\n+   |                ...is captured here...\n \n error: aborting due to previous error\n "}, {"sha": "04c475be787b89af4af76ca7f5cb93c83e167882", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -2,19 +2,15 @@ error: cannot infer an appropriate lifetime\n   --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:44\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |                               ----------   ^^^^ ...but this borrow...\n-   |                               |\n-   |                               this return type evaluates to the `'static` lifetime...\n+   |                ----------     ----------   ^^^^ ...and is captured here\n+   |                |              |\n+   |                |              ...is required to be `'static` by this...\n+   |                data with this lifetime...\n    |\n-note: ...can't outlive the anonymous lifetime #1 defined on the method body at 6:5\n-  --> $DIR/arbitrary_self_types_pin_lifetime_impl_trait.rs:6:5\n-   |\n-LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: you can add a bound to the return type to make it last less than `'static` and match the anonymous lifetime #1 defined on the method body at 6:5\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the method body at 6:5\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n-   |                               ^^^^^^^^^^^^^^^\n+   |                                          ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "2072b00f7b2cb3f3512cba02809c1166e7dcf4de", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.nll.stderr", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.nll.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -0,0 +1,115 @@\n+error[E0261]: use of undeclared lifetime name `'a`\n+  --> $DIR/missing-lifetimes-in-signature.rs:37:11\n+   |\n+LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |        -  ^^ undeclared lifetime\n+   |        |\n+   |        help: consider introducing lifetime `'a` here: `'a,`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:15:37\n+   |\n+LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+   |                          -          ^^^^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n+   |                          |\n+   |                          let's call the lifetime of this reference `'1`\n+   |\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a bound\n+   |\n+LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:37\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the function body at 25:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:1\n+   |\n+LL | / fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL | |\n+LL | | where\n+LL | |     G: Get<T>\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:45\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                             ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the function body at 47:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:1\n+   |\n+LL | / fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL | |\n+LL | | where\n+LL | |     G: Get<T>\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:58\n+   |\n+LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |                                                          ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the method body at 59:5...\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:5\n+   |\n+LL | /     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+LL | |\n+LL | |         move || {\n+LL | |             *dest = g.get();\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:68:45\n+   |\n+LL | fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the function body at 68:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:68:1\n+   |\n+LL | / fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+LL | |\n+LL | | where\n+LL | |     G: Get<T>\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+\n+error[E0621]: explicit lifetime required in the type of `dest`\n+  --> $DIR/missing-lifetimes-in-signature.rs:73:5\n+   |\n+LL |   fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |                                    ------ help: add explicit lifetime `'a` to the type of `dest`: `&'a mut T`\n+...\n+LL | /     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^ lifetime `'a` required\n+\n+error[E0309]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:79:44\n+   |\n+LL | fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+   |                                            ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `G: 'a`...\n+\n+error: aborting due to 8 previous errors\n+\n+Some errors have detailed explanations: E0261, E0309, E0621.\n+For more information about an error, try `rustc --explain E0261`."}, {"sha": "d3853445dfdfebb01518eb66ac063a0872c38fcb", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.rs?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -0,0 +1,110 @@\n+pub trait Get<T> {\n+    fn get(self) -> T;\n+}\n+\n+struct Foo {\n+    x: usize,\n+}\n+\n+impl Get<usize> for Foo {\n+    fn get(self) -> usize {\n+        self.x\n+    }\n+}\n+\n+fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+where\n+    G: Get<T>\n+{\n+    move || { //~ ERROR cannot infer an appropriate lifetime\n+        *dest = g.get();\n+    }\n+}\n+\n+// After applying suggestion for `foo`:\n+fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+//~^ ERROR the parameter type `G` may not live long enough\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+\n+// After applying suggestion for `bar`:\n+fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ //~ ERROR undeclared lifetime\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+// After applying suggestion for `baz`:\n+fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+//~^ ERROR the parameter type `G` may not live long enough\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+// Same as above, but show that we pay attention to lifetime names from parent item\n+impl<'a> Foo {\n+    fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+        //~^ ERROR the parameter type `G` may not live long enough\n+        move || {\n+            *dest = g.get();\n+        }\n+    }\n+}\n+\n+// After applying suggestion for `qux`:\n+fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+//~^ ERROR explicit lifetime required in the type of `dest`\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+// Potential incorrect attempt:\n+fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+//~^ ERROR the parameter type `G` may not live long enough\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+\n+// We need to tie the lifetime of `G` with the lifetime of `&mut T` and the returned closure:\n+fn ok<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+// This also works. The `'_` isn't necessary but it's where we arrive to following the suggestions:\n+fn ok2<'a, G: 'a, T>(g: G, dest: &'a mut T) -> impl FnOnce() + '_ + 'a\n+where\n+    G: Get<T>\n+{\n+    move || {\n+        *dest = g.get();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5cf170d566ca94acb9767161c8e4609de7d1526b", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -0,0 +1,126 @@\n+error[E0261]: use of undeclared lifetime name `'a`\n+  --> $DIR/missing-lifetimes-in-signature.rs:37:11\n+   |\n+LL | fn baz<G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |        -  ^^ undeclared lifetime\n+   |        |\n+   |        help: consider introducing lifetime `'a` here: `'a,`\n+\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/missing-lifetimes-in-signature.rs:19:5\n+   |\n+LL |   fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce()\n+   |                            ------     ------------- ...is required to be `'static` by this...\n+   |                            |\n+   |                            data with this lifetime...\n+...\n+LL | /     move || {\n+LL | |         *dest = g.get();\n+LL | |     }\n+   | |_____^ ...and is captured here\n+   |\n+help: to permit non-static references in an `impl Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 15:1\n+   |\n+LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                                   ^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:37\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the function body at 25:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:1\n+   |\n+LL | / fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL | |\n+LL | | where\n+LL | |     G: Get<T>\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:30:5: 32:6 g:G, dest:&mut T]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:25:37\n+   |\n+LL | fn bar<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                     ^^^^^^^^^^^^^^^^^^\n+help: consider introducing an explicit lifetime bound\n+   |\n+LL | fn bar<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |        ^^^^^                                                   ^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:45\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                             ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the function body at 47:1...\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:1\n+   |\n+LL | / fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+LL | |\n+LL | | where\n+LL | |     G: Get<T>\n+...  |\n+LL | |     }\n+LL | | }\n+   | |_^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:52:5: 54:6 g:G, dest:&mut T]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:47:45\n+   |\n+LL | fn qux<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n+   |                                             ^^^^^^^^^^^^^^^^^^\n+help: consider introducing an explicit lifetime bound\n+   |\n+LL | fn qux<'b, 'a, G: 'b + 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'b\n+   |        ^^^     ^^^^^^^                                                  ^^^^\n+\n+error[E0311]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:58\n+   |\n+LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |                                                          ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the parameter type `G` must be valid for the anonymous lifetime #1 defined on the method body at 59:5...\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:5\n+   |\n+LL | /     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+LL | |\n+LL | |         move || {\n+LL | |             *dest = g.get();\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+note: ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:61:9: 63:10 g:G, dest:&mut T]` will meet its required lifetime bounds\n+  --> $DIR/missing-lifetimes-in-signature.rs:59:58\n+   |\n+LL |     fn qux<'b, G: Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ {\n+   |                                                          ^^^^^^^^^^^^^^^^^^\n+help: consider introducing an explicit lifetime bound\n+   |\n+LL |     fn qux<'c, 'b, G: 'c + Get<T> + 'b, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'c {\n+   |            ^^^     ^^^^^^^                                                           ^^^^\n+\n+error[E0621]: explicit lifetime required in the type of `dest`\n+  --> $DIR/missing-lifetimes-in-signature.rs:68:45\n+   |\n+LL | fn bat<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n+   |                                  ------     ^^^^^^^^^^^^^^^^^^^^^^^ lifetime `'a` required\n+   |                                  |\n+   |                                  help: add explicit lifetime `'a` to the type of `dest`: `&'a mut T`\n+\n+error[E0309]: the parameter type `G` may not live long enough\n+  --> $DIR/missing-lifetimes-in-signature.rs:79:44\n+   |\n+LL | fn bak<'a, G, T>(g: G, dest: &'a mut T) -> impl FnOnce() + 'a\n+   |            -                               ^^^^^^^^^^^^^^^^^^ ...so that the type `[closure@$DIR/missing-lifetimes-in-signature.rs:84:5: 86:6 g:G, dest:&mut T]` will meet its required lifetime bounds\n+   |            |\n+   |            help: consider adding an explicit lifetime bound...: `G: 'a`\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors have detailed explanations: E0261, E0309, E0621.\n+For more information about an error, try `rustc --explain E0261`."}, {"sha": "643dac25724972168904f14bebbcc95168c4e2ff", "filename": "src/test/ui/suggestions/suggest-impl-trait-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-impl-trait-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-impl-trait-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-impl-trait-lifetime.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -5,13 +5,7 @@ LL | fn foo(d: impl Debug) {\n    |           ---------- help: consider adding an explicit lifetime bound...: `impl Debug + 'static`\n LL |\n LL |     bar(d);\n-   |     ^^^\n-   |\n-note: ...so that the type `impl Debug` will meet its required lifetime bounds\n-  --> $DIR/suggest-impl-trait-lifetime.rs:7:5\n-   |\n-LL |     bar(d);\n-   |     ^^^\n+   |     ^^^ ...so that the type `impl Debug` will meet its required lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "e2540e424cb19ac9d0990673e6ac6c0f6f56615d", "filename": "src/test/ui/type-alias-impl-trait/generic_type_does_not_live_long_enough.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_type_does_not_live_long_enough.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -22,16 +22,10 @@ error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/generic_type_does_not_live_long_enough.rs:9:1\n    |\n LL | type WrongGeneric<T> = impl 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n ...\n LL | fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n    |                  - help: consider adding an explicit lifetime bound...: `T: 'static`\n-   |\n-note: ...so that the type `T` will meet its required lifetime bounds\n-  --> $DIR/generic_type_does_not_live_long_enough.rs:9:1\n-   |\n-LL | type WrongGeneric<T> = impl 'static;\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "3577dd59289e5ca7c3a42750cb845fcf3c4b162d", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.stderr", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -1,31 +1,16 @@\n-error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements\n+error: cannot infer an appropriate lifetime\n   --> $DIR/dyn-trait-underscore.rs:8:20\n    |\n+LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n+   |                ---- data with this lifetime...\n+LL |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n LL |     Box::new(items.iter())\n-   |                    ^^^^\n+   |     ---------------^^^^--- ...is captured and required to be `'static` here\n    |\n-note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the function body at 6:1...\n-  --> $DIR/dyn-trait-underscore.rs:6:1\n+help: to permit non-static references in a `dyn Trait` value, you can add an explicit bound for the anonymous lifetime #1 defined on the function body at 6:1\n    |\n-LL | / fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n-LL | |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n-LL | |     Box::new(items.iter())\n-LL | | }\n-   | |_^\n-note: ...so that reference does not outlive borrowed content\n-  --> $DIR/dyn-trait-underscore.rs:8:14\n-   |\n-LL |     Box::new(items.iter())\n-   |              ^^^^^\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the expression is assignable\n-  --> $DIR/dyn-trait-underscore.rs:8:5\n-   |\n-LL |     Box::new(items.iter())\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected `std::boxed::Box<(dyn std::iter::Iterator<Item = &T> + 'static)>`\n-              found `std::boxed::Box<dyn std::iter::Iterator<Item = &T>>`\n+LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T> + '_> {\n+   |                                                   ^^^^\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0495`."}, {"sha": "f3b32ad3f7e85d27399c8e9a574d4aad8789606a", "filename": "src/test/ui/wf/wf-impl-associated-type-region.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-region.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -4,13 +4,7 @@ error[E0309]: the parameter type `T` may not live long enough\n LL | impl<'a, T> Foo<'a> for T {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Bar = &'a T;\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'a T` does not outlive the data it points at\n-  --> $DIR/wf-impl-associated-type-region.rs:10:5\n-   |\n-LL |     type Bar = &'a T;\n-   |     ^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^ ...so that the reference type `&'a T` does not outlive the data it points at\n \n error: aborting due to previous error\n "}, {"sha": "a79c446247794ad59a1fdbc56bfd1922059da488", "filename": "src/test/ui/wf/wf-in-fn-type-static.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-static.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -5,13 +5,7 @@ LL | struct Foo<T> {\n    |            - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // needs T: 'static\n LL |     x: fn() -> &'static T\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'static T` does not outlive the data it points at\n-  --> $DIR/wf-in-fn-type-static.rs:13:5\n-   |\n-LL |     x: fn() -> &'static T\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n \n error[E0310]: the parameter type `T` may not live long enough\n   --> $DIR/wf-in-fn-type-static.rs:18:5\n@@ -20,13 +14,7 @@ LL | struct Bar<T> {\n    |            - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // needs T: Copy\n LL |     x: fn(&'static T)\n-   |     ^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'static T` does not outlive the data it points at\n-  --> $DIR/wf-in-fn-type-static.rs:18:5\n-   |\n-LL |     x: fn(&'static T)\n-   |     ^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c0057f3c82977fd990fc09b3251108ec65239106", "filename": "src/test/ui/wf/wf-in-obj-type-static.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-static.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -5,13 +5,7 @@ LL | struct Foo<T> {\n    |            - help: consider adding an explicit lifetime bound...: `T: 'static`\n LL |     // needs T: 'static\n LL |     x: dyn Object<&'static T>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'static T` does not outlive the data it points at\n-  --> $DIR/wf-in-obj-type-static.rs:14:5\n-   |\n-LL |     x: dyn Object<&'static T>\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the reference type `&'static T` does not outlive the data it points at\n \n error: aborting due to previous error\n "}, {"sha": "4c25ab9593958ddf8d26de9dc9da0e548ebc6d21", "filename": "src/test/ui/wf/wf-outlives-ty-in-fn-or-trait.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fwf%2Fwf-outlives-ty-in-fn-or-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fwf%2Fwf-outlives-ty-in-fn-or-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-outlives-ty-in-fn-or-trait.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -4,27 +4,15 @@ error[E0309]: the parameter type `T` may not live long enough\n LL | impl<'a, T> Trait<'a, T> for usize {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Out = &'a fn(T);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'a fn(T)` does not outlive the data it points at\n-  --> $DIR/wf-outlives-ty-in-fn-or-trait.rs:9:5\n-   |\n-LL |     type Out = &'a fn(T);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^ ...so that the reference type `&'a fn(T)` does not outlive the data it points at\n \n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/wf-outlives-ty-in-fn-or-trait.rs:19:5\n    |\n LL | impl<'a, T> Trait<'a, T> for u32 {\n    |          - help: consider adding an explicit lifetime bound...: `T: 'a`\n LL |     type Out = &'a dyn Baz<T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...so that the reference type `&'a (dyn Baz<T> + 'a)` does not outlive the data it points at\n-  --> $DIR/wf-outlives-ty-in-fn-or-trait.rs:19:5\n-   |\n-LL |     type Out = &'a dyn Baz<T>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ ...so that the reference type `&'a (dyn Baz<T> + 'a)` does not outlive the data it points at\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ae681ba6c9bb5c573fd8f7e3fe555cdd07370e3b", "filename": "src/test/ui/wf/wf-trait-associated-type-region.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1661d23e386ecd2d2ebb7990fa4cb459b2896f6/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-region.stderr?ref=f1661d23e386ecd2d2ebb7990fa4cb459b2896f6", "patch": "@@ -5,11 +5,7 @@ LL |     type Type2 = &'a Self::Type1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `<Self as SomeTrait<'a>>::Type1: 'a`...\n-note: ...so that the reference type `&'a <Self as SomeTrait<'a>>::Type1` does not outlive the data it points at\n-  --> $DIR/wf-trait-associated-type-region.rs:9:5\n-   |\n-LL |     type Type2 = &'a Self::Type1;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...so that the reference type `&'a <Self as SomeTrait<'a>>::Type1` does not outlive the data it points at\n \n error: aborting due to previous error\n "}]}