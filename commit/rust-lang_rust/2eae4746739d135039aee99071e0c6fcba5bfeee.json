{"sha": "2eae4746739d135039aee99071e0c6fcba5bfeee", "node_id": "C_kwDOAAsO6NoAKDJlYWU0NzQ2NzM5ZDEzNTAzOWFlZTk5MDcxZTBjNmZjYmE1YmZlZWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-05T18:37:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-05T18:37:07Z"}, "message": "Auto merge of #2197 - RalfJung:round-robin, r=RalfJung\n\nmake Miri's scheduler proper round-robin\n\nWhen thread N blocks or yields, we activate thread N+1 next, rather than always activating thread 0. This should guarantee that as long as all threads regularly yield, each thread eventually takes a step again.\n\nFixes the \"multiple loops that yield playing ping-pong\" part of https://github.com/rust-lang/miri/issues/1388.\n`@cbeuw` I hope this doesn't screw up the scheduler-dependent tests you are adding in your PR.", "tree": {"sha": "97bcba9959c664c46da2e03b0303946a068375f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97bcba9959c664c46da2e03b0303946a068375f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2eae4746739d135039aee99071e0c6fcba5bfeee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2eae4746739d135039aee99071e0c6fcba5bfeee", "html_url": "https://github.com/rust-lang/rust/commit/2eae4746739d135039aee99071e0c6fcba5bfeee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2eae4746739d135039aee99071e0c6fcba5bfeee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fbe710012e0b83142a5a5fc5704b97dcd295eec", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fbe710012e0b83142a5a5fc5704b97dcd295eec", "html_url": "https://github.com/rust-lang/rust/commit/0fbe710012e0b83142a5a5fc5704b97dcd295eec"}, {"sha": "34b359be1ec89383baff1dba5f74f5bfe8beedd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/34b359be1ec89383baff1dba5f74f5bfe8beedd7", "html_url": "https://github.com/rust-lang/rust/commit/34b359be1ec89383baff1dba5f74f5bfe8beedd7"}], "stats": {"total": 110, "additions": 102, "deletions": 8}, "files": [{"sha": "b6fb866f714a4568d3e206fd8cea27438fd58a3c", "filename": "src/thread.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2eae4746739d135039aee99071e0c6fcba5bfeee/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eae4746739d135039aee99071e0c6fcba5bfeee/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=2eae4746739d135039aee99071e0c6fcba5bfeee", "patch": "@@ -518,16 +518,26 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             return Ok(SchedulingAction::ExecuteTimeoutCallback);\n         }\n         // No callbacks scheduled, pick a regular thread to execute.\n-        // We need to pick a new thread for execution.\n-        for (id, thread) in self.threads.iter_enumerated() {\n+        // The active thread blocked or yielded. So we go search for another enabled thread.\n+        // Curcially, we start searching at the current active thread ID, rather than at 0, since we\n+        // want to avoid always scheduling threads 0 and 1 without ever making progress in thread 2.\n+        //\n+        // `skip(N)` means we start iterating at thread N, so we skip 1 more to start just *after*\n+        // the active thread. Then after that we look at `take(N)`, i.e., the threads *before* the\n+        // active thread.\n+        let threads = self\n+            .threads\n+            .iter_enumerated()\n+            .skip(self.active_thread.index() + 1)\n+            .chain(self.threads.iter_enumerated().take(self.active_thread.index()));\n+        for (id, thread) in threads {\n+            debug_assert_ne!(self.active_thread, id);\n             if thread.state == ThreadState::Enabled {\n-                if !self.yield_active_thread || id != self.active_thread {\n-                    self.active_thread = id;\n-                    if let Some(data_race) = data_race {\n-                        data_race.thread_set_active(self.active_thread);\n-                    }\n-                    break;\n+                self.active_thread = id;\n+                if let Some(data_race) = data_race {\n+                    data_race.thread_set_active(self.active_thread);\n                 }\n+                break;\n             }\n         }\n         self.yield_active_thread = false;"}, {"sha": "a6fceb03638dd873dc404f4a27ec00e38cf85d8b", "filename": "tests/pass/concurrency/spin_loops.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/2eae4746739d135039aee99071e0c6fcba5bfeee/tests%2Fpass%2Fconcurrency%2Fspin_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eae4746739d135039aee99071e0c6fcba5bfeee/tests%2Fpass%2Fconcurrency%2Fspin_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loops.rs?ref=2eae4746739d135039aee99071e0c6fcba5bfeee", "patch": "@@ -0,0 +1,82 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+\n+use std::thread;\n+use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n+use std::sync::mpsc;\n+use std::cell::Cell;\n+\n+/// When a thread yields, Miri's scheduler used to pick the thread with the lowest ID\n+/// that can run. IDs are assigned in thread creation order.\n+/// This means we could make 2 threads infinitely ping-pong with each other while\n+/// really there is a 3rd thread that we should schedule to make progress.\n+fn two_player_ping_pong() {\n+    static FLAG: AtomicUsize = AtomicUsize::new(0);\n+\n+    let waiter1 = thread::spawn(|| {\n+        while FLAG.load(Ordering::Acquire) == 0 {\n+            // spin and wait\n+            thread::yield_now();\n+        }\n+    });\n+    let waiter2 = thread::spawn(|| {\n+        while FLAG.load(Ordering::Acquire) == 0 {\n+            // spin and wait\n+            thread::yield_now();\n+        }\n+    });\n+    let progress = thread::spawn(|| {\n+        FLAG.store(1, Ordering::Release);\n+    });\n+    // The first `join` blocks the main thread and thus takes it out of the equation.\n+    waiter1.join().unwrap();\n+    waiter2.join().unwrap();\n+    progress.join().unwrap();\n+}\n+\n+/// Based on a test by @jethrogb.\n+fn launcher() {\n+    static THREAD2_LAUNCHED: AtomicBool = AtomicBool::new(false);\n+\n+    for _ in 0..10 {\n+        let (tx, rx) = mpsc::sync_channel(0);\n+        THREAD2_LAUNCHED.store(false, Ordering::SeqCst);\n+\n+        let jh = thread::spawn(move || {\n+            struct RecvOnDrop(Cell<Option<mpsc::Receiver<()>>>);\n+\n+            impl Drop for RecvOnDrop {\n+                fn drop(&mut self) {\n+                    let rx = self.0.take().unwrap();\n+                    while !THREAD2_LAUNCHED.load(Ordering::SeqCst) {\n+                        thread::yield_now();\n+                    }\n+                    rx.recv().unwrap();\n+                }\n+            }\n+\n+            let tl_rx: RecvOnDrop = RecvOnDrop(Cell::new(None));\n+            tl_rx.0.set(Some(rx));\n+        });\n+\n+        let tx_clone = tx.clone();\n+        let jh2 = thread::spawn(move || {\n+            THREAD2_LAUNCHED.store(true, Ordering::SeqCst);\n+            jh.join().unwrap();\n+            tx_clone.send(()).expect_err(\n+                \"Expecting channel to be closed because thread 1 TLS destructors must've run\",\n+            );\n+        });\n+\n+        while !THREAD2_LAUNCHED.load(Ordering::SeqCst) {\n+            thread::yield_now();\n+        }\n+        thread::yield_now();\n+        tx.send(()).expect(\"Expecting channel to be live because thread 2 must block on join\");\n+        jh2.join().unwrap();\n+    }\n+}\n+\n+fn main() {\n+    two_player_ping_pong();\n+    launcher();\n+}"}, {"sha": "03676519d4f1c052581dee9227a650c2a4b8d782", "filename": "tests/pass/concurrency/spin_loops.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eae4746739d135039aee99071e0c6fcba5bfeee/tests%2Fpass%2Fconcurrency%2Fspin_loops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2eae4746739d135039aee99071e0c6fcba5bfeee/tests%2Fpass%2Fconcurrency%2Fspin_loops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Fspin_loops.stderr?ref=2eae4746739d135039aee99071e0c6fcba5bfeee", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+"}]}