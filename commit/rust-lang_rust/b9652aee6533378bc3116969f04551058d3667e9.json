{"sha": "b9652aee6533378bc3116969f04551058d3667e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NjUyYWVlNjUzMzM3OGJjMzExNjk2OWYwNDU1MTA1OGQzNjY3ZTk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-26T12:38:18Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-07-31T00:31:41Z"}, "message": "region_infer: rustfmt, pacifying the mercilous tidy", "tree": {"sha": "cf033e7d81821349c2da2b2a91e703c9d112a4a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf033e7d81821349c2da2b2a91e703c9d112a4a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9652aee6533378bc3116969f04551058d3667e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9652aee6533378bc3116969f04551058d3667e9", "html_url": "https://github.com/rust-lang/rust/commit/b9652aee6533378bc3116969f04551058d3667e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9652aee6533378bc3116969f04551058d3667e9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9baf01363cfe579e6a04b7f4d821dcff5d27831d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9baf01363cfe579e6a04b7f4d821dcff5d27831d", "html_url": "https://github.com/rust-lang/rust/commit/9baf01363cfe579e6a04b7f4d821dcff5d27831d"}], "stats": {"total": 72, "additions": 48, "deletions": 24}, "files": [{"sha": "afd4e2859aced768268d115e4c867da0bd4d5e53", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b9652aee6533378bc3116969f04551058d3667e9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9652aee6533378bc3116969f04551058d3667e9/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=b9652aee6533378bc3116969f04551058d3667e9", "patch": "@@ -14,8 +14,8 @@ use borrow_check::nll::constraints::{\n     ConstraintIndex, ConstraintSccIndex, ConstraintSet, OutlivesConstraint,\n };\n use borrow_check::nll::region_infer::values::{RegionElement, ToElementIndex};\n-use borrow_check::nll::type_check::Locations;\n use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n+use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::region_constraints::{GenericKind, VarInfos};\n@@ -313,8 +313,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for (external_name, variable) in self.universal_regions.named_universal_regions() {\n             debug!(\n                 \"init_universal_regions: region {:?} has external name {:?}\",\n-                variable,\n-                external_name\n+                variable, external_name\n             );\n             self.definitions[variable].external_name = Some(external_name);\n         }\n@@ -424,10 +423,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n \n         self.check_type_tests(\n-            infcx, mir, mir_def_id, outlives_requirements.as_mut(), errors_buffer);\n+            infcx,\n+            mir,\n+            mir_def_id,\n+            outlives_requirements.as_mut(),\n+            errors_buffer,\n+        );\n \n         self.check_universal_regions(\n-            infcx, mir, mir_def_id, outlives_requirements.as_mut(), errors_buffer);\n+            infcx,\n+            mir,\n+            mir_def_id,\n+            outlives_requirements.as_mut(),\n+            errors_buffer,\n+        );\n \n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n@@ -586,13 +595,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let Some(lower_bound_region) = lower_bound_region {\n                 let region_scope_tree = &tcx.region_scope_tree(mir_def_id);\n                 let type_test_span = type_test.locations.span(mir);\n-                infcx.construct_generic_bound_failure(\n-                    region_scope_tree,\n-                    type_test_span,\n-                    None,\n-                    type_test.generic_kind,\n-                    lower_bound_region,\n-                ).buffer(errors_buffer);\n+                infcx\n+                    .construct_generic_bound_failure(\n+                        region_scope_tree,\n+                        type_test_span,\n+                        None,\n+                        type_test.generic_kind,\n+                        lower_bound_region,\n+                    )\n+                    .buffer(errors_buffer);\n             } else {\n                 // FIXME. We should handle this case better. It\n                 // indicates that we have e.g. some region variable\n@@ -604,10 +615,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // iterating over the universal regions and reporting\n                 // an error that multiple bounds are required.\n                 let type_test_span = type_test.locations.span(mir);\n-                tcx.sess.struct_span_err(\n-                    type_test_span,\n-                    &format!(\"`{}` does not live long enough\", type_test.generic_kind,),\n-                ).buffer(errors_buffer);\n+                tcx.sess\n+                    .struct_span_err(\n+                        type_test_span,\n+                        &format!(\"`{}` does not live long enough\", type_test.generic_kind,),\n+                    )\n+                    .buffer(errors_buffer);\n             }\n         }\n     }\n@@ -659,8 +672,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // region, which ensures it can be encoded in a `ClosureOutlivesRequirement`.\n         let lower_bound_plus = self.non_local_universal_upper_bound(*lower_bound);\n         assert!(self.universal_regions.is_universal_region(lower_bound_plus));\n-        assert!(!self.universal_regions\n-            .is_local_free_region(lower_bound_plus));\n+        assert!(\n+            !self\n+                .universal_regions\n+                .is_local_free_region(lower_bound_plus)\n+        );\n \n         propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n             subject,\n@@ -892,7 +908,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return true;\n         }\n \n-        self.scc_values.contains_points(sup_region_scc, sub_region_scc)\n+        self.scc_values\n+            .contains_points(sup_region_scc, sub_region_scc)\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -982,7 +999,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // (because `fr` includes `end(o)`).\n         for shorter_fr in self.scc_values.universal_regions_outlived_by(longer_fr_scc) {\n             // If it is known that `fr: o`, carry on.\n-            if self.universal_region_relations.outlives(longer_fr, shorter_fr) {\n+            if self\n+                .universal_region_relations\n+                .outlives(longer_fr, shorter_fr)\n+            {\n                 continue;\n             }\n \n@@ -996,14 +1016,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do).\n                 // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n-                if let Some(fr_minus) = self.universal_region_relations.non_local_lower_bound(longer_fr) {\n+                if let Some(fr_minus) = self\n+                    .universal_region_relations\n+                    .non_local_lower_bound(longer_fr)\n+                {\n                     debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n \n                     // Grow `shorter_fr` until we find a non-local\n                     // region. (We always will.)  We'll call that\n                     // `shorter_fr+` -- it's ever so slightly larger than\n                     // `fr`.\n-                    let shorter_fr_plus = self.universal_region_relations.non_local_upper_bound(shorter_fr);\n+                    let shorter_fr_plus = self\n+                        .universal_region_relations\n+                        .non_local_upper_bound(shorter_fr);\n                     debug!(\n                         \"check_universal_region: shorter_fr_plus={:?}\",\n                         shorter_fr_plus\n@@ -1026,8 +1051,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Note: in this case, we use the unapproximated regions\n             // to report the error. This gives better error messages\n             // in some cases.\n-            self.report_error(\n-                mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n+            self.report_error(mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n         }\n     }\n "}]}