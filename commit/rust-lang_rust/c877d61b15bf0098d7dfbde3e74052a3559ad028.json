{"sha": "c877d61b15bf0098d7dfbde3e74052a3559ad028", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NzdkNjFiMTViZjAwOThkN2RmYmRlM2U3NDA1MmEzNTU5YWQwMjg=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-02-08T22:55:55Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas@schievink.net", "date": "2016-02-12T18:28:42Z"}, "message": "Use more autoderef in libsyntax", "tree": {"sha": "7dfa1c87ae094311d147f91b914ce179c93f43f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dfa1c87ae094311d147f91b914ce179c93f43f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c877d61b15bf0098d7dfbde3e74052a3559ad028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c877d61b15bf0098d7dfbde3e74052a3559ad028", "html_url": "https://github.com/rust-lang/rust/commit/c877d61b15bf0098d7dfbde3e74052a3559ad028", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c877d61b15bf0098d7dfbde3e74052a3559ad028/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db6e5d5ef946a2f8369e665f2b756c2465b77b68", "url": "https://api.github.com/repos/rust-lang/rust/commits/db6e5d5ef946a2f8369e665f2b756c2465b77b68", "html_url": "https://github.com/rust-lang/rust/commit/db6e5d5ef946a2f8369e665f2b756c2465b77b68"}], "stats": {"total": 342, "additions": 171, "deletions": 171}, "files": [{"sha": "dd414c463c7b1c4aea0bab5b160050c6200c0bde", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=c877d61b15bf0098d7dfbde3e74052a3559ad028", "patch": "@@ -143,7 +143,7 @@ pub trait AttributeMethods {\n impl AttributeMethods for Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n     fn meta(&self) -> &MetaItem {\n-        &*self.node.value\n+        &self.node.value\n     }\n \n     /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n@@ -370,17 +370,17 @@ pub fn cfg_matches<T: CfgDiag>(cfgs: &[P<MetaItem>],\n                            diag: &mut T) -> bool {\n     match cfg.node {\n         ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"any\" =>\n-            mis.iter().any(|mi| cfg_matches(cfgs, &**mi, diag)),\n+            mis.iter().any(|mi| cfg_matches(cfgs, &mi, diag)),\n         ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"all\" =>\n-            mis.iter().all(|mi| cfg_matches(cfgs, &**mi, diag)),\n+            mis.iter().all(|mi| cfg_matches(cfgs, &mi, diag)),\n         ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"not\" => {\n             if mis.len() != 1 {\n                 diag.emit_error(|diagnostic| {\n                     diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n                 });\n                 return false;\n             }\n-            !cfg_matches(cfgs, &*mis[0], diag)\n+            !cfg_matches(cfgs, &mis[0], diag)\n         }\n         ast::MetaItemKind::List(ref pred, _) => {\n             diag.emit_error(|diagnostic| {"}, {"sha": "123a21fb8f0c00690b14eaef5b15292154c64276", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c877d61b15bf0098d7dfbde3e74052a3559ad028", "patch": "@@ -1040,7 +1040,7 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n                             allow_internal_unstable: true,\n                         }\n                     });\n-                    it = mac.expand(fld.cx, attr.span, &*attr.node.value, it);\n+                    it = mac.expand(fld.cx, attr.span, &attr.node.value, it);\n                     fld.cx.bt_pop();\n                 }\n                 _ => unreachable!()"}, {"sha": "5dfec8dafcf3776e10193ff07ddb1dd7f8a1b4c3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c877d61b15bf0098d7dfbde3e74052a3559ad028", "patch": "@@ -676,7 +676,7 @@ impl<'a> Context<'a> {\n             }\n         }\n         for &(ref n, ref ty) in self.plugin_attributes {\n-            if &*n == name {\n+            if n == name {\n                 // Plugins can't gate attributes, so we don't check for it\n                 // unlike the code above; we only use this loop to\n                 // short-circuit to avoid the checks below"}, {"sha": "6df313177a08cb4b37f8a9007cfd43e78601ea6b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c877d61b15bf0098d7dfbde3e74052a3559ad028", "patch": "@@ -1071,7 +1071,7 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}\n     let ident = match node {\n         // The node may have changed, recompute the \"pretty\" impl name.\n         ItemKind::Impl(_, _, _, ref maybe_trait, ref ty, _) => {\n-            ast_util::impl_pretty_name(maybe_trait, Some(&**ty))\n+            ast_util::impl_pretty_name(maybe_trait, Some(&ty))\n         }\n         _ => ident\n     };"}, {"sha": "aaa6f79cb188adcd7769e1fdceca72dd18565639", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c877d61b15bf0098d7dfbde3e74052a3559ad028", "patch": "@@ -606,8 +606,8 @@ pub fn integer_lit(s: &str,\n                 2 => sd.span_err(sp, \"binary float literal is not supported\"),\n                 _ => ()\n             }\n-            let ident = token::intern_and_get_ident(&*s);\n-            return filtered_float_lit(ident, Some(&**suf), sd, sp)\n+            let ident = token::intern_and_get_ident(&s);\n+            return filtered_float_lit(ident, Some(&suf), sd, sp)\n         }\n     }\n \n@@ -990,24 +990,24 @@ mod tests {\n     #[test] fn parse_use() {\n         let use_s = \"use foo::bar::baz;\";\n         let vitem = string_to_item(use_s.to_string()).unwrap();\n-        let vitem_s = item_to_string(&*vitem);\n+        let vitem_s = item_to_string(&vitem);\n         assert_eq!(&vitem_s[..], use_s);\n \n         let use_s = \"use foo::bar as baz;\";\n         let vitem = string_to_item(use_s.to_string()).unwrap();\n-        let vitem_s = item_to_string(&*vitem);\n+        let vitem_s = item_to_string(&vitem);\n         assert_eq!(&vitem_s[..], use_s);\n     }\n \n     #[test] fn parse_extern_crate() {\n         let ex_s = \"extern crate foo;\";\n         let vitem = string_to_item(ex_s.to_string()).unwrap();\n-        let vitem_s = item_to_string(&*vitem);\n+        let vitem_s = item_to_string(&vitem);\n         assert_eq!(&vitem_s[..], ex_s);\n \n         let ex_s = \"extern crate foo as bar;\";\n         let vitem = string_to_item(ex_s.to_string()).unwrap();\n-        let vitem_s = item_to_string(&*vitem);\n+        let vitem_s = item_to_string(&vitem);\n         assert_eq!(&vitem_s[..], ex_s);\n     }\n \n@@ -1030,7 +1030,7 @@ mod tests {\n             }\n         }\n         let mut v = PatIdentVisitor { spans: Vec::new() };\n-        ::visit::walk_item(&mut v, &*item);\n+        ::visit::walk_item(&mut v, &item);\n         return v.spans;\n     }\n "}, {"sha": "1e1877ec6ae0ace68d0a984b4d8885aaa1b6e23e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c877d61b15bf0098d7dfbde3e74052a3559ad028", "patch": "@@ -444,7 +444,7 @@ impl<'a> Parser<'a> {\n                 } else {\n                     b.push_str(\", \");\n                 }\n-                b.push_str(&*a.to_string());\n+                b.push_str(&a.to_string());\n                 b\n             })\n         }\n@@ -696,7 +696,7 @@ impl<'a> Parser<'a> {\n                 if text.is_empty() {\n                     self.span_bug(sp, \"found empty literal suffix in Some\")\n                 }\n-                self.span_err(sp, &*format!(\"{} with a suffix is invalid\", kind));\n+                self.span_err(sp, &format!(\"{} with a suffix is invalid\", kind));\n             }\n         }\n     }\n@@ -1574,7 +1574,7 @@ impl<'a> Parser<'a> {\n \n                 if suffix_illegal {\n                     let sp = self.last_span;\n-                    self.expect_no_suffix(sp, &*format!(\"{} literal\", lit.short_name()), suf)\n+                    self.expect_no_suffix(sp, &format!(\"{} literal\", lit.short_name()), suf)\n                 }\n \n                 Ok(out)\n@@ -2083,7 +2083,7 @@ impl<'a> Parser<'a> {\n                 let mut trailing_comma = false;\n                 while self.token != token::CloseDelim(token::Paren) {\n                     es.push(try!(self.parse_expr()));\n-                    try!(self.commit_expr(&**es.last().unwrap(), &[],\n+                    try!(self.commit_expr(&es.last().unwrap(), &[],\n                                      &[token::Comma, token::CloseDelim(token::Paren)]));\n                     if self.check(&token::Comma) {\n                         trailing_comma = true;\n@@ -2295,7 +2295,7 @@ impl<'a> Parser<'a> {\n                                 }\n \n                                 fields.push(try!(self.parse_field()));\n-                                try!(self.commit_expr(&*fields.last().unwrap().expr,\n+                                try!(self.commit_expr(&fields.last().unwrap().expr,\n                                                  &[token::Comma],\n                                                  &[token::CloseDelim(token::Brace)]));\n                             }\n@@ -2508,7 +2508,7 @@ impl<'a> Parser<'a> {\n                 }\n                 continue;\n             }\n-            if self.expr_is_complete(&*e) { break; }\n+            if self.expr_is_complete(&e) { break; }\n             match self.token {\n               // expr(...)\n               token::OpenDelim(token::Paren) => {\n@@ -2530,7 +2530,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 let ix = try!(self.parse_expr());\n                 hi = self.span.hi;\n-                try!(self.commit_expr_expecting(&*ix, token::CloseDelim(token::Bracket)));\n+                try!(self.commit_expr_expecting(&ix, token::CloseDelim(token::Bracket)));\n                 let index = self.mk_index(e, ix);\n                 e = self.mk_expr(lo, hi, index, None)\n               }\n@@ -2820,7 +2820,7 @@ impl<'a> Parser<'a> {\n         };\n \n \n-        if self.expr_is_complete(&*lhs) {\n+        if self.expr_is_complete(&lhs) {\n             // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n             return Ok(lhs);\n         }\n@@ -2844,7 +2844,7 @@ impl<'a> Parser<'a> {\n             }\n             self.bump();\n             if op.is_comparison() {\n-                self.check_no_chained_comparison(&*lhs, &op);\n+                self.check_no_chained_comparison(&lhs, &op);\n             }\n             // Special cases:\n             if op == AssocOp::As {\n@@ -3152,7 +3152,7 @@ impl<'a> Parser<'a> {\n         let lo = self.last_span.lo;\n         let discriminant = try!(self.parse_expr_res(\n             Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n-        if let Err(mut e) = self.commit_expr_expecting(&*discriminant,\n+        if let Err(mut e) = self.commit_expr_expecting(&discriminant,\n                                                        token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n                 e.span_note(match_span, \"did you mean to remove this `match` keyword?\");\n@@ -3183,11 +3183,11 @@ impl<'a> Parser<'a> {\n         let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR, None));\n \n         let require_comma =\n-            !classify::expr_is_simple_block(&*expr)\n+            !classify::expr_is_simple_block(&expr)\n             && self.token != token::CloseDelim(token::Brace);\n \n         if require_comma {\n-            try!(self.commit_expr(&*expr, &[token::Comma], &[token::CloseDelim(token::Brace)]));\n+            try!(self.commit_expr(&expr, &[token::Comma], &[token::CloseDelim(token::Brace)]));\n         } else {\n             self.eat(&token::Comma);\n         }\n@@ -3936,7 +3936,7 @@ impl<'a> Parser<'a> {\n             stmts: &mut Vec<Stmt>,\n             last_block_expr: &mut Option<P<Expr>>) -> PResult<'a, ()> {\n         // expression without semicolon\n-        if classify::expr_requires_semi_to_be_stmt(&*e) {\n+        if classify::expr_requires_semi_to_be_stmt(&e) {\n             // Just check for errors and recover; do not eat semicolon yet.\n             try!(self.commit_stmt(&[],\n                              &[token::Semi, token::CloseDelim(token::Brace)]));\n@@ -4861,7 +4861,7 @@ impl<'a> Parser<'a> {\n                 impl_items.push(try!(self.parse_impl_item()));\n             }\n \n-            Ok((ast_util::impl_pretty_name(&opt_trait, Some(&*ty)),\n+            Ok((ast_util::impl_pretty_name(&opt_trait, Some(&ty)),\n              ItemKind::Impl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n              Some(attrs)))\n         }\n@@ -5075,7 +5075,7 @@ impl<'a> Parser<'a> {\n         let ty = try!(self.parse_ty_sum());\n         try!(self.expect(&token::Eq));\n         let e = try!(self.parse_expr());\n-        try!(self.commit_expr_expecting(&*e, token::Semi));\n+        try!(self.commit_expr_expecting(&e, token::Semi));\n         let item = match m {\n             Some(m) => ItemKind::Static(ty, m, e),\n             None => ItemKind::Const(ty, e),"}, {"sha": "accbb54c629b243220c4bdb33caa5f39349af5b4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=c877d61b15bf0098d7dfbde3e74052a3559ad028", "patch": "@@ -666,7 +666,7 @@ impl InternedString {\n impl Deref for InternedString {\n     type Target = str;\n \n-    fn deref(&self) -> &str { &*self.string }\n+    fn deref(&self) -> &str { &self.string }\n }\n \n impl fmt::Debug for InternedString {"}, {"sha": "2eb719627da50dad109bbbaeccb6f2c6263569c4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 133, "deletions": 133, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c877d61b15bf0098d7dfbde3e74052a3559ad028", "patch": "@@ -286,22 +286,22 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::SpecialVarNt(var)    => format!(\"${}\", var.as_str()),\n \n         token::Interpolated(ref nt) => match *nt {\n-            token::NtExpr(ref e)        => expr_to_string(&**e),\n-            token::NtMeta(ref e)        => meta_item_to_string(&**e),\n-            token::NtTy(ref e)          => ty_to_string(&**e),\n-            token::NtPath(ref e)        => path_to_string(&**e),\n-            token::NtItem(ref e)        => item_to_string(&**e),\n-            token::NtBlock(ref e)       => block_to_string(&**e),\n-            token::NtStmt(ref e)        => stmt_to_string(&**e),\n-            token::NtPat(ref e)         => pat_to_string(&**e),\n+            token::NtExpr(ref e)        => expr_to_string(&e),\n+            token::NtMeta(ref e)        => meta_item_to_string(&e),\n+            token::NtTy(ref e)          => ty_to_string(&e),\n+            token::NtPath(ref e)        => path_to_string(&e),\n+            token::NtItem(ref e)        => item_to_string(&e),\n+            token::NtBlock(ref e)       => block_to_string(&e),\n+            token::NtStmt(ref e)        => stmt_to_string(&e),\n+            token::NtPat(ref e)         => pat_to_string(&e),\n             token::NtIdent(ref e, _)    => ident_to_string(e.node),\n-            token::NtTT(ref e)          => tt_to_string(&**e),\n-            token::NtArm(ref e)         => arm_to_string(&*e),\n-            token::NtImplItem(ref e)    => impl_item_to_string(&**e),\n-            token::NtTraitItem(ref e)   => trait_item_to_string(&**e),\n-            token::NtGenerics(ref e)    => generics_to_string(&*e),\n-            token::NtWhereClause(ref e) => where_clause_to_string(&*e),\n-            token::NtArg(ref e)         => arg_to_string(&*e),\n+            token::NtTT(ref e)          => tt_to_string(&e),\n+            token::NtArm(ref e)         => arm_to_string(&e),\n+            token::NtImplItem(ref e)    => impl_item_to_string(&e),\n+            token::NtTraitItem(ref e)   => trait_item_to_string(&e),\n+            token::NtGenerics(ref e)    => generics_to_string(&e),\n+            token::NtWhereClause(ref e) => where_clause_to_string(&e),\n+            token::NtArg(ref e)         => arg_to_string(&e),\n         }\n     }\n }\n@@ -758,7 +758,7 @@ pub trait PrintState<'a> {\n                 ast::AttrStyle::Inner => try!(word(self.writer(), \"#![\")),\n                 ast::AttrStyle::Outer => try!(word(self.writer(), \"#[\")),\n             }\n-            try!(self.print_meta_item(&*attr.meta()));\n+            try!(self.print_meta_item(&attr.meta()));\n             word(self.writer(), \"]\")\n         }\n     }\n@@ -779,7 +779,7 @@ pub trait PrintState<'a> {\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n                                    &items[..],\n-                                   |s, i| s.print_meta_item(&**i)));\n+                                   |s, i| s.print_meta_item(&i)));\n                 try!(self.pclose());\n             }\n         }\n@@ -923,14 +923,14 @@ impl<'a> State<'a> {\n \n     pub fn commasep_exprs(&mut self, b: Breaks,\n                           exprs: &[P<ast::Expr>]) -> io::Result<()> {\n-        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&**e), |e| e.span)\n+        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&e), |e| e.span)\n     }\n \n     pub fn print_mod(&mut self, _mod: &ast::Mod,\n                      attrs: &[ast::Attribute]) -> io::Result<()> {\n         try!(self.print_inner_attributes(attrs));\n         for item in &_mod.items {\n-            try!(self.print_item(&**item));\n+            try!(self.print_item(&item));\n         }\n         Ok(())\n     }\n@@ -959,7 +959,7 @@ impl<'a> State<'a> {\n         match ty.node {\n             ast::TyKind::Vec(ref ty) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::TyKind::Ptr(ref mt) => {\n@@ -968,7 +968,7 @@ impl<'a> State<'a> {\n                     ast::Mutability::Mutable => try!(self.word_nbsp(\"mut\")),\n                     ast::Mutability::Immutable => try!(self.word_nbsp(\"const\")),\n                 }\n-                try!(self.print_type(&*mt.ty));\n+                try!(self.print_type(&mt.ty));\n             }\n             ast::TyKind::Rptr(ref lifetime, ref mt) => {\n                 try!(word(&mut self.s, \"&\"));\n@@ -978,15 +978,15 @@ impl<'a> State<'a> {\n             ast::TyKind::Tup(ref elts) => {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent, &elts[..],\n-                                   |s, ty| s.print_type(&**ty)));\n+                                   |s, ty| s.print_type(&ty)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n             ast::TyKind::Paren(ref typ) => {\n                 try!(self.popen());\n-                try!(self.print_type(&**typ));\n+                try!(self.print_type(&typ));\n                 try!(self.pclose());\n             }\n             ast::TyKind::BareFn(ref f) => {\n@@ -1000,7 +1000,7 @@ impl<'a> State<'a> {\n                 };\n                 try!(self.print_ty_fn(f.abi,\n                                       f.unsafety,\n-                                      &*f.decl,\n+                                      &f.decl,\n                                       None,\n                                       &generics,\n                                       None));\n@@ -1012,22 +1012,22 @@ impl<'a> State<'a> {\n                 try!(self.print_qpath(path, qself, false))\n             }\n             ast::TyKind::ObjectSum(ref ty, ref bounds) => {\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(self.print_bounds(\"+\", &bounds[..]));\n             }\n             ast::TyKind::PolyTraitRef(ref bounds) => {\n                 try!(self.print_bounds(\"\", &bounds[..]));\n             }\n             ast::TyKind::FixedLengthVec(ref ty, ref v) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(word(&mut self.s, \"; \"));\n-                try!(self.print_expr(&**v));\n+                try!(self.print_expr(&v));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::TyKind::Typeof(ref e) => {\n                 try!(word(&mut self.s, \"typeof(\"));\n-                try!(self.print_expr(&**e));\n+                try!(self.print_expr(&e));\n                 try!(word(&mut self.s, \")\"));\n             }\n             ast::TyKind::Infer => {\n@@ -1064,7 +1064,7 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**t));\n+                try!(self.print_type(&t));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the head-ibox\n                 self.end() // end the outer cbox\n@@ -1139,7 +1139,7 @@ impl<'a> State<'a> {\n             ast::ItemKind::Use(ref vp) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                      \"use\")));\n-                try!(self.print_view_path(&**vp));\n+                try!(self.print_view_path(&vp));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end inner head-block\n                 try!(self.end()); // end outer head-block\n@@ -1152,12 +1152,12 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(space(&mut self.s));\n                 try!(self.end()); // end the head-ibox\n \n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n@@ -1166,12 +1166,12 @@ impl<'a> State<'a> {\n                                                     \"const\")));\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(space(&mut self.s));\n                 try!(self.end()); // end the head-ibox\n \n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n@@ -1188,7 +1188,7 @@ impl<'a> State<'a> {\n                     item.vis\n                 ));\n                 try!(word(&mut self.s, \" \"));\n-                try!(self.print_block_with_attrs(&**body, &item.attrs));\n+                try!(self.print_block_with_attrs(&body, &item.attrs));\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n@@ -1217,7 +1217,7 @@ impl<'a> State<'a> {\n                 try!(self.print_where_clause(&params.where_clause));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer ibox\n             }\n@@ -1279,7 +1279,7 @@ impl<'a> State<'a> {\n                     None => {}\n                 }\n \n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(self.print_where_clause(&generics.where_clause));\n \n                 try!(space(&mut self.s));\n@@ -1412,7 +1412,7 @@ impl<'a> State<'a> {\n                             ast::UnnamedField(vis) => {\n                                 try!(s.print_visibility(vis));\n                                 try!(s.maybe_print_comment(field.span.lo));\n-                                s.print_type(&*field.node.ty)\n+                                s.print_type(&field.node.ty)\n                             }\n                         }\n                     }\n@@ -1441,7 +1441,7 @@ impl<'a> State<'a> {\n                         try!(self.print_visibility(visibility));\n                         try!(self.print_ident(ident));\n                         try!(self.word_nbsp(\":\"));\n-                        try!(self.print_type(&*field.node.ty));\n+                        try!(self.print_type(&field.node.ty));\n                         try!(word(&mut self.s, \",\"));\n                     }\n                 }\n@@ -1524,7 +1524,7 @@ impl<'a> State<'a> {\n             Some(ref d) => {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                self.print_expr(&**d)\n+                self.print_expr(&d)\n             }\n             _ => Ok(())\n         }\n@@ -1614,15 +1614,15 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n             ast::StmtKind::Decl(ref decl, _) => {\n-                try!(self.print_decl(&**decl));\n+                try!(self.print_decl(&decl));\n             }\n             ast::StmtKind::Expr(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr_outer_attr_style(&**expr, false));\n+                try!(self.print_expr_outer_attr_style(&expr, false));\n             }\n             ast::StmtKind::Semi(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr_outer_attr_style(&**expr, false));\n+                try!(self.print_expr_outer_attr_style(&expr, false));\n                 try!(word(&mut self.s, \";\"));\n             }\n             ast::StmtKind::Mac(ref mac, style, ref attrs) => {\n@@ -1632,7 +1632,7 @@ impl<'a> State<'a> {\n                     ast::MacStmtStyle::Braces => token::Brace,\n                     _ => token::Paren\n                 };\n-                try!(self.print_mac(&**mac, delim));\n+                try!(self.print_mac(&mac, delim));\n                 match style {\n                     ast::MacStmtStyle::Braces => {}\n                     _ => try!(word(&mut self.s, \";\")),\n@@ -1691,7 +1691,7 @@ impl<'a> State<'a> {\n         match blk.expr {\n             Some(ref expr) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr_outer_attr_style(&**expr, false));\n+                try!(self.print_expr_outer_attr_style(&expr, false));\n                 try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n             }\n             _ => ()\n@@ -1709,30 +1709,30 @@ impl<'a> State<'a> {\n                         try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if \"));\n-                        try!(self.print_expr(&**i));\n+                        try!(self.print_expr(&i));\n                         try!(space(&mut self.s));\n-                        try!(self.print_block(&**then));\n+                        try!(self.print_block(&then));\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"another else-if-let\"\n                     ast::ExprKind::IfLet(ref pat, ref expr, ref then, ref e) => {\n                         try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if let \"));\n-                        try!(self.print_pat(&**pat));\n+                        try!(self.print_pat(&pat));\n                         try!(space(&mut self.s));\n                         try!(self.word_space(\"=\"));\n-                        try!(self.print_expr(&**expr));\n+                        try!(self.print_expr(&expr));\n                         try!(space(&mut self.s));\n-                        try!(self.print_block(&**then));\n+                        try!(self.print_block(&then));\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n                     ast::ExprKind::Block(ref b) => {\n                         try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else \"));\n-                        self.print_block(&**b)\n+                        self.print_block(&b)\n                     }\n                     // BLEAH, constraints would be great here\n                     _ => {\n@@ -1867,7 +1867,7 @@ impl<'a> State<'a> {\n                 try!(s.ibox(INDENT_UNIT));\n                 try!(s.print_ident(field.ident.node));\n                 try!(s.word_space(\":\"));\n-                try!(s.print_expr(&*field.expr));\n+                try!(s.print_expr(&field.expr));\n                 s.end()\n             },\n             |f| f.span));\n@@ -1879,7 +1879,7 @@ impl<'a> State<'a> {\n                     try!(space(&mut self.s));\n                 }\n                 try!(word(&mut self.s, \"..\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(self.end());\n             }\n             _ => if !fields.is_empty() {\n@@ -1913,13 +1913,13 @@ impl<'a> State<'a> {\n                               tys: &[P<ast::Ty>],\n                               args: &[P<ast::Expr>]) -> io::Result<()> {\n         let base_args = &args[1..];\n-        try!(self.print_expr(&*args[0]));\n+        try!(self.print_expr(&args[0]));\n         try!(word(&mut self.s, \".\"));\n         try!(self.print_ident(ident.node));\n         if !tys.is_empty() {\n             try!(word(&mut self.s, \"::<\"));\n             try!(self.commasep(Inconsistent, tys,\n-                               |s, ty| s.print_type(&**ty)));\n+                               |s, ty| s.print_type(&ty)));\n             try!(word(&mut self.s, \">\"));\n         }\n         self.print_call_post(base_args)\n@@ -1988,7 +1988,7 @@ impl<'a> State<'a> {\n                 try!(self.print_expr_vec(&exprs[..], attrs));\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n-                try!(self.print_expr_repeat(&**element, &**count, attrs));\n+                try!(self.print_expr_repeat(&element, &count, attrs));\n             }\n             ast::ExprKind::Struct(ref path, ref fields, ref wth) => {\n                 try!(self.print_expr_struct(path, &fields[..], wth, attrs));\n@@ -1997,79 +1997,79 @@ impl<'a> State<'a> {\n                 try!(self.print_expr_tup(&exprs[..], attrs));\n             }\n             ast::ExprKind::Call(ref func, ref args) => {\n-                try!(self.print_expr_call(&**func, &args[..]));\n+                try!(self.print_expr_call(&func, &args[..]));\n             }\n             ast::ExprKind::MethodCall(ident, ref tys, ref args) => {\n                 try!(self.print_expr_method_call(ident, &tys[..], &args[..]));\n             }\n             ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                try!(self.print_expr_binary(op, &**lhs, &**rhs));\n+                try!(self.print_expr_binary(op, &lhs, &rhs));\n             }\n             ast::ExprKind::Unary(op, ref expr) => {\n-                try!(self.print_expr_unary(op, &**expr));\n+                try!(self.print_expr_unary(op, &expr));\n             }\n             ast::ExprKind::AddrOf(m, ref expr) => {\n-                try!(self.print_expr_addr_of(m, &**expr));\n+                try!(self.print_expr_addr_of(m, &expr));\n             }\n             ast::ExprKind::Lit(ref lit) => {\n-                try!(self.print_literal(&**lit));\n+                try!(self.print_literal(&lit));\n             }\n             ast::ExprKind::Cast(ref expr, ref ty) => {\n                 if let ast::ExprKind::Cast(..) = expr.node {\n-                    try!(self.print_expr(&**expr));\n+                    try!(self.print_expr(&expr));\n                 } else {\n-                    try!(self.print_expr_maybe_paren(&**expr));\n+                    try!(self.print_expr_maybe_paren(&expr));\n                 }\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"as\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n             }\n             ast::ExprKind::Type(ref expr, ref ty) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n             }\n             ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                try!(self.print_if(&**test, &**blk, elseopt.as_ref().map(|e| &**e)));\n+                try!(self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e)));\n             }\n             ast::ExprKind::IfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n-                try!(self.print_if_let(&**pat, &**expr, &** blk, elseopt.as_ref().map(|e| &**e)));\n+                try!(self.print_if_let(&pat, &expr, &blk, elseopt.as_ref().map(|e| &**e)));\n             }\n             ast::ExprKind::While(ref test, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"while\"));\n-                try!(self.print_expr(&**test));\n+                try!(self.print_expr(&test));\n                 try!(space(&mut self.s));\n-                try!(self.print_block_with_attrs(&**blk, attrs));\n+                try!(self.print_block_with_attrs(&blk, attrs));\n             }\n             ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"while let\"));\n-                try!(self.print_pat(&**pat));\n+                try!(self.print_pat(&pat));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(space(&mut self.s));\n-                try!(self.print_block_with_attrs(&**blk, attrs));\n+                try!(self.print_block_with_attrs(&blk, attrs));\n             }\n             ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"for\"));\n-                try!(self.print_pat(&**pat));\n+                try!(self.print_pat(&pat));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"in\"));\n-                try!(self.print_expr(&**iter));\n+                try!(self.print_expr(&iter));\n                 try!(space(&mut self.s));\n-                try!(self.print_block_with_attrs(&**blk, attrs));\n+                try!(self.print_block_with_attrs(&blk, attrs));\n             }\n             ast::ExprKind::Loop(ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n@@ -2078,13 +2078,13 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.head(\"loop\"));\n                 try!(space(&mut self.s));\n-                try!(self.print_block_with_attrs(&**blk, attrs));\n+                try!(self.print_block_with_attrs(&blk, attrs));\n             }\n             ast::ExprKind::Match(ref expr, ref arms) => {\n                 try!(self.cbox(INDENT_UNIT));\n                 try!(self.ibox(4));\n                 try!(self.word_nbsp(\"match\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n                 try!(self.print_inner_attributes_no_trailing_hardbreak(attrs));\n@@ -2096,7 +2096,7 @@ impl<'a> State<'a> {\n             ast::ExprKind::Closure(capture_clause, ref decl, ref body) => {\n                 try!(self.print_capture_clause(capture_clause));\n \n-                try!(self.print_fn_block_args(&**decl));\n+                try!(self.print_fn_block_args(&decl));\n                 try!(space(&mut self.s));\n \n                 let default_return = match decl.output {\n@@ -2105,19 +2105,19 @@ impl<'a> State<'a> {\n                 };\n \n                 if !default_return || !body.stmts.is_empty() || body.expr.is_none() {\n-                    try!(self.print_block_unclosed(&**body));\n+                    try!(self.print_block_unclosed(&body));\n                 } else {\n                     // we extract the block, so as not to create another set of boxes\n                     let i_expr = body.expr.as_ref().unwrap();\n                     match i_expr.node {\n                         ast::ExprKind::Block(ref blk) => {\n                             try!(self.print_block_unclosed_with_attrs(\n-                                &**blk,\n+                                &blk,\n                                 i_expr.attrs.as_attr_slice()));\n                         }\n                         _ => {\n                             // this is a bare expression\n-                            try!(self.print_expr(&**i_expr));\n+                            try!(self.print_expr(&i_expr));\n                             try!(self.end()); // need to close a box\n                         }\n                     }\n@@ -2132,44 +2132,44 @@ impl<'a> State<'a> {\n                 try!(self.cbox(INDENT_UNIT));\n                 // head-box, will be closed by print-block after {\n                 try!(self.ibox(0));\n-                try!(self.print_block_with_attrs(&**blk, attrs));\n+                try!(self.print_block_with_attrs(&blk, attrs));\n             }\n             ast::ExprKind::Assign(ref lhs, ref rhs) => {\n-                try!(self.print_expr(&**lhs));\n+                try!(self.print_expr(&lhs));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**rhs));\n+                try!(self.print_expr(&rhs));\n             }\n             ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                try!(self.print_expr(&**lhs));\n+                try!(self.print_expr(&lhs));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, op.node.to_string()));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**rhs));\n+                try!(self.print_expr(&rhs));\n             }\n             ast::ExprKind::Field(ref expr, id) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_ident(id.node));\n             }\n             ast::ExprKind::TupField(ref expr, id) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_usize(id.node));\n             }\n             ast::ExprKind::Index(ref expr, ref index) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_expr(&**index));\n+                try!(self.print_expr(&index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::ExprKind::Range(ref start, ref end) => {\n                 if let &Some(ref e) = start {\n-                    try!(self.print_expr(&**e));\n+                    try!(self.print_expr(&e));\n                 }\n                 try!(word(&mut self.s, \"..\"));\n                 if let &Some(ref e) = end {\n-                    try!(self.print_expr(&**e));\n+                    try!(self.print_expr(&e));\n                 }\n             }\n             ast::ExprKind::Path(None, ref path) => {\n@@ -2199,7 +2199,7 @@ impl<'a> State<'a> {\n                 match *result {\n                     Some(ref expr) => {\n                         try!(word(&mut self.s, \" \"));\n-                        try!(self.print_expr(&**expr));\n+                        try!(self.print_expr(&expr));\n                     }\n                     _ => ()\n                 }\n@@ -2220,7 +2220,7 @@ impl<'a> State<'a> {\n                         _ => try!(s.print_string(&out.constraint, ast::StrStyle::Cooked))\n                     }\n                     try!(s.popen());\n-                    try!(s.print_expr(&*out.expr));\n+                    try!(s.print_expr(&out.expr));\n                     try!(s.pclose());\n                     Ok(())\n                 }));\n@@ -2231,7 +2231,7 @@ impl<'a> State<'a> {\n                                    |s, &(ref co, ref o)| {\n                     try!(s.print_string(&co, ast::StrStyle::Cooked));\n                     try!(s.popen());\n-                    try!(s.print_expr(&**o));\n+                    try!(s.print_expr(&o));\n                     try!(s.pclose());\n                     Ok(())\n                 }));\n@@ -2258,7 +2258,7 @@ impl<'a> State<'a> {\n                 if !options.is_empty() {\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\":\"));\n-                    try!(self.commasep(Inconsistent, &*options,\n+                    try!(self.commasep(Inconsistent, &options,\n                                        |s, &co| {\n                         try!(s.print_string(co, ast::StrStyle::Cooked));\n                         Ok(())\n@@ -2271,7 +2271,7 @@ impl<'a> State<'a> {\n             ast::ExprKind::Paren(ref e) => {\n                 try!(self.popen());\n                 try!(self.print_inner_attributes_inline(attrs));\n-                try!(self.print_expr(&**e));\n+                try!(self.print_expr(&e));\n                 try!(self.pclose());\n             }\n         }\n@@ -2280,10 +2280,10 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_local_decl(&mut self, loc: &ast::Local) -> io::Result<()> {\n-        try!(self.print_pat(&*loc.pat));\n+        try!(self.print_pat(&loc.pat));\n         if let Some(ref ty) = loc.ty {\n             try!(self.word_space(\":\"));\n-            try!(self.print_type(&**ty));\n+            try!(self.print_type(&ty));\n         }\n         Ok(())\n     }\n@@ -2298,16 +2298,16 @@ impl<'a> State<'a> {\n                 try!(self.word_nbsp(\"let\"));\n \n                 try!(self.ibox(INDENT_UNIT));\n-                try!(self.print_local_decl(&**loc));\n+                try!(self.print_local_decl(&loc));\n                 try!(self.end());\n                 if let Some(ref init) = loc.init {\n                     try!(self.nbsp());\n                     try!(self.word_space(\"=\"));\n-                    try!(self.print_expr(&**init));\n+                    try!(self.print_expr(&init));\n                 }\n                 self.end()\n             }\n-            ast::DeclKind::Item(ref item) => self.print_item(&**item)\n+            ast::DeclKind::Item(ref item) => self.print_item(&item)\n         }\n     }\n \n@@ -2411,7 +2411,7 @@ impl<'a> State<'a> {\n                     try!(self.commasep(\n                         Inconsistent,\n                         &data.types,\n-                        |s, ty| s.print_type(&**ty)));\n+                        |s, ty| s.print_type(&ty)));\n                         comma = true;\n                 }\n \n@@ -2422,7 +2422,7 @@ impl<'a> State<'a> {\n                     try!(self.print_ident(binding.ident));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));\n-                    try!(self.print_type(&*binding.ty));\n+                    try!(self.print_type(&binding.ty));\n                     comma = true;\n                 }\n \n@@ -2434,15 +2434,15 @@ impl<'a> State<'a> {\n                 try!(self.commasep(\n                     Inconsistent,\n                     &data.inputs,\n-                    |s, ty| s.print_type(&**ty)));\n+                    |s, ty| s.print_type(&ty)));\n                 try!(word(&mut self.s, \")\"));\n \n                 match data.output {\n                     None => { }\n                     Some(ref ty) => {\n                         try!(self.space_if_not_bol());\n                         try!(self.word_space(\"->\"));\n-                        try!(self.print_type(&**ty));\n+                        try!(self.print_type(&ty));\n                     }\n                 }\n             }\n@@ -2473,7 +2473,7 @@ impl<'a> State<'a> {\n                 match *sub {\n                     Some(ref p) => {\n                         try!(word(&mut self.s, \"@\"));\n-                        try!(self.print_pat(&**p));\n+                        try!(self.print_pat(&p));\n                     }\n                     None => ()\n                 }\n@@ -2486,7 +2486,7 @@ impl<'a> State<'a> {\n                         if !args.is_empty() {\n                             try!(self.popen());\n                             try!(self.commasep(Inconsistent, &args[..],\n-                                              |s, p| s.print_pat(&**p)));\n+                                              |s, p| s.print_pat(&p)));\n                             try!(self.pclose());\n                         }\n                     }\n@@ -2507,7 +2507,7 @@ impl<'a> State<'a> {\n                             try!(s.print_ident(f.node.ident));\n                             try!(s.word_nbsp(\":\"));\n                         }\n-                        try!(s.print_pat(&*f.node.pat));\n+                        try!(s.print_pat(&f.node.pat));\n                         s.end()\n                     },\n                     |f| f.node.pat.span));\n@@ -2522,46 +2522,46 @@ impl<'a> State<'a> {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent,\n                                    &elts[..],\n-                                   |s, p| s.print_pat(&**p)));\n+                                   |s, p| s.print_pat(&p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n             ast::PatBox(ref inner) => {\n                 try!(word(&mut self.s, \"box \"));\n-                try!(self.print_pat(&**inner));\n+                try!(self.print_pat(&inner));\n             }\n             ast::PatRegion(ref inner, mutbl) => {\n                 try!(word(&mut self.s, \"&\"));\n                 if mutbl == ast::Mutability::Mutable {\n                     try!(word(&mut self.s, \"mut \"));\n                 }\n-                try!(self.print_pat(&**inner));\n+                try!(self.print_pat(&inner));\n             }\n-            ast::PatLit(ref e) => try!(self.print_expr(&**e)),\n+            ast::PatLit(ref e) => try!(self.print_expr(&e)),\n             ast::PatRange(ref begin, ref end) => {\n-                try!(self.print_expr(&**begin));\n+                try!(self.print_expr(&begin));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"...\"));\n-                try!(self.print_expr(&**end));\n+                try!(self.print_expr(&end));\n             }\n             ast::PatVec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.commasep(Inconsistent,\n                                    &before[..],\n-                                   |s, p| s.print_pat(&**p)));\n+                                   |s, p| s.print_pat(&p)));\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() { try!(self.word_space(\",\")); }\n                     if p.node != ast::PatWild {\n-                        try!(self.print_pat(&**p));\n+                        try!(self.print_pat(&p));\n                     }\n                     try!(word(&mut self.s, \"..\"));\n                     if !after.is_empty() { try!(self.word_space(\",\")); }\n                 }\n                 try!(self.commasep(Inconsistent,\n                                    &after[..],\n-                                   |s, p| s.print_pat(&**p)));\n+                                   |s, p| s.print_pat(&p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::PatMac(ref m) => try!(self.print_mac(m, token::Paren)),\n@@ -2586,20 +2586,20 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"|\"));\n             }\n-            try!(self.print_pat(&**p));\n+            try!(self.print_pat(&p));\n         }\n         try!(space(&mut self.s));\n         if let Some(ref e) = arm.guard {\n             try!(self.word_space(\"if\"));\n-            try!(self.print_expr(&**e));\n+            try!(self.print_expr(&e));\n             try!(space(&mut self.s));\n         }\n         try!(self.word_space(\"=>\"));\n \n         match arm.body.node {\n             ast::ExprKind::Block(ref blk) => {\n                 // the block will close the pattern's ibox\n-                try!(self.print_block_unclosed_indent(&**blk, INDENT_UNIT));\n+                try!(self.print_block_unclosed_indent(&blk, INDENT_UNIT));\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n@@ -2608,7 +2608,7 @@ impl<'a> State<'a> {\n             }\n             _ => {\n                 try!(self.end()); // close the ibox for the pattern\n-                try!(self.print_expr(&*arm.body));\n+                try!(self.print_expr(&arm.body));\n                 try!(word(&mut self.s, \",\"));\n             }\n         }\n@@ -2634,7 +2634,7 @@ impl<'a> State<'a> {\n             ast::SelfKind::Explicit(ref typ, _) => {\n                 try!(word(&mut self.s, \"self\"));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**typ));\n+                try!(self.print_type(&typ));\n             }\n         }\n         return Ok(true);\n@@ -2722,7 +2722,7 @@ impl<'a> State<'a> {\n         try!(self.word_space(\"->\"));\n         match decl.output {\n             ast::FunctionRetTy::Ty(ref ty) => {\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 self.maybe_print_comment(ty.span.lo)\n             }\n             ast::FunctionRetTy::Default(..) => unreachable!(),\n@@ -2834,7 +2834,7 @@ impl<'a> State<'a> {\n             Some(ref default) => {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                self.print_type(&**default)\n+                self.print_type(&default)\n             }\n             _ => Ok(())\n         }\n@@ -2860,7 +2860,7 @@ impl<'a> State<'a> {\n                                                                              ref bounds,\n                                                                              ..}) => {\n                     try!(self.print_formal_lifetime_list(bound_lifetimes));\n-                    try!(self.print_type(&**bounded_ty));\n+                    try!(self.print_type(&bounded_ty));\n                     try!(self.print_bounds(\":\", bounds));\n                 }\n                 ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n@@ -2881,7 +2881,7 @@ impl<'a> State<'a> {\n                     try!(self.print_path(path, false, 0));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));\n-                    try!(self.print_type(&**ty));\n+                    try!(self.print_type(&ty));\n                 }\n             }\n         }\n@@ -2953,13 +2953,13 @@ impl<'a> State<'a> {\n \n     pub fn print_mt(&mut self, mt: &ast::MutTy) -> io::Result<()> {\n         try!(self.print_mutability(mt.mutbl));\n-        self.print_type(&*mt.ty)\n+        self.print_type(&mt.ty)\n     }\n \n     pub fn print_arg(&mut self, input: &ast::Arg, is_closure: bool) -> io::Result<()> {\n         try!(self.ibox(INDENT_UNIT));\n         match input.ty.node {\n-            ast::TyKind::Infer if is_closure => try!(self.print_pat(&*input.pat)),\n+            ast::TyKind::Infer if is_closure => try!(self.print_pat(&input.pat)),\n             _ => {\n                 match input.pat.node {\n                     ast::PatIdent(_, ref path1, _) if\n@@ -2968,12 +2968,12 @@ impl<'a> State<'a> {\n                         // Do nothing.\n                     }\n                     _ => {\n-                        try!(self.print_pat(&*input.pat));\n+                        try!(self.print_pat(&input.pat));\n                         try!(word(&mut self.s, \":\"));\n                         try!(space(&mut self.s));\n                     }\n                 }\n-                try!(self.print_type(&*input.ty));\n+                try!(self.print_type(&input.ty));\n             }\n         }\n         self.end()\n@@ -2992,7 +2992,7 @@ impl<'a> State<'a> {\n                 try!(self.word_nbsp(\"!\")),\n             ast::FunctionRetTy::Default(..) => unreachable!(),\n             ast::FunctionRetTy::Ty(ref ty) =>\n-                try!(self.print_type(&**ty))\n+                try!(self.print_type(&ty))\n         }\n         try!(self.end());\n "}, {"sha": "fda9741d35c419285d9ea0961721a2c96983a6c9", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=c877d61b15bf0098d7dfbde3e74052a3559ad028", "patch": "@@ -87,7 +87,7 @@ impl<T> Deref for P<T> {\n     type Target = T;\n \n     fn deref<'a>(&'a self) -> &'a T {\n-        &*self.ptr\n+        &self.ptr\n     }\n }\n \n@@ -153,7 +153,7 @@ impl<T> P<[T]> {\n     }\n \n     pub fn as_slice<'a>(&'a self) -> &'a [T] {\n-        &*self.ptr\n+        &self.ptr\n     }\n \n     pub fn move_iter(self) -> vec::IntoIter<T> {"}, {"sha": "81b702e794d7737ef08f3652c231ba6f174e577c", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c877d61b15bf0098d7dfbde3e74052a3559ad028/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=c877d61b15bf0098d7dfbde3e74052a3559ad028", "patch": "@@ -123,7 +123,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(&self.cx.path));\n \n-        let i = if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n+        let i = if is_test_fn(&self.cx, &i) || is_bench_fn(&self.cx, &i) {\n             match i.node {\n                 ast::ItemKind::Fn(_, ast::Unsafety::Unsafe, _, _, _, _) => {\n                     let diag = self.cx.span_diagnostic;\n@@ -134,9 +134,9 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     let test = Test {\n                         span: i.span,\n                         path: self.cx.path.clone(),\n-                        bench: is_bench_fn(&self.cx, &*i),\n-                        ignore: is_ignored(&*i),\n-                        should_panic: should_panic(&*i)\n+                        bench: is_bench_fn(&self.cx, &i),\n+                        ignore: is_ignored(&i),\n+                        should_panic: should_panic(&i)\n                     };\n                     self.cx.testfns.push(test);\n                     self.tests.push(i.ident);\n@@ -205,7 +205,7 @@ impl fold::Folder for EntryPointCleaner {\n         // Remove any #[main] or #[start] from the AST so it doesn't\n         // clash with the one we're going to add, but mark it as\n         // #[allow(dead_code)] to avoid printing warnings.\n-        let folded = match entry::entry_point_type(&*folded, self.depth) {\n+        let folded = match entry::entry_point_type(&folded, self.depth) {\n             EntryPointType::MainNamed |\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n@@ -556,7 +556,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         })\n     });\n \n-    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&*item));\n+    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&item));\n \n     (item, reexport)\n }"}]}