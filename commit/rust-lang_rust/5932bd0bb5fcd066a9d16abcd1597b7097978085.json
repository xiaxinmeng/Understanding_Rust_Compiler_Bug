{"sha": "5932bd0bb5fcd066a9d16abcd1597b7097978085", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MzJiZDBiYjVmY2QwNjZhOWQxNmFiY2QxNTk3YjcwOTc5NzgwODU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-10-25T15:04:48Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-10-25T15:04:48Z"}, "message": "Merge #162\n\n162: Db everywhere r=matklad a=matklad\n\nThis PR continues our switch to salsa.\r\n\r\nNow *all* state is handled by a single salsa database.\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "7b6ea86855fe34c3d45d14262c8cf94e315566e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b6ea86855fe34c3d45d14262c8cf94e315566e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5932bd0bb5fcd066a9d16abcd1597b7097978085", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5932bd0bb5fcd066a9d16abcd1597b7097978085", "html_url": "https://github.com/rust-lang/rust/commit/5932bd0bb5fcd066a9d16abcd1597b7097978085", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5932bd0bb5fcd066a9d16abcd1597b7097978085/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "2cb2074c4b7219b32993abdcc7084637c0123d49", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cb2074c4b7219b32993abdcc7084637c0123d49", "html_url": "https://github.com/rust-lang/rust/commit/2cb2074c4b7219b32993abdcc7084637c0123d49"}, {"sha": "363adf07b7763cfe7e13fac0ee148361d51834e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/363adf07b7763cfe7e13fac0ee148361d51834e4", "html_url": "https://github.com/rust-lang/rust/commit/363adf07b7763cfe7e13fac0ee148361d51834e4"}], "stats": {"total": 734, "additions": 384, "deletions": 350}, "files": [{"sha": "ea4275e630508143eba40917d441a0703ee8cb63", "filename": "Cargo.lock", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -602,12 +602,13 @@ name = \"ra_analysis\"\n version = \"0.1.0\"\n dependencies = [\n  \"fst 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_editor 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"rayon 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"salsa 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"salsa 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"test_utils 0.1.0\",\n ]\n \n@@ -833,11 +834,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"salsa\"\n-version = \"0.6.0\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"derive-new 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"indexmap 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lock_api 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1348,7 +1350,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n \"checksum ryu 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7153dd96dade874ab973e098cb62fcdbb89a03682e46b144fd09550998d4a4a7\"\n \"checksum safemem 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8dca453248a96cb0749e36ccdfe2b0b4e54a61bfef89fb97ec621eb8e0a93dd9\"\n-\"checksum salsa 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6c8f8b59428c040fbac0f6a2e698ae892e33d23d7519713ba8b243edb3082dad\"\n+\"checksum salsa 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ba7fe802c02c7b0074b0b4794442d73e3c7d071967300a98bb0f5dfc25e9f1ef\"\n \"checksum same-file 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"10f7794e2fda7f594866840e95f5c5962e886e228e68b6505885811a94dd728c\"\n \"checksum scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94258f53601af11e6a49f722422f6e3425c52b06245a5cf9bc09908b174f5e27\"\n \"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\""}, {"sha": "5d7915fa5cbf14f265cb0b13083560e6be479d8f", "filename": "crates/ra_analysis/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2FCargo.toml?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -5,12 +5,13 @@ version = \"0.1.0\"\n authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n \n [dependencies]\n+log = \"0.4.5\"\n relative-path = \"0.4.0\"\n rayon = \"1.0.2\"\n fst = \"0.3.1\"\n ra_syntax = { path = \"../ra_syntax\" }\n ra_editor = { path = \"../ra_editor\" }\n-salsa = \"0.6.0\"\n+salsa = \"0.6.2\"\n rustc-hash = \"1.0\"\n \n [dev-dependencies]"}, {"sha": "0a2f99575583eaa0888310dc70a89df839ecfd8c", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -6,13 +6,15 @@ use ra_syntax::{\n \n use crate::{\n     FileId, Cancelable,\n+    input::FilesDatabase,\n     db::{self, SyntaxDatabase},\n     descriptors::module::{ModulesDatabase, ModuleTree, ModuleId},\n };\n \n pub(crate) fn resolve_based_completion(db: &db::RootDatabase, file_id: FileId, offset: TextUnit) -> Cancelable<Option<Vec<CompletionItem>>> {\n+    let source_root_id = db.file_source_root(file_id);\n     let file = db.file_syntax(file_id);\n-    let module_tree = db.module_tree()?;\n+    let module_tree = db.module_tree(source_root_id)?;\n     let file = {\n         let edit = AtomEdit::insert(offset, \"intellijRulezz\".to_string());\n         file.reparse(&edit)"}, {"sha": "3ca14af79d2261345c0b00997bcded3a4fbbe828", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 10, "deletions": 48, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -1,33 +1,24 @@\n use std::{\n-    fmt,\n-    hash::{Hash, Hasher},\n     sync::Arc,\n };\n \n use ra_editor::LineIndex;\n use ra_syntax::File;\n-use rustc_hash::FxHashSet;\n use salsa;\n \n use crate::{\n     db,\n     Cancelable, Canceled,\n     descriptors::module::{SubmodulesQuery, ModuleTreeQuery, ModulesDatabase},\n     symbol_index::SymbolIndex,\n-    FileId, FileResolverImp,\n+    FileId,\n };\n \n-#[derive(Default)]\n+#[derive(Default, Debug)]\n pub(crate) struct RootDatabase {\n     runtime: salsa::Runtime<RootDatabase>,\n }\n \n-impl fmt::Debug for RootDatabase {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt.write_str(\"RootDatabase { ... }\")\n-    }\n-}\n-\n impl salsa::Database for RootDatabase {\n     fn salsa_runtime(&self) -> &salsa::Runtime<RootDatabase> {\n         &self.runtime\n@@ -58,9 +49,13 @@ impl Clone for RootDatabase {\n \n salsa::database_storage! {\n     pub(crate) struct RootDatabaseStorage for RootDatabase {\n-        impl FilesDatabase {\n-            fn file_text() for FileTextQuery;\n-            fn file_set() for FileSetQuery;\n+        impl crate::input::FilesDatabase {\n+            fn file_text() for crate::input::FileTextQuery;\n+            fn file_source_root() for crate::input::FileSourceRootQuery;\n+            fn source_root() for crate::input::SourceRootQuery;\n+            fn libraries() for crate::input::LibrarieseQuery;\n+            fn library_symbols() for crate::input::LibrarySymbolsQuery;\n+            fn crate_graph() for crate::input::CrateGraphQuery;\n         }\n         impl SyntaxDatabase {\n             fn file_syntax() for FileSyntaxQuery;\n@@ -75,40 +70,7 @@ salsa::database_storage! {\n }\n \n salsa::query_group! {\n-    pub(crate) trait FilesDatabase: salsa::Database {\n-        fn file_text(file_id: FileId) -> Arc<String> {\n-            type FileTextQuery;\n-            storage input;\n-        }\n-        fn file_set() -> Arc<FileSet> {\n-            type FileSetQuery;\n-            storage input;\n-        }\n-    }\n-}\n-\n-#[derive(Default, Debug, Eq)]\n-pub(crate) struct FileSet {\n-    pub(crate) files: FxHashSet<FileId>,\n-    pub(crate) resolver: FileResolverImp,\n-}\n-\n-impl PartialEq for FileSet {\n-    fn eq(&self, other: &FileSet) -> bool {\n-        self.files == other.files && self.resolver == other.resolver\n-    }\n-}\n-\n-impl Hash for FileSet {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        let mut files = self.files.iter().cloned().collect::<Vec<_>>();\n-        files.sort();\n-        files.hash(hasher);\n-    }\n-}\n-\n-salsa::query_group! {\n-    pub(crate) trait SyntaxDatabase: FilesDatabase {\n+    pub(crate) trait SyntaxDatabase: crate::input::FilesDatabase {\n         fn file_syntax(file_id: FileId) -> File {\n             type FileSyntaxQuery;\n         }"}, {"sha": "aecf6e29af86da53c1fc2b860ab18c698ad60717", "filename": "crates/ra_analysis/src/descriptors/module/imp.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fimp.rs?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -8,8 +8,8 @@ use ra_syntax::{\n };\n \n use crate::{\n-    FileId, Cancelable, FileResolverImp,\n-    db,\n+    FileId, Cancelable, FileResolverImp, db,\n+    input::{SourceRoot, SourceRootId},\n };\n \n use super::{\n@@ -35,9 +35,12 @@ pub(super) fn modules(root: ast::Root<'_>) -> impl Iterator<Item = (SmolStr, ast\n     })\n }\n \n-pub(super) fn module_tree(db: &impl ModulesDatabase) -> Cancelable<Arc<ModuleTree>> {\n+pub(super) fn module_tree(\n+    db: &impl ModulesDatabase,\n+    source_root: SourceRootId,\n+) -> Cancelable<Arc<ModuleTree>> {\n     db::check_canceled(db)?;\n-    let res = create_module_tree(db)?;\n+    let res = create_module_tree(db, source_root)?;\n     Ok(Arc::new(res))\n }\n \n@@ -50,6 +53,7 @@ pub struct Submodule {\n \n fn create_module_tree<'a>(\n     db: &impl ModulesDatabase,\n+    source_root: SourceRootId,\n ) -> Cancelable<ModuleTree> {\n     let mut tree = ModuleTree {\n         mods: Vec::new(),\n@@ -59,19 +63,21 @@ fn create_module_tree<'a>(\n     let mut roots = FxHashMap::default();\n     let mut visited = FxHashSet::default();\n \n-    for &file_id in db.file_set().files.iter() {\n+    let source_root = db.source_root(source_root);\n+    for &file_id in source_root.files.iter() {\n         if visited.contains(&file_id) {\n             continue; // TODO: use explicit crate_roots here\n         }\n         assert!(!roots.contains_key(&file_id));\n-        let module_id = build_subtree(db, &mut tree, &mut visited, &mut roots, None, file_id)?;\n+        let module_id = build_subtree(db, &source_root, &mut tree, &mut visited, &mut roots, None, file_id)?;\n         roots.insert(file_id, module_id);\n     }\n     Ok(tree)\n }\n \n fn build_subtree(\n     db: &impl ModulesDatabase,\n+    source_root: &SourceRoot,\n     tree: &mut ModuleTree,\n     visited: &mut FxHashSet<FileId>,\n     roots: &mut FxHashMap<FileId, ModuleId>,\n@@ -84,10 +90,8 @@ fn build_subtree(\n         parent,\n         children: Vec::new(),\n     });\n-    let file_set = db.file_set();\n-    let file_resolver = &file_set.resolver;\n     for name in db.submodules(file_id)?.iter() {\n-        let (points_to, problem) = resolve_submodule(file_id, name, file_resolver);\n+        let (points_to, problem) = resolve_submodule(file_id, name, &source_root.file_resolver);\n         let link = tree.push_link(LinkData {\n             name: name.clone(),\n             owner: id,\n@@ -102,7 +106,7 @@ fn build_subtree(\n                     tree.module_mut(module_id).parent = Some(link);\n                     Ok(module_id)\n                 }\n-                None => build_subtree(db, tree, visited, roots, Some(link), file_id),\n+                None => build_subtree(db, source_root, tree, visited, roots, Some(link), file_id),\n             })\n             .collect::<Cancelable<Vec<_>>>()?;\n         tree.link_mut(link).points_to = points_to;"}, {"sha": "8968c4afdb2151fd4879fee8abca0bcf551f85bc", "filename": "crates/ra_analysis/src/descriptors/module/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fmod.rs?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -8,11 +8,12 @@ use ra_syntax::{ast::{self, NameOwner, AstNode}, SmolStr, SyntaxNode};\n use crate::{\n     FileId, Cancelable,\n     db::SyntaxDatabase,\n+    input::SourceRootId,\n };\n \n salsa::query_group! {\n     pub(crate) trait ModulesDatabase: SyntaxDatabase {\n-        fn module_tree() -> Cancelable<Arc<ModuleTree>> {\n+        fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n             type ModuleTreeQuery;\n             use fn imp::module_tree;\n         }\n@@ -110,15 +111,9 @@ impl ModuleId {\n }\n \n impl LinkId {\n-    pub(crate) fn name(self, tree: &ModuleTree) -> SmolStr {\n-        tree.link(self).name.clone()\n-    }\n     pub(crate) fn owner(self, tree: &ModuleTree) -> ModuleId {\n         tree.link(self).owner\n     }\n-    fn points_to(self, tree: &ModuleTree) -> &[ModuleId] {\n-        &tree.link(self).points_to\n-    }\n     pub(crate) fn bind_source<'a>(\n         self,\n         tree: &ModuleTree,"}, {"sha": "5a6e2450d979fe8b12e457775ee446e56c6a68a6", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 104, "deletions": 80, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -1,7 +1,5 @@\n use std::{\n-    fmt,\n     hash::{Hash, Hasher},\n-    iter,\n     sync::Arc,\n };\n \n@@ -14,12 +12,17 @@ use ra_syntax::{\n };\n use relative_path::RelativePath;\n use rustc_hash::FxHashSet;\n+use salsa::{ParallelDatabase, Database};\n \n use crate::{\n-    db::SyntaxDatabase,\n+    AnalysisChange,\n+    db::{\n+        self, SyntaxDatabase,\n+\n+    },\n+    input::{SourceRootId, FilesDatabase, SourceRoot, WORKSPACE},\n     descriptors::module::{ModulesDatabase, ModuleTree, Problem},\n     descriptors::{FnDescriptor},\n-    roots::{ReadonlySourceRoot, SourceRoot, WritableSourceRoot},\n     CrateGraph, CrateId, Diagnostic, FileId, FileResolver, FileSystemEdit, Position,\n     Query, SourceChange, SourceFileEdit, Cancelable,\n };\n@@ -80,96 +83,128 @@ impl Default for FileResolverImp {\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Default)]\n pub(crate) struct AnalysisHostImpl {\n-    data: WorldData,\n+    db: db::RootDatabase,\n }\n \n+\n impl AnalysisHostImpl {\n     pub fn new() -> AnalysisHostImpl {\n-        AnalysisHostImpl {\n-            data: WorldData::default(),\n-        }\n+        AnalysisHostImpl::default()\n     }\n     pub fn analysis(&self) -> AnalysisImpl {\n         AnalysisImpl {\n-            data: self.data.clone(),\n+            db: self.db.fork() // freeze revision here\n         }\n     }\n-    pub fn change_files(&mut self, changes: &mut dyn Iterator<Item = (FileId, Option<String>)>) {\n-        self.data_mut().root.apply_changes(changes, None);\n-    }\n-    pub fn set_file_resolver(&mut self, resolver: FileResolverImp) {\n-        self.data_mut()\n-            .root\n-            .apply_changes(&mut iter::empty(), Some(resolver));\n-    }\n-    pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n-        let mut visited = FxHashSet::default();\n-        for &file_id in graph.crate_roots.values() {\n-            if !visited.insert(file_id) {\n-                panic!(\"duplicate crate root: {:?}\", file_id);\n+    pub fn apply_change(&mut self, change: AnalysisChange) {\n+        log::info!(\"apply_change {:?}\", change);\n+\n+        for (file_id, text) in change.files_changed {\n+            self.db\n+                .query(crate::input::FileTextQuery)\n+                .set(file_id, Arc::new(text))\n+        }\n+        if !(change.files_added.is_empty() && change.files_removed.is_empty()) {\n+            let file_resolver = change.file_resolver\n+                .expect(\"change resolver when changing set of files\");\n+            let mut source_root = SourceRoot::clone(&self.db.source_root(WORKSPACE));\n+            for (file_id, text) in change.files_added {\n+                self.db\n+                    .query(crate::input::FileTextQuery)\n+                    .set(file_id, Arc::new(text));\n+                self.db\n+                    .query(crate::input::FileSourceRootQuery)\n+                    .set(file_id, crate::input::WORKSPACE);\n+                source_root.files.insert(file_id);\n+            }\n+            for file_id in change.files_removed {\n+                self.db\n+                    .query(crate::input::FileTextQuery)\n+                    .set(file_id, Arc::new(String::new()));\n+                source_root.files.remove(&file_id);\n             }\n+            source_root.file_resolver = file_resolver;\n+            self.db\n+                .query(crate::input::SourceRootQuery)\n+                .set(WORKSPACE, Arc::new(source_root))\n+        }\n+        if !change.libraries_added.is_empty() {\n+            let mut libraries = Vec::clone(&self.db.libraries());\n+            for library in change.libraries_added {\n+                let source_root_id = SourceRootId(1 + libraries.len() as u32);\n+                libraries.push(source_root_id);\n+                let mut files = FxHashSet::default();\n+                for (file_id, text) in library.files {\n+                    files.insert(file_id);\n+                    self.db\n+                        .query(crate::input::FileSourceRootQuery)\n+                        .set_constant(file_id, source_root_id);\n+                    self.db\n+                        .query(crate::input::FileTextQuery)\n+                        .set_constant(file_id, Arc::new(text));\n+                }\n+                let source_root = SourceRoot {\n+                    files,\n+                    file_resolver: library.file_resolver,\n+                };\n+                self.db\n+                    .query(crate::input::SourceRootQuery)\n+                    .set(source_root_id, Arc::new(source_root));\n+                self.db\n+                    .query(crate::input::LibrarySymbolsQuery)\n+                    .set(source_root_id, Arc::new(library.symbol_index));\n+            }\n+            self.db\n+                .query(crate::input::LibrarieseQuery)\n+                .set((), Arc::new(libraries));\n+        }\n+        if let Some(crate_graph) = change.crate_graph {\n+            self.db.query(crate::input::CrateGraphQuery)\n+                .set((), Arc::new(crate_graph))\n         }\n-        self.data_mut().crate_graph = graph;\n-    }\n-    pub fn add_library(&mut self, root: ReadonlySourceRoot) {\n-        self.data_mut().libs.push(root);\n-    }\n-    fn data_mut(&mut self) -> &mut WorldData {\n-        &mut self.data\n     }\n }\n \n+#[derive(Debug)]\n pub(crate) struct AnalysisImpl {\n-    data: WorldData,\n-}\n-\n-impl fmt::Debug for AnalysisImpl {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.data.fmt(f)\n-    }\n+    db: db::RootDatabase,\n }\n \n impl AnalysisImpl {\n-    fn root(&self, file_id: FileId) -> &SourceRoot {\n-        if self.data.root.contains(file_id) {\n-            return &self.data.root;\n-        }\n-        self\n-            .data\n-            .libs\n-            .iter()\n-            .find(|it| it.contains(file_id))\n-            .unwrap()\n-    }\n     pub fn file_syntax(&self, file_id: FileId) -> File {\n-        self.root(file_id).db().file_syntax(file_id)\n+        self.db.file_syntax(file_id)\n     }\n     pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n-        self.root(file_id).db().file_lines(file_id)\n+        self.db.file_lines(file_id)\n     }\n     pub fn world_symbols(&self, query: Query) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n         let mut buf = Vec::new();\n         if query.libs {\n-            for lib in self.data.libs.iter() {\n-                lib.symbols(&mut buf)?;\n+            for &lib_id in self.db.libraries().iter() {\n+                buf.push(self.db.library_symbols(lib_id));\n             }\n         } else {\n-            self.data.root.symbols(&mut buf)?;\n+            for &file_id in self.db.source_root(WORKSPACE).files.iter() {\n+                buf.push(self.db.file_symbols(file_id)?);\n+            }\n         }\n         Ok(query.search(&buf))\n     }\n+    fn module_tree(&self, file_id: FileId) -> Cancelable<Arc<ModuleTree>> {\n+        let source_root = self.db.file_source_root(file_id);\n+        self.db.module_tree(source_root)\n+    }\n     pub fn parent_module(&self, file_id: FileId) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let root = self.root(file_id);\n-        let module_tree = root.db().module_tree()?;\n+        let module_tree = self.module_tree(file_id)?;\n \n         let res = module_tree.modules_for_file(file_id)\n             .into_iter()\n             .filter_map(|module_id| {\n                 let link = module_id.parent_link(&module_tree)?;\n                 let file_id = link.owner(&module_tree).file_id(&module_tree);\n-                let syntax = root.db().file_syntax(file_id);\n+                let syntax = self.db.file_syntax(file_id);\n                 let decl = link.bind_source(&module_tree, syntax.ast());\n \n                 let sym = FileSymbol {\n@@ -183,8 +218,8 @@ impl AnalysisImpl {\n         Ok(res)\n     }\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        let module_tree = self.root(file_id).db().module_tree()?;\n-        let crate_graph = &self.data.crate_graph;\n+        let module_tree = self.module_tree(file_id)?;\n+        let crate_graph = self.db.crate_graph();\n         let res = module_tree.modules_for_file(file_id)\n             .into_iter()\n             .map(|it| it.root(&module_tree))\n@@ -195,7 +230,7 @@ impl AnalysisImpl {\n         Ok(res)\n     }\n     pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n-        self.data.crate_graph.crate_roots[&crate_id]\n+        self.db.crate_graph().crate_roots[&crate_id]\n     }\n     pub fn completions(&self, file_id: FileId, offset: TextUnit) -> Cancelable<Option<Vec<CompletionItem>>> {\n         let mut res = Vec::new();\n@@ -205,8 +240,7 @@ impl AnalysisImpl {\n             res.extend(scope_based);\n             has_completions = true;\n         }\n-        let root = self.root(file_id);\n-        if let Some(scope_based) = crate::completion::resolve_based_completion(root.db(), file_id, offset)? {\n+        if let Some(scope_based) = crate::completion::resolve_based_completion(&self.db, file_id, offset)? {\n             res.extend(scope_based);\n             has_completions = true;\n         }\n@@ -222,9 +256,8 @@ impl AnalysisImpl {\n         file_id: FileId,\n         offset: TextUnit,\n     ) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let root = self.root(file_id);\n-        let module_tree = root.db().module_tree()?;\n-        let file = root.db().file_syntax(file_id);\n+        let module_tree = self.module_tree(file_id)?;\n+        let file = self.db.file_syntax(file_id);\n         let syntax = file.syntax();\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, offset) {\n             // First try to resolve the symbol locally\n@@ -273,8 +306,7 @@ impl AnalysisImpl {\n     }\n \n     pub fn find_all_refs(&self, file_id: FileId, offset: TextUnit) -> Vec<(FileId, TextRange)> {\n-        let root = self.root(file_id);\n-        let file = root.db().file_syntax(file_id);\n+        let file = self.db.file_syntax(file_id);\n         let syntax = file.syntax();\n \n         let mut ret = vec![];\n@@ -305,9 +337,8 @@ impl AnalysisImpl {\n     }\n \n     pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n-        let root = self.root(file_id);\n-        let module_tree = root.db().module_tree()?;\n-        let syntax = root.db().file_syntax(file_id);\n+        let module_tree = self.module_tree(file_id)?;\n+        let syntax = self.db.file_syntax(file_id);\n \n         let mut res = ra_editor::diagnostics(&syntax)\n             .into_iter()\n@@ -396,8 +427,7 @@ impl AnalysisImpl {\n         file_id: FileId,\n         offset: TextUnit,\n     ) -> Cancelable<Option<(FnDescriptor, Option<usize>)>> {\n-        let root = self.root(file_id);\n-        let file = root.db().file_syntax(file_id);\n+        let file = self.db.file_syntax(file_id);\n         let syntax = file.syntax();\n \n         // Find the calling expression and it's NameRef\n@@ -412,9 +442,10 @@ impl AnalysisImpl {\n \n         // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n         let file_symbols = self.index_resolve(name_ref)?;\n-        for (_, fs) in file_symbols {\n+        for (fn_fiel_id, fs) in file_symbols {\n             if fs.kind == FN_DEF {\n-                if let Some(fn_def) = find_node_at_offset(syntax, fs.node_range.start()) {\n+                let fn_file = self.db.file_syntax(fn_fiel_id);\n+                if let Some(fn_def) = find_node_at_offset(fn_file.syntax(), fs.node_range.start()) {\n                     if let Some(descriptor) = FnDescriptor::new(fn_def) {\n                         // If we have a calling expression let's find which argument we are on\n                         let mut current_parameter = None;\n@@ -491,13 +522,6 @@ impl AnalysisImpl {\n     }\n }\n \n-#[derive(Default, Clone, Debug)]\n-struct WorldData {\n-    crate_graph: CrateGraph,\n-    root: WritableSourceRoot,\n-    libs: Vec<ReadonlySourceRoot>,\n-}\n-\n impl SourceChange {\n     pub(crate) fn from_local_edit(file_id: FileId, label: &str, edit: LocalEdit) -> SourceChange {\n         let file_edit = SourceFileEdit {"}, {"sha": "e64fad40cf4754ae7ca2c6ee98c10483e5f77804", "filename": "crates/ra_analysis/src/input.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Finput.rs?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -0,0 +1,79 @@\n+use std::{\n+    sync::Arc,\n+    fmt,\n+};\n+\n+use salsa;\n+use rustc_hash::FxHashSet;\n+use relative_path::RelativePath;\n+use rustc_hash::FxHashMap;\n+\n+use crate::{symbol_index::SymbolIndex, FileResolverImp};\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct FileId(pub u32);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct CrateId(pub u32);\n+\n+#[derive(Debug, Clone, Default, PartialEq, Eq)]\n+pub struct CrateGraph {\n+    pub(crate) crate_roots: FxHashMap<CrateId, FileId>,\n+}\n+\n+impl CrateGraph {\n+    pub fn new() -> CrateGraph {\n+        CrateGraph::default()\n+    }\n+    pub fn add_crate_root(&mut self, file_id: FileId) -> CrateId{\n+        let crate_id = CrateId(self.crate_roots.len() as u32);\n+        let prev = self.crate_roots.insert(crate_id, file_id);\n+        assert!(prev.is_none());\n+        crate_id\n+    }\n+}\n+\n+pub trait FileResolver: fmt::Debug + Send + Sync + 'static {\n+    fn file_stem(&self, file_id: FileId) -> String;\n+    fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId>;\n+}\n+\n+salsa::query_group! {\n+    pub(crate) trait FilesDatabase: salsa::Database {\n+        fn file_text(file_id: FileId) -> Arc<String> {\n+            type FileTextQuery;\n+            storage input;\n+        }\n+        fn file_source_root(file_id: FileId) -> SourceRootId {\n+            type FileSourceRootQuery;\n+            storage input;\n+        }\n+        fn source_root(id: SourceRootId) -> Arc<SourceRoot> {\n+            type SourceRootQuery;\n+            storage input;\n+        }\n+        fn libraries() -> Arc<Vec<SourceRootId>> {\n+            type LibrarieseQuery;\n+            storage input;\n+        }\n+        fn library_symbols(id: SourceRootId) -> Arc<SymbolIndex> {\n+            type LibrarySymbolsQuery;\n+            storage input;\n+        }\n+        fn crate_graph() -> Arc<CrateGraph> {\n+            type CrateGraphQuery;\n+            storage input;\n+        }\n+    }\n+}\n+\n+#[derive(Default, Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub(crate) struct SourceRootId(pub(crate) u32);\n+\n+#[derive(Clone, Default, Debug, PartialEq, Eq)]\n+pub(crate) struct SourceRoot {\n+    pub(crate) file_resolver: FileResolverImp,\n+    pub(crate) files: FxHashSet<FileId>,\n+}\n+\n+pub(crate) const WORKSPACE: SourceRootId = SourceRootId(0);"}, {"sha": "a67cac21ee930fa158301b5b36f3aea4712795a5", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 65, "deletions": 34, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -6,23 +6,30 @@ extern crate relative_path;\n extern crate rustc_hash;\n extern crate salsa;\n \n+mod input;\n mod db;\n mod descriptors;\n mod imp;\n-mod roots;\n mod symbol_index;\n mod completion;\n \n-use std::{fmt::Debug, sync::Arc};\n+use std::{\n+    fmt,\n+    sync::Arc,\n+};\n \n use ra_syntax::{AtomEdit, File, TextRange, TextUnit};\n-use relative_path::{RelativePath, RelativePathBuf};\n-use rustc_hash::FxHashMap;\n+use relative_path::RelativePathBuf;\n+use rayon::prelude::*;\n \n-use crate::imp::{AnalysisHostImpl, AnalysisImpl, FileResolverImp};\n+use crate::{\n+    imp::{AnalysisHostImpl, AnalysisImpl, FileResolverImp},\n+    symbol_index::SymbolIndex,\n+};\n \n pub use crate::{\n     descriptors::FnDescriptor,\n+    input::{FileId, FileResolver, CrateGraph, CrateId}\n };\n pub use ra_editor::{\n     CompletionItem, FileSymbol, Fold, FoldKind, HighlightedRange, LineIndex, Runnable,\n@@ -43,20 +50,52 @@ impl std::fmt::Display for Canceled {\n impl std::error::Error for Canceled {\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct FileId(pub u32);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct CrateId(pub u32);\n+#[derive(Default)]\n+pub struct AnalysisChange {\n+    files_added: Vec<(FileId, String)>,\n+    files_changed: Vec<(FileId, String)>,\n+    files_removed: Vec<(FileId)>,\n+    libraries_added: Vec<LibraryData>,\n+    crate_graph: Option<CrateGraph>,\n+    file_resolver: Option<FileResolverImp>,\n+}\n \n-#[derive(Debug, Clone, Default)]\n-pub struct CrateGraph {\n-    pub crate_roots: FxHashMap<CrateId, FileId>,\n+impl fmt::Debug for AnalysisChange {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt.debug_struct(\"AnalysisChange\")\n+            .field(\"files_added\", &self.files_added.len())\n+            .field(\"files_changed\", &self.files_changed.len())\n+            .field(\"files_removed\", &self.files_removed.len())\n+            .field(\"libraries_added\", &self.libraries_added.len())\n+            .field(\"crate_graph\", &self.crate_graph)\n+            .field(\"file_resolver\", &self.file_resolver)\n+            .finish()\n+    }\n }\n \n-pub trait FileResolver: Debug + Send + Sync + 'static {\n-    fn file_stem(&self, file_id: FileId) -> String;\n-    fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId>;\n+\n+impl AnalysisChange {\n+    pub fn new() -> AnalysisChange {\n+        AnalysisChange::default()\n+    }\n+    pub fn add_file(&mut self, file_id: FileId, text: String) {\n+        self.files_added.push((file_id, text))\n+    }\n+    pub fn change_file(&mut self, file_id: FileId, new_text: String) {\n+        self.files_changed.push((file_id, new_text))\n+    }\n+    pub fn remove_file(&mut self, file_id: FileId) {\n+        self.files_removed.push(file_id)\n+    }\n+    pub fn add_library(&mut self, data: LibraryData) {\n+        self.libraries_added.push(data)\n+    }\n+    pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n+        self.crate_graph = Some(graph);\n+    }\n+    pub fn set_file_resolver(&mut self, file_resolver: Arc<FileResolver>) {\n+        self.file_resolver = Some(FileResolverImp::new(file_resolver));\n+    }\n }\n \n #[derive(Debug)]\n@@ -75,20 +114,8 @@ impl AnalysisHost {\n             imp: self.imp.analysis(),\n         }\n     }\n-    pub fn change_file(&mut self, file_id: FileId, text: Option<String>) {\n-        self.change_files(::std::iter::once((file_id, text)));\n-    }\n-    pub fn change_files(&mut self, mut changes: impl Iterator<Item = (FileId, Option<String>)>) {\n-        self.imp.change_files(&mut changes)\n-    }\n-    pub fn set_file_resolver(&mut self, resolver: Arc<FileResolver>) {\n-        self.imp.set_file_resolver(FileResolverImp::new(resolver));\n-    }\n-    pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n-        self.imp.set_crate_graph(graph)\n-    }\n-    pub fn add_library(&mut self, data: LibraryData) {\n-        self.imp.add_library(data.root)\n+    pub fn apply_change(&mut self, change: AnalysisChange) {\n+        self.imp.apply_change(change)\n     }\n }\n \n@@ -266,14 +293,18 @@ impl Analysis {\n \n #[derive(Debug)]\n pub struct LibraryData {\n-    root: roots::ReadonlySourceRoot,\n+    files: Vec<(FileId, String)>,\n+    file_resolver: FileResolverImp,\n+    symbol_index: SymbolIndex,\n }\n \n impl LibraryData {\n     pub fn prepare(files: Vec<(FileId, String)>, file_resolver: Arc<FileResolver>) -> LibraryData {\n-        let file_resolver = FileResolverImp::new(file_resolver);\n-        let root = roots::ReadonlySourceRoot::new(files, file_resolver);\n-        LibraryData { root }\n+        let symbol_index = SymbolIndex::for_files(files.par_iter().map(|(file_id, text)| {\n+            let file = File::parse(text);\n+            (*file_id, file)\n+        }));\n+        LibraryData { files, file_resolver: FileResolverImp::new(file_resolver), symbol_index }\n     }\n }\n "}, {"sha": "1e9e613ac2d9323001a3c77e1a407a5c491d1e25", "filename": "crates/ra_analysis/src/roots.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/2cb2074c4b7219b32993abdcc7084637c0123d49/crates%2Fra_analysis%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb2074c4b7219b32993abdcc7084637c0123d49/crates%2Fra_analysis%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Froots.rs?ref=2cb2074c4b7219b32993abdcc7084637c0123d49", "patch": "@@ -1,116 +0,0 @@\n-use std::{sync::Arc};\n-\n-use rustc_hash::FxHashSet;\n-use rayon::prelude::*;\n-use salsa::Database;\n-\n-use crate::{\n-    Cancelable,\n-    db::{self, FilesDatabase, SyntaxDatabase},\n-    imp::FileResolverImp,\n-    symbol_index::SymbolIndex,\n-    FileId,\n-};\n-\n-pub(crate) trait SourceRoot {\n-    fn contains(&self, file_id: FileId) -> bool;\n-    fn db(&self) -> &db::RootDatabase;\n-    fn symbols(&self, acc: &mut Vec<Arc<SymbolIndex>>) -> Cancelable<()>;\n-}\n-\n-#[derive(Default, Debug, Clone)]\n-pub(crate) struct WritableSourceRoot {\n-    db: db::RootDatabase,\n-}\n-\n-impl WritableSourceRoot {\n-    pub fn apply_changes(\n-        &mut self,\n-        changes: &mut dyn Iterator<Item = (FileId, Option<String>)>,\n-        file_resolver: Option<FileResolverImp>,\n-    ) {\n-        let mut changed = FxHashSet::default();\n-        let mut removed = FxHashSet::default();\n-        for (file_id, text) in changes {\n-            match text {\n-                None => {\n-                    removed.insert(file_id);\n-                }\n-                Some(text) => {\n-                    self.db\n-                        .query(db::FileTextQuery)\n-                        .set(file_id, Arc::new(text));\n-                    changed.insert(file_id);\n-                }\n-            }\n-        }\n-        let file_set = self.db.file_set();\n-        let mut files: FxHashSet<FileId> = file_set.files.clone();\n-        for file_id in removed {\n-            files.remove(&file_id);\n-        }\n-        files.extend(changed);\n-        let resolver = file_resolver.unwrap_or_else(|| file_set.resolver.clone());\n-        self.db\n-            .query(db::FileSetQuery)\n-            .set((), Arc::new(db::FileSet { files, resolver }));\n-    }\n-}\n-\n-impl SourceRoot for WritableSourceRoot {\n-    fn contains(&self, file_id: FileId) -> bool {\n-        self.db.file_set().files.contains(&file_id)\n-    }\n-    fn db(&self) -> &db::RootDatabase {\n-        &self.db\n-    }\n-    fn symbols<'a>(&'a self, acc: &mut Vec<Arc<SymbolIndex>>) -> Cancelable<()> {\n-        for &file_id in self.db.file_set().files.iter() {\n-            let symbols = self.db.file_symbols(file_id)?;\n-            acc.push(symbols)\n-        }\n-        Ok(())\n-    }\n-}\n-\n-#[derive(Debug, Clone)]\n-pub(crate) struct ReadonlySourceRoot {\n-    db: db::RootDatabase,\n-    symbol_index: Arc<SymbolIndex>,\n-}\n-\n-impl ReadonlySourceRoot {\n-    pub(crate) fn new(\n-        files: Vec<(FileId, String)>,\n-        resolver: FileResolverImp,\n-    ) -> ReadonlySourceRoot {\n-        let db = db::RootDatabase::default();\n-        let mut file_ids = FxHashSet::default();\n-        for (file_id, text) in files {\n-            file_ids.insert(file_id);\n-            db.query(db::FileTextQuery).set(file_id, Arc::new(text));\n-        }\n-\n-        db.query(db::FileSetQuery)\n-            .set((), Arc::new(db::FileSet { files: file_ids, resolver }));\n-        let file_set = db.file_set();\n-        let symbol_index =\n-            SymbolIndex::for_files(file_set.files.par_iter()\n-                .map_with(db.clone(), |db, &file_id| (file_id, db.file_syntax(file_id))));\n-\n-        ReadonlySourceRoot { db, symbol_index: Arc::new(symbol_index) }\n-    }\n-}\n-\n-impl SourceRoot for ReadonlySourceRoot {\n-    fn contains(&self, file_id: FileId) -> bool {\n-        self.db.file_set().files.contains(&file_id)\n-    }\n-    fn db(&self) -> &db::RootDatabase {\n-        &self.db\n-    }\n-    fn symbols(&self, acc: &mut Vec<Arc<SymbolIndex>>) -> Cancelable<()> {\n-        acc.push(Arc::clone(&self.symbol_index));\n-        Ok(())\n-    }\n-}"}, {"sha": "5f302cbda4e4860ea55cb88c188811b7474f36ea", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -13,7 +13,7 @@ use rayon::prelude::*;\n \n use crate::{FileId, Query};\n \n-#[derive(Debug)]\n+#[derive(Default, Debug)]\n pub(crate) struct SymbolIndex {\n     symbols: Vec<(FileId, FileSymbol)>,\n     map: fst::Map,"}, {"sha": "806e1fb34584f22ea73d40c1765b5b81f8bd2a25", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -5,15 +5,16 @@ extern crate relative_path;\n extern crate rustc_hash;\n extern crate test_utils;\n \n-use std::sync::Arc;\n+use std::{\n+    sync::Arc,\n+};\n \n use ra_syntax::TextRange;\n use relative_path::{RelativePath, RelativePathBuf};\n-use rustc_hash::FxHashMap;\n use test_utils::{assert_eq_dbg, extract_offset};\n \n use ra_analysis::{\n-    Analysis, AnalysisHost, CrateGraph, CrateId, FileId, FileResolver, FnDescriptor,\n+    AnalysisChange, Analysis, AnalysisHost, CrateGraph, CrateId, FileId, FileResolver, FnDescriptor,\n };\n \n #[derive(Debug)]\n@@ -45,14 +46,16 @@ impl FileResolver for FileMap {\n fn analysis_host(files: &[(&str, &str)]) -> AnalysisHost {\n     let mut host = AnalysisHost::new();\n     let mut file_map = Vec::new();\n+    let mut change = AnalysisChange::new();\n     for (id, &(path, contents)) in files.iter().enumerate() {\n         let file_id = FileId((id + 1) as u32);\n         assert!(path.starts_with('/'));\n         let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-        host.change_file(file_id, Some(contents.to_string()));\n+        change.add_file(file_id, contents.to_string());\n         file_map.push((file_id, path));\n     }\n-    host.set_file_resolver(Arc::new(FileMap(file_map)));\n+    change.set_file_resolver(Arc::new(FileMap(file_map)));\n+    host.apply_change(change);\n     host\n }\n \n@@ -126,17 +129,17 @@ fn test_resolve_crate_root() {\n     let snap = host.analysis();\n     assert!(snap.crate_for(FileId(2)).unwrap().is_empty());\n \n-    let crate_graph = CrateGraph {\n-        crate_roots: {\n-            let mut m = FxHashMap::default();\n-            m.insert(CrateId(1), FileId(1));\n-            m\n-        },\n+    let crate_graph = {\n+        let mut g = CrateGraph::new();\n+        g.add_crate_root(FileId(1));\n+        g\n     };\n-    host.set_crate_graph(crate_graph);\n+    let mut change = AnalysisChange::new();\n+    change.set_crate_graph(crate_graph);\n+    host.apply_change(change);\n     let snap = host.analysis();\n \n-    assert_eq!(snap.crate_for(FileId(2)).unwrap(), vec![CrateId(1)],);\n+    assert_eq!(snap.crate_for(FileId(2)).unwrap(), vec![CrateId(0)],);\n }\n \n #[test]"}, {"sha": "9ddc3fd0bb590b7bdea56c6efad2b27b6ef81138", "filename": "crates/ra_lsp_server/src/main_loop/mod.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fmod.rs?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -8,7 +8,7 @@ use gen_lsp_server::{\n     handle_shutdown, ErrorCode, RawMessage, RawNotification, RawRequest, RawResponse,\n };\n use languageserver_types::NumberOrString;\n-use ra_analysis::{FileId, LibraryData};\n+use ra_analysis::{Canceled, FileId, LibraryData};\n use rayon::{self, ThreadPool};\n use rustc_hash::FxHashSet;\n use serde::{de::DeserializeOwned, Serialize};\n@@ -376,7 +376,7 @@ impl<'a> PoolDispatcher<'a> {\n                         Err(e) => {\n                             match e.downcast::<LspError>() {\n                                 Ok(lsp_error) => RawResponse::err(id, lsp_error.code, lsp_error.message),\n-                                Err(e) => RawResponse::err(id, ErrorCode::InternalError as i32, e.to_string())\n+                                Err(e) => RawResponse::err(id, ErrorCode::InternalError as i32, format!(\"{}\\n{}\", e, e.backtrace()))\n                             }\n                         }\n                     };\n@@ -408,14 +408,22 @@ fn update_file_notifications_on_threadpool(\n     pool.spawn(move || {\n         for file_id in subscriptions {\n             match handlers::publish_diagnostics(&world, file_id) {\n-                Err(e) => error!(\"failed to compute diagnostics: {:?}\", e),\n+                Err(e) => {\n+                    if !is_canceled(&e) {\n+                        error!(\"failed to compute diagnostics: {:?}\", e);\n+                    }\n+                },\n                 Ok(params) => {\n                     let not = RawNotification::new::<req::PublishDiagnostics>(&params);\n                     sender.send(Task::Notify(not));\n                 }\n             }\n             match handlers::publish_decorations(&world, file_id) {\n-                Err(e) => error!(\"failed to compute decorations: {:?}\", e),\n+                Err(e) => {\n+                    if !is_canceled(&e) {\n+                        error!(\"failed to compute decorations: {:?}\", e);\n+                    }\n+                },\n                 Ok(params) => {\n                     let not = RawNotification::new::<req::PublishDecorations>(&params);\n                     sender.send(Task::Notify(not))\n@@ -432,3 +440,7 @@ fn feedback(intrnal_mode: bool, msg: &str, sender: &Sender<RawMessage>) {\n     let not = RawNotification::new::<req::InternalFeedback>(&msg.to_string());\n     sender.send(RawMessage::Notification(not));\n }\n+\n+fn is_canceled(e: &failure::Error) -> bool {\n+    e.downcast_ref::<Canceled>().is_some()\n+}"}, {"sha": "d5957d67352c023bea8c5717676e4516cf815631", "filename": "crates/ra_lsp_server/src/path_map.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -1,4 +1,7 @@\n-use std::path::{Component, Path, PathBuf};\n+use std::{\n+    fmt,\n+    path::{Component, Path, PathBuf},\n+};\n \n use im;\n use ra_analysis::{FileId, FileResolver};\n@@ -10,27 +13,36 @@ pub enum Root {\n     Lib,\n }\n \n-#[derive(Debug, Default, Clone)]\n+#[derive(Default, Clone)]\n pub struct PathMap {\n     next_id: u32,\n     path2id: im::HashMap<PathBuf, FileId>,\n     id2path: im::HashMap<FileId, PathBuf>,\n     id2root: im::HashMap<FileId, Root>,\n }\n \n+impl fmt::Debug for PathMap {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(\"PathMap { ... }\")\n+    }\n+}\n+\n impl PathMap {\n     pub fn new() -> PathMap {\n         Default::default()\n     }\n-    pub fn get_or_insert(&mut self, path: PathBuf, root: Root) -> FileId {\n-        self.path2id\n+    pub fn get_or_insert(&mut self, path: PathBuf, root: Root) -> (bool, FileId) {\n+        let mut inserted = false;\n+        let file_id = self.path2id\n             .get(path.as_path())\n             .map(|&id| id)\n             .unwrap_or_else(|| {\n+                inserted = true;\n                 let id = self.new_file_id();\n                 self.insert(path, id, root);\n                 id\n-            })\n+            });\n+        (inserted, file_id)\n     }\n     pub fn get_id(&self, path: &Path) -> Option<FileId> {\n         self.path2id.get(path).map(|&id| id)\n@@ -105,8 +117,8 @@ mod test {\n     #[test]\n     fn test_resolve() {\n         let mut m = PathMap::new();\n-        let id1 = m.get_or_insert(PathBuf::from(\"/foo\"), Root::Workspace);\n-        let id2 = m.get_or_insert(PathBuf::from(\"/foo/bar.rs\"), Root::Workspace);\n+        let (_, id1) = m.get_or_insert(PathBuf::from(\"/foo\"), Root::Workspace);\n+        let (_, id2) = m.get_or_insert(PathBuf::from(\"/foo/bar.rs\"), Root::Workspace);\n         assert_eq!(m.resolve(id1, &RelativePath::new(\"bar.rs\")), Some(id2),)\n     }\n }"}, {"sha": "25986e230443aeb2ec33b4c8d1b7c4ebacfd6c33", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5932bd0bb5fcd066a9d16abcd1597b7097978085/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=5932bd0bb5fcd066a9d16abcd1597b7097978085", "patch": "@@ -5,7 +5,7 @@ use std::{\n };\n \n use languageserver_types::Url;\n-use ra_analysis::{Analysis, AnalysisHost, CrateGraph, CrateId, FileId, FileResolver, LibraryData};\n+use ra_analysis::{Analysis, AnalysisHost, AnalysisChange, CrateGraph, FileId, FileResolver, LibraryData};\n use rustc_hash::FxHashMap;\n \n use crate::{\n@@ -39,30 +39,40 @@ impl ServerWorldState {\n         }\n     }\n     pub fn apply_fs_changes(&mut self, events: Vec<FileEvent>) {\n+        let mut change = AnalysisChange::new();\n+        let mut inserted = false;\n         {\n             let pm = &mut self.path_map;\n             let mm = &mut self.mem_map;\n-            let changes = events\n+            events\n                 .into_iter()\n                 .map(|event| {\n                     let text = match event.kind {\n-                        FileEventKind::Add(text) => Some(text),\n+                        FileEventKind::Add(text) => text,\n                     };\n                     (event.path, text)\n                 })\n-                .map(|(path, text)| (pm.get_or_insert(path, Root::Workspace), text))\n-                .filter_map(|(id, text)| {\n-                    if mm.contains_key(&id) {\n-                        mm.insert(id, text);\n+                .map(|(path, text)| {\n+                    let (ins, file_id) = pm.get_or_insert(path, Root::Workspace);\n+                    inserted |= ins;\n+                    (file_id, text)\n+                })\n+                .filter_map(|(file_id, text)| {\n+                    if mm.contains_key(&file_id) {\n+                        mm.insert(file_id, Some(text));\n                         None\n                     } else {\n-                        Some((id, text))\n+                        Some((file_id, text))\n                     }\n+                })\n+                .for_each(|(file_id, text)| {\n+                    change.add_file(file_id, text)\n                 });\n-            self.analysis_host.change_files(changes);\n         }\n-        self.analysis_host\n-            .set_file_resolver(Arc::new(self.path_map.clone()));\n+        if inserted {\n+            change.set_file_resolver(Arc::new(self.path_map.clone()))\n+        }\n+        self.analysis_host.apply_change(change);\n     }\n     pub fn events_to_files(\n         &mut self,\n@@ -76,24 +86,31 @@ impl ServerWorldState {\n                     let FileEventKind::Add(text) = event.kind;\n                     (event.path, text)\n                 })\n-                .map(|(path, text)| (pm.get_or_insert(path, Root::Lib), text))\n+                .map(|(path, text)| (pm.get_or_insert(path, Root::Lib).1, text))\n                 .collect()\n         };\n         let resolver = Arc::new(self.path_map.clone());\n         (files, resolver)\n     }\n     pub fn add_lib(&mut self, data: LibraryData) {\n-        self.analysis_host.add_library(data);\n+        let mut change = AnalysisChange::new();\n+        change.add_library(data);\n+        self.analysis_host.apply_change(change);\n     }\n \n     pub fn add_mem_file(&mut self, path: PathBuf, text: String) -> FileId {\n-        let file_id = self.path_map.get_or_insert(path, Root::Workspace);\n-        self.analysis_host\n-            .set_file_resolver(Arc::new(self.path_map.clone()));\n-        self.mem_map.insert(file_id, None);\n+        let (inserted, file_id) = self.path_map.get_or_insert(path, Root::Workspace);\n         if self.path_map.get_root(file_id) != Root::Lib {\n-            self.analysis_host.change_file(file_id, Some(text));\n+            let mut change = AnalysisChange::new();\n+            if inserted {\n+                change.add_file(file_id, text);\n+                change.set_file_resolver(Arc::new(self.path_map.clone()));\n+            } else {\n+                change.change_file(file_id, text);\n+            }\n+            self.analysis_host.apply_change(change);\n         }\n+        self.mem_map.insert(file_id, None);\n         file_id\n     }\n \n@@ -103,7 +120,9 @@ impl ServerWorldState {\n             .get_id(path)\n             .ok_or_else(|| format_err!(\"change to unknown file: {}\", path.display()))?;\n         if self.path_map.get_root(file_id) != Root::Lib {\n-            self.analysis_host.change_file(file_id, Some(text));\n+            let mut change = AnalysisChange::new();\n+            change.change_file(file_id, text);\n+            self.analysis_host.apply_change(change);\n         }\n         Ok(())\n     }\n@@ -120,12 +139,16 @@ impl ServerWorldState {\n         // Do this via file watcher ideally.\n         let text = fs::read_to_string(path).ok();\n         if self.path_map.get_root(file_id) != Root::Lib {\n-            self.analysis_host.change_file(file_id, text);\n+            let mut change = AnalysisChange::new();\n+            if let Some(text) = text {\n+                change.change_file(file_id, text);\n+            }\n+            self.analysis_host.apply_change(change);\n         }\n         Ok(file_id)\n     }\n     pub fn set_workspaces(&mut self, ws: Vec<CargoWorkspace>) {\n-        let mut crate_roots = FxHashMap::default();\n+        let mut crate_graph = CrateGraph::new();\n         ws.iter()\n             .flat_map(|ws| {\n                 ws.packages()\n@@ -134,13 +157,13 @@ impl ServerWorldState {\n             })\n             .for_each(|root| {\n                 if let Some(file_id) = self.path_map.get_id(root) {\n-                    let crate_id = CrateId(crate_roots.len() as u32);\n-                    crate_roots.insert(crate_id, file_id);\n+                    crate_graph.add_crate_root(file_id);\n                 }\n             });\n-        let crate_graph = CrateGraph { crate_roots };\n         self.workspaces = Arc::new(ws);\n-        self.analysis_host.set_crate_graph(crate_graph);\n+        let mut change = AnalysisChange::new();\n+        change.set_crate_graph(crate_graph);\n+        self.analysis_host.apply_change(change);\n     }\n     pub fn snapshot(&self) -> ServerWorld {\n         ServerWorld {"}]}