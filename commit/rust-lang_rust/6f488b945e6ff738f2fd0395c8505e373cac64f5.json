{"sha": "6f488b945e6ff738f2fd0395c8505e373cac64f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNDg4Yjk0NWU2ZmY3MzhmMmZkMDM5NWM4NTA1ZTM3M2NhYzY0ZjU=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-11-23T21:47:00Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-12-27T18:21:15Z"}, "message": "Rename functions giving WF clauses for builtin types", "tree": {"sha": "10c4a003c637cea96d0712ea64172654e0192144", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10c4a003c637cea96d0712ea64172654e0192144"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f488b945e6ff738f2fd0395c8505e373cac64f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f488b945e6ff738f2fd0395c8505e373cac64f5", "html_url": "https://github.com/rust-lang/rust/commit/6f488b945e6ff738f2fd0395c8505e373cac64f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f488b945e6ff738f2fd0395c8505e373cac64f5/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b8da7908f5a9b2ad1d9acf7ae6fb90817b0d114", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b8da7908f5a9b2ad1d9acf7ae6fb90817b0d114", "html_url": "https://github.com/rust-lang/rust/commit/7b8da7908f5a9b2ad1d9acf7ae6fb90817b0d114"}], "stats": {"total": 59, "additions": 38, "deletions": 21}, "files": [{"sha": "e202d29d3fce3d72c82e5410512ccbaab09af608", "filename": "src/librustc_traits/chalk_context/program_clauses.rs", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6f488b945e6ff738f2fd0395c8505e373cac64f5/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f488b945e6ff738f2fd0395c8505e373cac64f5/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs?ref=6f488b945e6ff738f2fd0395c8505e373cac64f5", "patch": "@@ -49,7 +49,7 @@ fn assemble_clauses_from_assoc_ty_values<'tcx>(\n }\n \n \n-fn program_clauses_for_raw_ptr<'tcx>(\n+fn wf_clause_for_raw_ptr<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     mutbl: hir::Mutability\n ) -> Clauses<'tcx> {\n@@ -66,7 +66,7 @@ fn program_clauses_for_raw_ptr<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-fn program_clauses_for_fn_ptr<'tcx>(\n+fn wf_clause_for_fn_ptr<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     arity_and_output: usize,\n     variadic: bool,\n@@ -87,7 +87,7 @@ fn program_clauses_for_fn_ptr<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-fn program_clauses_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+fn wf_clause_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n     let ty = generic_types::bound(tcx, 0);\n     let slice_ty = tcx.mk_slice(ty);\n \n@@ -116,7 +116,7 @@ fn program_clauses_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tc\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-fn program_clauses_for_array<'tcx>(\n+fn wf_clause_for_array<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     length: &'tcx ty::Const<'tcx>\n ) -> Clauses<'tcx> {\n@@ -148,7 +148,7 @@ fn program_clauses_for_array<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-fn program_clauses_for_tuple<'tcx>(\n+fn wf_clause_for_tuple<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     arity: usize\n ) -> Clauses<'tcx> {\n@@ -189,7 +189,7 @@ fn program_clauses_for_tuple<'tcx>(\n     tcx.mk_clauses(iter::once(wf_clause))\n }\n \n-fn program_clauses_for_ref<'tcx>(\n+fn wf_clause_for_ref<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n     mutbl: hir::Mutability\n ) -> Clauses<'tcx> {\n@@ -202,13 +202,16 @@ fn program_clauses_for_ref<'tcx>(\n         mutbl,\n     });\n \n-    let outlives: DomainGoal = ty::OutlivesPredicate(ty, region).lower();\n+    let _outlives: DomainGoal = ty::OutlivesPredicate(ty, region).lower();\n     let wf_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(ref_ty)),\n-        hypotheses: tcx.mk_goals(\n-            iter::once(tcx.mk_goal(outlives.into_goal()))\n-        ),\n-        category: ProgramClauseCategory::ImpliedBound,\n+        hypotheses: ty::List::empty(),\n+\n+        // FIXME: restore this later once we get better at handling regions\n+        // hypotheses: tcx.mk_goals(\n+        //     iter::once(tcx.mk_goal(outlives.into_goal()))\n+        // ),\n+        category: ProgramClauseCategory::WellFormed,\n     };\n     let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n \n@@ -323,6 +326,8 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n                     ty::Float(..) |\n                     ty::Str |\n                     ty::Param(..) |\n+                    ty::Placeholder(..) |\n+                    ty::Error |\n                     ty::Never => {\n                         let wf_clause = ProgramClause {\n                             goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n@@ -335,12 +340,12 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n                     }\n \n                     // Always WF (recall that we do not check for parameters to be WF).\n-                    ty::RawPtr(ptr) => program_clauses_for_raw_ptr(self.infcx.tcx, ptr.mutbl),\n+                    ty::RawPtr(ptr) => wf_clause_for_raw_ptr(self.infcx.tcx, ptr.mutbl),\n \n                     // Always WF (recall that we do not check for parameters to be WF).\n                     ty::FnPtr(fn_ptr) => {\n                         let fn_ptr = fn_ptr.skip_binder();\n-                        program_clauses_for_fn_ptr(\n+                        wf_clause_for_fn_ptr(\n                             self.infcx.tcx,\n                             fn_ptr.inputs_and_output.len(),\n                             fn_ptr.variadic,\n@@ -350,19 +355,19 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n                     }\n \n                     // WF if inner type is `Sized`.\n-                    ty::Slice(..) => program_clauses_for_slice(self.infcx.tcx),\n+                    ty::Slice(..) => wf_clause_for_slice(self.infcx.tcx),\n \n                     // WF if inner type is `Sized`.\n-                    ty::Array(_, length) => program_clauses_for_array(self.infcx.tcx, length),\n+                    ty::Array(_, length) => wf_clause_for_array(self.infcx.tcx, length),\n \n                     // WF if all types but the last one are `Sized`.\n-                    ty::Tuple(types) => program_clauses_for_tuple(\n+                    ty::Tuple(types) => wf_clause_for_tuple(\n                         self.infcx.tcx,\n                         types.len()\n                     ),\n \n                     // WF if `sub_ty` outlives `region`.\n-                    ty::Ref(_, _, mutbl) => program_clauses_for_ref(self.infcx.tcx, mutbl),\n+                    ty::Ref(_, _, mutbl) => wf_clause_for_ref(self.infcx.tcx, mutbl),\n \n                     ty::Dynamic(..) => {\n                         // FIXME: no rules yet for trait objects\n@@ -381,12 +386,24 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n                         self.infcx.tcx.program_clauses_for(def_id)\n                     }\n \n+                    // Artificially trigger an ambiguity.\n+                    ty::Infer(..) => {\n+                        let tcx = self.infcx.tcx;\n+                        let types = [tcx.types.i32, tcx.types.u32, tcx.types.f32, tcx.types.f64];\n+                        let clauses = types.iter()\n+                            .cloned()\n+                            .map(|ty| ProgramClause {\n+                                goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n+                                hypotheses: ty::List::empty(),\n+                                category: ProgramClauseCategory::WellFormed,\n+                            })\n+                            .map(|clause| Clause::Implies(clause));\n+                        tcx.mk_clauses(clauses)\n+                    }\n+\n                     ty::GeneratorWitness(..) |\n-                    ty::Placeholder(..) |\n                     ty::UnnormalizedProjection(..) |\n-                    ty::Infer(..) |\n-                    ty::Bound(..) |\n-                    ty::Error => {\n+                    ty::Bound(..) => {\n                         bug!(\"unexpected type {:?}\", ty)\n                     }\n                 };"}]}