{"sha": "8c6c0f80a399e61d8454bb449962103449b52739", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNmMwZjgwYTM5OWU2MWQ4NDU0YmI0NDk5NjIxMDM0NDliNTI3Mzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-04T01:47:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-04T01:47:51Z"}, "message": "Auto merge of #40163 - arielb1:normalization-1702, r=nikomatsakis\n\nMore through normalization, Feb/Mar 2017 edition\n\nFix a few normalization bugs.\n\nFixes #27901.\nFixes #28828.\nFixes #38135.\nFixes #39363.\nFixes #39367.", "tree": {"sha": "5965feac6011ac438b1ddf42965fcd1a51d4d3cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5965feac6011ac438b1ddf42965fcd1a51d4d3cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c6c0f80a399e61d8454bb449962103449b52739", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c6c0f80a399e61d8454bb449962103449b52739", "html_url": "https://github.com/rust-lang/rust/commit/8c6c0f80a399e61d8454bb449962103449b52739", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c6c0f80a399e61d8454bb449962103449b52739/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52080902d9e180ab3877a7c8a3cc1179473c3e1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/52080902d9e180ab3877a7c8a3cc1179473c3e1d", "html_url": "https://github.com/rust-lang/rust/commit/52080902d9e180ab3877a7c8a3cc1179473c3e1d"}, {"sha": "4aede759146260cddd194de71375d3f1b8183135", "url": "https://api.github.com/repos/rust-lang/rust/commits/4aede759146260cddd194de71375d3f1b8183135", "html_url": "https://github.com/rust-lang/rust/commit/4aede759146260cddd194de71375d3f1b8183135"}], "stats": {"total": 371, "additions": 235, "deletions": 136}, "files": [{"sha": "ed72fe1801663a4bc0987622180c8cb82ae4b11e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -816,12 +816,20 @@ pub enum Lvalue<'tcx> {\n     Local(Local),\n \n     /// static or static mut variable\n-    Static(DefId),\n+    Static(Box<Static<'tcx>>),\n \n     /// projection out of an lvalue (access a field, deref a pointer, etc)\n     Projection(Box<LvalueProjection<'tcx>>),\n }\n \n+/// The def-id of a static, along with its normalized type (which is\n+/// stored to avoid requiring normalization when reading MIR).\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+pub struct Static<'tcx> {\n+    pub def_id: DefId,\n+    pub ty: Ty<'tcx>,\n+}\n+\n /// The `Projection` data structure defines things of the form `B.x`\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Lvalue`. See the aliases\n@@ -911,8 +919,8 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n \n         match *self {\n             Local(id) => write!(fmt, \"{:?}\", id),\n-            Static(def_id) =>\n-                write!(fmt, \"{}\", ty::tls::with(|tcx| tcx.item_path_str(def_id))),\n+            Static(box self::Static { def_id, ty }) =>\n+                write!(fmt, \"({}: {:?})\", ty::tls::with(|tcx| tcx.item_path_str(def_id)), ty),\n             Projection(ref data) =>\n                 match data.elem {\n                     ProjectionElem::Downcast(ref adt_def, index) =>"}, {"sha": "f40b9c6053753f762b3e2fc3beaf61bcbb353492", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -125,8 +125,8 @@ impl<'tcx> Lvalue<'tcx> {\n         match *self {\n             Lvalue::Local(index) =>\n                 LvalueTy::Ty { ty: mir.local_decls[index].ty },\n-            Lvalue::Static(def_id) =>\n-                LvalueTy::Ty { ty: tcx.item_type(def_id) },\n+            Lvalue::Static(ref data) =>\n+                LvalueTy::Ty { ty: data.ty },\n             Lvalue::Projection(ref proj) =>\n                 proj.base.ty(mir, tcx).projection_ty(tcx, &proj.elem),\n         }"}, {"sha": "733ad36de90e3febf6757a6b8a41a5ade16028a0", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -154,6 +154,13 @@ macro_rules! make_mir_visitor {\n                 self.super_lvalue(lvalue, context, location);\n             }\n \n+            fn visit_static(&mut self,\n+                            static_: & $($mutability)* Static<'tcx>,\n+                            context: LvalueContext<'tcx>,\n+                            location: Location) {\n+                self.super_static(static_, context, location);\n+            }\n+\n             fn visit_projection(&mut self,\n                                 lvalue: & $($mutability)* LvalueProjection<'tcx>,\n                                 context: LvalueContext<'tcx>,\n@@ -554,15 +561,27 @@ macro_rules! make_mir_visitor {\n                 match *lvalue {\n                     Lvalue::Local(_) => {\n                     }\n-                    Lvalue::Static(ref $($mutability)* def_id) => {\n-                        self.visit_def_id(def_id, location);\n+                    Lvalue::Static(ref $($mutability)* static_) => {\n+                        self.visit_static(static_, context, location);\n                     }\n                     Lvalue::Projection(ref $($mutability)* proj) => {\n                         self.visit_projection(proj, context, location);\n                     }\n                 }\n             }\n \n+            fn super_static(&mut self,\n+                            static_: & $($mutability)* Static<'tcx>,\n+                            _context: LvalueContext<'tcx>,\n+                            location: Location) {\n+                let Static {\n+                    ref $($mutability)* def_id,\n+                    ref $($mutability)* ty,\n+                } = *static_;\n+                self.visit_def_id(def_id, location);\n+                self.visit_ty(ty);\n+            }\n+\n             fn super_projection(&mut self,\n                                 proj: & $($mutability)* LvalueProjection<'tcx>,\n                                 context: LvalueContext<'tcx>,\n@@ -818,4 +837,3 @@ impl<'tcx> LvalueContext<'tcx> {\n         self.is_mutating_use() || self.is_nonmutating_use()\n     }\n }\n-"}, {"sha": "1cd9a1b25bade8c0f1080b61480637d5e50423f2", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(Lvalue::Local(index))\n             }\n             ExprKind::StaticRef { id } => {\n-                block.and(Lvalue::Static(id))\n+                block.and(Lvalue::Static(Box::new(Static { def_id: id, ty: expr.ty })))\n             }\n \n             ExprKind::Array { .. } |"}, {"sha": "f98bb73c504dcfb00e44a5247f184ee4b930e3f5", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -25,22 +25,21 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use rustc_data_structures::indexed_vec::Idx;\n \n+fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n+    tcx.sess.diagnostic().span_bug(span, msg);\n+}\n+\n macro_rules! span_mirbug {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n-        $context.tcx().sess.span_warn(\n-            $context.last_span,\n-            &format!(\"broken MIR ({:?}): {}\", $elem, format!($($message)*))\n-        )\n+        mirbug($context.tcx(), $context.last_span,\n+               &format!(\"broken MIR ({:?}): {}\", $elem, format!($($message)*)))\n     })\n }\n \n macro_rules! span_mirbug_and_err {\n     ($context:expr, $elem:expr, $($message:tt)*) => ({\n         {\n-            $context.tcx().sess.span_warn(\n-                $context.last_span,\n-                &format!(\"broken MIR ({:?}): {:?}\", $elem, format!($($message)*))\n-            );\n+            span_mirbug!($context, $elem, $($message)*);\n             $context.error()\n         }\n     })\n@@ -125,8 +124,18 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         debug!(\"sanitize_lvalue: {:?}\", lvalue);\n         match *lvalue {\n             Lvalue::Local(index) => LvalueTy::Ty { ty: self.mir.local_decls[index].ty },\n-            Lvalue::Static(def_id) =>\n-                LvalueTy::Ty { ty: self.tcx().item_type(def_id) },\n+            Lvalue::Static(box Static { def_id, ty: sty }) => {\n+                let sty = self.sanitize_type(lvalue, sty);\n+                let ty = self.tcx().item_type(def_id);\n+                let ty = self.cx.normalize(&ty);\n+                if let Err(terr) = self.cx.eq_types(self.last_span, ty, sty) {\n+                    span_mirbug!(\n+                        self, lvalue, \"bad static type ({:?}: {:?}): {:?}\",\n+                        ty, sty, terr);\n+                }\n+                LvalueTy::Ty { ty: sty }\n+\n+            },\n             Lvalue::Projection(ref proj) => {\n                 let base_ty = self.sanitize_lvalue(&proj.base, location);\n                 if let LvalueTy::Ty { ty } = base_ty {"}, {"sha": "36f6fa764390929a6647ca0880e217e817d8c302", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -596,10 +596,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     // release builds.\n     info!(\"trans_instance({})\", instance);\n \n-    let fn_ty = ccx.tcx().item_type(instance.def);\n-    let fn_ty = ccx.tcx().erase_regions(&fn_ty);\n-    let fn_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &fn_ty);\n-\n+    let fn_ty = common::def_ty(ccx.shared(), instance.def, instance.substs);\n     let sig = common::ty_fn_sig(ccx, fn_ty);\n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n \n@@ -626,9 +623,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     attributes::inline(llfn, attributes::InlineAttr::Hint);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n \n-    let ctor_ty = ccx.tcx().item_type(def_id);\n-    let ctor_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &ctor_ty);\n-\n+    let ctor_ty = common::def_ty(ccx.shared(), def_id, substs);\n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n     let fn_ty = FnType::new(ccx, sig, &[]);\n "}, {"sha": "762aaf1ce1d1b8734cf11fa766850bc1c21e4eb3", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -24,14 +24,15 @@ use abi::{Abi, FnType};\n use attributes;\n use base;\n use builder::Builder;\n-use common::{self, CrateContext, SharedCrateContext};\n+use common::{self, CrateContext};\n use cleanup::CleanupScope;\n use mir::lvalue::LvalueRef;\n use consts;\n+use common::def_ty;\n use declare;\n use value::Value;\n use meth;\n-use monomorphize::{self, Instance};\n+use monomorphize::Instance;\n use trans_item::TransItem;\n use type_of;\n use Disr;\n@@ -207,16 +208,6 @@ impl<'tcx> Callee<'tcx> {\n     }\n }\n \n-/// Given a DefId and some Substs, produces the monomorphic item type.\n-fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n-                    def_id: DefId,\n-                    substs: &'tcx Substs<'tcx>)\n-                    -> Ty<'tcx> {\n-    let ty = shared.tcx().item_type(def_id);\n-    monomorphize::apply_param_substs(shared, substs, &ty)\n-}\n-\n-\n fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                                   def_id: DefId,\n                                   substs: ty::ClosureSubsts<'tcx>,\n@@ -544,8 +535,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let substs = tcx.normalize_associated_type(&substs);\n     let instance = Instance::new(def_id, substs);\n-    let item_ty = ccx.tcx().item_type(def_id);\n-    let fn_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &item_ty);\n+    let fn_ty = common::def_ty(ccx.shared(), def_id, substs);\n \n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n         return (llfn, fn_ty);"}, {"sha": "8d1db38999c6b1d5fc2985dd78536160697d4d00", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -207,7 +207,7 @@ use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n use callee::needs_fn_once_adapter_shim;\n use context::SharedCrateContext;\n-use common::fulfill_obligation;\n+use common::{def_ty, fulfill_obligation};\n use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n@@ -341,7 +341,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n             // Sanity check whether this ended up being collected accidentally\n             debug_assert!(should_trans_locally(scx.tcx(), def_id));\n \n-            let ty = scx.tcx().item_type(def_id);\n+            let ty = def_ty(scx, def_id, Substs::empty());\n             let ty = glue::get_drop_glue_type(scx, ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n \n@@ -815,10 +815,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n         ty::TyAdt(def, substs) => {\n             for field in def.all_fields() {\n-                let field_type = scx.tcx().item_type(field.did);\n-                let field_type = monomorphize::apply_param_substs(scx,\n-                                                                  substs,\n-                                                                  &field_type);\n+                let field_type = def_ty(scx, field.did, substs);\n                 let field_type = glue::get_drop_glue_type(scx, field_type);\n \n                 if scx.type_needs_drop(field_type) {\n@@ -1184,7 +1181,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                         debug!(\"RootCollector: ADT drop-glue for {}\",\n                                def_id_to_string(self.scx.tcx(), def_id));\n \n-                        let ty = self.scx.tcx().item_type(def_id);\n+                        let ty = def_ty(self.scx, def_id, Substs::empty());\n                         let ty = glue::get_drop_glue_type(self.scx, ty);\n                         self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n                     }"}, {"sha": "a509587f80fd025e1f9b2c1f9b6aab40b41075a5", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -29,7 +29,7 @@ use type_::Type;\n use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::Layout;\n-use rustc::ty::subst::Subst;\n+use rustc::ty::subst::{Subst, Substs};\n use rustc::traits::{self, SelectionContext, Reveal};\n use rustc::hir;\n \n@@ -604,3 +604,13 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn is_closure(tcx: TyCtxt, def_id: DefId) -> bool {\n     tcx.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr\n }\n+\n+/// Given a DefId and some Substs, produces the monomorphic item type.\n+pub fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n+                        def_id: DefId,\n+                        substs: &'tcx Substs<'tcx>)\n+                        -> Ty<'tcx>\n+{\n+    let ty = shared.tcx().item_type(def_id);\n+    monomorphize::apply_param_substs(shared, substs, &ty)\n+}"}, {"sha": "bf1d9886ae7f0b9eddc5cb52b720181f5686931c", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -18,12 +18,13 @@ use rustc::hir::map as hir_map;\n use {debuginfo, machine};\n use base;\n use trans_item::TransItem;\n-use common::{CrateContext, val_ty};\n+use common::{self, CrateContext, val_ty};\n use declare;\n-use monomorphize::{Instance};\n+use monomorphize::Instance;\n use type_::Type;\n use type_of;\n use rustc::ty;\n+use rustc::ty::subst::Substs;\n \n use rustc::hir;\n \n@@ -84,7 +85,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n         return g;\n     }\n \n-    let ty = ccx.tcx().item_type(def_id);\n+    let ty = common::def_ty(ccx.shared(), def_id, Substs::empty());\n     let g = if let Some(id) = ccx.tcx().hir.as_local_node_id(def_id) {\n \n         let llty = type_of::type_of(ccx, ty);\n@@ -234,7 +235,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             v\n         };\n \n-        let ty = ccx.tcx().item_type(def_id);\n+        let ty = common::def_ty(ccx.shared(), def_id, Substs::empty());\n         let llty = type_of::type_of(ccx, ty);\n         let g = if val_llty == llty {\n             g"}, {"sha": "049178a2575f39d10c80b13cf485360c622e39f6", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -33,7 +33,7 @@ use rustc::ty::util::TypeIdHasher;\n use rustc::hir;\n use rustc_data_structures::ToHex;\n use {type_of, machine, monomorphize};\n-use common::CrateContext;\n+use common::{self, CrateContext};\n use type_::Type;\n use rustc::ty::{self, AdtKind, Ty, layout};\n use session::config;\n@@ -377,7 +377,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                       span: Span)\n                                       -> MetadataCreationResult\n {\n-    let signature = cx.tcx().erase_late_bound_regions(&signature);\n+    let signature = cx.tcx().erase_late_bound_regions_and_normalize(&signature);\n \n     let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs().len() + 1);\n \n@@ -1764,16 +1764,15 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);\n-    let variable_type = tcx.erase_regions(&tcx.item_type(node_def_id));\n+    let variable_type = common::def_ty(cx.shared(), node_def_id, Substs::empty());\n     let type_metadata = type_metadata(cx, variable_type, span);\n     let var_name = tcx.item_name(node_def_id).to_string();\n     let linkage_name = mangled_name_of_item(cx, node_def_id, \"\");\n \n     let var_name = CString::new(var_name).unwrap();\n     let linkage_name = CString::new(linkage_name).unwrap();\n \n-    let ty = cx.tcx().item_type(node_def_id);\n-    let global_align = type_of::align_of(cx, ty);\n+    let global_align = type_of::align_of(cx, variable_type);\n \n     unsafe {\n         llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(cx),"}, {"sha": "6933f158256209602c266b4807531d08796d6f0a", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -27,9 +27,9 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n \n use abi::Abi;\n-use common::CrateContext;\n+use common::{self, CrateContext};\n use builder::Builder;\n-use monomorphize::{self, Instance};\n+use monomorphize::Instance;\n use rustc::ty::{self, Ty};\n use rustc::mir;\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n@@ -397,11 +397,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         let self_type = cx.tcx().impl_of_method(instance.def).and_then(|impl_def_id| {\n             // If the method does *not* belong to a trait, proceed\n             if cx.tcx().trait_id_of_impl(impl_def_id).is_none() {\n-                let impl_self_ty = cx.tcx().item_type(impl_def_id);\n-                let impl_self_ty = cx.tcx().erase_regions(&impl_self_ty);\n-                let impl_self_ty = monomorphize::apply_param_substs(cx.shared(),\n-                                                                    instance.substs,\n-                                                                    &impl_self_ty);\n+                let impl_self_ty =\n+                    common::def_ty(cx.shared(), impl_def_id, instance.substs);\n \n                 // Only \"class\" methods are generally understood by LLVM,\n                 // so avoid methods on other types (e.g. `<*mut T>::null`)."}, {"sha": "b6fcc990344cebbb15fbd04d952c98427af8f6c3", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -382,11 +382,11 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n         let lvalue = match *lvalue {\n             mir::Lvalue::Local(_)  => bug!(), // handled above\n-            mir::Lvalue::Static(def_id) => {\n+            mir::Lvalue::Static(box mir::Static { def_id, ty }) => {\n                 ConstLvalue {\n                     base: Base::Static(consts::get_static(self.ccx, def_id)),\n                     llextra: ptr::null_mut(),\n-                    ty: lvalue.ty(self.mir, tcx).to_ty(tcx)\n+                    ty: self.monomorphize(&ty),\n                 }\n             }\n             mir::Lvalue::Projection(ref projection) => {"}, {"sha": "49e1e3855571b6bcf9f6fe9ea9f35c96dee97112", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -304,10 +304,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         let result = match *lvalue {\n             mir::Lvalue::Local(_) => bug!(), // handled above\n-            mir::Lvalue::Static(def_id) => {\n-                let const_ty = self.monomorphized_lvalue_ty(lvalue);\n+            mir::Lvalue::Static(box mir::Static { def_id, ty }) => {\n                 LvalueRef::new_sized(consts::get_static(ccx, def_id),\n-                                     LvalueTy::from_ty(const_ty),\n+                                     LvalueTy::from_ty(self.monomorphize(&ty)),\n                                      Alignment::AbiAligned)\n             },\n             mir::Lvalue::Projection(box mir::Projection {"}, {"sha": "cc9fd8f46f6f0236c7e927d29ea6a04bef86084e", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -103,9 +103,9 @@\n //! inlining, even when they are not marked #[inline].\n \n use collector::InliningMap;\n+use common;\n use context::SharedCrateContext;\n use llvm;\n-use monomorphize;\n use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n@@ -468,12 +468,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n             if let Some(impl_def_id) = tcx.impl_of_method(instance.def) {\n                 // This is a method within an inherent impl, find out what the\n                 // self-type is:\n-                let impl_self_ty = tcx.item_type(impl_def_id);\n-                let impl_self_ty = tcx.erase_regions(&impl_self_ty);\n-                let impl_self_ty = monomorphize::apply_param_substs(scx,\n-                                                                    instance.substs,\n-                                                                    &impl_self_ty);\n-\n+                let impl_self_ty = common::def_ty(scx, impl_def_id, instance.substs);\n                 if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n                     return Some(def_id);\n                 }"}, {"sha": "d19f04b9554fb287580e33aeb602c66b2e5906ee", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -22,7 +22,7 @@ use common;\n use declare;\n use glue::DropGlueKind;\n use llvm;\n-use monomorphize::{self, Instance};\n+use monomorphize::Instance;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -146,7 +146,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                         linkage: llvm::Linkage,\n                         symbol_name: &str) {\n         let def_id = ccx.tcx().hir.local_def_id(node_id);\n-        let ty = ccx.tcx().item_type(def_id);\n+        let ty = common::def_ty(ccx.shared(), def_id, Substs::empty());\n         let llty = type_of::type_of(ccx, ty);\n \n         let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n@@ -168,10 +168,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         assert!(!instance.substs.needs_infer() &&\n                 !instance.substs.has_param_types());\n \n-        let item_ty = ccx.tcx().item_type(instance.def);\n-        let item_ty = ccx.tcx().erase_regions(&item_ty);\n-        let mono_ty = monomorphize::apply_param_substs(ccx.shared(), instance.substs, &item_ty);\n-\n+        let mono_ty = common::def_ty(ccx.shared(), instance.def, instance.substs);\n         let attrs = ccx.tcx().get_attrs(instance.def);\n         let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n         unsafe { llvm::LLVMRustSetLinkage(lldecl, linkage) };"}, {"sha": "923ec05c22b77d0410952f3349460e15f4f53331", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -79,13 +79,8 @@ pub trait AstConv<'gcx, 'tcx> {\n                                         item_name: ast::Name)\n                                         -> Ty<'tcx>;\n \n-    /// Project an associated type from a non-higher-ranked trait reference.\n-    /// This is fairly straightforward and can be accommodated in any context.\n-    fn projected_ty(&self,\n-                    span: Span,\n-                    _trait_ref: ty::TraitRef<'tcx>,\n-                    _item_name: ast::Name)\n-                    -> Ty<'tcx>;\n+    /// Normalize an associated type coming from the user.\n+    fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx>;\n \n     /// Invoked when we encounter an error from some prior pass\n     /// (e.g. resolve) that is translated into a ty-error. This is\n@@ -310,8 +305,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     tcx.types.err\n                 } else {\n                     // This is a default type parameter.\n-                    ty::queries::ty::get(tcx, span, def.def_id)\n-                        .subst_spanned(tcx, substs, Some(span))\n+                    self.normalize_ty(\n+                        span,\n+                        ty::queries::ty::get(tcx, span, def.def_id)\n+                            .subst_spanned(tcx, substs, Some(span))\n+                    )\n                 }\n             } else {\n                 // We've already errored above about the mismatch.\n@@ -600,7 +598,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         -> Ty<'tcx>\n     {\n         let substs = self.ast_path_substs_for_ty(span, did, item_segment);\n-        ty::queries::ty::get(self.tcx(), span, did).subst(self.tcx(), substs)\n+        self.normalize_ty(\n+            span,\n+            ty::queries::ty::get(self.tcx(), span, did).subst(self.tcx(), substs)\n+        )\n     }\n \n     /// Transform a PolyTraitRef into a PolyExistentialTraitRef by\n@@ -900,6 +901,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let trait_did = bound.0.def_id;\n         let ty = self.projected_ty_from_poly_trait_ref(span, bound, assoc_name);\n+        let ty = self.normalize_ty(span, ty);\n \n         let item = tcx.associated_items(trait_did).find(|i| i.name == assoc_name);\n         let def_id = item.expect(\"missing associated type\").def_id;\n@@ -939,7 +941,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"qpath_to_ty: trait_ref={:?}\", trait_ref);\n \n-        self.projected_ty(span, trait_ref, item_segment.name)\n+        self.normalize_ty(span, tcx.mk_projection(trait_ref, item_segment.name))\n     }\n \n     pub fn prohibit_type_params(&self, segments: &[hir::PathSegment]) {"}, {"sha": "e8957bad0986c28e380da5d2bc0284a88a03821b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 35, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -665,8 +665,9 @@ fn typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             check_fn(&inh, fn_sig, decl, id, body)\n         } else {\n-            let expected_type = tcx.item_type(def_id);\n             let fcx = FnCtxt::new(&inh, None, body.value.id);\n+            let expected_type = tcx.item_type(def_id);\n+            let expected_type = fcx.normalize_associated_types_in(body.value.span, &expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n             // Gather locals in statics (because of block expressions).\n@@ -1374,16 +1375,15 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n                 infer::LateBoundRegionConversionTime::AssocTypeProjection(item_name),\n                 &poly_trait_ref);\n \n-        self.normalize_associated_type(span, trait_ref, item_name)\n+        self.tcx().mk_projection(trait_ref, item_name)\n     }\n \n-    fn projected_ty(&self,\n-                    span: Span,\n-                    trait_ref: ty::TraitRef<'tcx>,\n-                    item_name: ast::Name)\n-                    -> Ty<'tcx>\n-    {\n-        self.normalize_associated_type(span, trait_ref, item_name)\n+    fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if ty.has_escaping_regions() {\n+            ty // FIXME: normalization and escaping regions\n+        } else {\n+            self.normalize_associated_types_in(span, &ty)\n+        }\n     }\n \n     fn set_tainted_by_errors(&self) {\n@@ -1660,25 +1660,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.inh.normalize_associated_types_in(span, self.body_id, value)\n     }\n \n-    fn normalize_associated_type(&self,\n-                                 span: Span,\n-                                 trait_ref: ty::TraitRef<'tcx>,\n-                                 item_name: ast::Name)\n-                                 -> Ty<'tcx>\n-    {\n-        let cause = traits::ObligationCause::new(span,\n-                                                 self.body_id,\n-                                                 traits::ObligationCauseCode::MiscObligation);\n-        self.fulfillment_cx\n-            .borrow_mut()\n-            .normalize_projection_type(self,\n-                                       ty::ProjectionTy {\n-                                           trait_ref: trait_ref,\n-                                           item_name: item_name,\n-                                       },\n-                                       cause)\n-    }\n-\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx.mk_nil());\n     }\n@@ -1709,9 +1690,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn register_bound(&self,\n-                                  ty: Ty<'tcx>,\n-                                  def_id: DefId,\n-                                  cause: traits::ObligationCause<'tcx>)\n+                          ty: Ty<'tcx>,\n+                          def_id: DefId,\n+                          cause: traits::ObligationCause<'tcx>)\n     {\n         self.fulfillment_cx.borrow_mut()\n             .register_bound(self, ty, def_id, cause);\n@@ -1720,8 +1701,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn register_predicate(&self,\n                               obligation: traits::PredicateObligation<'tcx>)\n     {\n-        debug!(\"register_predicate({:?})\",\n-               obligation);\n+        debug!(\"register_predicate({:?})\", obligation);\n+        if obligation.has_escaping_regions() {\n+            span_bug!(obligation.cause.span, \"escaping regions in predicate {:?}\",\n+                      obligation);\n+        }\n         self.fulfillment_cx\n             .borrow_mut()\n             .register_predicate_obligation(self, obligation);\n@@ -2040,10 +2024,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             Neither => {\n                                 if let Some(default) = default_map.get(ty) {\n                                     let default = default.clone();\n+                                    let default_ty = self.normalize_associated_types_in(\n+                                        default.origin_span, &default.ty);\n                                     match self.eq_types(false,\n                                                         &self.misc(default.origin_span),\n                                                         ty,\n-                                                        default.ty) {\n+                                                        default_ty) {\n                                         Ok(ok) => self.register_infer_ok_obligations(ok),\n                                         Err(_) => conflicts.push((*ty, default)),\n                                     }\n@@ -4344,7 +4330,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             } else if !infer_types && def.has_default {\n                 // No type parameter provided, but a default exists.\n                 let default = self.tcx.item_type(def.def_id);\n-                default.subst_spanned(self.tcx, substs, Some(span))\n+                self.normalize_ty(\n+                    span,\n+                    default.subst_spanned(self.tcx, substs, Some(span))\n+                )\n             } else {\n                 // No type parameters were provided, we can infer all.\n                 // This can also be reached in some error cases:"}, {"sha": "db7cf3c000ba4cae91f45e0567edf4b9b4423365", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -291,7 +291,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n                                         -> Ty<'tcx>\n     {\n         if let Some(trait_ref) = self.tcx().no_late_bound_regions(&poly_trait_ref) {\n-            self.projected_ty(span, trait_ref, item_name)\n+            self.tcx().mk_projection(trait_ref, item_name)\n         } else {\n             // no late-bound regions, we can just ignore the binder\n             span_err!(self.tcx().sess, span, E0212,\n@@ -301,13 +301,10 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn projected_ty(&self,\n-                    _span: Span,\n-                    trait_ref: ty::TraitRef<'tcx>,\n-                    item_name: ast::Name)\n-                    -> Ty<'tcx>\n-    {\n-        self.tcx().mk_projection(trait_ref, item_name)\n+    fn normalize_ty(&self, _span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        // types in item signatures are not normalized, to avoid undue\n+        // dependencies.\n+        ty\n     }\n \n     fn set_tainted_by_errors(&self) {"}, {"sha": "b7a9daaf8abd4c2fdc3db971b8c2e14ffcf9554f", "filename": "src/test/run-pass/issue-27901.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Ftest%2Frun-pass%2Fissue-27901.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Ftest%2Frun-pass%2Fissue-27901.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27901.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Stream { type Item; }\n+impl<'a> Stream for &'a str { type Item = u8; }\n+fn f<'s>(s: &'s str) -> (&'s str, <&'s str as Stream>::Item) {\n+    (s, 42)\n+}\n+\n+fn main() {\n+    let fx = f as for<'t> fn(&'t str) -> (&'t str, <&'t str as Stream>::Item);\n+    assert_eq!(fx(\"hi\"), (\"hi\", 42));\n+}"}, {"sha": "24e4b83e8a6754486e4bb143100a129b78d2b466", "filename": "src/test/run-pass/issue-28828.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Ftest%2Frun-pass%2Fissue-28828.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Ftest%2Frun-pass%2Fissue-28828.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28828.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Foo {\n+    type Out;\n+}\n+\n+impl Foo for () {\n+    type Out = bool;\n+}\n+\n+fn main() {\n+    type Bool = <() as Foo>::Out;\n+\n+    let x: Bool = true;\n+    assert!(x);\n+\n+    let y: Option<Bool> = None;\n+    assert_eq!(y, None);\n+}"}, {"sha": "3e72efada84e621083976722579b8386081ca291", "filename": "src/test/run-pass/issue-39367.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8c6c0f80a399e61d8454bb449962103449b52739/src%2Ftest%2Frun-pass%2Fissue-39367.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c6c0f80a399e61d8454bb449962103449b52739/src%2Ftest%2Frun-pass%2Fissue-39367.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-39367.rs?ref=8c6c0f80a399e61d8454bb449962103449b52739", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+struct ArenaSet<U: Deref, V=<U as Deref>::Target>(U, &'static V)\n+    where V: 'static + ?Sized;\n+\n+static Z: [u8; 4] = [1,2,3,4];\n+\n+fn arena() -> &'static ArenaSet<Vec<u8>> {\n+    fn __static_ref_initialize() -> ArenaSet<Vec<u8>> {\n+        ArenaSet(vec![], &Z)\n+    }\n+    unsafe {\n+        use std::sync::{Once, ONCE_INIT};\n+        fn require_sync<T: Sync>(_: &T) { }\n+        unsafe fn __stability() -> &'static ArenaSet<Vec<u8>> {\n+            use std::mem::transmute;\n+            use std::boxed::Box;\n+            static mut DATA: *const ArenaSet<Vec<u8>> = 0 as *const ArenaSet<Vec<u8>>;\n+\n+            static mut ONCE: Once = ONCE_INIT;\n+            ONCE.call_once(|| {\n+                DATA = transmute\n+                    ::<Box<ArenaSet<Vec<u8>>>, *const ArenaSet<Vec<u8>>>\n+                    (Box::new(__static_ref_initialize()));\n+            });\n+\n+            &*DATA\n+        }\n+        let static_ref = __stability();\n+        require_sync(static_ref);\n+        static_ref\n+    }\n+}\n+\n+fn main() {\n+    let &ArenaSet(ref u, v) = arena();\n+    assert!(u.is_empty());\n+    assert_eq!(v, Z);\n+}"}]}