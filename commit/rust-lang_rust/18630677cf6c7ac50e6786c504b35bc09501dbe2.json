{"sha": "18630677cf6c7ac50e6786c504b35bc09501dbe2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NjMwNjc3Y2Y2YzdhYzUwZTY3ODZjNTA0YjM1YmMwOTUwMWRiZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-25T22:34:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-25T22:34:23Z"}, "message": "Auto merge of #62990 - Centril:rollup-k9n0hvs, r=Centril\n\nRollup of 15 pull requests\n\nSuccessful merges:\n\n - #60066 (Stabilize the type_name intrinsic in core::any)\n - #60938 (rustdoc: make #[doc(include)] relative to the containing file)\n - #61884 (Stablize Euclidean Modulo (feature euclidean_division))\n - #61890 (Fix some sanity checks)\n - #62528 (Add joining slices of slices with a slice separator, not just a single item)\n - #62707 (Add tests for overlapping explicitly dropped locals in generators)\n - #62735 (Turn `#[global_allocator]` into a regular attribute macro)\n - #62822 (Improve some pointer-related documentation)\n - #62887 (Make the parser TokenStream more resilient after mismatched delimiter recovery)\n - #62921 (Add method disambiguation help for trait implementation)\n - #62930 (Add test for #51559)\n - #62942 (Use match ergonomics in Condvar documentation)\n - #62977 (Fix inconsistent highlight blocks.)\n - #62978 (Remove `cfg(bootstrap)` code for array implementations)\n - #62981 (Add note suggesting to borrow a String argument to find)\n\nFailed merges:\n\n - #62964 (clarify and unify some type test names)\n\nr? @ghost", "tree": {"sha": "b6f28ed1be746076ce883fa0ccda880019eb91fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6f28ed1be746076ce883fa0ccda880019eb91fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18630677cf6c7ac50e6786c504b35bc09501dbe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18630677cf6c7ac50e6786c504b35bc09501dbe2", "html_url": "https://github.com/rust-lang/rust/commit/18630677cf6c7ac50e6786c504b35bc09501dbe2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18630677cf6c7ac50e6786c504b35bc09501dbe2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "890881f8f4c77e8670d4b32104c0325fcfefc90f", "url": "https://api.github.com/repos/rust-lang/rust/commits/890881f8f4c77e8670d4b32104c0325fcfefc90f", "html_url": "https://github.com/rust-lang/rust/commit/890881f8f4c77e8670d4b32104c0325fcfefc90f"}, {"sha": "1a775b3b55263a82c3e69a942de5d2cdfb374bf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a775b3b55263a82c3e69a942de5d2cdfb374bf1", "html_url": "https://github.com/rust-lang/rust/commit/1a775b3b55263a82c3e69a942de5d2cdfb374bf1"}], "stats": {"total": 2569, "additions": 1330, "deletions": 1239}, "files": [{"sha": "8993254627863540e842d6ebb48e3f91b2319cea", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -2751,20 +2751,6 @@ dependencies = [\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"rustc_allocator\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc 0.0.0\",\n- \"rustc_data_structures 0.0.0\",\n- \"rustc_errors 0.0.0\",\n- \"rustc_target 0.0.0\",\n- \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"syntax 0.0.0\",\n- \"syntax_pos 0.0.0\",\n-]\n-\n [[package]]\n name = \"rustc_apfloat\"\n version = \"0.0.0\"\n@@ -2822,7 +2808,6 @@ dependencies = [\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc_allocator 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -2883,7 +2868,6 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_allocator 0.0.0\",\n  \"rustc_ast_borrowck 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -2904,7 +2888,6 @@ dependencies = [\n  \"serialize 0.0.0\",\n  \"smallvec 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n- \"syntax_ext 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n \n@@ -2948,7 +2931,6 @@ dependencies = [\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-rayon 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_allocator 0.0.0\",\n  \"rustc_ast_borrowck 0.0.0\",\n  \"rustc_codegen_ssa 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\","}, {"sha": "4e3930c8da7fc5b2b48e9ee771655b46bfb70dc7", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -78,8 +78,11 @@ pub fn check(build: &mut Build) {\n \n     // We need cmake, but only if we're actually building LLVM or sanitizers.\n     let building_llvm = build.hosts.iter()\n-        .filter_map(|host| build.config.target_config.get(host))\n-        .any(|config| config.llvm_config.is_none());\n+        .map(|host| build.config.target_config\n+            .get(host)\n+            .map(|config| config.llvm_config.is_none())\n+            .unwrap_or(true))\n+        .any(|build_llvm_ourselves| build_llvm_ourselves);\n     if building_llvm || build.config.sanitizers {\n         cmd_finder.must_have(\"cmake\");\n     }\n@@ -106,6 +109,14 @@ pub fn check(build: &mut Build) {\n                 build.config.ninja = true;\n             }\n         }\n+\n+        if build.config.lldb_enabled {\n+            cmd_finder.must_have(\"swig\");\n+            let out = output(Command::new(\"swig\").arg(\"-version\"));\n+            if !out.contains(\"SWIG Version 3\") && !out.contains(\"SWIG Version 4\") {\n+                panic!(\"Ensure that Swig 3.x.x or 4.x.x is installed.\");\n+            }\n+        }\n     }\n \n     build.config.python = build.config.python.take().map(|p| cmd_finder.must_have(p))"}, {"sha": "6e32468b64dee0f4c4503f90e3424fd53dfdb61e", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -183,9 +183,8 @@ Book][unstable-masked] and [its tracking issue][issue-masked].\n \n As designed in [RFC 1990], Rustdoc can read an external file to use as a type's documentation. This\n is useful if certain documentation is so long that it would break the flow of reading the source.\n-Instead of writing it all inline, writing `#[doc(include = \"sometype.md\")]` (where `sometype.md` is\n-a file adjacent to the `lib.rs` for the crate) will ask Rustdoc to instead read that file and use it\n-as if it were written inline.\n+Instead of writing it all inline, writing `#[doc(include = \"sometype.md\")]` will ask Rustdoc to\n+instead read that file and use it as if it were written inline.\n \n [RFC 1990]: https://github.com/rust-lang/rfcs/pull/1990\n "}, {"sha": "881d499c0745baf427f3e61e98281d263473b06f", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 83, "deletions": 21, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -494,10 +494,10 @@ impl<T> [T] {\n     /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn concat<Separator: ?Sized>(&self) -> T::Output\n-        where T: SliceConcat<Separator>\n+    pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n+        where Self: Concat<Item>\n     {\n-        SliceConcat::concat(self)\n+        Concat::concat(self)\n     }\n \n     /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n@@ -508,12 +508,13 @@ impl<T> [T] {\n     /// ```\n     /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n     /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n+    /// assert_eq!([[1, 2], [3, 4]].join(&[0, 0][..]), [1, 2, 0, 0, 3, 4]);\n     /// ```\n     #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n-    pub fn join<Separator: ?Sized>(&self, sep: &Separator) -> T::Output\n-        where T: SliceConcat<Separator>\n+    pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n+        where Self: Join<Separator>\n     {\n-        SliceConcat::join(self, sep)\n+        Join::join(self, sep)\n     }\n \n     /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n@@ -528,10 +529,10 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n-    pub fn connect<Separator: ?Sized>(&self, sep: &Separator) -> T::Output\n-        where T: SliceConcat<Separator>\n+    pub fn connect<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n+        where Self: Join<Separator>\n     {\n-        SliceConcat::join(self, sep)\n+        Join::join(self, sep)\n     }\n \n }\n@@ -578,45 +579,83 @@ impl [u8] {\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Helper trait for [`[T]::concat`](../../std/primitive.slice.html#method.concat)\n-/// and [`[T]::join`](../../std/primitive.slice.html#method.join)\n+/// Helper trait for [`[T]::concat`](../../std/primitive.slice.html#method.concat).\n+///\n+/// Note: the `Item` type parameter is not used in this trait,\n+/// but it allows impls to be more generic.\n+/// Without it, we get this error:\n+///\n+/// ```error\n+/// error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predica\n+///    --> src/liballoc/slice.rs:608:6\n+///     |\n+/// 608 | impl<T: Clone, V: Borrow<[T]>> Concat for [V] {\n+///     |      ^ unconstrained type parameter\n+/// ```\n+///\n+/// This is because there could exist `V` types with multiple `Borrow<[_]>` impls,\n+/// such that multiple `T` types would apply:\n+///\n+/// ```\n+/// # #[allow(dead_code)]\n+/// pub struct Foo(Vec<u32>, Vec<String>);\n+///\n+/// impl std::borrow::Borrow<[u32]> for Foo {\n+///     fn borrow(&self) -> &[u32] { &self.0 }\n+/// }\n+///\n+/// impl std::borrow::Borrow<[String]> for Foo {\n+///     fn borrow(&self) -> &[String] { &self.1 }\n+/// }\n+/// ```\n #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n-pub trait SliceConcat<Separator: ?Sized>: Sized {\n+pub trait Concat<Item: ?Sized> {\n     #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n     /// The resulting type after concatenation\n     type Output;\n \n     /// Implementation of [`[T]::concat`](../../std/primitive.slice.html#method.concat)\n     #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n-    fn concat(slice: &[Self]) -> Self::Output;\n+    fn concat(slice: &Self) -> Self::Output;\n+}\n+\n+/// Helper trait for [`[T]::join`](../../std/primitive.slice.html#method.join)\n+#[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+pub trait Join<Separator> {\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+    /// The resulting type after concatenation\n+    type Output;\n \n     /// Implementation of [`[T]::join`](../../std/primitive.slice.html#method.join)\n     #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n-    fn join(slice: &[Self], sep: &Separator) -> Self::Output;\n+    fn join(slice: &Self, sep: Separator) -> Self::Output;\n }\n \n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-impl<T: Clone, V: Borrow<[T]>> SliceConcat<T> for V {\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<T: Clone, V: Borrow<[T]>> Concat<T> for [V] {\n     type Output = Vec<T>;\n \n-    fn concat(slice: &[Self]) -> Vec<T> {\n+    fn concat(slice: &Self) -> Vec<T> {\n         let size = slice.iter().map(|slice| slice.borrow().len()).sum();\n         let mut result = Vec::with_capacity(size);\n         for v in slice {\n             result.extend_from_slice(v.borrow())\n         }\n         result\n     }\n+}\n+\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<T: Clone, V: Borrow<[T]>> Join<&T> for [V] {\n+    type Output = Vec<T>;\n \n-    fn join(slice: &[Self], sep: &T) -> Vec<T> {\n+    fn join(slice: &Self, sep: &T) -> Vec<T> {\n         let mut iter = slice.iter();\n         let first = match iter.next() {\n             Some(first) => first,\n             None => return vec![],\n         };\n-        let size = slice.iter().map(|slice| slice.borrow().len()).sum::<usize>() + slice.len() - 1;\n+        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() + slice.len() - 1;\n         let mut result = Vec::with_capacity(size);\n         result.extend_from_slice(first.borrow());\n \n@@ -628,6 +667,29 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcat<T> for V {\n     }\n }\n \n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<T: Clone, V: Borrow<[T]>> Join<&[T]> for [V] {\n+    type Output = Vec<T>;\n+\n+    fn join(slice: &Self, sep: &[T]) -> Vec<T> {\n+        let mut iter = slice.iter();\n+        let first = match iter.next() {\n+            Some(first) => first,\n+            None => return vec![],\n+        };\n+        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() +\n+            sep.len() * (slice.len() - 1);\n+        let mut result = Vec::with_capacity(size);\n+        result.extend_from_slice(first.borrow());\n+\n+        for v in iter {\n+            result.extend_from_slice(sep);\n+            result.extend_from_slice(v.borrow())\n+        }\n+        result\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Standard trait implementations for slices\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "9a1342c30d502b57130c632b4c3011faf1420f40", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -37,7 +37,7 @@ use core::unicode::conversions;\n \n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n-use crate::slice::{SliceConcat, SliceIndex};\n+use crate::slice::{Concat, Join, SliceIndex};\n use crate::string::String;\n use crate::vec::Vec;\n \n@@ -71,17 +71,22 @@ pub use core::str::SplitAsciiWhitespace;\n #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n pub use core::str::{EscapeDebug, EscapeDefault, EscapeUnicode};\n \n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-impl<S: Borrow<str>> SliceConcat<str> for S {\n+/// Note: `str` in `Concat<str>` is not meaningful here.\n+/// This type parameter of the trait only exists to enable another impl.\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<S: Borrow<str>> Concat<str> for [S] {\n     type Output = String;\n \n-    fn concat(slice: &[Self]) -> String {\n-        Self::join(slice, \"\")\n+    fn concat(slice: &Self) -> String {\n+        Join::join(slice, \"\")\n     }\n+}\n+\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<S: Borrow<str>> Join<&str> for [S] {\n+    type Output = String;\n \n-    fn join(slice: &[Self], sep: &str) -> String {\n+    fn join(slice: &Self, sep: &str) -> String {\n         unsafe {\n             String::from_utf8_unchecked( join_generic_copy(slice, sep.as_bytes()) )\n         }"}, {"sha": "f7aef66942d9b556a62cdb5a400029353af9e5d1", "filename": "src/libcore/any.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -450,3 +450,29 @@ impl TypeId {\n         }\n     }\n }\n+\n+/// Returns the name of a type as a string slice.\n+///\n+/// # Note\n+///\n+/// This is intended for diagnostic use. The exact contents and format of the\n+/// string are not specified, other than being a best-effort description of the\n+/// type. For example, `type_name::<Option<String>>()` could return the\n+/// `\"Option<String>\"` or `\"std::option::Option<std::string::String>\"`, but not\n+/// `\"foobar\"`. In addition, the output may change between versions of the\n+/// compiler.\n+///\n+/// The type name should not be considered a unique identifier of a type;\n+/// multiple types may share the same type name.\n+///\n+/// The current implementation uses the same infrastructure as compiler\n+/// diagnostics and debuginfo, but this is not guaranteed.\n+#[stable(feature = \"type_name\", since = \"1.38.0\")]\n+pub fn type_name<T: ?Sized>() -> &'static str {\n+    #[cfg(bootstrap)]\n+    unsafe {\n+        intrinsics::type_name::<T>()\n+    }\n+    #[cfg(not(bootstrap))]\n+    intrinsics::type_name::<T>()\n+}"}, {"sha": "6ecc0487fae1b16fdadaf00c94d36a3117a9b373", "filename": "src/libcore/array.rs", "status": "modified", "additions": 240, "deletions": 433, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -81,487 +81,296 @@ impl From<Infallible> for TryFromSliceError {\n     }\n }\n \n-#[cfg(bootstrap)]\n-macro_rules! __impl_slice_eq1 {\n-    ($Lhs: ty, $Rhs: ty) => {\n-        __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n-    };\n-    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n-            #[inline]\n-            fn eq(&self, other: &$Rhs) -> bool { self[..] == other[..] }\n-            #[inline]\n-            fn ne(&self, other: &$Rhs) -> bool { self[..] != other[..] }\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, const N: usize> AsRef<[T]> for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn as_ref(&self) -> &[T] {\n+        &self[..]\n     }\n }\n \n-#[cfg(bootstrap)]\n-macro_rules! __impl_slice_eq2 {\n-    ($Lhs: ty, $Rhs: ty) => {\n-        __impl_slice_eq2! { $Lhs, $Rhs, Sized }\n-    };\n-    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n-        __impl_slice_eq1!($Lhs, $Rhs, $Bound);\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, 'b, A: $Bound, B> PartialEq<$Lhs> for $Rhs where B: PartialEq<A> {\n-            #[inline]\n-            fn eq(&self, other: &$Lhs) -> bool { self[..] == other[..] }\n-            #[inline]\n-            fn ne(&self, other: &$Lhs) -> bool { self[..] != other[..] }\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, const N: usize> AsMut<[T]> for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn as_mut(&mut self) -> &mut [T] {\n+        &mut self[..]\n     }\n }\n \n-// macro for implementing n-element array functions and operations\n-#[cfg(bootstrap)]\n-macro_rules! array_impls {\n-    ($($N:expr)+) => {\n-        $(\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T> AsRef<[T]> for [T; $N] {\n-                #[inline]\n-                fn as_ref(&self) -> &[T] {\n-                    &self[..]\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T> AsMut<[T]> for [T; $N] {\n-                #[inline]\n-                fn as_mut(&mut self) -> &mut [T] {\n-                    &mut self[..]\n-                }\n-            }\n-\n-            #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-            impl<T> Borrow<[T]> for [T; $N] {\n-                fn borrow(&self) -> &[T] {\n-                    self\n-                }\n-            }\n-\n-            #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-            impl<T> BorrowMut<[T]> for [T; $N] {\n-                fn borrow_mut(&mut self) -> &mut [T] {\n-                    self\n-                }\n-            }\n-\n-            #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-            impl<T> TryFrom<&[T]> for [T; $N] where T: Copy {\n-                type Error = TryFromSliceError;\n-\n-                fn try_from(slice: &[T]) -> Result<[T; $N], TryFromSliceError> {\n-                    <&Self>::try_from(slice).map(|r| *r)\n-                }\n-            }\n-\n-            #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-            impl<'a, T> TryFrom<&'a [T]> for &'a [T; $N] {\n-                type Error = TryFromSliceError;\n-\n-                fn try_from(slice: &[T]) -> Result<&[T; $N], TryFromSliceError> {\n-                    if slice.len() == $N {\n-                        let ptr = slice.as_ptr() as *const [T; $N];\n-                        unsafe { Ok(&*ptr) }\n-                    } else {\n-                        Err(TryFromSliceError(()))\n-                    }\n-                }\n-            }\n-\n-            #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-            impl<'a, T> TryFrom<&'a mut [T]> for &'a mut [T; $N] {\n-                type Error = TryFromSliceError;\n-\n-                fn try_from(slice: &mut [T]) -> Result<&mut [T; $N], TryFromSliceError> {\n-                    if slice.len() == $N {\n-                        let ptr = slice.as_mut_ptr() as *mut [T; $N];\n-                        unsafe { Ok(&mut *ptr) }\n-                    } else {\n-                        Err(TryFromSliceError(()))\n-                    }\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T: Hash> Hash for [T; $N] {\n-                fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-                    Hash::hash(&self[..], state)\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T: fmt::Debug> fmt::Debug for [T; $N] {\n-                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                    fmt::Debug::fmt(&&self[..], f)\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<'a, T> IntoIterator for &'a [T; $N] {\n-                type Item = &'a T;\n-                type IntoIter = Iter<'a, T>;\n-\n-                fn into_iter(self) -> Iter<'a, T> {\n-                    self.iter()\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<'a, T> IntoIterator for &'a mut [T; $N] {\n-                type Item = &'a mut T;\n-                type IntoIter = IterMut<'a, T>;\n-\n-                fn into_iter(self) -> IterMut<'a, T> {\n-                    self.iter_mut()\n-                }\n-            }\n-\n-            // NOTE: some less important impls are omitted to reduce code bloat\n-            __impl_slice_eq1! { [A; $N], [B; $N] }\n-            __impl_slice_eq2! { [A; $N], [B] }\n-            __impl_slice_eq2! { [A; $N], &'b [B] }\n-            __impl_slice_eq2! { [A; $N], &'b mut [B] }\n-            // __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n-            // __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T:Eq> Eq for [T; $N] { }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T:PartialOrd> PartialOrd for [T; $N] {\n-                #[inline]\n-                fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n-                    PartialOrd::partial_cmp(&&self[..], &&other[..])\n-                }\n-                #[inline]\n-                fn lt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::lt(&&self[..], &&other[..])\n-                }\n-                #[inline]\n-                fn le(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::le(&&self[..], &&other[..])\n-                }\n-                #[inline]\n-                fn ge(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::ge(&&self[..], &&other[..])\n-                }\n-                #[inline]\n-                fn gt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::gt(&&self[..], &&other[..])\n-                }\n-            }\n-\n-            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<T:Ord> Ord for [T; $N] {\n-                #[inline]\n-                fn cmp(&self, other: &[T; $N]) -> Ordering {\n-                    Ord::cmp(&&self[..], &&other[..])\n-                }\n-            }\n-        )+\n+#[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n+impl<T, const N: usize> Borrow<[T]> for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn borrow(&self) -> &[T] {\n+        self\n     }\n }\n \n-#[cfg(not(bootstrap))]\n-mod impls_using_const_generics {\n-    use super::*;\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T, const N: usize> AsRef<[T]> for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn as_ref(&self) -> &[T] {\n-            &self[..]\n-        }\n+#[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n+impl<T, const N: usize> BorrowMut<[T]> for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn borrow_mut(&mut self) -> &mut [T] {\n+        self\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T, const N: usize> AsMut<[T]> for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn as_mut(&mut self) -> &mut [T] {\n-            &mut self[..]\n-        }\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl<T, const N: usize> TryFrom<&[T]> for [T; N]\n+where\n+    T: Copy,\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = TryFromSliceError;\n+\n+    fn try_from(slice: &[T]) -> Result<[T; N], TryFromSliceError> {\n+        <&Self>::try_from(slice).map(|r| *r)\n     }\n+}\n \n-    #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-    impl<T, const N: usize> Borrow<[T]> for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        fn borrow(&self) -> &[T] {\n-            self\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = TryFromSliceError;\n+\n+    fn try_from(slice: &[T]) -> Result<&[T; N], TryFromSliceError> {\n+        if slice.len() == N {\n+            let ptr = slice.as_ptr() as *const [T; N];\n+            unsafe { Ok(&*ptr) }\n+        } else {\n+            Err(TryFromSliceError(()))\n         }\n     }\n+}\n \n-    #[stable(feature = \"array_borrow\", since = \"1.4.0\")]\n-    impl<T, const N: usize> BorrowMut<[T]> for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        fn borrow_mut(&mut self) -> &mut [T] {\n-            self\n+#[stable(feature = \"try_from\", since = \"1.34.0\")]\n+impl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = TryFromSliceError;\n+\n+    fn try_from(slice: &mut [T]) -> Result<&mut [T; N], TryFromSliceError> {\n+        if slice.len() == N {\n+            let ptr = slice.as_mut_ptr() as *mut [T; N];\n+            unsafe { Ok(&mut *ptr) }\n+        } else {\n+            Err(TryFromSliceError(()))\n         }\n     }\n+}\n \n-    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-    impl<T, const N: usize> TryFrom<&[T]> for [T; N]\n-    where\n-        T: Copy,\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Error = TryFromSliceError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Hash, const N: usize> Hash for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        Hash::hash(&self[..], state)\n+    }\n+}\n \n-        fn try_from(slice: &[T]) -> Result<[T; N], TryFromSliceError> {\n-            <&Self>::try_from(slice).map(|r| *r)\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&&self[..], f)\n     }\n+}\n \n-    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-    impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Error = TryFromSliceError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, const N: usize> IntoIterator for &'a [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n \n-        fn try_from(slice: &[T]) -> Result<&[T; N], TryFromSliceError> {\n-            if slice.len() == N {\n-                let ptr = slice.as_ptr() as *const [T; N];\n-                unsafe { Ok(&*ptr) }\n-            } else {\n-                Err(TryFromSliceError(()))\n-            }\n-        }\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n     }\n+}\n \n-    #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-    impl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Error = TryFromSliceError;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, const N: usize> IntoIterator for &'a mut [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Item = &'a mut T;\n+    type IntoIter = IterMut<'a, T>;\n \n-        fn try_from(slice: &mut [T]) -> Result<&mut [T; N], TryFromSliceError> {\n-            if slice.len() == N {\n-                let ptr = slice.as_mut_ptr() as *mut [T; N];\n-                unsafe { Ok(&mut *ptr) }\n-            } else {\n-                Err(TryFromSliceError(()))\n-            }\n-        }\n+    fn into_iter(self) -> IterMut<'a, T> {\n+        self.iter_mut()\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Hash, const N: usize> Hash for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-            Hash::hash(&self[..], state)\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[B; N]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+    [A; N]: LengthAtMost32,\n+    [B; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[B; N]) -> bool {\n+        self[..] == other[..]\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: fmt::Debug, const N: usize> fmt::Debug for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            fmt::Debug::fmt(&&self[..], f)\n-        }\n+    #[inline]\n+    fn ne(&self, other: &[B; N]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, T, const N: usize> IntoIterator for &'a [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Item = &'a T;\n-        type IntoIter = Iter<'a, T>;\n-\n-        fn into_iter(self) -> Iter<'a, T> {\n-            self.iter()\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[B]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[B]) -> bool {\n+        self[..] == other[..]\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, T, const N: usize> IntoIterator for &'a mut [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        type Item = &'a mut T;\n-        type IntoIter = IterMut<'a, T>;\n-\n-        fn into_iter(self) -> IterMut<'a, T> {\n-            self.iter_mut()\n-        }\n+    #[inline]\n+    fn ne(&self, other: &[B]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[B; N]> for [A; N]\n-    where\n-        A: PartialEq<B>,\n-        [A; N]: LengthAtMost32,\n-        [B; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[B; N]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[B; N]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for [B]\n+where\n+    B: PartialEq<A>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[A; N]) -> bool {\n+        self[..] == other[..]\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[B]> for [A; N]\n-    where\n-        A: PartialEq<B>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[B]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[B]) -> bool {\n-            self[..] != other[..]\n-        }\n+    #[inline]\n+    fn ne(&self, other: &[A; N]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for [B]\n-    where\n-        B: PartialEq<A>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[A; N]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[A; N]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<&'b [B]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &&'b [B]) -> bool {\n+        self[..] == other[..]\n     }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<&'b [B]> for [A; N]\n-    where\n-        A: PartialEq<B>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &&'b [B]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &&'b [B]) -> bool {\n-            self[..] != other[..]\n-        }\n+    #[inline]\n+    fn ne(&self, other: &&'b [B]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b [B]\n-    where\n-        B: PartialEq<A>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[A; N]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[A; N]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b [B]\n+where\n+    B: PartialEq<A>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[A; N]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &[A; N]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<&'b mut [B]> for [A; N]\n-    where\n-        A: PartialEq<B>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &&'b mut [B]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &&'b mut [B]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<&'b mut [B]> for [A; N]\n+where\n+    A: PartialEq<B>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &&'b mut [B]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &&'b mut [B]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b mut [B]\n-    where\n-        B: PartialEq<A>,\n-        [A; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn eq(&self, other: &[A; N]) -> bool {\n-            self[..] == other[..]\n-        }\n-        #[inline]\n-        fn ne(&self, other: &[A; N]) -> bool {\n-            self[..] != other[..]\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, A, B, const N: usize> PartialEq<[A; N]> for &'b mut [B]\n+where\n+    B: PartialEq<A>,\n+    [A; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn eq(&self, other: &[A; N]) -> bool {\n+        self[..] == other[..]\n+    }\n+    #[inline]\n+    fn ne(&self, other: &[A; N]) -> bool {\n+        self[..] != other[..]\n     }\n+}\n \n-    // NOTE: some less important impls are omitted to reduce code bloat\n-    // __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n-    // __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n+// NOTE: some less important impls are omitted to reduce code bloat\n+// __impl_slice_eq2! { [A; $N], &'b [B; $N] }\n+// __impl_slice_eq2! { [A; $N], &'b mut [B; $N] }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Eq, const N: usize> Eq for [T; N] where [T; N]: LengthAtMost32 {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Eq, const N: usize> Eq for [T; N] where [T; N]: LengthAtMost32 {}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: PartialOrd, const N: usize> PartialOrd for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn partial_cmp(&self, other: &[T; N]) -> Option<Ordering> {\n-            PartialOrd::partial_cmp(&&self[..], &&other[..])\n-        }\n-        #[inline]\n-        fn lt(&self, other: &[T; N]) -> bool {\n-            PartialOrd::lt(&&self[..], &&other[..])\n-        }\n-        #[inline]\n-        fn le(&self, other: &[T; N]) -> bool {\n-            PartialOrd::le(&&self[..], &&other[..])\n-        }\n-        #[inline]\n-        fn ge(&self, other: &[T; N]) -> bool {\n-            PartialOrd::ge(&&self[..], &&other[..])\n-        }\n-        #[inline]\n-        fn gt(&self, other: &[T; N]) -> bool {\n-            PartialOrd::gt(&&self[..], &&other[..])\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: PartialOrd, const N: usize> PartialOrd for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn partial_cmp(&self, other: &[T; N]) -> Option<Ordering> {\n+        PartialOrd::partial_cmp(&&self[..], &&other[..])\n+    }\n+    #[inline]\n+    fn lt(&self, other: &[T; N]) -> bool {\n+        PartialOrd::lt(&&self[..], &&other[..])\n+    }\n+    #[inline]\n+    fn le(&self, other: &[T; N]) -> bool {\n+        PartialOrd::le(&&self[..], &&other[..])\n     }\n+    #[inline]\n+    fn ge(&self, other: &[T; N]) -> bool {\n+        PartialOrd::ge(&&self[..], &&other[..])\n+    }\n+    #[inline]\n+    fn gt(&self, other: &[T; N]) -> bool {\n+        PartialOrd::gt(&&self[..], &&other[..])\n+    }\n+}\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<T: Ord, const N: usize> Ord for [T; N]\n-    where\n-        [T; N]: LengthAtMost32,\n-    {\n-        #[inline]\n-        fn cmp(&self, other: &[T; N]) -> Ordering {\n-            Ord::cmp(&&self[..], &&other[..])\n-        }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Ord, const N: usize> Ord for [T; N]\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    #[inline]\n+    fn cmp(&self, other: &[T; N]) -> Ordering {\n+        Ord::cmp(&&self[..], &&other[..])\n     }\n }\n \n@@ -571,10 +380,8 @@ mod impls_using_const_generics {\n )]\n #[unstable(feature = \"const_generic_impls_guard\", issue = \"0\",\n     reason = \"will never be stable, just a temporary step until const generics are stable\")]\n-#[cfg(not(bootstrap))]\n pub trait LengthAtMost32 {}\n \n-#[cfg(not(bootstrap))]\n macro_rules! array_impls {\n     ($($N:literal)+) => {\n         $("}, {"sha": "aa834db2b9b3e99f68d8fd1f9454570305fc765a", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -547,10 +547,10 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` satisfies the 'XID_Start' Unicode property, and false\n+    /// Returns `true` if this `char` satisfies the `XID_Start` Unicode property, and false\n     /// otherwise.\n     ///\n-    /// 'XID_Start' is a Unicode Derived Property specified in\n+    /// `XID_Start` is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to `ID_Start` but modified for closure under `NFKx`.\n     #[cfg_attr(bootstrap,\n@@ -563,12 +563,12 @@ impl char {\n         derived_property::XID_Start(self)\n     }\n \n-    /// Returns `true` if this `char` satisfies the 'XID_Continue' Unicode property, and false\n+    /// Returns `true` if this `char` satisfies the `XID_Continue` Unicode property, and false\n     /// otherwise.\n     ///\n-    /// 'XID_Continue' is a Unicode Derived Property specified in\n+    /// `XID_Continue` is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n+    /// mostly similar to `ID_Continue` but modified for closure under NFKx.\n     #[cfg_attr(bootstrap,\n                unstable(feature = \"rustc_private\",\n                         reason = \"mainly needed for compiler internals\",\n@@ -666,7 +666,7 @@ impl char {\n     /// Returns `true` if this `char` is alphanumeric.\n     ///\n     /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n-    /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n+    /// `Nd`, `Nl`, `No` and the Derived Core Property `Alphabetic`.\n     ///\n     /// # Examples\n     ///\n@@ -720,7 +720,7 @@ impl char {\n     /// Returns `true` if this `char` is numeric.\n     ///\n     /// 'Numeric'-ness is defined in terms of the Unicode General Categories\n-    /// 'Nd', 'Nl', 'No'.\n+    /// `Nd`, `Nl`, `No`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "2bb941b490e56097d20a4940bed90eb27393e015", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -74,7 +74,7 @@\n #![feature(concat_idents)]\n #![feature(const_fn)]\n #![feature(const_fn_union)]\n-#![cfg_attr(not(bootstrap), feature(const_generics))]\n+#![feature(const_generics)]\n #![feature(custom_inner_attributes)]\n #![feature(decl_macro)]\n #![feature(doc_cfg)]"}, {"sha": "17781798946ed8d71f86b467ca18e09208a619ef", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1281,6 +1281,13 @@ mod builtin {\n     #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test_case($item:item) { /* compiler built-in */ }\n \n+    /// Attribute macro applied to a static to register it as a global allocator.\n+    #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n+    #[allow_internal_unstable(rustc_attrs)]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro global_allocator($item:item) { /* compiler built-in */ }\n+\n     /// Derive macro generating an impl of the trait `Clone`.\n     #[rustc_builtin_macro]\n     #[rustc_macro_transparency = \"semitransparent\"]"}, {"sha": "67e30e7ffcb24d371d9f4c691d6e4c3cab5b62aa", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -717,13 +717,12 @@ returning `None` if `rhs == 0` or the division results in overflow.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n assert_eq!((\", stringify!($SelfT),\n \"::min_value() + 1).checked_div_euclid(-1), Some(\", stringify!($Max), \"));\n assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div_euclid(-1), None);\n assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n@@ -774,14 +773,13 @@ if `rhs == 0` or the division results in overflow.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n use std::\", stringify!($SelfT), \";\n \n assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\n assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n@@ -1210,11 +1208,10 @@ This function will panic if `rhs` is 0.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n@@ -1269,11 +1266,10 @@ This function will panic if `rhs` is 0.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n@@ -1566,15 +1562,14 @@ This function will panic if `rhs` is 0.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n use std::\", stringify!($SelfT), \";\n \n assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringify!($SelfT),\n \"::MIN, true));\n ```\"),\n             #[inline]\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n@@ -1636,13 +1631,12 @@ This function will panic if `rhs` is 0.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n use std::\", stringify!($SelfT), \";\n \n assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n@@ -1873,7 +1867,6 @@ This function will panic if `rhs` is 0.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n let a: \", stringify!($SelfT), \" = 7; // or any other integer type\n let b = 4;\n \n@@ -1882,7 +1875,7 @@ assert_eq!(a.div_euclid(-b), -1); // 7 >= -4 * -1\n assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n@@ -1913,7 +1906,6 @@ This function will panic if `rhs` is 0.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n let a: \", stringify!($SelfT), \" = 7; // or any other integer type\n let b = 4;\n \n@@ -1922,7 +1914,7 @@ assert_eq!((-a).rem_euclid(b), 1);\n assert_eq!(a.rem_euclid(-b), 3);\n assert_eq!((-a).rem_euclid(-b), 1);\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n@@ -2753,11 +2745,10 @@ if `rhs == 0`.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\n assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n@@ -2805,11 +2796,10 @@ if `rhs == 0`.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\n assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n@@ -3127,10 +3117,9 @@ is exactly equal to `self.wrapping_div(rhs)`.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n@@ -3179,10 +3168,9 @@ is exactly equal to `self.wrapping_rem(rhs)`.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n@@ -3448,11 +3436,10 @@ This function will panic if `rhs` is 0.\n Basic usage\n \n ```\n-#![feature(euclidean_division)]\n assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n ```\"),\n             #[inline]\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n@@ -3508,11 +3495,10 @@ This function will panic if `rhs` is 0.\n Basic usage\n \n ```\n-#![feature(euclidean_division)]\n assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n ```\"),\n             #[inline]\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n@@ -3696,10 +3682,9 @@ is exactly equal to `self / rhs`.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n@@ -3722,10 +3707,9 @@ is exactly equal to `self % rhs`.\n Basic usage:\n \n ```\n-#![feature(euclidean_division)]\n assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\n ```\"),\n-            #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]"}, {"sha": "b9552eaa1a0e5678c8b66aa6e2af55508416ea9b", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -137,6 +137,10 @@ pub trait Fn<Args> : FnMut<Args> {\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n     on(Args=\"()\", note=\"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}\"),\n+    on(\n+        all(Args=\"(char,)\", _Self=\"std::string::String\"),\n+        note=\"borrowing the `{Self}` might fix the problem\"\n+    ),\n     message=\"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n     label=\"expected an `FnMut<{Args}>` closure, found `{Self}`\",\n )]"}, {"sha": "505f8b0a261d72616d3b26d366ca5a310093ffbb", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -5,7 +5,6 @@\n #![feature(core_private_diy_float)]\n #![feature(debug_map_key_value)]\n #![feature(dec2flt)]\n-#![feature(euclidean_division)]\n #![feature(exact_size_is_empty)]\n #![feature(fixed_size_array)]\n #![feature(flt2dec)]"}, {"sha": "79f60778d3cf397e65ebbb2a311fa965e99f6771", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -104,7 +104,6 @@ pub mod infer;\n pub mod lint;\n \n pub mod middle {\n-    pub mod allocator;\n     pub mod borrowck;\n     pub mod expr_use_visitor;\n     pub mod cstore;"}, {"sha": "bb2e3b4ec19715c7f2bc830dce78b164a56addb3", "filename": "src/librustc/middle/allocator.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/890881f8f4c77e8670d4b32104c0325fcfefc90f/src%2Flibrustc%2Fmiddle%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890881f8f4c77e8670d4b32104c0325fcfefc90f/src%2Flibrustc%2Fmiddle%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fallocator.rs?ref=890881f8f4c77e8670d4b32104c0325fcfefc90f", "patch": "@@ -1,16 +0,0 @@\n-#[derive(Clone, Copy)]\n-pub enum AllocatorKind {\n-    Global,\n-    DefaultLib,\n-    DefaultExe,\n-}\n-\n-impl AllocatorKind {\n-    pub fn fn_name(&self, base: &str) -> String {\n-        match *self {\n-            AllocatorKind::Global => format!(\"__rg_{}\", base),\n-            AllocatorKind::DefaultLib => format!(\"__rdl_{}\", base),\n-            AllocatorKind::DefaultExe => format!(\"__rde_{}\", base),\n-        }\n-    }\n-}"}, {"sha": "88de77829a6e06fc28da53a50f331fd61fec1b5a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -320,11 +320,6 @@ fn has_allow_dead_code_or_lang_attr(\n         return true;\n     }\n \n-    // Don't lint about global allocators\n-    if attr::contains_name(attrs, sym::global_allocator) {\n-        return true;\n-    }\n-\n     let def_id = tcx.hir().local_def_id(id);\n     let cg_attrs = tcx.codegen_fn_attrs(def_id);\n "}, {"sha": "61dac678912dff657868accb27c0a620c1168778", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::fingerprint::Fingerprint;\n \n use crate::lint;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n-use crate::middle::allocator::AllocatorKind;\n use crate::middle::dependency_format;\n use crate::session::config::{OutputType, PrintRequest, SwitchWithOptPath};\n use crate::session::search_paths::{PathKind, SearchPath};\n@@ -27,6 +26,7 @@ use errors::emitter::HumanReadableErrorType;\n use errors::annotate_snippet_emitter_writer::{AnnotateSnippetEmitterWriter};\n use syntax::ast::{self, NodeId};\n use syntax::edition::Edition;\n+use syntax::ext::allocator::AllocatorKind;\n use syntax::feature_gate::{self, AttributeType};\n use syntax::json::JsonEmitter;\n use syntax::source_map;"}, {"sha": "2ffcd0fd4d941b054ff92b0c7be849cb06492d2f", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -34,7 +34,7 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n     {\n         debug!(\n             \"normalize::<{}>(value={:?}, param_env={:?})\",\n-            unsafe { ::std::intrinsics::type_name::<T>() },\n+            ::std::any::type_name::<T>(),\n             value,\n             self.param_env,\n         );"}, {"sha": "d09288461d44489d4bb3200ce8e54d5f425257c5", "filename": "src/librustc/traits/query/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize_erasing_regions.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -22,7 +22,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     {\n         debug!(\n             \"normalize_erasing_regions::<{}>(value={:?}, param_env={:?})\",\n-            unsafe { ::std::intrinsics::type_name::<T>() },\n+            ::std::any::type_name::<T>(),\n             value,\n             param_env,\n         );"}, {"sha": "1cc083ea93c6c1c66fee90fabcc19fd1ebbc75d2", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -69,7 +69,7 @@ impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()\n         } else {\n-            let name = unsafe { ::std::intrinsics::type_name::<M>() };\n+            let name = ::std::any::type_name::<M>();\n             format!(\"processing {:?} with query `{}`\", def_id, name).into()\n         }\n     }"}, {"sha": "f4b99ca3688747ee0c8cca34e2b34cc907db146f", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -54,7 +54,7 @@ use rustc_target::spec::PanicStrategy;\n use std::borrow::Cow;\n use std::ops::Deref;\n use std::sync::Arc;\n-use std::intrinsics::type_name;\n+use std::any::type_name;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::symbol::InternedString;\n use syntax::attr;"}, {"sha": "45bc89f5a84abefdf1c0d4899909bf815366f6c7", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1060,7 +1060,7 @@ where\n     Q::Value: Encodable,\n {\n     let desc = &format!(\"encode_query_results for {}\",\n-        unsafe { ::std::intrinsics::type_name::<Q>() });\n+        ::std::any::type_name::<Q>());\n \n     time_ext(tcx.sess.time_extended(), Some(tcx.sess), desc, || {\n         let map = Q::query_cache(tcx).borrow();"}, {"sha": "ce9f67db592324e8d11fe80949ab48a1b3270b16", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -782,9 +782,9 @@ macro_rules! define_queries_inner {\n                         #[cfg(not(debug_assertions))]\n                         cache_hits: 0,\n                         key_size: mem::size_of::<Q::Key>(),\n-                        key_type: unsafe { type_name::<Q::Key>() },\n+                        key_type: type_name::<Q::Key>(),\n                         value_size: mem::size_of::<Q::Value>(),\n-                        value_type: unsafe { type_name::<Q::Value>() },\n+                        value_type: type_name::<Q::Value>(),\n                         entry_count: map.results.len(),\n                     }\n                 }"}, {"sha": "a964f323c9e7d06214eb8831b2fbbc81a13bee58", "filename": "src/librustc_allocator/Cargo.toml", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/890881f8f4c77e8670d4b32104c0325fcfefc90f/src%2Flibrustc_allocator%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/890881f8f4c77e8670d4b32104c0325fcfefc90f/src%2Flibrustc_allocator%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2FCargo.toml?ref=890881f8f4c77e8670d4b32104c0325fcfefc90f", "patch": "@@ -1,19 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rustc_allocator\"\n-version = \"0.0.0\"\n-edition = \"2018\"\n-\n-[lib]\n-path = \"lib.rs\"\n-test = false\n-\n-[dependencies]\n-rustc = { path = \"../librustc\" }\n-rustc_data_structures = { path = \"../librustc_data_structures\" }\n-rustc_errors = { path = \"../librustc_errors\" }\n-rustc_target = { path = \"../librustc_target\" }\n-syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n-log = \"0.4\"\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "af63fffc0f9b4074a7fd32b0f9ed733d40e6c562", "filename": "src/librustc_allocator/expand.rs", "status": "removed", "additions": 0, "deletions": 298, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/890881f8f4c77e8670d4b32104c0325fcfefc90f/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890881f8f4c77e8670d4b32104c0325fcfefc90f/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=890881f8f4c77e8670d4b32104c0325fcfefc90f", "patch": "@@ -1,298 +0,0 @@\n-use log::debug;\n-use rustc::middle::allocator::AllocatorKind;\n-use smallvec::{smallvec, SmallVec};\n-use syntax::{\n-    ast::{\n-        self, Arg, Attribute, Crate, Expr, FnHeader, Generics, Ident, Item, ItemKind,\n-        Mac, Mod, Mutability, Ty, TyKind, Unsafety, VisibilityKind,\n-    },\n-    attr,\n-    source_map::{\n-        respan, ExpnInfo, ExpnKind,\n-    },\n-    ext::{\n-        base::{ExtCtxt, MacroKind, Resolver},\n-        build::AstBuilder,\n-        expand::ExpansionConfig,\n-        hygiene::ExpnId,\n-    },\n-    mut_visit::{self, MutVisitor},\n-    parse::ParseSess,\n-    ptr::P,\n-    symbol::{kw, sym}\n-};\n-use syntax_pos::Span;\n-\n-use crate::{AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n-\n-pub fn modify(\n-    sess: &ParseSess,\n-    resolver: &mut dyn Resolver,\n-    krate: &mut Crate,\n-    crate_name: String,\n-    handler: &rustc_errors::Handler,\n-) {\n-    ExpandAllocatorDirectives {\n-        handler,\n-        sess,\n-        resolver,\n-        found: false,\n-        crate_name: Some(crate_name),\n-        in_submod: -1, // -1 to account for the \"root\" module\n-    }.visit_crate(krate);\n-}\n-\n-struct ExpandAllocatorDirectives<'a> {\n-    found: bool,\n-    handler: &'a rustc_errors::Handler,\n-    sess: &'a ParseSess,\n-    resolver: &'a mut dyn Resolver,\n-    crate_name: Option<String>,\n-\n-    // For now, we disallow `global_allocator` in submodules because hygiene is hard. Keep track of\n-    // whether we are in a submodule or not. If `in_submod > 0` we are in a submodule.\n-    in_submod: isize,\n-}\n-\n-impl MutVisitor for ExpandAllocatorDirectives<'_> {\n-    fn flat_map_item(&mut self, item: P<Item>) -> SmallVec<[P<Item>; 1]> {\n-        debug!(\"in submodule {}\", self.in_submod);\n-\n-        if !attr::contains_name(&item.attrs, sym::global_allocator) {\n-            return mut_visit::noop_flat_map_item(item, self);\n-        }\n-\n-        match item.node {\n-            ItemKind::Static(..) => {}\n-            _ => {\n-                self.handler\n-                    .span_err(item.span, \"allocators must be statics\");\n-                return smallvec![item];\n-            }\n-        }\n-\n-        if self.in_submod > 0 {\n-            self.handler\n-                .span_err(item.span, \"`global_allocator` cannot be used in submodules\");\n-            return smallvec![item];\n-        }\n-\n-        if self.found {\n-            self.handler\n-                .span_err(item.span, \"cannot define more than one `#[global_allocator]`\");\n-            return smallvec![item];\n-        }\n-        self.found = true;\n-\n-        // Create a new expansion for the generated allocator code.\n-        let span = item.span.fresh_expansion(ExpnId::root(), ExpnInfo::allow_unstable(\n-            ExpnKind::Macro(MacroKind::Attr, sym::global_allocator), item.span, self.sess.edition,\n-            [sym::rustc_attrs][..].into(),\n-        ));\n-\n-        // Create an expansion config\n-        let ecfg = ExpansionConfig::default(self.crate_name.take().unwrap());\n-\n-        // Generate a bunch of new items using the AllocFnFactory\n-        let mut f = AllocFnFactory {\n-            span,\n-            kind: AllocatorKind::Global,\n-            global: item.ident,\n-            core: Ident::with_empty_ctxt(sym::core),\n-            cx: ExtCtxt::new(self.sess, ecfg, self.resolver),\n-        };\n-\n-        // We will generate a new submodule. To `use` the static from that module, we need to get\n-        // the `super::...` path.\n-        let super_path = f.cx.path(f.span, vec![Ident::with_empty_ctxt(kw::Super), f.global]);\n-\n-        // Generate the items in the submodule\n-        let mut items = vec![\n-            // import `core` to use allocators\n-            f.cx.item_extern_crate(f.span, f.core),\n-            // `use` the `global_allocator` in `super`\n-            f.cx.item_use_simple(\n-                f.span,\n-                respan(f.span.shrink_to_lo(), VisibilityKind::Inherited),\n-                super_path,\n-            ),\n-        ];\n-\n-        // Add the allocator methods to the submodule\n-        items.extend(\n-            ALLOCATOR_METHODS\n-                .iter()\n-                .map(|method| f.allocator_fn(method)),\n-        );\n-\n-        // Generate the submodule itself\n-        let name = f.kind.fn_name(\"allocator_abi\");\n-        let allocator_abi = Ident::from_str(&name).gensym();\n-        let module = f.cx.item_mod(span, span, allocator_abi, Vec::new(), items);\n-        let module = f.cx.monotonic_expander().flat_map_item(module).pop().unwrap();\n-\n-        // Return the item and new submodule\n-        smallvec![item, module]\n-    }\n-\n-    // If we enter a submodule, take note.\n-    fn visit_mod(&mut self, m: &mut Mod) {\n-        debug!(\"enter submodule\");\n-        self.in_submod += 1;\n-        mut_visit::noop_visit_mod(m, self);\n-        self.in_submod -= 1;\n-        debug!(\"exit submodule\");\n-    }\n-\n-    // `visit_mac` is disabled by default. Enable it here.\n-    fn visit_mac(&mut self, mac: &mut Mac) {\n-        mut_visit::noop_visit_mac(mac, self)\n-    }\n-}\n-\n-struct AllocFnFactory<'a> {\n-    span: Span,\n-    kind: AllocatorKind,\n-    global: Ident,\n-    core: Ident,\n-    cx: ExtCtxt<'a>,\n-}\n-\n-impl AllocFnFactory<'_> {\n-    fn allocator_fn(&self, method: &AllocatorMethod) -> P<Item> {\n-        let mut abi_args = Vec::new();\n-        let mut i = 0;\n-        let ref mut mk = || {\n-            let name = Ident::from_str(&format!(\"arg{}\", i));\n-            i += 1;\n-            name\n-        };\n-        let args = method\n-            .inputs\n-            .iter()\n-            .map(|ty| self.arg_ty(ty, &mut abi_args, mk))\n-            .collect();\n-        let result = self.call_allocator(method.name, args);\n-        let (output_ty, output_expr) = self.ret_ty(&method.output, result);\n-        let kind = ItemKind::Fn(\n-            self.cx.fn_decl(abi_args, ast::FunctionRetTy::Ty(output_ty)),\n-            FnHeader {\n-                unsafety: Unsafety::Unsafe,\n-                ..FnHeader::default()\n-            },\n-            Generics::default(),\n-            self.cx.block_expr(output_expr),\n-        );\n-        self.cx.item(\n-            self.span,\n-            Ident::from_str(&self.kind.fn_name(method.name)),\n-            self.attrs(),\n-            kind,\n-        )\n-    }\n-\n-    fn call_allocator(&self, method: &str, mut args: Vec<P<Expr>>) -> P<Expr> {\n-        let method = self.cx.path(\n-            self.span,\n-            vec![\n-                self.core,\n-                Ident::from_str(\"alloc\"),\n-                Ident::from_str(\"GlobalAlloc\"),\n-                Ident::from_str(method),\n-            ],\n-        );\n-        let method = self.cx.expr_path(method);\n-        let allocator = self.cx.path_ident(self.span, self.global);\n-        let allocator = self.cx.expr_path(allocator);\n-        let allocator = self.cx.expr_addr_of(self.span, allocator);\n-        args.insert(0, allocator);\n-\n-        self.cx.expr_call(self.span, method, args)\n-    }\n-\n-    fn attrs(&self) -> Vec<Attribute> {\n-        let special = sym::rustc_std_internal_symbol;\n-        let special = self.cx.meta_word(self.span, special);\n-        vec![self.cx.attribute(self.span, special)]\n-    }\n-\n-    fn arg_ty(\n-        &self,\n-        ty: &AllocatorTy,\n-        args: &mut Vec<Arg>,\n-        ident: &mut dyn FnMut() -> Ident,\n-    ) -> P<Expr> {\n-        match *ty {\n-            AllocatorTy::Layout => {\n-                let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n-                let ty_usize = self.cx.ty_path(usize);\n-                let size = ident();\n-                let align = ident();\n-                args.push(self.cx.arg(self.span, size, ty_usize.clone()));\n-                args.push(self.cx.arg(self.span, align, ty_usize));\n-\n-                let layout_new = self.cx.path(\n-                    self.span,\n-                    vec![\n-                        self.core,\n-                        Ident::from_str(\"alloc\"),\n-                        Ident::from_str(\"Layout\"),\n-                        Ident::from_str(\"from_size_align_unchecked\"),\n-                    ],\n-                );\n-                let layout_new = self.cx.expr_path(layout_new);\n-                let size = self.cx.expr_ident(self.span, size);\n-                let align = self.cx.expr_ident(self.span, align);\n-                let layout = self.cx.expr_call(self.span, layout_new, vec![size, align]);\n-                layout\n-            }\n-\n-            AllocatorTy::Ptr => {\n-                let ident = ident();\n-                args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n-                let arg = self.cx.expr_ident(self.span, ident);\n-                self.cx.expr_cast(self.span, arg, self.ptr_u8())\n-            }\n-\n-            AllocatorTy::Usize => {\n-                let ident = ident();\n-                args.push(self.cx.arg(self.span, ident, self.usize()));\n-                self.cx.expr_ident(self.span, ident)\n-            }\n-\n-            AllocatorTy::ResultPtr | AllocatorTy::Unit => {\n-                panic!(\"can't convert AllocatorTy to an argument\")\n-            }\n-        }\n-    }\n-\n-    fn ret_ty(&self, ty: &AllocatorTy, expr: P<Expr>) -> (P<Ty>, P<Expr>) {\n-        match *ty {\n-            AllocatorTy::ResultPtr => {\n-                // We're creating:\n-                //\n-                //      #expr as *mut u8\n-\n-                let expr = self.cx.expr_cast(self.span, expr, self.ptr_u8());\n-                (self.ptr_u8(), expr)\n-            }\n-\n-            AllocatorTy::Unit => (self.cx.ty(self.span, TyKind::Tup(Vec::new())), expr),\n-\n-            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n-                panic!(\"can't convert `AllocatorTy` to an output\")\n-            }\n-        }\n-    }\n-\n-    fn usize(&self) -> P<Ty> {\n-        let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n-        self.cx.ty_path(usize)\n-    }\n-\n-    fn ptr_u8(&self) -> P<Ty> {\n-        let u8 = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::u8));\n-        let ty_u8 = self.cx.ty_path(u8);\n-        self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n-    }\n-}"}, {"sha": "8d380c47bc4a371360b12198f7901b82dd9cd860", "filename": "src/librustc_allocator/lib.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/890881f8f4c77e8670d4b32104c0325fcfefc90f/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890881f8f4c77e8670d4b32104c0325fcfefc90f/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=890881f8f4c77e8670d4b32104c0325fcfefc90f", "patch": "@@ -1,44 +0,0 @@\n-#![feature(nll)]\n-#![feature(rustc_private)]\n-\n-#![deny(rust_2018_idioms)]\n-#![deny(unused_lifetimes)]\n-\n-pub mod expand;\n-\n-pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n-    AllocatorMethod {\n-        name: \"alloc\",\n-        inputs: &[AllocatorTy::Layout],\n-        output: AllocatorTy::ResultPtr,\n-    },\n-    AllocatorMethod {\n-        name: \"dealloc\",\n-        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout],\n-        output: AllocatorTy::Unit,\n-    },\n-    AllocatorMethod {\n-        name: \"realloc\",\n-        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Usize],\n-        output: AllocatorTy::ResultPtr,\n-    },\n-    AllocatorMethod {\n-        name: \"alloc_zeroed\",\n-        inputs: &[AllocatorTy::Layout],\n-        output: AllocatorTy::ResultPtr,\n-    },\n-];\n-\n-pub struct AllocatorMethod {\n-    pub name: &'static str,\n-    pub inputs: &'static [AllocatorTy],\n-    pub output: AllocatorTy,\n-}\n-\n-pub enum AllocatorTy {\n-    Layout,\n-    Ptr,\n-    ResultPtr,\n-    Unit,\n-    Usize,\n-}"}, {"sha": "5d43bf6ae28bf662c208365f483ac7732bf4790d", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -2,9 +2,8 @@ use std::ffi::CString;\n \n use crate::attributes;\n use libc::c_uint;\n-use rustc::middle::allocator::AllocatorKind;\n use rustc::ty::TyCtxt;\n-use rustc_allocator::{ALLOCATOR_METHODS, AllocatorTy};\n+use syntax::ext::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n \n use crate::ModuleLlvm;\n use crate::llvm::{self, False, True};"}, {"sha": "8dd241bd81a0a1490cb0da0b6af4e42d8225c8e5", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -32,7 +32,6 @@ extern crate flate2;\n #[macro_use] extern crate bitflags;\n extern crate libc;\n #[macro_use] extern crate rustc;\n-extern crate rustc_allocator;\n extern crate rustc_target;\n #[macro_use] extern crate rustc_data_structures;\n extern crate rustc_incremental;\n@@ -52,13 +51,13 @@ use rustc_codegen_ssa::back::lto::{SerializedModule, LtoModuleCodegen, ThinModul\n use rustc_codegen_ssa::CompiledModule;\n use errors::{FatalError, Handler};\n use rustc::dep_graph::WorkProduct;\n+use syntax::ext::allocator::AllocatorKind;\n use syntax_pos::symbol::InternedString;\n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::{mpsc, Arc};\n \n use rustc::dep_graph::DepGraph;\n-use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc::session::Session;\n use rustc::session::config::{OutputFilenames, OutputType, PrintRequest, OptLevel};"}, {"sha": "89a6ec27fe595b65c14a1ceb1d53c79d8f60322b", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -24,7 +24,6 @@ rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc = { path = \"../librustc\" }\n-rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_data_structures = { path = \"../librustc_data_structures\"}"}, {"sha": "2d9220f897cff63f43c9c42dfdd0f9a466ee8b5f", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1,3 +1,4 @@\n+use std::collections::hash_map::Entry::*;\n use std::sync::Arc;\n \n use rustc::ty::Instance;\n@@ -12,9 +13,8 @@ use rustc::ty::{TyCtxt, SymbolName};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::SubstsRef;\n use rustc::util::nodemap::{FxHashMap, DefIdMap};\n-use rustc_allocator::ALLOCATOR_METHODS;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use std::collections::hash_map::Entry::*;\n+use syntax::ext::allocator::ALLOCATOR_METHODS;\n \n pub type ExportedSymbols = FxHashMap<\n     CrateNum,"}, {"sha": "9fbb44dcc9959dfc627f5b441c744d5e9b7c526f", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -3,12 +3,12 @@ use rustc::ty::Ty;\n \n use super::write::WriteBackendMethods;\n use super::CodegenObject;\n-use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::session::{Session, config};\n use rustc::ty::TyCtxt;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use std::sync::Arc;\n+use syntax::ext::allocator::AllocatorKind;\n use syntax_pos::symbol::InternedString;\n \n pub trait BackendTypes {"}, {"sha": "e8c9828a202efdc4e0ca0a96427cb0010a3bd995", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -16,7 +16,6 @@ log = \"0.4\"\n env_logger = { version = \"0.5\", default-features = false }\n rayon = { version = \"0.2.0\", package = \"rustc-rayon\" }\n rustc = { path = \"../librustc\" }\n-rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_ast_borrowck = { path = \"../librustc_ast_borrowck\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n@@ -37,5 +36,4 @@ rustc_interface = { path = \"../librustc_interface\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n-syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "4937801d311ff82eb72ba5eb87f24be15551e5c7", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -18,7 +18,6 @@ syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc = { path = \"../librustc\" }\n-rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_ast_borrowck = { path = \"../librustc_ast_borrowck\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_traits = { path = \"../librustc_traits\" }"}, {"sha": "1cc7cfda0120af5a1d90d8a5aa257afd40f04671", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -469,7 +469,7 @@ fn configure_and_expand_inner<'a>(\n         util::ReplaceBodyWithLoop::new(sess).visit_crate(&mut krate);\n     }\n \n-    let (has_proc_macro_decls, has_global_allocator) = time(sess, \"AST validation\", || {\n+    let has_proc_macro_decls = time(sess, \"AST validation\", || {\n         ast_validation::check_crate(sess, &krate)\n     });\n \n@@ -495,19 +495,6 @@ fn configure_and_expand_inner<'a>(\n         });\n     }\n \n-    if has_global_allocator {\n-        // Expand global allocators, which are treated as an in-tree proc macro\n-        time(sess, \"creating allocators\", || {\n-            allocator::expand::modify(\n-                &sess.parse_sess,\n-                &mut resolver,\n-                &mut krate,\n-                crate_name.to_string(),\n-                sess.diagnostic(),\n-            )\n-        });\n-    }\n-\n     // Done with macro expansion!\n \n     if sess.opts.debugging_opts.input_stats {"}, {"sha": "b63d14ca949ee6b7b8189e5d71c068f0d75e480d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -36,10 +36,10 @@ use syntax::tokenstream::{TokenTree, TokenStream};\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::ast::Expr;\n-use syntax::attr::{self, HasAttrs};\n+use syntax::attr::{self, HasAttrs, AttributeTemplate};\n use syntax::source_map::Spanned;\n use syntax::edition::Edition;\n-use syntax::feature_gate::{AttributeGate, AttributeTemplate, AttributeType};\n+use syntax::feature_gate::{AttributeGate, AttributeType};\n use syntax::feature_gate::{Stability, deprecated_attributes};\n use syntax_pos::{BytePos, Span, SyntaxContext};\n use syntax::symbol::{Symbol, kw, sym};"}, {"sha": "3404ec5e173bdfd93aed4325d61c8da79d86c8d9", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -8,7 +8,6 @@ use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n-use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::DepKind;\n use rustc::mir::interpret::AllocDecodingState;\n use rustc::session::{Session, CrateDisambiguator};\n@@ -26,9 +25,9 @@ use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n+use syntax::ext::allocator::{global_allocator_spans, AllocatorKind};\n use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::symbol::{Symbol, sym};\n-use syntax::visit;\n use syntax::{span_err, span_fatal};\n use syntax_pos::{Span, DUMMY_SP};\n use log::{debug, info, log_enabled};\n@@ -888,7 +887,14 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n-        let has_global_allocator = has_global_allocator(krate);\n+        let has_global_allocator = match &*global_allocator_spans(krate) {\n+            [span1, span2, ..] => {\n+                self.sess.struct_span_err(*span2, \"cannot define multiple global allocators\")\n+                         .span_note(*span1, \"the previous global allocator is defined here\").emit();\n+                true\n+            }\n+            spans => !spans.is_empty()\n+        };\n         self.sess.has_global_allocator.set(has_global_allocator);\n \n         // Check to see if we actually need an allocator. This desire comes\n@@ -975,25 +981,8 @@ impl<'a> CrateLoader<'a> {\n                            that implements the GlobalAlloc trait.\");\n         }\n         self.sess.allocator_kind.set(Some(AllocatorKind::DefaultLib));\n-\n-        fn has_global_allocator(krate: &ast::Crate) -> bool {\n-            struct Finder(bool);\n-            let mut f = Finder(false);\n-            visit::walk_crate(&mut f, krate);\n-            return f.0;\n-\n-            impl<'ast> visit::Visitor<'ast> for Finder {\n-                fn visit_item(&mut self, i: &'ast ast::Item) {\n-                    if attr::contains_name(&i.attrs, sym::global_allocator) {\n-                        self.0 = true;\n-                    }\n-                    visit::walk_item(self, i)\n-                }\n-            }\n-        }\n     }\n \n-\n     fn inject_dependency_if(&self,\n                             krate: CrateNum,\n                             what: &str,"}, {"sha": "8db3ec491df8331d0e3ab58ce7c8b2291cf5f284", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1,16 +1,17 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(box_patterns)]\n+#![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n #![feature(in_band_lifetimes)]\n #![feature(libc)]\n #![feature(nll)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(crate_visibility_modifier)]\n-#![feature(specialization)]\n #![feature(rustc_private)]\n+#![feature(slice_patterns)]\n+#![feature(specialization)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "195a652b0a2e674759f977b83afdcae4bfe7cf2c", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -127,7 +127,7 @@ impl<'tcx> MirSource<'tcx> {\n /// Generates a default name for the pass based on the name of the\n /// type `T`.\n pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n-    let name = unsafe { ::std::intrinsics::type_name::<T>() };\n+    let name = ::std::any::type_name::<T>();\n     if let Some(tail) = name.rfind(\":\") {\n         Cow::from(&name[tail+1..])\n     } else {"}, {"sha": "b550029d9786d33bdc962ac0e3f718825d2525df", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -51,7 +51,6 @@ impl OuterImplTrait {\n struct AstValidator<'a> {\n     session: &'a Session,\n     has_proc_macro_decls: bool,\n-    has_global_allocator: bool,\n \n     /// Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n     /// Nested `impl Trait` _is_ allowed in associated type position,\n@@ -539,10 +538,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if attr::contains_name(&item.attrs, sym::global_allocator) {\n-            self.has_global_allocator = true;\n-        }\n-\n         match item.node {\n             ItemKind::Impl(unsafety, polarity, _, _, Some(..), ref ty, ref impl_items) => {\n                 self.invalid_visibility(&item.vis, None);\n@@ -848,11 +843,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n }\n \n-pub fn check_crate(session: &Session, krate: &Crate) -> (bool, bool) {\n+pub fn check_crate(session: &Session, krate: &Crate) -> bool {\n     let mut validator = AstValidator {\n         session,\n         has_proc_macro_decls: false,\n-        has_global_allocator: false,\n         outer_impl_trait: None,\n         is_impl_trait_banned: false,\n         is_assoc_ty_bound_banned: false,\n@@ -861,5 +855,5 @@ pub fn check_crate(session: &Session, krate: &Crate) -> (bool, bool) {\n     };\n     visit::walk_crate(&mut validator, krate);\n \n-    (validator.has_proc_macro_decls, validator.has_global_allocator)\n+    validator.has_proc_macro_decls\n }"}, {"sha": "4d8f564123634e7c3bc190589a4078b2109f3e3a", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -71,7 +71,7 @@ pub fn intrisic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n         \"saturating_add\" | \"saturating_sub\" |\n         \"rotate_left\" | \"rotate_right\" |\n         \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" | \"bitreverse\" |\n-        \"minnumf32\" | \"minnumf64\" | \"maxnumf32\" | \"maxnumf64\"\n+        \"minnumf32\" | \"minnumf64\" | \"maxnumf32\" | \"maxnumf64\" | \"type_name\"\n         => hir::Unsafety::Normal,\n         _ => hir::Unsafety::Unsafe,\n     }"}, {"sha": "d48ba74f9f23f5f04639c237701b2bf8bae2715c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -10,7 +10,6 @@ use rustc::hir::{self, ExprKind, Node, QPath};\n use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::hir::map as hir_map;\n-use rustc::hir::print;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::traits::Obligation;\n use rustc::ty::{self, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n@@ -78,6 +77,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         }\n \n+        let print_disambiguation_help = |\n+            err: &mut DiagnosticBuilder<'_>,\n+            trait_name: String,\n+        | {\n+            err.help(&format!(\n+                \"to disambiguate the method call, write `{}::{}({}{})` instead\",\n+                trait_name,\n+                item_name,\n+                if rcvr_ty.is_region_ptr() && args.is_some() {\n+                    if rcvr_ty.is_mutable_pointer() {\n+                        \"&mut \"\n+                    } else {\n+                        \"&\"\n+                    }\n+                } else {\n+                    \"\"\n+                },\n+                args.map(|arg| arg\n+                    .iter()\n+                    .map(|arg| self.tcx.sess.source_map().span_to_snippet(arg.span)\n+                        .unwrap_or_else(|_| \"...\".to_owned()))\n+                    .collect::<Vec<_>>()\n+                    .join(\", \")\n+                ).unwrap_or_else(|| \"...\".to_owned())\n+            ));\n+        };\n+\n         let report_candidates = |\n             span: Span,\n             err: &mut DiagnosticBuilder<'_>,\n@@ -139,6 +165,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         } else {\n                             err.note(&note_str);\n                         }\n+                        if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n+                            print_disambiguation_help(err, self.tcx.def_path_str(trait_ref.def_id));\n+                        }\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n                         let item = match self.associated_item(\n@@ -163,24 +192,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                        \"the candidate is defined in the trait `{}`\",\n                                        self.tcx.def_path_str(trait_did));\n                         }\n-                        err.help(&format!(\"to disambiguate the method call, write `{}::{}({}{})` \\\n-                                          instead\",\n-                                          self.tcx.def_path_str(trait_did),\n-                                          item_name,\n-                                          if rcvr_ty.is_region_ptr() && args.is_some() {\n-                                              if rcvr_ty.is_mutable_pointer() {\n-                                                  \"&mut \"\n-                                              } else {\n-                                                  \"&\"\n-                                              }\n-                                          } else {\n-                                              \"\"\n-                                          },\n-                                          args.map(|arg| arg.iter()\n-                                              .map(|arg| print::to_string(print::NO_ANN,\n-                                                                          |s| s.print_expr(arg)))\n-                                              .collect::<Vec<_>>()\n-                                              .join(\", \")).unwrap_or_else(|| \"...\".to_owned())));\n+                        print_disambiguation_help(err, self.tcx.def_path_str(trait_did));\n                     }\n                 }\n             }"}, {"sha": "a5f7b4898ae0e854a98f0e57644fa3ea0a804edb", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -4,8 +4,8 @@\n Core encoding and decoding interfaces.\n */\n \n+use std::any;\n use std::borrow::Cow;\n-use std::intrinsics;\n use std::marker::PhantomData;\n use std::path;\n use std::rc::Rc;\n@@ -849,9 +849,9 @@ pub trait SpecializationError {\n impl<E> SpecializationError for E {\n     default fn not_found<S, T: ?Sized>(trait_name: &'static str, method_name: &'static str) -> E {\n         panic!(\"missing specialization: `<{} as {}<{}>>::{}` not overridden\",\n-               unsafe { intrinsics::type_name::<S>() },\n+               any::type_name::<S>(),\n                trait_name,\n-               unsafe { intrinsics::type_name::<T>() },\n+               any::type_name::<T>(),\n                method_name);\n     }\n }"}, {"sha": "f649170c40372d12bb48817a41ba308ace79e6e2", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -256,7 +256,6 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(euclidean_division)]\n     /// let a: f32 = 7.0;\n     /// let b = 4.0;\n     /// assert_eq!(a.div_euclid(b), 1.0); // 7.0 > 4.0 * 1.0\n@@ -265,7 +264,7 @@ impl f32 {\n     /// assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+    #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n     pub fn div_euclid(self, rhs: f32) -> f32 {\n         let q = (self / rhs).trunc();\n         if self % rhs < 0.0 {\n@@ -288,7 +287,6 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(euclidean_division)]\n     /// let a: f32 = 7.0;\n     /// let b = 4.0;\n     /// assert_eq!(a.rem_euclid(b), 3.0);\n@@ -299,7 +297,7 @@ impl f32 {\n     /// assert!((-std::f32::EPSILON).rem_euclid(3.0) != 0.0);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+    #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n     pub fn rem_euclid(self, rhs: f32) -> f32 {\n         let r = self % rhs;\n         if r < 0.0 {"}, {"sha": "f61630997dcdb42003790d0acaf9092f346e8d32", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -232,7 +232,6 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(euclidean_division)]\n     /// let a: f64 = 7.0;\n     /// let b = 4.0;\n     /// assert_eq!(a.div_euclid(b), 1.0); // 7.0 > 4.0 * 1.0\n@@ -241,7 +240,7 @@ impl f64 {\n     /// assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+    #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n     pub fn div_euclid(self, rhs: f64) -> f64 {\n         let q = (self / rhs).trunc();\n         if self % rhs < 0.0 {\n@@ -264,7 +263,6 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(euclidean_division)]\n     /// let a: f64 = 7.0;\n     /// let b = 4.0;\n     /// assert_eq!(a.rem_euclid(b), 3.0);\n@@ -275,7 +273,7 @@ impl f64 {\n     /// assert!((-std::f64::EPSILON).rem_euclid(3.0) != 0.0);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+    #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n     pub fn rem_euclid(self, rhs: f64) -> f64 {\n         let r = self % rhs;\n         if r < 0.0 {"}, {"sha": "0761c50f4b22953624566ecb1ebe852b3c07a8d6", "filename": "src/libstd/os/raw/mod.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw%2Fmod.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -8,7 +8,8 @@\n \n #![stable(feature = \"raw_os\", since = \"1.1.0\")]\n \n-#[doc(include = \"os/raw/char.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/char.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"char.md\"))]\n #[cfg(any(all(target_os = \"linux\", any(target_arch = \"aarch64\",\n                                        target_arch = \"arm\",\n                                        target_arch = \"hexagon\",\n@@ -32,7 +33,8 @@\n                                          target_arch = \"powerpc\")),\n           all(target_os = \"fuchsia\", target_arch = \"aarch64\")))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n-#[doc(include = \"os/raw/char.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/char.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"char.md\"))]\n #[cfg(not(any(all(target_os = \"linux\", any(target_arch = \"aarch64\",\n                                            target_arch = \"arm\",\n                                            target_arch = \"hexagon\",\n@@ -56,37 +58,51 @@\n                                              target_arch = \"powerpc\")),\n               all(target_os = \"fuchsia\", target_arch = \"aarch64\"))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n-#[doc(include = \"os/raw/schar.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/schar.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"schar.md\"))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_schar = i8;\n-#[doc(include = \"os/raw/uchar.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/uchar.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"uchar.md\"))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uchar = u8;\n-#[doc(include = \"os/raw/short.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/short.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"short.md\"))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_short = i16;\n-#[doc(include = \"os/raw/ushort.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/ushort.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"ushort.md\"))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ushort = u16;\n-#[doc(include = \"os/raw/int.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/int.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"int.md\"))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_int = i32;\n-#[doc(include = \"os/raw/uint.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/uint.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"uint.md\"))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uint = u32;\n-#[doc(include = \"os/raw/long.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/long.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"long.md\"))]\n #[cfg(any(target_pointer_width = \"32\", windows))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_long = i32;\n-#[doc(include = \"os/raw/ulong.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/ulong.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"ulong.md\"))]\n #[cfg(any(target_pointer_width = \"32\", windows))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ulong = u32;\n-#[doc(include = \"os/raw/long.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/long.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"long.md\"))]\n #[cfg(all(target_pointer_width = \"64\", not(windows)))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_long = i64;\n-#[doc(include = \"os/raw/ulong.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/ulong.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"ulong.md\"))]\n #[cfg(all(target_pointer_width = \"64\", not(windows)))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ulong = u64;\n-#[doc(include = \"os/raw/longlong.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/longlong.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"longlong.md\"))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_longlong = i64;\n-#[doc(include = \"os/raw/ulonglong.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/ulonglong.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"ulonglong.md\"))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_ulonglong = u64;\n-#[doc(include = \"os/raw/float.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/float.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"float.md\"))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_float = f32;\n-#[doc(include = \"os/raw/double.md\")]\n+#[cfg_attr(bootstrap, doc(include = \"os/raw/double.md\"))]\n+#[cfg_attr(not(bootstrap), doc(include = \"double.md\"))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_double = f64;\n \n #[stable(feature = \"raw_os\", since = \"1.1.0\")]"}, {"sha": "d9a3da66a67868096011e29eac00e9328109c2f0", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -362,8 +362,13 @@ mod prim_unit { }\n ///\n /// *[See also the `std::ptr` module](ptr/index.html).*\n ///\n-/// Working with raw pointers in Rust is uncommon,\n-/// typically limited to a few patterns.\n+/// Working with raw pointers in Rust is uncommon, typically limited to a few patterns.\n+/// Raw pointers can be unaligned or [`null`]. However, when a raw pointer is\n+/// dereferenced (using the `*` operator), it must be non-null and aligned.\n+///\n+/// Storing through a raw pointer using `*ptr = data` calls `drop` on the old value, so\n+/// [`write`] must be used if the type has drop glue and memory is not already\n+/// initialized - otherwise `drop` would be called on the uninitialized memory.\n ///\n /// Use the [`null`] and [`null_mut`] functions to create null pointers, and the\n /// [`is_null`] method of the `*const T` and `*mut T` types to check for null.\n@@ -442,6 +447,7 @@ mod prim_unit { }\n /// [`offset`]: ../std/primitive.pointer.html#method.offset\n /// [`into_raw`]: ../std/boxed/struct.Box.html#method.into_raw\n /// [`drop`]: ../std/mem/fn.drop.html\n+/// [`write`]: ../std/ptr/fn.write.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_pointer { }\n \n@@ -891,9 +897,13 @@ mod prim_usize { }\n /// A reference represents a borrow of some owned value. You can get one by using the `&` or `&mut`\n /// operators on a value, or by using a `ref` or `ref mut` pattern.\n ///\n-/// For those familiar with pointers, a reference is just a pointer that is assumed to not be null.\n-/// In fact, `Option<&T>` has the same memory representation as a nullable pointer, and can be\n-/// passed across FFI boundaries as such.\n+/// For those familiar with pointers, a reference is just a pointer that is assumed to be\n+/// aligned, not null, and pointing to memory containing a valid value of `T` - for example,\n+/// `&bool` can only point to an allocation containing the integer values `1` (`true`) or `0`\n+/// (`false`), but creating a `&bool` that points to an allocation containing\n+/// the value `3` causes undefined behaviour.\n+/// In fact, `Option<&T>` has the same memory representation as a\n+/// nullable but aligned pointer, and can be passed across FFI boundaries as such.\n ///\n /// In most cases, references can be used much like the original value. Field access, method\n /// calling, and indexing work the same (save for mutability rules, of course). In addition, the\n@@ -1036,6 +1046,11 @@ mod prim_ref { }\n /// [`FnMut`]: ops/trait.FnMut.html\n /// [`FnOnce`]: ops/trait.FnOnce.html\n ///\n+/// Function pointers are pointers that point to *code*, not data. They can be called\n+/// just like functions. Like references, function pointers are, among other things, assumed to\n+/// not be null, so if you want to pass a function pointer over FFI and be able to accommodate null\n+/// pointers, make your type `Option<fn()>` with your required signature.\n+///\n /// Plain function pointers are obtained by casting either plain functions, or closures that don't\n /// capture an environment:\n ///\n@@ -1091,10 +1106,6 @@ mod prim_ref { }\n ///\n /// These markers can be combined, so `unsafe extern \"stdcall\" fn()` is a valid type.\n ///\n-/// Like references in rust, function pointers are assumed to not be null, so if you want to pass a\n-/// function pointer over FFI and be able to accommodate null pointers, make your type\n-/// `Option<fn()>` with your required signature.\n-///\n /// Function pointers implement the following traits:\n ///\n /// * [`Clone`]"}, {"sha": "aeff57716e86b26769b37e22162964df8c861ab8", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -36,7 +36,7 @@ impl WaitTimeoutResult {\n     /// let pair2 = pair.clone();\n     ///\n     /// thread::spawn(move|| {\n-    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let (lock, cvar) = &*pair2;\n     ///\n     ///     // Let's wait 20 milliseconds before notifying the condvar.\n     ///     thread::sleep(Duration::from_millis(20));\n@@ -48,7 +48,7 @@ impl WaitTimeoutResult {\n     /// });\n     ///\n     /// // Wait for the thread to start up.\n-    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let (lock, cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n     /// loop {\n     ///     // Let's put a timeout on the condvar's wait.\n@@ -94,15 +94,15 @@ impl WaitTimeoutResult {\n ///\n /// // Inside of our lock, spawn a new thread, and then wait for it to start.\n /// thread::spawn(move|| {\n-///     let &(ref lock, ref cvar) = &*pair2;\n+///     let (lock, cvar) = &*pair2;\n ///     let mut started = lock.lock().unwrap();\n ///     *started = true;\n ///     // We notify the condvar that the value has changed.\n ///     cvar.notify_one();\n /// });\n ///\n /// // Wait for the thread to start up.\n-/// let &(ref lock, ref cvar) = &*pair;\n+/// let (lock, cvar) = &*pair;\n /// let mut started = lock.lock().unwrap();\n /// while !*started {\n ///     started = cvar.wait(started).unwrap();\n@@ -180,15 +180,15 @@ impl Condvar {\n     /// let pair2 = pair.clone();\n     ///\n     /// thread::spawn(move|| {\n-    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let (lock, cvar) = &*pair2;\n     ///     let mut started = lock.lock().unwrap();\n     ///     *started = true;\n     ///     // We notify the condvar that the value has changed.\n     ///     cvar.notify_one();\n     /// });\n     ///\n     /// // Wait for the thread to start up.\n-    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let (lock, cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n     /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// while !*started {\n@@ -245,15 +245,15 @@ impl Condvar {\n     /// let pair2 = pair.clone();\n     ///\n     /// thread::spawn(move|| {\n-    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let (lock, cvar) = &*pair2;\n     ///     let mut started = lock.lock().unwrap();\n     ///     *started = true;\n     ///     // We notify the condvar that the value has changed.\n     ///     cvar.notify_one();\n     /// });\n     ///\n     /// // Wait for the thread to start up.\n-    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let (lock, cvar) = &*pair;\n     /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// let _guard = cvar.wait_until(lock.lock().unwrap(), |started| { *started }).unwrap();\n     /// ```\n@@ -301,15 +301,15 @@ impl Condvar {\n     /// let pair2 = pair.clone();\n     ///\n     /// thread::spawn(move|| {\n-    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let (lock, cvar) = &*pair2;\n     ///     let mut started = lock.lock().unwrap();\n     ///     *started = true;\n     ///     // We notify the condvar that the value has changed.\n     ///     cvar.notify_one();\n     /// });\n     ///\n     /// // Wait for the thread to start up.\n-    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let (lock, cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n     /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// loop {\n@@ -374,15 +374,15 @@ impl Condvar {\n     /// let pair2 = pair.clone();\n     ///\n     /// thread::spawn(move|| {\n-    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let (lock, cvar) = &*pair2;\n     ///     let mut started = lock.lock().unwrap();\n     ///     *started = true;\n     ///     // We notify the condvar that the value has changed.\n     ///     cvar.notify_one();\n     /// });\n     ///\n     /// // wait for the thread to start up\n-    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let (lock, cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n     /// // as long as the value inside the `Mutex<bool>` is `false`, we wait\n     /// loop {\n@@ -449,15 +449,15 @@ impl Condvar {\n     /// let pair2 = pair.clone();\n     ///\n     /// thread::spawn(move|| {\n-    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let (lock, cvar) = &*pair2;\n     ///     let mut started = lock.lock().unwrap();\n     ///     *started = true;\n     ///     // We notify the condvar that the value has changed.\n     ///     cvar.notify_one();\n     /// });\n     ///\n     /// // wait for the thread to start up\n-    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let (lock, cvar) = &*pair;\n     /// let result = cvar.wait_timeout_until(\n     ///     lock.lock().unwrap(),\n     ///     Duration::from_millis(100),\n@@ -508,15 +508,15 @@ impl Condvar {\n     /// let pair2 = pair.clone();\n     ///\n     /// thread::spawn(move|| {\n-    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let (lock, cvar) = &*pair2;\n     ///     let mut started = lock.lock().unwrap();\n     ///     *started = true;\n     ///     // We notify the condvar that the value has changed.\n     ///     cvar.notify_one();\n     /// });\n     ///\n     /// // Wait for the thread to start up.\n-    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let (lock, cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n     /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// while !*started {\n@@ -548,15 +548,15 @@ impl Condvar {\n     /// let pair2 = pair.clone();\n     ///\n     /// thread::spawn(move|| {\n-    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let (lock, cvar) = &*pair2;\n     ///     let mut started = lock.lock().unwrap();\n     ///     *started = true;\n     ///     // We notify the condvar that the value has changed.\n     ///     cvar.notify_all();\n     /// });\n     ///\n     /// // Wait for the thread to start up.\n-    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let (lock, cvar) = &*pair;\n     /// let mut started = lock.lock().unwrap();\n     /// // As long as the value inside the `Mutex<bool>` is `false`, we wait.\n     /// while !*started {"}, {"sha": "dbf31ad0148325a1e3eda47eea8cfb9d1bd2de33", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1,6 +1,9 @@\n //! Parsing and validation of builtin attributes\n \n use crate::ast::{self, Attribute, MetaItem, NestedMetaItem};\n+use crate::early_buffered_lints::BufferedEarlyLintId;\n+use crate::ext::base::ExtCtxt;\n+use crate::ext::build::AstBuilder;\n use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n \n@@ -19,6 +22,27 @@ enum AttrError {\n     UnsupportedLiteral(&'static str, /* is_bytestr */ bool),\n }\n \n+/// A template that the attribute input must match.\n+/// Only top-level shape (`#[attr]` vs `#[attr(...)]` vs `#[attr = ...]`) is considered now.\n+#[derive(Clone, Copy)]\n+pub struct AttributeTemplate {\n+    crate word: bool,\n+    crate list: Option<&'static str>,\n+    crate name_value_str: Option<&'static str>,\n+}\n+\n+impl AttributeTemplate {\n+    /// Checks that the given meta-item is compatible with this template.\n+    fn compatible(&self, meta_item_kind: &ast::MetaItemKind) -> bool {\n+        match meta_item_kind {\n+            ast::MetaItemKind::Word => self.word,\n+            ast::MetaItemKind::List(..) => self.list.is_some(),\n+            ast::MetaItemKind::NameValue(lit) if lit.node.is_str() => self.name_value_str.is_some(),\n+            ast::MetaItemKind::NameValue(..) => false,\n+        }\n+    }\n+}\n+\n fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n     let diag = &sess.span_diagnostic;\n     match error {\n@@ -901,3 +925,76 @@ pub fn find_transparency(\n     let fallback = if is_legacy { Transparency::SemiTransparent } else { Transparency::Opaque };\n     (transparency.map_or(fallback, |t| t.0), error)\n }\n+\n+pub fn check_builtin_macro_attribute(ecx: &ExtCtxt<'_>, meta_item: &MetaItem, name: Symbol) {\n+    // All the built-in macro attributes are \"words\" at the moment.\n+    let template = AttributeTemplate { word: true, list: None, name_value_str: None };\n+    let attr = ecx.attribute(meta_item.span, meta_item.clone());\n+    check_builtin_attribute(ecx.parse_sess, &attr, name, template);\n+}\n+\n+crate fn check_builtin_attribute(\n+    sess: &ParseSess, attr: &ast::Attribute, name: Symbol, template: AttributeTemplate\n+) {\n+    // Some special attributes like `cfg` must be checked\n+    // before the generic check, so we skip them here.\n+    let should_skip = |name| name == sym::cfg;\n+    // Some of previously accepted forms were used in practice,\n+    // report them as warnings for now.\n+    let should_warn = |name| name == sym::doc || name == sym::ignore ||\n+                             name == sym::inline || name == sym::link ||\n+                             name == sym::test || name == sym::bench;\n+\n+    match attr.parse_meta(sess) {\n+        Ok(meta) => if !should_skip(name) && !template.compatible(&meta.node) {\n+            let error_msg = format!(\"malformed `{}` attribute input\", name);\n+            let mut msg = \"attribute must be of the form \".to_owned();\n+            let mut suggestions = vec![];\n+            let mut first = true;\n+            if template.word {\n+                first = false;\n+                let code = format!(\"#[{}]\", name);\n+                msg.push_str(&format!(\"`{}`\", &code));\n+                suggestions.push(code);\n+            }\n+            if let Some(descr) = template.list {\n+                if !first {\n+                    msg.push_str(\" or \");\n+                }\n+                first = false;\n+                let code = format!(\"#[{}({})]\", name, descr);\n+                msg.push_str(&format!(\"`{}`\", &code));\n+                suggestions.push(code);\n+            }\n+            if let Some(descr) = template.name_value_str {\n+                if !first {\n+                    msg.push_str(\" or \");\n+                }\n+                let code = format!(\"#[{} = \\\"{}\\\"]\", name, descr);\n+                msg.push_str(&format!(\"`{}`\", &code));\n+                suggestions.push(code);\n+            }\n+            if should_warn(name) {\n+                sess.buffer_lint(\n+                    BufferedEarlyLintId::IllFormedAttributeInput,\n+                    meta.span,\n+                    ast::CRATE_NODE_ID,\n+                    &msg,\n+                );\n+            } else {\n+                sess.span_diagnostic.struct_span_err(meta.span, &error_msg)\n+                    .span_suggestions(\n+                        meta.span,\n+                        if suggestions.len() == 1 {\n+                            \"must be of the form\"\n+                        } else {\n+                            \"the following are the possible correct uses\"\n+                        },\n+                        suggestions.into_iter(),\n+                        Applicability::HasPlaceholders,\n+                    ).emit();\n+            }\n+        }\n+        Err(mut err) => err.emit(),\n+    }\n+}"}, {"sha": "99aeb5414c5d8d5b62057d8c6ae2499ce906146a", "filename": "src/libsyntax/ext/allocator.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Fext%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Fext%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fallocator.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,75 @@\n+use crate::{ast, attr, visit};\n+use crate::symbol::{sym, Symbol};\n+use syntax_pos::Span;\n+\n+#[derive(Clone, Copy)]\n+pub enum AllocatorKind {\n+    Global,\n+    DefaultLib,\n+    DefaultExe,\n+}\n+\n+impl AllocatorKind {\n+    pub fn fn_name(&self, base: &str) -> String {\n+        match *self {\n+            AllocatorKind::Global => format!(\"__rg_{}\", base),\n+            AllocatorKind::DefaultLib => format!(\"__rdl_{}\", base),\n+            AllocatorKind::DefaultExe => format!(\"__rde_{}\", base),\n+        }\n+    }\n+}\n+\n+pub enum AllocatorTy {\n+    Layout,\n+    Ptr,\n+    ResultPtr,\n+    Unit,\n+    Usize,\n+}\n+\n+pub struct AllocatorMethod {\n+    pub name: &'static str,\n+    pub inputs: &'static [AllocatorTy],\n+    pub output: AllocatorTy,\n+}\n+\n+pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n+    AllocatorMethod {\n+        name: \"alloc\",\n+        inputs: &[AllocatorTy::Layout],\n+        output: AllocatorTy::ResultPtr,\n+    },\n+    AllocatorMethod {\n+        name: \"dealloc\",\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout],\n+        output: AllocatorTy::Unit,\n+    },\n+    AllocatorMethod {\n+        name: \"realloc\",\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Usize],\n+        output: AllocatorTy::ResultPtr,\n+    },\n+    AllocatorMethod {\n+        name: \"alloc_zeroed\",\n+        inputs: &[AllocatorTy::Layout],\n+        output: AllocatorTy::ResultPtr,\n+    },\n+];\n+\n+pub fn global_allocator_spans(krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder { name: Symbol, spans: Vec<Span> }\n+    impl<'ast> visit::Visitor<'ast> for Finder {\n+        fn visit_item(&mut self, item: &'ast ast::Item) {\n+            if item.ident.name == self.name &&\n+               attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol) {\n+                self.spans.push(item.span);\n+            }\n+            visit::walk_item(self, item)\n+        }\n+    }\n+\n+    let name = Symbol::intern(&AllocatorKind::Global.fn_name(\"alloc\"));\n+    let mut f = Finder { name, spans: Vec::new() };\n+    visit::walk_crate(&mut f, krate);\n+    f.spans\n+}"}, {"sha": "11b7a984aaa001493ed1498a103bb404db49cfb8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1,6 +1,6 @@\n use crate::ast::{self, Attribute, Name, PatKind};\n use crate::attr::{HasAttrs, Stability, Deprecation};\n-use crate::source_map::{SourceMap, Spanned, respan};\n+use crate::source_map::{SourceMap, Spanned, FileName, respan};\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, Transparency};\n@@ -889,6 +889,31 @@ impl<'a> ExtCtxt<'a> {\n     pub fn check_unused_macros(&self) {\n         self.resolver.check_unused_macros();\n     }\n+\n+    /// Resolve a path mentioned inside Rust code.\n+    ///\n+    /// This unifies the logic used for resolving `include_X!`, and `#[doc(include)]` file paths.\n+    ///\n+    /// Returns an absolute path to the file that `path` refers to.\n+    pub fn resolve_path(&self, path: impl Into<PathBuf>, span: Span) -> PathBuf {\n+        let path = path.into();\n+\n+        // Relative paths are resolved relative to the file in which they are found\n+        // after macro expansion (that is, they are unhygienic).\n+        if !path.is_absolute() {\n+            let callsite = span.source_callsite();\n+            let mut result = match self.source_map().span_to_unmapped_path(callsite) {\n+                FileName::Real(path) => path,\n+                FileName::DocTest(path, _) => path,\n+                other => panic!(\"cannot resolve relative path in non-file source `{}`\", other),\n+            };\n+            result.pop();\n+            result.push(path);\n+            result\n+        } else {\n+            path\n+        }\n+    }\n }\n \n /// Extracts a string literal from the macro expanded version of `expr`,"}, {"sha": "640daaccc3a2c8b911c0534cb5b53e07871bd682", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1253,7 +1253,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                         return noop_visit_attribute(at, self);\n                     }\n \n-                    let filename = self.cx.root_path.join(file.to_string());\n+                    let filename = self.cx.resolve_path(&*file.as_str(), it.span());\n                     match fs::read_to_string(&filename) {\n                         Ok(src) => {\n                             let src_interned = Symbol::intern(&src);\n@@ -1302,10 +1302,6 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                                 );\n                                 err.span_label(lit.span, \"couldn't read file\");\n \n-                                if e.kind() == ErrorKind::NotFound {\n-                                    err.help(\"external doc paths are relative to the crate root\");\n-                                }\n-\n                                 err.emit();\n                             }\n                         }"}, {"sha": "ae080c05eec91bbfb59b68ae1a8c7dc0bc854b5e", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -8,11 +8,10 @@ use crate::symbol::Symbol;\n use crate::tokenstream;\n \n use smallvec::SmallVec;\n-use syntax_pos::{self, Pos, Span, FileName};\n+use syntax_pos::{self, Pos, Span};\n \n use std::fs;\n use std::io::ErrorKind;\n-use std::path::PathBuf;\n use rustc_data_structures::sync::Lrc;\n \n // These macros all relate to the file system; they either return\n@@ -78,9 +77,9 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt<'_>, sp: Span, tts: &[tokenstrea\n         None => return DummyResult::any(sp),\n     };\n     // The file will be added to the code map by the parser\n-    let path = res_rel_file(cx, sp, file);\n+    let file = cx.resolve_path(file, sp);\n     let directory_ownership = DirectoryOwnership::Owned { relative: None };\n-    let p = parse::new_sub_parser_from_file(cx.parse_sess(), &path, directory_ownership, None, sp);\n+    let p = parse::new_sub_parser_from_file(cx.parse_sess(), &file, directory_ownership, None, sp);\n \n     struct ExpandResult<'a> {\n         p: parse::parser::Parser<'a>,\n@@ -115,7 +114,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::To\n         Some(f) => f,\n         None => return DummyResult::expr(sp)\n     };\n-    let file = res_rel_file(cx, sp, file);\n+    let file = cx.resolve_path(file, sp);\n     match fs::read_to_string(&file) {\n         Ok(src) => {\n             let interned_src = Symbol::intern(&src);\n@@ -143,7 +142,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::\n         Some(f) => f,\n         None => return DummyResult::expr(sp)\n     };\n-    let file = res_rel_file(cx, sp, file);\n+    let file = cx.resolve_path(file, sp);\n     match fs::read(&file) {\n         Ok(bytes) => {\n             // Add the contents to the source map if it contains UTF-8.\n@@ -164,24 +163,3 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::\n         }\n     }\n }\n-\n-// resolve a file-system path to an absolute file-system path (if it\n-// isn't already)\n-fn res_rel_file(cx: &mut ExtCtxt<'_>, sp: syntax_pos::Span, arg: String) -> PathBuf {\n-    let arg = PathBuf::from(arg);\n-    // Relative paths are resolved relative to the file in which they are found\n-    // after macro expansion (that is, they are unhygienic).\n-    if !arg.is_absolute() {\n-        let callsite = sp.source_callsite();\n-        let mut path = match cx.source_map().span_to_unmapped_path(callsite) {\n-            FileName::Real(path) => path,\n-            FileName::DocTest(path, _) => path,\n-            other => panic!(\"cannot resolve relative path in non-file source `{}`\", other),\n-        };\n-        path.pop();\n-        path.push(arg);\n-        path\n-    } else {\n-        arg\n-    }\n-}"}, {"sha": "72184b0bd6400374f59ad582793a44c6707a9b25", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 89, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -19,8 +19,7 @@ use crate::ast::{\n     self, AssocTyConstraint, AssocTyConstraintKind, NodeId, GenericParam, GenericParamKind,\n     PatKind, RangeEnd,\n };\n-use crate::attr;\n-use crate::early_buffered_lints::BufferedEarlyLintId;\n+use crate::attr::{self, check_builtin_attribute, AttributeTemplate};\n use crate::source_map::Spanned;\n use crate::edition::{ALL_EDITIONS, Edition};\n use crate::visit::{self, FnKind, Visitor};\n@@ -906,27 +905,6 @@ pub enum AttributeGate {\n     Ungated,\n }\n \n-/// A template that the attribute input must match.\n-/// Only top-level shape (`#[attr]` vs `#[attr(...)]` vs `#[attr = ...]`) is considered now.\n-#[derive(Clone, Copy)]\n-pub struct AttributeTemplate {\n-    word: bool,\n-    list: Option<&'static str>,\n-    name_value_str: Option<&'static str>,\n-}\n-\n-impl AttributeTemplate {\n-    /// Checks that the given meta-item is compatible with this template.\n-    fn compatible(&self, meta_item_kind: &ast::MetaItemKind) -> bool {\n-        match meta_item_kind {\n-            ast::MetaItemKind::Word => self.word,\n-            ast::MetaItemKind::List(..) => self.list.is_some(),\n-            ast::MetaItemKind::NameValue(lit) if lit.node.is_str() => self.name_value_str.is_some(),\n-            ast::MetaItemKind::NameValue(..) => false,\n-        }\n-    }\n-}\n-\n /// A convenience macro for constructing attribute templates.\n /// E.g., `template!(Word, List: \"description\")` means that the attribute\n /// supports forms `#[attr]` and `#[attr(description)]`.\n@@ -1117,7 +1095,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n                                             \"the `#[rustc_const_unstable]` attribute \\\n                                             is an internal feature\",\n                                             cfg_fn!(rustc_const_unstable))),\n-    (sym::global_allocator, Normal, template!(Word), Ungated),\n     (sym::default_lib_allocator, Whitelisted, template!(Word), Gated(Stability::Unstable,\n                                             sym::allocator_internals,\n                                             \"the `#[default_lib_allocator]` \\\n@@ -1902,70 +1879,6 @@ impl<'a> PostExpansionVisitor<'a> {\n             Abi::System => {}\n         }\n     }\n-\n-    fn check_builtin_attribute(&mut self, attr: &ast::Attribute, name: Symbol,\n-                               template: AttributeTemplate) {\n-        // Some special attributes like `cfg` must be checked\n-        // before the generic check, so we skip them here.\n-        let should_skip = |name| name == sym::cfg;\n-        // Some of previously accepted forms were used in practice,\n-        // report them as warnings for now.\n-        let should_warn = |name| name == sym::doc || name == sym::ignore ||\n-                                 name == sym::inline || name == sym::link;\n-\n-        match attr.parse_meta(self.context.parse_sess) {\n-            Ok(meta) => if !should_skip(name) && !template.compatible(&meta.node) {\n-                let error_msg = format!(\"malformed `{}` attribute input\", name);\n-                let mut msg = \"attribute must be of the form \".to_owned();\n-                let mut suggestions = vec![];\n-                let mut first = true;\n-                if template.word {\n-                    first = false;\n-                    let code = format!(\"#[{}]\", name);\n-                    msg.push_str(&format!(\"`{}`\", &code));\n-                    suggestions.push(code);\n-                }\n-                if let Some(descr) = template.list {\n-                    if !first {\n-                        msg.push_str(\" or \");\n-                    }\n-                    first = false;\n-                    let code = format!(\"#[{}({})]\", name, descr);\n-                    msg.push_str(&format!(\"`{}`\", &code));\n-                    suggestions.push(code);\n-                }\n-                if let Some(descr) = template.name_value_str {\n-                    if !first {\n-                        msg.push_str(\" or \");\n-                    }\n-                    let code = format!(\"#[{} = \\\"{}\\\"]\", name, descr);\n-                    msg.push_str(&format!(\"`{}`\", &code));\n-                    suggestions.push(code);\n-                }\n-                if should_warn(name) {\n-                    self.context.parse_sess.buffer_lint(\n-                        BufferedEarlyLintId::IllFormedAttributeInput,\n-                        meta.span,\n-                        ast::CRATE_NODE_ID,\n-                        &msg,\n-                    );\n-                } else {\n-                    self.context.parse_sess.span_diagnostic.struct_span_err(meta.span, &error_msg)\n-                        .span_suggestions(\n-                            meta.span,\n-                            if suggestions.len() == 1 {\n-                                \"must be of the form\"\n-                            } else {\n-                                \"the following are the possible correct uses\"\n-                            },\n-                            suggestions.into_iter(),\n-                            Applicability::HasPlaceholders,\n-                        ).emit();\n-                }\n-            }\n-            Err(mut err) => err.emit(),\n-        }\n-    }\n }\n \n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n@@ -2006,7 +1919,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match attr_info {\n             // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n             Some(&(name, _, template, _)) if name != sym::rustc_dummy =>\n-                self.check_builtin_attribute(attr, name, template),\n+                check_builtin_attribute(self.context.parse_sess, attr, name, template),\n             _ => if let Some(TokenTree::Token(token)) = attr.tokens.trees().next() {\n                 if token == token::Eq {\n                     // All key-value attributes are restricted to meta-item syntax."}, {"sha": "75b4e89ec01c259572a5322e20ca94aa355a88f8", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -162,6 +162,7 @@ pub mod print {\n \n pub mod ext {\n     pub use syntax_pos::hygiene;\n+    pub mod allocator;\n     pub mod base;\n     pub mod build;\n     pub mod derive;"}, {"sha": "a5b6f0d683629342ee2573c018e77ec72ce347c7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -7671,14 +7671,27 @@ impl<'a> Parser<'a> {\n         let ret = f(self);\n         let last_token = if self.token_cursor.stack.len() == prev {\n             &mut self.token_cursor.frame.last_token\n+        } else if self.token_cursor.stack.get(prev).is_none() {\n+            // This can happen due to a bad interaction of two unrelated recovery mechanisms with\n+            // mismatched delimiters *and* recovery lookahead on the likely typo `pub ident(`\n+            // (#62881).\n+            return Ok((ret?, TokenStream::new(vec![])));\n         } else {\n             &mut self.token_cursor.stack[prev].last_token\n         };\n \n         // Pull out the tokens that we've collected from the call to `f` above.\n         let mut collected_tokens = match *last_token {\n             LastToken::Collecting(ref mut v) => mem::take(v),\n-            LastToken::Was(_) => panic!(\"our vector went away?\"),\n+            LastToken::Was(ref was) => {\n+                let msg = format!(\"our vector went away? - found Was({:?})\", was);\n+                debug!(\"collect_tokens: {}\", msg);\n+                self.sess.span_diagnostic.delay_span_bug(self.token.span, &msg);\n+                // This can happen due to a bad interaction of two unrelated recovery mechanisms\n+                // with mismatched delimiters *and* recovery lookahead on the likely typo\n+                // `pub ident(` (#62895, different but similar to the case above).\n+                return Ok((ret?, TokenStream::new(vec![])));\n+            }\n         };\n \n         // If we're not at EOF our current token wasn't actually consumed by"}, {"sha": "33072487e19f4b520b42dabe66ff2d380b602f1d", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,191 @@\n+use syntax::ast::{ItemKind, Mutability, Stmt, Ty, TyKind, Unsafety};\n+use syntax::ast::{self, Arg, Attribute, Expr, FnHeader, Generics, Ident};\n+use syntax::attr::check_builtin_macro_attribute;\n+use syntax::ext::allocator::{AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::hygiene::SyntaxContext;\n+use syntax::ptr::P;\n+use syntax::symbol::{kw, sym, Symbol};\n+use syntax_pos::Span;\n+\n+pub fn expand(\n+    ecx: &mut ExtCtxt<'_>,\n+    _span: Span,\n+    meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::global_allocator);\n+\n+    let not_static = |item: Annotatable| {\n+        ecx.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n+        vec![item]\n+    };\n+    let item = match item {\n+        Annotatable::Item(item) => match item.node {\n+            ItemKind::Static(..) => item,\n+            _ => return not_static(Annotatable::Item(item)),\n+        }\n+        _ => return not_static(item),\n+    };\n+\n+    // Generate a bunch of new items using the AllocFnFactory\n+    let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));\n+    let f = AllocFnFactory {\n+        span,\n+        kind: AllocatorKind::Global,\n+        global: item.ident,\n+        cx: ecx,\n+    };\n+\n+    // Generate item statements for the allocator methods.\n+    let stmts = ALLOCATOR_METHODS.iter().map(|method| f.allocator_fn(method)).collect();\n+\n+    // Generate anonymous constant serving as container for the allocator methods.\n+    let const_ty = ecx.ty(span, TyKind::Tup(Vec::new()));\n+    let const_body = ecx.expr_block(ecx.block(span, stmts));\n+    let const_item =\n+        ecx.item_const(span, Ident::with_empty_ctxt(kw::Underscore), const_ty, const_body);\n+\n+    // Return the original item and the new methods.\n+    vec![Annotatable::Item(item), Annotatable::Item(const_item)]\n+}\n+\n+struct AllocFnFactory<'a, 'b> {\n+    span: Span,\n+    kind: AllocatorKind,\n+    global: Ident,\n+    cx: &'b ExtCtxt<'a>,\n+}\n+\n+impl AllocFnFactory<'_, '_> {\n+    fn allocator_fn(&self, method: &AllocatorMethod) -> Stmt {\n+        let mut abi_args = Vec::new();\n+        let mut i = 0;\n+        let ref mut mk = || {\n+            let name = Ident::from_str(&format!(\"arg{}\", i));\n+            i += 1;\n+            name\n+        };\n+        let args = method\n+            .inputs\n+            .iter()\n+            .map(|ty| self.arg_ty(ty, &mut abi_args, mk))\n+            .collect();\n+        let result = self.call_allocator(method.name, args);\n+        let (output_ty, output_expr) = self.ret_ty(&method.output, result);\n+        let kind = ItemKind::Fn(\n+            self.cx.fn_decl(abi_args, ast::FunctionRetTy::Ty(output_ty)),\n+            FnHeader {\n+                unsafety: Unsafety::Unsafe,\n+                ..FnHeader::default()\n+            },\n+            Generics::default(),\n+            self.cx.block_expr(output_expr),\n+        );\n+        let item = self.cx.item(\n+            self.span,\n+            Ident::from_str(&self.kind.fn_name(method.name)),\n+            self.attrs(),\n+            kind,\n+        );\n+        self.cx.stmt_item(self.span, item)\n+    }\n+\n+    fn call_allocator(&self, method: &str, mut args: Vec<P<Expr>>) -> P<Expr> {\n+        let method = self.cx.std_path(&[\n+            Symbol::intern(\"alloc\"),\n+            Symbol::intern(\"GlobalAlloc\"),\n+            Symbol::intern(method),\n+        ]);\n+        let method = self.cx.expr_path(self.cx.path(self.span, method));\n+        let allocator = self.cx.path_ident(self.span, self.global);\n+        let allocator = self.cx.expr_path(allocator);\n+        let allocator = self.cx.expr_addr_of(self.span, allocator);\n+        args.insert(0, allocator);\n+\n+        self.cx.expr_call(self.span, method, args)\n+    }\n+\n+    fn attrs(&self) -> Vec<Attribute> {\n+        let special = sym::rustc_std_internal_symbol;\n+        let special = self.cx.meta_word(self.span, special);\n+        vec![self.cx.attribute(self.span, special)]\n+    }\n+\n+    fn arg_ty(\n+        &self,\n+        ty: &AllocatorTy,\n+        args: &mut Vec<Arg>,\n+        ident: &mut dyn FnMut() -> Ident,\n+    ) -> P<Expr> {\n+        match *ty {\n+            AllocatorTy::Layout => {\n+                let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n+                let ty_usize = self.cx.ty_path(usize);\n+                let size = ident();\n+                let align = ident();\n+                args.push(self.cx.arg(self.span, size, ty_usize.clone()));\n+                args.push(self.cx.arg(self.span, align, ty_usize));\n+\n+                let layout_new = self.cx.std_path(&[\n+                    Symbol::intern(\"alloc\"),\n+                    Symbol::intern(\"Layout\"),\n+                    Symbol::intern(\"from_size_align_unchecked\"),\n+                ]);\n+                let layout_new = self.cx.expr_path(self.cx.path(self.span, layout_new));\n+                let size = self.cx.expr_ident(self.span, size);\n+                let align = self.cx.expr_ident(self.span, align);\n+                let layout = self.cx.expr_call(self.span, layout_new, vec![size, align]);\n+                layout\n+            }\n+\n+            AllocatorTy::Ptr => {\n+                let ident = ident();\n+                args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n+                let arg = self.cx.expr_ident(self.span, ident);\n+                self.cx.expr_cast(self.span, arg, self.ptr_u8())\n+            }\n+\n+            AllocatorTy::Usize => {\n+                let ident = ident();\n+                args.push(self.cx.arg(self.span, ident, self.usize()));\n+                self.cx.expr_ident(self.span, ident)\n+            }\n+\n+            AllocatorTy::ResultPtr | AllocatorTy::Unit => {\n+                panic!(\"can't convert AllocatorTy to an argument\")\n+            }\n+        }\n+    }\n+\n+    fn ret_ty(&self, ty: &AllocatorTy, expr: P<Expr>) -> (P<Ty>, P<Expr>) {\n+        match *ty {\n+            AllocatorTy::ResultPtr => {\n+                // We're creating:\n+                //\n+                //      #expr as *mut u8\n+\n+                let expr = self.cx.expr_cast(self.span, expr, self.ptr_u8());\n+                (self.ptr_u8(), expr)\n+            }\n+\n+            AllocatorTy::Unit => (self.cx.ty(self.span, TyKind::Tup(Vec::new())), expr),\n+\n+            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n+                panic!(\"can't convert `AllocatorTy` to an output\")\n+            }\n+        }\n+    }\n+\n+    fn usize(&self) -> P<Ty> {\n+        let usize = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::usize));\n+        self.cx.ty_path(usize)\n+    }\n+\n+    fn ptr_u8(&self) -> P<Ty> {\n+        let u8 = self.cx.path_ident(self.span, Ident::with_empty_ctxt(sym::u8));\n+        let ty_u8 = self.cx.ty_path(u8);\n+        self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n+    }\n+}"}, {"sha": "400bfe796bb0765793019b5bb7f51045cfbcf816", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -29,6 +29,7 @@ mod concat_idents;\n mod env;\n mod format;\n mod format_foreign;\n+mod global_allocator;\n mod global_asm;\n mod log_syntax;\n mod proc_macro_server;\n@@ -151,6 +152,12 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n             SyntaxExtensionKind::LegacyAttr(Box::new(test::expand_bench)), edition\n         )\n     });\n+    register(sym::global_allocator, SyntaxExtension {\n+        allow_internal_unstable: Some([sym::rustc_attrs][..].into()),\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyAttr(Box::new(global_allocator::expand)), edition\n+        )\n+    });\n \n     let allow_internal_unstable = Some([sym::fmt_internals][..].into());\n     register(sym::format_args, SyntaxExtension {"}, {"sha": "d381c42f9ce84a1b543912144a35272f90c1e7d1", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1,31 +1,34 @@\n /// The expansion from a test function to the appropriate test struct for libtest\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n \n+use syntax::ast;\n+use syntax::attr::{self, check_builtin_macro_attribute};\n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::SyntaxContext;\n-use syntax::attr;\n-use syntax::ast;\n use syntax::print::pprust;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n+\n use std::iter;\n \n pub fn expand_test(\n     cx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n-    _meta_item: &ast::MetaItem,\n+    meta_item: &ast::MetaItem,\n     item: Annotatable,\n ) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(cx, meta_item, sym::test);\n     expand_test_or_bench(cx, attr_sp, item, false)\n }\n \n pub fn expand_bench(\n     cx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n-    _meta_item: &ast::MetaItem,\n+    meta_item: &ast::MetaItem,\n     item: Annotatable,\n ) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(cx, meta_item, sym::bench);\n     expand_test_or_bench(cx, attr_sp, item, true)\n }\n "}, {"sha": "ea4a8d541ab9928f8636bdde77b24a1adfc17532", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -9,20 +9,23 @@\n // We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n // logic will pick up on.\n \n+use syntax::ast;\n+use syntax::attr::check_builtin_macro_attribute;\n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::SyntaxContext;\n-use syntax::ast;\n use syntax::source_map::respan;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n-    _meta_item: &ast::MetaItem,\n+    meta_item: &ast::MetaItem,\n     anno_item: Annotatable\n ) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::test_case);\n+\n     if !ecx.ecfg.should_test { return vec![]; }\n \n     let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));"}, {"sha": "4791ba85e7645c02146dd416288480943670d1ca", "filename": "src/stdarch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstdarch?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1 +1 @@\n-Subproject commit b881a2d124cb0eea09d137300eb4a35829b517fb\n+Subproject commit 4791ba85e7645c02146dd416288480943670d1ca"}, {"sha": "12813a1fc8bd4088818ab205bd9035ffe94b6e02", "filename": "src/test/run-pass/allocator/custom-in-block.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-block.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,22 @@\n+// run-pass\n+// no-prefer-dynamic\n+// aux-build:custom.rs\n+// aux-build:helper.rs\n+\n+extern crate custom;\n+extern crate helper;\n+\n+use custom::A;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+fn main() {\n+    #[global_allocator]\n+    pub static GLOBAL: A = A(AtomicUsize::new(0));\n+\n+    let n = GLOBAL.0.load(Ordering::SeqCst);\n+    let s = Box::new(0);\n+    helper::work_with(&s);\n+    assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n+    drop(s);\n+    assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n+}"}, {"sha": "ea341b1ac14aeee096f1340fa316f50d39752a0b", "filename": "src/test/run-pass/allocator/custom-in-submodule.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-submodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-submodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom-in-submodule.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,26 @@\n+// run-pass\n+// no-prefer-dynamic\n+// aux-build:custom.rs\n+// aux-build:helper.rs\n+\n+extern crate custom;\n+extern crate helper;\n+\n+use custom::A;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+mod submodule {\n+    use super::*;\n+\n+    #[global_allocator]\n+    pub static GLOBAL: A = A(AtomicUsize::new(0));\n+}\n+\n+fn main() {\n+    let n = submodule::GLOBAL.0.load(Ordering::SeqCst);\n+    let s = Box::new(0);\n+    helper::work_with(&s);\n+    assert_eq!(submodule::GLOBAL.0.load(Ordering::SeqCst), n + 1);\n+    drop(s);\n+    assert_eq!(submodule::GLOBAL.0.load(Ordering::SeqCst), n + 2);\n+}"}, {"sha": "2bb1aeecf376d9d8abdc97779d5fd5a38f9b6695", "filename": "src/test/run-pass/consts/const-fn-type-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-fn-type-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-fn-type-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-fn-type-name.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -5,7 +5,7 @@\n #![allow(dead_code)]\n \n const fn type_name_wrapper<T>(_: &T) -> &'static str {\n-    unsafe { core::intrinsics::type_name::<T>() }\n+    core::intrinsics::type_name::<T>()\n }\n \n struct Struct<TA, TB, TC> {"}, {"sha": "dbcdfc61ef951da80016c9690ce5fa3835e4ed5c", "filename": "src/test/run-pass/generator/size-moved-locals.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Fgenerator%2Fsize-moved-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Fgenerator%2Fsize-moved-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fsize-moved-locals.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -56,8 +56,20 @@ fn overlap_move_points() -> impl Generator<Yield = (), Return = ()> {\n     }\n }\n \n+fn overlap_x_and_y() -> impl Generator<Yield = (), Return = ()>{\n+    static || {\n+        let x = Foo([0; FOO_SIZE]);\n+        yield;\n+        drop(x);\n+        let y = Foo([0; FOO_SIZE]);\n+        yield;\n+        drop(y);\n+    }\n+}\n+\n fn main() {\n     assert_eq!(1028, std::mem::size_of_val(&move_before_yield()));\n     assert_eq!(1032, std::mem::size_of_val(&move_before_yield_with_noop()));\n     assert_eq!(2056, std::mem::size_of_val(&overlap_move_points()));\n+    assert_eq!(1032, std::mem::size_of_val(&overlap_x_and_y()));\n }"}, {"sha": "6facf0b2dd5782fb0228e3cafcd574d9df27ffc5", "filename": "src/test/run-pass/issues/issue-21058.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Fissues%2Fissue-21058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Fissues%2Fissue-21058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-21058.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1,6 +1,5 @@\n // run-pass\n #![allow(dead_code)]\n-#![feature(core_intrinsics)]\n \n use std::fmt::Debug;\n \n@@ -12,7 +11,7 @@ macro_rules! check {\n         assert_eq!(type_name_of_val($ty_of), $expected);\n     };\n     ($ty:ty, $expected:expr) => {\n-        assert_eq!(unsafe { std::intrinsics::type_name::<$ty>()}, $expected);\n+        assert_eq!(std::any::type_name::<$ty>(), $expected);\n     };\n }\n \n@@ -50,7 +49,7 @@ fn bar<T: Trait>() {\n }\n \n fn type_name_of_val<T>(_: T) -> &'static str {\n-    unsafe { std::intrinsics::type_name::<T>() }\n+    std::any::type_name::<T>()\n }\n \n #[derive(Debug)]"}, {"sha": "4d407125299a722a699c73d4a9a377325ebf5ff9", "filename": "src/test/run-pass/issues/issue-61894.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Fissues%2Fissue-61894.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Fissues%2Fissue-61894.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-61894.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1,14 +1,14 @@\n #![feature(core_intrinsics)]\n \n-use std::intrinsics::type_name;\n+use std::any::type_name;\n \n struct Bar<M>(M);\n \n impl<M> Bar<M> {\n     fn foo(&self) -> &'static str {\n         fn f() {}\n         fn type_name_of<T>(_: T) -> &'static str {\n-            unsafe { type_name::<T>() }\n+            type_name::<T>()\n         }\n         type_name_of(f)\n     }"}, {"sha": "d9d947bd4c062ac8787cd8b9eba5248668717132", "filename": "src/test/run-pass/tydesc-name.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Ftydesc-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Frun-pass%2Ftydesc-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftydesc-name.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1,16 +1,12 @@\n #![allow(dead_code)]\n \n-#![feature(core_intrinsics)]\n-\n-use std::intrinsics::type_name;\n+use std::any::type_name;\n \n struct Foo<T> {\n     x: T\n }\n \n pub fn main() {\n-    unsafe {\n-        assert_eq!(type_name::<isize>(), \"isize\");\n-        assert_eq!(type_name::<Foo<usize>>(), \"tydesc_name::Foo<usize>\");\n-    }\n+    assert_eq!(type_name::<isize>(), \"isize\");\n+    assert_eq!(type_name::<Foo<usize>>(), \"tydesc_name::Foo<usize>\");\n }"}, {"sha": "7a8d86b8da18cf08df1f0225a654fd40851a15d6", "filename": "src/test/ui/allocator-submodule.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/890881f8f4c77e8670d4b32104c0325fcfefc90f/src%2Ftest%2Fui%2Fallocator-submodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890881f8f4c77e8670d4b32104c0325fcfefc90f/src%2Ftest%2Fui%2Fallocator-submodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-submodule.rs?ref=890881f8f4c77e8670d4b32104c0325fcfefc90f", "patch": "@@ -1,28 +0,0 @@\n-// Tests that it is possible to create a global allocator in a submodule, rather than in the crate\n-// root.\n-\n-extern crate alloc;\n-\n-use std::{\n-    alloc::{GlobalAlloc, Layout},\n-    ptr,\n-};\n-\n-struct MyAlloc;\n-\n-unsafe impl GlobalAlloc for MyAlloc {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        ptr::null_mut()\n-    }\n-\n-    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {}\n-}\n-\n-mod submod {\n-    use super::MyAlloc;\n-\n-    #[global_allocator]\n-    static MY_HEAP: MyAlloc = MyAlloc; //~ ERROR global_allocator\n-}\n-\n-fn main() {}"}, {"sha": "91c7c0f6b8e24fd3f8035c093b706d0011f6a284", "filename": "src/test/ui/allocator-submodule.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/890881f8f4c77e8670d4b32104c0325fcfefc90f/src%2Ftest%2Fui%2Fallocator-submodule.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/890881f8f4c77e8670d4b32104c0325fcfefc90f/src%2Ftest%2Fui%2Fallocator-submodule.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator-submodule.stderr?ref=890881f8f4c77e8670d4b32104c0325fcfefc90f", "patch": "@@ -1,8 +0,0 @@\n-error: `global_allocator` cannot be used in submodules\n-  --> $DIR/allocator-submodule.rs:25:5\n-   |\n-LL |     static MY_HEAP: MyAlloc = MyAlloc;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "1033f947c5f5b68a72f4b4bde656114a7c9ad63b", "filename": "src/test/ui/allocator/allocator-args.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,13 @@\n+use std::alloc::{GlobalAlloc, Layout};\n+\n+struct A;\n+\n+unsafe impl GlobalAlloc for A {\n+    unsafe fn alloc(&self, _: Layout) -> *mut u8 { panic!() }\n+    unsafe fn dealloc(&self, _: *mut u8, _: Layout) { panic!() }\n+}\n+\n+#[global_allocator(malloc)] //~ ERROR malformed `global_allocator` attribute input\n+static S: A = A;\n+\n+fn main() {}"}, {"sha": "dfff2a7e7094d368a9a83a8854c3a429557fdcb9", "filename": "src/test/ui/allocator/allocator-args.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,8 @@\n+error: malformed `global_allocator` attribute input\n+  --> $DIR/allocator-args.rs:10:1\n+   |\n+LL | #[global_allocator(malloc)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[global_allocator]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "aa1291e77aecbb3a495210ef3b318af7078208fc", "filename": "src/test/ui/allocator/two-allocators.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -4,6 +4,6 @@ use std::alloc::System;\n static A: System = System;\n #[global_allocator]\n static B: System = System;\n-//~^ ERROR: cannot define more than one `#[global_allocator]`\n+//~^ ERROR: cannot define multiple global allocators\n \n fn main() {}"}, {"sha": "ed0aa13eb8078e6bce1bace25afc41b5c8d7d210", "filename": "src/test/ui/allocator/two-allocators.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1,8 +1,14 @@\n-error: cannot define more than one `#[global_allocator]`\n+error: cannot define multiple global allocators\n   --> $DIR/two-allocators.rs:6:1\n    |\n LL | static B: System = System;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the previous global allocator is defined here\n+  --> $DIR/two-allocators.rs:4:1\n+   |\n+LL | static A: System = System;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "bb217bd182db664cd33ccfa0801f216b1668da30", "filename": "src/test/ui/associated-const/associated-const-ambiguity-report.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-ambiguity-report.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-ambiguity-report.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-ambiguity-report.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -9,11 +9,13 @@ note: candidate #1 is defined in an impl of the trait `Foo` for the type `i32`\n    |\n LL |     const ID: i32 = 1;\n    |     ^^^^^^^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `Foo::ID(...)` instead\n note: candidate #2 is defined in an impl of the trait `Bar` for the type `i32`\n   --> $DIR/associated-const-ambiguity-report.rs:14:5\n    |\n LL |     const ID: i32 = 3;\n    |     ^^^^^^^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `Bar::ID(...)` instead\n \n error: aborting due to previous error\n "}, {"sha": "429947269385be53b7f1c71d7b6ff99ed701a51c", "filename": "src/test/ui/consts/issue-51559.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fconsts%2Fissue-51559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fconsts%2Fissue-51559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-51559.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,7 @@\n+#![feature(const_raw_ptr_to_usize_cast)]\n+\n+const BAR: *mut () = ((|| 3) as fn() -> i32) as *mut ();\n+pub const FOO: usize = unsafe { BAR as usize };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+fn main() {}"}, {"sha": "917c54ddaef1efeeab049cd327c2a013b591cf3e", "filename": "src/test/ui/consts/issue-51559.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fconsts%2Fissue-51559.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fconsts%2Fissue-51559.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-51559.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,11 @@\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/issue-51559.rs:4:1\n+   |\n+LL | pub const FOO: usize = unsafe { BAR as usize };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "a58d16bfafb591757740b870b45b8851325e3d6a", "filename": "src/test/ui/error-codes/E0034.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Ferror-codes%2FE0034.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Ferror-codes%2FE0034.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0034.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -9,11 +9,13 @@ note: candidate #1 is defined in an impl of the trait `Trait1` for the type `Tes\n    |\n LL |     fn foo() {}\n    |     ^^^^^^^^\n+   = help: to disambiguate the method call, write `Trait1::foo(...)` instead\n note: candidate #2 is defined in an impl of the trait `Trait2` for the type `Test`\n   --> $DIR/E0034.rs:16:5\n    |\n LL |     fn foo() {}\n    |     ^^^^^^^^\n+   = help: to disambiguate the method call, write `Trait2::foo(...)` instead\n \n error: aborting due to previous error\n "}, {"sha": "4e89f7464da49219e786d25b96813cb790977823", "filename": "src/test/ui/extern/external-doc-error.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fextern%2Fexternal-doc-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fextern%2Fexternal-doc-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fexternal-doc-error.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -4,7 +4,6 @@\n \n #[doc(include = \"not-a-file.md\")]\n pub struct SomeStruct; //~^ ERROR couldn't read\n-                       //~| HELP external doc paths are relative to the crate root\n \n #[doc(include = \"auxiliary/invalid-utf8.txt\")]\n pub struct InvalidUtf8; //~^ ERROR wasn't a utf-8 file"}, {"sha": "b180cd66c52696534864ea82b087ab6137d38169", "filename": "src/test/ui/extern/external-doc-error.stderr", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fextern%2Fexternal-doc-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fextern%2Fexternal-doc-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fexternal-doc-error.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -3,35 +3,33 @@ error: couldn't read $DIR/not-a-file.md: $FILE_NOT_FOUND_MSG (os error 2)\n    |\n LL | #[doc(include = \"not-a-file.md\")]\n    |                 ^^^^^^^^^^^^^^^ couldn't read file\n-   |\n-   = help: external doc paths are relative to the crate root\n \n error: $DIR/auxiliary/invalid-utf8.txt wasn't a utf-8 file\n-  --> $DIR/external-doc-error.rs:9:17\n+  --> $DIR/external-doc-error.rs:8:17\n    |\n LL | #[doc(include = \"auxiliary/invalid-utf8.txt\")]\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ contains invalid utf-8\n \n error: expected path to external documentation\n-  --> $DIR/external-doc-error.rs:12:7\n+  --> $DIR/external-doc-error.rs:11:7\n    |\n LL | #[doc(include)]\n    |       ^^^^^^^ help: provide a file path with `=`: `include = \"<path>\"`\n \n error: expected path to external documentation\n-  --> $DIR/external-doc-error.rs:17:7\n+  --> $DIR/external-doc-error.rs:16:7\n    |\n LL | #[doc(include(\"../README.md\"))]\n    |       ^^^^^^^^^^^^^^^^^^^^^^^ help: provide a file path with `=`: `include = \"../README.md\"`\n \n error: expected path to external documentation\n-  --> $DIR/external-doc-error.rs:22:7\n+  --> $DIR/external-doc-error.rs:21:7\n    |\n LL | #[doc(include = 123)]\n    |       ^^^^^^^^^^^^^ help: provide a file path with `=`: `include = \"<path>\"`\n \n error: expected path to external documentation\n-  --> $DIR/external-doc-error.rs:27:7\n+  --> $DIR/external-doc-error.rs:26:7\n    |\n LL | #[doc(include(123))]\n    |       ^^^^^^^^^^^^ help: provide a file path with `=`: `include = \"<path>\"`"}, {"sha": "37b5e792dc239f6a9ee3eaac800260afe30bea1b", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-bench.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1,3 +1,13 @@\n+warning: attribute must be of the form `#[bench]`\n+  --> $DIR/issue-43106-gating-of-bench.rs:15:1\n+   |\n+LL | #![bench                   = \"4100\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(ill_formed_attribute_input)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #57571 <https://github.com/rust-lang/rust/issues/57571>\n+\n error[E0601]: `main` function not found in crate `issue_43106_gating_of_bench`\n    |\n    = note: consider adding a `main` function to `$DIR/issue-43106-gating-of-bench.rs`"}, {"sha": "dbffabf3e02f93045198648d7104c4840a4fee53", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-test.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -1,3 +1,13 @@\n+warning: attribute must be of the form `#[test]`\n+  --> $DIR/issue-43106-gating-of-test.rs:10:1\n+   |\n+LL | #![test                    = \"4200\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(ill_formed_attribute_input)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #57571 <https://github.com/rust-lang/rust/issues/57571>\n+\n error[E0601]: `main` function not found in crate `issue_43106_gating_of_test`\n    |\n    = note: consider adding a `main` function to `$DIR/issue-43106-gating-of-test.rs`"}, {"sha": "b06a6298a571c67e596d486585fa23e84f44f9b3", "filename": "src/test/ui/inference/inference_unstable_featured.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Finference%2Finference_unstable_featured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Finference%2Finference_unstable_featured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Finference_unstable_featured.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -5,7 +5,9 @@ LL |     assert_eq!('x'.ipu_flatten(), 0);\n    |                    ^^^^^^^^^^^ multiple `ipu_flatten` found\n    |\n    = note: candidate #1 is defined in an impl of the trait `inference_unstable_iterator::IpuIterator` for the type `char`\n+   = help: to disambiguate the method call, write `inference_unstable_iterator::IpuIterator::ipu_flatten('x')` instead\n    = note: candidate #2 is defined in an impl of the trait `inference_unstable_itertools::IpuItertools` for the type `char`\n+   = help: to disambiguate the method call, write `inference_unstable_itertools::IpuItertools::ipu_flatten('x')` instead\n \n error: aborting due to previous error\n "}, {"sha": "4d0ff750c254c0c50209f4a3fd70432aa7fe684e", "filename": "src/test/ui/issues/issue-3702-2.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fissues%2Fissue-3702-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fissues%2Fissue-3702-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3702-2.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -9,11 +9,13 @@ note: candidate #1 is defined in an impl of the trait `ToPrimitive` for the type\n    |\n LL |     fn to_int(&self) -> isize { 0 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `ToPrimitive::to_int(&self)` instead\n note: candidate #2 is defined in an impl of the trait `Add` for the type `isize`\n   --> $DIR/issue-3702-2.rs:14:5\n    |\n LL |     fn to_int(&self) -> isize { *self }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `Add::to_int(&self)` instead\n \n error: aborting due to previous error\n "}, {"sha": "9f46a722a508e1a09a0c1743e59a8bc9c703f7b8", "filename": "src/test/ui/methods/method-ambig-two-traits-cross-crate.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-cross-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-cross-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-cross-crate.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -9,7 +9,9 @@ note: candidate #1 is defined in an impl of the trait `Me2` for the type `usize`\n    |\n LL | impl Me2 for usize { fn me(&self) -> usize { *self } }\n    |                      ^^^^^^^^^^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `Me2::me(1_usize)` instead\n    = note: candidate #2 is defined in an impl of the trait `ambig_impl_2_lib::Me` for the type `usize`\n+   = help: to disambiguate the method call, write `ambig_impl_2_lib::Me::me(1_usize)` instead\n \n error: aborting due to previous error\n "}, {"sha": "22bf840660536c7d489cc9e12b2850b15091a191", "filename": "src/test/ui/methods/method-ambig-two-traits-from-impls.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,16 @@\n+trait A { fn foo(self); }\n+trait B { fn foo(self); }\n+\n+struct AB {}\n+\n+impl A for AB {\n+    fn foo(self) {}\n+}\n+\n+impl B for AB {\n+    fn foo(self) {}\n+}\n+\n+fn main() {\n+    AB {}.foo();  //~ ERROR E0034\n+}"}, {"sha": "0b3724e030fa49ae986a6ef7b56ab5b25caafa3e", "filename": "src/test/ui/methods/method-ambig-two-traits-from-impls.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,22 @@\n+error[E0034]: multiple applicable items in scope\n+  --> $DIR/method-ambig-two-traits-from-impls.rs:15:11\n+   |\n+LL |     AB {}.foo();\n+   |           ^^^ multiple `foo` found\n+   |\n+note: candidate #1 is defined in an impl of the trait `A` for the type `AB`\n+  --> $DIR/method-ambig-two-traits-from-impls.rs:7:5\n+   |\n+LL |     fn foo(self) {}\n+   |     ^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `A::foo(AB {})` instead\n+note: candidate #2 is defined in an impl of the trait `B` for the type `AB`\n+  --> $DIR/method-ambig-two-traits-from-impls.rs:11:5\n+   |\n+LL |     fn foo(self) {}\n+   |     ^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `B::foo(AB {})` instead\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0034`."}, {"sha": "0a96c1223da36a475e769f0aa1880a59bd3b2227", "filename": "src/test/ui/methods/method-ambig-two-traits-from-impls2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls2.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,16 @@\n+trait A { fn foo(); }\n+trait B { fn foo(); }\n+\n+struct AB {}\n+\n+impl A for AB {\n+    fn foo() {}\n+}\n+\n+impl B for AB {\n+    fn foo() {}\n+}\n+\n+fn main() {\n+    AB::foo();  //~ ERROR E0034\n+}"}, {"sha": "81c99b33c813e07ff30cbe4ba287372605ca8812", "filename": "src/test/ui/methods/method-ambig-two-traits-from-impls2.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls2.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,22 @@\n+error[E0034]: multiple applicable items in scope\n+  --> $DIR/method-ambig-two-traits-from-impls2.rs:15:5\n+   |\n+LL |     AB::foo();\n+   |     ^^^^^^^ multiple `foo` found\n+   |\n+note: candidate #1 is defined in an impl of the trait `A` for the type `AB`\n+  --> $DIR/method-ambig-two-traits-from-impls2.rs:7:5\n+   |\n+LL |     fn foo() {}\n+   |     ^^^^^^^^\n+   = help: to disambiguate the method call, write `A::foo(...)` instead\n+note: candidate #2 is defined in an impl of the trait `B` for the type `AB`\n+  --> $DIR/method-ambig-two-traits-from-impls2.rs:11:5\n+   |\n+LL |     fn foo() {}\n+   |     ^^^^^^^^\n+   = help: to disambiguate the method call, write `B::foo(...)` instead\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0034`."}, {"sha": "dc8aef250373946452bcf34b4e67f554fc4c9561", "filename": "src/test/ui/methods/method-ambig-two-traits-with-default-method.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-with-default-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-with-default-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-with-default-method.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -9,11 +9,13 @@ note: candidate #1 is defined in an impl of the trait `Foo` for the type `usize`\n    |\n LL | trait Foo { fn method(&self) {} }\n    |             ^^^^^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `Foo::method(1_usize)` instead\n note: candidate #2 is defined in an impl of the trait `Bar` for the type `usize`\n   --> $DIR/method-ambig-two-traits-with-default-method.rs:6:13\n    |\n LL | trait Bar { fn method(&self) {} }\n    |             ^^^^^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `Bar::method(1_usize)` instead\n \n error: aborting due to previous error\n "}, {"sha": "283ef8fcba7a4e58cf5dd134eeebd6dd46770fb4", "filename": "src/test/ui/methods/method-deref-to-same-trait-object-with-separate-params.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -27,11 +27,13 @@ note: candidate #1 is defined in an impl of the trait `internal::X` for the type\n    |\n LL |         fn foo(self: Smaht<Self, u64>) -> u64 {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `internal::X::foo(x)` instead\n note: candidate #2 is defined in an impl of the trait `nuisance_foo::NuisanceFoo` for the type `_`\n   --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:70:9\n    |\n LL |         fn foo(self) {}\n    |         ^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `nuisance_foo::NuisanceFoo::foo(x)` instead\n note: candidate #3 is defined in the trait `FinalFoo`\n   --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:57:5\n    |"}, {"sha": "1782c2e375df556e67280e46908340fb2dd8c33a", "filename": "src/test/ui/parser/issue-62881.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fparser%2Fissue-62881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fparser%2Fissue-62881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62881.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,6 @@\n+fn main() {}\n+\n+fn f() -> isize { fn f() -> isize {} pub f<\n+//~^ ERROR missing `fn` or `struct` for function or struct definition\n+//~| ERROR mismatched types\n+//~ ERROR this file contains an un-closed delimiter"}, {"sha": "85c3575fd92885dfae2255072ccbc19b81de9c92", "filename": "src/test/ui/parser/issue-62881.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fparser%2Fissue-62881.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fparser%2Fissue-62881.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62881.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,29 @@\n+error: this file contains an un-closed delimiter\n+  --> $DIR/issue-62881.rs:6:53\n+   |\n+LL | fn f() -> isize { fn f() -> isize {} pub f<\n+   |                 - un-closed delimiter\n+...\n+LL |\n+   |                                                     ^\n+\n+error: missing `fn` or `struct` for function or struct definition\n+  --> $DIR/issue-62881.rs:3:41\n+   |\n+LL | fn f() -> isize { fn f() -> isize {} pub f<\n+   |                                         ^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-62881.rs:3:29\n+   |\n+LL | fn f() -> isize { fn f() -> isize {} pub f<\n+   |                      -      ^^^^^ expected isize, found ()\n+   |                      |\n+   |                      this function's body doesn't return\n+   |\n+   = note: expected type `isize`\n+              found type `()`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "53f17405d79f4aa8ec07b069f532fc31fd0df807", "filename": "src/test/ui/parser/issue-62895.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fparser%2Fissue-62895.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fparser%2Fissue-62895.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62895.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,11 @@\n+fn main() {}\n+\n+fn v() -> isize { //~ ERROR mismatched types\n+mod _ { //~ ERROR expected identifier\n+pub fn g() -> isizee { //~ ERROR cannot find type `isizee` in this scope\n+mod _ { //~ ERROR expected identifier\n+pub    g() -> is //~ ERROR missing `fn` for function definition\n+(), w20);\n+}\n+(), w20); //~ ERROR expected item, found `;`\n+}"}, {"sha": "7def7b562ca593b3dd99a95a159884204c8a69a3", "filename": "src/test/ui/parser/issue-62895.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fparser%2Fissue-62895.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fparser%2Fissue-62895.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-62895.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,49 @@\n+error: expected identifier, found reserved identifier `_`\n+  --> $DIR/issue-62895.rs:4:5\n+   |\n+LL | mod _ {\n+   |     ^ expected identifier, found reserved identifier\n+\n+error: expected identifier, found reserved identifier `_`\n+  --> $DIR/issue-62895.rs:6:5\n+   |\n+LL | mod _ {\n+   |     ^ expected identifier, found reserved identifier\n+\n+error: missing `fn` for function definition\n+  --> $DIR/issue-62895.rs:7:4\n+   |\n+LL | pub    g() -> is\n+   |    ^^^^\n+help: add `fn` here to parse `g` as a public function\n+   |\n+LL | pub fn g() -> is\n+   |     ^^\n+\n+error: expected item, found `;`\n+  --> $DIR/issue-62895.rs:10:9\n+   |\n+LL | (), w20);\n+   |         ^ help: remove this semicolon\n+\n+error[E0412]: cannot find type `isizee` in this scope\n+  --> $DIR/issue-62895.rs:5:15\n+   |\n+LL | pub fn g() -> isizee {\n+   |               ^^^^^^ help: a builtin type with a similar name exists: `isize`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-62895.rs:3:11\n+   |\n+LL | fn v() -> isize {\n+   |    -      ^^^^^ expected isize, found ()\n+   |    |\n+   |    this function's body doesn't return\n+   |\n+   = note: expected type `isize`\n+              found type `()`\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0308, E0412.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "d96b12fd15ac9c99b281d820aea5af7515b2bd10", "filename": "src/test/ui/suggestions/issue-62843.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fsuggestions%2Fissue-62843.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fsuggestions%2Fissue-62843.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-62843.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let line = String::from(\"abc\");\n+    let pattern = String::from(\"bc\");\n+    println!(\"{:?}\", line.find(pattern)); //~ ERROR E0277\n+}"}, {"sha": "cc27b5b49b67da35a3c7da614e5bc064e07dd69c", "filename": "src/test/ui/suggestions/issue-62843.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fsuggestions%2Fissue-62843.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Fsuggestions%2Fissue-62843.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-62843.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -0,0 +1,13 @@\n+error[E0277]: expected a `std::ops::FnMut<(char,)>` closure, found `std::string::String`\n+  --> $DIR/issue-62843.rs:4:27\n+   |\n+LL |     println!(\"{:?}\", line.find(pattern));\n+   |                           ^^^^ expected an `FnMut<(char,)>` closure, found `std::string::String`\n+   |\n+   = help: the trait `std::ops::FnMut<(char,)>` is not implemented for `std::string::String`\n+   = note: borrowing the `std::string::String` might fix the problem\n+   = note: required because of the requirements on the impl of `std::str::pattern::Pattern<'_>` for `std::string::String`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "cde7dd08249247200d18f268b4d31561f63e31e9", "filename": "src/test/ui/traits/trait-alias-ambiguous.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -9,11 +9,13 @@ note: candidate #1 is defined in an impl of the trait `inner::A` for the type `u\n    |\n LL |         fn foo(&self) {}\n    |         ^^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `inner::A::foo(t)` instead\n note: candidate #2 is defined in an impl of the trait `inner::B` for the type `u8`\n   --> $DIR/trait-alias-ambiguous.rs:11:9\n    |\n LL |         fn foo(&self) {}\n    |         ^^^^^^^^^^^^^\n+   = help: to disambiguate the method call, write `inner::B::foo(t)` instead\n \n error: aborting due to previous error\n "}, {"sha": "335c1aa0175edd9e6d658eae24231df36dbc2372", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18630677cf6c7ac50e6786c504b35bc09501dbe2/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=18630677cf6c7ac50e6786c504b35bc09501dbe2", "patch": "@@ -344,7 +344,7 @@ fn get_and_check_lib_features(base_src_path: &Path,\n                 Ok((name, f)) => {\n                     let mut check_features = |f: &Feature, list: &Features, display: &str| {\n                         if let Some(ref s) = list.get(name) {\n-                            if f.tracking_issue != s.tracking_issue {\n+                            if f.tracking_issue != s.tracking_issue && f.level != Status::Stable {\n                                 tidy_error!(bad,\n                                             \"{}:{}: mismatches the `issue` in {}\",\n                                             file.display(),"}]}