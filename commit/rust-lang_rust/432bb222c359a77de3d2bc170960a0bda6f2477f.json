{"sha": "432bb222c359a77de3d2bc170960a0bda6f2477f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMmJiMjIyYzM1OWE3N2RlM2QyYmMxNzA5NjBhMGJkYTZmMjQ3N2Y=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-02T13:27:10Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-08-02T13:27:47Z"}, "message": "Simplify inline_local_variable assist", "tree": {"sha": "e474d395ea1af6015d0d772206f52ed34eb40fc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e474d395ea1af6015d0d772206f52ed34eb40fc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/432bb222c359a77de3d2bc170960a0bda6f2477f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/432bb222c359a77de3d2bc170960a0bda6f2477f", "html_url": "https://github.com/rust-lang/rust/commit/432bb222c359a77de3d2bc170960a0bda6f2477f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/432bb222c359a77de3d2bc170960a0bda6f2477f/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb513c22f7fd18cb8ac21de44e8293fee9cd2b6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb513c22f7fd18cb8ac21de44e8293fee9cd2b6d", "html_url": "https://github.com/rust-lang/rust/commit/eb513c22f7fd18cb8ac21de44e8293fee9cd2b6d"}], "stats": {"total": 205, "additions": 93, "deletions": 112}, "files": [{"sha": "1474505971f2c0488de1ba64699d6fa374abe6ec", "filename": "crates/ide_assists/src/assist_context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432bb222c359a77de3d2bc170960a0bda6f2477f/crates%2Fide_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432bb222c359a77de3d2bc170960a0bda6f2477f/crates%2Fide_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fassist_context.rs?ref=432bb222c359a77de3d2bc170960a0bda6f2477f", "patch": "@@ -100,10 +100,6 @@ impl<'a> AssistContext<'a> {\n     pub(crate) fn covering_element(&self) -> SyntaxElement {\n         self.source_file.syntax().covering_element(self.frange.range)\n     }\n-    // FIXME: remove\n-    pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {\n-        self.source_file.syntax().covering_element(range)\n-    }\n }\n \n pub(crate) struct Assists {"}, {"sha": "dec8c320fdce5cf9c0f06262d8f92c052ea6b48e", "filename": "crates/ide_assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 93, "deletions": 108, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/432bb222c359a77de3d2bc170960a0bda6f2477f/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432bb222c359a77de3d2bc170960a0bda6f2477f/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=432bb222c359a77de3d2bc170960a0bda6f2477f", "patch": "@@ -1,10 +1,12 @@\n use either::Either;\n use hir::PathResolution;\n-use ide_db::{base_db::FileId, defs::Definition, search::FileReference};\n-use rustc_hash::FxHashMap;\n+use ide_db::{\n+    defs::Definition,\n+    search::{FileReference, UsageSearchResult},\n+};\n use syntax::{\n     ast::{self, AstNode, AstToken, NameOwner},\n-    TextRange,\n+    SyntaxElement, TextRange,\n };\n \n use crate::{\n@@ -14,7 +16,7 @@ use crate::{\n \n // Assist: inline_local_variable\n //\n-// Inlines local variable.\n+// Inlines a local variable.\n //\n // ```\n // fn main() {\n@@ -29,76 +31,77 @@ use crate::{\n // }\n // ```\n pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let InlineData { let_stmt, delete_let, replace_usages, target } =\n+    let InlineData { let_stmt, delete_let, references, target } =\n         inline_let(ctx).or_else(|| inline_usage(ctx))?;\n     let initializer_expr = let_stmt.initializer()?;\n \n-    let delete_range = if delete_let {\n+    let delete_range = delete_let.then(|| {\n         if let Some(whitespace) = let_stmt\n             .syntax()\n             .next_sibling_or_token()\n-            .and_then(|it| ast::Whitespace::cast(it.as_token()?.clone()))\n+            .and_then(SyntaxElement::into_token)\n+            .and_then(ast::Whitespace::cast)\n         {\n-            Some(TextRange::new(\n+            TextRange::new(\n                 let_stmt.syntax().text_range().start(),\n                 whitespace.syntax().text_range().end(),\n-            ))\n+            )\n         } else {\n-            Some(let_stmt.syntax().text_range())\n+            let_stmt.syntax().text_range()\n         }\n-    } else {\n-        None\n-    };\n+    });\n \n-    let wrap_in_parens = replace_usages\n-        .iter()\n-        .map(|(&file_id, refs)| {\n-            refs.iter()\n-                .map(|&FileReference { range, .. }| {\n-                    let usage_node = ctx\n-                        .covering_node_for_range(range)\n-                        .ancestors()\n-                        .find_map(ast::PathExpr::cast)?;\n-                    let usage_parent_option =\n-                        usage_node.syntax().parent().and_then(ast::Expr::cast);\n-                    let usage_parent = match usage_parent_option {\n-                        Some(u) => u,\n-                        None => return Some(false),\n-                    };\n-                    let initializer = matches!(\n-                        initializer_expr,\n-                        ast::Expr::CallExpr(_)\n-                            | ast::Expr::IndexExpr(_)\n-                            | ast::Expr::MethodCallExpr(_)\n-                            | ast::Expr::FieldExpr(_)\n-                            | ast::Expr::TryExpr(_)\n-                            | ast::Expr::RefExpr(_)\n-                            | ast::Expr::Literal(_)\n-                            | ast::Expr::TupleExpr(_)\n-                            | ast::Expr::ArrayExpr(_)\n-                            | ast::Expr::ParenExpr(_)\n-                            | ast::Expr::PathExpr(_)\n-                            | ast::Expr::BlockExpr(_)\n-                            | ast::Expr::EffectExpr(_),\n-                    );\n-                    let parent = matches!(\n-                        usage_parent,\n-                        ast::Expr::CallExpr(_)\n-                            | ast::Expr::TupleExpr(_)\n-                            | ast::Expr::ArrayExpr(_)\n-                            | ast::Expr::ParenExpr(_)\n-                            | ast::Expr::ForExpr(_)\n-                            | ast::Expr::WhileExpr(_)\n-                            | ast::Expr::BreakExpr(_)\n-                            | ast::Expr::ReturnExpr(_)\n-                            | ast::Expr::MatchExpr(_)\n-                    );\n-                    Some(!(initializer || parent))\n-                })\n-                .collect::<Option<_>>()\n-                .map(|b| (file_id, b))\n+    let wrap_in_parens = references\n+        .into_iter()\n+        .filter_map(|FileReference { range, name, .. }| match name {\n+            ast::NameLike::NameRef(name) => Some((range, name)),\n+            _ => None,\n+        })\n+        .map(|(range, name_ref)| {\n+            if range != name_ref.syntax().text_range() {\n+                // Do not rename inside macros\n+                // FIXME: This feels like a bad heuristic for macros\n+                return None;\n+            }\n+            let usage_node =\n+                name_ref.syntax().ancestors().find(|it| ast::PathExpr::can_cast(it.kind()));\n+            let usage_parent_option =\n+                usage_node.and_then(|it| it.parent()).and_then(ast::Expr::cast);\n+            let usage_parent = match usage_parent_option {\n+                Some(u) => u,\n+                None => return Some((range, name_ref, false)),\n+            };\n+            let initializer = matches!(\n+                initializer_expr,\n+                ast::Expr::CallExpr(_)\n+                    | ast::Expr::IndexExpr(_)\n+                    | ast::Expr::MethodCallExpr(_)\n+                    | ast::Expr::FieldExpr(_)\n+                    | ast::Expr::TryExpr(_)\n+                    | ast::Expr::RefExpr(_)\n+                    | ast::Expr::Literal(_)\n+                    | ast::Expr::TupleExpr(_)\n+                    | ast::Expr::ArrayExpr(_)\n+                    | ast::Expr::ParenExpr(_)\n+                    | ast::Expr::PathExpr(_)\n+                    | ast::Expr::BlockExpr(_)\n+                    | ast::Expr::EffectExpr(_),\n+            );\n+            let parent = matches!(\n+                usage_parent,\n+                ast::Expr::CallExpr(_)\n+                    | ast::Expr::TupleExpr(_)\n+                    | ast::Expr::ArrayExpr(_)\n+                    | ast::Expr::ParenExpr(_)\n+                    | ast::Expr::ForExpr(_)\n+                    | ast::Expr::WhileExpr(_)\n+                    | ast::Expr::BreakExpr(_)\n+                    | ast::Expr::ReturnExpr(_)\n+                    | ast::Expr::MatchExpr(_)\n+            );\n+            Some((range, name_ref, !(initializer || parent)))\n         })\n-        .collect::<Option<FxHashMap<_, Vec<_>>>>()?;\n+        .collect::<Option<Vec<_>>>()?;\n \n     let init_str = initializer_expr.syntax().text().to_string();\n     let init_in_paren = format!(\"({})\", &init_str);\n@@ -116,19 +119,13 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n             if let Some(range) = delete_range {\n                 builder.delete(range);\n             }\n-            for (file_id, references) in replace_usages {\n-                for (&should_wrap, reference) in wrap_in_parens[&file_id].iter().zip(references) {\n-                    let replacement =\n-                        if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n-                    match reference.name.as_name_ref() {\n-                        Some(name_ref)\n-                            if ast::RecordExprField::for_field_name(name_ref).is_some() =>\n-                        {\n-                            cov_mark::hit!(inline_field_shorthand);\n-                            builder.insert(reference.range.end(), format!(\": {}\", replacement));\n-                        }\n-                        _ => builder.replace(reference.range, replacement),\n-                    }\n+            for (range, name, should_wrap) in wrap_in_parens {\n+                let replacement = if should_wrap { &init_in_paren } else { &init_str };\n+                if ast::RecordExprField::for_field_name(&name).is_some() {\n+                    cov_mark::hit!(inline_field_shorthand);\n+                    builder.insert(range.end(), format!(\": {}\", replacement));\n+                } else {\n+                    builder.replace(range, replacement.clone())\n                 }\n             }\n         },\n@@ -139,7 +136,7 @@ struct InlineData {\n     let_stmt: ast::LetStmt,\n     delete_let: bool,\n     target: ast::NameOrNameRef,\n-    replace_usages: FxHashMap<FileId, Vec<FileReference>>,\n+    references: Vec<FileReference>,\n }\n \n fn inline_let(ctx: &AssistContext) -> Option<InlineData> {\n@@ -157,35 +154,32 @@ fn inline_let(ctx: &AssistContext) -> Option<InlineData> {\n         return None;\n     }\n \n-    let def = ctx.sema.to_def(&bind_pat)?;\n-    let def = Definition::Local(def);\n-    let usages = def.usages(&ctx.sema).all();\n-    if usages.is_empty() {\n-        cov_mark::hit!(test_not_applicable_if_variable_unused);\n-        return None;\n-    };\n-\n-    Some(InlineData {\n-        let_stmt,\n-        delete_let: true,\n-        target: ast::NameOrNameRef::Name(bind_pat.name()?),\n-        replace_usages: usages.references,\n-    })\n+    let local = ctx.sema.to_def(&bind_pat)?;\n+    let UsageSearchResult { mut references } = Definition::Local(local).usages(&ctx.sema).all();\n+    match references.remove(&ctx.frange.file_id) {\n+        Some(references) => Some(InlineData {\n+            let_stmt,\n+            delete_let: true,\n+            target: ast::NameOrNameRef::Name(bind_pat.name()?),\n+            references,\n+        }),\n+        None => {\n+            cov_mark::hit!(test_not_applicable_if_variable_unused);\n+            None\n+        }\n+    }\n }\n \n fn inline_usage(ctx: &AssistContext) -> Option<InlineData> {\n     let path_expr = ctx.find_node_at_offset::<ast::PathExpr>()?;\n     let path = path_expr.path()?;\n-    let name = match path.as_single_segment()?.kind()? {\n-        ast::PathSegmentKind::Name(name) => name,\n-        _ => return None,\n-    };\n+    let name = path.as_single_name_ref()?;\n \n     let local = match ctx.sema.resolve_path(&path)? {\n         PathResolution::Local(local) => local,\n         _ => return None,\n     };\n-    if local.is_mut(ctx.sema.db) {\n+    if local.is_mut(ctx.db()) {\n         cov_mark::hit!(test_not_inline_mut_variable_use);\n         return None;\n     }\n@@ -197,21 +191,12 @@ fn inline_usage(ctx: &AssistContext) -> Option<InlineData> {\n \n     let let_stmt = ast::LetStmt::cast(bind_pat.syntax().parent()?)?;\n \n-    let def = Definition::Local(local);\n-    let mut usages = def.usages(&ctx.sema).all();\n-\n-    let delete_let = usages.references.values().map(|v| v.len()).sum::<usize>() == 1;\n-\n-    for references in usages.references.values_mut() {\n-        references.retain(|reference| reference.name.as_name_ref() == Some(&name));\n-    }\n+    let UsageSearchResult { mut references } = Definition::Local(local).usages(&ctx.sema).all();\n+    let mut references = references.remove(&ctx.frange.file_id)?;\n+    let delete_let = references.len() == 1;\n+    references.retain(|fref| fref.name.as_name_ref() == Some(&name));\n \n-    Some(InlineData {\n-        let_stmt,\n-        delete_let,\n-        target: ast::NameOrNameRef::NameRef(name),\n-        replace_usages: usages.references,\n-    })\n+    Some(InlineData { let_stmt, delete_let, target: ast::NameOrNameRef::NameRef(name), references })\n }\n \n #[cfg(test)]"}]}