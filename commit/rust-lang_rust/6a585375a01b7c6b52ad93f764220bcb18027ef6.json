{"sha": "6a585375a01b7c6b52ad93f764220bcb18027ef6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNTg1Mzc1YTAxYjdjNmI1MmFkOTNmNzY0MjIwYmNiMTgwMjdlZjY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-30T01:50:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-05T20:55:10Z"}, "message": "std: Recreate a `collections` module\n\nAs with the previous commit with `librand`, this commit shuffles around some\n`collections` code. The new state of the world is similar to that of librand:\n\n* The libcollections crate now only depends on libcore and liballoc.\n* The standard library has a new module, `std::collections`. All functionality\n  of libcollections is reexported through this module.\n\nI would like to stress that this change is purely cosmetic. There are very few\nalterations to these primitives.\n\nThere are a number of notable points about the new organization:\n\n* std::{str, slice, string, vec} all moved to libcollections. There is no reason\n  that these primitives shouldn't be necessarily usable in a freestanding\n  context that has allocation. These are all reexported in their usual places in\n  the standard library.\n\n* The `hashmap`, and transitively the `lru_cache`, modules no longer reside in\n  `libcollections`, but rather in libstd. The reason for this is because the\n  `HashMap::new` contructor requires access to the OSRng for initially seeding\n  the hash map. Beyond this requirement, there is no reason that the hashmap\n  could not move to libcollections.\n\n  I do, however, have a plan to move the hash map to the collections module. The\n  `HashMap::new` function could be altered to require that the `H` hasher\n  parameter ascribe to the `Default` trait, allowing the entire `hashmap` module\n  to live in libcollections. The key idea would be that the default hasher would\n  be different in libstd. Something along the lines of:\n\n      // src/libstd/collections/mod.rs\n\n      pub type HashMap<K, V, H = RandomizedSipHasher> =\n            core_collections::HashMap<K, V, H>;\n\n  This is not possible today because you cannot invoke static methods through\n  type aliases. If we modified the compiler, however, to allow invocation of\n  static methods through type aliases, then this type definition would\n  essentially be switching the default hasher from `SipHasher` in libcollections\n  to a libstd-defined `RandomizedSipHasher` type. This type's `Default`\n  implementation would randomly seed the `SipHasher` instance, and otherwise\n  perform the same as `SipHasher`.\n\n  This future state doesn't seem incredibly far off, but until that time comes,\n  the hashmap module will live in libstd to not compromise on functionality.\n\n* In preparation for the hashmap moving to libcollections, the `hash` module has\n  moved from libstd to libcollections. A previously snapshotted commit enables a\n  distinct `Writer` trait to live in the `hash` module which `Hash`\n  implementations are now parameterized over.\n\n  Due to using a custom trait, the `SipHasher` implementation has lost its\n  specialized methods for writing integers. These can be re-added\n  backwards-compatibly in the future via default methods if necessary, but the\n  FNV hashing should satisfy much of the need for speedier hashing.\n\nA list of breaking changes:\n\n* HashMap::{get, get_mut} no longer fails with the key formatted into the error\n  message with `{:?}`, instead, a generic message is printed. With backtraces,\n  it should still be not-too-hard to track down errors.\n\n* The HashMap, HashSet, and LruCache types are now available through\n  std::collections instead of the collections crate.\n\n* Manual implementations of hash should be parameterized over `hash::Writer`\n  instead of just `Writer`.\n\n[breaking-change]", "tree": {"sha": "a797dd088b4bae373e358cc450286eb9a21fbe50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a797dd088b4bae373e358cc450286eb9a21fbe50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a585375a01b7c6b52ad93f764220bcb18027ef6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a585375a01b7c6b52ad93f764220bcb18027ef6", "html_url": "https://github.com/rust-lang/rust/commit/6a585375a01b7c6b52ad93f764220bcb18027ef6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a585375a01b7c6b52ad93f764220bcb18027ef6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d70a9b93d0dee15325cba1a6e29cbfc7ca483ef4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d70a9b93d0dee15325cba1a6e29cbfc7ca483ef4", "html_url": "https://github.com/rust-lang/rust/commit/d70a9b93d0dee15325cba1a6e29cbfc7ca483ef4"}], "stats": {"total": 770, "additions": 398, "deletions": 372}, "files": [{"sha": "cea9133e8351a34c920f2a0e1ea6d63c75645f13", "filename": "mk/crates.mk", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -60,36 +60,36 @@ DEPS_core :=\n DEPS_rlibc :=\n DEPS_alloc := core libc native:jemalloc\n DEPS_debug := std\n-DEPS_std := core rand libc alloc native:rustrt native:backtrace\n+DEPS_std := core rand libc alloc collections native:rustrt native:backtrace\n DEPS_graphviz := std\n DEPS_green := std native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std\n-DEPS_syntax := std term serialize collections log fmt_macros debug\n+DEPS_syntax := std term serialize log fmt_macros debug\n DEPS_rustc := syntax native:rustllvm flate arena serialize sync getopts \\\n-              collections time log graphviz debug\n-DEPS_rustdoc := rustc native:hoedown serialize sync getopts collections \\\n+              time log graphviz debug\n+DEPS_rustdoc := rustc native:hoedown serialize sync getopts \\\n                 test time debug\n DEPS_flate := std native:miniz\n-DEPS_arena := std collections\n+DEPS_arena := std\n DEPS_graphviz := std\n DEPS_glob := std\n-DEPS_serialize := std collections log\n-DEPS_term := std collections log\n+DEPS_serialize := std log\n+DEPS_term := std log\n DEPS_semver := std\n DEPS_uuid := std serialize\n DEPS_sync := std alloc\n DEPS_getopts := std\n-DEPS_collections := std debug\n+DEPS_collections := core alloc\n DEPS_fourcc := syntax std\n DEPS_hexfloat := syntax std\n DEPS_num := std\n-DEPS_test := std collections getopts serialize term time regex\n+DEPS_test := std getopts serialize term time regex\n DEPS_time := std serialize sync\n DEPS_rand := core\n-DEPS_url := std collections\n+DEPS_url := std\n DEPS_log := std sync\n-DEPS_regex := std collections\n+DEPS_regex := std\n DEPS_regex_macros = syntax std regex\n DEPS_fmt_macros = std\n \n@@ -105,6 +105,7 @@ ONLY_RLIB_libc := 1\n ONLY_RLIB_rlibc := 1\n ONLY_RLIB_alloc := 1\n ONLY_RLIB_rand := 1\n+ONLY_RLIB_collections := 1\n \n ################################################################################\n # You should not need to edit below this line"}, {"sha": "6cd3616fc711cc851fb7de0c6c0c23a6d347375d", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -10,14 +10,17 @@\n \n #![allow(missing_doc)]\n \n+use core::prelude::*;\n \n-use std::cmp;\n-use std::fmt;\n-use std::iter::RandomAccessIterator;\n-use std::iter::{Enumerate, Repeat, Map, Zip};\n-use std::ops;\n-use std::slice;\n-use std::uint;\n+use core::cmp;\n+use core::fmt;\n+use core::iter::{Enumerate, Repeat, Map, Zip};\n+use core::ops;\n+use core::slice;\n+use core::uint;\n+\n+use string::String;\n+use vec::Vec;\n \n #[deriving(Clone)]\n struct SmallBitv {"}, {"sha": "d589aa73a52591560b75823e39b39e58e249d297", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -18,8 +18,13 @@\n ///a length (the height of the tree), and lower and upper bounds on the\n ///number of elements that a given node can contain.\n \n-use std::fmt;\n-use std::fmt::Show;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::fmt;\n+use core::fmt::Show;\n+\n+use vec::Vec;\n \n #[allow(missing_doc)]\n pub struct BTree<K, V> {"}, {"sha": "b4930173bb664131d90b1883d5c688c3d6263ee1", "filename": "src/libcollections/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdeque.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -10,7 +10,7 @@\n \n //! Container traits for collections\n \n-use std::container::Mutable;\n+use core::prelude::*;\n \n /// A double-ended sequence that allows querying, insertion and deletion at both ends.\n pub trait Deque<T> : Mutable {"}, {"sha": "062e94d21c097a95220c0ba3719ee7fc89f9498e", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -21,9 +21,12 @@\n // Backlinks over DList::prev are raw pointers that form a full chain in\n // the reverse direction.\n \n-use std::iter;\n-use std::mem;\n-use std::ptr;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::iter;\n+use core::mem;\n+use core::ptr;\n \n use deque::Deque;\n "}, {"sha": "856aff64b6a22ede0e219461ea4bec9439d59238", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -13,7 +13,9 @@\n //! This module defines a container which uses an efficient bit mask\n //! representation to hold C-like enum variants.\n \n-use std::num::Bitwise;\n+use core::prelude::*;\n+\n+use core::num::Bitwise;\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n /// A specialized Set implementation to use enum types."}, {"sha": "067f266f63f0952d0f61bcd2da3fd8ec9098f58b", "filename": "src/libcollections/hash/mod.rs", "status": "renamed", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -63,22 +63,17 @@\n \n #![allow(unused_must_use)]\n \n-use container::Container;\n-use intrinsics::TypeId;\n-use iter::Iterator;\n-use option::{Option, Some, None};\n-use owned::Box;\n-use rc::Rc;\n-use result::{Result, Ok, Err};\n-use slice::{Vector, ImmutableVector};\n-use str::{Str, StrSlice};\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use alloc::rc::Rc;\n+use core::intrinsics::TypeId;\n+\n use vec::Vec;\n \n /// Reexport the `sip::hash` function as our default hasher.\n pub use hash = self::sip::hash;\n \n-pub use Writer = io::Writer;\n-\n pub mod sip;\n \n /// A trait that represents a hashable type. The `S` type parameter is an\n@@ -96,33 +91,29 @@ pub trait Hasher<S> {\n     fn hash<T: Hash<S>>(&self, value: &T) -> u64;\n }\n \n+pub trait Writer {\n+    fn write(&mut self, bytes: &[u8]);\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n \n macro_rules! impl_hash(\n-    ( $( $ty:ty => $method:ident;)* ) => (\n+    ( $($ty:ident)* ) => (\n         $(\n             impl<S: Writer> Hash<S> for $ty {\n                 #[inline]\n                 fn hash(&self, state: &mut S) {\n-                    state.$method(*self);\n+                    let a: [u8, ..::core::$ty::BYTES] = unsafe {\n+                        ::core::mem::transmute(*self)\n+                    };\n+                    state.write(a.as_slice())\n                 }\n             }\n         )*\n     )\n )\n \n-impl_hash!(\n-    u8 => write_u8;\n-    u16 => write_le_u16;\n-    u32 => write_le_u32;\n-    u64 => write_le_u64;\n-    uint => write_le_uint;\n-    i8 => write_i8;\n-    i16 => write_le_i16;\n-    i32 => write_le_i32;\n-    i64 => write_le_i64;\n-    int => write_le_int;\n-)\n+impl_hash!( u8 u16 u32 u64 uint i8 i16 i32 i64 int )\n \n impl<S: Writer> Hash<S> for bool {\n     #[inline]\n@@ -142,7 +133,7 @@ impl<'a, S: Writer> Hash<S> for &'a str {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         state.write(self.as_bytes());\n-        state.write_u8(0xFF);\n+        0xffu8.hash(state)\n     }\n }\n ", "previous_filename": "src/libstd/hash/mod.rs"}, {"sha": "039aee7347b638cf26b35b74e1143945e5f26a84", "filename": "src/libcollections/hash/sip.rs", "status": "renamed", "additions": 7, "deletions": 96, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -24,17 +24,11 @@\n  * discouraged.\n  */\n \n-use clone::Clone;\n-use container::Container;\n-use default::Default;\n-use int;\n-use io::{IoResult, Writer};\n-use iter::Iterator;\n-use result::Ok;\n-use slice::ImmutableVector;\n-use uint;\n-\n-use super::{Hash, Hasher};\n+use core::prelude::*;\n+\n+use core::default::Default;\n+\n+use super::{Hash, Hasher, Writer};\n \n /// `SipState` computes a SipHash 2-4 hash over a stream of bytes.\n pub struct SipState {\n@@ -151,41 +145,11 @@ impl SipState {\n \n         v0 ^ v1 ^ v2 ^ v3\n     }\n-\n-    #[inline]\n-    fn write_le(&mut self, n: u64, size: uint) {\n-        self.tail |= n << 8*self.ntail;\n-        self.ntail += size;\n-\n-        if self.ntail >= 8 {\n-            let m = self.tail;\n-\n-            self.v3 ^= m;\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            compress!(self.v0, self.v1, self.v2, self.v3);\n-            self.v0 ^= m;\n-\n-            self.ntail -= 8;\n-            if self.ntail == 0 {\n-                self.tail = 0;\n-            } else {\n-                self.tail = n >> 64 - 8*self.ntail;\n-            }\n-        }\n-    }\n }\n \n-macro_rules! make_write_le(\n-    ($this:expr, $n:expr, $size:expr) => ({\n-          $this.write_le($n as u64, $size);\n-          $this.length += $size;\n-          Ok(())\n-    })\n-)\n-\n impl Writer for SipState {\n     #[inline]\n-    fn write(&mut self, msg: &[u8]) -> IoResult<()> {\n+    fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n         self.length += length;\n \n@@ -196,7 +160,7 @@ impl Writer for SipState {\n             if length < needed {\n                 self.tail |= u8to64_le!(msg, 0, length) << 8*self.ntail;\n                 self.ntail += length;\n-                return Ok(());\n+                return\n             }\n \n             let m = self.tail | u8to64_le!(msg, 0, needed) << 8*self.ntail;\n@@ -228,60 +192,7 @@ impl Writer for SipState {\n \n         self.tail = u8to64_le!(msg, i, left);\n         self.ntail = left;\n-\n-        Ok(())\n-    }\n-\n-    #[inline]\n-    fn write_u8(&mut self, n: u8) -> IoResult<()> {\n-        make_write_le!(self, n, 1)\n-    }\n-\n-    #[inline]\n-    fn write_le_u16(&mut self, n: u16) -> IoResult<()> {\n-        make_write_le!(self, n, 2)\n     }\n-\n-    #[inline]\n-    fn write_le_u32(&mut self, n: u32) -> IoResult<()> {\n-        make_write_le!(self, n, 4)\n-    }\n-\n-    #[inline]\n-    fn write_le_u64(&mut self, n: u64) -> IoResult<()> {\n-        make_write_le!(self, n, 8)\n-    }\n-\n-    #[inline]\n-    fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n-        make_write_le!(self, n, uint::BYTES)\n-    }\n-\n-    #[inline]\n-    fn write_i8(&mut self, n: i8) -> IoResult<()> {\n-        make_write_le!(self, n, 1)\n-    }\n-\n-    #[inline]\n-    fn write_le_i16(&mut self, n: i16) -> IoResult<()> {\n-        make_write_le!(self, n, 2)\n-    }\n-\n-    #[inline]\n-    fn write_le_i32(&mut self, n: i32) -> IoResult<()> {\n-        make_write_le!(self, n, 4)\n-    }\n-\n-    #[inline]\n-    fn write_le_i64(&mut self, n: i64) -> IoResult<()> {\n-        make_write_le!(self, n, 8)\n-    }\n-\n-    #[inline]\n-    fn write_le_int(&mut self, n: int) -> IoResult<()> {\n-        make_write_le!(self, n, int::BYTES)\n-    }\n-\n }\n \n impl Clone for SipState {", "previous_filename": "src/libstd/hash/sip.rs"}, {"sha": "0ac26e686cd25c2da1c471d7e9f721a646873390", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -14,43 +14,66 @@\n \n #![crate_id = \"collections#0.11.0-pre\"]\n #![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n #![license = \"MIT/ASL2\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\")]\n \n-#![feature(macro_rules, managed_boxes, default_type_params, phase)]\n+#![feature(macro_rules, managed_boxes, default_type_params, phase, globs)]\n+#![no_std]\n \n-#![deny(deprecated_owned_vector)]\n-\n-extern crate debug;\n+#[phase(syntax, link)] extern crate core;\n+extern crate alloc;\n \n+#[cfg(test)] extern crate native;\n+#[cfg(test)] extern crate std;\n #[cfg(test)] extern crate test;\n #[cfg(test)] #[phase(syntax, link)] extern crate log;\n \n-pub use bitv::Bitv;\n+pub use bitv::{Bitv, BitvSet};\n pub use btree::BTree;\n pub use deque::Deque;\n pub use dlist::DList;\n pub use enum_set::EnumSet;\n-pub use hashmap::{HashMap, HashSet};\n-pub use lru_cache::LruCache;\n pub use priority_queue::PriorityQueue;\n pub use ringbuf::RingBuf;\n pub use smallintmap::SmallIntMap;\n pub use treemap::{TreeMap, TreeSet};\n pub use trie::{TrieMap, TrieSet};\n \n+mod macros;\n+\n pub mod bitv;\n pub mod btree;\n pub mod deque;\n pub mod dlist;\n pub mod enum_set;\n-pub mod hashmap;\n-pub mod lru_cache;\n pub mod priority_queue;\n pub mod ringbuf;\n pub mod smallintmap;\n pub mod treemap;\n pub mod trie;\n+pub mod slice;\n+pub mod str;\n+pub mod string;\n+pub mod vec;\n+pub mod hash;\n+\n+// Internal unicode fiddly bits for the str module\n+mod unicode;\n+\n+// FIXME(#14008) should this actually exist, or should a method be added?\n+fn expect<T>(a: core::option::Option<T>, b: &str) -> T {\n+    match a {\n+        core::option::Some(a) => a,\n+        core::option::None => fail!(b),\n+    }\n+}\n+\n+mod std {\n+    pub use core::fmt;      // necessary for fail!()\n+    pub use core::option;   // necessary for fail!()\n+    pub use core::clone;    // deriving(Clone)\n+    pub use core::cmp;      // deriving(Eq, Ord, etc.)\n+    pub use hash;           // deriving(Hash)\n+}"}, {"sha": "db062a70bbb677fdbe03199c9057145a694129e4", "filename": "src/libcollections/macros.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![macro_escape]\n+\n+/// Create a `std::vec::Vec` containing the arguments.\n+macro_rules! vec(\n+    ($($e:expr),*) => ({\n+        // leading _ to allow empty construction without a warning.\n+        let mut _temp = ::vec::Vec::new();\n+        $(_temp.push($e);)*\n+        _temp\n+    });\n+    ($($e:expr),+,) => (vec!($($e),+))\n+)"}, {"sha": "d40051faf13fa22379d5590039f3a85f4136aa56", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -12,10 +12,12 @@\n \n #![allow(missing_doc)]\n \n-use std::clone::Clone;\n-use std::mem::{zeroed, replace, swap};\n-use std::ptr;\n-use std::slice;\n+use core::prelude::*;\n+\n+use core::mem::{overwrite, zeroed, replace, swap};\n+\n+use slice;\n+use vec::Vec;\n \n /// A priority queue implemented with a binary heap\n #[deriving(Clone)]"}, {"sha": "713888cf473370bc34c914d77210e66f2724d9cb", "filename": "src/libcollections/ringbuf.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fringbuf.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -13,12 +13,14 @@\n //! RingBuf implements the trait Deque. It should be imported with `use\n //! collections::deque::Deque`.\n \n-use std::cmp;\n-use std::fmt;\n-use std::fmt::Show;\n-use std::iter::RandomAccessIterator;\n+use core::prelude::*;\n+\n+use core::cmp;\n+use core::fmt;\n+use core::iter::RandomAccessIterator;\n \n use deque::Deque;\n+use vec::Vec;\n \n static INITIAL_CAPACITY: uint = 8u; // 2^3\n static MINIMUM_CAPACITY: uint = 2u;\n@@ -393,7 +395,7 @@ impl<A> Extendable<A> for RingBuf<A> {\n     }\n }\n \n-impl<T: Show> Show for RingBuf<T> {\n+impl<T: fmt::Show> fmt::Show for RingBuf<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"[\"));\n "}, {"sha": "a724307a70ea6b411ed7533d994065e7bbc0b64b", "filename": "src/libcollections/slice.rs", "status": "renamed", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -99,20 +99,16 @@ There are a number of free functions that create or take vectors, for example:\n \n #![doc(primitive = \"slice\")]\n \n-use mem::transmute;\n-use clone::Clone;\n-use cmp::{Ord, Ordering, Less, Greater};\n-use cmp;\n-use container::Container;\n-use iter::*;\n-use mem::size_of;\n-use mem;\n-use ops::Drop;\n-use option::{None, Option, Some};\n-use ptr::RawPtr;\n-use ptr;\n-use rt::heap::{allocate, deallocate};\n-use finally::try_finally;\n+use core::prelude::*;\n+\n+use alloc::heap::{allocate, deallocate};\n+use core::cmp;\n+use core::finally::try_finally;\n+use core::mem::size_of;\n+use core::mem::transmute;\n+use core::mem;\n+use core::ptr;\n+use core::iter::{range_step, MultiplicativeIterator};\n use vec::Vec;\n \n pub use core::slice::{ref_slice, mut_ref_slice, Splits, Windows};\n@@ -295,13 +291,13 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n         use RawVec = core::raw::Vec;\n-        use num::{CheckedAdd, CheckedMul};\n+        use core::num::{CheckedAdd, CheckedMul};\n \n         let len = self.len();\n         let data_size = len.checked_mul(&mem::size_of::<T>());\n-        let data_size = data_size.expect(\"overflow in to_owned()\");\n+        let data_size = ::expect(data_size, \"overflow in to_owned()\");\n         let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n-        let size = size.expect(\"overflow in to_owned()\");\n+        let size = ::expect(size, \"overflow in to_owned()\");\n \n         unsafe {\n             // this should pass the real required alignment", "previous_filename": "src/libstd/slice.rs"}, {"sha": "c284a73d8bca64f374a7689f82a77d36f8cd8766", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -15,9 +15,13 @@\n \n #![allow(missing_doc)]\n \n-use std::iter::{Enumerate, FilterMap};\n-use std::mem::replace;\n-use std::{vec, slice};\n+use core::prelude::*;\n+\n+use core::iter::{Enumerate, FilterMap};\n+use core::mem::replace;\n+\n+use {vec, slice};\n+use vec::Vec;\n \n #[allow(missing_doc)]\n pub struct SmallIntMap<T> {\n@@ -118,7 +122,7 @@ impl<V> SmallIntMap<V> {\n     }\n \n     pub fn get<'a>(&'a self, key: &uint) -> &'a V {\n-        self.find(key).expect(\"key not present\")\n+        ::expect(self.find(key), \"key not present\")\n     }\n \n     /// An iterator visiting all key-value pairs in ascending order by the keys."}, {"sha": "144f14acdcd76707d3353c80567b80067e77cd8d", "filename": "src/libcollections/str.rs", "status": "renamed", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -67,21 +67,17 @@ is the same as `&[u8]`.\n \n #![doc(primitive = \"str\")]\n \n-use char::Char;\n-use char;\n-use clone::Clone;\n-use cmp::{PartialEq, Eq, PartialOrd, Ord, Equiv, Ordering};\n-use container::Container;\n-use default::Default;\n-use fmt;\n-use io::Writer;\n-use iter::{Iterator, range, AdditiveIterator};\n-use mem::transmute;\n-use mem;\n-use option::{None, Option, Some};\n-use result::Result;\n-use slice::Vector;\n-use slice::{ImmutableVector, MutableVector};\n+use core::prelude::*;\n+\n+use core::char;\n+use core::default::Default;\n+use core::fmt;\n+use core::cmp;\n+use core::iter::AdditiveIterator;\n+use core::mem;\n+\n+use hash;\n+use slice::CloneableVector;\n use string::String;\n use vec::Vec;\n \n@@ -201,9 +197,6 @@ Section: Iterators\n \n // Helper functions used for Unicode normalization\n fn canonical_sort(comb: &mut [(char, u8)]) {\n-    use iter::range;\n-    use tuple::Tuple2;\n-\n     let len = comb.len();\n     for i in range(0, len) {\n         let mut swapped = false;\n@@ -638,13 +631,10 @@ impl<'a> Default for MaybeOwned<'a> {\n     fn default() -> MaybeOwned<'a> { Slice(\"\") }\n }\n \n-impl<'a, H: Writer> ::hash::Hash<H> for MaybeOwned<'a> {\n+impl<'a, H: hash::Writer> hash::Hash<H> for MaybeOwned<'a> {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n-        match *self {\n-            Slice(s) => s.hash(hasher),\n-            Owned(ref s) => s.as_slice().hash(hasher),\n-        }\n+        self.as_slice().hash(hasher)\n     }\n }\n \n@@ -660,10 +650,10 @@ impl<'a> fmt::Show for MaybeOwned<'a> {\n \n /// Unsafe operations\n pub mod raw {\n-    use c_str::CString;\n-    use libc;\n-    use mem;\n-    use raw::Slice;\n+    use core::prelude::*;\n+    use core::mem;\n+    use core::raw::Slice;\n+\n     use string::String;\n     use vec::Vec;\n \n@@ -681,9 +671,16 @@ pub mod raw {\n     }\n \n     /// Create a Rust string from a null-terminated C string\n-    pub unsafe fn from_c_str(c_string: *libc::c_char) -> String {\n+    pub unsafe fn from_c_str(c_string: *i8) -> String {\n         let mut buf = String::new();\n-        buf.push_bytes(CString::new(c_string, false).as_bytes_no_nul());\n+        let mut len = 0;\n+        while *c_string.offset(len) != 0 {\n+            len += 1;\n+        }\n+        buf.push_bytes(mem::transmute(Slice {\n+            data: c_string,\n+            len: len as uint,\n+        }));\n         buf\n     }\n \n@@ -800,10 +797,8 @@ pub trait StrAllocating: Str {\n     #[deprecated = \"obsolete, use `to_string`\"]\n     #[inline]\n     fn to_owned(&self) -> String {\n-        use slice::Vector;\n-\n         unsafe {\n-            ::mem::transmute(Vec::from_slice(self.as_slice().as_bytes()))\n+            mem::transmute(Vec::from_slice(self.as_slice().as_bytes()))\n         }\n     }\n \n@@ -852,9 +847,9 @@ pub trait StrAllocating: Str {\n                 if sc == tc {\n                     *dcol.get_mut(j + 1) = current;\n                 } else {\n-                    *dcol.get_mut(j + 1) = ::cmp::min(current, next);\n-                    *dcol.get_mut(j + 1) = ::cmp::min(*dcol.get(j + 1),\n-                                                      *dcol.get(j)) + 1;\n+                    *dcol.get_mut(j + 1) = cmp::min(current, next);\n+                    *dcol.get_mut(j + 1) = cmp::min(*dcol.get(j + 1),\n+                                                    *dcol.get(j)) + 1;\n                 }\n \n                 current = next;", "previous_filename": "src/libstd/str.rs"}, {"sha": "764811e92c7638fcbd045e40b625f740da0ebee5", "filename": "src/libcollections/string.rs", "status": "renamed", "additions": 19, "deletions": 29, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -10,23 +10,17 @@\n \n //! An owned, growable string that enforces that its contents are valid UTF-8.\n \n-use c_vec::CVec;\n-use char::Char;\n-use cmp::Equiv;\n-use container::{Container, Mutable};\n-use default::Default;\n-use fmt;\n-use from_str::FromStr;\n-use io::Writer;\n-use iter::{Extendable, FromIterator, Iterator, range};\n-use mem;\n-use option::{None, Option, Some};\n-use ptr::RawPtr;\n-use ptr;\n-use result::{Result, Ok, Err};\n-use slice::Vector;\n-use str::{CharRange, Str, StrSlice, StrAllocating};\n+use core::prelude::*;\n+\n+use core::default::Default;\n+use core::fmt;\n+use core::mem;\n+use core::ptr;\n+use core::raw::Slice;\n+\n+use hash;\n use str;\n+use str::{CharRange, StrAllocating};\n use vec::Vec;\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -168,14 +162,17 @@ impl String {\n     #[inline]\n     pub fn push_char(&mut self, ch: char) {\n         let cur_len = self.len();\n-        unsafe {\n-            // This may use up to 4 bytes.\n-            self.vec.reserve_additional(4);\n+        // This may use up to 4 bytes.\n+        self.vec.reserve_additional(4);\n \n+        unsafe {\n             // Attempt to not use an intermediate buffer by just pushing bytes\n             // directly onto this string.\n-            let mut c_vector = CVec::new(self.vec.as_mut_ptr().offset(cur_len as int), 4);\n-            let used = ch.encode_utf8(c_vector.as_mut_slice());\n+            let slice = Slice {\n+                data: self.vec.as_ptr().offset(cur_len as int),\n+                len: 4,\n+            };\n+            let used = ch.encode_utf8(mem::transmute(slice));\n             self.vec.set_len(cur_len + used);\n         }\n     }\n@@ -340,7 +337,7 @@ impl fmt::Show for String {\n     }\n }\n \n-impl<H:Writer> ::hash::Hash<H> for String {\n+impl<H: hash::Writer> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         self.as_slice().hash(hasher)\n@@ -354,13 +351,6 @@ impl<'a, S: Str> Equiv<S> for String {\n     }\n }\n \n-impl FromStr for String {\n-    #[inline]\n-    fn from_str(s: &str) -> Option<String> {\n-        Some(s.to_string())\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     extern crate test;", "previous_filename": "src/libstd/string.rs"}, {"sha": "1fd9fce20898da59027dbe0745a83957f452c5ae", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -12,13 +12,17 @@\n //! trees. The only requirement for the types is that the key implements\n //! `Ord`.\n \n-use std::cmp::Ordering;\n-use std::fmt::Show;\n-use std::fmt;\n-use std::iter::Peekable;\n-use std::iter;\n-use std::mem::{replace, swap};\n-use std::ptr;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::fmt;\n+use core::fmt::Show;\n+use core::iter::Peekable;\n+use core::iter;\n+use core::mem::{replace, swap};\n+use core::ptr;\n+\n+use vec::Vec;\n \n // This is implemented as an AA tree, which is a simplified variation of\n // a red-black tree where red (horizontal) nodes can only be added"}, {"sha": "a70b466623f54865bd7827a8f8d6662a59a996d6", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -10,11 +10,15 @@\n \n //! Ordered containers with integer keys, implemented as radix tries (`TrieSet` and `TrieMap` types)\n \n-use std::mem::zeroed;\n-use std::mem;\n-use std::slice::{Items, MutItems};\n-use std::slice;\n-use std::uint;\n+use core::prelude::*;\n+\n+use alloc::owned::Box;\n+use core::mem::zeroed;\n+use core::mem;\n+use core::uint;\n+\n+use slice::{Items, MutItems};\n+use slice;\n \n // FIXME: #5244: need to manually update the TrieNode constructor\n static SHIFT: uint = 4;\n@@ -457,7 +461,7 @@ fn insert<T>(count: &mut uint, child: &mut Child<T>, key: uint, value: T,\n             *child = Internal(new);\n             return ret;\n         }\n-        _ => unreachable!()\n+        _ => fail!(\"unreachable code\"),\n     }\n }\n "}, {"sha": "440290164c37d2031a8b22f599513d488908d82b", "filename": "src/libcollections/unicode.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Funicode.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -13,11 +13,9 @@\n #![allow(missing_doc, non_uppercase_statics)]\n \n pub mod normalization {\n-    use option::{Some, None};\n-    use slice::ImmutableVector;\n+    use core::prelude::*;\n \n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n-        use cmp::{Equal, Less, Greater};\n         match r.bsearch(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }", "previous_filename": "src/libstd/unicode.rs"}, {"sha": "faa9db7c91903be655f3cc6e49d819e2c50393e8", "filename": "src/libcollections/vec.rs", "status": "renamed", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -10,25 +10,22 @@\n \n //! An owned, growable vector.\n \n-use RawVec = raw::Vec;\n-use clone::Clone;\n-use cmp::{PartialOrd, PartialEq, Ordering, Eq, Ord, max};\n-use container::{Container, Mutable};\n-use default::Default;\n-use fmt;\n-use iter::{DoubleEndedIterator, FromIterator, Extendable, Iterator, range};\n-use mem;\n-use num::{CheckedMul, CheckedAdd};\n-use num;\n-use ops::{Add, Drop};\n-use option::{None, Option, Some};\n-use ptr::RawPtr;\n-use ptr;\n-use raw::Slice;\n-use rt::heap::{allocate, reallocate, deallocate};\n-use slice::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n-use slice::{MutableOrdVector, OwnedVector, Vector};\n-use slice::{MutableVectorAllocating};\n+use core::prelude::*;\n+\n+use alloc::heap::{allocate, reallocate, deallocate};\n+use RawVec = core::raw::Vec;\n+use core::raw::Slice;\n+use core::cmp::max;\n+use core::default::Default;\n+use core::fmt;\n+use core::mem;\n+use core::num::{CheckedMul, CheckedAdd};\n+use core::num;\n+use core::ptr;\n+use core::uint;\n+\n+use slice::{MutableTotalOrdVector, OwnedVector, MutableVectorAllocating};\n+use slice::{Items, MutItems};\n \n /// An owned, growable vector.\n ///\n@@ -90,12 +87,12 @@ impl<T> Vec<T> {\n     /// ```\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n         if mem::size_of::<T>() == 0 {\n-            Vec { len: 0, cap: ::uint::MAX, ptr: 0 as *mut T }\n+            Vec { len: 0, cap: uint::MAX, ptr: 0 as *mut T }\n         } else if capacity == 0 {\n             Vec::new()\n         } else {\n-            let size = capacity.checked_mul(&mem::size_of::<T>())\n-                               .expect(\"capacity overflow\");\n+            let size = ::expect(capacity.checked_mul(&mem::size_of::<T>()),\n+                                \"capacity overflow\");\n             let ptr = unsafe { allocate(size, mem::min_align_of::<T>()) };\n             Vec { len: 0, cap: capacity, ptr: ptr as *mut T }\n         }\n@@ -503,8 +500,8 @@ impl<T> Vec<T> {\n         if mem::size_of::<T>() == 0 { return }\n \n         if capacity > self.cap {\n-            let size = capacity.checked_mul(&mem::size_of::<T>())\n-                               .expect(\"capacity overflow\");\n+            let size = ::expect(capacity.checked_mul(&mem::size_of::<T>()),\n+                                \"capacity overflow\");\n             unsafe {\n                 self.ptr = alloc_or_realloc(self.ptr, size,\n                                             self.cap * mem::size_of::<T>());\n@@ -583,7 +580,7 @@ impl<T> Vec<T> {\n     pub fn push(&mut self, value: T) {\n         if mem::size_of::<T>() == 0 {\n             // zero-size types consume no memory, so we can't rely on the address space running out\n-            self.len = self.len.checked_add(&1).expect(\"length overflow\");\n+            self.len = ::expect(self.len.checked_add(&1), \"length overflow\");\n             unsafe { mem::forget(value); }\n             return\n         }\n@@ -1530,9 +1527,9 @@ impl<T> FromVec<T> for ~[T] {\n     fn from_vec(mut v: Vec<T>) -> ~[T] {\n         let len = v.len();\n         let data_size = len.checked_mul(&mem::size_of::<T>());\n-        let data_size = data_size.expect(\"overflow in from_vec()\");\n+        let data_size = ::expect(data_size, \"overflow in from_vec()\");\n         let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n-        let size = size.expect(\"overflow in from_vec()\");\n+        let size = ::expect(size, \"overflow in from_vec()\");\n \n         // In a post-DST world, we can attempt to reuse the Vec allocation by calling\n         // shrink_to_fit() on it. That may involve a reallocation+memcpy, but that's no\n@@ -1563,7 +1560,7 @@ impl<T> FromVec<T> for ~[T] {\n /// Unsafe operations\n pub mod raw {\n     use super::Vec;\n-    use ptr;\n+    use core::ptr;\n \n     /// Constructs a vector from an unsafe pointer to a buffer.\n     ///", "previous_filename": "src/libstd/vec.rs"}, {"sha": "eef133181e1298352407f9da53ecbba7ad93c006", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -61,9 +61,7 @@\n //! types to reintroduce mutability:\n //!\n //! ```\n-//! extern crate collections;\n-//!\n-//! use collections::HashMap;\n+//! use std::collections::HashMap;\n //! use std::cell::RefCell;\n //! use std::rc::Rc;\n //!\n@@ -86,8 +84,6 @@\n //! to take `&self`.\n //!\n //! ```\n-//! extern crate collections;\n-//!\n //! use std::cell::RefCell;\n //!\n //! struct Graph {"}, {"sha": "2cce68d5f60f2c33198b153fbbfeff78f425eeef", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -31,12 +31,6 @@ pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;\n \n-macro_rules! write(\n-    ($dst:expr, $($arg:tt)*) => ({\n-        format_args!(|args| { $dst.write_fmt(args) }, $($arg)*)\n-    })\n-)\n-\n mod num;\n mod float;\n pub mod rt;"}, {"sha": "94901aff001c00b46d8d4af54b4adb77156408d0", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -54,7 +54,18 @@ macro_rules! assert(\n     );\n )\n \n+/// Runtime assertion, only without `--cfg ndebug`\n+#[macro_export]\n+macro_rules! debug_assert(\n+    ($(a:tt)*) => ({\n+        if cfg!(not(ndebug)) {\n+            assert!($($a)*);\n+        }\n+    })\n+)\n+\n /// Runtime assertion for equality, for details see std::macros\n+#[macro_export]\n macro_rules! assert_eq(\n     ($cond1:expr, $cond2:expr) => ({\n         let c1 = $cond1;\n@@ -65,6 +76,16 @@ macro_rules! assert_eq(\n     })\n )\n \n+/// Runtime assertion for equality, only without `--cfg ndebug`\n+#[macro_export]\n+macro_rules! debug_assert_eq(\n+    ($($a:tt)*) => ({\n+        if cfg!(not(ndebug)) {\n+            assert_eq!($($a)*);\n+        }\n+    })\n+)\n+\n /// Runtime assertion, disableable at compile time\n #[macro_export]\n macro_rules! debug_assert(\n@@ -86,3 +107,13 @@ macro_rules! vec( ($($e:expr),*) => ({\n \n #[cfg(test)]\n macro_rules! format( ($($arg:tt)*) => (format_args!(::fmt::format, $($arg)*)) )\n+\n+/// Write some formatted data into a stream.\n+///\n+/// Identical to the macro in `std::macros`\n+#[macro_export]\n+macro_rules! write(\n+    ($dst:expr, $($arg:tt)*) => ({\n+        format_args_method!($dst, write_fmt, $($arg)*)\n+    })\n+)"}, {"sha": "bcf6d139c3584dfc9a05de598d617cba049c7130", "filename": "src/libstd/collections/hashmap.rs", "status": "renamed", "additions": 55, "deletions": 46, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -10,40 +10,39 @@\n \n //! Unordered containers, implemented as hash-tables (`HashSet` and `HashMap` types)\n \n-use std::container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n-use std::clone::Clone;\n-use std::cmp::{PartialEq, Eq, Equiv, max};\n-use std::default::Default;\n-use std::fmt;\n-use std::fmt::Show;\n-use std::hash::{Hash, Hasher, sip};\n-use std::iter;\n-use std::iter::{Iterator, FromIterator, Extendable};\n-use std::iter::{FilterMap, Chain, Repeat, Zip};\n-use std::iter::{range, range_inclusive};\n-use std::mem::replace;\n-use std::num;\n-use std::option::{Option, Some, None};\n-use std::rand;\n-use std::rand::Rng;\n-use std::result::{Ok, Err};\n-use std::slice::ImmutableVector;\n+use clone::Clone;\n+use cmp::{max, Eq, Equiv, PartialEq};\n+use container::{Container, Mutable, Set, MutableSet, Map, MutableMap};\n+use default::Default;\n+use fmt::Show;\n+use fmt;\n+use hash::{Hash, Hasher, sip};\n+use iter::{Iterator, FilterMap, Chain, Repeat, Zip, Extendable};\n+use iter::{range, range_inclusive, FromIterator};\n+use iter;\n+use mem::replace;\n+use num;\n+use option::{Some, None, Option};\n+use rand::Rng;\n+use rand;\n+use result::{Ok, Err};\n \n mod table {\n-    use std::clone::Clone;\n-    use std::cmp;\n-    use std::cmp::PartialEq;\n-    use std::hash::{Hash, Hasher};\n-    use std::kinds::marker;\n-    use std::num::{CheckedMul, is_power_of_two};\n-    use std::option::{Option, Some, None};\n-    use std::prelude::Drop;\n-    use std::ptr;\n-    use std::ptr::RawPtr;\n-    use std::mem::{min_align_of, size_of};\n-    use std::intrinsics::{move_val_init, set_memory, transmute};\n-    use std::iter::{Iterator, range_step_inclusive};\n-    use std::rt::heap::{allocate, deallocate};\n+    use clone::Clone;\n+    use cmp;\n+    use hash::{Hash, Hasher};\n+    use iter::range_step_inclusive;\n+    use iter::{Iterator, range};\n+    use kinds::marker;\n+    use mem::{min_align_of, size_of};\n+    use mem::{overwrite, transmute};\n+    use num::{CheckedMul, is_power_of_two};\n+    use ops::Drop;\n+    use option::{Some, None, Option, Expect};\n+    use ptr::RawPtr;\n+    use ptr::set_memory;\n+    use ptr;\n+    use rt::heap::{allocate, deallocate};\n \n     static EMPTY_BUCKET: u64 = 0u64;\n \n@@ -217,12 +216,12 @@ mod table {\n         /// Does not initialize the buckets. The caller should ensure they,\n         /// at the very least, set every hash to EMPTY_BUCKET.\n         unsafe fn new_uninitialized(capacity: uint) -> RawTable<K, V> {\n-            let hashes_size =\n-                capacity.checked_mul(&size_of::<u64>()).expect(\"capacity overflow\");\n-            let keys_size   =\n-                capacity.checked_mul(&size_of::< K >()).expect(\"capacity overflow\");\n-            let vals_size   =\n-                capacity.checked_mul(&size_of::< V >()).expect(\"capacity overflow\");\n+            let hashes_size = capacity.checked_mul(&size_of::<u64>())\n+                                      .expect(\"capacity overflow\");\n+            let keys_size = capacity.checked_mul(&size_of::< K >())\n+                                    .expect(\"capacity overflow\");\n+            let vals_size = capacity.checked_mul(&size_of::< V >())\n+                                    .expect(\"capacity overflow\");\n \n             // Allocating hashmaps is a little tricky. We need to allocate three\n             // arrays, but since we know their sizes and alignments up front,\n@@ -339,8 +338,8 @@ mod table {\n             unsafe {\n                 debug_assert_eq!(*self.hashes.offset(idx), EMPTY_BUCKET);\n                 *self.hashes.offset(idx) = hash.inspect();\n-                move_val_init(&mut *self.keys.offset(idx), k);\n-                move_val_init(&mut *self.vals.offset(idx), v);\n+                overwrite(&mut *self.keys.offset(idx), k);\n+                overwrite(&mut *self.vals.offset(idx), v);\n             }\n \n             self.size += 1;\n@@ -519,8 +518,8 @@ mod table {\n                             let hash = idx.hash().inspect();\n                             let (k, v) = self.read(&idx);\n                             *new_ht.hashes.offset(i as int) = hash;\n-                            move_val_init(&mut *new_ht.keys.offset(i as int), (*k).clone());\n-                            move_val_init(&mut *new_ht.vals.offset(i as int), (*v).clone());\n+                            overwrite(&mut *new_ht.keys.offset(i as int), (*k).clone());\n+                            overwrite(&mut *new_ht.vals.offset(i as int), (*v).clone());\n                         }\n                     }\n                 }\n@@ -1037,6 +1036,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, sip::SipHasher> {\n         HashMap::with_capacity(INITIAL_CAPACITY)\n     }\n \n+    /// Creates an empty hash map with the given initial capacity.\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V, sip::SipHasher> {\n         let mut r = rand::task_rng();\n         let r0 = r.gen();\n@@ -1047,6 +1047,9 @@ impl<K: Hash + Eq, V> HashMap<K, V, sip::SipHasher> {\n }\n \n impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n+    /// Creates an empty hashmap which will use the given hasher to hash keys.\n+    ///\n+    /// The creates map has the default initial capacity.\n     pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n         HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n@@ -1326,15 +1329,15 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     pub fn get<'a>(&'a self, k: &K) -> &'a V {\n         match self.find(k) {\n             Some(v) => v,\n-            None => fail!(\"No entry found for key: {:?}\", k)\n+            None => fail!(\"no entry found for key\")\n         }\n     }\n \n     /// Retrieves a (mutable) value for the given key, failing if the key is not present.\n     pub fn get_mut<'a>(&'a mut self, k: &K) -> &'a mut V {\n         match self.find_mut(k) {\n             Some(v) => v,\n-            None => fail!(\"No entry found for key: {:?}\", k)\n+            None => fail!(\"no entry found for key\")\n         }\n     }\n \n@@ -1533,6 +1536,10 @@ impl<T: Hash + Eq> HashSet<T, sip::SipHasher> {\n }\n \n impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n+    /// Creates a new empty hash set which will use the given hasher to hash\n+    /// keys.\n+    ///\n+    /// The hash set is also created with the default initial capacity.\n     pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n         HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n@@ -1632,8 +1639,10 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Extendable<T> for HashSet<T, H>\n     }\n }\n \n-impl<T: Eq + Hash> Default for HashSet<T, sip::SipHasher> {\n-    fn default() -> HashSet<T> { HashSet::new() }\n+impl<T: TotalEq + Hash<S>, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n+    fn default() -> HashSet<T, H> {\n+        HashSet::with_hasher(Default::default())\n+    }\n }\n \n // `Repeat` is used to feed the filter closure an explicit capture", "previous_filename": "src/libcollections/hashmap.rs"}, {"sha": "09511316a67bc8094e494300fe5b6bfb6371196f", "filename": "src/libstd/collections/lru_cache.rs", "status": "renamed", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Fcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Fcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Flru_cache.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -37,13 +37,18 @@\n //! assert!(cache.get(&2).is_none());\n //! ```\n \n-use std::container::Container;\n-use std::hash::Hash;\n-use std::fmt;\n-use std::mem;\n-use std::ptr;\n-\n-use HashMap;\n+use cmp::{Eq, TotalEq};\n+use collections::HashMap;\n+use container::{Container, Mutable, MutableMap};\n+use fmt;\n+use hash::Hash;\n+use iter::{range, Iterator};\n+use mem;\n+use ops::Drop;\n+use option::{Some, None, Option};\n+use owned::Box;\n+use ptr;\n+use result::{Ok, Err};\n \n struct KeyRef<K> { k: *K }\n ", "previous_filename": "src/libcollections/lru_cache.rs"}, {"sha": "16a6a35d9d5f751970397317196a692ea911e03b", "filename": "src/libstd/collections/mod.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Collection types.\n+ */\n+\n+pub use core_collections::{Bitv, BitvSet, BTree, Deque, DList, EnumSet};\n+pub use core_collections::{PriorityQueue, RingBuf, SmallIntMap};\n+pub use core_collections::{TreeMap, TreeSet, TrieMap, TrieSet};\n+pub use core_collections::{bitv, btree, deque, dlist, enum_set};\n+pub use core_collections::{priority_queue, ringbuf, smallintmap, treemap, trie};\n+\n+pub use self::hashmap::{HashMap, HashSet};\n+pub use self::lru_cache::LruCache;\n+\n+pub mod hashmap;\n+pub mod lru_cache;"}, {"sha": "4394fb9d35556a77dc5fe3273ef0b97ea92a1caf", "filename": "src/libstd/from_str.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffrom_str.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -11,6 +11,8 @@\n //! The `FromStr` trait for types that can be created from strings\n \n use option::{Option, Some, None};\n+use string::String;\n+use str::StrAllocating;\n \n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n@@ -47,6 +49,13 @@ impl FromStr for bool {\n     }\n }\n \n+impl FromStr for String {\n+    #[inline]\n+    fn from_str(s: &str) -> Option<String> {\n+        Some(s.to_string())\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use prelude::*;"}, {"sha": "90d6677d61228024600bc3c579c84342cc96983a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -124,6 +124,7 @@ extern crate alloc;\n extern crate core;\n extern crate libc;\n extern crate core_rand = \"rand\";\n+extern crate core_collections = \"collections\";\n \n // Make std testable by not duplicating lang items. See #2912\n #[cfg(test)] extern crate realstd = \"std\";\n@@ -160,6 +161,12 @@ pub use core::option;\n pub use alloc::owned;\n pub use alloc::rc;\n \n+pub use core_collections::hash;\n+pub use core_collections::slice;\n+pub use core_collections::str;\n+pub use core_collections::string;\n+pub use core_collections::vec;\n+\n // Run tests with libgreen instead of libnative.\n //\n // FIXME: This egregiously hacks around starting the test runner in a different\n@@ -203,10 +210,6 @@ pub mod prelude;\n #[path = \"num/f32.rs\"]   pub mod f32;\n #[path = \"num/f64.rs\"]   pub mod f64;\n \n-pub mod slice;\n-pub mod vec;\n-pub mod str;\n-pub mod string;\n pub mod rand;\n \n pub mod ascii;\n@@ -218,7 +221,10 @@ pub mod gc;\n pub mod from_str;\n pub mod num;\n pub mod to_str;\n-pub mod hash;\n+\n+/* Common data structures */\n+\n+pub mod collections;\n \n /* Tasks and communication */\n \n@@ -242,10 +248,6 @@ pub mod cleanup;\n #[unstable]\n pub mod unstable;\n \n-/* For internal use, not exported */\n-\n-mod unicode;\n-\n // FIXME #7809: This shouldn't be pub, and it should be reexported under 'unstable'\n // but name resolution doesn't work without it being pub.\n #[unstable]"}, {"sha": "8dfb64194e7977d1b0809d5fcbe9cf96583e1e99", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -10,16 +10,17 @@\n \n //! POSIX file path handling\n \n-use container::Container;\n use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::{PartialEq, Eq};\n+use container::Container;\n use from_str::FromStr;\n+use hash;\n use io::Writer;\n use iter::{DoubleEndedIterator, AdditiveIterator, Extendable, Iterator, Map};\n use option::{Option, None, Some};\n-use str;\n use str::Str;\n+use str;\n use slice::{CloneableVector, Splits, Vector, VectorVector,\n             ImmutableEqVector, OwnedVector, ImmutableVector};\n use vec::Vec;\n@@ -105,7 +106,7 @@ impl<'a> ToCStr for &'a Path {\n     }\n }\n \n-impl<S: Writer> ::hash::Hash<S> for Path {\n+impl<S: hash::Writer> hash::Hash<S> for Path {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         self.repr.hash(state)"}, {"sha": "e53842ecd8faf741443369a0122d41b4719ab393", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a585375a01b7c6b52ad93f764220bcb18027ef6/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=6a585375a01b7c6b52ad93f764220bcb18027ef6", "patch": "@@ -16,6 +16,7 @@ use clone::Clone;\n use cmp::{PartialEq, Eq};\n use container::Container;\n use from_str::FromStr;\n+use hash;\n use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Iterator, Map};\n use mem;\n@@ -126,7 +127,7 @@ impl<'a> ToCStr for &'a Path {\n     }\n }\n \n-impl<S: Writer> ::hash::Hash<S> for Path {\n+impl<S: hash::Writer> hash::Hash<S> for Path {\n     #[cfg(not(test))]\n     #[inline]\n     fn hash(&self, state: &mut S) {"}]}