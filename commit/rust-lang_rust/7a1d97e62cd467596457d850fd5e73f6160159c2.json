{"sha": "7a1d97e62cd467596457d850fd5e73f6160159c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMWQ5N2U2MmNkNDY3NTk2NDU3ZDg1MGZkNWU3M2Y2MTYwMTU5YzI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-26T04:55:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-26T05:12:55Z"}, "message": "Enhance timers to create ports\n\nIn addition to being able to sleep the current task, timers should be able to\ncreate ports which get notified after a period of time.\n\nCloses #10014", "tree": {"sha": "db458c437467ccc81610a13ea48fe551ca3c57e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db458c437467ccc81610a13ea48fe551ca3c57e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a1d97e62cd467596457d850fd5e73f6160159c2", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a1d97e62cd467596457d850fd5e73f6160159c2", "html_url": "https://github.com/rust-lang/rust/commit/7a1d97e62cd467596457d850fd5e73f6160159c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a1d97e62cd467596457d850fd5e73f6160159c2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "baeed886aa64943ad48121cc3b57dabec12bc835", "url": "https://api.github.com/repos/rust-lang/rust/commits/baeed886aa64943ad48121cc3b57dabec12bc835", "html_url": "https://github.com/rust-lang/rust/commit/baeed886aa64943ad48121cc3b57dabec12bc835"}], "stats": {"total": 176, "additions": 170, "deletions": 6}, "files": [{"sha": "500cd91b3db96ce11c52f6330ed7c68cbbb09002", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 131, "deletions": 4, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d97e62cd467596457d850fd5e73f6160159c2/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d97e62cd467596457d850fd5e73f6160159c2/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=7a1d97e62cd467596457d850fd5e73f6160159c2", "patch": "@@ -8,6 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+\n+Synchronous Timers\n+\n+This module exposes the functionality to create timers, block the current task,\n+and create ports which will receive notifications after a period of time.\n+\n+# Example\n+\n+```rust\n+\n+use std::rt::io::Timer;\n+\n+let mut timer = Timer::new().unwrap();\n+timer.sleep(10); // block the task for awhile\n+\n+let timeout = timer.oneshot(10);\n+// do some work\n+timeout.recv(); // wait for the timeout to expire\n+\n+let periodic = timer.periodic(10);\n+loop {\n+    periodic.recv();\n+    // this loop is only executed once every 10ms\n+}\n+\n+```\n+\n+*/\n+\n+use comm::{Port, PortOne};\n use option::{Option, Some, None};\n use result::{Ok, Err};\n use rt::io::io_error;\n@@ -25,9 +56,9 @@ pub fn sleep(msecs: u64) {\n }\n \n impl Timer {\n-\n     /// Creates a new timer which can be used to put the current task to sleep\n-    /// for a number of milliseconds.\n+    /// for a number of milliseconds, or to possibly create channels which will\n+    /// get notified after an amount of time has passed.\n     pub fn new() -> Option<Timer> {\n         do with_local_io |io| {\n             match io.timer_init() {\n@@ -42,20 +73,116 @@ impl Timer {\n         }\n     }\n \n+    /// Blocks the current task for `msecs` milliseconds.\n+    ///\n+    /// Note that this function will cause any other ports for this timer to be\n+    /// invalidated (the other end will be closed).\n     pub fn sleep(&mut self, msecs: u64) {\n         self.obj.sleep(msecs);\n     }\n+\n+    /// Creates a oneshot port which will have a notification sent when `msecs`\n+    /// milliseconds has elapsed. This does *not* block the current task, but\n+    /// instead returns immediately.\n+    ///\n+    /// Note that this invalidates any previous port which has been created by\n+    /// this timer, and that the returned port will be invalidated once the\n+    /// timer is destroyed (when it falls out of scope).\n+    pub fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n+        self.obj.oneshot(msecs)\n+    }\n+\n+    /// Creates a port which will have a continuous stream of notifications\n+    /// being sent every `msecs` milliseconds. This does *not* block the\n+    /// current task, but instead returns immediately. The first notification\n+    /// will not be received immediately, but rather after `msec` milliseconds\n+    /// have passed.\n+    ///\n+    /// Note that this invalidates any previous port which has been created by\n+    /// this timer, and that the returned port will be invalidated once the\n+    /// timer is destroyed (when it falls out of scope).\n+    pub fn periodic(&mut self, msecs: u64) -> Port<()> {\n+        self.obj.period(msecs)\n+    }\n }\n \n #[cfg(test)]\n mod test {\n     use super::*;\n     use rt::test::*;\n+    use cell::Cell;\n+    use task;\n+\n     #[test]\n     fn test_io_timer_sleep_simple() {\n         do run_in_mt_newsched_task {\n-            let timer = Timer::new();\n-            do timer.map |mut t| { t.sleep(1) };\n+            let mut timer = Timer::new().unwrap();\n+            timer.sleep(1);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_io_timer_sleep_oneshot() {\n+        do run_in_mt_newsched_task {\n+            let mut timer = Timer::new().unwrap();\n+            timer.oneshot(1).recv();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_io_timer_sleep_oneshot_forget() {\n+        do run_in_mt_newsched_task {\n+            let mut timer = Timer::new().unwrap();\n+            timer.oneshot(100000000000);\n+        }\n+    }\n+\n+    #[test]\n+    fn oneshot_twice() {\n+        do run_in_mt_newsched_task {\n+            let mut timer = Timer::new().unwrap();\n+            let port1 = timer.oneshot(100000000000);\n+            let port = timer.oneshot(1);\n+            port.recv();\n+            let port1 = Cell::new(port1);\n+            let ret = do task::try {\n+                port1.take().recv();\n+            };\n+            assert!(ret.is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_io_timer_oneshot_then_sleep() {\n+        do run_in_mt_newsched_task {\n+            let mut timer = Timer::new().unwrap();\n+            let port = timer.oneshot(100000000000);\n+            timer.sleep(1); // this should invalidate the port\n+\n+            let port = Cell::new(port);\n+            let ret = do task::try {\n+                port.take().recv();\n+            };\n+            assert!(ret.is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_io_timer_sleep_periodic() {\n+        do run_in_mt_newsched_task {\n+            let mut timer = Timer::new().unwrap();\n+            let port = timer.periodic(1);\n+            port.recv();\n+            port.recv();\n+            port.recv();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_io_timer_sleep_periodic_forget() {\n+        do run_in_mt_newsched_task {\n+            let mut timer = Timer::new().unwrap();\n+            timer.periodic(100000000000);\n         }\n     }\n "}, {"sha": "366388063d4ef02c75268b4cc7851e2b1f41ca2b", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d97e62cd467596457d850fd5e73f6160159c2/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d97e62cd467596457d850fd5e73f6160159c2/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=7a1d97e62cd467596457d850fd5e73f6160159c2", "patch": "@@ -11,7 +11,7 @@\n use libc;\n use option::*;\n use result::*;\n-use comm::SharedChan;\n+use comm::{SharedChan, PortOne, Port};\n use libc::c_int;\n use c_str::CString;\n \n@@ -162,6 +162,8 @@ pub trait RtioUdpSocket : RtioSocket {\n \n pub trait RtioTimer {\n     fn sleep(&mut self, msecs: u64);\n+    fn oneshot(&mut self, msecs: u64) -> PortOne<()>;\n+    fn period(&mut self, msecs: u64) -> Port<()>;\n }\n \n pub trait RtioFileStream {"}, {"sha": "2f8dacc4339ffd9e40e0266d2a6c480a0442c03e", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7a1d97e62cd467596457d850fd5e73f6160159c2/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a1d97e62cd467596457d850fd5e73f6160159c2/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=7a1d97e62cd467596457d850fd5e73f6160159c2", "patch": "@@ -13,7 +13,7 @@ use cast::transmute;\n use cast;\n use cell::Cell;\n use clone::Clone;\n-use comm::{SendDeferred, SharedChan};\n+use comm::{SendDeferred, SharedChan, Port, PortOne, GenericChan};\n use libc::{c_int, c_uint, c_void, pid_t};\n use ops::Drop;\n use option::*;\n@@ -1468,6 +1468,41 @@ impl RtioTimer for UvTimer {\n             self_.watcher.stop();\n         }\n     }\n+\n+    fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n+        use comm::oneshot;\n+\n+        let (port, chan) = oneshot();\n+        let chan = Cell::new(chan);\n+        do self.home_for_io |self_| {\n+            let chan = Cell::new(chan.take());\n+            do self_.watcher.start(msecs, 0) |_, status| {\n+                assert!(status.is_none());\n+                assert!(!chan.is_empty());\n+                chan.take().send_deferred(());\n+            }\n+        }\n+\n+        return port;\n+    }\n+\n+    fn period(&mut self, msecs: u64) -> Port<()> {\n+        use comm::stream;\n+\n+        let (port, chan) = stream();\n+        let chan = Cell::new(chan);\n+        do self.home_for_io |self_| {\n+            let chan = Cell::new(chan.take());\n+            do self_.watcher.start(msecs, msecs) |_, status| {\n+                assert!(status.is_none());\n+                do chan.with_ref |chan| {\n+                    chan.send_deferred(());\n+                }\n+            }\n+        }\n+\n+        return port;\n+    }\n }\n \n pub struct UvFileStream {"}]}