{"sha": "763aaef670f7ac1e00003beec760188d9987173d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2M2FhZWY2NzBmN2FjMWUwMDAwM2JlZWM3NjAxODhkOTk4NzE3M2Q=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-07-11T07:49:22Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-07-16T08:03:28Z"}, "message": "Move `ty::Const` and `ty::ConstKind` into their own modules", "tree": {"sha": "f3f512b8cb94e1760472f5d15776ccb22a1e3bee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3f512b8cb94e1760472f5d15776ccb22a1e3bee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/763aaef670f7ac1e00003beec760188d9987173d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/763aaef670f7ac1e00003beec760188d9987173d", "html_url": "https://github.com/rust-lang/rust/commit/763aaef670f7ac1e00003beec760188d9987173d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/763aaef670f7ac1e00003beec760188d9987173d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c0e172f919e09e8d37dfa98e9b29855282cb672", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c0e172f919e09e8d37dfa98e9b29855282cb672", "html_url": "https://github.com/rust-lang/rust/commit/5c0e172f919e09e8d37dfa98e9b29855282cb672"}], "stats": {"total": 871, "additions": 445, "deletions": 426}, "files": [{"sha": "d861b9323677aa220d45d45d165cb0f75a2b667b", "filename": "src/librustc_middle/ty/consts.rs", "status": "modified", "additions": 192, "deletions": 100, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/763aaef670f7ac1e00003beec760188d9987173d/src%2Flibrustc_middle%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763aaef670f7ac1e00003beec760188d9987173d/src%2Flibrustc_middle%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fconsts.rs?ref=763aaef670f7ac1e00003beec760188d9987173d", "patch": "@@ -1,111 +1,203 @@\n-use crate::mir::interpret::truncate;\n-use rustc_target::abi::Size;\n-\n-#[derive(Copy, Clone)]\n-/// A type for representing any integer. Only used for printing.\n-// FIXME: Use this for the integer-tree representation needed for type level ints and\n-// const generics?\n-pub struct ConstInt {\n-    /// Number of bytes of the integer. Only 1, 2, 4, 8, 16 are legal values.\n-    size: u8,\n-    /// Whether the value is of a signed integer type.\n-    signed: bool,\n-    /// Whether the value is a `usize` or `isize` type.\n-    is_ptr_sized_integral: bool,\n-    /// Raw memory of the integer. All bytes beyond the `size` are unused and must be zero.\n-    raw: u128,\n+use crate::mir::interpret::ConstValue;\n+use crate::mir::interpret::{LitToConstInput, Scalar};\n+use crate::ty::subst::InternalSubsts;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{ParamEnv, ParamEnvAnd};\n+use rustc_errors::ErrorReported;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_macros::HashStable;\n+\n+mod int;\n+mod kind;\n+\n+pub use int::*;\n+pub use kind::*;\n+\n+/// Typed constant value.\n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+#[derive(HashStable)]\n+pub struct Const<'tcx> {\n+    pub ty: Ty<'tcx>,\n+\n+    pub val: ConstKind<'tcx>,\n }\n \n-impl ConstInt {\n-    pub fn new(raw: u128, size: Size, signed: bool, is_ptr_sized_integral: bool) -> Self {\n-        assert!(raw <= truncate(u128::MAX, size));\n-        Self { raw, size: size.bytes() as u8, signed, is_ptr_sized_integral }\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(Const<'_>, 48);\n+\n+impl<'tcx> Const<'tcx> {\n+    /// Literals and const generic parameters are eagerly converted to a constant, everything else\n+    /// becomes `Unevaluated`.\n+    pub fn from_anon_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx Self {\n+        Self::from_opt_const_arg_anon_const(tcx, ty::WithOptConstParam::unknown(def_id))\n     }\n-}\n \n-impl std::fmt::Debug for ConstInt {\n-    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        let Self { size, signed, raw, is_ptr_sized_integral } = *self;\n-        if signed {\n-            let bit_size = size * 8;\n-            let min = 1u128 << (bit_size - 1);\n-            let max = min - 1;\n-            if raw == min {\n-                match (size, is_ptr_sized_integral) {\n-                    (_, true) => write!(fmt, \"isize::MIN\"),\n-                    (1, _) => write!(fmt, \"i8::MIN\"),\n-                    (2, _) => write!(fmt, \"i16::MIN\"),\n-                    (4, _) => write!(fmt, \"i32::MIN\"),\n-                    (8, _) => write!(fmt, \"i64::MIN\"),\n-                    (16, _) => write!(fmt, \"i128::MIN\"),\n-                    _ => bug!(\"ConstInt 0x{:x} with size = {} and signed = {}\", raw, size, signed),\n-                }\n-            } else if raw == max {\n-                match (size, is_ptr_sized_integral) {\n-                    (_, true) => write!(fmt, \"isize::MAX\"),\n-                    (1, _) => write!(fmt, \"i8::MAX\"),\n-                    (2, _) => write!(fmt, \"i16::MAX\"),\n-                    (4, _) => write!(fmt, \"i32::MAX\"),\n-                    (8, _) => write!(fmt, \"i64::MAX\"),\n-                    (16, _) => write!(fmt, \"i128::MAX\"),\n-                    _ => bug!(\"ConstInt 0x{:x} with size = {} and signed = {}\", raw, size, signed),\n+    pub fn from_opt_const_arg_anon_const(\n+        tcx: TyCtxt<'tcx>,\n+        def: ty::WithOptConstParam<LocalDefId>,\n+    ) -> &'tcx Self {\n+        debug!(\"Const::from_anon_const(def={:?})\", def);\n+\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n+\n+        let body_id = match tcx.hir().get(hir_id) {\n+            hir::Node::AnonConst(ac) => ac.body,\n+            _ => span_bug!(\n+                tcx.def_span(def.did.to_def_id()),\n+                \"from_anon_const can only process anonymous constants\"\n+            ),\n+        };\n+\n+        let expr = &tcx.hir().body(body_id).value;\n+\n+        let ty = tcx.type_of(def.def_id_for_type_of());\n+\n+        let lit_input = match expr.kind {\n+            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n+            hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => match expr.kind {\n+                hir::ExprKind::Lit(ref lit) => {\n+                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n                 }\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+\n+        if let Some(lit_input) = lit_input {\n+            // If an error occurred, ignore that it's a literal and leave reporting the error up to\n+            // mir.\n+            if let Ok(c) = tcx.at(expr.span).lit_to_const(lit_input) {\n+                return c;\n             } else {\n-                match size {\n-                    1 => write!(fmt, \"{}\", raw as i8)?,\n-                    2 => write!(fmt, \"{}\", raw as i16)?,\n-                    4 => write!(fmt, \"{}\", raw as i32)?,\n-                    8 => write!(fmt, \"{}\", raw as i64)?,\n-                    16 => write!(fmt, \"{}\", raw as i128)?,\n-                    _ => bug!(\"ConstInt 0x{:x} with size = {} and signed = {}\", raw, size, signed),\n-                }\n-                if fmt.alternate() {\n-                    match (size, is_ptr_sized_integral) {\n-                        (_, true) => write!(fmt, \"_isize\")?,\n-                        (1, _) => write!(fmt, \"_i8\")?,\n-                        (2, _) => write!(fmt, \"_i16\")?,\n-                        (4, _) => write!(fmt, \"_i32\")?,\n-                        (8, _) => write!(fmt, \"_i64\")?,\n-                        (16, _) => write!(fmt, \"_i128\")?,\n-                        _ => bug!(),\n-                    }\n-                }\n-                Ok(())\n+                tcx.sess.delay_span_bug(expr.span, \"Const::from_anon_const: couldn't lit_to_const\");\n             }\n-        } else {\n-            let max = truncate(u128::MAX, Size::from_bytes(size));\n-            if raw == max {\n-                match (size, is_ptr_sized_integral) {\n-                    (_, true) => write!(fmt, \"usize::MAX\"),\n-                    (1, _) => write!(fmt, \"u8::MAX\"),\n-                    (2, _) => write!(fmt, \"u16::MAX\"),\n-                    (4, _) => write!(fmt, \"u32::MAX\"),\n-                    (8, _) => write!(fmt, \"u64::MAX\"),\n-                    (16, _) => write!(fmt, \"u128::MAX\"),\n-                    _ => bug!(\"ConstInt 0x{:x} with size = {} and signed = {}\", raw, size, signed),\n-                }\n-            } else {\n-                match size {\n-                    1 => write!(fmt, \"{}\", raw as u8)?,\n-                    2 => write!(fmt, \"{}\", raw as u16)?,\n-                    4 => write!(fmt, \"{}\", raw as u32)?,\n-                    8 => write!(fmt, \"{}\", raw as u64)?,\n-                    16 => write!(fmt, \"{}\", raw as u128)?,\n-                    _ => bug!(\"ConstInt 0x{:x} with size = {} and signed = {}\", raw, size, signed),\n-                }\n-                if fmt.alternate() {\n-                    match (size, is_ptr_sized_integral) {\n-                        (_, true) => write!(fmt, \"_usize\")?,\n-                        (1, _) => write!(fmt, \"_u8\")?,\n-                        (2, _) => write!(fmt, \"_u16\")?,\n-                        (4, _) => write!(fmt, \"_u32\")?,\n-                        (8, _) => write!(fmt, \"_u64\")?,\n-                        (16, _) => write!(fmt, \"_u128\")?,\n-                        _ => bug!(),\n-                    }\n-                }\n-                Ok(())\n+        }\n+\n+        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n+        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n+        let expr = match &expr.kind {\n+            hir::ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n+                block.expr.as_ref().unwrap()\n+            }\n+            _ => expr,\n+        };\n+\n+        use hir::{def::DefKind::ConstParam, def::Res, ExprKind, Path, QPath};\n+        let val = match expr.kind {\n+            ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n+                // Find the name and index of the const parameter by indexing the generics of\n+                // the parent item and construct a `ParamConst`.\n+                let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+                let item_id = tcx.hir().get_parent_node(hir_id);\n+                let item_def_id = tcx.hir().local_def_id(item_id);\n+                let generics = tcx.generics_of(item_def_id.to_def_id());\n+                let index =\n+                    generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id).to_def_id()];\n+                let name = tcx.hir().name(hir_id);\n+                ty::ConstKind::Param(ty::ParamConst::new(index, name))\n             }\n+            _ => ty::ConstKind::Unevaluated(\n+                def.to_global(),\n+                InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n+                None,\n+            ),\n+        };\n+\n+        tcx.mk_const(ty::Const { val, ty })\n+    }\n+\n+    #[inline]\n+    /// Interns the given value as a constant.\n+    pub fn from_value(tcx: TyCtxt<'tcx>, val: ConstValue<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n+        tcx.mk_const(Self { val: ConstKind::Value(val), ty })\n+    }\n+\n+    #[inline]\n+    /// Interns the given scalar as a constant.\n+    pub fn from_scalar(tcx: TyCtxt<'tcx>, val: Scalar, ty: Ty<'tcx>) -> &'tcx Self {\n+        Self::from_value(tcx, ConstValue::Scalar(val), ty)\n+    }\n+\n+    #[inline]\n+    /// Creates a constant with the given integer value and interns it.\n+    pub fn from_bits(tcx: TyCtxt<'tcx>, bits: u128, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> &'tcx Self {\n+        let size = tcx\n+            .layout_of(ty)\n+            .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n+            .size;\n+        Self::from_scalar(tcx, Scalar::from_uint(bits, size), ty.value)\n+    }\n+\n+    #[inline]\n+    /// Creates an interned zst constant.\n+    pub fn zero_sized(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n+        Self::from_scalar(tcx, Scalar::zst(), ty)\n+    }\n+\n+    #[inline]\n+    /// Creates an interned bool constant.\n+    pub fn from_bool(tcx: TyCtxt<'tcx>, v: bool) -> &'tcx Self {\n+        Self::from_bits(tcx, v as u128, ParamEnv::empty().and(tcx.types.bool))\n+    }\n+\n+    #[inline]\n+    /// Creates an interned usize constant.\n+    pub fn from_usize(tcx: TyCtxt<'tcx>, n: u64) -> &'tcx Self {\n+        Self::from_bits(tcx, n as u128, ParamEnv::empty().and(tcx.types.usize))\n+    }\n+\n+    #[inline]\n+    /// Attempts to evaluate the given constant to bits. Can fail to evaluate in the presence of\n+    /// generics (or erroneous code) or if the value can't be represented as bits (e.g. because it\n+    /// contains const generic parameters or pointers).\n+    pub fn try_eval_bits(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Option<u128> {\n+        assert_eq!(self.ty, ty);\n+        let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n+        // if `ty` does not depend on generic parameters, use an empty param_env\n+        self.val.eval(tcx, param_env).try_to_bits(size)\n+    }\n+\n+    #[inline]\n+    /// Tries to evaluate the constant if it is `Unevaluated`. If that doesn't succeed, return the\n+    /// unevaluated constant.\n+    pub fn eval(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> &Const<'tcx> {\n+        if let Some(val) = self.val.try_eval(tcx, param_env) {\n+            match val {\n+                Ok(val) => Const::from_value(tcx, val, self.ty),\n+                Err(ErrorReported) => tcx.const_error(self.ty),\n+            }\n+        } else {\n+            self\n         }\n     }\n+\n+    #[inline]\n+    pub fn try_eval_bool(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Option<bool> {\n+        self.val.eval(tcx, param_env).try_to_bool()\n+    }\n+\n+    #[inline]\n+    pub fn try_eval_usize(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Option<u64> {\n+        self.val.eval(tcx, param_env).try_to_machine_usize(tcx)\n+    }\n+\n+    #[inline]\n+    /// Panics if the value cannot be evaluated or doesn't contain a valid integer of the given type.\n+    pub fn eval_bits(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {\n+        self.try_eval_bits(tcx, param_env, ty)\n+            .unwrap_or_else(|| bug!(\"expected bits of {:#?}, got {:#?}\", ty, self))\n+    }\n+\n+    #[inline]\n+    /// Panics if the value cannot be evaluated or doesn't contain a valid `usize`.\n+    pub fn eval_usize(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> u64 {\n+        self.try_eval_usize(tcx, param_env)\n+            .unwrap_or_else(|| bug!(\"expected usize, got {:#?}\", self))\n+    }\n }"}, {"sha": "ced0429deab934736c835b16d8f14220815424cb", "filename": "src/librustc_middle/ty/consts/int.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/763aaef670f7ac1e00003beec760188d9987173d/src%2Flibrustc_middle%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763aaef670f7ac1e00003beec760188d9987173d/src%2Flibrustc_middle%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fconsts%2Fint.rs?ref=763aaef670f7ac1e00003beec760188d9987173d", "patch": "@@ -0,0 +1,111 @@\n+use crate::mir::interpret::truncate;\n+use rustc_target::abi::Size;\n+\n+#[derive(Copy, Clone)]\n+/// A type for representing any integer. Only used for printing.\n+// FIXME: Use this for the integer-tree representation needed for type level ints and\n+// const generics?\n+pub struct ConstInt {\n+    /// Number of bytes of the integer. Only 1, 2, 4, 8, 16 are legal values.\n+    size: u8,\n+    /// Whether the value is of a signed integer type.\n+    signed: bool,\n+    /// Whether the value is a `usize` or `isize` type.\n+    is_ptr_sized_integral: bool,\n+    /// Raw memory of the integer. All bytes beyond the `size` are unused and must be zero.\n+    raw: u128,\n+}\n+\n+impl ConstInt {\n+    pub fn new(raw: u128, size: Size, signed: bool, is_ptr_sized_integral: bool) -> Self {\n+        assert!(raw <= truncate(u128::MAX, size));\n+        Self { raw, size: size.bytes() as u8, signed, is_ptr_sized_integral }\n+    }\n+}\n+\n+impl std::fmt::Debug for ConstInt {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        let Self { size, signed, raw, is_ptr_sized_integral } = *self;\n+        if signed {\n+            let bit_size = size * 8;\n+            let min = 1u128 << (bit_size - 1);\n+            let max = min - 1;\n+            if raw == min {\n+                match (size, is_ptr_sized_integral) {\n+                    (_, true) => write!(fmt, \"isize::MIN\"),\n+                    (1, _) => write!(fmt, \"i8::MIN\"),\n+                    (2, _) => write!(fmt, \"i16::MIN\"),\n+                    (4, _) => write!(fmt, \"i32::MIN\"),\n+                    (8, _) => write!(fmt, \"i64::MIN\"),\n+                    (16, _) => write!(fmt, \"i128::MIN\"),\n+                    _ => bug!(\"ConstInt 0x{:x} with size = {} and signed = {}\", raw, size, signed),\n+                }\n+            } else if raw == max {\n+                match (size, is_ptr_sized_integral) {\n+                    (_, true) => write!(fmt, \"isize::MAX\"),\n+                    (1, _) => write!(fmt, \"i8::MAX\"),\n+                    (2, _) => write!(fmt, \"i16::MAX\"),\n+                    (4, _) => write!(fmt, \"i32::MAX\"),\n+                    (8, _) => write!(fmt, \"i64::MAX\"),\n+                    (16, _) => write!(fmt, \"i128::MAX\"),\n+                    _ => bug!(\"ConstInt 0x{:x} with size = {} and signed = {}\", raw, size, signed),\n+                }\n+            } else {\n+                match size {\n+                    1 => write!(fmt, \"{}\", raw as i8)?,\n+                    2 => write!(fmt, \"{}\", raw as i16)?,\n+                    4 => write!(fmt, \"{}\", raw as i32)?,\n+                    8 => write!(fmt, \"{}\", raw as i64)?,\n+                    16 => write!(fmt, \"{}\", raw as i128)?,\n+                    _ => bug!(\"ConstInt 0x{:x} with size = {} and signed = {}\", raw, size, signed),\n+                }\n+                if fmt.alternate() {\n+                    match (size, is_ptr_sized_integral) {\n+                        (_, true) => write!(fmt, \"_isize\")?,\n+                        (1, _) => write!(fmt, \"_i8\")?,\n+                        (2, _) => write!(fmt, \"_i16\")?,\n+                        (4, _) => write!(fmt, \"_i32\")?,\n+                        (8, _) => write!(fmt, \"_i64\")?,\n+                        (16, _) => write!(fmt, \"_i128\")?,\n+                        _ => bug!(),\n+                    }\n+                }\n+                Ok(())\n+            }\n+        } else {\n+            let max = truncate(u128::MAX, Size::from_bytes(size));\n+            if raw == max {\n+                match (size, is_ptr_sized_integral) {\n+                    (_, true) => write!(fmt, \"usize::MAX\"),\n+                    (1, _) => write!(fmt, \"u8::MAX\"),\n+                    (2, _) => write!(fmt, \"u16::MAX\"),\n+                    (4, _) => write!(fmt, \"u32::MAX\"),\n+                    (8, _) => write!(fmt, \"u64::MAX\"),\n+                    (16, _) => write!(fmt, \"u128::MAX\"),\n+                    _ => bug!(\"ConstInt 0x{:x} with size = {} and signed = {}\", raw, size, signed),\n+                }\n+            } else {\n+                match size {\n+                    1 => write!(fmt, \"{}\", raw as u8)?,\n+                    2 => write!(fmt, \"{}\", raw as u16)?,\n+                    4 => write!(fmt, \"{}\", raw as u32)?,\n+                    8 => write!(fmt, \"{}\", raw as u64)?,\n+                    16 => write!(fmt, \"{}\", raw as u128)?,\n+                    _ => bug!(\"ConstInt 0x{:x} with size = {} and signed = {}\", raw, size, signed),\n+                }\n+                if fmt.alternate() {\n+                    match (size, is_ptr_sized_integral) {\n+                        (_, true) => write!(fmt, \"_usize\")?,\n+                        (1, _) => write!(fmt, \"_u8\")?,\n+                        (2, _) => write!(fmt, \"_u16\")?,\n+                        (4, _) => write!(fmt, \"_u32\")?,\n+                        (8, _) => write!(fmt, \"_u64\")?,\n+                        (16, _) => write!(fmt, \"_u128\")?,\n+                        _ => bug!(),\n+                    }\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+}"}, {"sha": "d1deea4a90e398e3dec7fb79dca809f96100f597", "filename": "src/librustc_middle/ty/consts/kind.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/763aaef670f7ac1e00003beec760188d9987173d/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763aaef670f7ac1e00003beec760188d9987173d/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs?ref=763aaef670f7ac1e00003beec760188d9987173d", "patch": "@@ -0,0 +1,135 @@\n+use crate::mir::interpret::ConstValue;\n+use crate::mir::interpret::Scalar;\n+use crate::mir::Promoted;\n+use crate::ty::subst::{InternalSubsts, SubstsRef};\n+use crate::ty::ParamEnv;\n+use crate::ty::{self, TyCtxt, TypeFoldable};\n+use rustc_errors::ErrorReported;\n+use rustc_hir::def_id::DefId;\n+use rustc_macros::HashStable;\n+use rustc_target::abi::Size;\n+\n+/// Represents a constant in Rust.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(HashStable)]\n+pub enum ConstKind<'tcx> {\n+    /// A const generic parameter.\n+    Param(ty::ParamConst),\n+\n+    /// Infer the value of the const.\n+    Infer(InferConst<'tcx>),\n+\n+    /// Bound const variable, used only when preparing a trait query.\n+    Bound(ty::DebruijnIndex, ty::BoundVar),\n+\n+    /// A placeholder const - universally quantified higher-ranked const.\n+    Placeholder(ty::PlaceholderConst),\n+\n+    /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to one of the other\n+    /// variants when the code is monomorphic enough for that.\n+    Unevaluated(ty::WithOptConstParam<DefId>, SubstsRef<'tcx>, Option<Promoted>),\n+\n+    /// Used to hold computed value.\n+    Value(ConstValue<'tcx>),\n+\n+    /// A placeholder for a const which could not be computed; this is\n+    /// propagated to avoid useless error messages.\n+    Error(ty::sty::DelaySpanBugEmitted),\n+}\n+\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(ConstKind<'_>, 40);\n+\n+impl<'tcx> ConstKind<'tcx> {\n+    #[inline]\n+    pub fn try_to_value(self) -> Option<ConstValue<'tcx>> {\n+        if let ConstKind::Value(val) = self { Some(val) } else { None }\n+    }\n+\n+    #[inline]\n+    pub fn try_to_scalar(self) -> Option<Scalar> {\n+        self.try_to_value()?.try_to_scalar()\n+    }\n+\n+    #[inline]\n+    pub fn try_to_bits(self, size: Size) -> Option<u128> {\n+        self.try_to_value()?.try_to_bits(size)\n+    }\n+\n+    #[inline]\n+    pub fn try_to_bool(self) -> Option<bool> {\n+        self.try_to_value()?.try_to_bool()\n+    }\n+\n+    #[inline]\n+    pub fn try_to_machine_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n+        self.try_to_value()?.try_to_machine_usize(tcx)\n+    }\n+}\n+\n+/// An inference variable for a const, for use in const generics.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(HashStable)]\n+pub enum InferConst<'tcx> {\n+    /// Infer the value of the const.\n+    Var(ty::ConstVid<'tcx>),\n+    /// A fresh const variable. See `infer::freshen` for more details.\n+    Fresh(u32),\n+}\n+\n+impl<'tcx> ConstKind<'tcx> {\n+    #[inline]\n+    /// Tries to evaluate the constant if it is `Unevaluated`. If that doesn't succeed, return the\n+    /// unevaluated constant.\n+    pub fn eval(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Self {\n+        self.try_eval(tcx, param_env).and_then(Result::ok).map(ConstKind::Value).unwrap_or(self)\n+    }\n+\n+    #[inline]\n+    /// Tries to evaluate the constant if it is `Unevaluated`. If that isn't possible or necessary\n+    // return None\n+    pub fn try_eval(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> Option<Result<ConstValue<'tcx>, ErrorReported>> {\n+        if let ConstKind::Unevaluated(def, substs, promoted) = self {\n+            use crate::mir::interpret::ErrorHandled;\n+\n+            let param_env_and_substs = param_env.with_reveal_all().and(substs);\n+\n+            // HACK(eddyb) this erases lifetimes even though `const_eval_resolve`\n+            // also does later, but we want to do it before checking for\n+            // inference variables.\n+            let param_env_and_substs = tcx.erase_regions(&param_env_and_substs);\n+\n+            // HACK(eddyb) when the query key would contain inference variables,\n+            // attempt using identity substs and `ParamEnv` instead, that will succeed\n+            // when the expression doesn't depend on any parameters.\n+            // FIXME(eddyb, skinny121) pass `InferCtxt` into here when it's available, so that\n+            // we can call `infcx.const_eval_resolve` which handles inference variables.\n+            let param_env_and_substs = if param_env_and_substs.needs_infer() {\n+                tcx.param_env(def.did).and(InternalSubsts::identity_for_item(tcx, def.did))\n+            } else {\n+                param_env_and_substs\n+            };\n+\n+            // FIXME(eddyb) maybe the `const_eval_*` methods should take\n+            // `ty::ParamEnvAnd<SubstsRef>` instead of having them separate.\n+            let (param_env, substs) = param_env_and_substs.into_parts();\n+            // try to resolve e.g. associated constants to their definition on an impl, and then\n+            // evaluate the const.\n+            match tcx.const_eval_resolve(param_env, def, substs, promoted, None) {\n+                // NOTE(eddyb) `val` contains no lifetimes/types/consts,\n+                // and we use the original type, so nothing from `substs`\n+                // (which may be identity substs, see above),\n+                // can leak through `val` into the const we return.\n+                Ok(val) => Some(Ok(val)),\n+                Err(ErrorHandled::TooGeneric | ErrorHandled::Linted) => None,\n+                Err(ErrorHandled::Reported(e)) => Some(Err(e)),\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "b3cfcc0f4c2a8a031518adc2eb6651cdefd46fd8", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/763aaef670f7ac1e00003beec760188d9987173d/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763aaef670f7ac1e00003beec760188d9987173d/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=763aaef670f7ac1e00003beec760188d9987173d", "patch": "@@ -60,9 +60,9 @@ pub use self::sty::{Binder, BoundTy, BoundTyKind, BoundVar, DebruijnIndex, INNER\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::{CanonicalPolyFnSig, FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, TypeAndMut, UpvarSubsts};\n-pub use self::sty::{Const, ConstKind, ExistentialProjection, PolyExistentialProjection};\n pub use self::sty::{ConstVid, FloatVid, IntVid, RegionVid, TyVid};\n-pub use self::sty::{ExistentialPredicate, InferConst, InferTy, ParamConst, ParamTy, ProjectionTy};\n+pub use self::sty::{ExistentialPredicate, InferTy, ParamConst, ParamTy, ProjectionTy};\n+pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{PolyTraitRef, TraitRef, TyKind};\n pub use crate::ty::diagnostics::*;\n@@ -87,7 +87,7 @@ pub use self::trait_def::TraitDef;\n \n pub use self::query::queries;\n \n-pub use self::consts::ConstInt;\n+pub use self::consts::{Const, ConstInt, ConstKind, InferConst};\n \n pub mod adjustment;\n pub mod binding;"}, {"sha": "2f17db6223362229db7180ba80a4e98efd8787ca", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 323, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/763aaef670f7ac1e00003beec760188d9987173d/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763aaef670f7ac1e00003beec760188d9987173d/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=763aaef670f7ac1e00003beec760188d9987173d", "patch": "@@ -6,24 +6,20 @@ use self::InferTy::*;\n use self::TyKind::*;\n \n use crate::infer::canonical::Canonical;\n-use crate::mir::interpret::ConstValue;\n-use crate::mir::interpret::{LitToConstInput, Scalar};\n-use crate::mir::Promoted;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::{\n     self, AdtDef, DefIdTree, Discr, Ty, TyCtxt, TypeFlags, TypeFoldable, WithConstness,\n };\n-use crate::ty::{List, ParamEnv, ParamEnvAnd, TyS};\n+use crate::ty::{List, ParamEnv, TyS};\n use polonius_engine::Atom;\n use rustc_ast::ast;\n use rustc_data_structures::captures::Captures;\n-use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::DefId;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, Ident, Symbol};\n-use rustc_target::abi::{Size, VariantIdx};\n+use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi;\n use std::borrow::Cow;\n use std::cmp::Ordering;\n@@ -1122,7 +1118,7 @@ impl<'tcx> ParamConst {\n         ParamConst::new(def.index, def.name)\n     }\n \n-    pub fn to_const(self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx Const<'tcx> {\n+    pub fn to_const(self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n         tcx.mk_const_param(self.index, self.name, ty)\n     }\n }\n@@ -2193,318 +2189,3 @@ impl<'tcx> TyS<'tcx> {\n         tcx.layout_of(tcx.param_env(did).and(self)).map(|layout| layout.is_zst()).unwrap_or(false)\n     }\n }\n-\n-/// Typed constant value.\n-#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n-#[derive(HashStable)]\n-pub struct Const<'tcx> {\n-    pub ty: Ty<'tcx>,\n-\n-    pub val: ConstKind<'tcx>,\n-}\n-\n-#[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(Const<'_>, 48);\n-\n-impl<'tcx> Const<'tcx> {\n-    /// Literals and const generic parameters are eagerly converted to a constant, everything else\n-    /// becomes `Unevaluated`.\n-    pub fn from_anon_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx Self {\n-        Self::from_opt_const_arg_anon_const(tcx, ty::WithOptConstParam::unknown(def_id))\n-    }\n-\n-    pub fn from_opt_const_arg_anon_const(\n-        tcx: TyCtxt<'tcx>,\n-        def: ty::WithOptConstParam<LocalDefId>,\n-    ) -> &'tcx Self {\n-        debug!(\"Const::from_anon_const(def={:?})\", def);\n-\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n-\n-        let body_id = match tcx.hir().get(hir_id) {\n-            hir::Node::AnonConst(ac) => ac.body,\n-            _ => span_bug!(\n-                tcx.def_span(def.did.to_def_id()),\n-                \"from_anon_const can only process anonymous constants\"\n-            ),\n-        };\n-\n-        let expr = &tcx.hir().body(body_id).value;\n-\n-        let ty = tcx.type_of(def.def_id_for_type_of());\n-\n-        let lit_input = match expr.kind {\n-            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n-            hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => match expr.kind {\n-                hir::ExprKind::Lit(ref lit) => {\n-                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        };\n-\n-        if let Some(lit_input) = lit_input {\n-            // If an error occurred, ignore that it's a literal and leave reporting the error up to\n-            // mir.\n-            if let Ok(c) = tcx.at(expr.span).lit_to_const(lit_input) {\n-                return c;\n-            } else {\n-                tcx.sess.delay_span_bug(expr.span, \"Const::from_anon_const: couldn't lit_to_const\");\n-            }\n-        }\n-\n-        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n-        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n-        let expr = match &expr.kind {\n-            hir::ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n-                block.expr.as_ref().unwrap()\n-            }\n-            _ => expr,\n-        };\n-\n-        use hir::{def::DefKind::ConstParam, def::Res, ExprKind, Path, QPath};\n-        let val = match expr.kind {\n-            ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n-                // Find the name and index of the const parameter by indexing the generics of\n-                // the parent item and construct a `ParamConst`.\n-                let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n-                let item_id = tcx.hir().get_parent_node(hir_id);\n-                let item_def_id = tcx.hir().local_def_id(item_id);\n-                let generics = tcx.generics_of(item_def_id.to_def_id());\n-                let index =\n-                    generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id).to_def_id()];\n-                let name = tcx.hir().name(hir_id);\n-                ty::ConstKind::Param(ty::ParamConst::new(index, name))\n-            }\n-            _ => ty::ConstKind::Unevaluated(\n-                def.to_global(),\n-                InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n-                None,\n-            ),\n-        };\n-\n-        tcx.mk_const(ty::Const { val, ty })\n-    }\n-\n-    #[inline]\n-    /// Interns the given value as a constant.\n-    pub fn from_value(tcx: TyCtxt<'tcx>, val: ConstValue<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n-        tcx.mk_const(Self { val: ConstKind::Value(val), ty })\n-    }\n-\n-    #[inline]\n-    /// Interns the given scalar as a constant.\n-    pub fn from_scalar(tcx: TyCtxt<'tcx>, val: Scalar, ty: Ty<'tcx>) -> &'tcx Self {\n-        Self::from_value(tcx, ConstValue::Scalar(val), ty)\n-    }\n-\n-    #[inline]\n-    /// Creates a constant with the given integer value and interns it.\n-    pub fn from_bits(tcx: TyCtxt<'tcx>, bits: u128, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> &'tcx Self {\n-        let size = tcx\n-            .layout_of(ty)\n-            .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n-            .size;\n-        Self::from_scalar(tcx, Scalar::from_uint(bits, size), ty.value)\n-    }\n-\n-    #[inline]\n-    /// Creates an interned zst constant.\n-    pub fn zero_sized(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n-        Self::from_scalar(tcx, Scalar::zst(), ty)\n-    }\n-\n-    #[inline]\n-    /// Creates an interned bool constant.\n-    pub fn from_bool(tcx: TyCtxt<'tcx>, v: bool) -> &'tcx Self {\n-        Self::from_bits(tcx, v as u128, ParamEnv::empty().and(tcx.types.bool))\n-    }\n-\n-    #[inline]\n-    /// Creates an interned usize constant.\n-    pub fn from_usize(tcx: TyCtxt<'tcx>, n: u64) -> &'tcx Self {\n-        Self::from_bits(tcx, n as u128, ParamEnv::empty().and(tcx.types.usize))\n-    }\n-\n-    #[inline]\n-    /// Attempts to evaluate the given constant to bits. Can fail to evaluate in the presence of\n-    /// generics (or erroneous code) or if the value can't be represented as bits (e.g. because it\n-    /// contains const generic parameters or pointers).\n-    pub fn try_eval_bits(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> Option<u128> {\n-        assert_eq!(self.ty, ty);\n-        let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n-        // if `ty` does not depend on generic parameters, use an empty param_env\n-        self.val.eval(tcx, param_env).try_to_bits(size)\n-    }\n-\n-    #[inline]\n-    /// Tries to evaluate the constant if it is `Unevaluated`. If that doesn't succeed, return the\n-    /// unevaluated constant.\n-    pub fn eval(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> &Const<'tcx> {\n-        if let Some(val) = self.val.try_eval(tcx, param_env) {\n-            match val {\n-                Ok(val) => Const::from_value(tcx, val, self.ty),\n-                Err(ErrorReported) => tcx.const_error(self.ty),\n-            }\n-        } else {\n-            self\n-        }\n-    }\n-}\n-\n-impl<'tcx> ConstKind<'tcx> {\n-    #[inline]\n-    /// Tries to evaluate the constant if it is `Unevaluated`. If that doesn't succeed, return the\n-    /// unevaluated constant.\n-    pub fn eval(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Self {\n-        self.try_eval(tcx, param_env).and_then(Result::ok).map(ConstKind::Value).unwrap_or(self)\n-    }\n-\n-    #[inline]\n-    /// Tries to evaluate the constant if it is `Unevaluated`. If that isn't possible or necessary\n-    // return None\n-    pub fn try_eval(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ParamEnv<'tcx>,\n-    ) -> Option<Result<ConstValue<'tcx>, ErrorReported>> {\n-        if let ConstKind::Unevaluated(def, substs, promoted) = self {\n-            use crate::mir::interpret::ErrorHandled;\n-\n-            let param_env_and_substs = param_env.with_reveal_all().and(substs);\n-\n-            // HACK(eddyb) this erases lifetimes even though `const_eval_resolve`\n-            // also does later, but we want to do it before checking for\n-            // inference variables.\n-            let param_env_and_substs = tcx.erase_regions(&param_env_and_substs);\n-\n-            // HACK(eddyb) when the query key would contain inference variables,\n-            // attempt using identity substs and `ParamEnv` instead, that will succeed\n-            // when the expression doesn't depend on any parameters.\n-            // FIXME(eddyb, skinny121) pass `InferCtxt` into here when it's available, so that\n-            // we can call `infcx.const_eval_resolve` which handles inference variables.\n-            let param_env_and_substs = if param_env_and_substs.needs_infer() {\n-                tcx.param_env(def.did).and(InternalSubsts::identity_for_item(tcx, def.did))\n-            } else {\n-                param_env_and_substs\n-            };\n-\n-            // FIXME(eddyb) maybe the `const_eval_*` methods should take\n-            // `ty::ParamEnvAnd<SubstsRef>` instead of having them separate.\n-            let (param_env, substs) = param_env_and_substs.into_parts();\n-            // try to resolve e.g. associated constants to their definition on an impl, and then\n-            // evaluate the const.\n-            match tcx.const_eval_resolve(param_env, def, substs, promoted, None) {\n-                // NOTE(eddyb) `val` contains no lifetimes/types/consts,\n-                // and we use the original type, so nothing from `substs`\n-                // (which may be identity substs, see above),\n-                // can leak through `val` into the const we return.\n-                Ok(val) => Some(Ok(val)),\n-                Err(ErrorHandled::TooGeneric | ErrorHandled::Linted) => None,\n-                Err(ErrorHandled::Reported(e)) => Some(Err(e)),\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'tcx> Const<'tcx> {\n-    #[inline]\n-    pub fn try_eval_bool(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Option<bool> {\n-        self.val.eval(tcx, param_env).try_to_bool()\n-    }\n-\n-    #[inline]\n-    pub fn try_eval_usize(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Option<u64> {\n-        self.val.eval(tcx, param_env).try_to_machine_usize(tcx)\n-    }\n-\n-    #[inline]\n-    /// Panics if the value cannot be evaluated or doesn't contain a valid integer of the given type.\n-    pub fn eval_bits(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {\n-        self.try_eval_bits(tcx, param_env, ty)\n-            .unwrap_or_else(|| bug!(\"expected bits of {:#?}, got {:#?}\", ty, self))\n-    }\n-\n-    #[inline]\n-    /// Panics if the value cannot be evaluated or doesn't contain a valid `usize`.\n-    pub fn eval_usize(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> u64 {\n-        self.try_eval_usize(tcx, param_env)\n-            .unwrap_or_else(|| bug!(\"expected usize, got {:#?}\", self))\n-    }\n-}\n-\n-/// Represents a constant in Rust.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n-#[derive(HashStable)]\n-pub enum ConstKind<'tcx> {\n-    /// A const generic parameter.\n-    Param(ParamConst),\n-\n-    /// Infer the value of the const.\n-    Infer(InferConst<'tcx>),\n-\n-    /// Bound const variable, used only when preparing a trait query.\n-    Bound(DebruijnIndex, BoundVar),\n-\n-    /// A placeholder const - universally quantified higher-ranked const.\n-    Placeholder(ty::PlaceholderConst),\n-\n-    /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to one of the other\n-    /// variants when the code is monomorphic enough for that.\n-    Unevaluated(ty::WithOptConstParam<DefId>, SubstsRef<'tcx>, Option<Promoted>),\n-\n-    /// Used to hold computed value.\n-    Value(ConstValue<'tcx>),\n-\n-    /// A placeholder for a const which could not be computed; this is\n-    /// propagated to avoid useless error messages.\n-    Error(DelaySpanBugEmitted),\n-}\n-\n-#[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(ConstKind<'_>, 40);\n-\n-impl<'tcx> ConstKind<'tcx> {\n-    #[inline]\n-    pub fn try_to_value(self) -> Option<ConstValue<'tcx>> {\n-        if let ConstKind::Value(val) = self { Some(val) } else { None }\n-    }\n-\n-    #[inline]\n-    pub fn try_to_scalar(self) -> Option<Scalar> {\n-        self.try_to_value()?.try_to_scalar()\n-    }\n-\n-    #[inline]\n-    pub fn try_to_bits(self, size: Size) -> Option<u128> {\n-        self.try_to_value()?.try_to_bits(size)\n-    }\n-\n-    #[inline]\n-    pub fn try_to_bool(self) -> Option<bool> {\n-        self.try_to_value()?.try_to_bool()\n-    }\n-\n-    #[inline]\n-    pub fn try_to_machine_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n-        self.try_to_value()?.try_to_machine_usize(tcx)\n-    }\n-}\n-\n-/// An inference variable for a const, for use in const generics.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n-#[derive(HashStable)]\n-pub enum InferConst<'tcx> {\n-    /// Infer the value of the const.\n-    Var(ConstVid<'tcx>),\n-    /// A fresh const variable. See `infer::freshen` for more details.\n-    Fresh(u32),\n-}"}]}