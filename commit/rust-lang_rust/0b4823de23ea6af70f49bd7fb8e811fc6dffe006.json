{"sha": "0b4823de23ea6af70f49bd7fb8e811fc6dffe006", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNDgyM2RlMjNlYTZhZjcwZjQ5YmQ3ZmI4ZTgxMWZjNmRmZmUwMDY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-12T08:58:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-12T08:58:12Z"}, "message": "Rollup merge of #62108 - Zoxc:sharded-queries, r=oli-obk\n\nUse sharded maps for queries\n\nBased on https://github.com/rust-lang/rust/pull/61779.\n\nr? @Gankro", "tree": {"sha": "cdb58ebbf4ed23a2b7fb682e9c9f1a20981a9f9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdb58ebbf4ed23a2b7fb682e9c9f1a20981a9f9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b4823de23ea6af70f49bd7fb8e811fc6dffe006", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdUSokCRBK7hj4Ov3rIwAAdHIIAHtLNM9W6XClv6HYNk011Pnk\nf98gD6k0uLq2FT124jPEeJxis/spB8/Q3D56DawQ7XK4zIQWk9o4RRU+kgHRBPcM\npbjpJr1wA3obU9X5UaQ0LUSyTXZjxSK2TWevwxgVEhnvvbt/gJWXqSBcnVQ/n0s0\n0eVZe3EAqxOAT0sHTcN47vdjlD/OrN5Gz7/hYp7o7fUST7Krz9IriC5F14y7Z3J5\nNWfFfSU+1QkBx5Twhd8/IzFpCVK8k8i3fKyYawlr3xIfTNAx+3xWSPd9strC9fBB\nzIgYAFqiuMBrstNWAg/kveDmTinpoUb/WWlOsFruvbhFI6YM2+nEE7oyb00mv30=\n=unTJ\n-----END PGP SIGNATURE-----\n", "payload": "tree cdb58ebbf4ed23a2b7fb682e9c9f1a20981a9f9a\nparent 72f8043d44a8925e469daf5c10e2630c80c2a7d4\nparent f84967f1ae2a8c56faad2d9d882ae93b805abf70\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565600292 +0200\ncommitter GitHub <noreply@github.com> 1565600292 +0200\n\nRollup merge of #62108 - Zoxc:sharded-queries, r=oli-obk\n\nUse sharded maps for queries\n\nBased on https://github.com/rust-lang/rust/pull/61779.\n\nr? @Gankro\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4823de23ea6af70f49bd7fb8e811fc6dffe006", "html_url": "https://github.com/rust-lang/rust/commit/0b4823de23ea6af70f49bd7fb8e811fc6dffe006", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b4823de23ea6af70f49bd7fb8e811fc6dffe006/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72f8043d44a8925e469daf5c10e2630c80c2a7d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/72f8043d44a8925e469daf5c10e2630c80c2a7d4", "html_url": "https://github.com/rust-lang/rust/commit/72f8043d44a8925e469daf5c10e2630c80c2a7d4"}, {"sha": "f84967f1ae2a8c56faad2d9d882ae93b805abf70", "url": "https://api.github.com/repos/rust-lang/rust/commits/f84967f1ae2a8c56faad2d9d882ae93b805abf70", "html_url": "https://github.com/rust-lang/rust/commit/f84967f1ae2a8c56faad2d9d882ae93b805abf70"}], "stats": {"total": 54, "additions": 28, "deletions": 26}, "files": [{"sha": "91082c59ba05ae7a23501902fb66c52eccd71ed4", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b4823de23ea6af70f49bd7fb8e811fc6dffe006/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4823de23ea6af70f49bd7fb8e811fc6dffe006/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=0b4823de23ea6af70f49bd7fb8e811fc6dffe006", "patch": "@@ -11,7 +11,7 @@ use crate::util::profiling::ProfileCategory;\n use std::borrow::Cow;\n use std::hash::Hash;\n use std::fmt::Debug;\n-use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::fingerprint::Fingerprint;\n use crate::ich::StableHashingContext;\n \n@@ -34,7 +34,7 @@ pub(crate) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n     fn query(key: Self::Key) -> Query<'tcx>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_cache<'a>(tcx: TyCtxt<'tcx>) -> &'a Lock<QueryCache<'tcx, Self>>;\n+    fn query_cache<'a>(tcx: TyCtxt<'tcx>) -> &'a Sharded<QueryCache<'tcx, Self>>;\n \n     fn to_dep_node(tcx: TyCtxt<'tcx>, key: &Self::Key) -> DepNode;\n "}, {"sha": "00871a1cbf2a95bf9078d3fcf43d7eccc5845a41", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b4823de23ea6af70f49bd7fb8e811fc6dffe006/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4823de23ea6af70f49bd7fb8e811fc6dffe006/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=0b4823de23ea6af70f49bd7fb8e811fc6dffe006", "patch": "@@ -1062,9 +1062,9 @@ where\n         ::std::any::type_name::<Q>());\n \n     time_ext(tcx.sess.time_extended(), Some(tcx.sess), desc, || {\n-        let map = Q::query_cache(tcx).borrow();\n-        assert!(map.active.is_empty());\n-        for (key, entry) in map.results.iter() {\n+        let shards = Q::query_cache(tcx).lock_shards();\n+        assert!(shards.iter().all(|shard| shard.active.is_empty()));\n+        for (key, entry) in shards.iter().flat_map(|shard| shard.results.iter()) {\n             if Q::cache_on_disk(tcx, key.clone(), Some(&entry.value)) {\n                 let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n "}, {"sha": "4dce55f5892339cc41255bbe346440de1971535d", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0b4823de23ea6af70f49bd7fb8e811fc6dffe006/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4823de23ea6af70f49bd7fb8e811fc6dffe006/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=0b4823de23ea6af70f49bd7fb8e811fc6dffe006", "patch": "@@ -17,6 +17,7 @@ use errors::Diagnostic;\n use errors::FatalError;\n use rustc_data_structures::fx::{FxHashMap};\n use rustc_data_structures::sync::{Lrc, Lock};\n+use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::thin_vec::ThinVec;\n #[cfg(not(parallel_compiler))]\n use rustc_data_structures::cold_path;\n@@ -90,7 +91,7 @@ macro_rules! profq_query_msg {\n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n pub(super) struct JobOwner<'a, 'tcx, Q: QueryDescription<'tcx>> {\n-    cache: &'a Lock<QueryCache<'tcx, Q>>,\n+    cache: &'a Sharded<QueryCache<'tcx, Q>>,\n     key: Q::Key,\n     job: Lrc<QueryJob<'tcx>>,\n }\n@@ -107,7 +108,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n     pub(super) fn try_get(tcx: TyCtxt<'tcx>, span: Span, key: &Q::Key) -> TryGetJob<'a, 'tcx, Q> {\n         let cache = Q::query_cache(tcx);\n         loop {\n-            let mut lock = cache.borrow_mut();\n+            let mut lock = cache.get_shard_by_value(key).lock();\n             if let Some(value) = lock.results.get(key) {\n                 profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                 tcx.sess.profiler(|p| p.record_query_hit(Q::NAME));\n@@ -191,7 +192,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n \n         let value = QueryValue::new(result.clone(), dep_node_index);\n         {\n-            let mut lock = cache.borrow_mut();\n+            let mut lock = cache.get_shard_by_value(&key).lock();\n             lock.active.remove(&key);\n             lock.results.insert(key, value);\n         }\n@@ -215,7 +216,8 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n     #[cold]\n     fn drop(&mut self) {\n         // Poison the query so jobs waiting on it panic\n-        self.cache.borrow_mut().active.insert(self.key.clone(), QueryResult::Poisoned);\n+        let shard = self.cache.get_shard_by_value(&self.key);\n+        shard.lock().active.insert(self.key.clone(), QueryResult::Poisoned);\n         // Also signal the completion of the job, so waiters\n         // will continue execution\n         self.job.signal_complete();\n@@ -708,7 +710,7 @@ macro_rules! define_queries_inner {\n         use std::mem;\n         #[cfg(parallel_compiler)]\n         use ty::query::job::QueryResult;\n-        use rustc_data_structures::sync::Lock;\n+        use rustc_data_structures::sharded::Sharded;\n         use crate::{\n             rustc_data_structures::stable_hasher::HashStable,\n             rustc_data_structures::stable_hasher::StableHasherResult,\n@@ -740,18 +742,17 @@ macro_rules! define_queries_inner {\n             pub fn collect_active_jobs(&self) -> Vec<Lrc<QueryJob<$tcx>>> {\n                 let mut jobs = Vec::new();\n \n-                // We use try_lock here since we are only called from the\n+                // We use try_lock_shards here since we are only called from the\n                 // deadlock handler, and this shouldn't be locked.\n                 $(\n-                    jobs.extend(\n-                        self.$name.try_lock().unwrap().active.values().filter_map(|v|\n-                            if let QueryResult::Started(ref job) = *v {\n-                                Some(job.clone())\n-                            } else {\n-                                None\n-                            }\n-                        )\n-                    );\n+                    let shards = self.$name.try_lock_shards().unwrap();\n+                    jobs.extend(shards.iter().flat_map(|shard| shard.active.values().filter_map(|v|\n+                        if let QueryResult::Started(ref job) = *v {\n+                            Some(job.clone())\n+                        } else {\n+                            None\n+                        }\n+                    )));\n                 )*\n \n                 jobs\n@@ -773,26 +774,27 @@ macro_rules! define_queries_inner {\n \n                 fn stats<'tcx, Q: QueryConfig<'tcx>>(\n                     name: &'static str,\n-                    map: &QueryCache<'tcx, Q>\n+                    map: &Sharded<QueryCache<'tcx, Q>>,\n                 ) -> QueryStats {\n+                    let map = map.lock_shards();\n                     QueryStats {\n                         name,\n                         #[cfg(debug_assertions)]\n-                        cache_hits: map.cache_hits,\n+                        cache_hits: map.iter().map(|shard| shard.cache_hits).sum(),\n                         #[cfg(not(debug_assertions))]\n                         cache_hits: 0,\n                         key_size: mem::size_of::<Q::Key>(),\n                         key_type: type_name::<Q::Key>(),\n                         value_size: mem::size_of::<Q::Value>(),\n                         value_type: type_name::<Q::Value>(),\n-                        entry_count: map.results.len(),\n+                        entry_count: map.iter().map(|shard| shard.results.len()).sum(),\n                     }\n                 }\n \n                 $(\n                     queries.push(stats::<queries::$name<'_>>(\n                         stringify!($name),\n-                        &*self.$name.lock()\n+                        &self.$name,\n                     ));\n                 )*\n \n@@ -967,7 +969,7 @@ macro_rules! define_queries_inner {\n             }\n \n             #[inline(always)]\n-            fn query_cache<'a>(tcx: TyCtxt<$tcx>) -> &'a Lock<QueryCache<$tcx, Self>> {\n+            fn query_cache<'a>(tcx: TyCtxt<$tcx>) -> &'a Sharded<QueryCache<$tcx, Self>> {\n                 &tcx.queries.$name\n             }\n \n@@ -1099,7 +1101,7 @@ macro_rules! define_queries_struct {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n             fallback_extern_providers: Box<Providers<$tcx>>,\n \n-            $($(#[$attr])*  $name: Lock<QueryCache<$tcx, queries::$name<$tcx>>>,)*\n+            $($(#[$attr])*  $name: Sharded<QueryCache<$tcx, queries::$name<$tcx>>>,)*\n         }\n     };\n }"}]}