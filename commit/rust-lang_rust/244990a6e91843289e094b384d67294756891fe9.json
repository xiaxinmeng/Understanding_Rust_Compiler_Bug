{"sha": "244990a6e91843289e094b384d67294756891fe9", "node_id": "C_kwDOAAsO6NoAKDI0NDk5MGE2ZTkxODQzMjg5ZTA5NGIzODRkNjcyOTQ3NTY4OTFmZTk", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-06T12:24:57Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-06T14:45:58Z"}, "message": "`rustc_attr` remove `ref` patterns\n\n...and some if-let-elses too :P", "tree": {"sha": "39f76d392fa3f37b673b11abeea2fd5648a201a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39f76d392fa3f37b673b11abeea2fd5648a201a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/244990a6e91843289e094b384d67294756891fe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/244990a6e91843289e094b384d67294756891fe9", "html_url": "https://github.com/rust-lang/rust/commit/244990a6e91843289e094b384d67294756891fe9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/244990a6e91843289e094b384d67294756891fe9/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c75817fb1bba30e915fc856b21a571d01411ac45", "url": "https://api.github.com/repos/rust-lang/rust/commits/c75817fb1bba30e915fc856b21a571d01411ac45", "html_url": "https://github.com/rust-lang/rust/commit/c75817fb1bba30e915fc856b21a571d01411ac45"}], "stats": {"total": 134, "additions": 69, "deletions": 65}, "files": [{"sha": "ab5e19050ead2ffbb0a0d475c69d985ec86fb588", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 69, "deletions": 65, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/244990a6e91843289e094b384d67294756891fe9/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/244990a6e91843289e094b384d67294756891fe9/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=244990a6e91843289e094b384d67294756891fe9", "patch": "@@ -277,8 +277,7 @@ where\n             allowed_through_unstable_modules = true;\n         }\n         // attributes with data\n-        else if let Some(MetaItem { kind: MetaItemKind::List(ref metas), .. }) = meta {\n-            let meta = meta.as_ref().unwrap();\n+        else if let Some(meta @ MetaItem { kind: MetaItemKind::List(metas), .. }) = &meta {\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(\n@@ -533,25 +532,24 @@ where\n \n     // Merge the const-unstable info into the stability info\n     if promotable {\n-        if let Some((ref mut stab, _)) = const_stab {\n-            stab.promotable = promotable;\n-        } else {\n-            sess.emit_err(session_diagnostics::RustcPromotablePairing { span: item_sp });\n+        match &mut const_stab {\n+            Some((stab, _)) => stab.promotable = promotable,\n+            _ => _ = sess.emit_err(session_diagnostics::RustcPromotablePairing { span: item_sp }),\n         }\n     }\n \n     if allowed_through_unstable_modules {\n-        if let Some((\n-            Stability {\n-                level: StabilityLevel::Stable { ref mut allowed_through_unstable_modules, .. },\n-                ..\n-            },\n-            _,\n-        )) = stab\n-        {\n-            *allowed_through_unstable_modules = true;\n-        } else {\n-            sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+        match &mut stab {\n+            Some((\n+                Stability {\n+                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n+                    ..\n+                },\n+                _,\n+            )) => *allowed_through_unstable_modules = true,\n+            _ => {\n+                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+            }\n         }\n     }\n \n@@ -654,8 +652,8 @@ pub fn eval_condition(\n     features: Option<&Features>,\n     eval: &mut impl FnMut(Condition) -> bool,\n ) -> bool {\n-    match cfg.kind {\n-        ast::MetaItemKind::List(ref mis) if cfg.name_or_empty() == sym::version => {\n+    match &cfg.kind {\n+        ast::MetaItemKind::List(mis) if cfg.name_or_empty() == sym::version => {\n             try_gate_cfg(sym::version, cfg.span, sess, features);\n             let (min_version, span) = match &mis[..] {\n                 [NestedMetaItem::Lit(MetaItemLit { kind: LitKind::Str(sym, ..), span, .. })] => {\n@@ -688,7 +686,7 @@ pub fn eval_condition(\n                 rustc_version >= min_version\n             }\n         }\n-        ast::MetaItemKind::List(ref mis) => {\n+        ast::MetaItemKind::List(mis) => {\n             for mi in mis.iter() {\n                 if !mi.is_meta_item() {\n                     handle_errors(\n@@ -759,7 +757,7 @@ pub fn eval_condition(\n             sess.emit_err(session_diagnostics::CfgPredicateIdentifier { span: cfg.path.span });\n             true\n         }\n-        MetaItemKind::NameValue(ref lit) if !lit.kind.is_str() => {\n+        MetaItemKind::NameValue(lit) if !lit.kind.is_str() => {\n             handle_errors(\n                 sess,\n                 lit.span,\n@@ -1036,52 +1034,58 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                     });\n                 }\n             } else if let Some(meta_item) = item.meta_item() {\n-                if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n-                    if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n-                        let name = meta_item.name_or_empty().to_ident_string();\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::IncorrectReprFormatGeneric {\n-                            span: item.span(),\n-                            repr_arg: &name,\n-                            cause: IncorrectReprFormatGenericCause::from_lit_kind(\n-                                item.span(),\n-                                &value.kind,\n-                                &name,\n-                            ),\n-                        });\n-                    } else if matches!(\n-                        meta_item.name_or_empty(),\n-                        sym::C | sym::simd | sym::transparent\n-                    ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                    {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n-                            span: meta_item.span,\n-                            name: meta_item.name_or_empty().to_ident_string(),\n-                        });\n+                match &meta_item.kind {\n+                    MetaItemKind::NameValue(value) => {\n+                        if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n+                            let name = meta_item.name_or_empty().to_ident_string();\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::IncorrectReprFormatGeneric {\n+                                span: item.span(),\n+                                repr_arg: &name,\n+                                cause: IncorrectReprFormatGenericCause::from_lit_kind(\n+                                    item.span(),\n+                                    &value.kind,\n+                                    &name,\n+                                ),\n+                            });\n+                        } else if matches!(\n+                            meta_item.name_or_empty(),\n+                            sym::C | sym::simd | sym::transparent\n+                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                        {\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n+                                span: meta_item.span,\n+                                name: meta_item.name_or_empty().to_ident_string(),\n+                            });\n+                        }\n                     }\n-                } else if let MetaItemKind::List(_) = meta_item.kind {\n-                    if meta_item.has_name(sym::align) {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::IncorrectReprFormatAlignOneArg {\n-                            span: meta_item.span,\n-                        });\n-                    } else if meta_item.has_name(sym::packed) {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::IncorrectReprFormatPackedOneOrZeroArg {\n-                            span: meta_item.span,\n-                        });\n-                    } else if matches!(\n-                        meta_item.name_or_empty(),\n-                        sym::C | sym::simd | sym::transparent\n-                    ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                    {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n-                            span: meta_item.span,\n-                            name: meta_item.name_or_empty().to_ident_string(),\n-                        });\n+                    MetaItemKind::List(_) => {\n+                        if meta_item.has_name(sym::align) {\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::IncorrectReprFormatAlignOneArg {\n+                                span: meta_item.span,\n+                            });\n+                        } else if meta_item.has_name(sym::packed) {\n+                            recognised = true;\n+                            sess.emit_err(\n+                                session_diagnostics::IncorrectReprFormatPackedOneOrZeroArg {\n+                                    span: meta_item.span,\n+                                },\n+                            );\n+                        } else if matches!(\n+                            meta_item.name_or_empty(),\n+                            sym::C | sym::simd | sym::transparent\n+                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                        {\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n+                                span: meta_item.span,\n+                                name: meta_item.name_or_empty().to_ident_string(),\n+                            });\n+                        }\n                     }\n+                    _ => (),\n                 }\n             }\n             if !recognised {"}]}