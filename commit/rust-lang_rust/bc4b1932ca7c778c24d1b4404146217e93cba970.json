{"sha": "bc4b1932ca7c778c24d1b4404146217e93cba970", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjNGIxOTMyY2E3Yzc3OGMyNGQxYjQ0MDQxNDYyMTdlOTNjYmE5NzA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-29T22:45:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-29T22:45:57Z"}, "message": "rollup merge of #24961: nham/net_docs_cleanup\n\nChanges made include adding missing punctuation, adding missing words, and converting uses of \"Gets\" to \"Returns\" in libstd/net/addr.rs to make it more consistent with the other documentation.\n\nFixes #24925.", "tree": {"sha": "4be57a566adb976f3b3bbf6e7c9124b4f9748d3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4be57a566adb976f3b3bbf6e7c9124b4f9748d3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc4b1932ca7c778c24d1b4404146217e93cba970", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc4b1932ca7c778c24d1b4404146217e93cba970", "html_url": "https://github.com/rust-lang/rust/commit/bc4b1932ca7c778c24d1b4404146217e93cba970", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc4b1932ca7c778c24d1b4404146217e93cba970/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c2834837486fe03aff4e721d0587ac086fdb971", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c2834837486fe03aff4e721d0587ac086fdb971", "html_url": "https://github.com/rust-lang/rust/commit/2c2834837486fe03aff4e721d0587ac086fdb971"}, {"sha": "2baeabddd98d38497780bcc2271b71ee693680df", "url": "https://api.github.com/repos/rust-lang/rust/commits/2baeabddd98d38497780bcc2271b71ee693680df", "html_url": "https://github.com/rust-lang/rust/commit/2baeabddd98d38497780bcc2271b71ee693680df"}], "stats": {"total": 78, "additions": 39, "deletions": 39}, "files": [{"sha": "b0bf9d0f8062674785c21a37fdb27c82ca530cfe", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b1932ca7c778c24d1b4404146217e93cba970/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b1932ca7c778c24d1b4404146217e93cba970/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=bc4b1932ca7c778c24d1b4404146217e93cba970", "patch": "@@ -41,7 +41,7 @@ pub enum SocketAddr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SocketAddrV4 { inner: libc::sockaddr_in }\n \n-/// An IPv6 socket address\n+/// An IPv6 socket address.\n #[derive(Copy)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SocketAddrV6 { inner: libc::sockaddr_in6 }\n@@ -56,7 +56,7 @@ impl SocketAddr {\n         }\n     }\n \n-    /// Gets the IP address associated with this socket address.\n+    /// Returns the IP address associated with this socket address.\n     #[unstable(feature = \"ip_addr\", reason = \"recent addition\")]\n     pub fn ip(&self) -> IpAddr {\n         match *self {\n@@ -65,7 +65,7 @@ impl SocketAddr {\n         }\n     }\n \n-    /// Gets the port number associated with this socket address\n+    /// Returns the port number associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 {\n         match *self {\n@@ -89,15 +89,15 @@ impl SocketAddrV4 {\n         }\n     }\n \n-    /// Gets the IP address associated with this socket address.\n+    /// Returns the IP address associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ip(&self) -> &Ipv4Addr {\n         unsafe {\n             &*(&self.inner.sin_addr as *const libc::in_addr as *const Ipv4Addr)\n         }\n     }\n \n-    /// Gets the port number associated with this socket address\n+    /// Returns the port number associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 { ntoh(self.inner.sin_port) }\n }\n@@ -120,24 +120,24 @@ impl SocketAddrV6 {\n         }\n     }\n \n-    /// Gets the IP address associated with this socket address.\n+    /// Returns the IP address associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ip(&self) -> &Ipv6Addr {\n         unsafe {\n             &*(&self.inner.sin6_addr as *const libc::in6_addr as *const Ipv6Addr)\n         }\n     }\n \n-    /// Gets the port number associated with this socket address\n+    /// Returns the port number associated with this socket address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn port(&self) -> u16 { ntoh(self.inner.sin6_port) }\n \n-    /// Gets scope ID associated with this address, corresponding to the\n+    /// Returns scope ID associated with this address, corresponding to the\n     /// `sin6_flowinfo` field in C.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn flowinfo(&self) -> u32 { ntoh(self.inner.sin6_flowinfo) }\n \n-    /// Gets scope ID associated with this address, corresponding to the\n+    /// Returns scope ID associated with this address, corresponding to the\n     /// `sin6_scope_id` field in C.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn scope_id(&self) -> u32 { ntoh(self.inner.sin6_scope_id) }"}, {"sha": "9fd69840f7f054ee93927945b2211297bec44463", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b1932ca7c778c24d1b4404146217e93cba970/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b1932ca7c778c24d1b4404146217e93cba970/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=bc4b1932ca7c778c24d1b4404146217e93cba970", "patch": "@@ -60,7 +60,7 @@ pub enum Ipv6MulticastScope {\n impl Ipv4Addr {\n     /// Creates a new IPv4 address from four eight-bit octets.\n     ///\n-    /// The result will represent the IP address a.b.c.d\n+    /// The result will represent the IP address `a`.`b`.`c`.`d`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n         Ipv4Addr {\n@@ -73,19 +73,19 @@ impl Ipv4Addr {\n         }\n     }\n \n-    /// Returns the four eight-bit integers that make up this address\n+    /// Returns the four eight-bit integers that make up this address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn octets(&self) -> [u8; 4] {\n         let bits = ntoh(self.inner.s_addr);\n         [(bits >> 24) as u8, (bits >> 16) as u8, (bits >> 8) as u8, bits as u8]\n     }\n \n-    /// Returns true for the special 'unspecified' address 0.0.0.0\n+    /// Returns true for the special 'unspecified' address 0.0.0.0.\n     pub fn is_unspecified(&self) -> bool {\n         self.inner.s_addr == 0\n     }\n \n-    /// Returns true if this is a loopback address (127.0.0.0/8)\n+    /// Returns true if this is a loopback address (127.0.0.0/8).\n     pub fn is_loopback(&self) -> bool {\n         self.octets()[0] == 127\n     }\n@@ -106,7 +106,7 @@ impl Ipv4Addr {\n         }\n     }\n \n-    /// Returns true if the address is link-local (169.254.0.0/16)\n+    /// Returns true if the address is link-local (169.254.0.0/16).\n     pub fn is_link_local(&self) -> bool {\n         self.octets()[0] == 169 && self.octets()[1] == 254\n     }\n@@ -116,7 +116,7 @@ impl Ipv4Addr {\n     /// Non-globally-routable networks include the private networks (10.0.0.0/8,\n     /// 172.16.0.0/12 and 192.168.0.0/16), the loopback network (127.0.0.0/8),\n     /// the link-local network (169.254.0.0/16), the broadcast address (255.255.255.255/32) and\n-    /// the test networks used for documentation (192.0.2.0/24, 198.51.100.0/24 and 203.0.113.0/24)\n+    /// the test networks used for documentation (192.0.2.0/24, 198.51.100.0/24 and 203.0.113.0/24).\n     pub fn is_global(&self) -> bool {\n         !self.is_private() && !self.is_loopback() && !self.is_link_local() &&\n         !self.is_broadcast() && !self.is_documentation()\n@@ -131,13 +131,13 @@ impl Ipv4Addr {\n \n     /// Returns true if this is a broadcast address.\n     ///\n-    /// A broadcast address has all octets set to 255 as defined in RFC 919\n+    /// A broadcast address has all octets set to 255 as defined in RFC 919.\n     pub fn is_broadcast(&self) -> bool {\n         self.octets()[0] == 255 && self.octets()[1] == 255 &&\n         self.octets()[2] == 255 && self.octets()[3] == 255\n     }\n \n-    /// Returns true if this address is in a range designated for documentation\n+    /// Returns true if this address is in a range designated for documentation.\n     ///\n     /// This is defined in RFC 5737\n     /// - 192.0.2.0/24 (TEST-NET-1)\n@@ -152,7 +152,7 @@ impl Ipv4Addr {\n         }\n     }\n \n-    /// Converts this address to an IPv4-compatible IPv6 address\n+    /// Converts this address to an IPv4-compatible IPv6 address.\n     ///\n     /// a.b.c.d becomes ::a.b.c.d\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -162,7 +162,7 @@ impl Ipv4Addr {\n                       ((self.octets()[2] as u16) << 8) | self.octets()[3] as u16)\n     }\n \n-    /// Converts this address to an IPv4-mapped IPv6 address\n+    /// Converts this address to an IPv4-mapped IPv6 address.\n     ///\n     /// a.b.c.d becomes ::ffff:a.b.c.d\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -247,7 +247,7 @@ impl FromInner<libc::in_addr> for Ipv4Addr {\n impl Ipv6Addr {\n     /// Creates a new IPv6 address from eight 16-bit segments.\n     ///\n-    /// The result will represent the IP address a:b:c:d:e:f:g:h\n+    /// The result will represent the IP address a:b:c:d:e:f:g:h.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16,\n                h: u16) -> Ipv6Addr {\n@@ -259,7 +259,7 @@ impl Ipv6Addr {\n         }\n     }\n \n-    /// Returns the eight 16-bit segments that make up this address\n+    /// Returns the eight 16-bit segments that make up this address.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn segments(&self) -> [u16; 8] {\n         [ntoh(self.inner.s6_addr[0]),\n@@ -272,12 +272,12 @@ impl Ipv6Addr {\n          ntoh(self.inner.s6_addr[7])]\n     }\n \n-    /// Returns true for the special 'unspecified' address ::\n+    /// Returns true for the special 'unspecified' address ::.\n     pub fn is_unspecified(&self) -> bool {\n         self.segments() == [0, 0, 0, 0, 0, 0, 0, 0]\n     }\n \n-    /// Returns true if this is a loopback address (::1)\n+    /// Returns true if this is a loopback address (::1).\n     pub fn is_loopback(&self) -> bool {\n         self.segments() == [0, 0, 0, 0, 0, 0, 0, 1]\n     }\n@@ -295,25 +295,25 @@ impl Ipv6Addr {\n         }\n     }\n \n-    /// Returns true if this is a unique local address (IPv6)\n+    /// Returns true if this is a unique local address (IPv6).\n     ///\n-    /// Unique local addresses are defined in RFC4193 and have the form fc00::/7\n+    /// Unique local addresses are defined in RFC4193 and have the form fc00::/7.\n     pub fn is_unique_local(&self) -> bool {\n         (self.segments()[0] & 0xfe00) == 0xfc00\n     }\n \n-    /// Returns true if the address is unicast and link-local (fe80::/10)\n+    /// Returns true if the address is unicast and link-local (fe80::/10).\n     pub fn is_unicast_link_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfe80\n     }\n \n     /// Returns true if this is a deprecated unicast site-local address (IPv6\n-    /// fec0::/10)\n+    /// fec0::/10).\n     pub fn is_unicast_site_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfec0\n     }\n \n-    /// Returns true if the address is a globally routable unicast address\n+    /// Returns true if the address is a globally routable unicast address.\n     ///\n     /// Non-globally-routable unicast addresses include the loopback address,\n     /// the link-local addresses, the deprecated site-local addresses and the"}, {"sha": "130e1eee8f924e1a456f93e923da329d186663bd", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b1932ca7c778c24d1b4404146217e93cba970/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b1932ca7c778c24d1b4404146217e93cba970/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=bc4b1932ca7c778c24d1b4404146217e93cba970", "patch": "@@ -125,7 +125,7 @@ impl TcpStream {\n         self.0.duplicate().map(TcpStream)\n     }\n \n-    /// Sets the nodelay flag on this connection to the boolean specified\n+    /// Sets the nodelay flag on this connection to the boolean specified.\n     pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n         self.0.set_nodelay(nodelay)\n     }"}, {"sha": "0b04ecb1b7228565577b5a958348922a5e596db6", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bc4b1932ca7c778c24d1b4404146217e93cba970/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc4b1932ca7c778c24d1b4404146217e93cba970/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=bc4b1932ca7c778c24d1b4404146217e93cba970", "patch": "@@ -50,8 +50,8 @@ pub struct UdpSocket(net_imp::UdpSocket);\n impl UdpSocket {\n     /// Creates a UDP socket from the given address.\n     ///\n-    /// Address type can be any implementor of `ToSocketAddr` trait. See its\n-    /// documentation for concrete examples.\n+    /// The address type can be any implementor of `ToSocketAddr` trait. See\n+    /// its documentation for concrete examples.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<UdpSocket> {\n         super::each_addr(addr, net_imp::UdpSocket::bind).map(UdpSocket)\n@@ -64,8 +64,8 @@ impl UdpSocket {\n         self.0.recv_from(buf)\n     }\n \n-    /// Sends data on the socket to the given address. Returns nothing on\n-    /// success.\n+    /// Sends data on the socket to the given address. On success, returns the\n+    /// number of bytes written.\n     ///\n     /// Address type can be any implementor of `ToSocketAddrs` trait. See its\n     /// documentation for concrete examples.\n@@ -95,34 +95,34 @@ impl UdpSocket {\n         self.0.duplicate().map(UdpSocket)\n     }\n \n-    /// Sets the broadcast flag on or off\n+    /// Sets the broadcast flag on or off.\n     pub fn set_broadcast(&self, on: bool) -> io::Result<()> {\n         self.0.set_broadcast(on)\n     }\n \n-    /// Sets the multicast loop flag to the specified value\n+    /// Sets the multicast loop flag to the specified value.\n     ///\n     /// This lets multicast packets loop back to local sockets (if enabled)\n     pub fn set_multicast_loop(&self, on: bool) -> io::Result<()> {\n         self.0.set_multicast_loop(on)\n     }\n \n-    /// Joins a multicast IP address (becomes a member of it)\n+    /// Joins a multicast IP address (becomes a member of it).\n     pub fn join_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n         self.0.join_multicast(multi)\n     }\n \n-    /// Leaves a multicast IP address (drops membership from it)\n+    /// Leaves a multicast IP address (drops membership from it).\n     pub fn leave_multicast(&self, multi: &IpAddr) -> io::Result<()> {\n         self.0.leave_multicast(multi)\n     }\n \n-    /// Sets the multicast TTL\n+    /// Sets the multicast TTL.\n     pub fn set_multicast_time_to_live(&self, ttl: i32) -> io::Result<()> {\n         self.0.multicast_time_to_live(ttl)\n     }\n \n-    /// Sets this socket's TTL\n+    /// Sets this socket's TTL.\n     pub fn set_time_to_live(&self, ttl: i32) -> io::Result<()> {\n         self.0.time_to_live(ttl)\n     }"}]}