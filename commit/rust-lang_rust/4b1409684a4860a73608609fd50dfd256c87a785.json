{"sha": "4b1409684a4860a73608609fd50dfd256c87a785", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMTQwOTY4NGE0ODYwYTczNjA4NjA5ZmQ1MGRmZDI1NmM4N2E3ODU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-11-03T21:45:52Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-11-03T21:45:52Z"}, "message": "Merge pull request #432 from nweston/zip-with-range\n\nNew lint for zip with array length instead of enumerate()", "tree": {"sha": "5ce26298616541be5f2be411b128ab967703f3a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ce26298616541be5f2be411b128ab967703f3a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b1409684a4860a73608609fd50dfd256c87a785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b1409684a4860a73608609fd50dfd256c87a785", "html_url": "https://github.com/rust-lang/rust/commit/4b1409684a4860a73608609fd50dfd256c87a785", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b1409684a4860a73608609fd50dfd256c87a785/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb729e1c6b55136df723069d9a423b262a06a760", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb729e1c6b55136df723069d9a423b262a06a760", "html_url": "https://github.com/rust-lang/rust/commit/cb729e1c6b55136df723069d9a423b262a06a760"}, {"sha": "d28b8e169fc9f722aa32dc16a21be137587316ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/d28b8e169fc9f722aa32dc16a21be137587316ef", "html_url": "https://github.com/rust-lang/rust/commit/d28b8e169fc9f722aa32dc16a21be137587316ef"}], "stats": {"total": 48, "additions": 43, "deletions": 5}, "files": [{"sha": "0da037e7b16d3d651a1f0637ca6b8557caf4a24d", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b1409684a4860a73608609fd50dfd256c87a785/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b1409684a4860a73608609fd50dfd256c87a785/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=4b1409684a4860a73608609fd50dfd256c87a785", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 70 lints included in this crate:\n+There are 71 lints included in this crate:\n \n name                                                                                                   | default | meaning\n -------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -53,6 +53,7 @@ name\n [precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                               | warn    | catches operations where precedence may be unclear. See the wiki for a list of cases caught\n [ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                     | warn    | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n [range_step_by_zero](https://github.com/Manishearth/rust-clippy/wiki#range_step_by_zero)               | warn    | using Range::step_by(0), which produces an infinite iterator\n+[range_zip_with_len](https://github.com/Manishearth/rust-clippy/wiki#range_zip_with_len)               | warn    | zipping iterator with a range when enumerate() would do\n [redundant_closure](https://github.com/Manishearth/rust-clippy/wiki#redundant_closure)                 | warn    | using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n [redundant_pattern](https://github.com/Manishearth/rust-clippy/wiki#redundant_pattern)                 | warn    | using `name @ _` in a pattern\n [result_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#result_unwrap_used)               | allow   | using `Result.unwrap()`, which might be better handled"}, {"sha": "525603dc2b805f1b6339f789ce1b585fd4ebee09", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b1409684a4860a73608609fd50dfd256c87a785/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1409684a4860a73608609fd50dfd256c87a785/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4b1409684a4860a73608609fd50dfd256c87a785", "patch": "@@ -166,6 +166,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         precedence::PRECEDENCE,\n         ptr_arg::PTR_ARG,\n         ranges::RANGE_STEP_BY_ZERO,\n+        ranges::RANGE_ZIP_WITH_LEN,\n         returns::LET_AND_RETURN,\n         returns::NEEDLESS_RETURN,\n         types::BOX_VEC,"}, {"sha": "39ff7d3cd31406bfa9b407d502475de24328626e", "filename": "src/ranges.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4b1409684a4860a73608609fd50dfd256c87a785/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1409684a4860a73608609fd50dfd256c87a785/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=4b1409684a4860a73608609fd50dfd256c87a785", "patch": "@@ -1,33 +1,64 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n-use utils::{match_type, is_integer_literal};\n+use utils::{is_integer_literal, match_type, snippet};\n \n declare_lint! {\n     pub RANGE_STEP_BY_ZERO, Warn,\n     \"using Range::step_by(0), which produces an infinite iterator\"\n }\n+declare_lint! {\n+    pub RANGE_ZIP_WITH_LEN, Warn,\n+    \"zipping iterator with a range when enumerate() would do\"\n+}\n \n #[derive(Copy,Clone)]\n pub struct StepByZero;\n \n impl LintPass for StepByZero {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(RANGE_STEP_BY_ZERO)\n+        lint_array!(RANGE_STEP_BY_ZERO, RANGE_ZIP_WITH_LEN)\n     }\n }\n \n impl LateLintPass for StepByZero {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprMethodCall(Spanned { node: ref name, .. }, _,\n                               ref args) = expr.node {\n-            // Only warn on literal ranges.\n+            // Range with step_by(0).\n             if name.as_str() == \"step_by\" && args.len() == 2 &&\n                 is_range(cx, &args[0]) && is_integer_literal(&args[1], 0) {\n                 cx.span_lint(RANGE_STEP_BY_ZERO, expr.span,\n                              \"Range::step_by(0) produces an infinite iterator. \\\n                               Consider using `std::iter::repeat()` instead\")\n             }\n+\n+            // x.iter().zip(0..x.len())\n+            else if name.as_str() == \"zip\" && args.len() == 2 {\n+                let iter = &args[0].node;\n+                let zip_arg = &args[1].node;\n+                if_let_chain! {\n+                    [\n+                        // .iter() call\n+                        let &ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = iter,\n+                        iter_name.as_str() == \"iter\",\n+                        // range expression in .zip() call: 0..x.len()\n+                        let &ExprRange(Some(ref from), Some(ref to)) = zip_arg,\n+                        is_integer_literal(from, 0),\n+                        // .len() call\n+                        let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = to.node,\n+                        len_name.as_str() == \"len\" && len_args.len() == 1,\n+                        // .iter() and .len() called on same Path\n+                        let ExprPath(_, Path { segments: ref iter_path, .. }) = iter_args[0].node,\n+                        let ExprPath(_, Path { segments: ref len_path, .. }) = len_args[0].node,\n+                        iter_path == len_path\n+                     ], {\n+                        cx.span_lint(RANGE_ZIP_WITH_LEN, expr.span,\n+                                     &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n+                                              snippet(cx, iter_args[0].span, \"_\")));\n+                    }\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "2d731670cbe391dd58b3b2ae521f354f9e78531b", "filename": "tests/compile-fail/range.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4b1409684a4860a73608609fd50dfd256c87a785/tests%2Fcompile-fail%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b1409684a4860a73608609fd50dfd256c87a785/tests%2Fcompile-fail%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Frange.rs?ref=4b1409684a4860a73608609fd50dfd256c87a785", "patch": "@@ -7,7 +7,7 @@ impl NotARange {\n     fn step_by(&self, _: u32) {}\n }\n \n-#[deny(range_step_by_zero)]\n+#[deny(range_step_by_zero, range_zip_with_len)]\n fn main() {\n     (0..1).step_by(0); //~ERROR Range::step_by(0) produces an infinite iterator\n     // No warning for non-zero step\n@@ -21,4 +21,9 @@ fn main() {\n     // No error, not a range.\n     let y = NotARange;\n     y.step_by(0);\n+\n+    let _v1 = vec![1,2,3];\n+    let _v2 = vec![4,5];\n+    let _x = _v1.iter().zip(0.._v1.len()); //~ERROR It is more idiomatic to use _v1.iter().enumerate()\n+    let _y = _v1.iter().zip(0.._v2.len()); // No error\n }"}]}