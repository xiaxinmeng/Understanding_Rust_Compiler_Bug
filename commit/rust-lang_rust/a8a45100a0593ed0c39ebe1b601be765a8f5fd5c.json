{"sha": "a8a45100a0593ed0c39ebe1b601be765a8f5fd5c", "node_id": "C_kwDOAAsO6NoAKGE4YTQ1MTAwYTA1OTNlZDBjMzllYmUxYjYwMWJlNzY1YThmNWZkNWM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-08T03:53:35Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-13T05:01:36Z"}, "message": "Move some codegen-y methods from rustc_hir_analysis::collect -> rustc_codegen_ssa", "tree": {"sha": "7b06800a6becb06c06d578732d4b441f8da00de8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b06800a6becb06c06d578732d4b441f8da00de8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c", "html_url": "https://github.com/rust-lang/rust/commit/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b96d9e0e20adb7716aa32a56fe96fde15c75d517", "url": "https://api.github.com/repos/rust-lang/rust/commits/b96d9e0e20adb7716aa32a56fe96fde15c75d517", "html_url": "https://github.com/rust-lang/rust/commit/b96d9e0e20adb7716aa32a56fe96fde15c75d517"}], "stats": {"total": 1685, "additions": 857, "deletions": 828}, "files": [{"sha": "c7f2e1966c1edfb271c9ce884ebcca932c3c0827", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "added", "additions": 688, "deletions": 0, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=a8a45100a0593ed0c39ebe1b601be765a8f5fd5c", "patch": "@@ -0,0 +1,688 @@\n+use rustc_ast::{ast, MetaItemKind, NestedMetaItem};\n+use rustc_attr::{list_contains_name, InlineAttr, InstructionSetAttr, OptimizeAttr};\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::{lang_items, weak_lang_items::WEAK_LANG_ITEMS, LangItem};\n+use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n+use rustc_middle::mir::mono::Linkage;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::{self as ty, DefIdTree, TyCtxt};\n+use rustc_session::{lint, parse::feature_err};\n+use rustc_span::{sym, Span};\n+use rustc_target::spec::{abi, SanitizerSet};\n+\n+use crate::target_features::from_target_feature;\n+use crate::{errors::ExpectedUsedSymbol, target_features::check_target_feature_trait_unsafe};\n+\n+fn linkage_by_name(tcx: TyCtxt<'_>, def_id: LocalDefId, name: &str) -> Linkage {\n+    use rustc_middle::mir::mono::Linkage::*;\n+\n+    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n+    // applicable to variable declarations and may not really make sense for\n+    // Rust code in the first place but allow them anyway and trust that the\n+    // user knows what they're doing. Who knows, unanticipated use cases may pop\n+    // up in the future.\n+    //\n+    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n+    // and don't have to be, LLVM treats them as no-ops.\n+    match name {\n+        \"appending\" => Appending,\n+        \"available_externally\" => AvailableExternally,\n+        \"common\" => Common,\n+        \"extern_weak\" => ExternalWeak,\n+        \"external\" => External,\n+        \"internal\" => Internal,\n+        \"linkonce\" => LinkOnceAny,\n+        \"linkonce_odr\" => LinkOnceODR,\n+        \"private\" => Private,\n+        \"weak\" => WeakAny,\n+        \"weak_odr\" => WeakODR,\n+        _ => tcx.sess.span_fatal(tcx.def_span(def_id), \"invalid linkage specified\"),\n+    }\n+}\n+\n+fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n+    if cfg!(debug_assertions) {\n+        let def_kind = tcx.def_kind(did);\n+        assert!(\n+            def_kind.has_codegen_attrs(),\n+            \"unexpected `def_kind` in `codegen_fn_attrs`: {def_kind:?}\",\n+        );\n+    }\n+\n+    let did = did.expect_local();\n+    let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(did));\n+    let mut codegen_fn_attrs = CodegenFnAttrs::new();\n+    if tcx.should_inherit_track_caller(did) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n+    }\n+\n+    let supported_target_features = tcx.supported_target_features(LOCAL_CRATE);\n+\n+    let mut inline_span = None;\n+    let mut link_ordinal_span = None;\n+    let mut no_sanitize_span = None;\n+    for attr in attrs.iter() {\n+        if attr.has_name(sym::cold) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n+        } else if attr.has_name(sym::rustc_allocator) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n+        } else if attr.has_name(sym::ffi_returns_twice) {\n+            if tcx.is_foreign_item(did) {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n+            } else {\n+                // `#[ffi_returns_twice]` is only allowed `extern fn`s.\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0724,\n+                    \"`#[ffi_returns_twice]` may only be used on foreign functions\"\n+                )\n+                .emit();\n+            }\n+        } else if attr.has_name(sym::ffi_pure) {\n+            if tcx.is_foreign_item(did) {\n+                if attrs.iter().any(|a| a.has_name(sym::ffi_const)) {\n+                    // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        attr.span,\n+                        E0757,\n+                        \"`#[ffi_const]` function cannot be `#[ffi_pure]`\"\n+                    )\n+                    .emit();\n+                } else {\n+                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE;\n+                }\n+            } else {\n+                // `#[ffi_pure]` is only allowed on foreign functions\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0755,\n+                    \"`#[ffi_pure]` may only be used on foreign functions\"\n+                )\n+                .emit();\n+            }\n+        } else if attr.has_name(sym::ffi_const) {\n+            if tcx.is_foreign_item(did) {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n+            } else {\n+                // `#[ffi_const]` is only allowed on foreign functions\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0756,\n+                    \"`#[ffi_const]` may only be used on foreign functions\"\n+                )\n+                .emit();\n+            }\n+        } else if attr.has_name(sym::rustc_nounwind) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n+        } else if attr.has_name(sym::rustc_reallocator) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::REALLOCATOR;\n+        } else if attr.has_name(sym::rustc_deallocator) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::DEALLOCATOR;\n+        } else if attr.has_name(sym::rustc_allocator_zeroed) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR_ZEROED;\n+        } else if attr.has_name(sym::naked) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n+        } else if attr.has_name(sym::no_mangle) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n+        } else if attr.has_name(sym::no_coverage) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n+        } else if attr.has_name(sym::rustc_std_internal_symbol) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n+        } else if attr.has_name(sym::used) {\n+            let inner = attr.meta_item_list();\n+            match inner.as_deref() {\n+                Some([item]) if item.has_name(sym::linker) => {\n+                    if !tcx.features().used_with_arg {\n+                        feature_err(\n+                            &tcx.sess.parse_sess,\n+                            sym::used_with_arg,\n+                            attr.span,\n+                            \"`#[used(linker)]` is currently unstable\",\n+                        )\n+                        .emit();\n+                    }\n+                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED_LINKER;\n+                }\n+                Some([item]) if item.has_name(sym::compiler) => {\n+                    if !tcx.features().used_with_arg {\n+                        feature_err(\n+                            &tcx.sess.parse_sess,\n+                            sym::used_with_arg,\n+                            attr.span,\n+                            \"`#[used(compiler)]` is currently unstable\",\n+                        )\n+                        .emit();\n+                    }\n+                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n+                }\n+                Some(_) => {\n+                    tcx.sess.emit_err(ExpectedUsedSymbol { span: attr.span });\n+                }\n+                None => {\n+                    // Unfortunately, unconditionally using `llvm.used` causes\n+                    // issues in handling `.init_array` with the gold linker,\n+                    // but using `llvm.compiler.used` caused a nontrival amount\n+                    // of unintentional ecosystem breakage -- particularly on\n+                    // Mach-O targets.\n+                    //\n+                    // As a result, we emit `llvm.compiler.used` only on ELF\n+                    // targets. This is somewhat ad-hoc, but actually follows\n+                    // our pre-LLVM 13 behavior (prior to the ecosystem\n+                    // breakage), and seems to match `clang`'s behavior as well\n+                    // (both before and after LLVM 13), possibly because they\n+                    // have similar compatibility concerns to us. See\n+                    // https://github.com/rust-lang/rust/issues/47384#issuecomment-1019080146\n+                    // and following comments for some discussion of this, as\n+                    // well as the comments in `rustc_codegen_llvm` where these\n+                    // flags are handled.\n+                    //\n+                    // Anyway, to be clear: this is still up in the air\n+                    // somewhat, and is subject to change in the future (which\n+                    // is a good thing, because this would ideally be a bit\n+                    // more firmed up).\n+                    let is_like_elf = !(tcx.sess.target.is_like_osx\n+                        || tcx.sess.target.is_like_windows\n+                        || tcx.sess.target.is_like_wasm);\n+                    codegen_fn_attrs.flags |= if is_like_elf {\n+                        CodegenFnAttrFlags::USED\n+                    } else {\n+                        CodegenFnAttrFlags::USED_LINKER\n+                    };\n+                }\n+            }\n+        } else if attr.has_name(sym::cmse_nonsecure_entry) {\n+            if !matches!(tcx.fn_sig(did).abi(), abi::Abi::C { .. }) {\n+                struct_span_err!(\n+                    tcx.sess,\n+                    attr.span,\n+                    E0776,\n+                    \"`#[cmse_nonsecure_entry]` requires C ABI\"\n+                )\n+                .emit();\n+            }\n+            if !tcx.sess.target.llvm_target.contains(\"thumbv8m\") {\n+                struct_span_err!(tcx.sess, attr.span, E0775, \"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M extension\")\n+                    .emit();\n+            }\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY;\n+        } else if attr.has_name(sym::thread_local) {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n+        } else if attr.has_name(sym::track_caller) {\n+            if !tcx.is_closure(did.to_def_id()) && tcx.fn_sig(did).abi() != abi::Abi::Rust {\n+                struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n+                    .emit();\n+            }\n+            if tcx.is_closure(did.to_def_id()) && !tcx.features().closure_track_caller {\n+                feature_err(\n+                    &tcx.sess.parse_sess,\n+                    sym::closure_track_caller,\n+                    attr.span,\n+                    \"`#[track_caller]` on closures is currently unstable\",\n+                )\n+                .emit();\n+            }\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n+        } else if attr.has_name(sym::export_name) {\n+            if let Some(s) = attr.value_str() {\n+                if s.as_str().contains('\\0') {\n+                    // `#[export_name = ...]` will be converted to a null-terminated string,\n+                    // so it may not contain any null characters.\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        attr.span,\n+                        E0648,\n+                        \"`export_name` may not contain null characters\"\n+                    )\n+                    .emit();\n+                }\n+                codegen_fn_attrs.export_name = Some(s);\n+            }\n+        } else if attr.has_name(sym::target_feature) {\n+            if !tcx.is_closure(did.to_def_id())\n+                && tcx.fn_sig(did).unsafety() == hir::Unsafety::Normal\n+            {\n+                if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n+                    // The `#[target_feature]` attribute is allowed on\n+                    // WebAssembly targets on all functions, including safe\n+                    // ones. Other targets require that `#[target_feature]` is\n+                    // only applied to unsafe functions (pending the\n+                    // `target_feature_11` feature) because on most targets\n+                    // execution of instructions that are not supported is\n+                    // considered undefined behavior. For WebAssembly which is a\n+                    // 100% safe target at execution time it's not possible to\n+                    // execute undefined instructions, and even if a future\n+                    // feature was added in some form for this it would be a\n+                    // deterministic trap. There is no undefined behavior when\n+                    // executing WebAssembly so `#[target_feature]` is allowed\n+                    // on safe functions (but again, only for WebAssembly)\n+                    //\n+                    // Note that this is also allowed if `actually_rustdoc` so\n+                    // if a target is documenting some wasm-specific code then\n+                    // it's not spuriously denied.\n+                } else if !tcx.features().target_feature_11 {\n+                    let mut err = feature_err(\n+                        &tcx.sess.parse_sess,\n+                        sym::target_feature_11,\n+                        attr.span,\n+                        \"`#[target_feature(..)]` can only be applied to `unsafe` functions\",\n+                    );\n+                    err.span_label(tcx.def_span(did), \"not an `unsafe` function\");\n+                    err.emit();\n+                } else {\n+                    check_target_feature_trait_unsafe(tcx, did, attr.span);\n+                }\n+            }\n+            from_target_feature(\n+                tcx,\n+                attr,\n+                supported_target_features,\n+                &mut codegen_fn_attrs.target_features,\n+            );\n+        } else if attr.has_name(sym::linkage) {\n+            if let Some(val) = attr.value_str() {\n+                let linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n+                if tcx.is_foreign_item(did) {\n+                    codegen_fn_attrs.import_linkage = linkage;\n+                } else {\n+                    codegen_fn_attrs.linkage = linkage;\n+                }\n+            }\n+        } else if attr.has_name(sym::link_section) {\n+            if let Some(val) = attr.value_str() {\n+                if val.as_str().bytes().any(|b| b == 0) {\n+                    let msg = format!(\n+                        \"illegal null byte in link_section \\\n+                         value: `{}`\",\n+                        &val\n+                    );\n+                    tcx.sess.span_err(attr.span, &msg);\n+                } else {\n+                    codegen_fn_attrs.link_section = Some(val);\n+                }\n+            }\n+        } else if attr.has_name(sym::link_name) {\n+            codegen_fn_attrs.link_name = attr.value_str();\n+        } else if attr.has_name(sym::link_ordinal) {\n+            link_ordinal_span = Some(attr.span);\n+            if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n+                codegen_fn_attrs.link_ordinal = ordinal;\n+            }\n+        } else if attr.has_name(sym::no_sanitize) {\n+            no_sanitize_span = Some(attr.span);\n+            if let Some(list) = attr.meta_item_list() {\n+                for item in list.iter() {\n+                    if item.has_name(sym::address) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::ADDRESS;\n+                    } else if item.has_name(sym::cfi) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n+                    } else if item.has_name(sym::kcfi) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI;\n+                    } else if item.has_name(sym::memory) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n+                    } else if item.has_name(sym::memtag) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMTAG;\n+                    } else if item.has_name(sym::shadow_call_stack) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::SHADOWCALLSTACK;\n+                    } else if item.has_name(sym::thread) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD;\n+                    } else if item.has_name(sym::hwaddress) {\n+                        codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS;\n+                    } else {\n+                        tcx.sess\n+                            .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n+                            .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n+                            .emit();\n+                    }\n+                }\n+            }\n+        } else if attr.has_name(sym::instruction_set) {\n+            codegen_fn_attrs.instruction_set = match attr.meta_kind() {\n+                Some(MetaItemKind::List(ref items)) => match items.as_slice() {\n+                    [NestedMetaItem::MetaItem(set)] => {\n+                        let segments =\n+                            set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n+                        match segments.as_slice() {\n+                            [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n+                                if !tcx.sess.target.has_thumb_interworking {\n+                                    struct_span_err!(\n+                                        tcx.sess.diagnostic(),\n+                                        attr.span,\n+                                        E0779,\n+                                        \"target does not support `#[instruction_set]`\"\n+                                    )\n+                                    .emit();\n+                                    None\n+                                } else if segments[1] == sym::a32 {\n+                                    Some(InstructionSetAttr::ArmA32)\n+                                } else if segments[1] == sym::t32 {\n+                                    Some(InstructionSetAttr::ArmT32)\n+                                } else {\n+                                    unreachable!()\n+                                }\n+                            }\n+                            _ => {\n+                                struct_span_err!(\n+                                    tcx.sess.diagnostic(),\n+                                    attr.span,\n+                                    E0779,\n+                                    \"invalid instruction set specified\",\n+                                )\n+                                .emit();\n+                                None\n+                            }\n+                        }\n+                    }\n+                    [] => {\n+                        struct_span_err!(\n+                            tcx.sess.diagnostic(),\n+                            attr.span,\n+                            E0778,\n+                            \"`#[instruction_set]` requires an argument\"\n+                        )\n+                        .emit();\n+                        None\n+                    }\n+                    _ => {\n+                        struct_span_err!(\n+                            tcx.sess.diagnostic(),\n+                            attr.span,\n+                            E0779,\n+                            \"cannot specify more than one instruction set\"\n+                        )\n+                        .emit();\n+                        None\n+                    }\n+                },\n+                _ => {\n+                    struct_span_err!(\n+                        tcx.sess.diagnostic(),\n+                        attr.span,\n+                        E0778,\n+                        \"must specify an instruction set\"\n+                    )\n+                    .emit();\n+                    None\n+                }\n+            };\n+        } else if attr.has_name(sym::repr) {\n+            codegen_fn_attrs.alignment = match attr.meta_item_list() {\n+                Some(items) => match items.as_slice() {\n+                    [item] => match item.name_value_literal() {\n+                        Some((sym::align, literal)) => {\n+                            let alignment = rustc_attr::parse_alignment(&literal.kind);\n+\n+                            match alignment {\n+                                Ok(align) => Some(align),\n+                                Err(msg) => {\n+                                    struct_span_err!(\n+                                        tcx.sess.diagnostic(),\n+                                        attr.span,\n+                                        E0589,\n+                                        \"invalid `repr(align)` attribute: {}\",\n+                                        msg\n+                                    )\n+                                    .emit();\n+\n+                                    None\n+                                }\n+                            }\n+                        }\n+                        _ => None,\n+                    },\n+                    [] => None,\n+                    _ => None,\n+                },\n+                None => None,\n+            };\n+        }\n+    }\n+\n+    codegen_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n+        if !attr.has_name(sym::inline) {\n+            return ia;\n+        }\n+        match attr.meta_kind() {\n+            Some(MetaItemKind::Word) => InlineAttr::Hint,\n+            Some(MetaItemKind::List(ref items)) => {\n+                inline_span = Some(attr.span);\n+                if items.len() != 1 {\n+                    struct_span_err!(\n+                        tcx.sess.diagnostic(),\n+                        attr.span,\n+                        E0534,\n+                        \"expected one argument\"\n+                    )\n+                    .emit();\n+                    InlineAttr::None\n+                } else if list_contains_name(&items, sym::always) {\n+                    InlineAttr::Always\n+                } else if list_contains_name(&items, sym::never) {\n+                    InlineAttr::Never\n+                } else {\n+                    struct_span_err!(\n+                        tcx.sess.diagnostic(),\n+                        items[0].span(),\n+                        E0535,\n+                        \"invalid argument\"\n+                    )\n+                    .help(\"valid inline arguments are `always` and `never`\")\n+                    .emit();\n+\n+                    InlineAttr::None\n+                }\n+            }\n+            Some(MetaItemKind::NameValue(_)) => ia,\n+            None => ia,\n+        }\n+    });\n+\n+    codegen_fn_attrs.optimize = attrs.iter().fold(OptimizeAttr::None, |ia, attr| {\n+        if !attr.has_name(sym::optimize) {\n+            return ia;\n+        }\n+        let err = |sp, s| struct_span_err!(tcx.sess.diagnostic(), sp, E0722, \"{}\", s).emit();\n+        match attr.meta_kind() {\n+            Some(MetaItemKind::Word) => {\n+                err(attr.span, \"expected one argument\");\n+                ia\n+            }\n+            Some(MetaItemKind::List(ref items)) => {\n+                inline_span = Some(attr.span);\n+                if items.len() != 1 {\n+                    err(attr.span, \"expected one argument\");\n+                    OptimizeAttr::None\n+                } else if list_contains_name(&items, sym::size) {\n+                    OptimizeAttr::Size\n+                } else if list_contains_name(&items, sym::speed) {\n+                    OptimizeAttr::Speed\n+                } else {\n+                    err(items[0].span(), \"invalid argument\");\n+                    OptimizeAttr::None\n+                }\n+            }\n+            Some(MetaItemKind::NameValue(_)) => ia,\n+            None => ia,\n+        }\n+    });\n+\n+    // #73631: closures inherit `#[target_feature]` annotations\n+    if tcx.features().target_feature_11 && tcx.is_closure(did.to_def_id()) {\n+        let owner_id = tcx.parent(did.to_def_id());\n+        if tcx.def_kind(owner_id).has_codegen_attrs() {\n+            codegen_fn_attrs\n+                .target_features\n+                .extend(tcx.codegen_fn_attrs(owner_id).target_features.iter().copied());\n+        }\n+    }\n+\n+    // If a function uses #[target_feature] it can't be inlined into general\n+    // purpose functions as they wouldn't have the right target features\n+    // enabled. For that reason we also forbid #[inline(always)] as it can't be\n+    // respected.\n+    if !codegen_fn_attrs.target_features.is_empty() {\n+        if codegen_fn_attrs.inline == InlineAttr::Always {\n+            if let Some(span) = inline_span {\n+                tcx.sess.span_err(\n+                    span,\n+                    \"cannot use `#[inline(always)]` with \\\n+                     `#[target_feature]`\",\n+                );\n+            }\n+        }\n+    }\n+\n+    if !codegen_fn_attrs.no_sanitize.is_empty() {\n+        if codegen_fn_attrs.inline == InlineAttr::Always {\n+            if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n+                tcx.struct_span_lint_hir(\n+                    lint::builtin::INLINE_NO_SANITIZE,\n+                    hir_id,\n+                    no_sanitize_span,\n+                    \"`no_sanitize` will have no effect after inlining\",\n+                    |lint| lint.span_note(inline_span, \"inlining requested here\"),\n+                )\n+            }\n+        }\n+    }\n+\n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n+        codegen_fn_attrs.inline = InlineAttr::Never;\n+    }\n+\n+    // Weak lang items have the same semantics as \"std internal\" symbols in the\n+    // sense that they're preserved through all our LTO passes and only\n+    // strippable by the linker.\n+    //\n+    // Additionally weak lang items have predetermined symbol names.\n+    if WEAK_LANG_ITEMS.iter().any(|&l| tcx.lang_items().get(l) == Some(did.to_def_id())) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n+    }\n+    if let Some((name, _)) = lang_items::extract(attrs)\n+        && let Some(lang_item) = LangItem::from_name(name)\n+        && let Some(link_name) = lang_item.link_name()\n+    {\n+        codegen_fn_attrs.export_name = Some(link_name);\n+        codegen_fn_attrs.link_name = Some(link_name);\n+    }\n+    check_link_name_xor_ordinal(tcx, &codegen_fn_attrs, link_ordinal_span);\n+\n+    // Internal symbols to the standard library all have no_mangle semantics in\n+    // that they have defined symbol names present in the function name. This\n+    // also applies to weak symbols where they all have known symbol names.\n+    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n+        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n+    }\n+\n+    // Any linkage to LLVM intrinsics for now forcibly marks them all as never\n+    // unwinds since LLVM sometimes can't handle codegen which `invoke`s\n+    // intrinsic functions.\n+    if let Some(name) = &codegen_fn_attrs.link_name {\n+        if name.as_str().starts_with(\"llvm.\") {\n+            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n+        }\n+    }\n+\n+    codegen_fn_attrs\n+}\n+\n+/// Checks if the provided DefId is a method in a trait impl for a trait which has track_caller\n+/// applied to the method prototype.\n+fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    if let Some(impl_item) = tcx.opt_associated_item(def_id)\n+        && let ty::AssocItemContainer::ImplContainer = impl_item.container\n+        && let Some(trait_item) = impl_item.trait_item_def_id\n+    {\n+        return tcx\n+            .codegen_fn_attrs(trait_item)\n+            .flags\n+            .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n+    }\n+\n+    false\n+}\n+\n+fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n+    use rustc_ast::{LitIntType, LitKind, MetaItemLit};\n+    if !tcx.features().raw_dylib && tcx.sess.target.arch == \"x86\" {\n+        feature_err(\n+            &tcx.sess.parse_sess,\n+            sym::raw_dylib,\n+            attr.span,\n+            \"`#[link_ordinal]` is unstable on x86\",\n+        )\n+        .emit();\n+    }\n+    let meta_item_list = attr.meta_item_list();\n+    let meta_item_list = meta_item_list.as_deref();\n+    let sole_meta_list = match meta_item_list {\n+        Some([item]) => item.lit(),\n+        Some(_) => {\n+            tcx.sess\n+                .struct_span_err(attr.span, \"incorrect number of arguments to `#[link_ordinal]`\")\n+                .note(\"the attribute requires exactly one argument\")\n+                .emit();\n+            return None;\n+        }\n+        _ => None,\n+    };\n+    if let Some(MetaItemLit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) =\n+        sole_meta_list\n+    {\n+        // According to the table at https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-header,\n+        // the ordinal must fit into 16 bits.  Similarly, the Ordinal field in COFFShortExport (defined\n+        // in llvm/include/llvm/Object/COFFImportFile.h), which we use to communicate import information\n+        // to LLVM for `#[link(kind = \"raw-dylib\"_])`, is also defined to be uint16_t.\n+        //\n+        // FIXME: should we allow an ordinal of 0?  The MSVC toolchain has inconsistent support for this:\n+        // both LINK.EXE and LIB.EXE signal errors and abort when given a .DEF file that specifies\n+        // a zero ordinal.  However, llvm-dlltool is perfectly happy to generate an import library\n+        // for such a .DEF file, and MSVC's LINK.EXE is also perfectly happy to consume an import\n+        // library produced by LLVM with an ordinal of 0, and it generates an .EXE.  (I don't know yet\n+        // if the resulting EXE runs, as I haven't yet built the necessary DLL -- see earlier comment\n+        // about LINK.EXE failing.)\n+        if *ordinal <= u16::MAX as u128 {\n+            Some(*ordinal as u16)\n+        } else {\n+            let msg = format!(\"ordinal value in `link_ordinal` is too large: `{}`\", &ordinal);\n+            tcx.sess\n+                .struct_span_err(attr.span, &msg)\n+                .note(\"the value may not exceed `u16::MAX`\")\n+                .emit();\n+            None\n+        }\n+    } else {\n+        tcx.sess\n+            .struct_span_err(attr.span, \"illegal ordinal format in `link_ordinal`\")\n+            .note(\"an unsuffixed integer value, e.g., `1`, is expected\")\n+            .emit();\n+        None\n+    }\n+}\n+\n+fn check_link_name_xor_ordinal(\n+    tcx: TyCtxt<'_>,\n+    codegen_fn_attrs: &CodegenFnAttrs,\n+    inline_span: Option<Span>,\n+) {\n+    if codegen_fn_attrs.link_name.is_none() || codegen_fn_attrs.link_ordinal.is_none() {\n+        return;\n+    }\n+    let msg = \"cannot use `#[link_name]` with `#[link_ordinal]`\";\n+    if let Some(span) = inline_span {\n+        tcx.sess.span_err(span, msg);\n+    } else {\n+        tcx.sess.err(msg);\n+    }\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers { codegen_fn_attrs, should_inherit_track_caller, ..*providers };\n+}"}, {"sha": "0620000201f0254f81ff6dd4200876324b02fd0a", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=a8a45100a0593ed0c39ebe1b601be765a8f5fd5c", "patch": "@@ -548,3 +548,10 @@ pub struct ArchiveBuildFailure {\n pub struct UnknownArchiveKind<'a> {\n     pub kind: &'a str,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_expected_used_symbol)]\n+pub struct ExpectedUsedSymbol {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "0e6596d4ba781bfd7a859a0329105f26a7a2ef60", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=a8a45100a0593ed0c39ebe1b601be765a8f5fd5c", "patch": "@@ -42,6 +42,7 @@ use std::path::{Path, PathBuf};\n \n pub mod back;\n pub mod base;\n+pub mod codegen_attrs;\n pub mod common;\n pub mod coverageinfo;\n pub mod debuginfo;\n@@ -180,6 +181,7 @@ pub fn provide(providers: &mut Providers) {\n     crate::back::symbol_export::provide(providers);\n     crate::base::provide(providers);\n     crate::target_features::provide(providers);\n+    crate::codegen_attrs::provide(providers);\n }\n \n pub fn provide_extern(providers: &mut ExternProviders) {"}, {"sha": "0dabe96b60277e032ad0214d2260277915f6a02d", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 154, "deletions": 10, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=a8a45100a0593ed0c39ebe1b601be765a8f5fd5c", "patch": "@@ -1,8 +1,19 @@\n+use rustc_ast::ast;\n+use rustc_attr::InstructionSetAttr;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n \n /// Features that control behaviour of rustc, rather than the codegen.\n pub const RUSTC_SPECIFIC_FEATURES: &[&str] = &[\"crt-static\"];\n@@ -322,15 +333,148 @@ pub fn tied_target_features(sess: &Session) -> &'static [&'static [&'static str]\n     }\n }\n \n-pub(crate) fn provide(providers: &mut Providers) {\n-    providers.supported_target_features = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        if tcx.sess.opts.actually_rustdoc {\n-            // rustdoc needs to be able to document functions that use all the features, so\n-            // whitelist them all\n-            all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n-        } else {\n-            supported_target_features(tcx.sess).iter().map(|&(a, b)| (a.to_string(), b)).collect()\n-        }\n+pub fn from_target_feature(\n+    tcx: TyCtxt<'_>,\n+    attr: &ast::Attribute,\n+    supported_target_features: &FxHashMap<String, Option<Symbol>>,\n+    target_features: &mut Vec<Symbol>,\n+) {\n+    let Some(list) = attr.meta_item_list() else { return };\n+    let bad_item = |span| {\n+        let msg = \"malformed `target_feature` attribute input\";\n+        let code = \"enable = \\\"..\\\"\";\n+        tcx.sess\n+            .struct_span_err(span, msg)\n+            .span_suggestion(span, \"must be of the form\", code, Applicability::HasPlaceholders)\n+            .emit();\n     };\n+    let rust_features = tcx.features();\n+    for item in list {\n+        // Only `enable = ...` is accepted in the meta-item list.\n+        if !item.has_name(sym::enable) {\n+            bad_item(item.span());\n+            continue;\n+        }\n+\n+        // Must be of the form `enable = \"...\"` (a string).\n+        let Some(value) = item.value_str() else {\n+            bad_item(item.span());\n+            continue;\n+        };\n+\n+        // We allow comma separation to enable multiple features.\n+        target_features.extend(value.as_str().split(',').filter_map(|feature| {\n+            let Some(feature_gate) = supported_target_features.get(feature) else {\n+                let msg =\n+                    format!(\"the feature named `{}` is not valid for this target\", feature);\n+                let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n+                err.span_label(\n+                    item.span(),\n+                    format!(\"`{}` is not valid for this target\", feature),\n+                );\n+                if let Some(stripped) = feature.strip_prefix('+') {\n+                    let valid = supported_target_features.contains_key(stripped);\n+                    if valid {\n+                        err.help(\"consider removing the leading `+` in the feature name\");\n+                    }\n+                }\n+                err.emit();\n+                return None;\n+            };\n+\n+            // Only allow features whose feature gates have been enabled.\n+            let allowed = match feature_gate.as_ref().copied() {\n+                Some(sym::arm_target_feature) => rust_features.arm_target_feature,\n+                Some(sym::hexagon_target_feature) => rust_features.hexagon_target_feature,\n+                Some(sym::powerpc_target_feature) => rust_features.powerpc_target_feature,\n+                Some(sym::mips_target_feature) => rust_features.mips_target_feature,\n+                Some(sym::riscv_target_feature) => rust_features.riscv_target_feature,\n+                Some(sym::avx512_target_feature) => rust_features.avx512_target_feature,\n+                Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,\n+                Some(sym::tbm_target_feature) => rust_features.tbm_target_feature,\n+                Some(sym::wasm_target_feature) => rust_features.wasm_target_feature,\n+                Some(sym::cmpxchg16b_target_feature) => rust_features.cmpxchg16b_target_feature,\n+                Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n+                Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n+                Some(sym::f16c_target_feature) => rust_features.f16c_target_feature,\n+                Some(sym::ermsb_target_feature) => rust_features.ermsb_target_feature,\n+                Some(sym::bpf_target_feature) => rust_features.bpf_target_feature,\n+                Some(sym::aarch64_ver_target_feature) => rust_features.aarch64_ver_target_feature,\n+                Some(name) => bug!(\"unknown target feature gate {}\", name),\n+                None => true,\n+            };\n+            if !allowed {\n+                feature_err(\n+                    &tcx.sess.parse_sess,\n+                    feature_gate.unwrap(),\n+                    item.span(),\n+                    &format!(\"the target feature `{}` is currently unstable\", feature),\n+                )\n+                .emit();\n+            }\n+            Some(Symbol::intern(feature))\n+        }));\n+    }\n+}\n+\n+/// Computes the set of target features used in a function for the purposes of\n+/// inline assembly.\n+fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, did: DefId) -> &'tcx FxHashSet<Symbol> {\n+    let mut target_features = tcx.sess.unstable_target_features.clone();\n+    if tcx.def_kind(did).has_codegen_attrs() {\n+        let attrs = tcx.codegen_fn_attrs(did);\n+        target_features.extend(&attrs.target_features);\n+        match attrs.instruction_set {\n+            None => {}\n+            Some(InstructionSetAttr::ArmA32) => {\n+                target_features.remove(&sym::thumb_mode);\n+            }\n+            Some(InstructionSetAttr::ArmT32) => {\n+                target_features.insert(sym::thumb_mode);\n+            }\n+        }\n+    }\n+\n+    tcx.arena.alloc(target_features)\n+}\n+\n+/// Checks the function annotated with `#[target_feature]` is not a safe\n+/// trait method implementation, reporting an error if it is.\n+pub fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span: Span) {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n+    let node = tcx.hir().get(hir_id);\n+    if let hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) = node {\n+        let parent_id = tcx.hir().get_parent_item(hir_id);\n+        let parent_item = tcx.hir().expect_item(parent_id.def_id);\n+        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = parent_item.kind {\n+            tcx.sess\n+                .struct_span_err(\n+                    attr_span,\n+                    \"`#[target_feature(..)]` cannot be applied to safe trait method\",\n+                )\n+                .span_label(attr_span, \"cannot be applied to safe trait method\")\n+                .span_label(tcx.def_span(id), \"not an `unsafe` function\")\n+                .emit();\n+        }\n+    }\n+}\n+\n+pub(crate) fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        supported_target_features: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            if tcx.sess.opts.actually_rustdoc {\n+                // rustdoc needs to be able to document functions that use all the features, so\n+                // whitelist them all\n+                all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n+            } else {\n+                supported_target_features(tcx.sess)\n+                    .iter()\n+                    .map(|&(a, b)| (a.to_string(), b))\n+                    .collect()\n+            }\n+        },\n+        asm_target_features,\n+        ..*providers\n+    }\n }"}, {"sha": "db4c82b35c77822d718d16039112205dada7972c", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=a8a45100a0593ed0c39ebe1b601be765a8f5fd5c", "patch": "@@ -192,3 +192,5 @@ codegen_ssa_archive_build_failure =\n \n codegen_ssa_unknown_archive_kind =\n     Don't know how to build archive of type: {$kind}\n+\n+codegen_ssa_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`"}, {"sha": "e33323a7795369bf6ccf2b77c0299b0e9b7600d2", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=a8a45100a0593ed0c39ebe1b601be765a8f5fd5c", "patch": "@@ -101,8 +101,6 @@ hir_analysis_extern_crate_not_idiomatic =\n     `extern crate` is not idiomatic in the new edition\n     .suggestion = convert it to a `{$msg_code}`\n \n-hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n-\n hir_analysis_const_impl_for_non_const_trait =\n     const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n     .suggestion = mark `{$trait_name}` as const"}, {"sha": "1eeaaf55e63af0f43a8e84884140294fe0e3f846", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 4, "deletions": 809, "changes": 813, "blob_url": "https://github.com/rust-lang/rust/blob/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=a8a45100a0593ed0c39ebe1b601be765a8f5fd5c", "patch": "@@ -17,28 +17,20 @@\n use crate::astconv::AstConv;\n use crate::check::intrinsic::intrinsic_operation_unsafety;\n use crate::errors;\n-use rustc_ast as ast;\n-use rustc_ast::{MetaItemKind, NestedMetaItem};\n-use rustc_attr::{list_contains_name, InlineAttr, InstructionSetAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::weak_lang_items::WEAK_LANG_ITEMS;\n-use rustc_hir::{lang_items, GenericParamKind, LangItem, Node};\n+use rustc_hir::{GenericParamKind, Node};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n-use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n-use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, IsSuggestable, ToPredicate, Ty, TyCtxt};\n-use rustc_session::lint;\n-use rustc_session::parse::feature_err;\n+use rustc_middle::ty::{self, AdtKind, Const, IsSuggestable, ToPredicate, Ty, TyCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n-use rustc_target::spec::{abi, SanitizerSet};\n+use rustc_target::spec::abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n use std::iter;\n \n@@ -78,10 +70,7 @@ pub fn provide(providers: &mut Providers) {\n         impl_polarity,\n         is_foreign_item,\n         generator_kind,\n-        codegen_fn_attrs,\n-        asm_target_features,\n         collect_mod_item_types,\n-        should_inherit_track_caller,\n         ..*providers\n     };\n }\n@@ -1455,797 +1444,3 @@ fn generator_kind(tcx: TyCtxt<'_>, def_id: DefId) -> Option<hir::GeneratorKind>\n         _ => bug!(\"generator_kind applied to non-local def-id {:?}\", def_id),\n     }\n }\n-\n-fn from_target_feature(\n-    tcx: TyCtxt<'_>,\n-    attr: &ast::Attribute,\n-    supported_target_features: &FxHashMap<String, Option<Symbol>>,\n-    target_features: &mut Vec<Symbol>,\n-) {\n-    let Some(list) = attr.meta_item_list() else { return };\n-    let bad_item = |span| {\n-        let msg = \"malformed `target_feature` attribute input\";\n-        let code = \"enable = \\\"..\\\"\";\n-        tcx.sess\n-            .struct_span_err(span, msg)\n-            .span_suggestion(span, \"must be of the form\", code, Applicability::HasPlaceholders)\n-            .emit();\n-    };\n-    let rust_features = tcx.features();\n-    for item in list {\n-        // Only `enable = ...` is accepted in the meta-item list.\n-        if !item.has_name(sym::enable) {\n-            bad_item(item.span());\n-            continue;\n-        }\n-\n-        // Must be of the form `enable = \"...\"` (a string).\n-        let Some(value) = item.value_str() else {\n-            bad_item(item.span());\n-            continue;\n-        };\n-\n-        // We allow comma separation to enable multiple features.\n-        target_features.extend(value.as_str().split(',').filter_map(|feature| {\n-            let Some(feature_gate) = supported_target_features.get(feature) else {\n-                let msg =\n-                    format!(\"the feature named `{}` is not valid for this target\", feature);\n-                let mut err = tcx.sess.struct_span_err(item.span(), &msg);\n-                err.span_label(\n-                    item.span(),\n-                    format!(\"`{}` is not valid for this target\", feature),\n-                );\n-                if let Some(stripped) = feature.strip_prefix('+') {\n-                    let valid = supported_target_features.contains_key(stripped);\n-                    if valid {\n-                        err.help(\"consider removing the leading `+` in the feature name\");\n-                    }\n-                }\n-                err.emit();\n-                return None;\n-            };\n-\n-            // Only allow features whose feature gates have been enabled.\n-            let allowed = match feature_gate.as_ref().copied() {\n-                Some(sym::arm_target_feature) => rust_features.arm_target_feature,\n-                Some(sym::hexagon_target_feature) => rust_features.hexagon_target_feature,\n-                Some(sym::powerpc_target_feature) => rust_features.powerpc_target_feature,\n-                Some(sym::mips_target_feature) => rust_features.mips_target_feature,\n-                Some(sym::riscv_target_feature) => rust_features.riscv_target_feature,\n-                Some(sym::avx512_target_feature) => rust_features.avx512_target_feature,\n-                Some(sym::sse4a_target_feature) => rust_features.sse4a_target_feature,\n-                Some(sym::tbm_target_feature) => rust_features.tbm_target_feature,\n-                Some(sym::wasm_target_feature) => rust_features.wasm_target_feature,\n-                Some(sym::cmpxchg16b_target_feature) => rust_features.cmpxchg16b_target_feature,\n-                Some(sym::movbe_target_feature) => rust_features.movbe_target_feature,\n-                Some(sym::rtm_target_feature) => rust_features.rtm_target_feature,\n-                Some(sym::f16c_target_feature) => rust_features.f16c_target_feature,\n-                Some(sym::ermsb_target_feature) => rust_features.ermsb_target_feature,\n-                Some(sym::bpf_target_feature) => rust_features.bpf_target_feature,\n-                Some(sym::aarch64_ver_target_feature) => rust_features.aarch64_ver_target_feature,\n-                Some(name) => bug!(\"unknown target feature gate {}\", name),\n-                None => true,\n-            };\n-            if !allowed {\n-                feature_err(\n-                    &tcx.sess.parse_sess,\n-                    feature_gate.unwrap(),\n-                    item.span(),\n-                    &format!(\"the target feature `{}` is currently unstable\", feature),\n-                )\n-                .emit();\n-            }\n-            Some(Symbol::intern(feature))\n-        }));\n-    }\n-}\n-\n-fn linkage_by_name(tcx: TyCtxt<'_>, def_id: LocalDefId, name: &str) -> Linkage {\n-    use rustc_middle::mir::mono::Linkage::*;\n-\n-    // Use the names from src/llvm/docs/LangRef.rst here. Most types are only\n-    // applicable to variable declarations and may not really make sense for\n-    // Rust code in the first place but allow them anyway and trust that the\n-    // user knows what they're doing. Who knows, unanticipated use cases may pop\n-    // up in the future.\n-    //\n-    // ghost, dllimport, dllexport and linkonce_odr_autohide are not supported\n-    // and don't have to be, LLVM treats them as no-ops.\n-    match name {\n-        \"appending\" => Appending,\n-        \"available_externally\" => AvailableExternally,\n-        \"common\" => Common,\n-        \"extern_weak\" => ExternalWeak,\n-        \"external\" => External,\n-        \"internal\" => Internal,\n-        \"linkonce\" => LinkOnceAny,\n-        \"linkonce_odr\" => LinkOnceODR,\n-        \"private\" => Private,\n-        \"weak\" => WeakAny,\n-        \"weak_odr\" => WeakODR,\n-        _ => tcx.sess.span_fatal(tcx.def_span(def_id), \"invalid linkage specified\"),\n-    }\n-}\n-\n-fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n-    if cfg!(debug_assertions) {\n-        let def_kind = tcx.def_kind(did);\n-        assert!(\n-            def_kind.has_codegen_attrs(),\n-            \"unexpected `def_kind` in `codegen_fn_attrs`: {def_kind:?}\",\n-        );\n-    }\n-\n-    let did = did.expect_local();\n-    let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(did));\n-    let mut codegen_fn_attrs = CodegenFnAttrs::new();\n-    if tcx.should_inherit_track_caller(did) {\n-        codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n-    }\n-\n-    let supported_target_features = tcx.supported_target_features(LOCAL_CRATE);\n-\n-    let mut inline_span = None;\n-    let mut link_ordinal_span = None;\n-    let mut no_sanitize_span = None;\n-    for attr in attrs.iter() {\n-        if attr.has_name(sym::cold) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n-        } else if attr.has_name(sym::rustc_allocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-        } else if attr.has_name(sym::ffi_returns_twice) {\n-            if tcx.is_foreign_item(did) {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n-            } else {\n-                // `#[ffi_returns_twice]` is only allowed `extern fn`s.\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0724,\n-                    \"`#[ffi_returns_twice]` may only be used on foreign functions\"\n-                )\n-                .emit();\n-            }\n-        } else if attr.has_name(sym::ffi_pure) {\n-            if tcx.is_foreign_item(did) {\n-                if attrs.iter().any(|a| a.has_name(sym::ffi_const)) {\n-                    // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        attr.span,\n-                        E0757,\n-                        \"`#[ffi_const]` function cannot be `#[ffi_pure]`\"\n-                    )\n-                    .emit();\n-                } else {\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE;\n-                }\n-            } else {\n-                // `#[ffi_pure]` is only allowed on foreign functions\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0755,\n-                    \"`#[ffi_pure]` may only be used on foreign functions\"\n-                )\n-                .emit();\n-            }\n-        } else if attr.has_name(sym::ffi_const) {\n-            if tcx.is_foreign_item(did) {\n-                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n-            } else {\n-                // `#[ffi_const]` is only allowed on foreign functions\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0756,\n-                    \"`#[ffi_const]` may only be used on foreign functions\"\n-                )\n-                .emit();\n-            }\n-        } else if attr.has_name(sym::rustc_nounwind) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n-        } else if attr.has_name(sym::rustc_reallocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::REALLOCATOR;\n-        } else if attr.has_name(sym::rustc_deallocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::DEALLOCATOR;\n-        } else if attr.has_name(sym::rustc_allocator_zeroed) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR_ZEROED;\n-        } else if attr.has_name(sym::naked) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n-        } else if attr.has_name(sym::no_mangle) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-        } else if attr.has_name(sym::no_coverage) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n-        } else if attr.has_name(sym::rustc_std_internal_symbol) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-        } else if attr.has_name(sym::used) {\n-            let inner = attr.meta_item_list();\n-            match inner.as_deref() {\n-                Some([item]) if item.has_name(sym::linker) => {\n-                    if !tcx.features().used_with_arg {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::used_with_arg,\n-                            attr.span,\n-                            \"`#[used(linker)]` is currently unstable\",\n-                        )\n-                        .emit();\n-                    }\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED_LINKER;\n-                }\n-                Some([item]) if item.has_name(sym::compiler) => {\n-                    if !tcx.features().used_with_arg {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::used_with_arg,\n-                            attr.span,\n-                            \"`#[used(compiler)]` is currently unstable\",\n-                        )\n-                        .emit();\n-                    }\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n-                }\n-                Some(_) => {\n-                    tcx.sess.emit_err(errors::ExpectedUsedSymbol { span: attr.span });\n-                }\n-                None => {\n-                    // Unfortunately, unconditionally using `llvm.used` causes\n-                    // issues in handling `.init_array` with the gold linker,\n-                    // but using `llvm.compiler.used` caused a nontrival amount\n-                    // of unintentional ecosystem breakage -- particularly on\n-                    // Mach-O targets.\n-                    //\n-                    // As a result, we emit `llvm.compiler.used` only on ELF\n-                    // targets. This is somewhat ad-hoc, but actually follows\n-                    // our pre-LLVM 13 behavior (prior to the ecosystem\n-                    // breakage), and seems to match `clang`'s behavior as well\n-                    // (both before and after LLVM 13), possibly because they\n-                    // have similar compatibility concerns to us. See\n-                    // https://github.com/rust-lang/rust/issues/47384#issuecomment-1019080146\n-                    // and following comments for some discussion of this, as\n-                    // well as the comments in `rustc_codegen_llvm` where these\n-                    // flags are handled.\n-                    //\n-                    // Anyway, to be clear: this is still up in the air\n-                    // somewhat, and is subject to change in the future (which\n-                    // is a good thing, because this would ideally be a bit\n-                    // more firmed up).\n-                    let is_like_elf = !(tcx.sess.target.is_like_osx\n-                        || tcx.sess.target.is_like_windows\n-                        || tcx.sess.target.is_like_wasm);\n-                    codegen_fn_attrs.flags |= if is_like_elf {\n-                        CodegenFnAttrFlags::USED\n-                    } else {\n-                        CodegenFnAttrFlags::USED_LINKER\n-                    };\n-                }\n-            }\n-        } else if attr.has_name(sym::cmse_nonsecure_entry) {\n-            if !matches!(tcx.fn_sig(did).abi(), abi::Abi::C { .. }) {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0776,\n-                    \"`#[cmse_nonsecure_entry]` requires C ABI\"\n-                )\n-                .emit();\n-            }\n-            if !tcx.sess.target.llvm_target.contains(\"thumbv8m\") {\n-                struct_span_err!(tcx.sess, attr.span, E0775, \"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M extension\")\n-                    .emit();\n-            }\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY;\n-        } else if attr.has_name(sym::thread_local) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n-        } else if attr.has_name(sym::track_caller) {\n-            if !tcx.is_closure(did.to_def_id()) && tcx.fn_sig(did).abi() != abi::Abi::Rust {\n-                struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n-                    .emit();\n-            }\n-            if tcx.is_closure(did.to_def_id()) && !tcx.features().closure_track_caller {\n-                feature_err(\n-                    &tcx.sess.parse_sess,\n-                    sym::closure_track_caller,\n-                    attr.span,\n-                    \"`#[track_caller]` on closures is currently unstable\",\n-                )\n-                .emit();\n-            }\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n-        } else if attr.has_name(sym::export_name) {\n-            if let Some(s) = attr.value_str() {\n-                if s.as_str().contains('\\0') {\n-                    // `#[export_name = ...]` will be converted to a null-terminated string,\n-                    // so it may not contain any null characters.\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        attr.span,\n-                        E0648,\n-                        \"`export_name` may not contain null characters\"\n-                    )\n-                    .emit();\n-                }\n-                codegen_fn_attrs.export_name = Some(s);\n-            }\n-        } else if attr.has_name(sym::target_feature) {\n-            if !tcx.is_closure(did.to_def_id())\n-                && tcx.fn_sig(did).unsafety() == hir::Unsafety::Normal\n-            {\n-                if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n-                    // The `#[target_feature]` attribute is allowed on\n-                    // WebAssembly targets on all functions, including safe\n-                    // ones. Other targets require that `#[target_feature]` is\n-                    // only applied to unsafe functions (pending the\n-                    // `target_feature_11` feature) because on most targets\n-                    // execution of instructions that are not supported is\n-                    // considered undefined behavior. For WebAssembly which is a\n-                    // 100% safe target at execution time it's not possible to\n-                    // execute undefined instructions, and even if a future\n-                    // feature was added in some form for this it would be a\n-                    // deterministic trap. There is no undefined behavior when\n-                    // executing WebAssembly so `#[target_feature]` is allowed\n-                    // on safe functions (but again, only for WebAssembly)\n-                    //\n-                    // Note that this is also allowed if `actually_rustdoc` so\n-                    // if a target is documenting some wasm-specific code then\n-                    // it's not spuriously denied.\n-                } else if !tcx.features().target_feature_11 {\n-                    let mut err = feature_err(\n-                        &tcx.sess.parse_sess,\n-                        sym::target_feature_11,\n-                        attr.span,\n-                        \"`#[target_feature(..)]` can only be applied to `unsafe` functions\",\n-                    );\n-                    err.span_label(tcx.def_span(did), \"not an `unsafe` function\");\n-                    err.emit();\n-                } else {\n-                    check_target_feature_trait_unsafe(tcx, did, attr.span);\n-                }\n-            }\n-            from_target_feature(\n-                tcx,\n-                attr,\n-                supported_target_features,\n-                &mut codegen_fn_attrs.target_features,\n-            );\n-        } else if attr.has_name(sym::linkage) {\n-            if let Some(val) = attr.value_str() {\n-                let linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n-                if tcx.is_foreign_item(did) {\n-                    codegen_fn_attrs.import_linkage = linkage;\n-                } else {\n-                    codegen_fn_attrs.linkage = linkage;\n-                }\n-            }\n-        } else if attr.has_name(sym::link_section) {\n-            if let Some(val) = attr.value_str() {\n-                if val.as_str().bytes().any(|b| b == 0) {\n-                    let msg = format!(\n-                        \"illegal null byte in link_section \\\n-                         value: `{}`\",\n-                        &val\n-                    );\n-                    tcx.sess.span_err(attr.span, &msg);\n-                } else {\n-                    codegen_fn_attrs.link_section = Some(val);\n-                }\n-            }\n-        } else if attr.has_name(sym::link_name) {\n-            codegen_fn_attrs.link_name = attr.value_str();\n-        } else if attr.has_name(sym::link_ordinal) {\n-            link_ordinal_span = Some(attr.span);\n-            if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n-                codegen_fn_attrs.link_ordinal = ordinal;\n-            }\n-        } else if attr.has_name(sym::no_sanitize) {\n-            no_sanitize_span = Some(attr.span);\n-            if let Some(list) = attr.meta_item_list() {\n-                for item in list.iter() {\n-                    if item.has_name(sym::address) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::ADDRESS;\n-                    } else if item.has_name(sym::cfi) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n-                    } else if item.has_name(sym::kcfi) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI;\n-                    } else if item.has_name(sym::memory) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n-                    } else if item.has_name(sym::memtag) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMTAG;\n-                    } else if item.has_name(sym::shadow_call_stack) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::SHADOWCALLSTACK;\n-                    } else if item.has_name(sym::thread) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD;\n-                    } else if item.has_name(sym::hwaddress) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS;\n-                    } else {\n-                        tcx.sess\n-                            .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n-                            .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n-                            .emit();\n-                    }\n-                }\n-            }\n-        } else if attr.has_name(sym::instruction_set) {\n-            codegen_fn_attrs.instruction_set = match attr.meta_kind() {\n-                Some(MetaItemKind::List(ref items)) => match items.as_slice() {\n-                    [NestedMetaItem::MetaItem(set)] => {\n-                        let segments =\n-                            set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n-                        match segments.as_slice() {\n-                            [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n-                                if !tcx.sess.target.has_thumb_interworking {\n-                                    struct_span_err!(\n-                                        tcx.sess.diagnostic(),\n-                                        attr.span,\n-                                        E0779,\n-                                        \"target does not support `#[instruction_set]`\"\n-                                    )\n-                                    .emit();\n-                                    None\n-                                } else if segments[1] == sym::a32 {\n-                                    Some(InstructionSetAttr::ArmA32)\n-                                } else if segments[1] == sym::t32 {\n-                                    Some(InstructionSetAttr::ArmT32)\n-                                } else {\n-                                    unreachable!()\n-                                }\n-                            }\n-                            _ => {\n-                                struct_span_err!(\n-                                    tcx.sess.diagnostic(),\n-                                    attr.span,\n-                                    E0779,\n-                                    \"invalid instruction set specified\",\n-                                )\n-                                .emit();\n-                                None\n-                            }\n-                        }\n-                    }\n-                    [] => {\n-                        struct_span_err!(\n-                            tcx.sess.diagnostic(),\n-                            attr.span,\n-                            E0778,\n-                            \"`#[instruction_set]` requires an argument\"\n-                        )\n-                        .emit();\n-                        None\n-                    }\n-                    _ => {\n-                        struct_span_err!(\n-                            tcx.sess.diagnostic(),\n-                            attr.span,\n-                            E0779,\n-                            \"cannot specify more than one instruction set\"\n-                        )\n-                        .emit();\n-                        None\n-                    }\n-                },\n-                _ => {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        attr.span,\n-                        E0778,\n-                        \"must specify an instruction set\"\n-                    )\n-                    .emit();\n-                    None\n-                }\n-            };\n-        } else if attr.has_name(sym::repr) {\n-            codegen_fn_attrs.alignment = match attr.meta_item_list() {\n-                Some(items) => match items.as_slice() {\n-                    [item] => match item.name_value_literal() {\n-                        Some((sym::align, literal)) => {\n-                            let alignment = rustc_attr::parse_alignment(&literal.kind);\n-\n-                            match alignment {\n-                                Ok(align) => Some(align),\n-                                Err(msg) => {\n-                                    struct_span_err!(\n-                                        tcx.sess.diagnostic(),\n-                                        attr.span,\n-                                        E0589,\n-                                        \"invalid `repr(align)` attribute: {}\",\n-                                        msg\n-                                    )\n-                                    .emit();\n-\n-                                    None\n-                                }\n-                            }\n-                        }\n-                        _ => None,\n-                    },\n-                    [] => None,\n-                    _ => None,\n-                },\n-                None => None,\n-            };\n-        }\n-    }\n-\n-    codegen_fn_attrs.inline = attrs.iter().fold(InlineAttr::None, |ia, attr| {\n-        if !attr.has_name(sym::inline) {\n-            return ia;\n-        }\n-        match attr.meta_kind() {\n-            Some(MetaItemKind::Word) => InlineAttr::Hint,\n-            Some(MetaItemKind::List(ref items)) => {\n-                inline_span = Some(attr.span);\n-                if items.len() != 1 {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        attr.span,\n-                        E0534,\n-                        \"expected one argument\"\n-                    )\n-                    .emit();\n-                    InlineAttr::None\n-                } else if list_contains_name(&items, sym::always) {\n-                    InlineAttr::Always\n-                } else if list_contains_name(&items, sym::never) {\n-                    InlineAttr::Never\n-                } else {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        items[0].span(),\n-                        E0535,\n-                        \"invalid argument\"\n-                    )\n-                    .help(\"valid inline arguments are `always` and `never`\")\n-                    .emit();\n-\n-                    InlineAttr::None\n-                }\n-            }\n-            Some(MetaItemKind::NameValue(_)) => ia,\n-            None => ia,\n-        }\n-    });\n-\n-    codegen_fn_attrs.optimize = attrs.iter().fold(OptimizeAttr::None, |ia, attr| {\n-        if !attr.has_name(sym::optimize) {\n-            return ia;\n-        }\n-        let err = |sp, s| struct_span_err!(tcx.sess.diagnostic(), sp, E0722, \"{}\", s).emit();\n-        match attr.meta_kind() {\n-            Some(MetaItemKind::Word) => {\n-                err(attr.span, \"expected one argument\");\n-                ia\n-            }\n-            Some(MetaItemKind::List(ref items)) => {\n-                inline_span = Some(attr.span);\n-                if items.len() != 1 {\n-                    err(attr.span, \"expected one argument\");\n-                    OptimizeAttr::None\n-                } else if list_contains_name(&items, sym::size) {\n-                    OptimizeAttr::Size\n-                } else if list_contains_name(&items, sym::speed) {\n-                    OptimizeAttr::Speed\n-                } else {\n-                    err(items[0].span(), \"invalid argument\");\n-                    OptimizeAttr::None\n-                }\n-            }\n-            Some(MetaItemKind::NameValue(_)) => ia,\n-            None => ia,\n-        }\n-    });\n-\n-    // #73631: closures inherit `#[target_feature]` annotations\n-    if tcx.features().target_feature_11 && tcx.is_closure(did.to_def_id()) {\n-        let owner_id = tcx.parent(did.to_def_id());\n-        if tcx.def_kind(owner_id).has_codegen_attrs() {\n-            codegen_fn_attrs\n-                .target_features\n-                .extend(tcx.codegen_fn_attrs(owner_id).target_features.iter().copied());\n-        }\n-    }\n-\n-    // If a function uses #[target_feature] it can't be inlined into general\n-    // purpose functions as they wouldn't have the right target features\n-    // enabled. For that reason we also forbid #[inline(always)] as it can't be\n-    // respected.\n-    if !codegen_fn_attrs.target_features.is_empty() {\n-        if codegen_fn_attrs.inline == InlineAttr::Always {\n-            if let Some(span) = inline_span {\n-                tcx.sess.span_err(\n-                    span,\n-                    \"cannot use `#[inline(always)]` with \\\n-                     `#[target_feature]`\",\n-                );\n-            }\n-        }\n-    }\n-\n-    if !codegen_fn_attrs.no_sanitize.is_empty() {\n-        if codegen_fn_attrs.inline == InlineAttr::Always {\n-            if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n-                let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n-                tcx.struct_span_lint_hir(\n-                    lint::builtin::INLINE_NO_SANITIZE,\n-                    hir_id,\n-                    no_sanitize_span,\n-                    \"`no_sanitize` will have no effect after inlining\",\n-                    |lint| lint.span_note(inline_span, \"inlining requested here\"),\n-                )\n-            }\n-        }\n-    }\n-\n-    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n-        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n-        codegen_fn_attrs.inline = InlineAttr::Never;\n-    }\n-\n-    // Weak lang items have the same semantics as \"std internal\" symbols in the\n-    // sense that they're preserved through all our LTO passes and only\n-    // strippable by the linker.\n-    //\n-    // Additionally weak lang items have predetermined symbol names.\n-    if WEAK_LANG_ITEMS.iter().any(|&l| tcx.lang_items().get(l) == Some(did.to_def_id())) {\n-        codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-    }\n-    if let Some((name, _)) = lang_items::extract(attrs)\n-        && let Some(lang_item) = LangItem::from_name(name)\n-        && let Some(link_name) = lang_item.link_name()\n-    {\n-        codegen_fn_attrs.export_name = Some(link_name);\n-        codegen_fn_attrs.link_name = Some(link_name);\n-    }\n-    check_link_name_xor_ordinal(tcx, &codegen_fn_attrs, link_ordinal_span);\n-\n-    // Internal symbols to the standard library all have no_mangle semantics in\n-    // that they have defined symbol names present in the function name. This\n-    // also applies to weak symbols where they all have known symbol names.\n-    if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n-        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-    }\n-\n-    // Any linkage to LLVM intrinsics for now forcibly marks them all as never\n-    // unwinds since LLVM sometimes can't handle codegen which `invoke`s\n-    // intrinsic functions.\n-    if let Some(name) = &codegen_fn_attrs.link_name {\n-        if name.as_str().starts_with(\"llvm.\") {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n-        }\n-    }\n-\n-    codegen_fn_attrs\n-}\n-\n-/// Computes the set of target features used in a function for the purposes of\n-/// inline assembly.\n-fn asm_target_features<'tcx>(tcx: TyCtxt<'tcx>, did: DefId) -> &'tcx FxHashSet<Symbol> {\n-    let mut target_features = tcx.sess.unstable_target_features.clone();\n-    if tcx.def_kind(did).has_codegen_attrs() {\n-        let attrs = tcx.codegen_fn_attrs(did);\n-        target_features.extend(&attrs.target_features);\n-        match attrs.instruction_set {\n-            None => {}\n-            Some(InstructionSetAttr::ArmA32) => {\n-                target_features.remove(&sym::thumb_mode);\n-            }\n-            Some(InstructionSetAttr::ArmT32) => {\n-                target_features.insert(sym::thumb_mode);\n-            }\n-        }\n-    }\n-\n-    tcx.arena.alloc(target_features)\n-}\n-\n-/// Checks if the provided DefId is a method in a trait impl for a trait which has track_caller\n-/// applied to the method prototype.\n-fn should_inherit_track_caller(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    if let Some(impl_item) = tcx.opt_associated_item(def_id)\n-        && let ty::AssocItemContainer::ImplContainer = impl_item.container\n-        && let Some(trait_item) = impl_item.trait_item_def_id\n-    {\n-        return tcx\n-            .codegen_fn_attrs(trait_item)\n-            .flags\n-            .intersects(CodegenFnAttrFlags::TRACK_CALLER);\n-    }\n-\n-    false\n-}\n-\n-fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n-    use rustc_ast::{LitIntType, LitKind, MetaItemLit};\n-    if !tcx.features().raw_dylib && tcx.sess.target.arch == \"x86\" {\n-        feature_err(\n-            &tcx.sess.parse_sess,\n-            sym::raw_dylib,\n-            attr.span,\n-            \"`#[link_ordinal]` is unstable on x86\",\n-        )\n-        .emit();\n-    }\n-    let meta_item_list = attr.meta_item_list();\n-    let meta_item_list = meta_item_list.as_deref();\n-    let sole_meta_list = match meta_item_list {\n-        Some([item]) => item.lit(),\n-        Some(_) => {\n-            tcx.sess\n-                .struct_span_err(attr.span, \"incorrect number of arguments to `#[link_ordinal]`\")\n-                .note(\"the attribute requires exactly one argument\")\n-                .emit();\n-            return None;\n-        }\n-        _ => None,\n-    };\n-    if let Some(MetaItemLit { kind: LitKind::Int(ordinal, LitIntType::Unsuffixed), .. }) =\n-        sole_meta_list\n-    {\n-        // According to the table at https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-header,\n-        // the ordinal must fit into 16 bits.  Similarly, the Ordinal field in COFFShortExport (defined\n-        // in llvm/include/llvm/Object/COFFImportFile.h), which we use to communicate import information\n-        // to LLVM for `#[link(kind = \"raw-dylib\"_])`, is also defined to be uint16_t.\n-        //\n-        // FIXME: should we allow an ordinal of 0?  The MSVC toolchain has inconsistent support for this:\n-        // both LINK.EXE and LIB.EXE signal errors and abort when given a .DEF file that specifies\n-        // a zero ordinal.  However, llvm-dlltool is perfectly happy to generate an import library\n-        // for such a .DEF file, and MSVC's LINK.EXE is also perfectly happy to consume an import\n-        // library produced by LLVM with an ordinal of 0, and it generates an .EXE.  (I don't know yet\n-        // if the resulting EXE runs, as I haven't yet built the necessary DLL -- see earlier comment\n-        // about LINK.EXE failing.)\n-        if *ordinal <= u16::MAX as u128 {\n-            Some(*ordinal as u16)\n-        } else {\n-            let msg = format!(\"ordinal value in `link_ordinal` is too large: `{}`\", &ordinal);\n-            tcx.sess\n-                .struct_span_err(attr.span, &msg)\n-                .note(\"the value may not exceed `u16::MAX`\")\n-                .emit();\n-            None\n-        }\n-    } else {\n-        tcx.sess\n-            .struct_span_err(attr.span, \"illegal ordinal format in `link_ordinal`\")\n-            .note(\"an unsuffixed integer value, e.g., `1`, is expected\")\n-            .emit();\n-        None\n-    }\n-}\n-\n-fn check_link_name_xor_ordinal(\n-    tcx: TyCtxt<'_>,\n-    codegen_fn_attrs: &CodegenFnAttrs,\n-    inline_span: Option<Span>,\n-) {\n-    if codegen_fn_attrs.link_name.is_none() || codegen_fn_attrs.link_ordinal.is_none() {\n-        return;\n-    }\n-    let msg = \"cannot use `#[link_name]` with `#[link_ordinal]`\";\n-    if let Some(span) = inline_span {\n-        tcx.sess.span_err(span, msg);\n-    } else {\n-        tcx.sess.err(msg);\n-    }\n-}\n-\n-/// Checks the function annotated with `#[target_feature]` is not a safe\n-/// trait method implementation, reporting an error if it is.\n-fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span: Span) {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n-    let node = tcx.hir().get(hir_id);\n-    if let Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) = node {\n-        let parent_id = tcx.hir().get_parent_item(hir_id);\n-        let parent_item = tcx.hir().expect_item(parent_id.def_id);\n-        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = parent_item.kind {\n-            tcx.sess\n-                .struct_span_err(\n-                    attr_span,\n-                    \"`#[target_feature(..)]` cannot be applied to safe trait method\",\n-                )\n-                .span_label(attr_span, \"cannot be applied to safe trait method\")\n-                .span_label(tcx.def_span(id), \"not an `unsafe` function\")\n-                .emit();\n-        }\n-    }\n-}"}, {"sha": "d9697c63c56e1e8df9d2cfa2ceb5542b92a04ad8", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a45100a0593ed0c39ebe1b601be765a8f5fd5c/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=a8a45100a0593ed0c39ebe1b601be765a8f5fd5c", "patch": "@@ -253,13 +253,6 @@ pub struct ExternCrateNotIdiomatic {\n     pub suggestion_code: String,\n }\n \n-#[derive(Diagnostic)]\n-#[diag(hir_analysis_expected_used_symbol)]\n-pub struct ExpectedUsedSymbol {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(hir_analysis_const_impl_for_non_const_trait)]\n pub struct ConstImplForNonConstTrait {"}]}