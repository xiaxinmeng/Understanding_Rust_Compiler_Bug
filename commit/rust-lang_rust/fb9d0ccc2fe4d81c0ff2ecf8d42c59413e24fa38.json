{"sha": "fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiOWQwY2NjMmZlNGQ4MWMwZmYyZWNmOGQ0MmM1OTQxM2UyNGZhMzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-31T10:36:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-03T22:41:01Z"}, "message": "Move associated types into the Assoc space and add in the builtin bounds\nfrom the definition (including Sized).", "tree": {"sha": "782c85a3217d5f714d613704894896ce8831e6b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/782c85a3217d5f714d613704894896ce8831e6b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38", "html_url": "https://github.com/rust-lang/rust/commit/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2f8074eac9413d70610809ff62ea8b1ff82dc93", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2f8074eac9413d70610809ff62ea8b1ff82dc93", "html_url": "https://github.com/rust-lang/rust/commit/d2f8074eac9413d70610809ff62ea8b1ff82dc93"}], "stats": {"total": 452, "additions": 243, "deletions": 209}, "files": [{"sha": "bf9374399811918c800a756a9a4087620ebf2830", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38", "patch": "@@ -118,10 +118,11 @@ impl Substs {\n \n     pub fn new_trait(t: Vec<ty::t>,\n                      r: Vec<ty::Region>,\n+                     a: Vec<ty::t>,\n                      s: ty::t)\n                     -> Substs\n     {\n-        Substs::new(VecPerParamSpace::new(t, vec!(s), Vec::new(), Vec::new()),\n+        Substs::new(VecPerParamSpace::new(t, vec!(s), a, Vec::new()),\n                     VecPerParamSpace::new(r, Vec::new(), Vec::new(), Vec::new()))\n     }\n "}, {"sha": "abc36359a8564f03e1840bbe2cc3d17c10908f64", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38", "patch": "@@ -1683,6 +1683,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 vec![arguments_tuple.subst(self.tcx(), substs),\n                      new_signature.output.unwrap().subst(self.tcx(), substs)],\n                 vec![],\n+                vec![],\n                 obligation.self_ty())\n         });\n "}, {"sha": "8211fec505b9f245e44d695d2c34c231e8cefcdb", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38", "patch": "@@ -573,10 +573,6 @@ pub struct ctxt<'tcx> {\n     /// Maps def IDs to true if and only if they're associated types.\n     pub associated_types: RefCell<DefIdMap<bool>>,\n \n-    /// Maps def IDs of traits to information about their associated types.\n-    pub trait_associated_types:\n-        RefCell<DefIdMap<Rc<Vec<AssociatedTypeInfo>>>>,\n-\n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache,\n@@ -1564,7 +1560,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         stability: RefCell::new(stability),\n         capture_modes: capture_modes,\n         associated_types: RefCell::new(DefIdMap::new()),\n-        trait_associated_types: RefCell::new(DefIdMap::new()),\n         selection_cache: traits::SelectionCache::new(),\n         repr_hint_cache: RefCell::new(DefIdMap::new()),\n    }\n@@ -1994,6 +1989,16 @@ impl ItemSubsts {\n     }\n }\n \n+impl ParamBounds {\n+    pub fn empty() -> ParamBounds {\n+        ParamBounds {\n+            builtin_bounds: empty_builtin_bounds(),\n+            trait_bounds: Vec::new(),\n+            region_bounds: Vec::new(),\n+        }\n+    }\n+}\n+\n // Type utilities\n \n pub fn type_is_nil(ty: t) -> bool {\n@@ -4155,18 +4160,6 @@ impl Ord for AssociatedTypeInfo {\n     }\n }\n \n-/// Returns the associated types belonging to the given trait, in parameter\n-/// order.\n-pub fn associated_types_for_trait(cx: &ctxt, trait_id: ast::DefId)\n-                                  -> Rc<Vec<AssociatedTypeInfo>> {\n-    cx.trait_associated_types\n-      .borrow()\n-      .find(&trait_id)\n-      .expect(\"associated_types_for_trait(): trait not found, try calling \\\n-               ensure_associated_types()\")\n-      .clone()\n-}\n-\n pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n                           -> Rc<Vec<ImplOrTraitItemId>> {\n     lookup_locally_or_in_crate_store(\"trait_item_def_ids\","}, {"sha": "951ac795d80b2d06b27979e5bc72d97c46055fb9", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38", "patch": "@@ -54,7 +54,7 @@ use middle::def;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n use middle::lang_items::{FnOnceTraitLangItem};\n use middle::resolve_lifetime as rl;\n-use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n+use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n use middle::ty;\n use middle::typeck::lookup_def_tcx;\n@@ -215,7 +215,8 @@ fn ast_path_substs<'tcx,AC,RS>(\n                    associated_ty: Option<ty::t>,\n                    path: &ast::Path)\n                    -> Substs\n-                   where AC: AstConv<'tcx>, RS: RegionScope {\n+                   where AC: AstConv<'tcx>, RS: RegionScope\n+{\n     /*!\n      * Given a path `path` that refers to an item `I` with the\n      * declared generics `decl_generics`, returns an appropriate\n@@ -338,17 +339,21 @@ fn ast_path_substs<'tcx,AC,RS>(\n                 substs.types.push(TypeSpace, default);\n             }\n             None => {\n-                // This is an associated type.\n-                substs.types.push(\n-                    TypeSpace,\n-                    this.associated_type_binding(path.span,\n-                                                 associated_ty,\n-                                                 decl_def_id,\n-                                                 param.def_id))\n+                tcx.sess.span_bug(path.span,\n+                                  \"extra parameter without default\");\n             }\n         }\n     }\n \n+    for param in decl_generics.types.get_slice(AssocSpace).iter() {\n+        substs.types.push(\n+            AssocSpace,\n+            this.associated_type_binding(path.span,\n+                                         associated_ty,\n+                                         decl_def_id,\n+                                         param.def_id))\n+    }\n+\n     substs\n }\n \n@@ -628,9 +633,13 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         a_seq_ty: &ast::Ty,\n         ptr_ty: PointerTy,\n         constr: |ty::t| -> ty::t)\n-        -> ty::t {\n+        -> ty::t\n+{\n     let tcx = this.tcx();\n-    debug!(\"mk_pointer(ptr_ty={})\", ptr_ty);\n+\n+    debug!(\"mk_pointer(ptr_ty={}, a_seq_ty={})\",\n+           ptr_ty,\n+           a_seq_ty.repr(tcx));\n \n     match a_seq_ty.node {\n         ast::TyVec(ref ty) => {\n@@ -730,7 +739,13 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                    trait_type_id: ast::DefId,\n                                    span: Span)\n                                    -> ty::t\n-                                   where AC: AstConv<'tcx>, RS: RegionScope {\n+                                   where AC: AstConv<'tcx>, RS: RegionScope\n+{\n+    debug!(\"associated_ty_to_ty(trait_path={}, for_ast_type={}, trait_type_id={})\",\n+           trait_path.repr(this.tcx()),\n+           for_ast_type.repr(this.tcx()),\n+           trait_type_id.repr(this.tcx()));\n+\n     // Find the trait that this associated type belongs to.\n     let trait_did = match ty::impl_or_trait_item(this.tcx(),\n                                                  trait_type_id).container() {\n@@ -757,9 +772,16 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                           None,\n                                           Some(for_type),\n                                           trait_path);\n+\n+    debug!(\"associated_ty_to_ty(trait_ref={})\",\n+           trait_ref.repr(this.tcx()));\n+\n     let trait_def = this.get_trait_def(trait_did);\n     for type_parameter in trait_def.generics.types.iter() {\n         if type_parameter.def_id == trait_type_id {\n+            debug!(\"associated_ty_to_ty(type_parameter={} substs={})\",\n+                   type_parameter.repr(this.tcx()),\n+                   trait_ref.substs.repr(this.tcx()));\n             return *trait_ref.substs.types.get(type_parameter.space,\n                                                type_parameter.index)\n         }\n@@ -772,7 +794,10 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type.\n pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t {\n+        this: &AC, rscope: &RS, ast_ty: &ast::Ty) -> ty::t\n+{\n+    debug!(\"ast_ty_to_ty(ast_ty={})\",\n+           ast_ty.repr(this.tcx()));\n \n     let tcx = this.tcx();\n "}, {"sha": "863f09736ab2784f03de6aee31f8c11f0adc549f", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 119, "deletions": 159, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38", "patch": "@@ -305,6 +305,12 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                     }\n                                 });\n \n+                                debug!(\"ty_method_of_trait_method yielded {} \\\n+                                        for method {} of trait {}\",\n+                                       ty_method.repr(ccx.tcx),\n+                                       trait_item.repr(ccx.tcx),\n+                                       local_def(trait_id).repr(ccx.tcx));\n+\n                                 make_method_ty(ccx, &*ty_method);\n \n                                 tcx.impl_or_trait_items\n@@ -460,7 +466,7 @@ fn convert_associated_type(ccx: &CrateCtxt,\n     // associated type.\n     let type_parameter_def = trait_def.generics\n                                       .types\n-                                      .get_slice(subst::TypeSpace)\n+                                      .get_slice(subst::AssocSpace)\n                                       .iter()\n                                       .find(|def| {\n         def.def_id == local_def(associated_type.ty_param.id)\n@@ -475,7 +481,7 @@ fn convert_associated_type(ccx: &CrateCtxt,\n         }\n     };\n     let param_type = ty::mk_param(ccx.tcx,\n-                                  subst::TypeSpace,\n+                                  type_parameter_def.space,\n                                   type_parameter_def.index,\n                                   local_def(associated_type.ty_param.id));\n     ccx.tcx.tcache.borrow_mut().insert(local_def(associated_type.ty_param.id),\n@@ -780,25 +786,18 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n                                ty: Option<ty::t>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> ty::t {\n-        ensure_associated_types(self, trait_id);\n-        let associated_type_ids = ty::associated_types_for_trait(self.ccx.tcx,\n-                                                                 trait_id);\n+                               -> ty::t\n+    {\n+        let trait_def = ty::lookup_trait_def(self.tcx(), trait_id);\n         match self.opt_trait_ref_id {\n             Some(trait_ref_id) if trait_ref_id == trait_id => {\n                 // It's an associated type on the trait that we're\n                 // implementing.\n-                let associated_type_id =\n-                    associated_type_ids.iter()\n-                                       .find(|id| {\n-                                           id.def_id == associated_type_id\n-                                       })\n-                                       .expect(\"associated_type_binding(): \\\n-                                                expected associated type ID \\\n-                                                in trait\");\n-                let associated_type =\n-                    ty::impl_or_trait_item(self.ccx.tcx,\n-                                           associated_type_id.def_id);\n+                assert!(trait_def.generics.types\n+                        .get_slice(subst::AssocSpace)\n+                        .iter()\n+                        .any(|type_param_def| type_param_def.def_id == associated_type_id));\n+                let associated_type = ty::impl_or_trait_item(self.ccx.tcx, associated_type_id);\n                 for impl_item in self.impl_items.iter() {\n                     match *impl_item {\n                         ast::MethodImplItem(_) => {}\n@@ -980,7 +979,7 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n                     ast::TypeTraitItem(ref item) => {\n                         if local_def(item.ty_param.id) == associated_type_id {\n                             return ty::mk_param(self.tcx(),\n-                                                subst::TypeSpace,\n+                                                subst::AssocSpace,\n                                                 index,\n                                                 associated_type_id)\n                         }\n@@ -1451,7 +1450,8 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n                        trait_id: ast::NodeId,\n                        generics: &ast::Generics,\n                        items: &[ast::TraitItem])\n-                        -> subst::Substs {\n+                        -> subst::Substs\n+    {\n         // Creates a no-op substitution for the trait's type parameters.\n         let regions =\n             generics.lifetimes\n@@ -1464,32 +1464,35 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n                     .collect();\n \n         // Start with the generics in the type parameters...\n-        let mut types: Vec<_> =\n+        let types: Vec<_> =\n             generics.ty_params\n                     .iter()\n                     .enumerate()\n                     .map(|(i, def)| ty::mk_param(ccx.tcx, subst::TypeSpace,\n                                                  i, local_def(def.id)))\n                     .collect();\n \n-        // ...and add generics synthesized from the associated types.\n-        for item in items.iter() {\n-            match *item {\n+        // ...and also create generics synthesized from the associated types.\n+        let assoc_types: Vec<_> =\n+            items.iter()\n+            .flat_map(|item| match *item {\n                 ast::TypeTraitItem(ref trait_item) => {\n                     let index = types.len();\n-                    types.push(ty::mk_param(ccx.tcx,\n-                                            subst::TypeSpace,\n-                                            index,\n-                                            local_def(trait_item.ty_param.id)))\n+                    Some(ty::mk_param(ccx.tcx,\n+                                      subst::AssocSpace,\n+                                      index,\n+                                      local_def(trait_item.ty_param.id))).into_iter()\n                 }\n-                ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n-            }\n-        }\n+                ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {\n+                    None.into_iter()\n+                }\n+            })\n+            .collect();\n \n         let self_ty =\n             ty::mk_param(ccx.tcx, subst::SelfSpace, 0, local_def(trait_id));\n \n-        subst::Substs::new_trait(types, regions, self_ty)\n+        subst::Substs::new_trait(types, regions, assoc_types, self_ty)\n     }\n }\n \n@@ -1680,14 +1683,14 @@ fn ty_generics_for_trait(ccx: &CrateCtxt,\n                 let def =\n                     get_or_create_type_parameter_def(\n                         ccx,\n-                        subst::TypeSpace,\n+                        subst::AssocSpace,\n                         &associated_type.ty_param,\n                         generics.types.len(subst::TypeSpace),\n                         &ast_generics.where_clause,\n                         Some(local_def(trait_id)));\n                 ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.ty_param.id,\n                                                           def.clone());\n-                generics.types.push(subst::TypeSpace, def);\n+                generics.types.push(subst::AssocSpace, def);\n             }\n             ast::ProvidedMethod(_) | ast::RequiredMethod(_) => {}\n         }\n@@ -1786,86 +1789,17 @@ enum CreateTypeParametersForAssociatedTypesFlag {\n     CreateTypeParametersForAssociatedTypes,\n }\n \n-fn ensure_associated_types<'tcx,AC>(this: &AC, trait_id: ast::DefId)\n-                                    where AC: AstConv<'tcx> {\n-    if this.tcx().trait_associated_types.borrow().contains_key(&trait_id) {\n-        return\n-    }\n-\n-    if trait_id.krate == ast::LOCAL_CRATE {\n-        match this.tcx().map.find(trait_id.node) {\n-            Some(ast_map::NodeItem(item)) => {\n-                match item.node {\n-                    ast::ItemTrait(_, _, _, ref trait_items) => {\n-                        let mut result = Vec::new();\n-                        let mut index = 0;\n-                        for trait_item in trait_items.iter() {\n-                            match *trait_item {\n-                                ast::RequiredMethod(_) |\n-                                ast::ProvidedMethod(_) => {}\n-                                ast::TypeTraitItem(ref associated_type) => {\n-                                    let info = ty::AssociatedTypeInfo {\n-                                        def_id: local_def(associated_type.ty_param.id),\n-                                        index: index,\n-                                        name: associated_type.ty_param.ident.name,\n-                                    };\n-                                    result.push(info);\n-                                    index += 1;\n-                                }\n-                            }\n-                        }\n-                        this.tcx()\n-                            .trait_associated_types\n-                            .borrow_mut()\n-                            .insert(trait_id, Rc::new(result));\n-                        return\n-                    }\n-                    _ => {\n-                        this.tcx().sess.bug(\"ensure_associated_types() \\\n-                                             called on non-trait\")\n-                    }\n-                }\n-            }\n-            _ => {\n-                this.tcx().sess.bug(\"ensure_associated_types() called on \\\n-                                     non-trait\")\n-            }\n-        }\n-\n-    }\n-\n-    // Cross-crate case.\n-    let mut result = Vec::new();\n-    let mut index = 0;\n-    let trait_items = ty::trait_items(this.tcx(), trait_id);\n-    for trait_item in trait_items.iter() {\n-        match *trait_item {\n-            ty::MethodTraitItem(_) => {}\n-            ty::TypeTraitItem(ref associated_type) => {\n-                let info = ty::AssociatedTypeInfo {\n-                    def_id: associated_type.def_id,\n-                    index: index,\n-                    name: associated_type.name\n-                };\n-                result.push(info);\n-                index += 1;\n-            }\n-        }\n-    }\n-    this.tcx().trait_associated_types.borrow_mut().insert(trait_id,\n-                                                          Rc::new(result));\n-}\n-\n fn ty_generics<'tcx,AC>(this: &AC,\n                         space: subst::ParamSpace,\n                         lifetime_defs: &[ast::LifetimeDef],\n                         types: &[ast::TyParam],\n                         base_generics: ty::Generics,\n                         where_clause: &ast::WhereClause,\n-                        create_type_parameters_for_associated_types:\n+                        create_type_parameters_for_associated_types_flag:\n                         CreateTypeParametersForAssociatedTypesFlag)\n                         -> ty::Generics\n-                        where AC: AstConv<'tcx> {\n+                        where AC: AstConv<'tcx>\n+{\n     let mut result = base_generics;\n \n     for (i, l) in lifetime_defs.iter().enumerate() {\n@@ -1886,62 +1820,11 @@ fn ty_generics<'tcx,AC>(this: &AC,\n     // First, create the virtual type parameters for associated types if\n     // necessary.\n     let mut associated_types_generics = ty::Generics::empty();\n-    match create_type_parameters_for_associated_types {\n+    match create_type_parameters_for_associated_types_flag {\n         DontCreateTypeParametersForAssociatedTypes => {}\n         CreateTypeParametersForAssociatedTypes => {\n-            let mut index = 0;\n-            for param in types.iter() {\n-                for bound in param.bounds.iter() {\n-                    match *bound {\n-                        ast::TraitTyParamBound(ref trait_bound) => {\n-                            match lookup_def_tcx(this.tcx(),\n-                                                 trait_bound.path.span,\n-                                                 trait_bound.ref_id) {\n-                                def::DefTrait(trait_did) => {\n-                                    ensure_associated_types(this, trait_did);\n-                                    let associated_types =\n-                                        ty::associated_types_for_trait(\n-                                            this.tcx(),\n-                                            trait_did);\n-                                    for associated_type_info in\n-                                            associated_types.iter() {\n-                                        let associated_type_trait_item =\n-                                            ty::impl_or_trait_item(\n-                                                this.tcx(),\n-                                                associated_type_info.def_id);\n-                                        let def = ty::TypeParameterDef {\n-                                            name: associated_type_trait_item.name(),\n-                                            def_id: associated_type_info.def_id,\n-                                            space: space,\n-                                            index: types.len() + index,\n-                                            bounds: ty::ParamBounds {\n-                                                builtin_bounds:\n-                                                ty::empty_builtin_bounds(),\n-                                                trait_bounds: Vec::new(),\n-                                                region_bounds: Vec::new(),\n-                                            },\n-                                            associated_with: {\n-                                                Some(local_def(param.id))\n-                                            },\n-                                            default: None,\n-                                        };\n-                                        associated_types_generics.types\n-                                                                 .push(space,\n-                                                                       def);\n-                                        index += 1;\n-                                    }\n-                                }\n-                                _ => {\n-                                    this.tcx().sess.span_bug(trait_bound.path\n-                                                                        .span,\n-                                                             \"not a trait?!\")\n-                                }\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n+            create_type_parameters_for_associated_types(this, space, types,\n+                                                        &mut associated_types_generics);\n         }\n     }\n \n@@ -1976,6 +1859,83 @@ fn ty_generics<'tcx,AC>(this: &AC,\n     }\n \n     return result;\n+\n+    fn create_type_parameters_for_associated_types<'tcx,AC>(\n+        this: &AC,\n+        space: subst::ParamSpace,\n+        types: &[ast::TyParam],\n+        associated_types_generics: &mut ty::Generics)\n+        where AC: AstConv<'tcx>\n+    {\n+        // The idea here is roughly as follows. We start with\n+        // an item that is paramerized by various type parameters\n+        // with bounds:\n+        //\n+        //    fn foo<T:Iterator>(t: T) { ... }\n+        //\n+        // The traits in those bounds declare associated types:\n+        //\n+        //    trait Iterator { type Elem; ... }\n+        //\n+        // And we rewrite the original function so that every associated\n+        // type is bound to some fresh type parameter:\n+        //\n+        //    fn foo<A,T:Iterator<Elem=A>>(t: T) { ... }\n+\n+        // Number of synthetic type parameters created thus far\n+        let mut index = 0;\n+\n+        // Iterate over the each type parameter `T` (from the example)\n+        for param in types.iter() {\n+            // Iterate over the bound `Iterator`\n+            for bound in param.bounds.iter() {\n+                // In the above example, `ast_trait_ref` is `Iterator`.\n+                let ast_trait_ref = match *bound {\n+                    ast::TraitTyParamBound(ref r) => r,\n+                    ast::UnboxedFnTyParamBound(..) => { continue; }\n+                    ast::RegionTyParamBound(..) => { continue; }\n+                };\n+\n+                let trait_def_id =\n+                    match lookup_def_tcx(this.tcx(),\n+                                         ast_trait_ref.path.span,\n+                                         ast_trait_ref.ref_id) {\n+                        def::DefTrait(trait_def_id) => trait_def_id,\n+                        _ => {\n+                            this.tcx().sess.span_bug(ast_trait_ref.path.span,\n+                                                     \"not a trait?!\")\n+                        }\n+                    };\n+\n+                // trait_def_id is def-id of `Iterator`\n+                let trait_def = ty::lookup_trait_def(this.tcx(), trait_def_id);\n+                let associated_type_defs = trait_def.generics.types.get_slice(subst::AssocSpace);\n+\n+                // Iterate over each associated type `Elem`\n+                for associated_type_def in associated_type_defs.iter() {\n+                    // Create the fresh type parameter `A`\n+                    let def = ty::TypeParameterDef {\n+                        name: associated_type_def.name,\n+                        def_id: associated_type_def.def_id,\n+                        space: space,\n+                        index: types.len() + index,\n+                        bounds: ty::ParamBounds {\n+                            builtin_bounds: associated_type_def.bounds.builtin_bounds,\n+\n+                            // FIXME(#18178) -- we should add the other bounds, but\n+                            // that requires subst and more logic\n+                            trait_bounds: Vec::new(),\n+                            region_bounds: Vec::new(),\n+                        },\n+                        associated_with: Some(local_def(param.id)),\n+                        default: None,\n+                    };\n+                    associated_types_generics.types.push(space, def);\n+                    index += 1;\n+                }\n+            }\n+        }\n+    }\n }\n \n fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,"}, {"sha": "55c3c23685357e31e0ecc54e2fbd1092004c4cfc", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38", "patch": "@@ -774,10 +774,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         assert!(generics.regions.len(subst::FnSpace) == 0);\n \n         let type_parameter_count = generics.types.len(subst::TypeSpace);\n+        let type_parameters = self.next_ty_vars(type_parameter_count);\n+\n         let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n         let regions = self.region_vars_for_defs(span, region_param_defs);\n-        let type_parameters = self.next_ty_vars(type_parameter_count);\n-        subst::Substs::new_trait(type_parameters, regions, self_ty)\n+\n+        let assoc_type_parameter_count = generics.types.len(subst::AssocSpace);\n+        let assoc_type_parameters = self.next_ty_vars(assoc_type_parameter_count);\n+\n+        subst::Substs::new_trait(type_parameters, regions, assoc_type_parameters, self_ty)\n     }\n \n     pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {\n@@ -791,7 +796,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn ty_to_string(&self, t: ty::t) -> String {\n         ty_to_string(self.tcx,\n-                  self.resolve_type_vars_if_possible(t))\n+                     self.resolve_type_vars_if_possible(t))\n     }\n \n     pub fn tys_to_string(&self, ts: &[ty::t]) -> String {"}, {"sha": "c4f988580308fcbc3a74f28b311d491be9f93ec7", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38", "patch": "@@ -423,7 +423,13 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n         }\n         ty_infer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n         ty_err => \"[type error]\".to_string(),\n-        ty_param(ref param_ty) => param_ty.repr(cx),\n+        ty_param(ref param_ty) => {\n+            if cx.sess.verbose() {\n+                param_ty.repr(cx)\n+            } else {\n+                param_ty.user_string(cx)\n+            }\n+        }\n         ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n             let base = ty::item_path_str(cx, did);\n             let generics = ty::lookup_item_type(cx, did).generics;\n@@ -479,6 +485,17 @@ pub fn parameterized(cx: &ctxt,\n                      generics: &ty::Generics)\n                      -> String\n {\n+    if cx.sess.verbose() {\n+        if substs.is_noop() {\n+            return format!(\"{}\", base);\n+        } else {\n+            return format!(\"{}<{},{}>\",\n+                           base,\n+                           substs.regions.repr(cx),\n+                           substs.types.repr(cx));\n+        }\n+    }\n+\n     let mut strs = Vec::new();\n \n     match substs.regions {\n@@ -503,7 +520,7 @@ pub fn parameterized(cx: &ctxt,\n     let tps = substs.types.get_slice(subst::TypeSpace);\n     let ty_params = generics.types.get_slice(subst::TypeSpace);\n     let has_defaults = ty_params.last().map_or(false, |def| def.default.is_some());\n-    let num_defaults = if has_defaults && !cx.sess.verbose() {\n+    let num_defaults = if has_defaults {\n         ty_params.iter().zip(tps.iter()).rev().take_while(|&(def, &actual)| {\n             match def.default {\n                 Some(default) => default.subst(cx, substs) == actual,\n@@ -518,18 +535,6 @@ pub fn parameterized(cx: &ctxt,\n         strs.push(ty_to_string(cx, *t))\n     }\n \n-    if cx.sess.verbose() {\n-        for t in substs.types.get_slice(subst::SelfSpace).iter() {\n-            strs.push(format!(\"self {}\", t.repr(cx)));\n-        }\n-\n-        // generally there shouldn't be any substs in the fn param\n-        // space, but in verbose mode, print them out.\n-        for t in substs.types.get_slice(subst::FnSpace).iter() {\n-            strs.push(format!(\"fn {}\", t.repr(cx)));\n-        }\n-    }\n-\n     if strs.len() > 0u {\n         format!(\"{}<{}>\", base, strs.connect(\", \"))\n     } else {\n@@ -725,7 +730,7 @@ impl Repr for ty::TraitRef {\n     fn repr(&self, tcx: &ctxt) -> String {\n         let base = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        format!(\"<{} as {}>\",\n+        format!(\"<{} : {}>\",\n                 self.substs.self_ty().repr(tcx),\n                 parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics))\n     }\n@@ -740,6 +745,19 @@ impl Repr for ty::TraitDef {\n     }\n }\n \n+impl Repr for ast::TraitItem {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        match *self {\n+            ast::RequiredMethod(ref data) => format!(\"RequiredMethod({}, id={})\",\n+                                                     data.ident, data.id),\n+            ast::ProvidedMethod(ref data) => format!(\"ProvidedMethod(id={})\",\n+                                                     data.id),\n+            ast::TypeTraitItem(ref data) => format!(\"TypeTraitItem({}, id={})\",\n+                                                     data.ty_param.ident, data.ty_param.id),\n+        }\n+    }\n+}\n+\n impl Repr for ast::Expr {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"expr({}: {})\", self.id, pprust::expr_to_string(self))\n@@ -758,6 +776,12 @@ impl UserString for ast::Path {\n     }\n }\n \n+impl Repr for ast::Ty {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        format!(\"type({})\", pprust::ty_to_string(self))\n+    }\n+}\n+\n impl Repr for ast::Item {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"item({})\", tcx.map.node_to_string(self.id))\n@@ -1261,7 +1285,8 @@ impl UserString for ParamTy {\n \n impl Repr for ParamTy {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        self.user_string(tcx)\n+        let ident = self.user_string(tcx);\n+        format!(\"{}/{}.{}\", ident, self.space, self.idx)\n     }\n }\n "}, {"sha": "47ab09d279f62ab773d6bca5051af0ca9c80c307", "filename": "src/test/compile-fail/associated-types-unsized.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-unsized.rs?ref=fb9d0ccc2fe4d81c0ff2ecf8d42c59413e24fa38", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get {\n+    type Sized? Value;\n+    fn get(&self) -> <Self as Get>::Value;\n+}\n+\n+fn foo<T:Get>(t: T) {\n+    let x = t.get(); //~ ERROR the trait `core::kinds::Sized` is not implemented\n+}\n+\n+fn main() {\n+}\n+"}]}