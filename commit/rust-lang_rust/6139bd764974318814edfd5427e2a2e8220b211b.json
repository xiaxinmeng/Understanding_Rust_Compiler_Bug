{"sha": "6139bd764974318814edfd5427e2a2e8220b211b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMzliZDc2NDk3NDMxODgxNGVkZmQ1NDI3ZTJhMmU4MjIwYjIxMWI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-15T12:51:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-15T12:51:27Z"}, "message": "Merge #8018\n\n8018: Make Ty wrap TyKind in an Arc r=flodiebold a=flodiebold\n\n... to further move towards Chalk.\r\n\r\nThis is a bit of a slowdown (218ginstr vs 213ginstr for inference on RA), even though it allows us to unwrap the Substs in `TyKind::Ref` etc..\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "70aa9b1a1b338f0c02545cb544ab37c4547f7ce2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70aa9b1a1b338f0c02545cb544ab37c4547f7ce2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6139bd764974318814edfd5427e2a2e8220b211b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgT1hPCRBK7hj4Ov3rIwAAdHIIACUOJzgcoqlBpVvcOa0Q4KaK\niC3DJ+4FXiys8QEH0/GbGO6ly4g7+Z0wbgz7RNzzzz5CcgWqT0bjPMLDiefK02xv\nOoeEqzpNixEss+T+/k4NX9m3A5F+sRjl2rOEjZDq+Y4V70WiHAzYP/vWHFeSONuq\nTjc3f3CO9YVa8HXRs2WYPt46dsJwf9Ljwq81w7jAJQ19GKczhO66lEbgceOmCi2K\nW7vf/F/pOeC82e033qiHuUXOD13q9ufHpRUwpN8gNnUaBqiKLldZVTMH6qiyjPOb\nQaRWG8YPHR2HsoIwHwhkKoNhvUCjX7o0nZ7P9uIwIPfHhlBIgXkKmWl0PnSXu/M=\n=MTM6\n-----END PGP SIGNATURE-----\n", "payload": "tree 70aa9b1a1b338f0c02545cb544ab37c4547f7ce2\nparent a8b319cf28c0985d964ef6624c3ee6e7f09afb2d\nparent 42217738e0b121a8e5d48a9a55cb51ef6c98975f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615812687 +0000\ncommitter GitHub <noreply@github.com> 1615812687 +0000\n\nMerge #8018\n\n8018: Make Ty wrap TyKind in an Arc r=flodiebold a=flodiebold\n\n... to further move towards Chalk.\r\n\r\nThis is a bit of a slowdown (218ginstr vs 213ginstr for inference on RA), even though it allows us to unwrap the Substs in `TyKind::Ref` etc..\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6139bd764974318814edfd5427e2a2e8220b211b", "html_url": "https://github.com/rust-lang/rust/commit/6139bd764974318814edfd5427e2a2e8220b211b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6139bd764974318814edfd5427e2a2e8220b211b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8b319cf28c0985d964ef6624c3ee6e7f09afb2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8b319cf28c0985d964ef6624c3ee6e7f09afb2d", "html_url": "https://github.com/rust-lang/rust/commit/a8b319cf28c0985d964ef6624c3ee6e7f09afb2d"}, {"sha": "42217738e0b121a8e5d48a9a55cb51ef6c98975f", "url": "https://api.github.com/repos/rust-lang/rust/commits/42217738e0b121a8e5d48a9a55cb51ef6c98975f", "html_url": "https://github.com/rust-lang/rust/commit/42217738e0b121a8e5d48a9a55cb51ef6c98975f"}], "stats": {"total": 297, "additions": 155, "deletions": 142}, "files": [{"sha": "25e5bfb01ff7399d330278db7869d13bfc77fa26", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=6139bd764974318814edfd5427e2a2e8220b211b", "patch": "@@ -1597,7 +1597,7 @@ impl Type {\n \n     pub fn remove_ref(&self) -> Option<Type> {\n         match &self.ty.value.interned(&Interner) {\n-            TyKind::Ref(.., substs) => Some(self.derived(substs[0].clone())),\n+            TyKind::Ref(.., ty) => Some(self.derived(ty.clone())),\n             _ => None,\n         }\n     }\n@@ -1751,10 +1751,30 @@ impl Type {\n         return go(&self.ty.value);\n \n         fn go(ty: &Ty) -> bool {\n-            if ty.is_unknown() {\n-                true\n-            } else {\n-                ty.substs().map_or(false, |substs| substs.iter().any(go))\n+            match ty.interned(&Interner) {\n+                TyKind::Unknown => true,\n+\n+                TyKind::Adt(_, substs)\n+                | TyKind::AssociatedType(_, substs)\n+                | TyKind::Tuple(_, substs)\n+                | TyKind::OpaqueType(_, substs)\n+                | TyKind::FnDef(_, substs)\n+                | TyKind::Closure(_, substs) => substs.iter().any(go),\n+\n+                TyKind::Array(ty) | TyKind::Slice(ty) | TyKind::Raw(_, ty) | TyKind::Ref(_, ty) => {\n+                    go(ty)\n+                }\n+\n+                TyKind::Scalar(_)\n+                | TyKind::Str\n+                | TyKind::Never\n+                | TyKind::Placeholder(_)\n+                | TyKind::BoundVar(_)\n+                | TyKind::InferenceVar(_, _)\n+                | TyKind::Dyn(_)\n+                | TyKind::Function(_)\n+                | TyKind::Alias(_)\n+                | TyKind::ForeignType(_) => false,\n             }\n         }\n     }\n@@ -1989,6 +2009,10 @@ impl Type {\n                     walk_bounds(db, &type_.derived(ty.clone()), bounds.as_ref(), cb);\n                 }\n \n+                TyKind::Ref(_, ty) | TyKind::Raw(_, ty) | TyKind::Array(ty) | TyKind::Slice(ty) => {\n+                    walk_type(db, &type_.derived(ty.clone()), cb);\n+                }\n+\n                 _ => {}\n             }\n             if let Some(substs) = ty.substs() {"}, {"sha": "c1062387e19d8cbd83504bcc8d676e1c171298e1", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=6139bd764974318814edfd5427e2a2e8220b211b", "patch": "@@ -276,20 +276,17 @@ impl HirDisplay for Ty {\n             &TyKind::Scalar(Scalar::Float(t)) => write!(f, \"{}\", primitive::float_ty_to_string(t))?,\n             &TyKind::Scalar(Scalar::Int(t)) => write!(f, \"{}\", primitive::int_ty_to_string(t))?,\n             &TyKind::Scalar(Scalar::Uint(t)) => write!(f, \"{}\", primitive::uint_ty_to_string(t))?,\n-            TyKind::Slice(parameters) => {\n-                let t = parameters.as_single();\n+            TyKind::Slice(t) => {\n                 write!(f, \"[\")?;\n                 t.hir_fmt(f)?;\n                 write!(f, \"]\")?;\n             }\n-            TyKind::Array(parameters) => {\n-                let t = parameters.as_single();\n+            TyKind::Array(t) => {\n                 write!(f, \"[\")?;\n                 t.hir_fmt(f)?;\n                 write!(f, \"; _]\")?;\n             }\n-            TyKind::Raw(m, parameters) | TyKind::Ref(m, parameters) => {\n-                let t = parameters.as_single();\n+            TyKind::Raw(m, t) | TyKind::Ref(m, t) => {\n                 let ty_display =\n                     t.into_displayable(f.db, f.max_size, f.omit_verbose_types, f.display_target);\n "}, {"sha": "9c385b845bc7d40b9bfbc9333fea3489632c877b", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=6139bd764974318814edfd5427e2a2e8220b211b", "patch": "@@ -108,6 +108,17 @@ pub struct TypeMismatch {\n     pub actual: Ty,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+struct InternedStandardTypes {\n+    unknown: Ty,\n+}\n+\n+impl Default for InternedStandardTypes {\n+    fn default() -> Self {\n+        InternedStandardTypes { unknown: TyKind::Unknown.intern(&Interner) }\n+    }\n+}\n+\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug, Default)]\n pub struct InferenceResult {\n@@ -126,6 +137,8 @@ pub struct InferenceResult {\n     pub type_of_expr: ArenaMap<ExprId, Ty>,\n     pub type_of_pat: ArenaMap<PatId, Ty>,\n     pub(super) type_mismatches: ArenaMap<ExprId, TypeMismatch>,\n+    /// Interned Unknown to return references to.\n+    standard_types: InternedStandardTypes,\n }\n \n impl InferenceResult {\n@@ -170,15 +183,15 @@ impl Index<ExprId> for InferenceResult {\n     type Output = Ty;\n \n     fn index(&self, expr: ExprId) -> &Ty {\n-        self.type_of_expr.get(expr).unwrap_or(&Ty(TyKind::Unknown))\n+        self.type_of_expr.get(expr).unwrap_or(&self.standard_types.unknown)\n     }\n }\n \n impl Index<PatId> for InferenceResult {\n     type Output = Ty;\n \n     fn index(&self, pat: PatId) -> &Ty {\n-        self.type_of_pat.get(pat).unwrap_or(&Ty(TyKind::Unknown))\n+        self.type_of_pat.get(pat).unwrap_or(&self.standard_types.unknown)\n     }\n }\n \n@@ -723,14 +736,19 @@ impl Expectation {\n \n     /// This expresses no expectation on the type.\n     fn none() -> Self {\n-        Expectation { ty: TyKind::Unknown.intern(&Interner), rvalue_hint: false }\n+        Expectation {\n+            // FIXME\n+            ty: TyKind::Unknown.intern(&Interner),\n+            rvalue_hint: false,\n+        }\n     }\n \n-    fn coercion_target(&self) -> &Ty {\n+    fn coercion_target(&self) -> Ty {\n         if self.rvalue_hint {\n-            &Ty(TyKind::Unknown)\n+            // FIXME\n+            TyKind::Unknown.intern(&Interner)\n         } else {\n-            &self.ty\n+            self.ty.clone()\n         }\n     }\n }"}, {"sha": "137419264605882294ea065c621eeb2569305171", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=6139bd764974318814edfd5427e2a2e8220b211b", "patch": "@@ -71,7 +71,7 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         // Pointer weakening and function to pointer\n-        match (&mut from_ty.0, to_ty.interned(&Interner)) {\n+        match (from_ty.interned_mut(), to_ty.interned(&Interner)) {\n             // `*mut T` -> `*const T`\n             // `&mut T` -> `&T`\n             (TyKind::Raw(m1, ..), TyKind::Raw(m2 @ Mutability::Not, ..))\n@@ -111,9 +111,7 @@ impl<'a> InferenceContext<'a> {\n         // Auto Deref if cannot coerce\n         match (from_ty.interned(&Interner), to_ty.interned(&Interner)) {\n             // FIXME: DerefMut\n-            (TyKind::Ref(_, st1), TyKind::Ref(_, st2)) => {\n-                self.unify_autoderef_behind_ref(&st1[0], &st2[0])\n-            }\n+            (TyKind::Ref(_, st1), TyKind::Ref(_, st2)) => self.unify_autoderef_behind_ref(st1, st2),\n \n             // Otherwise, normal unify\n             _ => self.unify(&from_ty, to_ty),\n@@ -178,11 +176,7 @@ impl<'a> InferenceContext<'a> {\n             // Stop when constructor matches.\n             if from_ty.equals_ctor(&to_ty) {\n                 // It will not recurse to `coerce`.\n-                return match (from_ty.substs(), to_ty.substs()) {\n-                    (Some(st1), Some(st2)) => self.table.unify_substs(st1, st2, 0),\n-                    (None, None) => true,\n-                    _ => false,\n-                };\n+                return self.table.unify(&from_ty, &to_ty);\n             } else if self.table.unify_inner_trivial(&derefed_ty, &to_ty, 0) {\n                 return true;\n             }"}, {"sha": "f40dec17f6c1eedf552af9bd5a8de2ed4f54aa58", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=6139bd764974318814edfd5427e2a2e8220b211b", "patch": "@@ -503,8 +503,8 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 let inner_ty = self.infer_expr_inner(*expr, &expectation);\n                 match rawness {\n-                    Rawness::RawPtr => TyKind::Raw(mutability, Substs::single(inner_ty)),\n-                    Rawness::Ref => TyKind::Ref(mutability, Substs::single(inner_ty)),\n+                    Rawness::RawPtr => TyKind::Raw(mutability, inner_ty),\n+                    Rawness::Ref => TyKind::Ref(mutability, inner_ty),\n                 }\n                 .intern(&Interner)\n             }\n@@ -685,7 +685,7 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Array(array) => {\n                 let elem_ty = match expected.ty.interned(&Interner) {\n-                    TyKind::Array(st) | TyKind::Slice(st) => st.as_single().clone(),\n+                    TyKind::Array(st) | TyKind::Slice(st) => st.clone(),\n                     _ => self.table.new_type_var(),\n                 };\n \n@@ -709,18 +709,17 @@ impl<'a> InferenceContext<'a> {\n                     }\n                 }\n \n-                TyKind::Array(Substs::single(elem_ty)).intern(&Interner)\n+                TyKind::Array(elem_ty).intern(&Interner)\n             }\n             Expr::Literal(lit) => match lit {\n                 Literal::Bool(..) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n                 Literal::String(..) => {\n-                    TyKind::Ref(Mutability::Not, Substs::single(TyKind::Str.intern(&Interner)))\n-                        .intern(&Interner)\n+                    TyKind::Ref(Mutability::Not, TyKind::Str.intern(&Interner)).intern(&Interner)\n                 }\n                 Literal::ByteString(..) => {\n                     let byte_type = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(&Interner);\n-                    let array_type = TyKind::Array(Substs::single(byte_type)).intern(&Interner);\n-                    TyKind::Ref(Mutability::Not, Substs::single(array_type)).intern(&Interner)\n+                    let array_type = TyKind::Array(byte_type).intern(&Interner);\n+                    TyKind::Ref(Mutability::Not, array_type).intern(&Interner)\n                 }\n                 Literal::Char(..) => TyKind::Scalar(Scalar::Char).intern(&Interner),\n                 Literal::Int(_v, ty) => match ty {\n@@ -799,7 +798,7 @@ impl<'a> InferenceContext<'a> {\n                 // we don't even make an attempt at coercion\n                 self.table.new_maybe_never_var()\n             } else {\n-                self.coerce(&Ty::unit(), expected.coercion_target());\n+                self.coerce(&Ty::unit(), &expected.coercion_target());\n                 Ty::unit()\n             }\n         };\n@@ -854,9 +853,7 @@ impl<'a> InferenceContext<'a> {\n         // Apply autoref so the below unification works correctly\n         // FIXME: return correct autorefs from lookup_method\n         let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n-            Some((_, mutability)) => {\n-                TyKind::Ref(mutability, Substs::single(derefed_receiver_ty)).intern(&Interner)\n-            }\n+            Some((_, mutability)) => TyKind::Ref(mutability, derefed_receiver_ty).intern(&Interner),\n             _ => derefed_receiver_ty,\n         };\n         self.unify(&expected_receiver_ty, &actual_receiver_ty);"}, {"sha": "9e8ca18efbcc91223be732596c09ffaf74b1df02", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=6139bd764974318814edfd5427e2a2e8220b211b", "patch": "@@ -158,12 +158,12 @@ impl<'a> InferenceContext<'a> {\n                         if mutability != exp_mut {\n                             // FIXME: emit type error?\n                         }\n-                        inner_ty\n+                        inner_ty.clone()\n                     }\n-                    _ => &Ty(TyKind::Unknown),\n+                    _ => self.result.standard_types.unknown.clone(),\n                 };\n-                let subty = self.infer_pat(*pat, expectation, default_bm);\n-                TyKind::Ref(mutability, Substs::single(subty)).intern(&Interner)\n+                let subty = self.infer_pat(*pat, &expectation, default_bm);\n+                TyKind::Ref(mutability, subty).intern(&Interner)\n             }\n             Pat::TupleStruct { path: p, args: subpats, ellipsis } => self.infer_tuple_struct_pat(\n                 p.as_ref(),\n@@ -196,7 +196,7 @@ impl<'a> InferenceContext<'a> {\n \n                 let bound_ty = match mode {\n                     BindingMode::Ref(mutability) => {\n-                        TyKind::Ref(mutability, Substs::single(inner_ty.clone())).intern(&Interner)\n+                        TyKind::Ref(mutability, inner_ty.clone()).intern(&Interner)\n                     }\n                     BindingMode::Move => inner_ty.clone(),\n                 };\n@@ -206,16 +206,16 @@ impl<'a> InferenceContext<'a> {\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n                 let (container_ty, elem_ty): (fn(_) -> _, _) = match expected.interned(&Interner) {\n-                    TyKind::Array(st) => (TyKind::Array, st.as_single().clone()),\n-                    TyKind::Slice(st) => (TyKind::Slice, st.as_single().clone()),\n+                    TyKind::Array(st) => (TyKind::Array, st.clone()),\n+                    TyKind::Slice(st) => (TyKind::Slice, st.clone()),\n                     _ => (TyKind::Slice, self.err_ty()),\n                 };\n \n                 for pat_id in prefix.iter().chain(suffix) {\n                     self.infer_pat(*pat_id, &elem_ty, default_bm);\n                 }\n \n-                let pat_ty = container_ty(Substs::single(elem_ty)).intern(&Interner);\n+                let pat_ty = container_ty(elem_ty).intern(&Interner);\n                 if let Some(slice_pat_id) = slice {\n                     self.infer_pat(*slice_pat_id, &pat_ty, default_bm);\n                 }\n@@ -232,11 +232,11 @@ impl<'a> InferenceContext<'a> {\n             Pat::Box { inner } => match self.resolve_boxed_box() {\n                 Some(box_adt) => {\n                     let inner_expected = match expected.as_adt() {\n-                        Some((adt, substs)) if adt == box_adt => substs.as_single(),\n-                        _ => &Ty(TyKind::Unknown),\n+                        Some((adt, substs)) if adt == box_adt => substs.as_single().clone(),\n+                        _ => self.result.standard_types.unknown.clone(),\n                     };\n \n-                    let inner_ty = self.infer_pat(*inner, inner_expected, default_bm);\n+                    let inner_ty = self.infer_pat(*inner, &inner_expected, default_bm);\n                     Ty::adt_ty(box_adt, Substs::single(inner_ty))\n                 }\n                 None => self.err_ty(),"}, {"sha": "66f8fe8a320a9cb2063369d18b5bbf733188ac3c", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=6139bd764974318814edfd5427e2a2e8220b211b", "patch": "@@ -7,8 +7,8 @@ use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n \n use super::{InferenceContext, Obligation};\n use crate::{\n-    BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferenceVar, Interner,\n-    Scalar, Substs, Ty, TyKind, TypeWalk,\n+    BoundVar, Canonical, DebruijnIndex, FnPointer, GenericPredicate, InEnvironment, InferenceVar,\n+    Interner, Scalar, Substs, Ty, TyKind, TypeWalk,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -108,7 +108,7 @@ impl<T> Canonicalized<T> {\n     pub(super) fn decanonicalize_ty(&self, mut ty: Ty) -> Ty {\n         ty.walk_mut_binders(\n             &mut |ty, binders| {\n-                if let &mut TyKind::BoundVar(bound) = &mut ty.0 {\n+                if let &mut TyKind::BoundVar(bound) = ty.interned_mut() {\n                     if bound.debruijn >= binders {\n                         let (v, k) = self.free_vars[bound.index];\n                         *ty = TyKind::InferenceVar(v, k).intern(&Interner);\n@@ -283,9 +283,23 @@ impl InferenceTable {\n         let ty1 = self.resolve_ty_shallow(ty1);\n         let ty2 = self.resolve_ty_shallow(ty2);\n         if ty1.equals_ctor(&ty2) {\n-            match (ty1.substs(), ty2.substs()) {\n-                (Some(st1), Some(st2)) => self.unify_substs(st1, st2, depth + 1),\n-                (None, None) => true,\n+            match (ty1.interned(&Interner), ty2.interned(&Interner)) {\n+                (TyKind::Adt(_, substs1), TyKind::Adt(_, substs2))\n+                | (TyKind::FnDef(_, substs1), TyKind::FnDef(_, substs2))\n+                | (\n+                    TyKind::Function(FnPointer { substs: substs1, .. }),\n+                    TyKind::Function(FnPointer { substs: substs2, .. }),\n+                )\n+                | (TyKind::Tuple(_, substs1), TyKind::Tuple(_, substs2))\n+                | (TyKind::OpaqueType(_, substs1), TyKind::OpaqueType(_, substs2))\n+                | (TyKind::AssociatedType(_, substs1), TyKind::AssociatedType(_, substs2))\n+                | (TyKind::Closure(.., substs1), TyKind::Closure(.., substs2)) => {\n+                    self.unify_substs(substs1, substs2, depth + 1)\n+                }\n+                (TyKind::Ref(_, ty1), TyKind::Ref(_, ty2))\n+                | (TyKind::Raw(_, ty1), TyKind::Raw(_, ty2))\n+                | (TyKind::Array(ty1), TyKind::Array(ty2))\n+                | (TyKind::Slice(ty1), TyKind::Slice(ty2)) => self.unify_inner(ty1, ty2, depth + 1),\n                 _ => false,\n             }\n         } else {\n@@ -404,7 +418,7 @@ impl InferenceTable {\n             if i > 0 {\n                 cov_mark::hit!(type_var_resolves_to_int_var);\n             }\n-            match &ty.0 {\n+            match ty.interned(&Interner) {\n                 TyKind::InferenceVar(tv, _) => {\n                     let inner = tv.to_inner();\n                     match self.var_unification_table.inlined_probe_value(inner).known() {"}, {"sha": "503910dde28bd90544bddfbda2ee303b80cb4b87", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 34, "deletions": 57, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=6139bd764974318814edfd5427e2a2e8220b211b", "patch": "@@ -151,17 +151,17 @@ pub enum TyKind {\n     Tuple(usize, Substs),\n \n     /// An array with the given length. Written as `[T; n]`.\n-    Array(Substs),\n+    Array(Ty),\n \n     /// The pointee of an array slice.  Written as `[T]`.\n-    Slice(Substs),\n+    Slice(Ty),\n \n     /// A raw pointer. Written as `*mut T` or `*const T`\n-    Raw(Mutability, Substs),\n+    Raw(Mutability, Ty),\n \n     /// A reference; a pointer with an associated lifetime. Written as\n     /// `&'a mut T` or `&'a T`.\n-    Ref(Mutability, Substs),\n+    Ref(Mutability, Ty),\n \n     /// This represents a placeholder for an opaque type in situations where we\n     /// don't know the hidden type (i.e. currently almost always). This is\n@@ -248,18 +248,26 @@ pub enum TyKind {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Ty(TyKind);\n+pub struct Ty(Arc<TyKind>);\n \n impl TyKind {\n     pub fn intern(self, _interner: &Interner) -> Ty {\n-        Ty(self)\n+        Ty(Arc::new(self))\n     }\n }\n \n impl Ty {\n     pub fn interned(&self, _interner: &Interner) -> &TyKind {\n         &self.0\n     }\n+\n+    pub fn interned_mut(&mut self) -> &mut TyKind {\n+        Arc::make_mut(&mut self.0)\n+    }\n+\n+    pub fn into_inner(self) -> TyKind {\n+        Arc::try_unwrap(self.0).unwrap_or_else(|a| (*a).clone())\n+    }\n }\n \n /// A list of substitutions for generic parameters.\n@@ -665,28 +673,24 @@ impl Ty {\n \n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n         match self.interned(&Interner) {\n-            TyKind::Ref(mutability, parameters) => Some((parameters.as_single(), *mutability)),\n+            TyKind::Ref(mutability, ty) => Some((ty, *mutability)),\n             _ => None,\n         }\n     }\n \n     pub fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)> {\n         match self.interned(&Interner) {\n-            TyKind::Ref(mutability, parameters) => {\n-                Some((parameters.as_single(), Rawness::Ref, *mutability))\n-            }\n-            TyKind::Raw(mutability, parameters) => {\n-                Some((parameters.as_single(), Rawness::RawPtr, *mutability))\n-            }\n+            TyKind::Ref(mutability, ty) => Some((ty, Rawness::Ref, *mutability)),\n+            TyKind::Raw(mutability, ty) => Some((ty, Rawness::RawPtr, *mutability)),\n             _ => None,\n         }\n     }\n \n     pub fn strip_references(&self) -> &Ty {\n         let mut t: &Ty = self;\n \n-        while let TyKind::Ref(_mutability, parameters) = t.interned(&Interner) {\n-            t = parameters.as_single();\n+        while let TyKind::Ref(_mutability, ty) = t.interned(&Interner) {\n+            t = ty;\n         }\n \n         t\n@@ -772,8 +776,8 @@ impl Ty {\n \n     fn builtin_deref(&self) -> Option<Ty> {\n         match self.interned(&Interner) {\n-            TyKind::Ref(.., parameters) => Some(Ty::clone(parameters.as_single())),\n-            TyKind::Raw(.., parameters) => Some(Ty::clone(parameters.as_single())),\n+            TyKind::Ref(.., ty) => Some(ty.clone()),\n+            TyKind::Raw(.., ty) => Some(ty.clone()),\n             _ => None,\n         }\n     }\n@@ -809,40 +813,11 @@ impl Ty {\n         }\n     }\n \n-    /// If this is a type with type parameters (an ADT or function), replaces\n-    /// the `Substs` for these type parameters with the given ones. (So e.g. if\n-    /// `self` is `Option<_>` and the substs contain `u32`, we'll have\n-    /// `Option<u32>` afterwards.)\n-    pub fn apply_substs(mut self, new_substs: Substs) -> Ty {\n-        match &mut self.0 {\n-            TyKind::Adt(_, substs)\n-            | TyKind::Slice(substs)\n-            | TyKind::Array(substs)\n-            | TyKind::Raw(_, substs)\n-            | TyKind::Ref(_, substs)\n-            | TyKind::FnDef(_, substs)\n-            | TyKind::Function(FnPointer { substs, .. })\n-            | TyKind::Tuple(_, substs)\n-            | TyKind::OpaqueType(_, substs)\n-            | TyKind::AssociatedType(_, substs)\n-            | TyKind::Closure(.., substs) => {\n-                assert_eq!(substs.len(), new_substs.len());\n-                *substs = new_substs;\n-            }\n-            _ => (),\n-        }\n-        self\n-    }\n-\n     /// Returns the type parameters of this type if it has some (i.e. is an ADT\n     /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n     pub fn substs(&self) -> Option<&Substs> {\n         match self.interned(&Interner) {\n             TyKind::Adt(_, substs)\n-            | TyKind::Slice(substs)\n-            | TyKind::Array(substs)\n-            | TyKind::Raw(_, substs)\n-            | TyKind::Ref(_, substs)\n             | TyKind::FnDef(_, substs)\n             | TyKind::Function(FnPointer { substs, .. })\n             | TyKind::Tuple(_, substs)\n@@ -853,13 +828,9 @@ impl Ty {\n         }\n     }\n \n-    pub fn substs_mut(&mut self) -> Option<&mut Substs> {\n-        match &mut self.0 {\n+    fn substs_mut(&mut self) -> Option<&mut Substs> {\n+        match self.interned_mut() {\n             TyKind::Adt(_, substs)\n-            | TyKind::Slice(substs)\n-            | TyKind::Array(substs)\n-            | TyKind::Raw(_, substs)\n-            | TyKind::Ref(_, substs)\n             | TyKind::FnDef(_, substs)\n             | TyKind::Function(FnPointer { substs, .. })\n             | TyKind::Tuple(_, substs)\n@@ -988,7 +959,7 @@ pub trait TypeWalk {\n     {\n         self.walk_mut_binders(\n             &mut |ty_mut, binders| {\n-                let ty = mem::replace(ty_mut, Ty(TyKind::Unknown));\n+                let ty = mem::replace(ty_mut, TyKind::Unknown.intern(&Interner));\n                 *ty_mut = f(ty, binders);\n             },\n             binders,\n@@ -1001,7 +972,7 @@ pub trait TypeWalk {\n         Self: Sized,\n     {\n         self.walk_mut(&mut |ty_mut| {\n-            let ty = mem::replace(ty_mut, Ty(TyKind::Unknown));\n+            let ty = mem::replace(ty_mut, TyKind::Unknown.intern(&Interner));\n             *ty_mut = f(ty);\n         });\n         self\n@@ -1022,7 +993,7 @@ pub trait TypeWalk {\n     {\n         self.walk_mut_binders(\n             &mut |ty, binders| {\n-                if let &mut TyKind::BoundVar(bound) = &mut ty.0 {\n+                if let &mut TyKind::BoundVar(bound) = ty.interned_mut() {\n                     if bound.debruijn >= binders {\n                         *ty = substs.0[bound.index].clone().shift_bound_vars(binders);\n                     }\n@@ -1039,7 +1010,7 @@ pub trait TypeWalk {\n         Self: Sized,\n     {\n         self.fold_binders(\n-            &mut |ty, binders| match &ty.0 {\n+            &mut |ty, binders| match ty.interned(&Interner) {\n                 TyKind::BoundVar(bound) if bound.debruijn >= binders => {\n                     TyKind::BoundVar(bound.shifted_in_from(n)).intern(&Interner)\n                 }\n@@ -1068,6 +1039,9 @@ impl TypeWalk for Ty {\n                     p.walk(f);\n                 }\n             }\n+            TyKind::Slice(ty) | TyKind::Array(ty) | TyKind::Ref(_, ty) | TyKind::Raw(_, ty) => {\n+                ty.walk(f);\n+            }\n             _ => {\n                 if let Some(substs) = self.substs() {\n                     for t in substs.iter() {\n@@ -1084,7 +1058,7 @@ impl TypeWalk for Ty {\n         f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n         binders: DebruijnIndex,\n     ) {\n-        match &mut self.0 {\n+        match self.interned_mut() {\n             TyKind::Alias(AliasTy::Projection(p_ty)) => {\n                 p_ty.substitution.walk_mut_binders(f, binders);\n             }\n@@ -1096,6 +1070,9 @@ impl TypeWalk for Ty {\n             TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n                 o_ty.substitution.walk_mut_binders(f, binders);\n             }\n+            TyKind::Slice(ty) | TyKind::Array(ty) | TyKind::Ref(_, ty) | TyKind::Raw(_, ty) => {\n+                ty.walk_mut_binders(f, binders);\n+            }\n             _ => {\n                 if let Some(substs) = self.substs_mut() {\n                     substs.walk_mut_binders(f, binders);"}, {"sha": "b4c650fa1ecc2c4957b54163fc8f1c9b5504d161", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=6139bd764974318814edfd5427e2a2e8220b211b", "patch": "@@ -160,21 +160,19 @@ impl<'a> TyLoweringContext<'a> {\n             }\n             TypeRef::RawPtr(inner, mutability) => {\n                 let inner_ty = self.lower_ty(inner);\n-                TyKind::Raw(lower_to_chalk_mutability(*mutability), Substs::single(inner_ty))\n-                    .intern(&Interner)\n+                TyKind::Raw(lower_to_chalk_mutability(*mutability), inner_ty).intern(&Interner)\n             }\n             TypeRef::Array(inner) => {\n                 let inner_ty = self.lower_ty(inner);\n-                TyKind::Array(Substs::single(inner_ty)).intern(&Interner)\n+                TyKind::Array(inner_ty).intern(&Interner)\n             }\n             TypeRef::Slice(inner) => {\n                 let inner_ty = self.lower_ty(inner);\n-                TyKind::Slice(Substs::single(inner_ty)).intern(&Interner)\n+                TyKind::Slice(inner_ty).intern(&Interner)\n             }\n             TypeRef::Reference(inner, _, mutability) => {\n                 let inner_ty = self.lower_ty(inner);\n-                TyKind::Ref(lower_to_chalk_mutability(*mutability), Substs::single(inner_ty))\n-                    .intern(&Interner)\n+                TyKind::Ref(lower_to_chalk_mutability(*mutability), inner_ty).intern(&Interner)\n             }\n             TypeRef::Placeholder => TyKind::Unknown.intern(&Interner),\n             TypeRef::Fn(params, is_varargs) => {\n@@ -993,7 +991,7 @@ pub(crate) fn generic_defaults_query(\n \n             // Each default can only refer to previous parameters.\n             ty.walk_mut_binders(\n-                &mut |ty, binders| match &mut ty.0 {\n+                &mut |ty, binders| match ty.interned_mut() {\n                     TyKind::BoundVar(BoundVar { debruijn, index }) if *debruijn == binders => {\n                         if *index >= idx {\n                             // type variable default referring to parameter coming"}, {"sha": "741440006485e6512ec25b82230b3497e4f552ac", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=6139bd764974318814edfd5427e2a2e8220b211b", "patch": "@@ -435,8 +435,7 @@ fn iterate_method_candidates_with_autoref(\n     }\n     let refed = Canonical {\n         kinds: deref_chain[0].kinds.clone(),\n-        value: TyKind::Ref(Mutability::Not, Substs::single(deref_chain[0].value.clone()))\n-            .intern(&Interner),\n+        value: TyKind::Ref(Mutability::Not, deref_chain[0].value.clone()).intern(&Interner),\n     };\n     if iterate_method_candidates_by_receiver(\n         &refed,\n@@ -452,8 +451,7 @@ fn iterate_method_candidates_with_autoref(\n     }\n     let ref_muted = Canonical {\n         kinds: deref_chain[0].kinds.clone(),\n-        value: TyKind::Ref(Mutability::Mut, Substs::single(deref_chain[0].value.clone()))\n-            .intern(&Interner),\n+        value: TyKind::Ref(Mutability::Mut, deref_chain[0].value.clone()).intern(&Interner),\n     };\n     if iterate_method_candidates_by_receiver(\n         &ref_muted,"}, {"sha": "6a8b6752e0d5877ed2fd1518b91995c424761778", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6139bd764974318814edfd5427e2a2e8220b211b/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=6139bd764974318814edfd5427e2a2e8220b211b", "patch": "@@ -24,9 +24,9 @@ use super::*;\n impl ToChalk for Ty {\n     type Chalk = chalk_ir::Ty<Interner>;\n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n-        match self.0 {\n-            TyKind::Ref(m, parameters) => ref_to_chalk(db, m, parameters),\n-            TyKind::Array(parameters) => array_to_chalk(db, parameters),\n+        match self.into_inner() {\n+            TyKind::Ref(m, ty) => ref_to_chalk(db, m, ty),\n+            TyKind::Array(ty) => array_to_chalk(db, ty),\n             TyKind::Function(FnPointer { sig, substs, .. }) => {\n                 let substitution = chalk_ir::FnSubst(substs.to_chalk(db).shifted_in(&Interner));\n                 chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n@@ -54,13 +54,11 @@ impl ToChalk for Ty {\n                 let substitution = substs.to_chalk(db);\n                 chalk_ir::TyKind::Tuple(cardinality.into(), substitution).intern(&Interner)\n             }\n-            TyKind::Raw(mutability, substs) => {\n-                let ty = substs[0].clone().to_chalk(db);\n+            TyKind::Raw(mutability, ty) => {\n+                let ty = ty.to_chalk(db);\n                 chalk_ir::TyKind::Raw(mutability, ty).intern(&Interner)\n             }\n-            TyKind::Slice(substs) => {\n-                chalk_ir::TyKind::Slice(substs[0].clone().to_chalk(db)).intern(&Interner)\n-            }\n+            TyKind::Slice(ty) => chalk_ir::TyKind::Slice(ty.to_chalk(db)).intern(&Interner),\n             TyKind::Str => chalk_ir::TyKind::Str.intern(&Interner),\n             TyKind::FnDef(id, substs) => {\n                 let substitution = substs.to_chalk(db);\n@@ -114,7 +112,7 @@ impl ToChalk for Ty {\n     fn from_chalk(db: &dyn HirDatabase, chalk: chalk_ir::Ty<Interner>) -> Self {\n         match chalk.data(&Interner).kind.clone() {\n             chalk_ir::TyKind::Error => TyKind::Unknown,\n-            chalk_ir::TyKind::Array(ty, _size) => TyKind::Array(Substs::single(from_chalk(db, ty))),\n+            chalk_ir::TyKind::Array(ty, _size) => TyKind::Array(from_chalk(db, ty)),\n             chalk_ir::TyKind::Placeholder(idx) => TyKind::Placeholder(idx),\n             chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Projection(proj)) => {\n                 let associated_ty = proj.associated_ty_id;\n@@ -168,12 +166,10 @@ impl ToChalk for Ty {\n             chalk_ir::TyKind::Tuple(cardinality, subst) => {\n                 TyKind::Tuple(cardinality, from_chalk(db, subst))\n             }\n-            chalk_ir::TyKind::Raw(mutability, ty) => {\n-                TyKind::Raw(mutability, Substs::single(from_chalk(db, ty)))\n-            }\n-            chalk_ir::TyKind::Slice(ty) => TyKind::Slice(Substs::single(from_chalk(db, ty))),\n+            chalk_ir::TyKind::Raw(mutability, ty) => TyKind::Raw(mutability, from_chalk(db, ty)),\n+            chalk_ir::TyKind::Slice(ty) => TyKind::Slice(from_chalk(db, ty)),\n             chalk_ir::TyKind::Ref(mutability, _lifetime, ty) => {\n-                TyKind::Ref(mutability, Substs::single(from_chalk(db, ty)))\n+                TyKind::Ref(mutability, from_chalk(db, ty))\n             }\n             chalk_ir::TyKind::Str => TyKind::Str,\n             chalk_ir::TyKind::Never => TyKind::Never,\n@@ -197,17 +193,17 @@ impl ToChalk for Ty {\n fn ref_to_chalk(\n     db: &dyn HirDatabase,\n     mutability: chalk_ir::Mutability,\n-    subst: Substs,\n+    ty: Ty,\n ) -> chalk_ir::Ty<Interner> {\n-    let arg = subst[0].clone().to_chalk(db);\n+    let arg = ty.to_chalk(db);\n     let lifetime = LifetimeData::Static.intern(&Interner);\n     chalk_ir::TyKind::Ref(mutability, lifetime, arg).intern(&Interner)\n }\n \n /// We currently don't model constants, but Chalk does. So, we have to insert a\n /// fake constant here, because Chalks built-in logic may expect it to be there.\n-fn array_to_chalk(db: &dyn HirDatabase, subst: Substs) -> chalk_ir::Ty<Interner> {\n-    let arg = subst[0].clone().to_chalk(db);\n+fn array_to_chalk(db: &dyn HirDatabase, ty: Ty) -> chalk_ir::Ty<Interner> {\n+    let arg = ty.to_chalk(db);\n     let usize_ty = chalk_ir::TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(&Interner);\n     let const_ = chalk_ir::ConstData {\n         ty: usize_ty,"}]}