{"sha": "3f4d6d73a9d01016d8ab689b6be253503d31afa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNGQ2ZDczYTlkMDEwMTZkOGFiNjg5YjZiZTI1MzUwM2QzMWFmYTY=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-06-15T08:40:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-15T08:40:09Z"}, "message": "Rollup merge of #85792 - mjptree:refactor-windows-sockets, r=JohnTitor\n\nRefactor windows sockets impl methods\n\nNo behavioural changes, but a bit tidier visual flow.", "tree": {"sha": "3fe56dfdf31fb1ca8138a170810c67dc7cbd75ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fe56dfdf31fb1ca8138a170810c67dc7cbd75ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f4d6d73a9d01016d8ab689b6be253503d31afa6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgyGdqCRBK7hj4Ov3rIwAAVKAIAJxO2KkDKMQfAxNMTBqGdtyO\n+Hq8/z8bnnj4QZesiK+1MSFUwNO6kJrmSwwYhOOPB7o1bBQjrF8FO1GJgtSDm1Ph\nwDteoR9EiBdsuZzz3wgs1oTppTyjX155pXFuRoI9mNPRyU2esfyo3stFMqmGMJUF\nem0eXTvQux2+ywy75sZWiq04TSWJsp/OI1V+1z1JXvyYZq2fpLLYPJDueEZ3rvck\nlwGLbi7z3doqhn5gitppxLczkfNBefuQ/5TCQ4Ry/8+8hhVMHF7FKgPBwLWas2So\n/WKcKjFF4W3J2ORb+4SwRGyf+UdlLjiPBONp95gw6ah5Zc4nkP5FClPYxGlRnTs=\n=4Iid\n-----END PGP SIGNATURE-----\n", "payload": "tree 3fe56dfdf31fb1ca8138a170810c67dc7cbd75ab\nparent 5936ecc24f8100b106c2e0cbaa8c1c7d5fef481f\nparent 78d3d3790a56227ba915d559907f5e6db54640db\nauthor Yuki Okushi <jtitor@2k36.org> 1623746409 +0900\ncommitter GitHub <noreply@github.com> 1623746409 +0900\n\nRollup merge of #85792 - mjptree:refactor-windows-sockets, r=JohnTitor\n\nRefactor windows sockets impl methods\n\nNo behavioural changes, but a bit tidier visual flow.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4d6d73a9d01016d8ab689b6be253503d31afa6", "html_url": "https://github.com/rust-lang/rust/commit/3f4d6d73a9d01016d8ab689b6be253503d31afa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f4d6d73a9d01016d8ab689b6be253503d31afa6/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5936ecc24f8100b106c2e0cbaa8c1c7d5fef481f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5936ecc24f8100b106c2e0cbaa8c1c7d5fef481f", "html_url": "https://github.com/rust-lang/rust/commit/5936ecc24f8100b106c2e0cbaa8c1c7d5fef481f"}, {"sha": "78d3d3790a56227ba915d559907f5e6db54640db", "url": "https://api.github.com/repos/rust-lang/rust/commits/78d3d3790a56227ba915d559907f5e6db54640db", "html_url": "https://github.com/rust-lang/rust/commit/78d3d3790a56227ba915d559907f5e6db54640db"}], "stats": {"total": 306, "additions": 173, "deletions": 133}, "files": [{"sha": "b64870401f1fdbe808b97ed2a58fa1a7b6d6e41d", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f4d6d73a9d01016d8ab689b6be253503d31afa6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4d6d73a9d01016d8ab689b6be253503d31afa6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=3f4d6d73a9d01016d8ab689b6be253503d31afa6", "patch": "@@ -234,6 +234,7 @@ pub const SD_RECEIVE: c_int = 0;\n pub const SD_SEND: c_int = 1;\n pub const SOCK_DGRAM: c_int = 2;\n pub const SOCK_STREAM: c_int = 1;\n+pub const SOCKET_ERROR: c_int = -1;\n pub const SOL_SOCKET: c_int = 0xffff;\n pub const SO_RCVTIMEO: c_int = 0x1006;\n pub const SO_SNDTIMEO: c_int = 0x1005;"}, {"sha": "9cea5c5e63a2df56ec4caed7be741e70c785570f", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 172, "deletions": 133, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/3f4d6d73a9d01016d8ab689b6be253503d31afa6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f4d6d73a9d01016d8ab689b6be253503d31afa6/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=3f4d6d73a9d01016d8ab689b6be253503d31afa6", "patch": "@@ -12,7 +12,7 @@ use crate::sys_common::net;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n \n-use libc::{c_int, c_long, c_ulong, c_void};\n+use libc::{c_int, c_long, c_ulong};\n \n pub type wrlen_t = i32;\n \n@@ -93,153 +93,177 @@ where\n \n impl Socket {\n     pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n-        let fam = match *addr {\n+        let family = match *addr {\n             SocketAddr::V4(..) => c::AF_INET,\n             SocketAddr::V6(..) => c::AF_INET6,\n         };\n         let socket = unsafe {\n-            match c::WSASocketW(\n-                fam,\n+            c::WSASocketW(\n+                family,\n                 ty,\n                 0,\n                 ptr::null_mut(),\n                 0,\n                 c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n-            ) {\n-                c::INVALID_SOCKET => match c::WSAGetLastError() {\n-                    c::WSAEPROTOTYPE | c::WSAEINVAL => {\n-                        match c::WSASocketW(fam, ty, 0, ptr::null_mut(), 0, c::WSA_FLAG_OVERLAPPED)\n-                        {\n-                            c::INVALID_SOCKET => Err(last_error()),\n-                            n => {\n-                                let s = Socket(n);\n-                                s.set_no_inherit()?;\n-                                Ok(s)\n-                            }\n-                        }\n-                    }\n-                    n => Err(io::Error::from_raw_os_error(n)),\n-                },\n-                n => Ok(Socket(n)),\n+            )\n+        };\n+\n+        if socket != c::INVALID_SOCKET {\n+            Ok(Self(socket))\n+        } else {\n+            let error = unsafe { c::WSAGetLastError() };\n+\n+            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n+                return Err(io::Error::from_raw_os_error(error));\n+            }\n+\n+            let socket =\n+                unsafe { c::WSASocketW(family, ty, 0, ptr::null_mut(), 0, c::WSA_FLAG_OVERLAPPED) };\n+\n+            if socket == c::INVALID_SOCKET {\n+                return Err(last_error());\n             }\n-        }?;\n-        Ok(socket)\n+\n+            let socket = Self(socket);\n+            socket.set_no_inherit()?;\n+            Ok(socket)\n+        }\n     }\n \n     pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n         self.set_nonblocking(true)?;\n-        let r = unsafe {\n+        let result = {\n             let (addrp, len) = addr.into_inner();\n-            cvt(c::connect(self.0, addrp, len))\n+            let result = unsafe { c::connect(self.0, addrp, len) };\n+            cvt(result).map(drop)\n         };\n         self.set_nonblocking(false)?;\n \n-        match r {\n-            Ok(_) => return Ok(()),\n-            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {}\n-            Err(e) => return Err(e),\n-        }\n-\n-        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new_const(\n-                io::ErrorKind::InvalidInput,\n-                &\"cannot set a 0 duration timeout\",\n-            ));\n-        }\n-\n-        let mut timeout = c::timeval {\n-            tv_sec: timeout.as_secs() as c_long,\n-            tv_usec: (timeout.subsec_nanos() / 1000) as c_long,\n-        };\n-        if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n-            timeout.tv_usec = 1;\n-        }\n+        match result {\n+            Err(ref error) if error.kind() == io::ErrorKind::WouldBlock => {\n+                if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n+                    return Err(io::Error::new_const(\n+                        io::ErrorKind::InvalidInput,\n+                        &\"cannot set a 0 duration timeout\",\n+                    ));\n+                }\n \n-        let fds = unsafe {\n-            let mut fds = mem::zeroed::<c::fd_set>();\n-            fds.fd_count = 1;\n-            fds.fd_array[0] = self.0;\n-            fds\n-        };\n+                let mut timeout = c::timeval {\n+                    tv_sec: timeout.as_secs() as c_long,\n+                    tv_usec: (timeout.subsec_nanos() / 1000) as c_long,\n+                };\n \n-        let mut writefds = fds;\n-        let mut errorfds = fds;\n+                if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n+                    timeout.tv_usec = 1;\n+                }\n \n-        let n =\n-            unsafe { cvt(c::select(1, ptr::null_mut(), &mut writefds, &mut errorfds, &timeout))? };\n+                let fds = {\n+                    let mut fds = unsafe { mem::zeroed::<c::fd_set>() };\n+                    fds.fd_count = 1;\n+                    fds.fd_array[0] = self.0;\n+                    fds\n+                };\n+\n+                let mut writefds = fds;\n+                let mut errorfds = fds;\n+\n+                let count = {\n+                    let result = unsafe {\n+                        c::select(1, ptr::null_mut(), &mut writefds, &mut errorfds, &timeout)\n+                    };\n+                    cvt(result)?\n+                };\n+\n+                match count {\n+                    0 => {\n+                        Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\"))\n+                    }\n+                    _ => {\n+                        if writefds.fd_count != 1 {\n+                            if let Some(e) = self.take_error()? {\n+                                return Err(e);\n+                            }\n+                        }\n \n-        match n {\n-            0 => Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\")),\n-            _ => {\n-                if writefds.fd_count != 1 {\n-                    if let Some(e) = self.take_error()? {\n-                        return Err(e);\n+                        Ok(())\n                     }\n                 }\n-                Ok(())\n             }\n+            _ => result,\n         }\n     }\n \n     pub fn accept(&self, storage: *mut c::SOCKADDR, len: *mut c_int) -> io::Result<Socket> {\n-        let socket = unsafe {\n-            match c::accept(self.0, storage, len) {\n-                c::INVALID_SOCKET => Err(last_error()),\n-                n => Ok(Socket(n)),\n-            }\n-        }?;\n-        Ok(socket)\n+        let socket = unsafe { c::accept(self.0, storage, len) };\n+\n+        match socket {\n+            c::INVALID_SOCKET => Err(last_error()),\n+            _ => Ok(Self(socket)),\n+        }\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {\n+        let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFO>() };\n+        let result = unsafe { c::WSADuplicateSocketW(self.0, c::GetCurrentProcessId(), &mut info) };\n+        cvt(result)?;\n         let socket = unsafe {\n-            let mut info: c::WSAPROTOCOL_INFO = mem::zeroed();\n-            cvt(c::WSADuplicateSocketW(self.0, c::GetCurrentProcessId(), &mut info))?;\n-\n-            match c::WSASocketW(\n+            c::WSASocketW(\n                 info.iAddressFamily,\n                 info.iSocketType,\n                 info.iProtocol,\n                 &mut info,\n                 0,\n                 c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n-            ) {\n-                c::INVALID_SOCKET => match c::WSAGetLastError() {\n-                    c::WSAEPROTOTYPE | c::WSAEINVAL => {\n-                        match c::WSASocketW(\n-                            info.iAddressFamily,\n-                            info.iSocketType,\n-                            info.iProtocol,\n-                            &mut info,\n-                            0,\n-                            c::WSA_FLAG_OVERLAPPED,\n-                        ) {\n-                            c::INVALID_SOCKET => Err(last_error()),\n-                            n => {\n-                                let s = Socket(n);\n-                                s.set_no_inherit()?;\n-                                Ok(s)\n-                            }\n-                        }\n-                    }\n-                    n => Err(io::Error::from_raw_os_error(n)),\n-                },\n-                n => Ok(Socket(n)),\n+            )\n+        };\n+\n+        if socket != c::INVALID_SOCKET {\n+            Ok(Self(socket))\n+        } else {\n+            let error = unsafe { c::WSAGetLastError() };\n+\n+            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n+                return Err(io::Error::from_raw_os_error(error));\n+            }\n+\n+            let socket = unsafe {\n+                c::WSASocketW(\n+                    info.iAddressFamily,\n+                    info.iSocketType,\n+                    info.iProtocol,\n+                    &mut info,\n+                    0,\n+                    c::WSA_FLAG_OVERLAPPED,\n+                )\n+            };\n+\n+            if socket == c::INVALID_SOCKET {\n+                return Err(last_error());\n             }\n-        }?;\n-        Ok(socket)\n+\n+            let socket = Self(socket);\n+            socket.set_no_inherit()?;\n+            Ok(socket)\n+        }\n     }\n \n     fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n-        let len = cmp::min(buf.len(), i32::MAX as usize) as i32;\n-        unsafe {\n-            match c::recv(self.0, buf.as_mut_ptr() as *mut c_void, len, flags) {\n-                -1 if c::WSAGetLastError() == c::WSAESHUTDOWN => Ok(0),\n-                -1 => Err(last_error()),\n-                n => Ok(n as usize),\n+        let length = cmp::min(buf.len(), i32::MAX as usize) as i32;\n+        let result = unsafe { c::recv(self.0, buf.as_mut_ptr() as *mut _, length, flags) };\n+\n+        match result {\n+            c::SOCKET_ERROR => {\n+                let error = unsafe { c::WSAGetLastError() };\n+\n+                if error == c::WSAESHUTDOWN {\n+                    Ok(0)\n+                } else {\n+                    Err(io::Error::from_raw_os_error(error))\n+                }\n             }\n+            _ => Ok(result as usize),\n         }\n     }\n \n@@ -250,23 +274,31 @@ impl Socket {\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n-        let len = cmp::min(bufs.len(), c::DWORD::MAX as usize) as c::DWORD;\n+        let length = cmp::min(bufs.len(), c::DWORD::MAX as usize) as c::DWORD;\n         let mut nread = 0;\n         let mut flags = 0;\n-        unsafe {\n-            let ret = c::WSARecv(\n+        let result = unsafe {\n+            c::WSARecv(\n                 self.0,\n                 bufs.as_mut_ptr() as *mut c::WSABUF,\n-                len,\n+                length,\n                 &mut nread,\n                 &mut flags,\n                 ptr::null_mut(),\n                 ptr::null_mut(),\n-            );\n-            match ret {\n-                0 => Ok(nread as usize),\n-                _ if c::WSAGetLastError() == c::WSAESHUTDOWN => Ok(0),\n-                _ => Err(last_error()),\n+            )\n+        };\n+\n+        match result {\n+            0 => Ok(nread as usize),\n+            _ => {\n+                let error = unsafe { c::WSAGetLastError() };\n+\n+                if error == c::WSAESHUTDOWN {\n+                    Ok(0)\n+                } else {\n+                    Err(io::Error::from_raw_os_error(error))\n+                }\n             }\n         }\n     }\n@@ -285,27 +317,34 @@ impl Socket {\n         buf: &mut [u8],\n         flags: c_int,\n     ) -> io::Result<(usize, SocketAddr)> {\n-        let mut storage: c::SOCKADDR_STORAGE_LH = unsafe { mem::zeroed() };\n+        let mut storage = unsafe { mem::zeroed::<c::SOCKADDR_STORAGE_LH>() };\n         let mut addrlen = mem::size_of_val(&storage) as c::socklen_t;\n-        let len = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n+        let length = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n \n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n-        unsafe {\n-            match c::recvfrom(\n+        let result = unsafe {\n+            c::recvfrom(\n                 self.0,\n-                buf.as_mut_ptr() as *mut c_void,\n-                len,\n+                buf.as_mut_ptr() as *mut _,\n+                length,\n                 flags,\n                 &mut storage as *mut _ as *mut _,\n                 &mut addrlen,\n-            ) {\n-                -1 if c::WSAGetLastError() == c::WSAESHUTDOWN => {\n+            )\n+        };\n+\n+        match result {\n+            c::SOCKET_ERROR => {\n+                let error = unsafe { c::WSAGetLastError() };\n+\n+                if error == c::WSAESHUTDOWN {\n                     Ok((0, net::sockaddr_to_addr(&storage, addrlen as usize)?))\n+                } else {\n+                    Err(io::Error::from_raw_os_error(error))\n                 }\n-                -1 => Err(last_error()),\n-                n => Ok((n as usize, net::sockaddr_to_addr(&storage, addrlen as usize)?)),\n             }\n+            _ => Ok((result as usize, net::sockaddr_to_addr(&storage, addrlen as usize)?)),\n         }\n     }\n \n@@ -318,20 +357,20 @@ impl Socket {\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let len = cmp::min(bufs.len(), c::DWORD::MAX as usize) as c::DWORD;\n+        let length = cmp::min(bufs.len(), c::DWORD::MAX as usize) as c::DWORD;\n         let mut nwritten = 0;\n-        unsafe {\n-            cvt(c::WSASend(\n+        let result = unsafe {\n+            c::WSASend(\n                 self.0,\n-                bufs.as_ptr() as *const c::WSABUF as *mut c::WSABUF,\n-                len,\n+                bufs.as_ptr() as *const c::WSABUF as *mut _,\n+                length,\n                 &mut nwritten,\n                 0,\n                 ptr::null_mut(),\n                 ptr::null_mut(),\n-            ))?;\n-        }\n-        Ok(nwritten as usize)\n+            )\n+        };\n+        cvt(result).map(|_| nwritten as usize)\n     }\n \n     #[inline]\n@@ -384,14 +423,14 @@ impl Socket {\n             Shutdown::Read => c::SD_RECEIVE,\n             Shutdown::Both => c::SD_BOTH,\n         };\n-        cvt(unsafe { c::shutdown(self.0, how) })?;\n-        Ok(())\n+        let result = unsafe { c::shutdown(self.0, how) };\n+        cvt(result).map(drop)\n     }\n \n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         let mut nonblocking = nonblocking as c_ulong;\n-        let r = unsafe { c::ioctlsocket(self.0, c::FIONBIO as c_int, &mut nonblocking) };\n-        if r == 0 { Ok(()) } else { Err(io::Error::last_os_error()) }\n+        let result = unsafe { c::ioctlsocket(self.0, c::FIONBIO as c_int, &mut nonblocking) };\n+        cvt(result).map(drop)\n     }\n \n     pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {"}]}