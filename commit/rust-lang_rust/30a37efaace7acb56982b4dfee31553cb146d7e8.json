{"sha": "30a37efaace7acb56982b4dfee31553cb146d7e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYTM3ZWZhYWNlN2FjYjU2OTgyYjRkZmVlMzE1NTNjYjE0NmQ3ZTg=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2018-02-05T07:21:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-05T07:21:21Z"}, "message": "Merge pull request #2433 from kimsnj/matches_sugg\n\nFix suggestions for ref matches", "tree": {"sha": "a36edce5bcee9593788b802ae3ceb7a05e8912e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a36edce5bcee9593788b802ae3ceb7a05e8912e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30a37efaace7acb56982b4dfee31553cb146d7e8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaeAXxCRBK7hj4Ov3rIwAAdHIIAD/ljspx6f/Cy0/srxL13Bdo\nTnP78vMOXrK9kj0Io/qy2g0X31ZG7FFdKP8UNtqR3BH2fCO/g0e21lbLKgYoH0HI\ndQSHtCxystmPLGgF/ICDVqOFJt/8rGBpbYn1Hl5Qo6brBNX+JNUf+CZoZ3c53KR4\ntIVVTiUiCqDXBWVZPzIQ5Bp0uwDzjxpPuSKLHk3DLvMiWzmVCdr3K5ZgXKjFbugD\n/xea6xstTlHfivRePPgXUNoVJW0o8RLzvFXP2lqA1XYTWuu9wHkoPA5EiqE0D9/D\nkL0/IJ1VHVxS001ICaY7qQVjE9fmjrRhxeShCwynCpx6DZFnYnguMLwaPSXrZFI=\n=1Sls\n-----END PGP SIGNATURE-----\n", "payload": "tree a36edce5bcee9593788b802ae3ceb7a05e8912e4\nparent 7fddc6116e12e0d40b8895e7112d226fcec14d06\nparent 21f606bd688c9a45b372790b26d3c3d083f1cdd1\nauthor Oliver Schneider <oli-obk@users.noreply.github.com> 1517815281 +0100\ncommitter GitHub <noreply@github.com> 1517815281 +0100\n\nMerge pull request #2433 from kimsnj/matches_sugg\n\nFix suggestions for ref matches"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30a37efaace7acb56982b4dfee31553cb146d7e8", "html_url": "https://github.com/rust-lang/rust/commit/30a37efaace7acb56982b4dfee31553cb146d7e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30a37efaace7acb56982b4dfee31553cb146d7e8/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fddc6116e12e0d40b8895e7112d226fcec14d06", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fddc6116e12e0d40b8895e7112d226fcec14d06", "html_url": "https://github.com/rust-lang/rust/commit/7fddc6116e12e0d40b8895e7112d226fcec14d06"}, {"sha": "21f606bd688c9a45b372790b26d3c3d083f1cdd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/21f606bd688c9a45b372790b26d3c3d083f1cdd1", "html_url": "https://github.com/rust-lang/rust/commit/21f606bd688c9a45b372790b26d3c3d083f1cdd1"}], "stats": {"total": 92, "additions": 46, "deletions": 46}, "files": [{"sha": "979f0806e525bc6fab3af1c1a41e853ab356b3d5", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 28, "deletions": 41, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/30a37efaace7acb56982b4dfee31553cb146d7e8/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a37efaace7acb56982b4dfee31553cb146d7e8/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=30a37efaace7acb56982b4dfee31553cb146d7e8", "patch": "@@ -11,8 +11,8 @@ use syntax::ast::LitKind;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use utils::paths;\n-use utils::{expr_block, in_external_macro, is_allowed, is_expn_of, match_qpath, match_type, remove_blocks,\n-            snippet, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty};\n+use utils::{expr_block, in_external_macro, is_allowed, is_expn_of, match_qpath, match_type, multispan_sugg,\n+            remove_blocks, snippet, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for matches with a single arm where an `if let`\n@@ -195,8 +195,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchPass {\n             check_wild_err_arm(cx, ex, arms);\n             check_match_as_ref(cx, ex, arms, expr);\n         }\n-        if let ExprMatch(ref ex, ref arms, source) = expr.node {\n-            check_match_ref_pats(cx, ex, arms, source, expr);\n+        if let ExprMatch(ref ex, ref arms, _) = expr.node {\n+            check_match_ref_pats(cx, ex, arms, expr);\n         }\n     }\n }\n@@ -400,37 +400,34 @@ fn is_panic_block(block: &Block) -> bool {\n     }\n }\n \n-fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: MatchSource, expr: &Expr) {\n+fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     if has_only_ref_pats(arms) {\n-        if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n-            span_lint_and_then(\n-                cx,\n-                MATCH_REF_PATS,\n-                expr.span,\n+        let mut suggs = Vec::new();\n+        let (title, msg) = if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n+            suggs.push((ex.span, Sugg::hir(cx, inner, \"..\").to_string()));\n+            (\n                 \"you don't need to add `&` to both the expression and the patterns\",\n-                |db| {\n-                    let inner = Sugg::hir(cx, inner, \"..\");\n-                    let template = match_template(expr.span, source, &inner);\n-                    db.span_suggestion(expr.span, \"try\", template);\n-                },\n-            );\n+                \"try\",\n+            )\n         } else {\n-            span_lint_and_then(\n-                cx,\n-                MATCH_REF_PATS,\n-                expr.span,\n+            suggs.push((ex.span, Sugg::hir(cx, ex, \"..\").deref().to_string()));\n+            (\n                 \"you don't need to add `&` to all patterns\",\n-                |db| {\n-                    let ex = Sugg::hir(cx, ex, \"..\");\n-                    let template = match_template(expr.span, source, &ex.deref());\n-                    db.span_suggestion(\n-                        expr.span,\n-                        \"instead of prefixing all patterns with `&`, you can dereference the expression\",\n-                        template,\n-                    );\n-                },\n-            );\n-        }\n+                \"instead of prefixing all patterns with `&`, you can dereference the expression\",\n+            )\n+        };\n+\n+        suggs.extend(arms.iter().flat_map(|a| &a.pats).filter_map(|p| {\n+            if let PatKind::Ref(ref refp, _) = p.node {\n+                Some((p.span, snippet(cx, refp.span, \"..\").to_string()))\n+            } else {\n+                None\n+            }\n+        }));\n+\n+        span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |db| {\n+            multispan_sugg(db, msg.to_owned(), suggs);\n+        });\n     }\n }\n \n@@ -615,16 +612,6 @@ fn has_only_ref_pats(arms: &[Arm]) -> bool {\n     mapped.map_or(false, |v| v.iter().any(|el| *el))\n }\n \n-fn match_template(span: Span, source: MatchSource, expr: &Sugg) -> String {\n-    match source {\n-        MatchSource::Normal => format!(\"match {} {{ .. }}\", expr),\n-        MatchSource::IfLetDesugar { .. } => format!(\"if let .. = {} {{ .. }}\", expr),\n-        MatchSource::WhileLetDesugar => format!(\"while let .. = {} {{ .. }}\", expr),\n-        MatchSource::ForLoopDesugar => span_bug!(span, \"for loop desugared to match with &-patterns!\"),\n-        MatchSource::TryDesugar => span_bug!(span, \"`?` operator desugared to match with &-patterns!\"),\n-    }\n-}\n-\n pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n where\n     T: Copy + Ord,"}, {"sha": "5b4c222e6dcad7998106b2833a7078342e54b44c", "filename": "tests/ui/matches.stderr", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/30a37efaace7acb56982b4dfee31553cb146d7e8/tests%2Fui%2Fmatches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30a37efaace7acb56982b4dfee31553cb146d7e8/tests%2Fui%2Fmatches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatches.stderr?ref=30a37efaace7acb56982b4dfee31553cb146d7e8", "patch": "@@ -132,7 +132,9 @@ error: you don't need to add `&` to all patterns\n     = note: `-D match-ref-pats` implied by `-D warnings`\n help: instead of prefixing all patterns with `&`, you can dereference the expression\n     |\n-138 |         match *v { .. }\n+138 |         match *v {\n+139 |             Some(v) => println!(\"{:?}\", v),\n+140 |             None => println!(\"none\"),\n     |\n \n error: you don't need to add `&` to all patterns\n@@ -145,7 +147,8 @@ error: you don't need to add `&` to all patterns\n     | |_____^\n help: instead of prefixing all patterns with `&`, you can dereference the expression\n     |\n-148 |     match *tup { .. }\n+148 |     match *tup {\n+149 |         (v, 1) => println!(\"{}\", v),\n     |\n \n error: you don't need to add `&` to both the expression and the patterns\n@@ -155,7 +158,13 @@ error: you don't need to add `&` to both the expression and the patterns\n 155 | |         &Some(v) => println!(\"{:?}\", v),\n 156 | |         &None => println!(\"none\"),\n 157 | |     }\n-    | |_____^ help: try: `match w { .. }`\n+    | |_____^\n+help: try\n+    |\n+154 |     match w {\n+155 |         Some(v) => println!(\"{:?}\", v),\n+156 |         None => println!(\"none\"),\n+    |\n \n error: you don't need to add `&` to all patterns\n    --> $DIR/matches.rs:165:5\n@@ -166,7 +175,7 @@ error: you don't need to add `&` to all patterns\n     | |_____^\n help: instead of prefixing all patterns with `&`, you can dereference the expression\n     |\n-165 |     if let .. = *a { .. }\n+165 |     if let None = *a {\n     |\n \n error: you don't need to add `&` to both the expression and the patterns\n@@ -175,7 +184,11 @@ error: you don't need to add `&` to both the expression and the patterns\n 170 | /     if let &None = &b {\n 171 | |         println!(\"none\");\n 172 | |     }\n-    | |_____^ help: try: `if let .. = b { .. }`\n+    | |_____^\n+help: try\n+    |\n+170 |     if let None = b {\n+    |\n \n error: some ranges overlap\n    --> $DIR/matches.rs:179:9"}]}