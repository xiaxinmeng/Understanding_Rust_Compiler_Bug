{"sha": "dda892a83d337556fd48aca78c07c7d3f5df69bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYTg5MmE4M2QzMzc1NTZmZDQ4YWNhNzhjMDdjN2QzZjVkZjY5YmQ=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-03-15T14:03:21Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-03-21T17:36:23Z"}, "message": "Make `fn move_path_for` take `&mut self` instead of `&self`. This is a\nprecursor for a number of other simplifying changes (mostly removing\nuses of `RefCell`).\n\nFactor lookup method out of `fn move_path_for`.", "tree": {"sha": "12637d31df84bfd5dd97140a9af3cb8b4a4fb600", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12637d31df84bfd5dd97140a9af3cb8b4a4fb600"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dda892a83d337556fd48aca78c07c7d3f5df69bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dda892a83d337556fd48aca78c07c7d3f5df69bd", "html_url": "https://github.com/rust-lang/rust/commit/dda892a83d337556fd48aca78c07c7d3f5df69bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dda892a83d337556fd48aca78c07c7d3f5df69bd/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9901768b4cf0472bb9e3c87750c69fcbe524a5e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9901768b4cf0472bb9e3c87750c69fcbe524a5e1", "html_url": "https://github.com/rust-lang/rust/commit/9901768b4cf0472bb9e3c87750c69fcbe524a5e1"}], "stats": {"total": 73, "additions": 37, "deletions": 36}, "files": [{"sha": "0e9419544e104d711195e0d7a1b27cfa73985514", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/dda892a83d337556fd48aca78c07c7d3f5df69bd/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dda892a83d337556fd48aca78c07c7d3f5df69bd/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=dda892a83d337556fd48aca78c07c7d3f5df69bd", "patch": "@@ -399,45 +399,42 @@ impl<'tcx> MovePathLookup<'tcx> {\n }\n \n impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n-    // (use of `&self` here is going to necessitate use of e.g. RefCell\n-    //  or some other &-safe data accumulator)\n-    //\n-    // Caller must ensure self's RefCells (i.e. `self.pre_move_paths`\n-    // and `self.rev_lookup`) are not mutably borrowed.\n-    fn move_path_for(&self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n-        let lookup = {\n+    fn lookup(&mut self, lval: &Lvalue<'tcx>) -> Lookup<MovePathIndex> {\n+        let proj = {\n             let mut rev_lookup = self.rev_lookup.borrow_mut();\n             match *lval {\n                 Lvalue::Var(var_idx) =>\n-                    rev_lookup.lookup_var(var_idx),\n+                    return rev_lookup.lookup_var(var_idx),\n                 Lvalue::Temp(temp_idx) =>\n-                    rev_lookup.lookup_temp(temp_idx),\n+                    return rev_lookup.lookup_temp(temp_idx),\n                 Lvalue::Arg(arg_idx) =>\n-                    rev_lookup.lookup_arg(arg_idx),\n+                    return rev_lookup.lookup_arg(arg_idx),\n                 Lvalue::Static(_def_id) =>\n-                    rev_lookup.lookup_static(),\n+                    return rev_lookup.lookup_static(),\n                 Lvalue::ReturnPointer =>\n-                    rev_lookup.lookup_return_pointer(),\n+                    return rev_lookup.lookup_return_pointer(),\n                 Lvalue::Projection(ref proj) => {\n-                    // Manually drop the rev_lookup ...\n-                    drop(rev_lookup);\n-\n-                    // ... so that we can reborrow it here (which may\n-                    //     well be building new move path) ...\n-                    let base_index = self.move_path_for(&proj.base);\n-\n-                    // ... and restablish exclusive access here.\n-                    let mut rev_lookup = self.rev_lookup.borrow_mut();\n-                    rev_lookup.lookup_proj(proj, base_index)\n+                    proj\n                 }\n             }\n+            // drop the rev_lookup here ...\n         };\n \n-        let mut pre_move_paths = self.pre_move_paths.borrow_mut();\n+        let base_index = self.move_path_for(&proj.base);\n \n-        // At this point, `lookup` is either the previously assigned\n-        // index or a newly-allocated one.\n-        debug_assert!(lookup.idx() <= pre_move_paths.len());\n+        // ... restablish exclusive access to rev_lookup here.\n+        let mut rev_lookup = self.rev_lookup.borrow_mut();\n+        rev_lookup.lookup_proj(proj, base_index)\n+    }\n+\n+    // Caller must ensure self's RefCells (i.e. `self.pre_move_paths`\n+    // and `self.rev_lookup`) are not mutably borrowed.\n+    fn move_path_for(&mut self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n+        let lookup: Lookup<MovePathIndex> = self.lookup(lval);\n+\n+        // `lookup` is either the previously assigned index or a\n+        // newly-allocated one.\n+        debug_assert!(lookup.idx() <= self.pre_move_paths.borrow().len());\n \n         if let Lookup(LookupKind::Generate, mpi) = lookup {\n             let parent;\n@@ -462,14 +459,13 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n                     content = Some(lval);\n \n                     // Here, install new MovePath as new first_child.\n-                    drop(pre_move_paths);\n \n                     // Note: `parent` previously allocated (Projection\n                     // case of match above established this).\n                     let idx = self.move_path_for(&proj.base);\n                     parent = Some(idx);\n \n-                    pre_move_paths = self.pre_move_paths.borrow_mut();\n+                    let mut pre_move_paths = self.pre_move_paths.borrow_mut();\n                     let parent_move_path = &mut pre_move_paths[idx.idx()];\n \n                     // At last: Swap in the new first_child.\n@@ -490,6 +486,7 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n                 first_child: Cell::new(None),\n             };\n \n+            let mut pre_move_paths = self.pre_move_paths.borrow_mut();\n             pre_move_paths.push(move_path);\n         }\n \n@@ -517,7 +514,10 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx>\n     let mut loc_map: Vec<_> = iter::repeat(Vec::new()).take(bbs.len()).collect();\n     let mut path_map = Vec::new();\n \n-    let builder = MovePathDataBuilder {\n+    // this is mutable only because we will move it to and fro' the\n+    // BlockContexts constructed on each iteration. (Moving is more\n+    // straight-forward than mutable borrows in this instance.)\n+    let mut builder = MovePathDataBuilder {\n         mir: mir,\n         pre_move_paths: RefCell::new(Vec::new()),\n         rev_lookup: RefCell::new(MovePathLookup::new()),\n@@ -535,7 +535,7 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx>\n         let mut bb_ctxt = BlockContext {\n             tcx: tcx,\n             moves: &mut moves,\n-            builder: &builder,\n+            builder: builder,\n             path_map: &mut path_map,\n             loc_map_bb: loc_map_bb,\n         };\n@@ -545,7 +545,7 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx>\n             match stmt.kind {\n                 StatementKind::Assign(ref lval, ref rval) => {\n                     // ensure MovePath created for `lval`.\n-                    builder.move_path_for(lval);\n+                    bb_ctxt.builder.move_path_for(lval);\n \n                     match *rval {\n                         Rvalue::Use(ref operand) => {\n@@ -626,11 +626,13 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx>\n                     if let Some((ref destination, _bb)) = *destination {\n                         // Create MovePath for `destination`, then\n                         // discard returned index.\n-                        builder.move_path_for(destination);\n+                        bb_ctxt.builder.move_path_for(destination);\n                     }\n                 }\n             }\n         }\n+\n+        builder = bb_ctxt.builder;\n     }\n \n     // At this point, we may have created some MovePaths that do not\n@@ -677,7 +679,7 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &ty::TyCtxt<'tcx>) -> MoveData<'tcx>\n struct BlockContext<'b, 'a: 'b, 'tcx: 'a> {\n     tcx: &'b ty::TyCtxt<'tcx>,\n     moves: &'b mut Vec<MoveOut>,\n-    builder: &'b MovePathDataBuilder<'a, 'tcx>,\n+    builder: MovePathDataBuilder<'a, 'tcx>,\n     path_map: &'b mut Vec<Vec<MoveOutIndex>>,\n     loc_map_bb: &'b mut Vec<Vec<MoveOutIndex>>,\n }\n@@ -687,9 +689,8 @@ impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n                         stmt_kind: StmtKind,\n                         lval: &repr::Lvalue<'tcx>,\n                         source: Location) {\n-        let builder = self.builder;\n         let tcx = self.tcx;\n-        let lval_ty = builder.mir.lvalue_ty(tcx, lval);\n+        let lval_ty = self.builder.mir.lvalue_ty(tcx, lval);\n \n         // FIXME: does lvalue_ty ever return TyError, or is it\n         // guaranteed to always return non-Infer/non-Error values?\n@@ -710,7 +711,7 @@ impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n         let i = source.index;\n         let index = MoveOutIndex::new(self.moves.len());\n \n-        let path = builder.move_path_for(lval);\n+        let path = self.builder.move_path_for(lval);\n         self.moves.push(MoveOut { path: path, source: source.clone() });\n         self.path_map.fill_to(path.idx());\n "}]}