{"sha": "aec535f8051c7cf00b1e373a05893b2cb580eeac", "node_id": "C_kwDOAAsO6NoAKGFlYzUzNWY4MDUxYzdjZjAwYjFlMzczYTA1ODkzYjJjYjU4MGVlYWM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-03-08T10:04:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-08T10:04:51Z"}, "message": "Rollup merge of #94559 - m-ou-se:thread-scope-spawn-closure-without-arg, r=Mark-Simulacrum\n\nRemove argument from closure in thread::Scope::spawn.\n\nThis implements ```@danielhenrymantilla's``` [suggestion](https://github.com/rust-lang/rust/issues/93203#issuecomment-1040798286) for improving the scoped threads interface.\n\nSummary:\n\nThe `Scope` type gets an extra lifetime argument, which represents basically its own lifetime that will be used in `&'scope Scope<'scope, 'env>`:\n\n```diff\n- pub struct Scope<'env> { .. };\n+ pub struct Scope<'scope, 'env: 'scope> { .. }\n\n  pub fn scope<'env, F, T>(f: F) -> T\n  where\n-     F: FnOnce(&Scope<'env>) -> T;\n+     F: for<'scope> FnOnce(&'scope Scope<'scope, 'env>) -> T;\n```\n\nThis simplifies the `spawn` function, which now no longer passes an argument to the closure you give it, and now uses the `'scope` lifetime for everything:\n\n```diff\n-     pub fn spawn<'scope, F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>\n+     pub fn spawn<F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>\n      where\n-         F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n+         F: FnOnce() -> T + Send + 'scope,\n-         T: Send + 'env;\n+         T: Send + 'scope;\n```\n\nThe only difference the user will notice, is that their closure now takes no arguments anymore, even when spawning threads from spawned threads:\n\n```diff\n  thread::scope(|s| {\n-     s.spawn(|_| {\n+     s.spawn(|| {\n          ...\n      });\n-     s.spawn(|s| {\n+     s.spawn(|| {\n          ...\n-         s.spawn(|_| ...);\n+         s.spawn(|| ...);\n      });\n  });\n```\n\n<details><summary>And, as a bonus, errors get <em>slightly</em> better because now any lifetime issues point to the outermost <code>s</code> (since there is only one <code>s</code>), rather than the innermost <code>s</code>, making it clear that the lifetime lasts for the entire <code>thread::scope</code>.\n\n</summary>\n\n```diff\n  error[E0373]: closure may outlive the current function, but it borrows `a`, which is owned by the current function\n   --> src/main.rs:9:21\n    |\n- 7 |         s.spawn(|s| {\n-   |                  - has type `&Scope<'1>`\n+ 6 |     thread::scope(|s| {\n+   |                    - lifetime `'1` appears in the type of `s`\n  9 |             s.spawn(|| println!(\"{:?}\", a)); // might run after `a` is dropped\n    |                     ^^                  - `a` is borrowed here\n    |                     |\n    |                     may outlive borrowed value `a`\n    |\n  note: function requires argument type to outlive `'1`\n   --> src/main.rs:9:13\n    |\n  9 |             s.spawn(|| println!(\"{:?}\", a)); // might run after `a` is dropped\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  help: to force the closure to take ownership of `a` (and any other referenced variables), use the `move` keyword\n    |\n  9 |             s.spawn(move || println!(\"{:?}\", a)); // might run after `a` is dropped\n    |                     ++++\n\"\n```\n</details>\n\nThe downside is that the signature of `scope` and `Scope` gets slightly more complex, but in most cases the user wouldn't need to write those, as they just use the argument provided by `thread::scope` without having to name its type.\n\nAnother downside is that this does not work nicely in Rust 2015 and Rust 2018, since in those editions, `s` would be captured by reference and not by copy. In those editions, the user would need to use `move ||` to capture `s` by copy. (Which is what the compiler suggests in the error.)", "tree": {"sha": "f3de1f8f634c093f02e57983faa811a872bd155f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3de1f8f634c093f02e57983faa811a872bd155f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aec535f8051c7cf00b1e373a05893b2cb580eeac", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiJypDCRBK7hj4Ov3rIwAAJsEIAIxNJXGR0YH9boVNxfTg+brR\nwUmJFWlsyrrvCpACOoIa741EdRDR3hcAwMcv9UcdGhh2i4H3PfPhFb9DCZCedhcP\nQYxWSVq/VONDpBBBpX1BuLAYdad9w26GtDVO/dGrnvHPiUPTbhDlNDvP0snvIzyH\nWT3VuskgCa/EYORQBs/hk9DYkARQMTdgGOJZdH952ruWLo/oErMKA8nknuhMvgGV\n+UM+wRwwR6o820XM+Sqbfg8gUsvKLxLT/BtpBiNbpWeZaiVsaGVSUUuegXloEDJT\nps1Z5YH4NJsHAOq1Sxzim/vWWGNlBcyLfY9Pq6Z2xWRjMIX9fxNAeUjzLOKmHjY=\n=Y5mb\n-----END PGP SIGNATURE-----\n", "payload": "tree f3de1f8f634c093f02e57983faa811a872bd155f\nparent e22331ce02d9847a0837bddc074f0e7b5d34db13\nparent a3d269e91cceb4d6234668014930f81fff587ff3\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1646733891 +0100\ncommitter GitHub <noreply@github.com> 1646733891 +0100\n\nRollup merge of #94559 - m-ou-se:thread-scope-spawn-closure-without-arg, r=Mark-Simulacrum\n\nRemove argument from closure in thread::Scope::spawn.\n\nThis implements ```@danielhenrymantilla's``` [suggestion](https://github.com/rust-lang/rust/issues/93203#issuecomment-1040798286) for improving the scoped threads interface.\n\nSummary:\n\nThe `Scope` type gets an extra lifetime argument, which represents basically its own lifetime that will be used in `&'scope Scope<'scope, 'env>`:\n\n```diff\n- pub struct Scope<'env> { .. };\n+ pub struct Scope<'scope, 'env: 'scope> { .. }\n\n  pub fn scope<'env, F, T>(f: F) -> T\n  where\n-     F: FnOnce(&Scope<'env>) -> T;\n+     F: for<'scope> FnOnce(&'scope Scope<'scope, 'env>) -> T;\n```\n\nThis simplifies the `spawn` function, which now no longer passes an argument to the closure you give it, and now uses the `'scope` lifetime for everything:\n\n```diff\n-     pub fn spawn<'scope, F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>\n+     pub fn spawn<F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>\n      where\n-         F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n+         F: FnOnce() -> T + Send + 'scope,\n-         T: Send + 'env;\n+         T: Send + 'scope;\n```\n\nThe only difference the user will notice, is that their closure now takes no arguments anymore, even when spawning threads from spawned threads:\n\n```diff\n  thread::scope(|s| {\n-     s.spawn(|_| {\n+     s.spawn(|| {\n          ...\n      });\n-     s.spawn(|s| {\n+     s.spawn(|| {\n          ...\n-         s.spawn(|_| ...);\n+         s.spawn(|| ...);\n      });\n  });\n```\n\n<details><summary>And, as a bonus, errors get <em>slightly</em> better because now any lifetime issues point to the outermost <code>s</code> (since there is only one <code>s</code>), rather than the innermost <code>s</code>, making it clear that the lifetime lasts for the entire <code>thread::scope</code>.\n\n</summary>\n\n```diff\n  error[E0373]: closure may outlive the current function, but it borrows `a`, which is owned by the current function\n   --> src/main.rs:9:21\n    |\n- 7 |         s.spawn(|s| {\n-   |                  - has type `&Scope<'1>`\n+ 6 |     thread::scope(|s| {\n+   |                    - lifetime `'1` appears in the type of `s`\n  9 |             s.spawn(|| println!(\"{:?}\", a)); // might run after `a` is dropped\n    |                     ^^                  - `a` is borrowed here\n    |                     |\n    |                     may outlive borrowed value `a`\n    |\n  note: function requires argument type to outlive `'1`\n   --> src/main.rs:9:13\n    |\n  9 |             s.spawn(|| println!(\"{:?}\", a)); // might run after `a` is dropped\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  help: to force the closure to take ownership of `a` (and any other referenced variables), use the `move` keyword\n    |\n  9 |             s.spawn(move || println!(\"{:?}\", a)); // might run after `a` is dropped\n    |                     ++++\n\"\n```\n</details>\n\nThe downside is that the signature of `scope` and `Scope` gets slightly more complex, but in most cases the user wouldn't need to write those, as they just use the argument provided by `thread::scope` without having to name its type.\n\nAnother downside is that this does not work nicely in Rust 2015 and Rust 2018, since in those editions, `s` would be captured by reference and not by copy. In those editions, the user would need to use `move ||` to capture `s` by copy. (Which is what the compiler suggests in the error.)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aec535f8051c7cf00b1e373a05893b2cb580eeac", "html_url": "https://github.com/rust-lang/rust/commit/aec535f8051c7cf00b1e373a05893b2cb580eeac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aec535f8051c7cf00b1e373a05893b2cb580eeac/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e22331ce02d9847a0837bddc074f0e7b5d34db13", "url": "https://api.github.com/repos/rust-lang/rust/commits/e22331ce02d9847a0837bddc074f0e7b5d34db13", "html_url": "https://github.com/rust-lang/rust/commit/e22331ce02d9847a0837bddc074f0e7b5d34db13"}, {"sha": "a3d269e91cceb4d6234668014930f81fff587ff3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3d269e91cceb4d6234668014930f81fff587ff3", "html_url": "https://github.com/rust-lang/rust/commit/a3d269e91cceb4d6234668014930f81fff587ff3"}], "stats": {"total": 50, "additions": 26, "deletions": 24}, "files": [{"sha": "2da04ab2cea7d4d78d1f9e517cd35a821b3ab87e", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aec535f8051c7cf00b1e373a05893b2cb580eeac/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec535f8051c7cf00b1e373a05893b2cb580eeac/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=aec535f8051c7cf00b1e373a05893b2cb580eeac", "patch": "@@ -352,7 +352,7 @@ impl AtomicBool {\n     /// let a = &*AtomicBool::from_mut_slice(&mut some_bools);\n     /// std::thread::scope(|s| {\n     ///     for i in 0..a.len() {\n-    ///         s.spawn(move |_| a[i].store(true, Ordering::Relaxed));\n+    ///         s.spawn(move || a[i].store(true, Ordering::Relaxed));\n     ///     }\n     /// });\n     /// assert_eq!(some_bools, [true; 10]);\n@@ -984,7 +984,7 @@ impl<T> AtomicPtr<T> {\n     /// let a = &*AtomicPtr::from_mut_slice(&mut some_ptrs);\n     /// std::thread::scope(|s| {\n     ///     for i in 0..a.len() {\n-    ///         s.spawn(move |_| {\n+    ///         s.spawn(move || {\n     ///             let name = Box::new(format!(\"thread{i}\"));\n     ///             a[i].store(Box::into_raw(name), Ordering::Relaxed);\n     ///         });\n@@ -1533,7 +1533,7 @@ macro_rules! atomic_int {\n             #[doc = concat!(\"let a = &*\", stringify!($atomic_type), \"::from_mut_slice(&mut some_ints);\")]\n             /// std::thread::scope(|s| {\n             ///     for i in 0..a.len() {\n-            ///         s.spawn(move |_| a[i].store(i as _, Ordering::Relaxed));\n+            ///         s.spawn(move || a[i].store(i as _, Ordering::Relaxed));\n             ///     }\n             /// });\n             /// for (i, n) in some_ints.into_iter().enumerate() {"}, {"sha": "4af58f1a3807533b9ba4e143a63326122002a8ba", "filename": "library/std/src/thread/scoped.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/aec535f8051c7cf00b1e373a05893b2cb580eeac/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec535f8051c7cf00b1e373a05893b2cb580eeac/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs?ref=aec535f8051c7cf00b1e373a05893b2cb580eeac", "patch": "@@ -9,23 +9,24 @@ use crate::sync::Arc;\n /// A scope to spawn scoped threads in.\n ///\n /// See [`scope`] for details.\n-pub struct Scope<'env> {\n+pub struct Scope<'scope, 'env: 'scope> {\n     data: ScopeData,\n-    /// Invariance over 'env, to make sure 'env cannot shrink,\n+    /// Invariance over 'scope, to make sure 'scope cannot shrink,\n     /// which is necessary for soundness.\n     ///\n     /// Without invariance, this would compile fine but be unsound:\n     ///\n-    /// ```compile_fail\n+    /// ```compile_fail,E0373\n     /// #![feature(scoped_threads)]\n     ///\n     /// std::thread::scope(|s| {\n-    ///     s.spawn(|s| {\n+    ///     s.spawn(|| {\n     ///         let a = String::from(\"abcd\");\n-    ///         s.spawn(|_| println!(\"{:?}\", a)); // might run after `a` is dropped\n+    ///         s.spawn(|| println!(\"{:?}\", a)); // might run after `a` is dropped\n     ///     });\n     /// });\n     /// ```\n+    scope: PhantomData<&'scope mut &'scope ()>,\n     env: PhantomData<&'env mut &'env ()>,\n }\n \n@@ -88,12 +89,12 @@ impl ScopeData {\n /// let mut x = 0;\n ///\n /// thread::scope(|s| {\n-///     s.spawn(|_| {\n+///     s.spawn(|| {\n ///         println!(\"hello from the first scoped thread\");\n ///         // We can borrow `a` here.\n ///         dbg!(&a);\n ///     });\n-///     s.spawn(|_| {\n+///     s.spawn(|| {\n ///         println!(\"hello from the second scoped thread\");\n ///         // We can even mutably borrow `x` here,\n ///         // because no other threads are using it.\n@@ -109,7 +110,7 @@ impl ScopeData {\n #[track_caller]\n pub fn scope<'env, F, T>(f: F) -> T\n where\n-    F: FnOnce(&Scope<'env>) -> T,\n+    F: for<'scope> FnOnce(&'scope Scope<'scope, 'env>) -> T,\n {\n     let scope = Scope {\n         data: ScopeData {\n@@ -118,6 +119,7 @@ where\n             a_thread_panicked: AtomicBool::new(false),\n         },\n         env: PhantomData,\n+        scope: PhantomData,\n     };\n \n     // Run `f`, but catch panics so we can make sure to wait for all the threads to join.\n@@ -138,7 +140,7 @@ where\n     }\n }\n \n-impl<'env> Scope<'env> {\n+impl<'scope, 'env> Scope<'scope, 'env> {\n     /// Spawns a new thread within a scope, returning a [`ScopedJoinHandle`] for it.\n     ///\n     /// Unlike non-scoped threads, threads spawned with this function may\n@@ -163,10 +165,10 @@ impl<'env> Scope<'env> {\n     /// to recover from such errors.\n     ///\n     /// [`join`]: ScopedJoinHandle::join\n-    pub fn spawn<'scope, F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>\n+    pub fn spawn<F, T>(&'scope self, f: F) -> ScopedJoinHandle<'scope, T>\n     where\n-        F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n-        T: Send + 'env,\n+        F: FnOnce() -> T + Send + 'scope,\n+        T: Send + 'scope,\n     {\n         Builder::new().spawn_scoped(self, f).expect(\"failed to spawn thread\")\n     }\n@@ -196,7 +198,7 @@ impl Builder {\n     /// thread::scope(|s| {\n     ///     thread::Builder::new()\n     ///         .name(\"first\".to_string())\n-    ///         .spawn_scoped(s, |_|\n+    ///         .spawn_scoped(s, ||\n     ///     {\n     ///         println!(\"hello from the {:?} scoped thread\", thread::current().name());\n     ///         // We can borrow `a` here.\n@@ -205,7 +207,7 @@ impl Builder {\n     ///     .unwrap();\n     ///     thread::Builder::new()\n     ///         .name(\"second\".to_string())\n-    ///         .spawn_scoped(s, |_|\n+    ///         .spawn_scoped(s, ||\n     ///     {\n     ///         println!(\"hello from the {:?} scoped thread\", thread::current().name());\n     ///         // We can even mutably borrow `x` here,\n@@ -222,14 +224,14 @@ impl Builder {\n     /// ```\n     pub fn spawn_scoped<'scope, 'env, F, T>(\n         self,\n-        scope: &'scope Scope<'env>,\n+        scope: &'scope Scope<'scope, 'env>,\n         f: F,\n     ) -> io::Result<ScopedJoinHandle<'scope, T>>\n     where\n-        F: FnOnce(&Scope<'env>) -> T + Send + 'env,\n-        T: Send + 'env,\n+        F: FnOnce() -> T + Send + 'scope,\n+        T: Send + 'scope,\n     {\n-        Ok(ScopedJoinHandle(unsafe { self.spawn_unchecked_(|| f(scope), Some(&scope.data)) }?))\n+        Ok(ScopedJoinHandle(unsafe { self.spawn_unchecked_(f, Some(&scope.data)) }?))\n     }\n }\n \n@@ -244,7 +246,7 @@ impl<'scope, T> ScopedJoinHandle<'scope, T> {\n     /// use std::thread;\n     ///\n     /// thread::scope(|s| {\n-    ///     let t = s.spawn(|_| {\n+    ///     let t = s.spawn(|| {\n     ///         println!(\"hello\");\n     ///     });\n     ///     println!(\"thread id: {:?}\", t.thread().id());\n@@ -277,7 +279,7 @@ impl<'scope, T> ScopedJoinHandle<'scope, T> {\n     /// use std::thread;\n     ///\n     /// thread::scope(|s| {\n-    ///     let t = s.spawn(|_| {\n+    ///     let t = s.spawn(|| {\n     ///         panic!(\"oh no\");\n     ///     });\n     ///     assert!(t.join().is_err());\n@@ -302,7 +304,7 @@ impl<'scope, T> ScopedJoinHandle<'scope, T> {\n     }\n }\n \n-impl<'env> fmt::Debug for Scope<'env> {\n+impl fmt::Debug for Scope<'_, '_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"Scope\")\n             .field(\"num_running_threads\", &self.data.num_running_threads.load(Ordering::Relaxed))"}]}