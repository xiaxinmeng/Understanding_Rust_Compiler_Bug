{"sha": "384623daa7ca04352fc57cb2f31790961ac27e21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4NDYyM2RhYTdjYTA0MzUyZmM1N2NiMmYzMTc5MDk2MWFjMjdlMjE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-08T11:43:34Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-10T16:06:36Z"}, "message": "function pointers", "tree": {"sha": "7e33778b6c7aa667aceedd5805fd37868c6967e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e33778b6c7aa667aceedd5805fd37868c6967e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/384623daa7ca04352fc57cb2f31790961ac27e21", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXWuWMAAoJEFbW7qD8Z6xGOXwP/RvKrDlKbylKlVX1YtLsAiDm\nCQsSmvIFHICob2k7Ha/lxdrCaMRC69SZgU51H2rbScn82AnAnm9wceqMyPUT0Sg2\nkTk0pKsDiZ62Es7jwPgN8SN7VDp0HuQTK1PrIg/QbLDraRr6pZqcvfIUz0Tsosx6\nmQNiE8RDKQJXiDM7T/NXVjkwtjD+BakkUpyuvOztGzJN83o6H94+SwaNOyH3AY4U\ndq4Eg3U3LoOIyID9SbPQPoee42jLLZjMsdtfMmTdGxo4O4bPa5ayN33z06723lbn\nAzUsIpY4PRmg8w99dQ2BR4DiD6f94CCfPbOfnbeAY7h2iHfwcPt1+0sVto33gZD6\nocI3HVOmF0e5iBx/XDrsINF0rHGN1TL83A5NoVtOaplSz1jBs/1lCPHx2HM62Cl7\nbpjNqKSKJrv7qIjrY2oIR73AHvY01IZ6T/Z/hp9GWasiaMwORl8VJWP0jwxCZWSk\nXDnCasqhtepAM6+Gmeue4Gk5nSBuj3JwSGx9tqgse4p3xqI9Wwx603QprTDvRbve\nyElsC4oq+s74Ds0XJUXYDyohX9eA+OUM2Rxqjt5U97IAQBXb4DNe4yK7laXvYkE2\nZD2/TQVH7nm1/tr2wuKHc/tYVs367ndnaR9J8bb5nCjaQGPq6VQ3+u6QBsFgXOaU\nH734D1CtRwzdgZdMvQ42\n=wUOp\n-----END PGP SIGNATURE-----", "payload": "tree 7e33778b6c7aa667aceedd5805fd37868c6967e0\nparent 67211218f0e3451cdc3fa979c0989ee47a0db048\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465386214 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465574796 +0200\n\nfunction pointers"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/384623daa7ca04352fc57cb2f31790961ac27e21", "html_url": "https://github.com/rust-lang/rust/commit/384623daa7ca04352fc57cb2f31790961ac27e21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/384623daa7ca04352fc57cb2f31790961ac27e21/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67211218f0e3451cdc3fa979c0989ee47a0db048", "url": "https://api.github.com/repos/rust-lang/rust/commits/67211218f0e3451cdc3fa979c0989ee47a0db048", "html_url": "https://github.com/rust-lang/rust/commit/67211218f0e3451cdc3fa979c0989ee47a0db048"}], "stats": {"total": 272, "additions": 184, "deletions": 88}, "files": [{"sha": "a4ae8cbdda25b46855a75464896db68820dd3c06", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/384623daa7ca04352fc57cb2f31790961ac27e21/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384623daa7ca04352fc57cb2f31790961ac27e21/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=384623daa7ca04352fc57cb2f31790961ac27e21", "patch": "@@ -6,6 +6,7 @@ use memory::Pointer;\n #[derive(Clone, Debug)]\n pub enum EvalError {\n     DanglingPointerDeref,\n+    InvalidFunctionPointer,\n     InvalidBool,\n     InvalidDiscriminant,\n     PointerOutOfBounds {\n@@ -28,6 +29,8 @@ impl Error for EvalError {\n         match *self {\n             EvalError::DanglingPointerDeref =>\n                 \"dangling pointer was dereferenced\",\n+            EvalError::InvalidFunctionPointer =>\n+                \"tried to use a pointer as a function pointer\",\n             EvalError::InvalidBool =>\n                 \"invalid boolean value read\",\n             EvalError::InvalidDiscriminant =>"}, {"sha": "943cf33a97a3a7ce01828a448c3fc52e48848f14", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 111, "deletions": 81, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/384623daa7ca04352fc57cb2f31790961ac27e21/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384623daa7ca04352fc57cb2f31790961ac27e21/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=384623daa7ca04352fc57cb2f31790961ac27e21", "patch": "@@ -6,15 +6,15 @@ use rustc::traits::{self, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::{self, Layout, Size};\n use rustc::ty::subst::{self, Subst, Substs};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n use rustc::util::nodemap::DefIdMap;\n use std::cell::RefCell;\n use std::ops::Deref;\n use std::rc::Rc;\n use std::{iter, mem};\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::{self, DUMMY_SP};\n+use syntax::codemap::{self, DUMMY_SP, Span};\n \n use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer};\n@@ -39,7 +39,7 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n \n     /// The virtual memory system.\n-    memory: Memory,\n+    memory: Memory<'tcx>,\n \n     /// Precomputed statics, constants and promoteds\n     statics: HashMap<ConstantId<'tcx>, Pointer>,\n@@ -421,81 +421,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let func_ty = self.operand_ty(func);\n                 match func_ty.sty {\n+                    ty::TyFnPtr(bare_fn_ty) => {\n+                        let ptr = self.eval_operand(func)?;\n+                        assert_eq!(ptr.offset, 0);\n+                        let fn_ptr = self.memory.read_ptr(ptr)?;\n+                        let (def_id, substs) = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        self.eval_fn_call(def_id, substs, bare_fn_ty, return_ptr, args, terminator.span)?\n+                    },\n                     ty::TyFnDef(def_id, substs, fn_ty) => {\n-                        use syntax::abi::Abi;\n-                        match fn_ty.abi {\n-                            Abi::RustIntrinsic => {\n-                                let name = self.tcx.item_name(def_id).as_str();\n-                                match fn_ty.sig.0.output {\n-                                    ty::FnConverging(ty) => {\n-                                        let size = self.type_size(ty, self.substs());\n-                                        let ret = return_ptr.unwrap();\n-                                        self.call_intrinsic(&name, substs, args, ret, size)?\n-                                    }\n-                                    ty::FnDiverging => unimplemented!(),\n-                                }\n-                            }\n-\n-                            Abi::C => {\n-                                match fn_ty.sig.0.output {\n-                                    ty::FnConverging(ty) => {\n-                                        let size = self.type_size(ty, self.substs());\n-                                        self.call_c_abi(def_id, args, return_ptr.unwrap(), size)?\n-                                    }\n-                                    ty::FnDiverging => unimplemented!(),\n-                                }\n-                            }\n-\n-                            Abi::Rust | Abi::RustCall => {\n-                                // TODO(solson): Adjust the first argument when calling a Fn or\n-                                // FnMut closure via FnOnce::call_once.\n-\n-                                // Only trait methods can have a Self parameter.\n-                                let (resolved_def_id, resolved_substs) = if substs.self_ty().is_some() {\n-                                    self.trait_method(def_id, substs)\n-                                } else {\n-                                    (def_id, substs)\n-                                };\n-\n-                                let mut arg_srcs = Vec::new();\n-                                for arg in args {\n-                                    let src = self.eval_operand(arg)?;\n-                                    let src_ty = self.operand_ty(arg);\n-                                    arg_srcs.push((src, src_ty));\n-                                }\n-\n-                                if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n-                                    arg_srcs.pop();\n-                                    let last_arg = args.last().unwrap();\n-                                    let last = self.eval_operand(last_arg)?;\n-                                    let last_ty = self.operand_ty(last_arg);\n-                                    let last_layout = self.type_layout(last_ty, self.substs());\n-                                    match (&last_ty.sty, last_layout) {\n-                                        (&ty::TyTuple(fields),\n-                                         &Layout::Univariant { ref variant, .. }) => {\n-                                            let offsets = iter::once(0)\n-                                                .chain(variant.offset_after_field.iter()\n-                                                    .map(|s| s.bytes()));\n-                                            for (offset, ty) in offsets.zip(fields) {\n-                                                let src = last.offset(offset as isize);\n-                                                arg_srcs.push((src, ty));\n-                                            }\n-                                        }\n-                                        ty => panic!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n-                                    }\n-                                }\n-\n-                                let mir = self.load_mir(resolved_def_id);\n-                                self.push_stack_frame(def_id, terminator.span, mir, resolved_substs, return_ptr);\n-\n-                                for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n-                                    let dest = self.frame().locals[i];\n-                                    self.move_(src, dest, src_ty)?;\n-                                }\n-                            }\n-\n-                            abi => return Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n-                        }\n+                        self.eval_fn_call(def_id, substs, fn_ty, return_ptr, args, terminator.span)?\n                     }\n \n                     _ => return Err(EvalError::Unimplemented(format!(\"can't handle callee of type {:?}\", func_ty))),\n@@ -515,6 +449,93 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n+    pub fn eval_fn_call(\n+        &mut self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+        fn_ty: &'tcx BareFnTy,\n+        return_ptr: Option<Pointer>,\n+        args: &[mir::Operand<'tcx>],\n+        span: Span,\n+    ) -> EvalResult<()> {\n+        use syntax::abi::Abi;\n+        match fn_ty.abi {\n+            Abi::RustIntrinsic => {\n+                let name = self.tcx.item_name(def_id).as_str();\n+                match fn_ty.sig.0.output {\n+                    ty::FnConverging(ty) => {\n+                        let size = self.type_size(ty, self.substs());\n+                        let ret = return_ptr.unwrap();\n+                        self.call_intrinsic(&name, substs, args, ret, size)\n+                    }\n+                    ty::FnDiverging => unimplemented!(),\n+                }\n+            }\n+\n+            Abi::C => {\n+                match fn_ty.sig.0.output {\n+                    ty::FnConverging(ty) => {\n+                        let size = self.type_size(ty, self.substs());\n+                        self.call_c_abi(def_id, args, return_ptr.unwrap(), size)\n+                    }\n+                    ty::FnDiverging => unimplemented!(),\n+                }\n+            }\n+\n+            Abi::Rust | Abi::RustCall => {\n+                // TODO(solson): Adjust the first argument when calling a Fn or\n+                // FnMut closure via FnOnce::call_once.\n+\n+                // Only trait methods can have a Self parameter.\n+                let (resolved_def_id, resolved_substs) = if substs.self_ty().is_some() {\n+                    self.trait_method(def_id, substs)\n+                } else {\n+                    (def_id, substs)\n+                };\n+\n+                let mut arg_srcs = Vec::new();\n+                for arg in args {\n+                    let src = self.eval_operand(arg)?;\n+                    let src_ty = self.operand_ty(arg);\n+                    arg_srcs.push((src, src_ty));\n+                }\n+\n+                if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n+                    arg_srcs.pop();\n+                    let last_arg = args.last().unwrap();\n+                    let last = self.eval_operand(last_arg)?;\n+                    let last_ty = self.operand_ty(last_arg);\n+                    let last_layout = self.type_layout(last_ty, self.substs());\n+                    match (&last_ty.sty, last_layout) {\n+                        (&ty::TyTuple(fields),\n+                         &Layout::Univariant { ref variant, .. }) => {\n+                            let offsets = iter::once(0)\n+                                .chain(variant.offset_after_field.iter()\n+                                    .map(|s| s.bytes()));\n+                            for (offset, ty) in offsets.zip(fields) {\n+                                let src = last.offset(offset as isize);\n+                                arg_srcs.push((src, ty));\n+                            }\n+                        }\n+                        ty => panic!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n+                    }\n+                }\n+\n+                let mir = self.load_mir(resolved_def_id);\n+                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr);\n+\n+                for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n+                    let dest = self.frame().locals[i];\n+                    self.move_(src, dest, src_ty)?;\n+                }\n+\n+                Ok(())\n+            }\n+\n+            abi => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n+        }\n+    }\n+\n     fn drop(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n         if !self.type_needs_drop(ty) {\n             debug!(\"no need to drop {:?}\", ty);\n@@ -989,12 +1010,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Cast(kind, ref operand, dest_ty) => {\n-                let src = self.eval_operand(operand)?;\n-                let src_ty = self.operand_ty(operand);\n-\n                 use rustc::mir::repr::CastKind::*;\n                 match kind {\n                     Unsize => {\n+                        let src = self.eval_operand(operand)?;\n+                        let src_ty = self.operand_ty(operand);\n                         self.move_(src, dest, src_ty)?;\n                         let src_pointee_ty = pointee_type(src_ty).unwrap();\n                         let dest_pointee_ty = pointee_type(dest_ty).unwrap();\n@@ -1010,11 +1030,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     Misc => {\n+                        let src = self.eval_operand(operand)?;\n                         // FIXME(solson): Wrong for almost everything.\n                         let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n                         self.memory.copy(src, dest, size)?;\n                     }\n \n+                    ReifyFnPointer => match self.operand_ty(operand).sty {\n+                        ty::TyFnDef(def_id, substs, _) => {\n+                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs);\n+                            self.memory.write_ptr(dest, fn_ptr)?;\n+                        },\n+                        ref other => panic!(\"reify fn pointer on {:?}\", other),\n+                    },\n+\n                     _ => return Err(EvalError::Unimplemented(format!(\"can't handle cast: {:?}\", rvalue))),\n                 }\n             }\n@@ -1103,7 +1132,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value { ref value } => Ok(self.const_to_ptr(value)?),\n                     Item { def_id, substs } => {\n                         if let ty::TyFnDef(..) = ty.sty {\n-                            Err(EvalError::Unimplemented(\"unimplemented: mentions of function items\".to_string()))\n+                            // function items are zero sized\n+                            Ok(self.memory.allocate(0))\n                         } else {\n                             let cid = ConstantId {\n                                 def_id: def_id,"}, {"sha": "d9999821e1b033f26a18734bc339961e77860ac9", "filename": "src/memory.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/384623daa7ca04352fc57cb2f31790961ac27e21/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384623daa7ca04352fc57cb2f31790961ac27e21/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=384623daa7ca04352fc57cb2f31790961ac27e21", "patch": "@@ -3,6 +3,9 @@ use std::collections::Bound::{Included, Excluded};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, mem, ptr};\n \n+use rustc::hir::def_id::DefId;\n+use rustc::ty::subst::Substs;\n+\n use error::{EvalError, EvalResult};\n use primval::PrimVal;\n \n@@ -42,22 +45,37 @@ impl Pointer {\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub struct Memory {\n+pub struct Memory<'tcx> {\n     alloc_map: HashMap<AllocId, Allocation>,\n+    functions: HashMap<AllocId, (DefId, &'tcx Substs<'tcx>)>,\n     next_id: AllocId,\n     pub pointer_size: usize,\n }\n \n-impl Memory {\n+impl<'tcx> Memory<'tcx> {\n     // FIXME: pass tcx.data_layout (This would also allow it to use primitive type alignments to diagnose unaligned memory accesses.)\n     pub fn new(pointer_size: usize) -> Self {\n         Memory {\n             alloc_map: HashMap::new(),\n+            functions: HashMap::new(),\n             next_id: AllocId(0),\n             pointer_size: pointer_size,\n         }\n     }\n \n+    // FIXME: never create two pointers to the same def_id + substs combination\n+    // maybe re-use the statics cache of the gecx?\n+    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Pointer {\n+        let id = self.next_id;\n+        debug!(\"creating fn ptr: {}\", id);\n+        self.next_id.0 += 1;\n+        self.functions.insert(id, (def_id, substs));\n+        Pointer {\n+            alloc_id: id,\n+            offset: 0,\n+        }\n+    }\n+\n     pub fn allocate(&mut self, size: usize) -> Pointer {\n         let alloc = Allocation {\n             bytes: vec![0; size],\n@@ -125,6 +143,11 @@ impl Memory {\n         self.alloc_map.get_mut(&id).ok_or(EvalError::DanglingPointerDeref)\n     }\n \n+    pub fn get_fn(&self, id: AllocId) -> EvalResult<(DefId, &'tcx Substs<'tcx>)> {\n+        debug!(\"reading fn ptr: {}\", id);\n+        self.functions.get(&id).map(|&did| did).ok_or(EvalError::InvalidFunctionPointer)\n+    }\n+\n     /// Print an allocation and all allocations it points to, recursively.\n     pub fn dump(&self, id: AllocId) {\n         let mut allocs_seen = HashSet::new();\n@@ -137,12 +160,18 @@ impl Memory {\n             print!(\"{}\", prefix);\n             let mut relocations = vec![];\n \n-            let alloc = match self.alloc_map.get(&id) {\n-                Some(a) => a,\n-                None => {\n+            let alloc = match (self.alloc_map.get(&id), self.functions.get(&id)) {\n+                (Some(a), None) => a,\n+                (None, Some(_)) => {\n+                    // FIXME: print function name\n+                    println!(\"function pointer\");\n+                    continue;\n+                },\n+                (None, None) => {\n                     println!(\"(deallocated)\");\n                     continue;\n-                }\n+                },\n+                (Some(_), Some(_)) => unreachable!(),\n             };\n \n             for i in 0..alloc.bytes.len() {"}, {"sha": "7752650ade8873f3dcf1c103ff5dfe5e18985c94", "filename": "tests/compile-fail/unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/384623daa7ca04352fc57cb2f31790961ac27e21/tests%2Fcompile-fail%2Funimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384623daa7ca04352fc57cb2f31790961ac27e21/tests%2Fcompile-fail%2Funimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funimplemented.rs?ref=384623daa7ca04352fc57cb2f31790961ac27e21", "patch": "@@ -1,7 +1,7 @@\n #![feature(custom_attribute)]\n #![allow(dead_code, unused_attributes)]\n \n-//error-pattern:unimplemented: mentions of function items\n+//error-pattern:begin_panic_fmt\n \n \n #[miri_run]"}, {"sha": "55a6f9fbeac46266a9f24cfefb36fce7d428c324", "filename": "tests/run-pass/function_pointers.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/384623daa7ca04352fc57cb2f31790961ac27e21/tests%2Frun-pass%2Ffunction_pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384623daa7ca04352fc57cb2f31790961ac27e21/tests%2Frun-pass%2Ffunction_pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_pointers.rs?ref=384623daa7ca04352fc57cb2f31790961ac27e21", "patch": "@@ -0,0 +1,17 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+fn f() -> i32 {\n+    42\n+}\n+\n+fn return_fn_ptr() -> fn() -> i32 {\n+    f\n+}\n+\n+#[miri_run]\n+fn call_fn_ptr() -> i32 {\n+    return_fn_ptr()()\n+}\n+\n+fn main() {}"}, {"sha": "d4f1d4023ba7f51e0d70e811ae008ab533747f3c", "filename": "tests/run-pass/zst.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/384623daa7ca04352fc57cb2f31790961ac27e21/tests%2Frun-pass%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/384623daa7ca04352fc57cb2f31790961ac27e21/tests%2Frun-pass%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst.rs?ref=384623daa7ca04352fc57cb2f31790961ac27e21", "patch": "@@ -0,0 +1,17 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+struct A;\n+\n+#[miri_run]\n+fn zst_ret() -> A {\n+    A\n+}\n+\n+#[miri_run]\n+fn use_zst() -> A {\n+    let a = A;\n+    a\n+}\n+\n+fn main() {}"}]}