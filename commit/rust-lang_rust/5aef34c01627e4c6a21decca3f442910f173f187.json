{"sha": "5aef34c01627e4c6a21decca3f442910f173f187", "node_id": "C_kwDOAAsO6NoAKDVhZWYzNGMwMTYyN2U0YzZhMjFkZWNjYTNmNDQyOTEwZjE3M2YxODc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-09T18:00:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-09T18:00:31Z"}, "message": "Auto merge of #2464 - RalfJung:atomic-must-be-mutable, r=RalfJung\n\nAtomics must be mutable\n\nFixes https://github.com/rust-lang/miri/issues/2463\nNeeds https://github.com/rust-lang/rust/pull/100181", "tree": {"sha": "0e4b83fe2a78afe17ffb8484c99f5e6f5d35966f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e4b83fe2a78afe17ffb8484c99f5e6f5d35966f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5aef34c01627e4c6a21decca3f442910f173f187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5aef34c01627e4c6a21decca3f442910f173f187", "html_url": "https://github.com/rust-lang/rust/commit/5aef34c01627e4c6a21decca3f442910f173f187", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5aef34c01627e4c6a21decca3f442910f173f187/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df3c141762b4082ef405bf092b385ca859f1dc8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/df3c141762b4082ef405bf092b385ca859f1dc8b", "html_url": "https://github.com/rust-lang/rust/commit/df3c141762b4082ef405bf092b385ca859f1dc8b"}, {"sha": "a1f5a75c80a325804b96d9a9f2d2f862ad29c736", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1f5a75c80a325804b96d9a9f2d2f862ad29c736", "html_url": "https://github.com/rust-lang/rust/commit/a1f5a75c80a325804b96d9a9f2d2f862ad29c736"}], "stats": {"total": 348, "additions": 204, "deletions": 144}, "files": [{"sha": "eb973aa081561a655c3c9cb04f07b94e8d1f158e", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5aef34c01627e4c6a21decca3f442910f173f187/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/5aef34c01627e4c6a21decca3f442910f173f187/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=5aef34c01627e4c6a21decca3f442910f173f187", "patch": "@@ -1 +1 @@\n-93ab13b4e894ab74258c40aaf29872db2b17b6b4\n+6d3f1beae1720055e5a30f4dbe7a9e7fb810c65e"}, {"sha": "410c2b9c3ddf756cf8ebafc496346d43014ca3d9", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 120, "deletions": 74, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/5aef34c01627e4c6a21decca3f442910f173f187/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aef34c01627e4c6a21decca3f442910f173f187/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=5aef34c01627e4c6a21decca3f442910f173f187", "patch": "@@ -46,10 +46,11 @@ use std::{\n     mem,\n };\n \n+use rustc_ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::{mir, ty::layout::TyAndLayout};\n-use rustc_target::abi::Size;\n+use rustc_target::abi::{Align, Size};\n \n use crate::*;\n \n@@ -470,6 +471,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         atomic: AtomicReadOrd,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n         let this = self.eval_context_ref();\n+        this.atomic_access_check(place)?;\n         // This will read from the last store in the modification order of this location. In case\n         // weak memory emulation is enabled, this may not be the store we will pick to actually read from and return.\n         // This is fine with StackedBorrow and race checks because they don't concern metadata on\n@@ -490,6 +492,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n+        this.atomic_access_check(dest)?;\n+\n         this.validate_overlapping_atomic(dest)?;\n         this.allow_data_races_mut(move |this| this.write_scalar(val, &dest.into()))?;\n         this.validate_atomic_store(dest, atomic)?;\n@@ -511,6 +515,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n+        this.atomic_access_check(place)?;\n \n         this.validate_overlapping_atomic(place)?;\n         let old = this.allow_data_races_mut(|this| this.read_immediate(&place.into()))?;\n@@ -540,6 +545,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n         let this = self.eval_context_mut();\n+        this.atomic_access_check(place)?;\n \n         this.validate_overlapping_atomic(place)?;\n         let old = this.allow_data_races_mut(|this| this.read_scalar(&place.into()))?;\n@@ -561,6 +567,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n+        this.atomic_access_check(place)?;\n \n         this.validate_overlapping_atomic(place)?;\n         let old = this.allow_data_races_mut(|this| this.read_immediate(&place.into()))?;\n@@ -604,6 +611,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, Immediate<Provenance>> {\n         use rand::Rng as _;\n         let this = self.eval_context_mut();\n+        this.atomic_access_check(place)?;\n \n         this.validate_overlapping_atomic(place)?;\n         // Failure ordering cannot be stronger than success ordering, therefore first attempt\n@@ -647,80 +655,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         Ok(res)\n     }\n \n-    /// Update the data-race detector for an atomic read occurring at the\n-    /// associated memory-place and on the current thread.\n-    fn validate_atomic_load(\n-        &self,\n-        place: &MPlaceTy<'tcx, Provenance>,\n-        atomic: AtomicReadOrd,\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_ref();\n-        this.validate_overlapping_atomic(place)?;\n-        this.validate_atomic_op(\n-            place,\n-            atomic,\n-            \"Atomic Load\",\n-            move |memory, clocks, index, atomic| {\n-                if atomic == AtomicReadOrd::Relaxed {\n-                    memory.load_relaxed(&mut *clocks, index)\n-                } else {\n-                    memory.load_acquire(&mut *clocks, index)\n-                }\n-            },\n-        )\n-    }\n-\n-    /// Update the data-race detector for an atomic write occurring at the\n-    /// associated memory-place and on the current thread.\n-    fn validate_atomic_store(\n-        &mut self,\n-        place: &MPlaceTy<'tcx, Provenance>,\n-        atomic: AtomicWriteOrd,\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        this.validate_overlapping_atomic(place)?;\n-        this.validate_atomic_op(\n-            place,\n-            atomic,\n-            \"Atomic Store\",\n-            move |memory, clocks, index, atomic| {\n-                if atomic == AtomicWriteOrd::Relaxed {\n-                    memory.store_relaxed(clocks, index)\n-                } else {\n-                    memory.store_release(clocks, index)\n-                }\n-            },\n-        )\n-    }\n-\n-    /// Update the data-race detector for an atomic read-modify-write occurring\n-    /// at the associated memory place and on the current thread.\n-    fn validate_atomic_rmw(\n-        &mut self,\n-        place: &MPlaceTy<'tcx, Provenance>,\n-        atomic: AtomicRwOrd,\n-    ) -> InterpResult<'tcx> {\n-        use AtomicRwOrd::*;\n-        let acquire = matches!(atomic, Acquire | AcqRel | SeqCst);\n-        let release = matches!(atomic, Release | AcqRel | SeqCst);\n-        let this = self.eval_context_mut();\n-        this.validate_overlapping_atomic(place)?;\n-        this.validate_atomic_op(place, atomic, \"Atomic RMW\", move |memory, clocks, index, _| {\n-            if acquire {\n-                memory.load_acquire(clocks, index)?;\n-            } else {\n-                memory.load_relaxed(clocks, index)?;\n-            }\n-            if release {\n-                memory.rmw_release(clocks, index)\n-            } else {\n-                memory.rmw_relaxed(clocks, index)\n-            }\n-        })\n-    }\n-\n     /// Update the data-race detector for an atomic fence on the current thread.\n-    fn validate_atomic_fence(&mut self, atomic: AtomicFenceOrd) -> InterpResult<'tcx> {\n+    fn atomic_fence(&mut self, atomic: AtomicFenceOrd) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if let Some(data_race) = &mut this.machine.data_race {\n             data_race.maybe_perform_sync_operation(&this.machine.threads, |index, mut clocks| {\n@@ -1016,6 +952,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriEvalContext<'mir, 'tcx>) -> R) -> R {\n         let this = self.eval_context_ref();\n         if let Some(data_race) = &this.machine.data_race {\n+            assert!(!data_race.ongoing_action_data_race_free.get(), \"cannot nest allow_data_races\");\n             data_race.ongoing_action_data_race_free.set(true);\n         }\n         let result = op(this);\n@@ -1035,6 +972,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     ) -> R {\n         let this = self.eval_context_mut();\n         if let Some(data_race) = &this.machine.data_race {\n+            assert!(!data_race.ongoing_action_data_race_free.get(), \"cannot nest allow_data_races\");\n             data_race.ongoing_action_data_race_free.set(true);\n         }\n         let result = op(this);\n@@ -1044,6 +982,114 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n         result\n     }\n \n+    /// Checks that an atomic access is legal at the given place.\n+    fn atomic_access_check(&self, place: &MPlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_ref();\n+        // Check alignment requirements. Atomics must always be aligned to their size,\n+        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+        // be 8-aligned).\n+        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+        this.check_ptr_access_align(\n+            place.ptr,\n+            place.layout.size,\n+            align,\n+            CheckInAllocMsg::MemoryAccessTest,\n+        )?;\n+        // Ensure the allocation is mutable. Even failing (read-only) compare_exchange need mutable\n+        // memory on many targets (i.e., they segfault if taht memory is mapped read-only), and\n+        // atomic loads can be implemented via compare_exchange on some targets. There could\n+        // possibly be some very specific exceptions to this, see\n+        // <https://github.com/rust-lang/miri/pull/2464#discussion_r939636130> for details.\n+        // We avoid `get_ptr_alloc` since we do *not* want to run the access hooks -- the actual\n+        // access will happen later.\n+        let (alloc_id, _offset, _prov) =\n+            this.ptr_try_get_alloc_id(place.ptr).expect(\"there are no zero-sized atomic accesses\");\n+        if this.get_alloc_mutability(alloc_id)? == Mutability::Not {\n+            // FIXME: make this prettier, once these messages have separate title/span/help messages.\n+            throw_ub_format!(\n+                \"atomic operations cannot be performed on read-only memory\\n\\\n+                many platforms require atomic read-modify-write instructions to be performed on writeable memory, even if the operation fails \\\n+                (and is hence nominally read-only)\\n\\\n+                some platforms implement (some) atomic loads via compare-exchange, which means they do not work on read-only memory; \\\n+                it is possible that we could have an exception permitting this for specific kinds of loads\\n\\\n+                please report an issue at <https://github.com/rust-lang/miri/issues> if this is a problem for you\"\n+            );\n+        }\n+        Ok(())\n+    }\n+\n+    /// Update the data-race detector for an atomic read occurring at the\n+    /// associated memory-place and on the current thread.\n+    fn validate_atomic_load(\n+        &self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        atomic: AtomicReadOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_ref();\n+        this.validate_overlapping_atomic(place)?;\n+        this.validate_atomic_op(\n+            place,\n+            atomic,\n+            \"Atomic Load\",\n+            move |memory, clocks, index, atomic| {\n+                if atomic == AtomicReadOrd::Relaxed {\n+                    memory.load_relaxed(&mut *clocks, index)\n+                } else {\n+                    memory.load_acquire(&mut *clocks, index)\n+                }\n+            },\n+        )\n+    }\n+\n+    /// Update the data-race detector for an atomic write occurring at the\n+    /// associated memory-place and on the current thread.\n+    fn validate_atomic_store(\n+        &mut self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        atomic: AtomicWriteOrd,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.validate_overlapping_atomic(place)?;\n+        this.validate_atomic_op(\n+            place,\n+            atomic,\n+            \"Atomic Store\",\n+            move |memory, clocks, index, atomic| {\n+                if atomic == AtomicWriteOrd::Relaxed {\n+                    memory.store_relaxed(clocks, index)\n+                } else {\n+                    memory.store_release(clocks, index)\n+                }\n+            },\n+        )\n+    }\n+\n+    /// Update the data-race detector for an atomic read-modify-write occurring\n+    /// at the associated memory place and on the current thread.\n+    fn validate_atomic_rmw(\n+        &mut self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        atomic: AtomicRwOrd,\n+    ) -> InterpResult<'tcx> {\n+        use AtomicRwOrd::*;\n+        let acquire = matches!(atomic, Acquire | AcqRel | SeqCst);\n+        let release = matches!(atomic, Release | AcqRel | SeqCst);\n+        let this = self.eval_context_mut();\n+        this.validate_overlapping_atomic(place)?;\n+        this.validate_atomic_op(place, atomic, \"Atomic RMW\", move |memory, clocks, index, _| {\n+            if acquire {\n+                memory.load_acquire(clocks, index)?;\n+            } else {\n+                memory.load_relaxed(clocks, index)?;\n+            }\n+            if release {\n+                memory.rmw_release(clocks, index)\n+            } else {\n+                memory.rmw_relaxed(clocks, index)\n+            }\n+        })\n+    }\n+\n     /// Generic atomic operation implementation\n     fn validate_atomic_op<A: Debug + Copy>(\n         &self,"}, {"sha": "86f132f73fc80d4ed1634e4fba3bf46d46ad436a", "filename": "src/shims/intrinsics/atomic.rs", "status": "modified", "additions": 12, "deletions": 64, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5aef34c01627e4c6a21decca3f442910f173f187/src%2Fshims%2Fintrinsics%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aef34c01627e4c6a21decca3f442910f173f187/src%2Fshims%2Fintrinsics%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fatomic.rs?ref=5aef34c01627e4c6a21decca3f442910f173f187", "patch": "@@ -1,5 +1,4 @@\n use rustc_middle::{mir, mir::BinOp, ty};\n-use rustc_target::abi::Align;\n \n use crate::*;\n use helpers::check_arg_count;\n@@ -68,8 +67,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             [\"load\", ord] => this.atomic_load(args, dest, read_ord(ord)?)?,\n             [\"store\", ord] => this.atomic_store(args, write_ord(ord)?)?,\n \n-            [\"fence\", ord] => this.atomic_fence(args, fence_ord(ord)?)?,\n-            [\"singlethreadfence\", ord] => this.compiler_fence(args, fence_ord(ord)?)?,\n+            [\"fence\", ord] => this.atomic_fence_intrinsic(args, fence_ord(ord)?)?,\n+            [\"singlethreadfence\", ord] => this.compiler_fence_intrinsic(args, fence_ord(ord)?)?,\n \n             [\"xchg\", ord] => this.atomic_exchange(args, dest, rw_ord(ord)?)?,\n             [\"cxchg\", ord1, ord2] =>\n@@ -118,7 +117,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         Ok(())\n     }\n+}\n \n+impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n+trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     fn atomic_load(\n         &mut self,\n         args: &[OpTy<'tcx, Provenance>],\n@@ -130,20 +132,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let [place] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n \n-        // make sure it fits into a scalar; otherwise it cannot be atomic\n+        // Perform atomic load.\n         let val = this.read_scalar_atomic(&place, atomic)?;\n-\n-        // Check alignment requirements. Atomics must always be aligned to their size,\n-        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n-        // be 8-aligned).\n-        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.check_ptr_access_align(\n-            place.ptr,\n-            place.layout.size,\n-            align,\n-            CheckInAllocMsg::MemoryAccessTest,\n-        )?;\n-        // Perform regular access.\n+        // Perform regular store.\n         this.write_scalar(val, dest)?;\n         Ok(())\n     }\n@@ -157,25 +148,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let [place, val] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n-        let val = this.read_scalar(val)?; // make sure it fits into a scalar; otherwise it cannot be atomic\n-\n-        // Check alignment requirements. Atomics must always be aligned to their size,\n-        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n-        // be 8-aligned).\n-        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.check_ptr_access_align(\n-            place.ptr,\n-            place.layout.size,\n-            align,\n-            CheckInAllocMsg::MemoryAccessTest,\n-        )?;\n \n+        // Perform regular load.\n+        let val = this.read_scalar(val)?;\n         // Perform atomic store\n         this.write_scalar_atomic(val, &place, atomic)?;\n         Ok(())\n     }\n \n-    fn compiler_fence(\n+    fn compiler_fence_intrinsic(\n         &mut self,\n         args: &[OpTy<'tcx, Provenance>],\n         atomic: AtomicFenceOrd,\n@@ -186,14 +167,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n \n-    fn atomic_fence(\n+    fn atomic_fence_intrinsic(\n         &mut self,\n         args: &[OpTy<'tcx, Provenance>],\n         atomic: AtomicFenceOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let [] = check_arg_count(args)?;\n-        this.validate_atomic_fence(atomic)?;\n+        this.atomic_fence(atomic)?;\n         Ok(())\n     }\n \n@@ -220,17 +201,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             span_bug!(this.cur_span(), \"atomic arithmetic operation type mismatch\");\n         }\n \n-        // Check alignment requirements. Atomics must always be aligned to their size,\n-        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n-        // be 8-aligned).\n-        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.check_ptr_access_align(\n-            place.ptr,\n-            place.layout.size,\n-            align,\n-            CheckInAllocMsg::MemoryAccessTest,\n-        )?;\n-\n         match atomic_op {\n             AtomicOp::Min => {\n                 let old = this.atomic_min_max_scalar(&place, rhs, true, atomic)?;\n@@ -262,17 +232,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let place = this.deref_operand(place)?;\n         let new = this.read_scalar(new)?;\n \n-        // Check alignment requirements. Atomics must always be aligned to their size,\n-        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n-        // be 8-aligned).\n-        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.check_ptr_access_align(\n-            place.ptr,\n-            place.layout.size,\n-            align,\n-            CheckInAllocMsg::MemoryAccessTest,\n-        )?;\n-\n         let old = this.atomic_exchange_scalar(&place, new, atomic)?;\n         this.write_scalar(old, dest)?; // old value is returned\n         Ok(())\n@@ -293,17 +252,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let expect_old = this.read_immediate(expect_old)?; // read as immediate for the sake of `binary_op()`\n         let new = this.read_scalar(new)?;\n \n-        // Check alignment requirements. Atomics must always be aligned to their size,\n-        // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n-        // be 8-aligned).\n-        let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n-        this.check_ptr_access_align(\n-            place.ptr,\n-            place.layout.size,\n-            align,\n-            CheckInAllocMsg::MemoryAccessTest,\n-        )?;\n-\n         let old = this.atomic_compare_exchange_scalar(\n             &place,\n             &expect_old,"}, {"sha": "b33553f4663b901604e0730bd9d8a5f6a1ff9245", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5aef34c01627e4c6a21decca3f442910f173f187/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aef34c01627e4c6a21decca3f442910f173f187/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=5aef34c01627e4c6a21decca3f442910f173f187", "patch": "@@ -169,7 +169,7 @@ pub fn futex<'tcx>(\n             //\n             // Thankfully, preemptions cannot happen inside a Miri shim, so we do not need to\n             // do anything special to guarantee fence-load-comparison atomicity.\n-            this.validate_atomic_fence(AtomicFenceOrd::SeqCst)?;\n+            this.atomic_fence(AtomicFenceOrd::SeqCst)?;\n             // Read an `i32` through the pointer, regardless of any wrapper types.\n             // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`.\n             let futex_val = this\n@@ -240,7 +240,7 @@ pub fn futex<'tcx>(\n             // Together with the SeqCst fence in futex_wait, this makes sure that futex_wait\n             // will see the latest value on addr which could be changed by our caller\n             // before doing the syscall.\n-            this.validate_atomic_fence(AtomicFenceOrd::SeqCst)?;\n+            this.atomic_fence(AtomicFenceOrd::SeqCst)?;\n             let mut n = 0;\n             for _ in 0..val {\n                 if let Some(thread) = this.futex_wake(addr_usize, bitset) {"}, {"sha": "cb6aeea665d3905b3c1d75e12a24f3d8ff94eddd", "filename": "tests/fail/concurrency/read_only_atomic_cmpxchg.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5aef34c01627e4c6a21decca3f442910f173f187/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aef34c01627e4c6a21decca3f442910f173f187/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.rs?ref=5aef34c01627e4c6a21decca3f442910f173f187", "patch": "@@ -0,0 +1,11 @@\n+// Should not rely on the aliasing model for its failure.\n+//@compile-flags: -Zmiri-disable-stacked-borrows\n+\n+use std::sync::atomic::{AtomicI32, Ordering};\n+\n+fn main() {\n+    static X: i32 = 0;\n+    let x = &X as *const i32 as *const AtomicI32;\n+    let x = unsafe { &*x };\n+    x.compare_exchange(1, 2, Ordering::Relaxed, Ordering::Relaxed).unwrap_err(); //~ERROR: atomic operations cannot be performed on read-only memory\n+}"}, {"sha": "b90dc5c9d6cd51dab7971198363479c71bd79dc9", "filename": "tests/fail/concurrency/read_only_atomic_cmpxchg.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5aef34c01627e4c6a21decca3f442910f173f187/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5aef34c01627e4c6a21decca3f442910f173f187/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_cmpxchg.stderr?ref=5aef34c01627e4c6a21decca3f442910f173f187", "patch": "@@ -0,0 +1,21 @@\n+error: Undefined Behavior: atomic operations cannot be performed on read-only memory\n+       many platforms require atomic read-modify-write instructions to be performed on writeable memory, even if the operation fails (and is hence nominally read-only)\n+       some platforms implement (some) atomic loads via compare-exchange, which means they do not work on read-only memory; it is possible that we could have an exception permitting this for specific kinds of loads\n+       please report an issue at <https://github.com/rust-lang/miri/issues> if this is a problem for you\n+  --> $DIR/read_only_atomic_cmpxchg.rs:LL:CC\n+   |\n+LL |     x.compare_exchange(1, 2, Ordering::Relaxed, Ordering::Relaxed).unwrap_err();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ atomic operations cannot be performed on read-only memory\n+many platforms require atomic read-modify-write instructions to be performed on writeable memory, even if the operation fails (and is hence nominally read-only)\n+some platforms implement (some) atomic loads via compare-exchange, which means they do not work on read-only memory; it is possible that we could have an exception permitting this for specific kinds of loads\n+please report an issue at <https://github.com/rust-lang/miri/issues> if this is a problem for you\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: backtrace:\n+   = note: inside `main` at $DIR/read_only_atomic_cmpxchg.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "6e92453e3c195e969713158c2bd5718eaefd288c", "filename": "tests/fail/concurrency/read_only_atomic_load.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5aef34c01627e4c6a21decca3f442910f173f187/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aef34c01627e4c6a21decca3f442910f173f187/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.rs?ref=5aef34c01627e4c6a21decca3f442910f173f187", "patch": "@@ -0,0 +1,13 @@\n+// Should not rely on the aliasing model for its failure.\n+//@compile-flags: -Zmiri-disable-stacked-borrows\n+\n+use std::sync::atomic::{AtomicI32, Ordering};\n+\n+fn main() {\n+    static X: i32 = 0;\n+    let x = &X as *const i32 as *const AtomicI32;\n+    let x = unsafe { &*x };\n+    // Some targets can implement atomic loads via compare_exchange, so we cannot allow them on\n+    // read-only memory.\n+    x.load(Ordering::Relaxed); //~ERROR: atomic operations cannot be performed on read-only memory\n+}"}, {"sha": "b19d3755fbb04fb6b8dea810ebb7640b15ded94e", "filename": "tests/fail/concurrency/read_only_atomic_load.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5aef34c01627e4c6a21decca3f442910f173f187/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5aef34c01627e4c6a21decca3f442910f173f187/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fconcurrency%2Fread_only_atomic_load.stderr?ref=5aef34c01627e4c6a21decca3f442910f173f187", "patch": "@@ -0,0 +1,21 @@\n+error: Undefined Behavior: atomic operations cannot be performed on read-only memory\n+       many platforms require atomic read-modify-write instructions to be performed on writeable memory, even if the operation fails (and is hence nominally read-only)\n+       some platforms implement (some) atomic loads via compare-exchange, which means they do not work on read-only memory; it is possible that we could have an exception permitting this for specific kinds of loads\n+       please report an issue at <https://github.com/rust-lang/miri/issues> if this is a problem for you\n+  --> $DIR/read_only_atomic_load.rs:LL:CC\n+   |\n+LL |     x.load(Ordering::Relaxed);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ atomic operations cannot be performed on read-only memory\n+many platforms require atomic read-modify-write instructions to be performed on writeable memory, even if the operation fails (and is hence nominally read-only)\n+some platforms implement (some) atomic loads via compare-exchange, which means they do not work on read-only memory; it is possible that we could have an exception permitting this for specific kinds of loads\n+please report an issue at <https://github.com/rust-lang/miri/issues> if this is a problem for you\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: backtrace:\n+   = note: inside `main` at $DIR/read_only_atomic_load.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "2c99bfa1000cd0dd75e9d721728ac13d2c3d0100", "filename": "tests/pass/concurrency/linux-futex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5aef34c01627e4c6a21decca3f442910f173f187/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aef34c01627e4c6a21decca3f442910f173f187/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs?ref=5aef34c01627e4c6a21decca3f442910f173f187", "patch": "@@ -130,7 +130,7 @@ fn wait_absolute_timeout() {\n fn wait_wake() {\n     let start = Instant::now();\n \n-    static FUTEX: i32 = 0;\n+    static mut FUTEX: i32 = 0;\n \n     let t = thread::spawn(move || {\n         thread::sleep(Duration::from_millis(200));\n@@ -167,7 +167,7 @@ fn wait_wake() {\n fn wait_wake_bitset() {\n     let start = Instant::now();\n \n-    static FUTEX: i32 = 0;\n+    static mut FUTEX: i32 = 0;\n \n     let t = thread::spawn(move || {\n         thread::sleep(Duration::from_millis(200));\n@@ -277,8 +277,8 @@ fn concurrent_wait_wake() {\n \n     // Make sure we got the interesting case (of having woken a thread) at least once, but not *each* time.\n     let woken = WOKEN.load(Ordering::Relaxed);\n-    assert!(woken > 0 && woken < rounds);\n     //eprintln!(\"waking happened {woken} times\");\n+    assert!(woken > 0 && woken < rounds);\n }\n \n fn main() {"}]}