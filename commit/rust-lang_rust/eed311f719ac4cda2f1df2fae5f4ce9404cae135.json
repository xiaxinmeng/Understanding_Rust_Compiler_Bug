{"sha": "eed311f719ac4cda2f1df2fae5f4ce9404cae135", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZDMxMWY3MTlhYzRjZGEyZjFkZjJmYWU1ZjRjZTk0MDRjYWUxMzU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-14T16:43:07Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-23T13:47:19Z"}, "message": "add check_borrow_conflicts_in_at_patterns analysis", "tree": {"sha": "3955526dac9168de643ab8971bc155515a183ab6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3955526dac9168de643ab8971bc155515a183ab6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eed311f719ac4cda2f1df2fae5f4ce9404cae135", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eed311f719ac4cda2f1df2fae5f4ce9404cae135", "html_url": "https://github.com/rust-lang/rust/commit/eed311f719ac4cda2f1df2fae5f4ce9404cae135", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eed311f719ac4cda2f1df2fae5f4ce9404cae135/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a87f99620f0883f9cf5924885c6175e578da6d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a87f99620f0883f9cf5924885c6175e578da6d6", "html_url": "https://github.com/rust-lang/rust/commit/6a87f99620f0883f9cf5924885c6175e578da6d6"}], "stats": {"total": 134, "additions": 104, "deletions": 30}, "files": [{"sha": "3f7a17183e7227a506ccac89d29356bd216a972e", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 104, "deletions": 30, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/eed311f719ac4cda2f1df2fae5f4ce9404cae135/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eed311f719ac4cda2f1df2fae5f4ce9404cae135/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=eed311f719ac4cda2f1df2fae5f4ce9404cae135", "patch": "@@ -15,6 +15,7 @@ use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_error_codes::*;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n+use syntax::ast::Mutability;\n use syntax::feature_gate::feature_err;\n use syntax_pos::symbol::sym;\n use syntax_pos::{MultiSpan, Span};\n@@ -122,6 +123,7 @@ impl PatCtxt<'_, '_> {\n impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_patterns(&mut self, has_guard: bool, pat: &Pat) {\n         check_legality_of_move_bindings(self, has_guard, pat);\n+        check_borrow_conflicts_in_at_patterns(self, pat);\n         if !self.tcx.features().bindings_after_at {\n             check_legality_of_bindings_in_at_patterns(self, pat);\n         }\n@@ -639,44 +641,116 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n     }\n }\n \n-/// Forbids bindings in `@` patterns. This is necessary for memory safety,\n-/// because of the way rvalues are handled in the borrow check. (See issue\n-/// #14587.)\n-fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n-    AtBindingPatternVisitor { cx, bindings_allowed: true }.visit_pat(pat);\n-}\n+fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n+    // Get the mutability of `p` if it's by-ref.\n+    let extract_binding_mut = |hir_id, span| match cx.tables.pat_binding_modes().get(hir_id) {\n+        None => {\n+            cx.tcx.sess.delay_span_bug(span, \"missing binding mode\");\n+            None\n+        }\n+        Some(ty::BindByValue(..)) => None,\n+        Some(ty::BindByReference(m)) => Some(*m),\n+    };\n+    pat.walk(|pat| {\n+        // Extract `sub` in `binding @ sub`.\n+        let (name, sub) = match &pat.kind {\n+            hir::PatKind::Binding(.., name, Some(sub)) => (*name, sub),\n+            _ => return true,\n+        };\n+\n+        // Extract the mutability.\n+        let mut_outer = match extract_binding_mut(pat.hir_id, pat.span) {\n+            None => return true,\n+            Some(m) => m,\n+        };\n+\n+        // We now have `ref $mut_outer binding @ sub` (semantically).\n+        // Recurse into each binding in `sub` and find mutability conflicts.\n+        let mut conflicts_mut_mut = Vec::new();\n+        let mut conflicts_mut_ref = Vec::new();\n+        sub.each_binding(|_, hir_id, span, _| {\n+            if let Some(mut_inner) = extract_binding_mut(hir_id, span) {\n+                match (mut_outer, mut_inner) {\n+                    (Mutability::Immutable, Mutability::Immutable) => {}\n+                    (Mutability::Mutable, Mutability::Mutable) => conflicts_mut_mut.push(span),\n+                    _ => conflicts_mut_ref.push(span),\n+                }\n+            }\n+        });\n+\n+        // Report errors if any.\n+        let binding_span = pat.span.with_hi(name.span.hi());\n+        if !conflicts_mut_mut.is_empty() {\n+            // Report mutability conflicts for e.g. `ref mut x @ Some(ref mut y)`.\n+            let msg = &format!(\"cannot borrow `{}` as mutable more than once at a time\", name);\n+            let mut err = cx.tcx.sess.struct_span_err(pat.span, msg);\n+            err.span_label(binding_span, \"first mutable borrow occurs here\");\n+            for sp in conflicts_mut_mut {\n+                err.span_label(sp, \"another mutable borrow occurs here\");\n+            }\n+            for sp in conflicts_mut_ref {\n+                err.span_label(sp, \"also borrowed as immutable here\");\n+            }\n+            err.emit();\n+        } else if !conflicts_mut_ref.is_empty() {\n+            // Report mutability conflicts for e.g. `ref x @ Some(ref mut y)` or the converse.\n+            let (primary, also) = match mut_outer {\n+                Mutability::Mutable => (\"mutable\", \"immutable\"),\n+                Mutability::Immutable => (\"immutable\", \"mutable\"),\n+            };\n+            let msg = &format!(\n+                \"cannot borrow `{}` as {} because it is also borrowed as {}\",\n+                name, primary, also,\n+            );\n+            let mut err = cx.tcx.sess.struct_span_err(pat.span, msg);\n+            err.span_label(binding_span, &format!(\"{} borrow occurs here\", primary));\n+            for sp in conflicts_mut_ref {\n+                err.span_label(sp, &format!(\"{} borrow occurs here\", also));\n+            }\n+            err.emit();\n+        }\n \n-struct AtBindingPatternVisitor<'a, 'b, 'tcx> {\n-    cx: &'a MatchVisitor<'b, 'tcx>,\n-    bindings_allowed: bool,\n+        true\n+    });\n }\n \n-impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n-        NestedVisitorMap::None\n+/// Forbids bindings in `@` patterns. This used to be is necessary for memory safety,\n+/// because of the way rvalues were handled in the borrow check. (See issue #14587.)\n+fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat) {\n+    AtBindingPatternVisitor { cx, bindings_allowed: true }.visit_pat(pat);\n+\n+    struct AtBindingPatternVisitor<'a, 'b, 'tcx> {\n+        cx: &'a MatchVisitor<'b, 'tcx>,\n+        bindings_allowed: bool,\n     }\n \n-    fn visit_pat(&mut self, pat: &Pat) {\n-        match pat.kind {\n-            hir::PatKind::Binding(.., ref subpat) => {\n-                if !self.bindings_allowed {\n-                    feature_err(\n-                        &self.cx.tcx.sess.parse_sess,\n-                        sym::bindings_after_at,\n-                        pat.span,\n-                        \"pattern bindings after an `@` are unstable\",\n-                    )\n-                    .emit();\n-                }\n+    impl<'v> Visitor<'v> for AtBindingPatternVisitor<'_, '_, '_> {\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+            NestedVisitorMap::None\n+        }\n \n-                if subpat.is_some() {\n-                    let bindings_were_allowed = self.bindings_allowed;\n-                    self.bindings_allowed = false;\n-                    intravisit::walk_pat(self, pat);\n-                    self.bindings_allowed = bindings_were_allowed;\n+        fn visit_pat(&mut self, pat: &Pat) {\n+            match pat.kind {\n+                hir::PatKind::Binding(.., ref subpat) => {\n+                    if !self.bindings_allowed {\n+                        feature_err(\n+                            &self.cx.tcx.sess.parse_sess,\n+                            sym::bindings_after_at,\n+                            pat.span,\n+                            \"pattern bindings after an `@` are unstable\",\n+                        )\n+                        .emit();\n+                    }\n+\n+                    if subpat.is_some() {\n+                        let bindings_were_allowed = self.bindings_allowed;\n+                        self.bindings_allowed = false;\n+                        intravisit::walk_pat(self, pat);\n+                        self.bindings_allowed = bindings_were_allowed;\n+                    }\n                 }\n+                _ => intravisit::walk_pat(self, pat),\n             }\n-            _ => intravisit::walk_pat(self, pat),\n         }\n     }\n }"}]}