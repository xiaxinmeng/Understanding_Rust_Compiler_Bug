{"sha": "9f22708ceda552784a42253523335533423f2b95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmMjI3MDhjZWRhNTUyNzg0YTQyMjUzNTIzMzM1NTMzNDIzZjJiOTU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-12T02:22:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-12T02:22:50Z"}, "message": "Rollup merge of #61654 - Electron-libre:use_slice_patterns_in_rustc, r=oli-obk,Centril\n\nuse pattern matching for slices destructuring\n\nrefs #61542\n\nUse slices pattern where it seems to make sense .", "tree": {"sha": "06da68ad78df47d86d27bbbd21dc45383fb57971", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06da68ad78df47d86d27bbbd21dc45383fb57971"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f22708ceda552784a42253523335533423f2b95", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdAGH6CRBK7hj4Ov3rIwAAdHIIAERiKqd/4zx7PNfkZsfvZhUe\nq5JLQ/m/W9myD731hxHhsEybWO/nmcfcvlSMxobqbjN1TlXUbAO3FRNY/H7834nx\no3ca817sCLamKizQGJSTy68jh+SdXJ10xD8DvDBzQn3hYgD0W30Ww5FCU0Jwin/F\n8z3kZ4xo5AMTMIR3VUHktZa7YPvRXmKHYNSnwRzpjzaauikLeqBbZ9eh6+EKOVRY\ncssM/4T1vlfDXHJxhcT+PkNt/VpPl0OaXAd+p587pCiGqh+KFolZls5F9OAl6tJu\nwh+QPUIO+JPn+OSBP3ZHB7VwtXBbTLSlwmpQbFtQsyRX8lRWIjz4uOqK24fGDCY=\n=Mm5a\n-----END PGP SIGNATURE-----\n", "payload": "tree 06da68ad78df47d86d27bbbd21dc45383fb57971\nparent 6933034a40aadc0e04a594789e7ad4b2034e9b17\nparent 0a4504d400805b2d102a433af98cc33f185fdcf2\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1560306170 +0200\ncommitter GitHub <noreply@github.com> 1560306170 +0200\n\nRollup merge of #61654 - Electron-libre:use_slice_patterns_in_rustc, r=oli-obk,Centril\n\nuse pattern matching for slices destructuring\n\nrefs #61542\n\nUse slices pattern where it seems to make sense .\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f22708ceda552784a42253523335533423f2b95", "html_url": "https://github.com/rust-lang/rust/commit/9f22708ceda552784a42253523335533423f2b95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f22708ceda552784a42253523335533423f2b95/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6933034a40aadc0e04a594789e7ad4b2034e9b17", "url": "https://api.github.com/repos/rust-lang/rust/commits/6933034a40aadc0e04a594789e7ad4b2034e9b17", "html_url": "https://github.com/rust-lang/rust/commit/6933034a40aadc0e04a594789e7ad4b2034e9b17"}, {"sha": "0a4504d400805b2d102a433af98cc33f185fdcf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a4504d400805b2d102a433af98cc33f185fdcf2", "html_url": "https://github.com/rust-lang/rust/commit/0a4504d400805b2d102a433af98cc33f185fdcf2"}], "stats": {"total": 123, "additions": 56, "deletions": 67}, "files": [{"sha": "98351048c35266c85707d10d7b17dc49fbc3862c", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=9f22708ceda552784a42253523335533423f2b95", "patch": "@@ -33,8 +33,10 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                    span: Span,\n                                    token_tree: &[TokenTree])\n                                    -> Box<dyn MacResult+'cx> {\n-    let code = match (token_tree.len(), token_tree.get(0)) {\n-        (1, Some(&TokenTree::Token(Token { kind: token::Ident(code, _), .. }))) => code,\n+    let code = match token_tree {\n+        [\n+            TokenTree::Token(Token { kind: token::Ident(code, _), .. })\n+        ] => code,\n         _ => unreachable!()\n     };\n \n@@ -66,22 +68,19 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                        span: Span,\n                                        token_tree: &[TokenTree])\n                                        -> Box<dyn MacResult+'cx> {\n-    let (code, description) = match (\n-        token_tree.len(),\n-        token_tree.get(0),\n-        token_tree.get(1),\n-        token_tree.get(2)\n-    ) {\n-        (1, Some(&TokenTree::Token(Token { kind: token::Ident(code, _), .. })), None, None) => {\n-            (code, None)\n+    let (code, description) = match  token_tree {\n+        [\n+            TokenTree::Token(Token { kind: token::Ident(code, _), .. })\n+        ] => {\n+            (*code, None)\n+        },\n+        [\n+            TokenTree::Token(Token { kind: token::Ident(code, _), .. }),\n+            TokenTree::Token(Token { kind: token::Comma, .. }),\n+            TokenTree::Token(Token { kind: token::Literal(token::Lit { symbol, .. }), ..})\n+        ] => {\n+            (*code, Some(*symbol))\n         },\n-        (3, Some(&TokenTree::Token(Token { kind: token::Ident(code, _), .. })),\n-            Some(&TokenTree::Token(Token { kind: token::Comma, .. })),\n-            Some(&TokenTree::Token(Token {\n-                kind: token::Literal(token::Lit { symbol, .. }), ..\n-            }))) => {\n-            (code, Some(symbol))\n-        }\n         _ => unreachable!()\n     };\n "}, {"sha": "dd96c63ab0ed66a1f895319259d22982559d9623", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9f22708ceda552784a42253523335533423f2b95", "patch": "@@ -424,48 +424,38 @@ mod tests {\n                 string_to_stream(\"macro_rules! zip (($a)=>($a))\".to_string()).trees().collect();\n             let tts: &[TokenTree] = &tts[..];\n \n-            match (tts.len(), tts.get(0), tts.get(1), tts.get(2), tts.get(3)) {\n-                (\n-                    4,\n-                    Some(&TokenTree::Token(Token {\n-                        kind: token::Ident(name_macro_rules, false), ..\n-                    })),\n-                    Some(&TokenTree::Token(Token { kind: token::Not, .. })),\n-                    Some(&TokenTree::Token(Token { kind: token::Ident(name_zip, false), .. })),\n-                    Some(&TokenTree::Delimited(_, macro_delim, ref macro_tts)),\n-                )\n-                if name_macro_rules == sym::macro_rules && name_zip.as_str() == \"zip\" => {\n+            match tts {\n+                [\n+                    TokenTree::Token(Token { kind: token::Ident(name_macro_rules, false), .. }),\n+                    TokenTree::Token(Token { kind: token::Not, .. }),\n+                    TokenTree::Token(Token { kind: token::Ident(name_zip, false), .. }),\n+                    TokenTree::Delimited(_, macro_delim,  macro_tts)\n+                ]\n+                if name_macro_rules == &sym::macro_rules && name_zip.as_str() == \"zip\" => {\n                     let tts = &macro_tts.trees().collect::<Vec<_>>();\n-                    match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n-                        (\n-                            3,\n-                            Some(&TokenTree::Delimited(_, first_delim, ref first_tts)),\n-                            Some(&TokenTree::Token(Token { kind: token::FatArrow, .. })),\n-                            Some(&TokenTree::Delimited(_, second_delim, ref second_tts)),\n-                        )\n-                        if macro_delim == token::Paren => {\n+                    match &tts[..] {\n+                        [\n+                            TokenTree::Delimited(_, first_delim, first_tts),\n+                            TokenTree::Token(Token { kind: token::FatArrow, .. }),\n+                            TokenTree::Delimited(_, second_delim, second_tts),\n+                        ]\n+                        if macro_delim == &token::Paren => {\n                             let tts = &first_tts.trees().collect::<Vec<_>>();\n-                            match (tts.len(), tts.get(0), tts.get(1)) {\n-                                (\n-                                    2,\n-                                    Some(&TokenTree::Token(Token { kind: token::Dollar, .. })),\n-                                    Some(&TokenTree::Token(Token {\n-                                        kind: token::Ident(name, false), ..\n-                                    })),\n-                                )\n-                                if first_delim == token::Paren && name.as_str() == \"a\" => {},\n+                            match &tts[..] {\n+                                [\n+                                    TokenTree::Token(Token { kind: token::Dollar, .. }),\n+                                    TokenTree::Token(Token { kind: token::Ident(name, false), .. }),\n+                                ]\n+                                if first_delim == &token::Paren && name.as_str() == \"a\" => {},\n                                 _ => panic!(\"value 3: {:?} {:?}\", first_delim, first_tts),\n                             }\n                             let tts = &second_tts.trees().collect::<Vec<_>>();\n-                            match (tts.len(), tts.get(0), tts.get(1)) {\n-                                (\n-                                    2,\n-                                    Some(&TokenTree::Token(Token { kind: token::Dollar, .. })),\n-                                    Some(&TokenTree::Token(Token {\n-                                        kind: token::Ident(name, false), ..\n-                                    })),\n-                                )\n-                                if second_delim == token::Paren && name.as_str() == \"a\" => {},\n+                            match &tts[..] {\n+                                [\n+                                    TokenTree::Token(Token { kind: token::Dollar, .. }),\n+                                    TokenTree::Token(Token { kind: token::Ident(name, false), .. }),\n+                                ]\n+                                if second_delim == &token::Paren && name.as_str() == \"a\" => {},\n                                 _ => panic!(\"value 4: {:?} {:?}\", second_delim, second_tts),\n                             }\n                         },"}, {"sha": "844865d57c7ad04102534e86736abd736c2fabe2", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=9f22708ceda552784a42253523335533423f2b95", "patch": "@@ -82,8 +82,8 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<\n         // }\n \n         let new = {\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n+            let other_f = match other_fs {\n+                [o_f] => o_f,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\"),\n             };\n "}, {"sha": "732bb234389a0aedd1ccf474f36d27ec3621d8b2", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=9f22708ceda552784a42253523335533423f2b95", "patch": "@@ -25,8 +25,8 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n              -> P<Expr>\n     {\n         let op = |cx: &mut ExtCtxt<'_>, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n+            let other_f = match other_fs {\n+                [o_f] => o_f,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\"),\n             };\n "}, {"sha": "a30a7d78222f47202e348f5a53b6ee694e67c242", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=9f22708ceda552784a42253523335533423f2b95", "patch": "@@ -143,8 +143,8 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n                 // }\n \n                 let new = {\n-                    let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                        (1, Some(o_f)) => o_f,\n+                    let other_f = match other_fs {\n+                        [o_f] => o_f,\n                                 _ => {\n                                     cx.span_bug(span,\n                                         \"not exactly 2 arguments in `derive(PartialOrd)`\")\n@@ -193,8 +193,8 @@ fn cs_op(less: bool,\n     };\n \n     let par_cmp = |cx: &mut ExtCtxt<'_>, span, self_f: P<Expr>, other_fs: &[P<Expr>], default| {\n-        let other_f = match (other_fs.len(), other_fs.get(0)) {\n-            (1, Some(o_f)) => o_f,\n+        let other_f = match other_fs {\n+            [o_f] => o_f,\n             _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n         };\n "}, {"sha": "7ad04aebf6e2ea6e4d5bfc2c5c49b0d3f5165216", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=9f22708ceda552784a42253523335533423f2b95", "patch": "@@ -52,8 +52,8 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt<'_>,\n }\n \n fn hash_substructure(cx: &mut ExtCtxt<'_>, trait_span: Span, substr: &Substructure<'_>) -> P<Expr> {\n-    let state_expr = match (substr.nonself_args.len(), substr.nonself_args.get(0)) {\n-        (1, Some(o_f)) => o_f,\n+    let state_expr = match &substr.nonself_args {\n+        &[o_f] => o_f,\n         _ => {\n             cx.span_bug(trait_span,\n                         \"incorrect number of arguments in `derive(Hash)`\")"}, {"sha": "512513e9b414c8d1aa2cdff8811755f55be18e3a", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22708ceda552784a42253523335533423f2b95/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=9f22708ceda552784a42253523335533423f2b95", "patch": "@@ -16,11 +16,11 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt<'_>,\n                                        feature_gate::EXPLAIN_TRACE_MACROS);\n     }\n \n-    match (tt.len(), tt.first()) {\n-        (1, Some(TokenTree::Token(token))) if token.is_keyword(kw::True) => {\n+    match tt {\n+        [TokenTree::Token(token)] if token.is_keyword(kw::True) => {\n             cx.set_trace_macros(true);\n         }\n-        (1, Some(TokenTree::Token(token))) if token.is_keyword(kw::False) => {\n+        [TokenTree::Token(token)] if token.is_keyword(kw::False) => {\n             cx.set_trace_macros(false);\n         }\n         _ => cx.span_err(sp, \"trace_macros! accepts only `true` or `false`\"),"}]}