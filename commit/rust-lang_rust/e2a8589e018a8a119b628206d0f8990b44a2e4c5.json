{"sha": "e2a8589e018a8a119b628206d0f8990b44a2e4c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYTg1ODllMDE4YThhMTE5YjYyODIwNmQwZjg5OTBiNDRhMmU0YzU=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-02-08T06:38:00Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-02-19T15:01:46Z"}, "message": "Add an abstraction for custom query caches", "tree": {"sha": "c02c10cedec2dbf4c8c5d072be5be5944ab4fb94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c02c10cedec2dbf4c8c5d072be5be5944ab4fb94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2a8589e018a8a119b628206d0f8990b44a2e4c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2a8589e018a8a119b628206d0f8990b44a2e4c5", "html_url": "https://github.com/rust-lang/rust/commit/e2a8589e018a8a119b628206d0f8990b44a2e4c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2a8589e018a8a119b628206d0f8990b44a2e4c5/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bf014ec99e40145ad5f046199f58c9c9d7f60e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf014ec99e40145ad5f046199f58c9c9d7f60e1", "html_url": "https://github.com/rust-lang/rust/commit/6bf014ec99e40145ad5f046199f58c9c9d7f60e1"}], "stats": {"total": 428, "additions": 305, "deletions": 123}, "files": [{"sha": "efc2804bd4d5985fa45b1fc95a19c05b18dc6501", "filename": "src/librustc/ty/query/caches.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fcaches.rs?ref=e2a8589e018a8a119b628206d0f8990b44a2e4c5", "patch": "@@ -0,0 +1,112 @@\n+use crate::dep_graph::DepNodeIndex;\n+use crate::ty::query::config::QueryAccessors;\n+use crate::ty::query::plumbing::{QueryLookup, QueryState, QueryStateShard};\n+use crate::ty::TyCtxt;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sharded::Sharded;\n+use std::default::Default;\n+use std::hash::Hash;\n+\n+pub(crate) trait CacheSelector<K, V> {\n+    type Cache: QueryCache<K, V>;\n+}\n+\n+pub(crate) trait QueryCache<K, V>: Default {\n+    type Sharded: Default;\n+\n+    /// Checks if the query is already computed and in the cache.\n+    /// It returns the shard index and a lock guard to the shard,\n+    /// which will be used if the query is not in the cache and we need\n+    /// to compute it.\n+    fn lookup<'tcx, R, GetCache, OnHit, OnMiss, Q>(\n+        &self,\n+        state: &'tcx QueryState<'tcx, Q>,\n+        get_cache: GetCache,\n+        key: K,\n+        // `on_hit` can be called while holding a lock to the query state shard.\n+        on_hit: OnHit,\n+        on_miss: OnMiss,\n+    ) -> R\n+    where\n+        Q: QueryAccessors<'tcx>,\n+        GetCache: for<'a> Fn(&'a mut QueryStateShard<'tcx, Q>) -> &'a mut Self::Sharded,\n+        OnHit: FnOnce(&V, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(K, QueryLookup<'tcx, Q>) -> R;\n+\n+    fn complete(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        lock_sharded_storage: &mut Self::Sharded,\n+        key: K,\n+        value: V,\n+        index: DepNodeIndex,\n+    );\n+\n+    fn iter<R, L>(\n+        &self,\n+        shards: &Sharded<L>,\n+        get_shard: impl Fn(&mut L) -> &mut Self::Sharded,\n+        f: impl for<'a> FnOnce(Box<dyn Iterator<Item = (&'a K, &'a V, DepNodeIndex)> + 'a>) -> R,\n+    ) -> R;\n+}\n+\n+pub struct DefaultCacheSelector;\n+\n+impl<K: Eq + Hash, V: Clone> CacheSelector<K, V> for DefaultCacheSelector {\n+    type Cache = DefaultCache;\n+}\n+\n+#[derive(Default)]\n+pub struct DefaultCache;\n+\n+impl<K: Eq + Hash, V: Clone> QueryCache<K, V> for DefaultCache {\n+    type Sharded = FxHashMap<K, (V, DepNodeIndex)>;\n+\n+    #[inline(always)]\n+    fn lookup<'tcx, R, GetCache, OnHit, OnMiss, Q>(\n+        &self,\n+        state: &'tcx QueryState<'tcx, Q>,\n+        get_cache: GetCache,\n+        key: K,\n+        on_hit: OnHit,\n+        on_miss: OnMiss,\n+    ) -> R\n+    where\n+        Q: QueryAccessors<'tcx>,\n+        GetCache: for<'a> Fn(&'a mut QueryStateShard<'tcx, Q>) -> &'a mut Self::Sharded,\n+        OnHit: FnOnce(&V, DepNodeIndex) -> R,\n+        OnMiss: FnOnce(K, QueryLookup<'tcx, Q>) -> R,\n+    {\n+        let mut lookup = state.get_lookup(&key);\n+        let lock = &mut *lookup.lock;\n+\n+        let result = get_cache(lock).raw_entry().from_key_hashed_nocheck(lookup.key_hash, &key);\n+\n+        if let Some((_, value)) = result { on_hit(&value.0, value.1) } else { on_miss(key, lookup) }\n+    }\n+\n+    #[inline]\n+    fn complete(\n+        &self,\n+        _: TyCtxt<'tcx>,\n+        lock_sharded_storage: &mut Self::Sharded,\n+        key: K,\n+        value: V,\n+        index: DepNodeIndex,\n+    ) {\n+        lock_sharded_storage.insert(key, (value, index));\n+    }\n+\n+    fn iter<R, L>(\n+        &self,\n+        shards: &Sharded<L>,\n+        get_shard: impl Fn(&mut L) -> &mut Self::Sharded,\n+        f: impl for<'a> FnOnce(Box<dyn Iterator<Item = (&'a K, &'a V, DepNodeIndex)> + 'a>) -> R,\n+    ) -> R {\n+        let mut shards = shards.lock_shards();\n+        let mut shards: Vec<_> = shards.iter_mut().map(|shard| get_shard(shard)).collect();\n+        let results = shards.iter_mut().flat_map(|shard| shard.iter()).map(|(k, v)| (k, &v.0, v.1));\n+        f(Box::new(results))\n+    }\n+}"}, {"sha": "e0e1ca374d9aef8deacadeabbbf29974773ecbd6", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=e2a8589e018a8a119b628206d0f8990b44a2e4c5", "patch": "@@ -1,15 +1,15 @@\n use crate::dep_graph::SerializedDepNodeIndex;\n use crate::dep_graph::{DepKind, DepNode};\n+use crate::ty::query::caches::QueryCache;\n use crate::ty::query::plumbing::CycleError;\n use crate::ty::query::queries;\n-use crate::ty::query::{Query, QueryCache};\n+use crate::ty::query::{Query, QueryState};\n use crate::ty::TyCtxt;\n use rustc_data_structures::profiling::ProfileCategory;\n use rustc_hir::def_id::{CrateNum, DefId};\n \n use crate::ich::StableHashingContext;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::sharded::Sharded;\n use std::borrow::Cow;\n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -30,10 +30,12 @@ pub(crate) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n     const ANON: bool;\n     const EVAL_ALWAYS: bool;\n \n+    type Cache: QueryCache<Self::Key, Self::Value>;\n+\n     fn query(key: Self::Key) -> Query<'tcx>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_cache<'a>(tcx: TyCtxt<'tcx>) -> &'a Sharded<QueryCache<'tcx, Self>>;\n+    fn query_state<'a>(tcx: TyCtxt<'tcx>) -> &'a QueryState<'tcx, Self>;\n \n     fn to_dep_node(tcx: TyCtxt<'tcx>, key: &Self::Key) -> DepNode;\n \n@@ -61,7 +63,10 @@ pub(crate) trait QueryDescription<'tcx>: QueryAccessors<'tcx> {\n     }\n }\n \n-impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M {\n+impl<'tcx, M: QueryAccessors<'tcx, Key = DefId>> QueryDescription<'tcx> for M\n+where\n+    <M as QueryAccessors<'tcx>>::Cache: QueryCache<DefId, <M as QueryConfig<'tcx>>::Value>,\n+{\n     default fn describe(tcx: TyCtxt<'_>, def_id: DefId) -> Cow<'static, str> {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.def_path_str(def_id)).into()"}, {"sha": "09fb307a1ceb416cb6aec8b5030a7a676002bee1", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=e2a8589e018a8a119b628206d0f8990b44a2e4c5", "patch": "@@ -4,6 +4,7 @@ use crate::infer::canonical::Canonical;\n use crate::mir;\n use crate::traits;\n use crate::ty::fast_reject::SimplifiedType;\n+use crate::ty::query::caches::DefaultCacheSelector;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n@@ -12,7 +13,9 @@ use rustc_span::{Span, DUMMY_SP};\n \n /// The `Key` trait controls what types can legally be used as the key\n /// for a query.\n-pub(super) trait Key {\n+pub trait Key {\n+    type CacheSelector;\n+\n     /// Given an instance of this key, what crate is it referring to?\n     /// This is used to find the provider.\n     fn query_crate(&self) -> CrateNum;\n@@ -23,6 +26,8 @@ pub(super) trait Key {\n }\n \n impl<'tcx> Key for ty::InstanceDef<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -33,6 +38,8 @@ impl<'tcx> Key for ty::InstanceDef<'tcx> {\n }\n \n impl<'tcx> Key for ty::Instance<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -43,6 +50,8 @@ impl<'tcx> Key for ty::Instance<'tcx> {\n }\n \n impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.instance.query_crate()\n     }\n@@ -53,6 +62,8 @@ impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n }\n \n impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -63,6 +74,8 @@ impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n }\n \n impl Key for CrateNum {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         *self\n     }\n@@ -72,6 +85,8 @@ impl Key for CrateNum {\n }\n \n impl Key for DefIndex {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -81,6 +96,8 @@ impl Key for DefIndex {\n }\n \n impl Key for DefId {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.krate\n     }\n@@ -90,6 +107,8 @@ impl Key for DefId {\n }\n \n impl Key for (DefId, DefId) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n@@ -99,6 +118,8 @@ impl Key for (DefId, DefId) {\n }\n \n impl Key for (CrateNum, DefId) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.0\n     }\n@@ -108,6 +129,8 @@ impl Key for (CrateNum, DefId) {\n }\n \n impl Key for (DefId, SimplifiedType) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n@@ -117,6 +140,8 @@ impl Key for (DefId, SimplifiedType) {\n }\n \n impl<'tcx> Key for SubstsRef<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -126,6 +151,8 @@ impl<'tcx> Key for SubstsRef<'tcx> {\n }\n \n impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.0.krate\n     }\n@@ -135,6 +162,8 @@ impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n }\n \n impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.1.def_id().krate\n     }\n@@ -144,6 +173,8 @@ impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n }\n \n impl<'tcx> Key for (&'tcx ty::Const<'tcx>, mir::Field) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -153,6 +184,8 @@ impl<'tcx> Key for (&'tcx ty::Const<'tcx>, mir::Field) {\n }\n \n impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.def_id().krate\n     }\n@@ -162,6 +195,8 @@ impl<'tcx> Key for ty::PolyTraitRef<'tcx> {\n }\n \n impl<'tcx> Key for &'tcx ty::Const<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -171,6 +206,8 @@ impl<'tcx> Key for &'tcx ty::Const<'tcx> {\n }\n \n impl<'tcx> Key for Ty<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -180,6 +217,8 @@ impl<'tcx> Key for Ty<'tcx> {\n }\n \n impl<'tcx> Key for ty::ParamEnv<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -189,6 +228,8 @@ impl<'tcx> Key for ty::ParamEnv<'tcx> {\n }\n \n impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         self.value.query_crate()\n     }\n@@ -198,6 +239,8 @@ impl<'tcx, T: Key> Key for ty::ParamEnvAnd<'tcx, T> {\n }\n \n impl<'tcx> Key for traits::Environment<'tcx> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -207,6 +250,8 @@ impl<'tcx> Key for traits::Environment<'tcx> {\n }\n \n impl Key for Symbol {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -218,6 +263,8 @@ impl Key for Symbol {\n /// Canonical query goals correspond to abstract trait operations that\n /// are not tied to any crate in particular.\n impl<'tcx, T> Key for Canonical<'tcx, T> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }\n@@ -228,6 +275,8 @@ impl<'tcx, T> Key for Canonical<'tcx, T> {\n }\n \n impl Key for (Symbol, u32, u32) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }"}, {"sha": "91ae11b327ed95f729ae3c6e59ebc7cf52a320ea", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=e2a8589e018a8a119b628206d0f8990b44a2e4c5", "patch": "@@ -76,6 +76,9 @@ use self::keys::Key;\n mod values;\n use self::values::Value;\n \n+mod caches;\n+use self::caches::CacheSelector;\n+\n mod config;\n use self::config::QueryAccessors;\n pub use self::config::QueryConfig;"}, {"sha": "b92081ff7c05f508b3e69073b9c287a6ec93584d", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=e2a8589e018a8a119b628206d0f8990b44a2e4c5", "patch": "@@ -1035,20 +1035,22 @@ where\n         .prof\n         .extra_verbose_generic_activity(\"encode_query_results_for\", ::std::any::type_name::<Q>());\n \n-    let shards = Q::query_cache(tcx).lock_shards();\n-    assert!(shards.iter().all(|shard| shard.active.is_empty()));\n-    for (key, entry) in shards.iter().flat_map(|shard| shard.results.iter()) {\n-        if Q::cache_on_disk(tcx, key.clone(), Some(&entry.value)) {\n-            let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n-\n-            // Record position of the cache entry.\n-            query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n-\n-            // Encode the type check tables with the `SerializedDepNodeIndex`\n-            // as tag.\n-            encoder.encode_tagged(dep_node, &entry.value)?;\n-        }\n-    }\n+    let state = Q::query_state(tcx);\n+    assert!(state.all_inactive());\n+\n+    state.iter_results(|results| {\n+        for (key, value, dep_node) in results {\n+            if Q::cache_on_disk(tcx, key.clone(), Some(&value)) {\n+                let dep_node = SerializedDepNodeIndex::new(dep_node.index());\n+\n+                // Record position of the cache entry.\n+                query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n \n-    Ok(())\n+                // Encode the type check tables with the `SerializedDepNodeIndex`\n+                // as tag.\n+                encoder.encode_tagged(dep_node, &value)?;\n+            }\n+        }\n+        Ok(())\n+    })\n }"}, {"sha": "3eaf4e36f3930975bf230982887122621bcb6229", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 101, "deletions": 73, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=e2a8589e018a8a119b628206d0f8990b44a2e4c5", "patch": "@@ -3,7 +3,8 @@\n //! manage the caches, and so forth.\n \n use crate::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n-use crate::ty::query::config::{QueryConfig, QueryDescription};\n+use crate::ty::query::caches::QueryCache;\n+use crate::ty::query::config::{QueryAccessors, QueryDescription};\n use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryShardJobId};\n use crate::ty::query::Query;\n use crate::ty::tls;\n@@ -24,25 +25,47 @@ use std::mem;\n use std::num::NonZeroU32;\n use std::ptr;\n \n-pub struct QueryCache<'tcx, D: QueryConfig<'tcx> + ?Sized> {\n-    pub(super) results: FxHashMap<D::Key, QueryValue<D::Value>>,\n+pub(crate) struct QueryStateShard<'tcx, D: QueryAccessors<'tcx> + ?Sized> {\n+    pub(super) cache: <<D as QueryAccessors<'tcx>>::Cache as QueryCache<D::Key, D::Value>>::Sharded,\n     pub(super) active: FxHashMap<D::Key, QueryResult<'tcx>>,\n \n     /// Used to generate unique ids for active jobs.\n     pub(super) jobs: u32,\n+}\n \n+impl<'tcx, Q: QueryAccessors<'tcx>> QueryStateShard<'tcx, Q> {\n+    fn get_cache(\n+        &mut self,\n+    ) -> &mut <<Q as QueryAccessors<'tcx>>::Cache as QueryCache<Q::Key, Q::Value>>::Sharded {\n+        &mut self.cache\n+    }\n+}\n+\n+impl<'tcx, Q: QueryAccessors<'tcx>> Default for QueryStateShard<'tcx, Q> {\n+    fn default() -> QueryStateShard<'tcx, Q> {\n+        QueryStateShard { cache: Default::default(), active: Default::default(), jobs: 0 }\n+    }\n+}\n+\n+pub(crate) struct QueryState<'tcx, D: QueryAccessors<'tcx> + ?Sized> {\n+    pub(super) cache: D::Cache,\n+    pub(super) shards: Sharded<QueryStateShard<'tcx, D>>,\n     #[cfg(debug_assertions)]\n     pub(super) cache_hits: usize,\n }\n \n-pub(super) struct QueryValue<T> {\n-    pub(super) value: T,\n-    pub(super) index: DepNodeIndex,\n-}\n+impl<'tcx, Q: QueryAccessors<'tcx>> QueryState<'tcx, Q> {\n+    pub(super) fn get_lookup<K: Hash>(&'tcx self, key: &K) -> QueryLookup<'tcx, Q> {\n+        // We compute the key's hash once and then use it for both the\n+        // shard lookup and the hashmap lookup. This relies on the fact\n+        // that both of them use `FxHasher`.\n+        let mut hasher = FxHasher::default();\n+        key.hash(&mut hasher);\n+        let key_hash = hasher.finish();\n \n-impl<T> QueryValue<T> {\n-    pub(super) fn new(value: T, dep_node_index: DepNodeIndex) -> QueryValue<T> {\n-        QueryValue { value, index: dep_node_index }\n+        let shard = self.shards.get_shard_index_by_hash(key_hash);\n+        let lock = self.shards.get_shard_by_index(shard).lock();\n+        QueryLookup { key_hash, shard, lock }\n     }\n }\n \n@@ -56,33 +79,48 @@ pub(super) enum QueryResult<'tcx> {\n     Poisoned,\n }\n \n-impl<'tcx, M: QueryConfig<'tcx>> Default for QueryCache<'tcx, M> {\n-    fn default() -> QueryCache<'tcx, M> {\n-        QueryCache {\n-            results: FxHashMap::default(),\n-            active: FxHashMap::default(),\n-            jobs: 0,\n+impl<'tcx, M: QueryAccessors<'tcx>> QueryState<'tcx, M> {\n+    pub fn iter_results<R>(\n+        &self,\n+        f: impl for<'a> FnOnce(\n+            Box<dyn Iterator<Item = (&'a M::Key, &'a M::Value, DepNodeIndex)> + 'a>,\n+        ) -> R,\n+    ) -> R {\n+        self.cache.iter(&self.shards, |shard| &mut shard.cache, f)\n+    }\n+    pub fn all_inactive(&self) -> bool {\n+        let shards = self.shards.lock_shards();\n+        shards.iter().all(|shard| shard.active.is_empty())\n+    }\n+}\n+\n+impl<'tcx, M: QueryAccessors<'tcx>> Default for QueryState<'tcx, M> {\n+    fn default() -> QueryState<'tcx, M> {\n+        QueryState {\n+            cache: M::Cache::default(),\n+            shards: Default::default(),\n             #[cfg(debug_assertions)]\n             cache_hits: 0,\n         }\n     }\n }\n \n /// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n-pub(super) struct QueryLookup<'tcx, Q: QueryDescription<'tcx>> {\n-    shard: usize,\n-    lock: LockGuard<'tcx, QueryCache<'tcx, Q>>,\n+pub(crate) struct QueryLookup<'tcx, Q: QueryAccessors<'tcx>> {\n+    pub(super) key_hash: u64,\n+    pub(super) shard: usize,\n+    pub(super) lock: LockGuard<'tcx, QueryStateShard<'tcx, Q>>,\n }\n \n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-pub(super) struct JobOwner<'a, 'tcx, Q: QueryDescription<'tcx>> {\n-    cache: &'a Sharded<QueryCache<'tcx, Q>>,\n+pub(super) struct JobOwner<'tcx, Q: QueryDescription<'tcx>> {\n+    tcx: TyCtxt<'tcx>,\n     key: Q::Key,\n     id: QueryJobId,\n }\n \n-impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n+impl<'tcx, Q: QueryDescription<'tcx>> JobOwner<'tcx, Q> {\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n     /// start executing the query, or returns with the result of the query.\n     /// This function assumes that `try_get_cached` is already called and returned `lookup`.\n@@ -97,7 +135,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n         span: Span,\n         key: &Q::Key,\n         mut lookup: QueryLookup<'tcx, Q>,\n-    ) -> TryGetJob<'a, 'tcx, Q> {\n+    ) -> TryGetJob<'tcx, Q> {\n         let lock = &mut *lookup.lock;\n \n         let (latch, mut _query_blocked_prof_timer) = match lock.active.entry((*key).clone()) {\n@@ -135,8 +173,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n \n                 entry.insert(QueryResult::Started(job));\n \n-                let owner =\n-                    JobOwner { cache: Q::query_cache(tcx), id: global_id, key: (*key).clone() };\n+                let owner = JobOwner { tcx, id: global_id, key: (*key).clone() };\n                 return TryGetJob::NotYetStarted(owner);\n             }\n         };\n@@ -179,19 +216,20 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n     pub(super) fn complete(self, result: &Q::Value, dep_node_index: DepNodeIndex) {\n         // We can move out of `self` here because we `mem::forget` it below\n         let key = unsafe { ptr::read(&self.key) };\n-        let cache = self.cache;\n+        let tcx = self.tcx;\n \n         // Forget ourself so our destructor won't poison the query\n         mem::forget(self);\n \n-        let value = QueryValue::new(result.clone(), dep_node_index);\n         let job = {\n-            let mut lock = cache.get_shard_by_value(&key).lock();\n+            let state = Q::query_state(tcx);\n+            let result = result.clone();\n+            let mut lock = state.shards.get_shard_by_value(&key).lock();\n             let job = match lock.active.remove(&key).unwrap() {\n                 QueryResult::Started(job) => job,\n                 QueryResult::Poisoned => panic!(),\n             };\n-            lock.results.insert(key, value);\n+            state.cache.complete(tcx, &mut lock.cache, key, result, dep_node_index);\n             job\n         };\n \n@@ -209,12 +247,13 @@ where\n     (result, diagnostics.into_inner())\n }\n \n-impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n+impl<'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'tcx, Q> {\n     #[inline(never)]\n     #[cold]\n     fn drop(&mut self) {\n         // Poison the query so jobs waiting on it panic.\n-        let shard = self.cache.get_shard_by_value(&self.key);\n+        let state = Q::query_state(self.tcx);\n+        let shard = state.shards.get_shard_by_value(&self.key);\n         let job = {\n             let mut shard = shard.lock();\n             let job = match shard.active.remove(&self.key).unwrap() {\n@@ -237,10 +276,10 @@ pub struct CycleError<'tcx> {\n     pub(super) cycle: Vec<QueryInfo<'tcx>>,\n }\n \n-/// The result of `try_get_lock`.\n-pub(super) enum TryGetJob<'a, 'tcx, D: QueryDescription<'tcx>> {\n+/// The result of `try_start`.\n+pub(super) enum TryGetJob<'tcx, D: QueryDescription<'tcx>> {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n-    NotYetStarted(JobOwner<'a, 'tcx, D>),\n+    NotYetStarted(JobOwner<'tcx, D>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep-node index\n@@ -390,30 +429,20 @@ impl<'tcx> TyCtxt<'tcx> {\n         OnHit: FnOnce(&Q::Value, DepNodeIndex) -> R,\n         OnMiss: FnOnce(Q::Key, QueryLookup<'tcx, Q>) -> R,\n     {\n-        let cache = Q::query_cache(self);\n-\n-        // We compute the key's hash once and then use it for both the\n-        // shard lookup and the hashmap lookup. This relies on the fact\n-        // that both of them use `FxHasher`.\n-        let mut state = FxHasher::default();\n-        key.hash(&mut state);\n-        let key_hash = state.finish();\n-\n-        let shard = cache.get_shard_index_by_hash(key_hash);\n-        let mut lock_guard = cache.get_shard_by_index(shard).lock();\n-        let lock = &mut *lock_guard;\n+        let state = Q::query_state(self);\n \n-        let result = lock.results.raw_entry().from_key_hashed_nocheck(key_hash, &key);\n-\n-        if let Some((_, value)) = result {\n-            if unlikely!(self.prof.enabled()) {\n-                self.prof.query_cache_hit(value.index.into());\n-            }\n-\n-            on_hit(&value.value, value.index)\n-        } else {\n-            on_miss(key, QueryLookup { lock: lock_guard, shard })\n-        }\n+        state.cache.lookup(\n+            state,\n+            QueryStateShard::<Q>::get_cache,\n+            key,\n+            |value, index| {\n+                if unlikely!(self.prof.enabled()) {\n+                    self.prof.query_cache_hit(index.into());\n+                }\n+                on_hit(value, index)\n+            },\n+            on_miss,\n+        )\n     }\n \n     #[inline(never)]\n@@ -430,7 +459,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 self.dep_graph.read_index(index);\n                 value.clone()\n             },\n-            |key, lookup| self.try_execute_query(span, key, lookup),\n+            |key, lookup| self.try_execute_query::<Q>(span, key, lookup),\n         )\n     }\n \n@@ -602,7 +631,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     fn force_query_with_job<Q: QueryDescription<'tcx>>(\n         self,\n         key: Q::Key,\n-        job: JobOwner<'_, 'tcx, Q>,\n+        job: JobOwner<'tcx, Q>,\n         dep_node: DepNode,\n     ) -> (Q::Value, DepNodeIndex) {\n         // If the following assertion triggers, it can have two reasons:\n@@ -783,7 +812,6 @@ macro_rules! define_queries_inner {\n         [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n \n         use std::mem;\n-        use rustc_data_structures::sharded::Sharded;\n         use crate::{\n             rustc_data_structures::stable_hasher::HashStable,\n             rustc_data_structures::stable_hasher::StableHasher,\n@@ -818,11 +846,11 @@ macro_rules! define_queries_inner {\n                 $(\n                     // We use try_lock_shards here since we are called from the\n                     // deadlock handler, and this shouldn't be locked.\n-                    let shards = self.$name.try_lock_shards()?;\n+                    let shards = self.$name.shards.try_lock_shards()?;\n                     let shards = shards.iter().enumerate();\n                     jobs.extend(shards.flat_map(|(shard_id, shard)| {\n                         shard.active.iter().filter_map(move |(k, v)| {\n-                            if let QueryResult::Started(ref job) = *v {\n+                        if let QueryResult::Started(ref job) = *v {\n                                 let id = QueryJobId {\n                                     job: job.id,\n                                     shard:  u16::try_from(shard_id).unwrap(),\n@@ -834,9 +862,9 @@ macro_rules! define_queries_inner {\n                                     query: queries::$name::query(k.clone())\n                                 };\n                                 Some((id, QueryJobInfo { info,  job: job.clone() }))\n-                            } else {\n-                                None\n-                            }\n+                        } else {\n+                            None\n+                        }\n                         })\n                     }));\n                 )*\n@@ -858,22 +886,21 @@ macro_rules! define_queries_inner {\n                     entry_count: usize,\n                 }\n \n-                fn stats<'tcx, Q: QueryConfig<'tcx>>(\n+                fn stats<'tcx, Q: QueryAccessors<'tcx>>(\n                     name: &'static str,\n-                    map: &Sharded<QueryCache<'tcx, Q>>,\n+                    map: &QueryState<'tcx, Q>,\n                 ) -> QueryStats {\n-                    let map = map.lock_shards();\n                     QueryStats {\n                         name,\n                         #[cfg(debug_assertions)]\n-                        cache_hits: map.iter().map(|shard| shard.cache_hits).sum(),\n+                        cache_hits: map.cache_hits,\n                         #[cfg(not(debug_assertions))]\n                         cache_hits: 0,\n                         key_size: mem::size_of::<Q::Key>(),\n                         key_type: type_name::<Q::Key>(),\n                         value_size: mem::size_of::<Q::Value>(),\n                         value_type: type_name::<Q::Value>(),\n-                        entry_count: map.iter().map(|shard| shard.results.len()).sum(),\n+                        entry_count: map.iter_results(|results| results.count()),\n                     }\n                 }\n \n@@ -1014,7 +1041,6 @@ macro_rules! define_queries_inner {\n         $(impl<$tcx> QueryConfig<$tcx> for queries::$name<$tcx> {\n             type Key = $K;\n             type Value = $V;\n-\n             const NAME: &'static str = stringify!($name);\n             const CATEGORY: ProfileCategory = $category;\n         }\n@@ -1023,13 +1049,15 @@ macro_rules! define_queries_inner {\n             const ANON: bool = is_anon!([$($modifiers)*]);\n             const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n \n+            type Cache = <<$K as Key>::CacheSelector as CacheSelector<$K, $V>>::Cache;\n+\n             #[inline(always)]\n             fn query(key: Self::Key) -> Query<'tcx> {\n                 Query::$name(key)\n             }\n \n             #[inline(always)]\n-            fn query_cache<'a>(tcx: TyCtxt<$tcx>) -> &'a Sharded<QueryCache<$tcx, Self>> {\n+            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<$tcx, Self> {\n                 &tcx.queries.$name\n             }\n \n@@ -1190,7 +1218,7 @@ macro_rules! define_queries_struct {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n             fallback_extern_providers: Box<Providers<$tcx>>,\n \n-            $($(#[$attr])*  $name: Sharded<QueryCache<$tcx, queries::$name<$tcx>>>,)*\n+            $($(#[$attr])*  $name: QueryState<$tcx, queries::$name<$tcx>>,)*\n         }\n     };\n }"}, {"sha": "99ada34d59ebed13c5b4829e107e0be83f973c40", "filename": "src/librustc/ty/query/profiling_support.rs", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a8589e018a8a119b628206d0f8990b44a2e4c5/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fprofiling_support.rs?ref=e2a8589e018a8a119b628206d0f8990b44a2e4c5", "patch": "@@ -1,11 +1,10 @@\n use crate::hir::map::definitions::DefPathData;\n use crate::ty::context::TyCtxt;\n-use crate::ty::query::config::QueryConfig;\n-use crate::ty::query::plumbing::QueryCache;\n+use crate::ty::query::config::QueryAccessors;\n+use crate::ty::query::plumbing::QueryState;\n use measureme::{StringComponent, StringId};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfiler;\n-use rustc_data_structures::sharded::Sharded;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use std::fmt::Debug;\n use std::io::Write;\n@@ -161,10 +160,10 @@ where\n pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, Q>(\n     tcx: TyCtxt<'tcx>,\n     query_name: &'static str,\n-    query_cache: &Sharded<QueryCache<'tcx, Q>>,\n+    query_state: &QueryState<'tcx, Q>,\n     string_cache: &mut QueryKeyStringCache,\n ) where\n-    Q: QueryConfig<'tcx>,\n+    Q: QueryAccessors<'tcx>,\n {\n     tcx.prof.with_profiler(|profiler| {\n         let event_id_builder = profiler.event_id_builder();\n@@ -181,20 +180,8 @@ pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, Q>(\n             // need to invoke queries itself, we cannot keep the query caches\n             // locked while doing so. Instead we copy out the\n             // `(query_key, dep_node_index)` pairs and release the lock again.\n-            let query_keys_and_indices = {\n-                let shards = query_cache.lock_shards();\n-                let len = shards.iter().map(|shard| shard.results.len()).sum();\n-\n-                let mut query_keys_and_indices = Vec::with_capacity(len);\n-\n-                for shard in &shards {\n-                    query_keys_and_indices.extend(\n-                        shard.results.iter().map(|(q_key, q_val)| (q_key.clone(), q_val.index)),\n-                    );\n-                }\n-\n-                query_keys_and_indices\n-            };\n+            let query_keys_and_indices: Vec<_> = query_state\n+                .iter_results(|results| results.map(|(k, _, i)| (k.clone(), i)).collect());\n \n             // Now actually allocate the strings. If allocating the strings\n             // generates new entries in the query cache, we'll miss them but\n@@ -218,18 +205,14 @@ pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, Q>(\n             let query_name = profiler.get_or_alloc_cached_string(query_name);\n             let event_id = event_id_builder.from_label(query_name).to_string_id();\n \n-            let shards = query_cache.lock_shards();\n+            query_state.iter_results(|results| {\n+                let query_invocation_ids: Vec<_> = results.map(|v| v.2.into()).collect();\n \n-            for shard in shards.iter() {\n-                let query_invocation_ids = shard\n-                    .results\n-                    .values()\n-                    .map(|v| v.index)\n-                    .map(|dep_node_index| dep_node_index.into());\n-\n-                profiler\n-                    .bulk_map_query_invocation_id_to_single_string(query_invocation_ids, event_id);\n-            }\n+                profiler.bulk_map_query_invocation_id_to_single_string(\n+                    query_invocation_ids.into_iter(),\n+                    event_id,\n+                );\n+            });\n         }\n     });\n }"}]}