{"sha": "5ee36b7ecafc873ae15c4a4aa74f8293103b14c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZTM2YjdlY2FmYzg3M2FlMTVjNGE0YWE3NGY4MjkzMTAzYjE0Yzk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T01:11:36Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T02:01:39Z"}, "message": "typeck/expr.rs: move check_method_call here.", "tree": {"sha": "cabee40a35b7226ee1415558e8f412a161423c10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cabee40a35b7226ee1415558e8f412a161423c10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ee36b7ecafc873ae15c4a4aa74f8293103b14c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ee36b7ecafc873ae15c4a4aa74f8293103b14c9", "html_url": "https://github.com/rust-lang/rust/commit/5ee36b7ecafc873ae15c4a4aa74f8293103b14c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ee36b7ecafc873ae15c4a4aa74f8293103b14c9/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "819c4f2f0890baea055d80d3f68a776328d1f5fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/819c4f2f0890baea055d80d3f68a776328d1f5fb", "html_url": "https://github.com/rust-lang/rust/commit/819c4f2f0890baea055d80d3f68a776328d1f5fb"}], "stats": {"total": 97, "additions": 50, "deletions": 47}, "files": [{"sha": "b133526054fdde340cff9f14e2e9c7923f5a3381", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5ee36b7ecafc873ae15c4a4aa74f8293103b14c9/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ee36b7ecafc873ae15c4a4aa74f8293103b14c9/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=5ee36b7ecafc873ae15c4a4aa74f8293103b14c9", "patch": "@@ -11,13 +11,16 @@ use crate::check::Expectation::{self, NoExpectation, ExpectHasType, ExpectCastab\n use crate::check::fatally_break_rust;\n use crate::check::report_unexpected_variant_res;\n use crate::check::Needs;\n+use crate::check::TupleArgumentsFlag::DontTupleArguments;\n+use crate::check::method::SelfSource;\n use crate::middle::lang_items;\n use crate::util::common::ErrorReported;\n \n use errors::Applicability;\n use syntax::ast;\n use syntax::ptr::P;\n-use syntax::symbol::sym;\n+use syntax::symbol::{kw, sym};\n+use syntax::source_map::Span;\n use rustc::hir;\n use rustc::hir::{ExprKind, QPath};\n use rustc::hir::def::{CtorKind, Res, DefKind};\n@@ -772,6 +775,52 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ctxt.coerce.map(|c| c.complete(self)).unwrap_or_else(|| self.tcx.mk_unit())\n     }\n \n+    /// Checks a method call.\n+    fn check_method_call(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        segment: &hir::PathSegment,\n+        span: Span,\n+        args: &'tcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+        needs: Needs,\n+    ) -> Ty<'tcx> {\n+        let rcvr = &args[0];\n+        let rcvr_t = self.check_expr_with_needs(&rcvr, needs);\n+        // no need to check for bot/err -- callee does that\n+        let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n+\n+        let method = match self.lookup_method(rcvr_t,\n+                                              segment,\n+                                              span,\n+                                              expr,\n+                                              rcvr) {\n+            Ok(method) => {\n+                self.write_method_call(expr.hir_id, method);\n+                Ok(method)\n+            }\n+            Err(error) => {\n+                if segment.ident.name != kw::Invalid {\n+                    self.report_method_error(span,\n+                                             rcvr_t,\n+                                             segment.ident,\n+                                             SelfSource::MethodCall(rcvr),\n+                                             error,\n+                                             Some(args));\n+                }\n+                Err(())\n+            }\n+        };\n+\n+        // Call the generic checker.\n+        self.check_method_argument_types(span,\n+                                         expr.span,\n+                                         method,\n+                                         &args[1..],\n+                                         DontTupleArguments,\n+                                         expected)\n+    }\n+\n     fn check_expr_cast(\n         &self,\n         e: &'tcx hir::Expr,"}, {"sha": "ae894a114520571baf2af6e0691ff4f267391703", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5ee36b7ecafc873ae15c4a4aa74f8293103b14c9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ee36b7ecafc873ae15c4a4aa74f8293103b14c9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5ee36b7ecafc873ae15c4a4aa74f8293103b14c9", "patch": "@@ -3266,52 +3266,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expect_args\n     }\n \n-    // Checks a method call.\n-    fn check_method_call(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        segment: &hir::PathSegment,\n-        span: Span,\n-        args: &'tcx [hir::Expr],\n-        expected: Expectation<'tcx>,\n-        needs: Needs,\n-    ) -> Ty<'tcx> {\n-        let rcvr = &args[0];\n-        let rcvr_t = self.check_expr_with_needs(&rcvr, needs);\n-        // no need to check for bot/err -- callee does that\n-        let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n-\n-        let method = match self.lookup_method(rcvr_t,\n-                                              segment,\n-                                              span,\n-                                              expr,\n-                                              rcvr) {\n-            Ok(method) => {\n-                self.write_method_call(expr.hir_id, method);\n-                Ok(method)\n-            }\n-            Err(error) => {\n-                if segment.ident.name != kw::Invalid {\n-                    self.report_method_error(span,\n-                                             rcvr_t,\n-                                             segment.ident,\n-                                             SelfSource::MethodCall(rcvr),\n-                                             error,\n-                                             Some(args));\n-                }\n-                Err(())\n-            }\n-        };\n-\n-        // Call the generic checker.\n-        self.check_method_argument_types(span,\n-                                         expr.span,\n-                                         method,\n-                                         &args[1..],\n-                                         DontTupleArguments,\n-                                         expected)\n-    }\n-\n     // Check field access expressions\n     fn check_field(\n         &self,"}]}