{"sha": "0ded8e734f0280e407f8e22f8c6895cb1dda69be", "node_id": "C_kwDOAAsO6NoAKDBkZWQ4ZTczNGYwMjgwZTQwN2Y4ZTIyZjhjNjg5NWNiMWRkYTY5YmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-20T12:00:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-20T12:00:14Z"}, "message": "Auto merge of #12825 - Veykril:trait-assoc-search, r=Veykril\n\nfix: Fix search for associated trait items being inconsistent", "tree": {"sha": "c702f61b5cf5aae8db41a4b763bffc3804ba58d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c702f61b5cf5aae8db41a4b763bffc3804ba58d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ded8e734f0280e407f8e22f8c6895cb1dda69be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ded8e734f0280e407f8e22f8c6895cb1dda69be", "html_url": "https://github.com/rust-lang/rust/commit/0ded8e734f0280e407f8e22f8c6895cb1dda69be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ded8e734f0280e407f8e22f8c6895cb1dda69be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3e9b38e26646a75fdb3c25a2909bce68cde596c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3e9b38e26646a75fdb3c25a2909bce68cde596c", "html_url": "https://github.com/rust-lang/rust/commit/f3e9b38e26646a75fdb3c25a2909bce68cde596c"}, {"sha": "bb4bfae42294dea4c0f97f2cea42817110caa809", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb4bfae42294dea4c0f97f2cea42817110caa809", "html_url": "https://github.com/rust-lang/rust/commit/bb4bfae42294dea4c0f97f2cea42817110caa809"}], "stats": {"total": 168, "additions": 125, "deletions": 43}, "files": [{"sha": "f02e096350556f9de220ef9adea35fcbe3f5f606", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0ded8e734f0280e407f8e22f8c6895cb1dda69be/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ded8e734f0280e407f8e22f8c6895cb1dda69be/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=0ded8e734f0280e407f8e22f8c6895cb1dda69be", "patch": "@@ -7,16 +7,14 @@\n use std::{convert::TryInto, mem, sync::Arc};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n-use hir::{\n-    AsAssocItem, DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility,\n-};\n+use hir::{DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility};\n use once_cell::unsync::Lazy;\n use rustc_hash::FxHashMap;\n use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n \n use crate::{\n     defs::{Definition, NameClass, NameRefClass},\n-    traits::convert_to_def_in_trait,\n+    traits::{as_trait_assoc_def, convert_to_def_in_trait},\n     RootDatabase,\n };\n \n@@ -314,6 +312,7 @@ impl Definition {\n                 _ => None,\n             },\n             def: self,\n+            trait_assoc_def: as_trait_assoc_def(sema.db, self),\n             sema,\n             scope: None,\n             include_self_kw_refs: None,\n@@ -325,6 +324,8 @@ impl Definition {\n #[derive(Clone)]\n pub struct FindUsages<'a> {\n     def: Definition,\n+    /// If def is an assoc item from a trait or trait impl, this is the corresponding item of the trait definition\n+    trait_assoc_def: Option<Definition>,\n     sema: &'a Semantics<'a, RootDatabase>,\n     scope: Option<SearchScope>,\n     include_self_kw_refs: Option<hir::Type>,\n@@ -375,7 +376,7 @@ impl<'a> FindUsages<'a> {\n         let sema = self.sema;\n \n         let search_scope = {\n-            let base = self.def.search_scope(sema.db);\n+            let base = self.trait_assoc_def.unwrap_or(self.def).search_scope(sema.db);\n             match &self.scope {\n                 None => base,\n                 Some(scope) => base.intersection(scope),\n@@ -621,7 +622,13 @@ impl<'a> FindUsages<'a> {\n                 sink(file_id, reference)\n             }\n             Some(NameRefClass::Definition(def))\n-                if convert_to_def_in_trait(self.sema.db, def) == self.def =>\n+                if match self.trait_assoc_def {\n+                    Some(trait_assoc_def) => {\n+                        // we have a trait assoc item, so force resolve all assoc items to their trait version\n+                        convert_to_def_in_trait(self.sema.db, def) == trait_assoc_def\n+                    }\n+                    None => self.def == def,\n+                } =>\n             {\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = FileReference {\n@@ -711,30 +718,22 @@ impl<'a> FindUsages<'a> {\n                 }\n                 false\n             }\n-            // Resolve trait impl function definitions to the trait definition's version if self.def is the trait definition's\n             Some(NameClass::Definition(def)) if def != self.def => {\n-                /* poor man's try block */\n-                (|| {\n-                    let this_trait = self\n-                        .def\n-                        .as_assoc_item(self.sema.db)?\n-                        .containing_trait_or_trait_impl(self.sema.db)?;\n-                    let trait_ = def\n-                        .as_assoc_item(self.sema.db)?\n-                        .containing_trait_or_trait_impl(self.sema.db)?;\n-                    (trait_ == this_trait && self.def.name(self.sema.db) == def.name(self.sema.db))\n-                        .then(|| {\n-                            let FileRange { file_id, range } =\n-                                self.sema.original_range(name.syntax());\n-                            let reference = FileReference {\n-                                range,\n-                                name: ast::NameLike::Name(name.clone()),\n-                                category: None,\n-                            };\n-                            sink(file_id, reference)\n-                        })\n-                })()\n-                .unwrap_or(false)\n+                // if the def we are looking for is a trait (impl) assoc item, we'll have to resolve the items to trait definition assoc item\n+                if !matches!(\n+                    self.trait_assoc_def,\n+                    Some(trait_assoc_def)\n+                        if convert_to_def_in_trait(self.sema.db, def) == trait_assoc_def\n+                ) {\n+                    return false;\n+                }\n+                let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n+                let reference = FileReference {\n+                    range,\n+                    name: ast::NameLike::Name(name.clone()),\n+                    category: None,\n+                };\n+                sink(file_id, reference)\n             }\n             _ => false,\n         }"}, {"sha": "b607cdfee3813a67d9cb4402b87549384c08263d", "filename": "crates/ide-db/src/traits.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0ded8e734f0280e407f8e22f8c6895cb1dda69be/crates%2Fide-db%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ded8e734f0280e407f8e22f8c6895cb1dda69be/crates%2Fide-db%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Ftraits.rs?ref=0ded8e734f0280e407f8e22f8c6895cb1dda69be", "patch": "@@ -71,26 +71,44 @@ pub fn get_missing_assoc_items(\n \n /// Converts associated trait impl items to their trait definition counterpart\n pub(crate) fn convert_to_def_in_trait(db: &dyn HirDatabase, def: Definition) -> Definition {\n-    use hir::AssocItem::*;\n     (|| {\n         let assoc = def.as_assoc_item(db)?;\n         let trait_ = assoc.containing_trait_impl(db)?;\n-        let name = match assoc {\n-            Function(it) => it.name(db),\n-            Const(it) => it.name(db)?,\n-            TypeAlias(it) => it.name(db),\n-        };\n-        let item = trait_.items(db).into_iter().find(|it| match (it, assoc) {\n-            (Function(trait_func), Function(_)) => trait_func.name(db) == name,\n-            (Const(trait_konst), Const(_)) => trait_konst.name(db).map_or(false, |it| it == name),\n-            (TypeAlias(trait_type_alias), TypeAlias(_)) => trait_type_alias.name(db) == name,\n-            _ => false,\n-        })?;\n-        Some(Definition::from(item))\n+        assoc_item_of_trait(db, assoc, trait_)\n     })()\n     .unwrap_or(def)\n }\n \n+/// If this is an trait (impl) assoc item, returns the assoc item of the corresponding trait definition.\n+pub(crate) fn as_trait_assoc_def(db: &dyn HirDatabase, def: Definition) -> Option<Definition> {\n+    let assoc = def.as_assoc_item(db)?;\n+    let trait_ = match assoc.container(db) {\n+        hir::AssocItemContainer::Trait(_) => return Some(def),\n+        hir::AssocItemContainer::Impl(i) => i.trait_(db),\n+    }?;\n+    assoc_item_of_trait(db, assoc, trait_)\n+}\n+\n+fn assoc_item_of_trait(\n+    db: &dyn HirDatabase,\n+    assoc: hir::AssocItem,\n+    trait_: hir::Trait,\n+) -> Option<Definition> {\n+    use hir::AssocItem::*;\n+    let name = match assoc {\n+        Function(it) => it.name(db),\n+        Const(it) => it.name(db)?,\n+        TypeAlias(it) => it.name(db),\n+    };\n+    let item = trait_.items(db).into_iter().find(|it| match (it, assoc) {\n+        (Function(trait_func), Function(_)) => trait_func.name(db) == name,\n+        (Const(trait_konst), Const(_)) => trait_konst.name(db).map_or(false, |it| it == name),\n+        (TypeAlias(trait_type_alias), TypeAlias(_)) => trait_type_alias.name(db) == name,\n+        _ => false,\n+    })?;\n+    Some(Definition::from(item))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use base_db::{fixture::ChangeFixture, FilePosition};"}, {"sha": "9b4bfc41075522074eb322a79b566926bd0b125e", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0ded8e734f0280e407f8e22f8c6895cb1dda69be/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ded8e734f0280e407f8e22f8c6895cb1dda69be/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=0ded8e734f0280e407f8e22f8c6895cb1dda69be", "patch": "@@ -1307,6 +1307,70 @@ fn foo((\n   //^^^read\n     let foo;\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_trait_impl_methods() {\n+        check(\n+            r#\"\n+trait Trait {\n+    fn func$0(self) {}\n+     //^^^^\n+}\n+\n+impl Trait for () {\n+    fn func(self) {}\n+     //^^^^\n+}\n+\n+fn main() {\n+    <()>::func(());\n+        //^^^^\n+    ().func();\n+     //^^^^\n+}\n+\"#,\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    fn func(self) {}\n+     //^^^^\n+}\n+\n+impl Trait for () {\n+    fn func$0(self) {}\n+     //^^^^\n+}\n+\n+fn main() {\n+    <()>::func(());\n+        //^^^^\n+    ().func();\n+     //^^^^\n+}\n+\"#,\n+        );\n+        check(\n+            r#\"\n+trait Trait {\n+    fn func(self) {}\n+     //^^^^\n+}\n+\n+impl Trait for () {\n+    fn func(self) {}\n+     //^^^^\n+}\n+\n+fn main() {\n+    <()>::func(());\n+        //^^^^\n+    ().func$0();\n+     //^^^^\n+}\n \"#,\n         );\n     }"}, {"sha": "8a00d6f14413fb28e1df21400b0fb7c798aa6be8", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ded8e734f0280e407f8e22f8c6895cb1dda69be/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ded8e734f0280e407f8e22f8c6895cb1dda69be/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=0ded8e734f0280e407f8e22f8c6895cb1dda69be", "patch": "@@ -73,6 +73,7 @@ pub(crate) fn find_all_refs(\n             });\n             let mut usages =\n                 def.usages(sema).set_scope(search_scope.clone()).include_self_refs().all();\n+\n             if literal_search {\n                 retain_adt_literal_usages(&mut usages, def, sema);\n             }\n@@ -105,7 +106,7 @@ pub(crate) fn find_all_refs(\n         }\n         None => {\n             let search = make_searcher(false);\n-            Some(find_defs(sema, &syntax, position.offset)?.into_iter().map(search).collect())\n+            Some(find_defs(sema, &syntax, position.offset)?.map(search).collect())\n         }\n     }\n }"}]}