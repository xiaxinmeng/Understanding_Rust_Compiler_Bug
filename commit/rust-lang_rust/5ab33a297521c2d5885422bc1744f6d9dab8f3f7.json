{"sha": "5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYjMzYTI5NzUyMWMyZDU4ODU0MjJiYzE3NDRmNmQ5ZGFiOGYzZjc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-01T12:49:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-01T12:49:48Z"}, "message": "correct incorrect handling of overloaded operators, exposing various other bits of rot", "tree": {"sha": "7cfc8d31f53e598e33747835b17e81b19244e3c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cfc8d31f53e598e33747835b17e81b19244e3c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "html_url": "https://github.com/rust-lang/rust/commit/5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f236b850c0dc4c1b925e33d1173f359605801307", "url": "https://api.github.com/repos/rust-lang/rust/commits/f236b850c0dc4c1b925e33d1173f359605801307", "html_url": "https://github.com/rust-lang/rust/commit/f236b850c0dc4c1b925e33d1173f359605801307"}], "stats": {"total": 246, "additions": 117, "deletions": 129}, "files": [{"sha": "85e46a0feff6b4006be4decab64bb076cf9973d5", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "patch": "@@ -296,34 +296,34 @@ impl<T> Ord for *const T {\n \n // Equality for region pointers\n #[cfg(notest)]\n-impl<'self,T:Eq> Eq for &'self const T {\n+impl<'self,T:Eq> Eq for &'self T {\n     #[inline(always)]\n-    fn eq(&self, other: & &'self const T) -> bool {\n+    fn eq(&self, other: & &'self T) -> bool {\n         return *(*self) == *(*other);\n     }\n     #[inline(always)]\n-    fn ne(&self, other: & &'self const T) -> bool {\n+    fn ne(&self, other: & &'self T) -> bool {\n         return *(*self) != *(*other);\n     }\n }\n \n // Comparison for region pointers\n #[cfg(notest)]\n-impl<'self,T:Ord> Ord for &'self const T {\n+impl<'self,T:Ord> Ord for &'self T {\n     #[inline(always)]\n-    fn lt(&self, other: & &'self const T) -> bool {\n+    fn lt(&self, other: & &'self T) -> bool {\n         *(*self) < *(*other)\n     }\n     #[inline(always)]\n-    fn le(&self, other: & &'self const T) -> bool {\n+    fn le(&self, other: & &'self T) -> bool {\n         *(*self) <= *(*other)\n     }\n     #[inline(always)]\n-    fn ge(&self, other: & &'self const T) -> bool {\n+    fn ge(&self, other: & &'self T) -> bool {\n         *(*self) >= *(*other)\n     }\n     #[inline(always)]\n-    fn gt(&self, other: & &'self const T) -> bool {\n+    fn gt(&self, other: & &'self T) -> bool {\n         *(*self) > *(*other)\n     }\n }"}, {"sha": "ecdf260bffffa14545182aa5f9afb48d95b169f3", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 15, "deletions": 48, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "patch": "@@ -68,8 +68,7 @@ struct GatherLoanCtxt {\n     id_range: id_range,\n     all_loans: @mut ~[Loan],\n     item_ub: ast::node_id,\n-    repeating_ids: ~[ast::node_id],\n-    ignore_adjustments: HashSet<ast::node_id>\n+    repeating_ids: ~[ast::node_id]\n }\n \n pub fn gather_loans(bccx: @BorrowckCtxt,\n@@ -79,8 +78,7 @@ pub fn gather_loans(bccx: @BorrowckCtxt,\n         id_range: id_range::max(),\n         all_loans: @mut ~[],\n         item_ub: body.node.id,\n-        repeating_ids: ~[body.node.id],\n-        ignore_adjustments: HashSet::new()\n+        repeating_ids: ~[body.node.id]\n     };\n     let v = visit::mk_vt(@visit::Visitor {visit_expr: gather_loans_in_expr,\n                                           visit_block: gather_loans_in_block,\n@@ -147,13 +145,8 @@ fn gather_loans_in_expr(ex: @ast::expr,\n     self.id_range.add(ex.callee_id);\n \n     // If this expression is borrowed, have to ensure it remains valid:\n-    {\n-        let this = &mut *self; // FIXME(#5074)\n-        if !this.ignore_adjustments.contains(&ex.id) {\n-            for tcx.adjustments.find(&ex.id).each |&adjustments| {\n-                this.guarantee_adjustments(ex, *adjustments);\n-            }\n-        }\n+    for tcx.adjustments.find(&ex.id).each |&adjustments| {\n+        self.guarantee_adjustments(ex, *adjustments);\n     }\n \n     // Special checks for various kinds of expressions:\n@@ -178,46 +171,20 @@ fn gather_loans_in_expr(ex: @ast::expr,\n         visit::visit_expr(ex, self, vt);\n       }\n \n-      ast::expr_index(rcvr, _) |\n-      ast::expr_binary(_, rcvr, _) |\n-      ast::expr_unary(_, rcvr) |\n-      ast::expr_assign_op(_, rcvr, _)\n+      ast::expr_index(_, arg) |\n+      ast::expr_binary(_, _, arg)\n       if self.bccx.method_map.contains_key(&ex.id) => {\n-        // Receivers in method calls are always passed by ref.\n-        //\n-        // Here, in an overloaded operator, the call is this expression,\n-        // and hence the scope of the borrow is this call.\n-        //\n-        // FIX? / NOT REALLY---technically we should check the other\n-        // argument and consider the argument mode.  But how annoying.\n-        // And this problem when goes away when argument modes are\n-        // phased out.  So I elect to leave this undone.\n-        let scope_r = ty::re_scope(ex.id);\n-        let rcvr_cmt = self.bccx.cat_expr(rcvr);\n-        self.guarantee_valid(rcvr.id, rcvr.span, rcvr_cmt, m_imm, scope_r);\n-\n-        // FIXME (#3387): Total hack: Ignore adjustments for the left-hand\n-        // side. Their regions will be inferred to be too large.\n-        self.ignore_adjustments.insert(rcvr.id);\n-\n-        visit::visit_expr(ex, self, vt);\n+          // Arguments in method calls are always passed by ref.\n+          //\n+          // Currently these do not use adjustments, so we have to\n+          // hardcode this check here (note that the receiver DOES use\n+          // adjustments).\n+          let scope_r = ty::re_scope(ex.id);\n+          let arg_cmt = self.bccx.cat_expr(arg);\n+          self.guarantee_valid(arg.id, arg.span, arg_cmt, m_imm, scope_r);\n+          visit::visit_expr(ex, self, vt);\n       }\n \n-      // FIXME--#3387\n-      // ast::expr_binary(_, lhs, rhs) => {\n-      //     // Universal comparison operators like ==, >=, etc\n-      //     // take their arguments by reference.\n-      //     let lhs_ty = ty::expr_ty(self.tcx(), lhs);\n-      //     if !ty::type_is_scalar(lhs_ty) {\n-      //         let scope_r = ty::re_scope(ex.id);\n-      //         let lhs_cmt = self.bccx.cat_expr(lhs);\n-      //         self.guarantee_valid(lhs_cmt, m_imm, scope_r);\n-      //         let rhs_cmt = self.bccx.cat_expr(rhs);\n-      //         self.guarantee_valid(rhs_cmt, m_imm, scope_r);\n-      //     }\n-      //     visit::visit_expr(ex, self, vt);\n-      // }\n-\n       // see explanation attached to the `root_ub` field:\n       ast::expr_while(cond, ref body) => {\n           // during the condition, can only root for the condition"}, {"sha": "1b0a22752a592313a388f6527a8c5210da487c96", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "patch": "@@ -236,9 +236,16 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n     // overloaded.  See #3511.\n     let tcx = rcx.fcx.tcx();\n     match expr.node {\n+        // You'd think that x += y where `+=` is overloaded would be a\n+        // cleanup scope. You'd be... kind of right. In fact the\n+        // handling of `+=` and friends in trans for overloaded\n+        // operators is a hopeless mess and I can't figure out how to\n+        // represent it. - ndm\n+        //\n+        // ast::expr_assign_op(*) |\n+\n         ast::expr_index(*) |\n         ast::expr_binary(*) |\n-        ast::expr_assign_op(*) |\n         ast::expr_unary(*) if has_method_map => {\n             tcx.region_maps.record_cleanup_scope(expr.id);\n         }"}, {"sha": "98d7a01b928b071b688e45f631ebfd229b2291ba", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "patch": "@@ -598,8 +598,8 @@ mod tests {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();\n         do task::try || {\n-            do arc2.write_downgrade |write_mode| {\n-                do (&write_mode).write |one| {\n+            do arc2.write_downgrade |mut write_mode| {\n+                do write_mode.write |one| {\n                     assert!(*one == 2);\n                 }\n             }\n@@ -733,8 +733,8 @@ mod tests {\n         }\n \n         // Downgrader (us)\n-        do arc.write_downgrade |write_mode| {\n-            do (&write_mode).write_cond |state, cond| {\n+        do arc.write_downgrade |mut write_mode| {\n+            do write_mode.write_cond |state, cond| {\n                 wc1.send(()); // send to another writer who will wake us up\n                 while *state == 0 {\n                     cond.wait();"}, {"sha": "93364f8a319ee8ea979ec5be2ece8eac5e616a32", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "patch": "@@ -1256,22 +1256,24 @@ mod tests {\n         match (r) {\n           node::Empty => return ~\"\",\n           node::Content(x) => {\n-            let str = @mut ~\"\";\n-            fn aux(str: @mut ~str, node: @node::Node) {\n+            let mut str = ~\"\";\n+            fn aux(str: &mut ~str, node: @node::Node) {\n                 match (*node) {\n-                  node::Leaf(x) => {\n-                    *str += str::slice(\n-                        *x.content, x.byte_offset,\n-                        x.byte_offset + x.byte_len).to_owned();\n-                  }\n-                  node::Concat(ref x) => {\n-                    aux(str, x.left);\n-                    aux(str, x.right);\n-                  }\n+                    node::Leaf(x) => {\n+                        str::push_str(\n+                            str,\n+                            str::slice(\n+                                *x.content, x.byte_offset,\n+                                x.byte_offset + x.byte_len));\n+                    }\n+                    node::Concat(ref x) => {\n+                        aux(str, x.left);\n+                        aux(str, x.right);\n+                    }\n                 }\n             }\n-            aux(str, x);\n-            return *str\n+            aux(&mut str, x);\n+            return str\n           }\n         }\n     }"}, {"sha": "119b47c904e8eee201edc679283334e6df925784", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 52, "deletions": 45, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "patch": "@@ -22,12 +22,12 @@ type Le<'self, T> = &'self fn(v1: &T, v2: &T) -> bool;\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-pub fn merge_sort<T:Copy>(v: &const [T], le: Le<T>) -> ~[T] {\n+pub fn merge_sort<T:Copy>(v: &[T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n     return merge_sort_(v, (0u, len(v)), le);\n \n-    fn merge_sort_<T:Copy>(v: &const [T], slice: Slice, le: Le<T>)\n+    fn merge_sort_<T:Copy>(v: &[T], slice: Slice, le: Le<T>)\n         -> ~[T] {\n         let begin = slice.first();\n         let end = slice.second();\n@@ -179,7 +179,7 @@ fn qsort3<T:Copy + Ord + Eq>(arr: &mut [T], left: int, right: int) {\n  */\n pub fn quick_sort3<T:Copy + Ord + Eq>(arr: &mut [T]) {\n     if arr.len() <= 1 { return; }\n-    let len = arr.len() - 1; // FIXME(#5074) nested calls\n+    let len = arr.len(); // FIXME(#5074) nested calls\n     qsort3(arr, 0, (len - 1) as int);\n }\n \n@@ -263,7 +263,7 @@ fn binarysort<T:Copy + Ord>(array: &mut [T], start: uint) {\n         assert!(left == right);\n         let n = start-left;\n \n-        copy_vec(array, left+1, array, left, n);\n+        shift_vec(array, left+1, left, n);\n         array[left] = pivot;\n         start += 1;\n     }\n@@ -309,8 +309,8 @@ fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n     return run;\n }\n \n-fn gallop_left<T:Copy + Ord>(key: &const T,\n-                             array: &const [T],\n+fn gallop_left<T:Copy + Ord>(key: &T,\n+                             array: &[T],\n                              hint: uint)\n                           -> uint {\n     let size = array.len();\n@@ -360,8 +360,8 @@ fn gallop_left<T:Copy + Ord>(key: &const T,\n     return ofs;\n }\n \n-fn gallop_right<T:Copy + Ord>(key: &const T,\n-                              array: &const [T],\n+fn gallop_right<T:Copy + Ord>(key: &T,\n+                              array: &[T],\n                               hint: uint)\n                            -> uint {\n     let size = array.len();\n@@ -457,15 +457,15 @@ impl<T:Copy + Ord> MergeState<T> {\n         }\n \n         let k = { // constrain lifetime of slice below\n-            let slice = vec::mut_slice(array, b1, b1+l1);\n-            gallop_right(&const array[b2], slice, 0)\n+            let slice = vec::slice(array, b1, b1+l1);\n+            gallop_right(&array[b2], slice, 0)\n         };\n         b1 += k;\n         l1 -= k;\n         if l1 != 0 {\n             let l2 = { // constrain lifetime of slice below\n-                let slice = vec::mut_slice(array, b2, b2+l2);\n-                gallop_left(&const array[b1+l1-1],slice,l2-1)\n+                let slice = vec::slice(array, b2, b2+l2);\n+                gallop_left(&array[b1+l1-1],slice,l2-1)\n             };\n             if l2 > 0 {\n                 if l1 <= l2 {\n@@ -497,11 +497,11 @@ impl<T:Copy + Ord> MergeState<T> {\n         dest += 1; c2 += 1; len2 -= 1;\n \n         if len2 == 0 {\n-            copy_vec(array, dest, tmp, 0, len1);\n+            copy_vec(array, dest, tmp.slice(0, len1));\n             return;\n         }\n         if len1 == 1 {\n-            copy_vec(array, dest, array, c2, len2);\n+            shift_vec(array, dest, c2, len2);\n             array[dest+len2] <-> tmp[c1];\n             return;\n         }\n@@ -539,21 +539,25 @@ impl<T:Copy + Ord> MergeState<T> {\n             loop {\n                 assert!(len1 > 1 && len2 != 0);\n \n-                let tmp_view = vec::const_slice(tmp, c1, c1+len1);\n-                count1 = gallop_right(&const array[c2], tmp_view, 0);\n+                count1 = {\n+                    let tmp_view = vec::slice(tmp, c1, c1+len1);\n+                    gallop_right(&array[c2], tmp_view, 0)\n+                };\n                 if count1 != 0 {\n-                    copy_vec(array, dest, tmp, c1, count1);\n+                    copy_vec(array, dest, tmp.slice(c1, c1+count1));\n                     dest += count1; c1 += count1; len1 -= count1;\n                     if len1 <= 1 { break_outer = true; break; }\n                 }\n                 array[dest] <-> array[c2];\n                 dest += 1; c2 += 1; len2 -= 1;\n                 if len2 == 0 { break_outer = true; break; }\n \n-                let tmp_view = vec::const_slice(array, c2, c2+len2);\n-                count2 = gallop_left(&const tmp[c1], tmp_view, 0);\n+                count2 = {\n+                    let tmp_view = vec::slice(array, c2, c2+len2);\n+                    gallop_left(&tmp[c1], tmp_view, 0)\n+                };\n                 if count2 != 0 {\n-                    copy_vec(array, dest, array, c2, count2);\n+                    shift_vec(array, dest, c2, count2);\n                     dest += count2; c2 += count2; len2 -= count2;\n                     if len2 == 0 { break_outer = true; break; }\n                 }\n@@ -573,14 +577,14 @@ impl<T:Copy + Ord> MergeState<T> {\n \n         if len1 == 1 {\n             assert!(len2 > 0);\n-            copy_vec(array, dest, array, c2, len2);\n+            shift_vec(array, dest, c2, len2);\n             array[dest+len2] <-> tmp[c1];\n         } else if len1 == 0 {\n             fail!(~\"Comparison violates its contract!\");\n         } else {\n             assert!(len2 == 0);\n             assert!(len1 > 1);\n-            copy_vec(array, dest, tmp, c1, len1);\n+            copy_vec(array, dest, tmp.slice(c1, c1+len1));\n         }\n     }\n \n@@ -603,13 +607,13 @@ impl<T:Copy + Ord> MergeState<T> {\n         dest -= 1; c1 -= 1; len1 -= 1;\n \n         if len1 == 0 {\n-            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n+            copy_vec(array, dest-(len2-1), tmp.slice(0, len2));\n             return;\n         }\n         if len2 == 1 {\n             dest -= len1;\n             c1 -= len1;\n-            copy_vec(array, dest+1, array, c1+1, len1);\n+            shift_vec(array, dest+1, c1+1, len1);\n             array[dest] <-> tmp[c2];\n             return;\n         }\n@@ -650,12 +654,12 @@ impl<T:Copy + Ord> MergeState<T> {\n                 { // constrain scope of tmp_view:\n                     let tmp_view = vec::mut_slice (array, base1, base1+len1);\n                     count1 = len1 - gallop_right(\n-                        &const tmp[c2], tmp_view, len1-1);\n+                        &tmp[c2], tmp_view, len1-1);\n                 }\n \n                 if count1 != 0 {\n                     dest -= count1; c1 -= count1; len1 -= count1;\n-                    copy_vec(array, dest+1, array, c1+1, count1);\n+                    shift_vec(array, dest+1, c1+1, count1);\n                     if len1 == 0 { break_outer = true; break; }\n                 }\n \n@@ -666,14 +670,14 @@ impl<T:Copy + Ord> MergeState<T> {\n                 let count2;\n                 { // constrain scope of tmp_view\n                     let tmp_view = vec::mut_slice(tmp, 0, len2);\n-                    count2 = len2 - gallop_left(&const array[c1],\n+                    count2 = len2 - gallop_left(&array[c1],\n                                                 tmp_view,\n                                                 len2-1);\n                 }\n \n                 if count2 != 0 {\n                     dest -= count2; c2 -= count2; len2 -= count2;\n-                    copy_vec(array, dest+1, tmp, c2+1, count2);\n+                    copy_vec(array, dest+1, tmp.slice(c2+1, c2+1+count2));\n                     if len2 <= 1 { break_outer = true; break; }\n                 }\n                 array[dest] <-> array[c1];\n@@ -695,14 +699,14 @@ impl<T:Copy + Ord> MergeState<T> {\n             assert!(len1 > 0);\n             dest -= len1;\n             c1 -= len1;\n-            copy_vec(array, dest+1, array, c1+1, len1);\n+            shift_vec(array, dest+1, c1+1, len1);\n             array[dest] <-> tmp[c2];\n         } else if len2 == 0 {\n             fail!(~\"Comparison violates its contract!\");\n         } else {\n             assert!(len1 == 0);\n             assert!(len2 != 0);\n-            copy_vec(array, dest-(len2-1), tmp, 0, len2);\n+            copy_vec(array, dest-(len2-1), tmp.slice(0, len2));\n         }\n     }\n \n@@ -738,21 +742,25 @@ impl<T:Copy + Ord> MergeState<T> {\n #[inline(always)]\n fn copy_vec<T:Copy>(dest: &mut [T],\n                     s1: uint,\n-                    from: &const [T],\n-                    s2: uint,\n-                    len: uint) {\n-    assert!(s1+len <= dest.len() && s2+len <= from.len());\n-\n-    let mut slice = ~[];\n-    for uint::range(s2, s2+len) |i| {\n-        slice.push(from[i]);\n-    }\n+                    from: &[T]) {\n+    assert!(s1+from.len() <= dest.len());\n \n-    for slice.eachi |i, v| {\n+    for from.eachi |i, v| {\n         dest[s1+i] = *v;\n     }\n }\n \n+#[inline(always)]\n+fn shift_vec<T:Copy>(dest: &mut [T],\n+                     s1: uint,\n+                     s2: uint,\n+                     len: uint) {\n+    assert!(s1+len <= dest.len());\n+\n+    let tmp = dest.slice(s2, s2+len).to_vec();\n+    copy_vec(dest, s1, tmp);\n+}\n+\n #[cfg(test)]\n mod test_qsort3 {\n     use sort::*;\n@@ -764,8 +772,7 @@ mod test_qsort3 {\n         quick_sort3::<int>(v1);\n         let mut i = 0;\n         while i < len {\n-            // debug!(v2[i]);\n-            assert!((v2[i] == v1[i]));\n+            assert_eq!(v2[i], v1[i]);\n             i += 1;\n         }\n     }\n@@ -1036,7 +1043,7 @@ mod big_tests {\n         tabulate_managed(low, high);\n     }\n \n-    fn multiplyVec<T:Copy>(arr: &const [T], num: uint) -> ~[T] {\n+    fn multiplyVec<T:Copy>(arr: &[T], num: uint) -> ~[T] {\n         let size = arr.len();\n         let res = do vec::from_fn(num) |i| {\n             arr[i % size]\n@@ -1052,7 +1059,7 @@ mod big_tests {\n     }\n \n     fn tabulate_unique(lo: uint, hi: uint) {\n-        fn isSorted<T:Ord>(arr: &const [T]) {\n+        fn isSorted<T:Ord>(arr: &[T]) {\n             for uint::range(0, arr.len()-1) |i| {\n                 if arr[i] > arr[i+1] {\n                     fail!(~\"Array not sorted\");\n@@ -1123,7 +1130,7 @@ mod big_tests {\n     }\n \n     fn tabulate_managed(lo: uint, hi: uint) {\n-        fn isSorted<T:Ord>(arr: &const [@T]) {\n+        fn isSorted<T:Ord>(arr: &[@T]) {\n             for uint::range(0, arr.len()-1) |i| {\n                 if arr[i] > arr[i+1] {\n                     fail!(~\"Array not sorted\");"}, {"sha": "9d1ddb8ec544baab9f4866c1d539c937c1fe8cd0", "filename": "src/libstd/std.rc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "patch": "@@ -69,7 +69,14 @@ pub mod list;\n pub mod priority_queue;\n pub mod rope;\n pub mod smallintmap;\n+\n+#[cfg(stage0)]\n+#[path=\"sort_stage0.rs\"]\n+pub mod sort;\n+\n+#[cfg(not(stage0))]\n pub mod sort;\n+\n pub mod dlist;\n pub mod treemap;\n "}, {"sha": "0361213af222612e9f70b8e77b725d7e4c6e57e2", "filename": "src/test/compile-fail/borrowck-loan-in-overloaded-op.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-in-overloaded-op.rs?ref=5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "patch": "@@ -8,18 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test #3387\n-\n struct foo(~uint);\n \n impl Add<foo, foo> for foo {\n-    fn add(f: &foo) -> foo {\n-        foo(~(**self + **(*f)))\n+    fn add(&self, f: &foo) -> foo {\n+        foo(~(***self + **(*f)))\n     }\n }\n \n fn main() {\n     let x = foo(~3);\n-    let _y = x + x;\n-    //~^ ERROR moving out of immutable local variable prohibited due to outstanding loan\n+    let _y = x + {x}; // the `{x}` forces a move to occur\n+    //~^ ERROR cannot move out of `x`\n }"}, {"sha": "07629651e560546f32850a0a703b571501eb99d8", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab33a297521c2d5885422bc1744f6d9dab8f3f7/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=5ab33a297521c2d5885422bc1744f6d9dab8f3f7", "patch": "@@ -17,13 +17,13 @@ trait MyIter {\n }\n \n impl<'self> MyIter for &'self [int] {\n-    fn test_imm(&self) { assert!(self[0] == 1) }\n-    fn test_const(&const self) { assert!(self[0] == 1) }\n+    fn test_imm(&self) { assert_eq!(self[0], 1) }\n+    fn test_const(&const self) { assert_eq!(self[0], 1) }\n }\n \n impl<'self> MyIter for &'self str {\n-    fn test_imm(&self) { assert!(*self == \"test\") }\n-    fn test_const(&const self) { assert!(*self == \"test\") }\n+    fn test_imm(&self) { assert_eq!(*self, \"test\") }\n+    fn test_const(&const self) { assert_eq!(self[0], 't') }\n }\n \n pub fn main() {"}]}