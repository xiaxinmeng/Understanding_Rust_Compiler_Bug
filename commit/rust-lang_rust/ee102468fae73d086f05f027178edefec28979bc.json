{"sha": "ee102468fae73d086f05f027178edefec28979bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMTAyNDY4ZmFlNzNkMDg2ZjA1ZjAyNzE3OGVkZWZlYzI4OTc5YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-09T08:22:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-09T08:22:35Z"}, "message": "auto merge of #7614 : MarkJr94/rust/smallintmap_enum, r=huonw\n\nAdded external iterators as well as tests to SmallIntMap and SmallIntSet. Fixes #7366", "tree": {"sha": "3e587e5087f46ed5c5a02f6a43954491d1a4da65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e587e5087f46ed5c5a02f6a43954491d1a4da65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee102468fae73d086f05f027178edefec28979bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee102468fae73d086f05f027178edefec28979bc", "html_url": "https://github.com/rust-lang/rust/commit/ee102468fae73d086f05f027178edefec28979bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee102468fae73d086f05f027178edefec28979bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac026e2e6948760380ab013e9dc82fc86ad92edc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac026e2e6948760380ab013e9dc82fc86ad92edc", "html_url": "https://github.com/rust-lang/rust/commit/ac026e2e6948760380ab013e9dc82fc86ad92edc"}, {"sha": "6f479a67285041183e57bfb28a5d41d25f20ee2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f479a67285041183e57bfb28a5d41d25f20ee2a", "html_url": "https://github.com/rust-lang/rust/commit/6f479a67285041183e57bfb28a5d41d25f20ee2a"}], "stats": {"total": 287, "additions": 287, "deletions": 0}, "files": [{"sha": "d952374ee5ccce39f95c045654e01e314f12dde8", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/ee102468fae73d086f05f027178edefec28979bc/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee102468fae73d086f05f027178edefec28979bc/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=ee102468fae73d086f05f027178edefec28979bc", "patch": "@@ -18,8 +18,10 @@\n \n use std::cmp;\n use std::container::{Container, Mutable, Map, Set};\n+use std::iterator::{Iterator,IteratorUtil,ZipIterator,Counter};\n use std::uint;\n use std::util::replace;\n+use std::vec::{VecIterator,VecMutIterator,VecRevIterator,VecMutRevIterator};\n \n #[allow(missing_doc)]\n pub struct SmallIntMap<T> {\n@@ -168,6 +170,40 @@ impl<V> SmallIntMap<V> {\n     pub fn get<'a>(&'a self, key: &uint) -> &'a V {\n         self.find(key).expect(\"key not present\")\n     }\n+\n+    /// An iterator visiting all key-value pairs in ascending order by the keys.\n+    /// Iterator element type is (uint, &'r V)\n+    pub fn iter<'r>(&'r self) -> SmallIntMapIterator<'r, V> {\n+        SmallIntMapIterator {\n+            iter: Counter::new(0,1).zip(self.v.iter())\n+        }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in ascending order by the keys,\n+    /// with mutable references to the values\n+    /// Iterator element type is (uint, &'r mut V)\n+    pub fn mut_iter<'r>(&'r mut self) -> SmallIntMapMutIterator<'r, V> {\n+        SmallIntMapMutIterator {\n+            iter: Counter::new(0,1).zip(self.v.mut_iter())\n+        }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in descending order by the keys.\n+    /// Iterator element type is (uint, &'r V)\n+    pub fn rev_iter<'r>(&'r self) -> SmallIntMapRevIterator<'r, V> {\n+        SmallIntMapRevIterator {\n+            iter: Counter::new(self.len() as int - 1, -1).zip(self.v.rev_iter())\n+        }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in descending order by the keys,\n+    /// with mutable references to the values\n+    /// Iterator element type is (uint, &'r mut V)\n+    pub fn mut_rev_iter<'r>(&'r mut self) -> SmallIntMapMutRevIterator <'r, V> {\n+        SmallIntMapMutRevIterator {\n+            iter: Counter::new(self.len() as int - 1, -1).zip(self.v.mut_rev_iter())\n+        }\n+    }\n }\n \n impl<V:Copy> SmallIntMap<V> {\n@@ -186,6 +222,95 @@ impl<V:Copy> SmallIntMap<V> {\n     }\n }\n \n+\n+macro_rules! iterator {\n+    /* FIXME: #4375 Cannot attach documentation/attributes to a macro generated struct.\n+    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n+        pub struct $name<'self, T> {\n+            priv ptr: $ptr,\n+            priv end: $ptr,\n+            priv lifetime: $elem // FIXME: #5922\n+        }\n+    };*/\n+    (impl $name:ident -> $elem:ty) => {\n+        impl<'self, T> Iterator<(uint, $elem)> for $name<'self, T> {\n+            #[inline]\n+            pub fn next(&mut self) -> Option<(uint, $elem)> {\n+                for self.iter.advance |(idx, elem)| {\n+                    match elem {\n+                        &None => {}\n+                        &Some(ref e) => { return Some((idx as uint, e)) }\n+                    }\n+                }\n+\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! mut_iterator {\n+    /* FIXME: #4375 Cannot attach documentation/attributes to a macro generated struct.\n+    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n+        pub struct $name<'self, T> {\n+            priv ptr: $ptr,\n+            priv end: $ptr,\n+            priv lifetime: $elem // FIXME: #5922\n+        }\n+    };*/\n+    (impl $name:ident -> $elem:ty) => {\n+        impl<'self, T> Iterator<(uint, $elem)> for $name<'self, T> {\n+            #[inline]\n+            pub fn next(&mut self) -> Option<(uint, $elem)> {\n+                for self.iter.advance |(idx, elem)| {\n+                    match elem {\n+                        &None => {}\n+                        &Some(ref mut e) => { return Some((idx as uint, e)) }\n+                    }\n+                }\n+\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+pub struct SmallIntMapIterator<'self, T> {\n+    priv iter: ZipIterator<int,\n+                           Counter<int>,\n+                           &'self Option<T>,\n+                           VecIterator<'self, Option<T> > >\n+}\n+\n+iterator!{impl SmallIntMapIterator -> &'self T}\n+\n+pub struct SmallIntMapMutIterator<'self, T> {\n+    priv iter: ZipIterator<int,\n+                           Counter<int>,\n+                           &'self mut Option<T>,\n+                           VecMutIterator<'self, Option<T> > >\n+}\n+\n+mut_iterator!{impl SmallIntMapMutIterator -> &'self mut T}\n+\n+pub struct SmallIntMapRevIterator<'self, T> {\n+    priv iter: ZipIterator<int,\n+                           Counter<int>,\n+                           &'self Option<T>,\n+                           VecRevIterator<'self, Option<T> > >\n+}\n+\n+iterator!{impl SmallIntMapRevIterator -> &'self T}\n+\n+pub struct SmallIntMapMutRevIterator<'self, T> {\n+    priv iter: ZipIterator<int,\n+                           Counter<int>,\n+                           &'self mut Option<T>,\n+                           VecMutRevIterator<'self, Option<T> > >\n+}\n+\n+mut_iterator!{impl SmallIntMapMutRevIterator -> &'self mut T}\n+\n /// A set implemented on top of the SmallIntMap type. This set is always a set\n /// of integers, and the space requirements are on the order of the highest\n /// valued integer in the set.\n@@ -281,8 +406,57 @@ impl SmallIntSet {\n \n     /// Visit all values in order\n     pub fn each(&self, f: &fn(&uint) -> bool) -> bool { self.map.each_key(f) }\n+\n+    /// An iterator visiting all set members in ascending order.\n+    /// Iterator element type is uint\n+    pub fn iter<'r>(&'r self) -> SmallIntSetIterator<'r> {\n+        SmallIntSetIterator {\n+            iter: self.map.iter()\n+        }\n+    }\n+\n+    /// An iterator visiting all set members in descending order.\n+    /// Iterator element type is uint\n+    pub fn rev_iter<'r>(&'r mut self) -> SmallIntSetRevIterator<'r> {\n+        SmallIntSetRevIterator {\n+            iter: self.map.rev_iter()\n+        }\n+    }\n+\n+}\n+\n+pub struct SmallIntSetIterator<'self> {\n+    priv iter: SmallIntMapIterator<'self, ()>\n+}\n+\n+pub struct SmallIntSetRevIterator<'self> {\n+    priv iter: SmallIntMapRevIterator<'self,()>\n+}\n+\n+impl<'self> Iterator<uint> for SmallIntSetIterator<'self> {\n+    #[inline]\n+    pub fn next(&mut self) -> Option<uint> {\n+        let next_opt = self.iter.next();\n+        match next_opt {\n+            None => { None }\n+            Some((idx, _)) => { Some(idx) }\n+        }\n+    }\n }\n \n+impl<'self> Iterator<uint> for SmallIntSetRevIterator<'self> {\n+    #[inline]\n+    pub fn next(&mut self) -> Option<uint> {\n+        let next_opt = self.iter.next();\n+        match next_opt {\n+            None => { None }\n+            Some((idx, _)) => { Some(idx) }\n+        }\n+    }\n+}\n+\n+\n+\n #[cfg(test)]\n mod tests {\n \n@@ -375,6 +549,82 @@ mod tests {\n         assert_eq!(m.pop(&1), Some(2));\n         assert_eq!(m.pop(&1), None);\n     }\n+\n+    #[test]\n+    fn test_iterator() {\n+        let mut a = SmallIntMap::new();\n+\n+        assert!(a.insert(0,1));\n+        assert!(a.insert(1,2));\n+        assert!(a.insert(2,5));\n+        assert!(a.insert(3,10));\n+        assert!(a.insert(4,11));\n+\n+        let mut it = a.iter();\n+        assert_eq!(it.next().unwrap(), (0, &1));\n+        assert_eq!(it.next().unwrap(), (1, &2));\n+        assert_eq!(it.next().unwrap(), (2, &5));\n+        assert_eq!(it.next().unwrap(), (3, &10));\n+        assert_eq!(it.next().unwrap(), (4, &11));\n+        assert!(it.next().is_none());\n+    }\n+\n+    #[test]\n+    fn test_mut_iterator() {\n+        let mut a = SmallIntMap::new();\n+\n+        assert!(a.insert(0,1));\n+        assert!(a.insert(1,1));\n+        assert!(a.insert(2,1));\n+        assert!(a.insert(3,1));\n+        assert!(a.insert(4,1));\n+\n+        for a.mut_iter().advance |(_,v)| {\n+            *v += 1;\n+        }\n+\n+       assert!(a.iter().all(|(_,v)| *v == 2));\n+    }\n+\n+    #[test]\n+    fn test_rev_iterator() {\n+       let mut a = SmallIntMap::new();\n+\n+        assert!(a.insert(0,1));\n+        assert!(a.insert(1,2));\n+        assert!(a.insert(2,5));\n+        assert!(a.insert(3,10));\n+        assert!(a.insert(4,11));\n+\n+        let mut b = SmallIntMap::new();\n+\n+        assert!(b.insert(0,11));\n+        assert!(b.insert(1,10));\n+        assert!(b.insert(2,5));\n+        assert!(b.insert(3,2));\n+        assert!(b.insert(4,1));\n+\n+        let (a_it, b_it) = (a.iter(), b.rev_iter());\n+\n+        assert!(a_it.zip(b_it).all(|( (_ ,v1), (_, v2) )| *v1 == *v2));\n+    }\n+\n+    #[test]\n+    fn test_mut_rev_iterator() {\n+        let mut a = SmallIntMap::new();\n+\n+        assert!(a.insert(0,5));\n+        assert!(a.insert(1,4));\n+        assert!(a.insert(2,3));\n+        assert!(a.insert(3,2));\n+        assert!(a.insert(4,1));\n+\n+        for a.mut_rev_iter().advance |(i,v)| {\n+            *v += i as int;\n+        }\n+\n+        assert!(a.iter().all(|(_,v)| *v == 5 ));\n+    }\n }\n \n #[cfg(test)]\n@@ -535,4 +785,41 @@ mod test_set {\n         }\n         assert_eq!(i, expected.len());\n     }\n+\n+    #[test]\n+    fn test_iterator() {\n+        let mut a = SmallIntSet::new();\n+\n+        assert!(a.insert(0));\n+        assert!(a.insert(1));\n+        assert!(a.insert(2));\n+        assert!(a.insert(3));\n+        assert!(a.insert(4));\n+\n+        let mut it = a.iter();\n+        assert_eq!(it.next().unwrap(), 0);\n+        assert_eq!(it.next().unwrap(), 1);\n+        assert_eq!(it.next().unwrap(), 2);\n+        assert_eq!(it.next().unwrap(), 3);\n+        assert_eq!(it.next().unwrap(), 4);\n+        assert!(it.next().is_none());\n+    }\n+\n+    #[test]\n+    fn test_rev_iterator() {\n+       let mut a = SmallIntSet::new();\n+\n+        assert!(a.insert(0));\n+        assert!(a.insert(1));\n+        assert!(a.insert(2));\n+        assert!(a.insert(3));\n+        assert!(a.insert(4));\n+\n+        let a_it = a.rev_iter();\n+\n+        assert!(do a_it.enumerate().all |( i, v2 )| {\n+            i + v2 == 4\n+        });\n+    }\n+\n }"}]}