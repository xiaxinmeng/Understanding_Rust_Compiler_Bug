{"sha": "8e404f49282d7ca8c68769c4d074dc0909e2c06e", "node_id": "C_kwDOAAsO6NoAKDhlNDA0ZjQ5MjgyZDdjYThjNjg3NjljNGQwNzRkYzA5MDllMmMwNmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-09T11:52:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-09T11:52:22Z"}, "message": "Auto merge of #14291 - HKalbasi:master, r=HKalbasi\n\nfix multiple definition binding in match to let-else\n\nfix #14290", "tree": {"sha": "f520de85c63078c3f43b941a427c0a130b54d62f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f520de85c63078c3f43b941a427c0a130b54d62f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e404f49282d7ca8c68769c4d074dc0909e2c06e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e404f49282d7ca8c68769c4d074dc0909e2c06e", "html_url": "https://github.com/rust-lang/rust/commit/8e404f49282d7ca8c68769c4d074dc0909e2c06e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e404f49282d7ca8c68769c4d074dc0909e2c06e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38e9a110d4f136c22cb4eed9c3581d7992eade56", "url": "https://api.github.com/repos/rust-lang/rust/commits/38e9a110d4f136c22cb4eed9c3581d7992eade56", "html_url": "https://github.com/rust-lang/rust/commit/38e9a110d4f136c22cb4eed9c3581d7992eade56"}, {"sha": "811190b913f906f1a993a5ffee4ff1a9be889183", "url": "https://api.github.com/repos/rust-lang/rust/commits/811190b913f906f1a993a5ffee4ff1a9be889183", "html_url": "https://github.com/rust-lang/rust/commit/811190b913f906f1a993a5ffee4ff1a9be889183"}], "stats": {"total": 85, "additions": 63, "deletions": 22}, "files": [{"sha": "7f2c01772baefa8861c9e055415feee02186ee27", "filename": "crates/ide-assists/src/handlers/convert_match_to_let_else.rs", "status": "modified", "additions": 63, "deletions": 22, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8e404f49282d7ca8c68769c4d074dc0909e2c06e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e404f49282d7ca8c68769c4d074dc0909e2c06e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs?ref=8e404f49282d7ca8c68769c4d074dc0909e2c06e", "patch": "@@ -1,6 +1,6 @@\n use ide_db::defs::{Definition, NameRefClass};\n use syntax::{\n-    ast::{self, HasName},\n+    ast::{self, HasName, Name},\n     ted, AstNode, SyntaxNode,\n };\n \n@@ -48,15 +48,15 @@ pub(crate) fn convert_match_to_let_else(acc: &mut Assists, ctx: &AssistContext<'\n         other => format!(\"{{ {other} }}\"),\n     };\n     let extracting_arm_pat = extracting_arm.pat()?;\n-    let extracted_variable = find_extracted_variable(ctx, &extracting_arm)?;\n+    let extracted_variable_positions = find_extracted_variable(ctx, &extracting_arm)?;\n \n     acc.add(\n         AssistId(\"convert_match_to_let_else\", AssistKind::RefactorRewrite),\n         \"Convert match to let-else\",\n         let_stmt.syntax().text_range(),\n         |builder| {\n             let extracting_arm_pat =\n-                rename_variable(&extracting_arm_pat, extracted_variable, binding);\n+                rename_variable(&extracting_arm_pat, &extracted_variable_positions, binding);\n             builder.replace(\n                 let_stmt.syntax().text_range(),\n                 format!(\"let {extracting_arm_pat} = {initializer_expr} else {diverging_arm_expr};\"),\n@@ -95,14 +95,15 @@ fn find_arms(\n }\n \n // Given an extracting arm, find the extracted variable.\n-fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Option<ast::Name> {\n+fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Option<Vec<Name>> {\n     match arm.expr()? {\n         ast::Expr::PathExpr(path) => {\n             let name_ref = path.syntax().descendants().find_map(ast::NameRef::cast)?;\n             match NameRefClass::classify(&ctx.sema, &name_ref)? {\n                 NameRefClass::Definition(Definition::Local(local)) => {\n-                    let source = local.primary_source(ctx.db()).into_ident_pat()?;\n-                    Some(source.name()?)\n+                    let source =\n+                        local.sources(ctx.db()).into_iter().map(|x| x.into_ident_pat()?.name());\n+                    source.collect()\n                 }\n                 _ => None,\n             }\n@@ -115,27 +116,34 @@ fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Opti\n }\n \n // Rename `extracted` with `binding` in `pat`.\n-fn rename_variable(pat: &ast::Pat, extracted: ast::Name, binding: ast::Pat) -> SyntaxNode {\n+fn rename_variable(pat: &ast::Pat, extracted: &[Name], binding: ast::Pat) -> SyntaxNode {\n     let syntax = pat.syntax().clone_for_update();\n-    let extracted_syntax = syntax.covering_element(extracted.syntax().text_range());\n-\n-    // If `extracted` variable is a record field, we should rename it to `binding`,\n-    // otherwise we just need to replace `extracted` with `binding`.\n-\n-    if let Some(record_pat_field) = extracted_syntax.ancestors().find_map(ast::RecordPatField::cast)\n-    {\n-        if let Some(name_ref) = record_pat_field.field_name() {\n-            ted::replace(\n-                record_pat_field.syntax(),\n-                ast::make::record_pat_field(ast::make::name_ref(&name_ref.text()), binding)\n+    let extracted = extracted\n+        .iter()\n+        .map(|e| syntax.covering_element(e.syntax().text_range()))\n+        .collect::<Vec<_>>();\n+    for extracted_syntax in extracted {\n+        // If `extracted` variable is a record field, we should rename it to `binding`,\n+        // otherwise we just need to replace `extracted` with `binding`.\n+\n+        if let Some(record_pat_field) =\n+            extracted_syntax.ancestors().find_map(ast::RecordPatField::cast)\n+        {\n+            if let Some(name_ref) = record_pat_field.field_name() {\n+                ted::replace(\n+                    record_pat_field.syntax(),\n+                    ast::make::record_pat_field(\n+                        ast::make::name_ref(&name_ref.text()),\n+                        binding.clone(),\n+                    )\n                     .syntax()\n                     .clone_for_update(),\n-            );\n+                );\n+            }\n+        } else {\n+            ted::replace(extracted_syntax, binding.clone().syntax().clone_for_update());\n         }\n-    } else {\n-        ted::replace(extracted_syntax, binding.syntax().clone_for_update());\n     }\n-\n     syntax\n }\n \n@@ -162,6 +170,39 @@ fn foo(opt: Option<()>) {\n         );\n     }\n \n+    #[test]\n+    fn or_pattern_multiple_binding() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+enum Foo {\n+    A(u32),\n+    B(u32),\n+    C(String),\n+}\n+\n+fn foo(opt: Option<Foo>) -> Result<u32, ()> {\n+    let va$0lue = match opt {\n+        Some(Foo::A(it) | Foo::B(it)) => it,\n+        _ => return Err(()),\n+    };\n+}\n+    \"#,\n+            r#\"\n+enum Foo {\n+    A(u32),\n+    B(u32),\n+    C(String),\n+}\n+\n+fn foo(opt: Option<Foo>) -> Result<u32, ()> {\n+    let Some(Foo::A(value) | Foo::B(value)) = opt else { return Err(()) };\n+}\n+    \"#,\n+        );\n+    }\n+\n     #[test]\n     fn should_not_be_applicable_if_extracting_arm_is_not_an_identity_expr() {\n         cov_mark::check_count!(extracting_arm_is_not_an_identity_expr, 2);"}]}