{"sha": "c02fa89007e47b4e99764e6f5bef7a7c3262139a", "node_id": "C_kwDOAAsO6NoAKGMwMmZhODkwMDdlNDdiNGU5OTc2NGU2ZjViZWY3YTdjMzI2MjEzOWE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-10T08:59:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-11-10T10:38:50Z"}, "message": "Merge from rustc", "tree": {"sha": "56e87adda0210ae585691eb2c6e3f1feb63affcf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56e87adda0210ae585691eb2c6e3f1feb63affcf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c02fa89007e47b4e99764e6f5bef7a7c3262139a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c02fa89007e47b4e99764e6f5bef7a7c3262139a", "html_url": "https://github.com/rust-lang/rust/commit/c02fa89007e47b4e99764e6f5bef7a7c3262139a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c02fa89007e47b4e99764e6f5bef7a7c3262139a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71c3ecf31f1adf920d2cfd577392b8a45ac9c808", "url": "https://api.github.com/repos/rust-lang/rust/commits/71c3ecf31f1adf920d2cfd577392b8a45ac9c808", "html_url": "https://github.com/rust-lang/rust/commit/71c3ecf31f1adf920d2cfd577392b8a45ac9c808"}, {"sha": "df2adc4760a1c03096ab4b39512ba90b983c2332", "url": "https://api.github.com/repos/rust-lang/rust/commits/df2adc4760a1c03096ab4b39512ba90b983c2332", "html_url": "https://github.com/rust-lang/rust/commit/df2adc4760a1c03096ab4b39512ba90b983c2332"}], "stats": {"total": 12878, "additions": 8439, "deletions": 4439}, "files": [{"sha": "ddacf9cf0246344ab05728a2312191d5d8092342", "filename": "Cargo.lock", "status": "modified", "additions": 67, "deletions": 94, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -4,41 +4,26 @@ version = 3\n \n [[package]]\n name = \"addr2line\"\n-version = \"0.16.0\"\n+version = \"0.17.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3e61f2b7f93d2c7d2b08263acaa4a363b3e276806c68af6134c44f523bf1aacd\"\n+checksum = \"b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b\"\n dependencies = [\n  \"compiler_builtins\",\n- \"gimli 0.25.0\",\n+ \"gimli\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n-[[package]]\n-name = \"addr2line\"\n-version = \"0.17.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b\"\n-dependencies = [\n- \"gimli 0.26.1\",\n-]\n-\n [[package]]\n name = \"adler\"\n-version = \"0.2.3\"\n+version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee2a4ec343196209d6594e19543ae87a39f96d5534d7174822a3ad825dd6ed7e\"\n+checksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n ]\n \n-[[package]]\n-name = \"adler\"\n-version = \"1.0.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f26201604c87b1e01bd3d98f8d5d9a8fcbb815e8cedb41ffccbeb4bf593a35fe\"\n-\n [[package]]\n name = \"ahash\"\n version = \"0.7.4\"\n@@ -185,12 +170,12 @@ version = \"0.3.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cab84319d616cfb654d03394f38ab7e6f0919e181b1b57e1fd15e7fb4077d9a7\"\n dependencies = [\n- \"addr2line 0.17.0\",\n+ \"addr2line\",\n  \"cc\",\n  \"cfg-if 1.0.0\",\n  \"libc\",\n- \"miniz_oxide 0.5.3\",\n- \"object 0.29.0\",\n+ \"miniz_oxide\",\n+ \"object\",\n  \"rustc-demangle\",\n ]\n \n@@ -1295,15 +1280,15 @@ checksum = \"37ab347416e802de484e4d03c7316c48f1ecb56574dfd4a46a80f173ce1de04d\"\n \n [[package]]\n name = \"flate2\"\n-version = \"1.0.16\"\n+version = \"1.0.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"68c90b0fc46cf89d227cc78b40e494ff81287a92dd07631e5af0d06fe3cf885e\"\n+checksum = \"b39522e96686d38f4bc984b9198e3a0613264abaebaff2c5c918bfa6b6da09af\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"crc32fast\",\n  \"libc\",\n  \"libz-sys\",\n- \"miniz_oxide 0.4.0\",\n+ \"miniz_oxide\",\n ]\n \n [[package]]\n@@ -1545,25 +1530,17 @@ dependencies = [\n  \"wasi 0.9.0+wasi-snapshot-preview1\",\n ]\n \n-[[package]]\n-name = \"gimli\"\n-version = \"0.25.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f0a01e0497841a3b2db4f8afa483cce65f7e96a3498bd6c541734792aeac8fe7\"\n-dependencies = [\n- \"compiler_builtins\",\n- \"rustc-std-workspace-alloc\",\n- \"rustc-std-workspace-core\",\n-]\n-\n [[package]]\n name = \"gimli\"\n version = \"0.26.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"78cc372d058dcf6d5ecd98510e7fbc9e5aec4d21de70f65fea8fecebcd881bd4\"\n dependencies = [\n+ \"compiler_builtins\",\n  \"fallible-iterator\",\n  \"indexmap\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n  \"stable_deref_trait\",\n ]\n \n@@ -2228,25 +2205,16 @@ checksum = \"68354c5c6bd36d73ff3feceb05efa59b6acb7626617f4962be322a825e61f79a\"\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.4.0\"\n+version = \"0.5.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"be0f75932c1f6cfae3c04000e40114adf955636e19040f9c0a2c380702aa1c7f\"\n+checksum = \"6f5c75688da582b8ffc1f1799e9db273f32133c49e048f614d22ec3256773ccc\"\n dependencies = [\n- \"adler 0.2.3\",\n+ \"adler\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n-[[package]]\n-name = \"miniz_oxide\"\n-version = \"0.5.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6f5c75688da582b8ffc1f1799e9db273f32133c49e048f614d22ec3256773ccc\"\n-dependencies = [\n- \"adler 1.0.2\",\n-]\n-\n [[package]]\n name = \"miow\"\n version = \"0.3.7\"\n@@ -2346,29 +2314,20 @@ dependencies = [\n  \"libc\",\n ]\n \n-[[package]]\n-name = \"object\"\n-version = \"0.26.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"39f37e50073ccad23b6d09bcb5b263f4e76d3bb6038e4a3c08e52162ffa8abc2\"\n-dependencies = [\n- \"compiler_builtins\",\n- \"memchr\",\n- \"rustc-std-workspace-alloc\",\n- \"rustc-std-workspace-core\",\n-]\n-\n [[package]]\n name = \"object\"\n version = \"0.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n dependencies = [\n+ \"compiler_builtins\",\n  \"crc32fast\",\n  \"flate2\",\n  \"hashbrown\",\n  \"indexmap\",\n  \"memchr\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n@@ -2522,7 +2481,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3742b2c103b9f06bc9fff0a37ff4912935851bee6d36f3c02bcc755bcfec228f\"\n dependencies = [\n  \"lock_api\",\n- \"parking_lot_core 0.9.3\",\n+ \"parking_lot_core 0.9.4\",\n ]\n \n [[package]]\n@@ -2541,15 +2500,15 @@ dependencies = [\n \n [[package]]\n name = \"parking_lot_core\"\n-version = \"0.9.3\"\n+version = \"0.9.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09a279cbf25cb0757810394fbc1e359949b59e348145c643a939a525692e6929\"\n+checksum = \"4dc9e0dc2adc1c69d09143aff38d3d30c5c3f0df0dad82e6d25547af174ebec0\"\n dependencies = [\n  \"cfg-if 1.0.0\",\n  \"libc\",\n  \"redox_syscall\",\n  \"smallvec\",\n- \"windows-sys 0.36.1\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -2774,9 +2733,9 @@ dependencies = [\n \n [[package]]\n name = \"psm\"\n-version = \"0.1.16\"\n+version = \"0.1.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cd136ff4382c4753fc061cb9e4712ab2af263376b95bbd5bd8cd50c020b78e69\"\n+checksum = \"5787f7cda34e3033a72192c018bc5883100330f362ef279a8cbccfce8bb4e874\"\n dependencies = [\n  \"cc\",\n ]\n@@ -3305,7 +3264,7 @@ dependencies = [\n  \"cstr\",\n  \"libc\",\n  \"measureme\",\n- \"object 0.29.0\",\n+ \"object\",\n  \"rustc-demangle\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3339,7 +3298,7 @@ dependencies = [\n  \"itertools\",\n  \"jobserver\",\n  \"libc\",\n- \"object 0.29.0\",\n+ \"object\",\n  \"pathdiff\",\n  \"regex\",\n  \"rustc_arena\",\n@@ -4677,9 +4636,9 @@ checksum = \"a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3\"\n \n [[package]]\n name = \"stacker\"\n-version = \"0.1.14\"\n+version = \"0.1.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"90939d5171a4420b3ff5fbc8954d641e7377335454c259dcb80786f3f21dc9b4\"\n+checksum = \"c886bd4480155fd3ef527d45e9ac8dd7118a898a46530b7b94c3e21866259fce\"\n dependencies = [\n  \"cc\",\n  \"cfg-if 1.0.0\",\n@@ -4698,7 +4657,7 @@ checksum = \"a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f\"\n name = \"std\"\n version = \"0.0.0\"\n dependencies = [\n- \"addr2line 0.16.0\",\n+ \"addr2line\",\n  \"alloc\",\n  \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n@@ -4708,8 +4667,8 @@ dependencies = [\n  \"hashbrown\",\n  \"hermit-abi 0.2.6\",\n  \"libc\",\n- \"miniz_oxide 0.4.0\",\n- \"object 0.26.2\",\n+ \"miniz_oxide\",\n+ \"object\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n@@ -4926,9 +4885,9 @@ version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e6cb0c7868d7f90407531108ab03263d9452a8811b7cdd87675343a40d4aa254\"\n dependencies = [\n- \"gimli 0.26.1\",\n+ \"gimli\",\n  \"hashbrown\",\n- \"object 0.29.0\",\n+ \"object\",\n  \"tracing\",\n ]\n \n@@ -5499,17 +5458,25 @@ dependencies = [\n \n [[package]]\n name = \"windows-sys\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n+checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n dependencies = [\n- \"windows_aarch64_msvc 0.36.1\",\n- \"windows_i686_gnu 0.36.1\",\n- \"windows_i686_msvc 0.36.1\",\n- \"windows_x86_64_gnu 0.36.1\",\n- \"windows_x86_64_msvc 0.36.1\",\n+ \"windows_aarch64_gnullvm\",\n+ \"windows_aarch64_msvc 0.42.0\",\n+ \"windows_i686_gnu 0.42.0\",\n+ \"windows_i686_msvc 0.42.0\",\n+ \"windows_x86_64_gnu 0.42.0\",\n+ \"windows_x86_64_gnullvm\",\n+ \"windows_x86_64_msvc 0.42.0\",\n ]\n \n+[[package]]\n+name = \"windows_aarch64_gnullvm\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n+\n [[package]]\n name = \"windows_aarch64_msvc\"\n version = \"0.28.0\"\n@@ -5518,9 +5485,9 @@ checksum = \"52695a41e536859d5308cc613b4a022261a274390b25bd29dfff4bf08505f3c2\"\n \n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n+checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n@@ -5530,9 +5497,9 @@ checksum = \"f54725ac23affef038fecb177de6c9bf065787c2f432f79e3c373da92f3e1d8a\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n+checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n@@ -5542,9 +5509,9 @@ checksum = \"51d5158a43cc43623c0729d1ad6647e62fa384a3d135fd15108d37c683461f64\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n+checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n@@ -5554,9 +5521,15 @@ checksum = \"bc31f409f565611535130cfe7ee8e6655d3fa99c1c61013981e491921b5ce954\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnullvm\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n+checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n@@ -5566,9 +5539,9 @@ checksum = \"3f2b8c7cbd3bfdddd9ab98769f9746a7fad1bca236554cd032b78d768bc0e89f\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.36.1\"\n+version = \"0.42.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\"\n+checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\"\n \n [[package]]\n name = \"xattr\""}, {"sha": "8f342175f7d37133f67b288b672b1eaa9e3bfaec", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -2,12 +2,9 @@\n \n use crate::ast::{self, Lit, LitKind};\n use crate::token::{self, Token};\n-\n-use rustc_lexer::unescape::{unescape_byte, unescape_char};\n-use rustc_lexer::unescape::{unescape_byte_literal, unescape_literal, Mode};\n+use rustc_lexer::unescape::{byte_from_char, unescape_byte, unescape_char, unescape_literal, Mode};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n-\n use std::ascii;\n \n pub enum LitError {\n@@ -109,13 +106,11 @@ impl LitKind {\n                 let s = symbol.as_str();\n                 let mut buf = Vec::with_capacity(s.len());\n                 let mut error = Ok(());\n-                unescape_byte_literal(&s, Mode::ByteStr, &mut |_, unescaped_byte| {\n-                    match unescaped_byte {\n-                        Ok(c) => buf.push(c),\n-                        Err(err) => {\n-                            if err.is_fatal() {\n-                                error = Err(LitError::LexerError);\n-                            }\n+                unescape_literal(&s, Mode::ByteStr, &mut |_, c| match c {\n+                    Ok(c) => buf.push(byte_from_char(c)),\n+                    Err(err) => {\n+                        if err.is_fatal() {\n+                            error = Err(LitError::LexerError);\n                         }\n                     }\n                 });\n@@ -127,13 +122,11 @@ impl LitKind {\n                 let bytes = if s.contains('\\r') {\n                     let mut buf = Vec::with_capacity(s.len());\n                     let mut error = Ok(());\n-                    unescape_byte_literal(&s, Mode::RawByteStr, &mut |_, unescaped_byte| {\n-                        match unescaped_byte {\n-                            Ok(c) => buf.push(c),\n-                            Err(err) => {\n-                                if err.is_fatal() {\n-                                    error = Err(LitError::LexerError);\n-                                }\n+                    unescape_literal(&s, Mode::RawByteStr, &mut |_, c| match c {\n+                        Ok(c) => buf.push(byte_from_char(c)),\n+                        Err(err) => {\n+                            if err.is_fatal() {\n+                                error = Err(LitError::LexerError);\n                             }\n                         }\n                     });"}, {"sha": "385f153174c3c2a9170b7b41957d67682efe0e17", "filename": "compiler/rustc_borrowck/src/constraints/graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -163,6 +163,7 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Edges<'s, 'tcx, D> {\n                 span: DUMMY_SP,\n                 category: ConstraintCategory::Internal,\n                 variance_info: VarianceDiagInfo::default(),\n+                from_closure: false,\n             })\n         } else {\n             None"}, {"sha": "9d9c4abb0aa57c460961d9dca8b8478dafbd9f0c", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -96,6 +96,9 @@ pub struct OutlivesConstraint<'tcx> {\n \n     /// Variance diagnostic information\n     pub variance_info: VarianceDiagInfo<'tcx>,\n+\n+    /// If this constraint is promoted from closure requirements.\n+    pub from_closure: bool,\n }\n \n impl<'tcx> fmt::Debug for OutlivesConstraint<'tcx> {"}, {"sha": "897a161f78563cbca11919475f651a1ce72a00f9", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -158,6 +158,7 @@ trait TypeOpInfo<'tcx> {\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>>;\n \n+    #[instrument(level = \"debug\", skip(self, mbcx))]\n     fn report_error(\n         &self,\n         mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n@@ -167,6 +168,7 @@ trait TypeOpInfo<'tcx> {\n     ) {\n         let tcx = mbcx.infcx.tcx;\n         let base_universe = self.base_universe();\n+        debug!(?base_universe);\n \n         let Some(adjusted_universe) =\n             placeholder.universe.as_u32().checked_sub(base_universe.as_u32())\n@@ -389,6 +391,7 @@ fn try_extract_error_from_fulfill_cx<'tcx>(\n     )\n }\n \n+#[instrument(level = \"debug\", skip(infcx, region_var_origin, universe_of_region))]\n fn try_extract_error_from_region_constraints<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     placeholder_region: ty::Region<'tcx>,"}, {"sha": "86cae5d09b5aa3941dc8b81e9ed772530e5cd5ea", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -724,13 +724,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             borrow_span,\n             &self.describe_any_place(borrow.borrowed_place.as_ref()),\n         );\n-\n-        borrow_spans.var_span_label(\n+        borrow_spans.var_subdiag(\n             &mut err,\n-            {\n+            |var_span| {\n+                use crate::session_diagnostics::CaptureVarCause::*;\n                 let place = &borrow.borrowed_place;\n                 let desc_place = self.describe_any_place(place.as_ref());\n-                format!(\"borrow occurs due to use of {}{}\", desc_place, borrow_spans.describe())\n+                match borrow_spans {\n+                    UseSpans::ClosureUse { generator_kind, .. } => match generator_kind {\n+                        Some(_) => BorrowUsePlaceGenerator { place: desc_place, var_span },\n+                        None => BorrowUsePlaceClosure { place: desc_place, var_span },\n+                    },\n+                    _ => BorrowUsePlace { place: desc_place, var_span },\n+                }\n             },\n             \"mutable\",\n         );\n@@ -1551,7 +1557,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         let mut err = self.temporary_value_borrowed_for_too_long(proper_span);\n-        err.span_label(proper_span, \"creates a temporary which is freed while still in use\");\n+        err.span_label(proper_span, \"creates a temporary value which is freed while still in use\");\n         err.span_label(drop_span, \"temporary value is freed at the end of this statement\");\n \n         match explanation {"}, {"sha": "61518378e3d0c7b0b738d73ef57367fb58e2ff9f", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -623,6 +623,26 @@ impl UseSpans<'_> {\n         }\n     }\n \n+    /// Add a subdiagnostic to the use of the captured variable, if it exists.\n+    pub(super) fn var_subdiag(\n+        self,\n+        err: &mut Diagnostic,\n+        f: impl Fn(Span) -> crate::session_diagnostics::CaptureVarCause,\n+        kind_desc: impl Into<String>,\n+    ) {\n+        if let UseSpans::ClosureUse { capture_kind_span, path_span, .. } = self {\n+            if capture_kind_span == path_span {\n+                err.subdiagnostic(f(capture_kind_span));\n+            } else {\n+                err.subdiagnostic(crate::session_diagnostics::CaptureVarKind {\n+                    kind_desc: kind_desc.into(),\n+                    kind_span: capture_kind_span,\n+                });\n+                err.subdiagnostic(f(path_span));\n+            }\n+        }\n+    }\n+\n     /// Returns `false` if this place is not used in a closure.\n     pub(super) fn for_closure(&self) -> bool {\n         match *self {"}, {"sha": "76f249dac5181439f4a437402e0d0aa68a38eb0a", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -2,7 +2,7 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n //! Error reporting machinery for lifetime errors.\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     // Try to convert the lower-bound region into something named we can print for the user.\n                     let lower_bound_region = self.to_error_region(type_test.lower_bound);\n \n-                    let type_test_span = type_test.locations.span(&self.body);\n+                    let type_test_span = type_test.span;\n \n                     if let Some(lower_bound_region) = lower_bound_region {\n                         let generic_ty = type_test.generic_kind.to_ty(self.infcx.tcx);\n@@ -276,7 +276,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     fn get_impl_ident_and_self_ty_from_trait(\n         &self,\n         def_id: DefId,\n-        trait_objects: &FxHashSet<DefId>,\n+        trait_objects: &FxIndexSet<DefId>,\n     ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n         let tcx = self.infcx.tcx;\n         match tcx.hir().get_if_local(def_id) {\n@@ -830,7 +830,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n         debug!(?param);\n \n-        let mut visitor = TraitObjectVisitor(FxHashSet::default());\n+        let mut visitor = TraitObjectVisitor(FxIndexSet::default());\n         visitor.visit_ty(param.param_ty);\n \n         let Some((ident, self_ty)) =\n@@ -843,7 +843,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     fn suggest_constrain_dyn_trait_in_impl(\n         &self,\n         err: &mut Diagnostic,\n-        found_dids: &FxHashSet<DefId>,\n+        found_dids: &FxIndexSet<DefId>,\n         ident: Ident,\n         self_ty: &hir::Ty<'_>,\n     ) -> bool {"}, {"sha": "f9741bacd17028bf46d0d7f04a9c61f7b8feca6a", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -355,7 +355,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     })\n                 }\n \n-                ty::BoundRegionKind::BrAnon(_) => None,\n+                ty::BoundRegionKind::BrAnon(..) => None,\n             },\n \n             ty::ReLateBound(..) | ty::ReVar(..) | ty::RePlaceholder(..) | ty::ReErased => None,"}, {"sha": "4a4887f19702f91149c053108308eaf0333c77d0", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -18,6 +18,7 @@ extern crate tracing;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n+use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n@@ -129,6 +130,19 @@ fn mir_borrowck<'tcx>(\n ) -> &'tcx BorrowCheckResult<'tcx> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n+\n+    if input_body.borrow().should_skip() {\n+        debug!(\"Skipping borrowck because of injected body\");\n+        // Let's make up a borrowck result! Fun times!\n+        let result = BorrowCheckResult {\n+            concrete_opaque_types: VecMap::new(),\n+            closure_requirements: None,\n+            used_mut_upvars: SmallVec::new(),\n+            tainted_by_errors: None,\n+        };\n+        return tcx.arena.alloc(result);\n+    }\n+\n     let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n \n     let infcx ="}, {"sha": "4e0205f8d43a14616d40ebb23361979b907bbd8f", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -242,7 +242,6 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n         mut liveness_constraints,\n         outlives_constraints,\n         member_constraints,\n-        closure_bounds_mapping,\n         universe_causes,\n         type_tests,\n     } = constraints;\n@@ -264,7 +263,6 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n         universal_region_relations,\n         outlives_constraints,\n         member_constraints,\n-        closure_bounds_mapping,\n         universe_causes,\n         type_tests,\n         liveness_constraints,"}, {"sha": "cc9450999525a9550be1ebdc942ec12270cdc0cd", "filename": "compiler/rustc_borrowck/src/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fdump_mir.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -74,8 +74,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n         constraints.sort_by_key(|c| (c.sup, c.sub));\n         for constraint in &constraints {\n-            let OutlivesConstraint { sup, sub, locations, category, span, variance_info: _ } =\n-                constraint;\n+            let OutlivesConstraint { sup, sub, locations, category, span, .. } = constraint;\n             let (name, arg) = match locations {\n                 Locations::All(span) => {\n                     (\"All\", tcx.sess.source_map().span_to_embeddable_string(*span))"}, {"sha": "94e9e05e5d640936be66ffb5bec23018b3d0a82f", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 17, "deletions": 145, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -6,10 +6,9 @@ use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_hir::CRATE_HIR_ID;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n@@ -19,9 +18,7 @@ use rustc_middle::mir::{\n };\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::traits::ObligationCauseCode;\n-use rustc_middle::ty::{\n-    self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable, TypeVisitable,\n-};\n+use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n use rustc_span::Span;\n \n use crate::{\n@@ -89,10 +86,6 @@ pub struct RegionInferenceContext<'tcx> {\n     /// `member_region_scc`.\n     member_constraints_applied: Vec<AppliedMemberConstraint>,\n \n-    /// Map closure bounds to a `Span` that should be used for error reporting.\n-    closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n-\n     /// Map universe indexes to information on why we created it.\n     universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n@@ -221,8 +214,8 @@ pub struct TypeTest<'tcx> {\n     /// The region `'x` that the type must outlive.\n     pub lower_bound: RegionVid,\n \n-    /// Where did this constraint arise and why?\n-    pub locations: Locations,\n+    /// The span to blame.\n+    pub span: Span,\n \n     /// A test which, if met by the region `'x`, proves that this type\n     /// constraint is satisfied.\n@@ -265,10 +258,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n         outlives_constraints: OutlivesConstraintSet<'tcx>,\n         member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n-        closure_bounds_mapping: FxHashMap<\n-            Location,\n-            FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>,\n-        >,\n         universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n         type_tests: Vec<TypeTest<'tcx>>,\n         liveness_constraints: LivenessValues<RegionVid>,\n@@ -310,7 +299,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             rev_scc_graph: None,\n             member_constraints,\n             member_constraints_applied: Vec::new(),\n-            closure_bounds_mapping,\n             universe_causes,\n             scc_universes,\n             scc_representatives,\n@@ -882,13 +870,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if deduplicate_errors.insert((\n                 erased_generic_kind,\n                 type_test.lower_bound,\n-                type_test.locations,\n+                type_test.span,\n             )) {\n                 debug!(\n                     \"check_type_test: reporting error for erased_generic_kind={:?}, \\\n                      lower_bound_region={:?}, \\\n-                     type_test.locations={:?}\",\n-                    erased_generic_kind, type_test.lower_bound, type_test.locations,\n+                     type_test.span={:?}\",\n+                    erased_generic_kind, type_test.lower_bound, type_test.span,\n                 );\n \n                 errors_buffer.push(RegionErrorKind::TypeTestError { type_test: type_test.clone() });\n@@ -931,7 +919,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> bool {\n         let tcx = infcx.tcx;\n \n-        let TypeTest { generic_kind, lower_bound, locations, verify_bound: _ } = type_test;\n+        let TypeTest { generic_kind, lower_bound, span: _, verify_bound: _ } = type_test;\n \n         let generic_ty = generic_kind.to_ty(tcx);\n         let Some(subject) = self.try_promote_type_test_subject(infcx, generic_ty) else {\n@@ -959,7 +947,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n                 subject,\n                 outlived_free_region: static_r,\n-                blame_span: locations.span(body),\n+                blame_span: type_test.span,\n                 category: ConstraintCategory::Boring,\n             });\n \n@@ -1011,7 +999,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 let requirement = ClosureOutlivesRequirement {\n                     subject,\n                     outlived_free_region: upper_bound,\n-                    blame_span: locations.span(body),\n+                    blame_span: type_test.span,\n                     category: ConstraintCategory::Boring,\n                 };\n                 debug!(\"try_promote_type_test: pushing {:#?}\", requirement);\n@@ -1804,18 +1792,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    pub(crate) fn retrieve_closure_constraint_info(\n-        &self,\n-        constraint: OutlivesConstraint<'tcx>,\n-    ) -> Option<(ConstraintCategory<'tcx>, Span)> {\n-        match constraint.locations {\n-            Locations::All(_) => None,\n-            Locations::Single(loc) => {\n-                self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub)).copied()\n-            }\n-        }\n-    }\n-\n     /// Finds a good `ObligationCause` to blame for the fact that `fr1` outlives `fr2`.\n     pub(crate) fn find_outlives_blame_span(\n         &self,\n@@ -1921,6 +1897,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     span: p_c.definition_span,\n                     category: ConstraintCategory::OpaqueType,\n                     variance_info: ty::VarianceDiagInfo::default(),\n+                    from_closure: false,\n                 };\n                 handle_constraint(constraint);\n             }\n@@ -2066,31 +2043,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Classify each of the constraints along the path.\n         let mut categorized_path: Vec<BlameConstraint<'tcx>> = path\n             .iter()\n-            .map(|constraint| {\n-                let (category, span, from_closure, cause_code) =\n-                    if constraint.category == ConstraintCategory::ClosureBounds {\n-                        if let Some((category, span)) =\n-                            self.retrieve_closure_constraint_info(*constraint)\n-                        {\n-                            (category, span, true, ObligationCauseCode::MiscObligation)\n-                        } else {\n-                            (\n-                                constraint.category,\n-                                constraint.span,\n-                                false,\n-                                ObligationCauseCode::MiscObligation,\n-                            )\n-                        }\n-                    } else {\n-                        (constraint.category, constraint.span, false, cause_code.clone())\n-                    };\n-                BlameConstraint {\n-                    category,\n-                    from_closure,\n-                    cause: ObligationCause::new(span, CRATE_HIR_ID, cause_code),\n-                    variance_info: constraint.variance_info,\n-                    outlives_constraint: *constraint,\n-                }\n+            .map(|constraint| BlameConstraint {\n+                category: constraint.category,\n+                from_closure: constraint.from_closure,\n+                cause: ObligationCause::new(constraint.span, CRATE_HIR_ID, cause_code.clone()),\n+                variance_info: constraint.variance_info,\n+                outlives_constraint: *constraint,\n             })\n             .collect();\n         debug!(\"categorized_path={:#?}\", categorized_path);\n@@ -2274,92 +2232,6 @@ impl<'tcx> RegionDefinition<'tcx> {\n     }\n }\n \n-pub trait ClosureRegionRequirementsExt<'tcx> {\n-    fn apply_requirements(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        closure_def_id: DefId,\n-        closure_substs: SubstsRef<'tcx>,\n-    ) -> Vec<QueryOutlivesConstraint<'tcx>>;\n-}\n-\n-impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx> {\n-    /// Given an instance T of the closure type, this method\n-    /// instantiates the \"extra\" requirements that we computed for the\n-    /// closure into the inference context. This has the effect of\n-    /// adding new outlives obligations to existing variables.\n-    ///\n-    /// As described on `ClosureRegionRequirements`, the extra\n-    /// requirements are expressed in terms of regionvids that index\n-    /// into the free regions that appear on the closure type. So, to\n-    /// do this, we first copy those regions out from the type T into\n-    /// a vector. Then we can just index into that vector to extract\n-    /// out the corresponding region from T and apply the\n-    /// requirements.\n-    fn apply_requirements(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        closure_def_id: DefId,\n-        closure_substs: SubstsRef<'tcx>,\n-    ) -> Vec<QueryOutlivesConstraint<'tcx>> {\n-        debug!(\n-            \"apply_requirements(closure_def_id={:?}, closure_substs={:?})\",\n-            closure_def_id, closure_substs\n-        );\n-\n-        // Extract the values of the free regions in `closure_substs`\n-        // into a vector.  These are the regions that we will be\n-        // relating to one another.\n-        let closure_mapping = &UniversalRegions::closure_mapping(\n-            tcx,\n-            closure_substs,\n-            self.num_external_vids,\n-            closure_def_id.expect_local(),\n-        );\n-        debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n-\n-        // Create the predicates.\n-        self.outlives_requirements\n-            .iter()\n-            .map(|outlives_requirement| {\n-                let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n-\n-                match outlives_requirement.subject {\n-                    ClosureOutlivesSubject::Region(region) => {\n-                        let region = closure_mapping[region];\n-                        debug!(\n-                            \"apply_requirements: region={:?} \\\n-                             outlived_region={:?} \\\n-                             outlives_requirement={:?}\",\n-                            region, outlived_region, outlives_requirement,\n-                        );\n-                        (\n-                            ty::Binder::dummy(ty::OutlivesPredicate(\n-                                region.into(),\n-                                outlived_region,\n-                            )),\n-                            ConstraintCategory::BoringNoLocation,\n-                        )\n-                    }\n-\n-                    ClosureOutlivesSubject::Ty(ty) => {\n-                        debug!(\n-                            \"apply_requirements: ty={:?} \\\n-                             outlived_region={:?} \\\n-                             outlives_requirement={:?}\",\n-                            ty, outlived_region, outlives_requirement,\n-                        );\n-                        (\n-                            ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), outlived_region)),\n-                            ConstraintCategory::BoringNoLocation,\n-                        )\n-                    }\n-                }\n-            })\n-            .collect()\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub struct BlameConstraint<'tcx> {\n     pub category: ConstraintCategory<'tcx>,"}, {"sha": "dd222485daf2c01b3188ff5abaa564065fa69246", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -299,8 +299,8 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         if errors.is_empty() {\n             definition_ty\n         } else {\n-            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n-            self.tcx.ty_error()\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+            self.tcx.ty_error_with_guaranteed(reported)\n         }\n     }\n }"}, {"sha": "824f20a31bb097463e8ef1a55927ed5b3e81d711", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -148,3 +148,33 @@ pub(crate) enum RequireStaticErr {\n         multi_span: MultiSpan,\n     },\n }\n+\n+#[derive(Subdiagnostic)]\n+#[label(borrowck_capture_kind_label)]\n+pub(crate) struct CaptureVarKind {\n+    pub kind_desc: String,\n+    #[primary_span]\n+    pub kind_span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureVarCause {\n+    #[label(borrowck_var_borrow_by_use_place)]\n+    BorrowUsePlace {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_borrow_by_use_place_in_generator)]\n+    BorrowUsePlaceGenerator {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_borrow_by_use_place_in_closure)]\n+    BorrowUsePlaceClosure {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+}"}, {"sha": "ce7f857e27310aa64b01f6d2529c08cd96ff00de", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,10 +1,10 @@\n-use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n+use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc_infer::infer::region_constraints::{GenericKind, VerifyBound};\n use rustc_infer::infer::{self, InferCtxt, SubregionOrigin};\n-use rustc_middle::mir::ConstraintCategory;\n+use rustc_middle::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, ConstraintCategory};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, TyCtxt};\n@@ -38,6 +38,7 @@ pub(crate) struct ConstraintConversion<'a, 'tcx> {\n     locations: Locations,\n     span: Span,\n     category: ConstraintCategory<'tcx>,\n+    from_closure: bool,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n }\n \n@@ -64,6 +65,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             span,\n             category,\n             constraints,\n+            from_closure: false,\n         }\n     }\n \n@@ -81,30 +83,70 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n         self.constraints.member_constraints = tmp;\n \n-        for query_constraint in outlives {\n-            self.convert(query_constraint);\n+        for (predicate, constraint_category) in outlives {\n+            // At the moment, we never generate any \"higher-ranked\"\n+            // region constraints like `for<'a> 'a: 'b`. At some point\n+            // when we move to universes, we will, and this assertion\n+            // will start to fail.\n+            let predicate = predicate.no_bound_vars().unwrap_or_else(|| {\n+                bug!(\"query_constraint {:?} contained bound vars\", predicate,);\n+            });\n+\n+            self.convert(predicate, *constraint_category);\n         }\n     }\n \n-    fn convert(&mut self, query_constraint: &QueryOutlivesConstraint<'tcx>) {\n+    /// Given an instance of the closure type, this method instantiates the \"extra\" requirements\n+    /// that we computed for the closure. This has the effect of adding new outlives obligations\n+    /// to existing region variables in `closure_substs`.\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub fn apply_closure_requirements(\n+        &mut self,\n+        closure_requirements: &ClosureRegionRequirements<'tcx>,\n+        closure_def_id: DefId,\n+        closure_substs: ty::SubstsRef<'tcx>,\n+    ) {\n+        // Extract the values of the free regions in `closure_substs`\n+        // into a vector.  These are the regions that we will be\n+        // relating to one another.\n+        let closure_mapping = &UniversalRegions::closure_mapping(\n+            self.tcx,\n+            closure_substs,\n+            closure_requirements.num_external_vids,\n+            closure_def_id.expect_local(),\n+        );\n+        debug!(?closure_mapping);\n+\n+        // Create the predicates.\n+        let backup = (self.category, self.span, self.from_closure);\n+        self.from_closure = true;\n+        for outlives_requirement in &closure_requirements.outlives_requirements {\n+            let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n+            let subject = match outlives_requirement.subject {\n+                ClosureOutlivesSubject::Region(re) => closure_mapping[re].into(),\n+                ClosureOutlivesSubject::Ty(ty) => ty.into(),\n+            };\n+\n+            self.category = outlives_requirement.category;\n+            self.span = outlives_requirement.blame_span;\n+            self.convert(ty::OutlivesPredicate(subject, outlived_region), self.category);\n+        }\n+        (self.category, self.span, self.from_closure) = backup;\n+    }\n+\n+    fn convert(\n+        &mut self,\n+        predicate: ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>,\n+        constraint_category: ConstraintCategory<'tcx>,\n+    ) {\n         debug!(\"generate: constraints at: {:#?}\", self.locations);\n \n         // Extract out various useful fields we'll need below.\n         let ConstraintConversion {\n             tcx, region_bound_pairs, implicit_region_bound, param_env, ..\n         } = *self;\n \n-        // At the moment, we never generate any \"higher-ranked\"\n-        // region constraints like `for<'a> 'a: 'b`. At some point\n-        // when we move to universes, we will, and this assertion\n-        // will start to fail.\n-        let ty::OutlivesPredicate(k1, r2) =\n-            query_constraint.0.no_bound_vars().unwrap_or_else(|| {\n-                bug!(\"query_constraint {:?} contained bound vars\", query_constraint,);\n-            });\n-\n-        let constraint_category = query_constraint.1;\n-\n+        let ty::OutlivesPredicate(k1, r2) = predicate;\n         match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n                 let r1_vid = self.to_region_vid(r1);\n@@ -127,10 +169,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n                 .type_must_outlive(origin, t1, r2, constraint_category);\n             }\n \n-            GenericArgKind::Const(_) => {\n-                // Consts cannot outlive one another, so we\n-                // don't need to handle any relations here.\n-            }\n+            GenericArgKind::Const(_) => unreachable!(),\n         }\n     }\n \n@@ -160,7 +199,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         verify_bound: VerifyBound<'tcx>,\n     ) -> TypeTest<'tcx> {\n         let lower_bound = self.to_region_vid(region);\n-        TypeTest { generic_kind, lower_bound, locations: self.locations, verify_bound }\n+        TypeTest { generic_kind, lower_bound, span: self.span, verify_bound }\n     }\n \n     fn to_region_vid(&mut self, r: ty::Region<'tcx>) -> ty::RegionVid {\n@@ -188,6 +227,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             sub,\n             sup,\n             variance_info: ty::VarianceDiagInfo::default(),\n+            from_closure: self.from_closure,\n         });\n     }\n "}, {"sha": "14cfc3613bf0c890357dc20e8e4d4db2846f41aa", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -247,12 +247,13 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                     .and(type_op::normalize::Normalize::new(ty))\n                     .fully_perform(self.infcx)\n                     .unwrap_or_else(|_| {\n-                        self.infcx\n+                        let reported = self\n+                            .infcx\n                             .tcx\n                             .sess\n                             .delay_span_bug(span, &format!(\"failed to normalize {:?}\", ty));\n                         TypeOpOutput {\n-                            output: self.infcx.tcx.ty_error(),\n+                            output: self.infcx.tcx.ty_error_with_guaranteed(reported),\n                             constraints: None,\n                             error_info: None,\n                         }"}, {"sha": "9c1d0bb8b235752feff6217722def95cf51be6da", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 20, "deletions": 89, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -27,7 +27,7 @@ use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::*;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::cast::CastTy;\n-use rustc_middle::ty::subst::{GenericArgKind, SubstsRef, UserSubsts};\n+use rustc_middle::ty::subst::{SubstsRef, UserSubsts};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n     self, Binder, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, Dynamic,\n@@ -61,7 +61,7 @@ use crate::{\n     region_infer::values::{\n         LivenessValues, PlaceholderIndex, PlaceholderIndices, RegionValueElements,\n     },\n-    region_infer::{ClosureRegionRequirementsExt, TypeTest},\n+    region_infer::TypeTest,\n     type_check::free_region_relations::{CreateResult, UniversalRegionRelations},\n     universal_regions::{DefiningTy, UniversalRegions},\n     Upvar,\n@@ -144,7 +144,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         liveness_constraints: LivenessValues::new(elements.clone()),\n         outlives_constraints: OutlivesConstraintSet::default(),\n         member_constraints: MemberConstraintSet::default(),\n-        closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n         universe_causes: FxHashMap::default(),\n     };\n@@ -234,11 +233,11 @@ pub(crate) fn type_check<'mir, 'tcx>(\n             let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n             trace!(\"finalized opaque type {:?} to {:#?}\", opaque_type_key, hidden_type.ty.kind());\n             if hidden_type.has_non_region_infer() {\n-                infcx.tcx.sess.delay_span_bug(\n+                let reported = infcx.tcx.sess.delay_span_bug(\n                     decl.hidden_type.span,\n                     &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n                 );\n-                hidden_type.ty = infcx.tcx.ty_error();\n+                hidden_type.ty = infcx.tcx.ty_error_with_guaranteed(reported);\n             }\n \n             (opaque_type_key, (hidden_type, decl.origin))\n@@ -584,8 +583,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         // modify their locations.\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n-        let mut type_tests = Default::default();\n-        let mut closure_bounds = Default::default();\n         let mut liveness_constraints =\n             LivenessValues::new(Rc::new(RegionValueElements::new(&promoted_body)));\n         // Don't try to add borrow_region facts for the promoted MIR\n@@ -596,11 +593,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 &mut this.cx.borrowck_context.constraints.outlives_constraints,\n                 &mut constraints,\n             );\n-            mem::swap(&mut this.cx.borrowck_context.constraints.type_tests, &mut type_tests);\n-            mem::swap(\n-                &mut this.cx.borrowck_context.constraints.closure_bounds_mapping,\n-                &mut closure_bounds,\n-            );\n             mem::swap(\n                 &mut this.cx.borrowck_context.constraints.liveness_constraints,\n                 &mut liveness_constraints,\n@@ -621,13 +613,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         swap_constraints(self);\n \n         let locations = location.to_locations();\n-\n-        // Use location of promoted const in collected constraints\n-        for type_test in type_tests.iter() {\n-            let mut type_test = type_test.clone();\n-            type_test.locations = locations;\n-            self.cx.borrowck_context.constraints.type_tests.push(type_test)\n-        }\n         for constraint in constraints.outlives().iter() {\n             let mut constraint = constraint.clone();\n             constraint.locations = locations;\n@@ -653,18 +638,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     .add_element(region, location);\n             }\n         }\n-\n-        if !closure_bounds.is_empty() {\n-            let combined_bounds_mapping =\n-                closure_bounds.into_iter().flat_map(|(_, value)| value).collect();\n-            let existing = self\n-                .cx\n-                .borrowck_context\n-                .constraints\n-                .closure_bounds_mapping\n-                .insert(location, combined_bounds_mapping);\n-            assert!(existing.is_none(), \"Multiple promoteds/closures at the same location.\");\n-        }\n     }\n \n     fn sanitize_projection(\n@@ -941,9 +914,6 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n \n     pub(crate) member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n-    pub(crate) closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n-\n     pub(crate) universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n     pub(crate) type_tests: Vec<TypeTest<'tcx>>,\n@@ -2562,6 +2532,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 span: location.to_locations().span(body),\n                                 category,\n                                 variance_info: ty::VarianceDiagInfo::default(),\n+                                from_closure: false,\n                             });\n \n                             match mutbl {\n@@ -2679,62 +2650,22 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         substs: SubstsRef<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n-        if let Some(ref closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements\n-        {\n-            let closure_constraints = QueryRegionConstraints {\n-                outlives: closure_region_requirements.apply_requirements(\n-                    tcx,\n-                    def_id.to_def_id(),\n-                    substs,\n-                ),\n-\n-                // Presently, closures never propagate member\n-                // constraints to their parents -- they are enforced\n-                // locally.  This is largely a non-issue as member\n-                // constraints only come from `-> impl Trait` and\n-                // friends which don't appear (thus far...) in\n-                // closures.\n-                member_constraints: vec![],\n-            };\n-\n-            let bounds_mapping = closure_constraints\n-                .outlives\n-                .iter()\n-                .enumerate()\n-                .filter_map(|(idx, constraint)| {\n-                    let ty::OutlivesPredicate(k1, r2) =\n-                        constraint.0.no_bound_vars().unwrap_or_else(|| {\n-                            bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n-                        });\n-\n-                    match k1.unpack() {\n-                        GenericArgKind::Lifetime(r1) => {\n-                            // constraint is r1: r2\n-                            let r1_vid = self.borrowck_context.universal_regions.to_region_vid(r1);\n-                            let r2_vid = self.borrowck_context.universal_regions.to_region_vid(r2);\n-                            let outlives_requirements =\n-                                &closure_region_requirements.outlives_requirements[idx];\n-                            Some((\n-                                (r1_vid, r2_vid),\n-                                (outlives_requirements.category, outlives_requirements.blame_span),\n-                            ))\n-                        }\n-                        GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n-                    }\n-                })\n-                .collect();\n-\n-            let existing = self\n-                .borrowck_context\n-                .constraints\n-                .closure_bounds_mapping\n-                .insert(location, bounds_mapping);\n-            assert!(existing.is_none(), \"Multiple closures at the same location.\");\n-\n-            self.push_region_constraints(\n+        if let Some(ref closure_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n+            constraint_conversion::ConstraintConversion::new(\n+                self.infcx,\n+                self.borrowck_context.universal_regions,\n+                self.region_bound_pairs,\n+                self.implicit_region_bound,\n+                self.param_env,\n                 location.to_locations(),\n-                ConstraintCategory::ClosureBounds,\n-                &closure_constraints,\n+                DUMMY_SP,                   // irrelevant; will be overrided.\n+                ConstraintCategory::Boring, // same as above.\n+                &mut self.borrowck_context.constraints,\n+            )\n+            .apply_closure_requirements(\n+                &closure_requirements,\n+                def_id.to_def_id(),\n+                substs,\n             );\n         }\n "}, {"sha": "94d51032866098954d19b99b974014e9b6189625", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -136,6 +136,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n                 span: self.locations.span(self.type_checker.body),\n                 category: self.category,\n                 variance_info: info,\n+                from_closure: false,\n             },\n         );\n     }"}, {"sha": "2ba012a77b0a908788f0272705f82f7c875cb1a7", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -59,7 +59,7 @@ impl DebugContext {\n \n         let producer = format!(\n             \"cg_clif (rustc {}, cranelift {})\",\n-            rustc_interface::util::version_str().unwrap_or(\"unknown version\"),\n+            rustc_interface::util::rustc_version_str().unwrap_or(\"unknown version\"),\n             cranelift_codegen::VERSION,\n         );\n         let comp_dir = tcx"}, {"sha": "862ed62c68b2ab9124e9ef04252819839e34a78c", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -201,6 +201,27 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     fn val_ty(&self, value: RValue<'gcc>) -> Type<'gcc> {\n         value.get_type()\n     }\n+\n+    fn type_array(&self, ty: Type<'gcc>, mut len: u64) -> Type<'gcc> {\n+        if let Some(struct_type) = ty.is_struct() {\n+            if struct_type.get_field_count() == 0 {\n+                // NOTE: since gccjit only supports i32 for the array size and libcore's tests uses a\n+                // size of usize::MAX in test_binary_search, we workaround this by setting the size to\n+                // zero for ZSTs.\n+                // FIXME(antoyo): fix gccjit API.\n+                len = 0;\n+            }\n+        }\n+\n+        // NOTE: see note above. Some other test uses usize::MAX.\n+        if len == u64::MAX {\n+            len = 0;\n+        }\n+\n+        let len: i32 = len.try_into().expect(\"array len\");\n+\n+        self.context.new_array_type(None, ty, len)\n+    }\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -227,27 +248,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         self.context.new_opaque_struct_type(None, name)\n     }\n \n-    pub fn type_array(&self, ty: Type<'gcc>, mut len: u64) -> Type<'gcc> {\n-        if let Some(struct_type) = ty.is_struct() {\n-            if struct_type.get_field_count() == 0 {\n-                // NOTE: since gccjit only supports i32 for the array size and libcore's tests uses a\n-                // size of usize::MAX in test_binary_search, we workaround this by setting the size to\n-                // zero for ZSTs.\n-                // FIXME(antoyo): fix gccjit API.\n-                len = 0;\n-            }\n-        }\n-\n-        // NOTE: see note above. Some other test uses usize::MAX.\n-        if len == u64::MAX {\n-            len = 0;\n-        }\n-\n-        let len: i32 = len.try_into().expect(\"array len\");\n-\n-        self.context.new_array_type(None, ty, len)\n-    }\n-\n     pub fn type_bool(&self) -> Type<'gcc> {\n         self.context.new_type::<bool>()\n     }"}, {"sha": "a8b47633519aabc39689ab19a7138c269b11440c", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -12,6 +12,7 @@ use rustc_target::spec::{FramePointer, SanitizerSet, StackProbeType, StackProtec\n use smallvec::SmallVec;\n \n use crate::attributes;\n+use crate::errors::{MissingFeatures, SanitizerMemtagRequiresMte, TargetFeatureDisableOrEnable};\n use crate::llvm::AttributePlace::Function;\n use crate::llvm::{self, AllocKindFlags, Attribute, AttributeKind, AttributePlace, MemoryEffects};\n use crate::llvm_util;\n@@ -82,7 +83,7 @@ pub fn sanitize_attrs<'ll>(\n         let mte_feature =\n             features.iter().map(|s| &s[..]).rfind(|n| [\"+mte\", \"-mte\"].contains(&&n[..]));\n         if let None | Some(\"-mte\") = mte_feature {\n-            cx.tcx.sess.err(\"`-Zsanitizer=memtag` requires `-Ctarget-feature=+mte`\");\n+            cx.tcx.sess.emit_err(SanitizerMemtagRequiresMte);\n         }\n \n         attrs.push(llvm::AttributeKind::SanitizeMemTag.create_attr(cx.llcx));\n@@ -393,13 +394,14 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n             .get_attrs(instance.def_id(), sym::target_feature)\n             .next()\n             .map_or_else(|| cx.tcx.def_span(instance.def_id()), |a| a.span);\n-        let msg = format!(\n-            \"the target features {} must all be either enabled or disabled together\",\n-            f.join(\", \")\n-        );\n-        let mut err = cx.tcx.sess.struct_span_err(span, &msg);\n-        err.help(\"add the missing features in a `target_feature` attribute\");\n-        err.emit();\n+        cx.tcx\n+            .sess\n+            .create_err(TargetFeatureDisableOrEnable {\n+                features: f,\n+                span: Some(span),\n+                missing_features: Some(MissingFeatures),\n+            })\n+            .emit();\n         return;\n     }\n "}, {"sha": "5c68abeb08baf288532e48c162926b39f92fce26", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -12,6 +12,10 @@ use std::str;\n use object::read::macho::FatArch;\n \n use crate::common;\n+use crate::errors::{\n+    ArchiveBuildFailure, DlltoolFailImportLibrary, ErrorCallingDllTool, ErrorCreatingImportLibrary,\n+    ErrorWritingDEFFile, UnknownArchiveKind,\n+};\n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n@@ -147,7 +151,7 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n     fn build(mut self: Box<Self>, output: &Path) -> bool {\n         match self.build_with_llvm(output) {\n             Ok(any_members) => any_members,\n-            Err(e) => self.sess.fatal(&format!(\"failed to build archive: {}\", e)),\n+            Err(e) => self.sess.emit_fatal(ArchiveBuildFailure { error: e }),\n         }\n     }\n }\n@@ -217,7 +221,7 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n             match std::fs::write(&def_file_path, def_file_content) {\n                 Ok(_) => {}\n                 Err(e) => {\n-                    sess.fatal(&format!(\"Error writing .DEF file: {}\", e));\n+                    sess.emit_fatal(ErrorWritingDEFFile { error: e });\n                 }\n             };\n \n@@ -239,13 +243,14 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n \n             match result {\n                 Err(e) => {\n-                    sess.fatal(&format!(\"Error calling dlltool: {}\", e));\n+                    sess.emit_fatal(ErrorCallingDllTool { error: e });\n+                }\n+                Ok(output) if !output.status.success() => {\n+                    sess.emit_fatal(DlltoolFailImportLibrary {\n+                        stdout: String::from_utf8_lossy(&output.stdout),\n+                        stderr: String::from_utf8_lossy(&output.stderr),\n+                    })\n                 }\n-                Ok(output) if !output.status.success() => sess.fatal(&format!(\n-                    \"Dlltool could not create import library: {}\\n{}\",\n-                    String::from_utf8_lossy(&output.stdout),\n-                    String::from_utf8_lossy(&output.stderr)\n-                )),\n                 _ => {}\n             }\n         } else {\n@@ -293,11 +298,10 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n             };\n \n             if result == crate::llvm::LLVMRustResult::Failure {\n-                sess.fatal(&format!(\n-                    \"Error creating import library for {}: {}\",\n+                sess.emit_fatal(ErrorCreatingImportLibrary {\n                     lib_name,\n-                    llvm::last_error().unwrap_or(\"unknown LLVM error\".to_string())\n-                ));\n+                    error: llvm::last_error().unwrap_or(\"unknown LLVM error\".to_string()),\n+                });\n             }\n         };\n \n@@ -308,9 +312,10 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n impl<'a> LlvmArchiveBuilder<'a> {\n     fn build_with_llvm(&mut self, output: &Path) -> io::Result<bool> {\n         let kind = &*self.sess.target.archive_format;\n-        let kind = kind.parse::<ArchiveKind>().map_err(|_| kind).unwrap_or_else(|kind| {\n-            self.sess.fatal(&format!(\"Don't know how to build archive of type: {}\", kind))\n-        });\n+        let kind = kind\n+            .parse::<ArchiveKind>()\n+            .map_err(|_| kind)\n+            .unwrap_or_else(|kind| self.sess.emit_fatal(UnknownArchiveKind { kind }));\n \n         let mut additions = mem::take(&mut self.additions);\n         let mut strings = Vec::new();"}, {"sha": "3fa21355b7f4c9b46349591904aac80717541976", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,4 +1,5 @@\n use crate::back::write::{self, save_temp_bitcode, DiagnosticHandlers};\n+use crate::errors::DynamicLinkingWithLTO;\n use crate::llvm::{self, build_string};\n use crate::{LlvmCodegenBackend, ModuleLlvm};\n use object::read::archive::ArchiveFile;\n@@ -90,13 +91,7 @@ fn prepare_lto(\n         }\n \n         if cgcx.opts.cg.prefer_dynamic && !cgcx.opts.unstable_opts.dylib_lto {\n-            diag_handler\n-                .struct_err(\"cannot prefer dynamic linking when performing LTO\")\n-                .note(\n-                    \"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n-                               supported with LTO\",\n-                )\n-                .emit();\n+            diag_handler.emit_err(DynamicLinkingWithLTO);\n             return Err(FatalError);\n         }\n "}, {"sha": "3b504d3a7df7589fc7f13a0027584d4cb51d6638", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,6 +1,7 @@\n use crate::base;\n use crate::common::{self, CodegenCx};\n use crate::debuginfo;\n+use crate::errors::{InvalidMinimumAlignment, LinkageConstOrMutType, SymbolAlreadyDefined};\n use crate::llvm::{self, True};\n use crate::llvm_util;\n use crate::type_::Type;\n@@ -19,6 +20,7 @@ use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n+use rustc_session::config::Lto;\n use rustc_target::abi::{\n     AddressSpace, Align, HasDataLayout, Primitive, Scalar, Size, WrappingRange,\n };\n@@ -145,7 +147,7 @@ fn set_global_alignment<'ll>(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align:\n         match Align::from_bits(min) {\n             Ok(min) => align = align.max(min),\n             Err(err) => {\n-                cx.sess().err(&format!(\"invalid minimum global alignment: {}\", err));\n+                cx.sess().emit_err(InvalidMinimumAlignment { err });\n             }\n         }\n     }\n@@ -173,10 +175,7 @@ fn check_and_apply_linkage<'ll, 'tcx>(\n         let llty2 = if let ty::RawPtr(ref mt) = ty.kind() {\n             cx.layout_of(mt.ty).llvm_type(cx)\n         } else {\n-            cx.sess().span_fatal(\n-                cx.tcx.def_span(def_id),\n-                \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\",\n-            )\n+            cx.sess().emit_fatal(LinkageConstOrMutType { span: cx.tcx.def_span(def_id) })\n         };\n         unsafe {\n             // Declare a symbol `foo` with the desired linkage.\n@@ -192,10 +191,10 @@ fn check_and_apply_linkage<'ll, 'tcx>(\n             let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n             real_name.push_str(sym);\n             let g2 = cx.define_global(&real_name, llty).unwrap_or_else(|| {\n-                cx.sess().span_fatal(\n-                    cx.tcx.def_span(def_id),\n-                    &format!(\"symbol `{}` is already defined\", &sym),\n-                )\n+                cx.sess().emit_fatal(SymbolAlreadyDefined {\n+                    span: cx.tcx.def_span(def_id),\n+                    symbol_name: sym,\n+                })\n             });\n             llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n             llvm::LLVMSetInitializer(g2, g1);\n@@ -303,7 +302,8 @@ impl<'ll> CodegenCx<'ll, '_> {\n                 // ThinLTO can't handle this workaround in all cases, so we don't\n                 // emit the attrs. Instead we make them unnecessary by disallowing\n                 // dynamic linking when linker plugin based LTO is enabled.\n-                !self.tcx.sess.opts.cg.linker_plugin_lto.enabled();\n+                !self.tcx.sess.opts.cg.linker_plugin_lto.enabled() &&\n+                self.tcx.sess.lto() != Lto::Thin;\n \n             // If this assertion triggers, there's something wrong with commandline\n             // argument validation."}, {"sha": "eaa2ccfc835c5f2564a58d53ff9522d87e3320e7", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -3,6 +3,7 @@ use crate::back::write::to_llvm_code_model;\n use crate::callee::get_fn;\n use crate::coverageinfo;\n use crate::debuginfo;\n+use crate::errors::BranchProtectionRequiresAArch64;\n use crate::llvm;\n use crate::llvm_util;\n use crate::type_::Type;\n@@ -26,6 +27,7 @@ use rustc_session::config::{BranchProtection, CFGuard, CFProtection};\n use rustc_session::config::{CrateType, DebugInfo, PAuthKey, PacRet};\n use rustc_session::Session;\n use rustc_span::source_map::Span;\n+use rustc_span::source_map::Spanned;\n use rustc_target::abi::{\n     call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx,\n };\n@@ -158,6 +160,10 @@ pub unsafe fn create_module<'ll>(\n         if sess.target.arch == \"s390x\" {\n             target_data_layout = target_data_layout.replace(\"-v128:64\", \"\");\n         }\n+\n+        if sess.target.arch == \"riscv64\" {\n+            target_data_layout = target_data_layout.replace(\"-n32:64-\", \"-n64-\");\n+        }\n     }\n \n     // Ensure the data-layout values hardcoded remain the defaults.\n@@ -271,7 +277,7 @@ pub unsafe fn create_module<'ll>(\n \n     if let Some(BranchProtection { bti, pac_ret }) = sess.opts.unstable_opts.branch_protection {\n         if sess.target.arch != \"aarch64\" {\n-            sess.err(\"-Zbranch-protection is only supported on aarch64\");\n+            sess.emit_err(BranchProtectionRequiresAArch64);\n         } else {\n             llvm::LLVMRustAddModuleFlag(\n                 llmod,\n@@ -947,7 +953,7 @@ impl<'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'_, 'tcx> {\n     #[inline]\n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n         if let LayoutError::SizeOverflow(_) = err {\n-            self.sess().span_fatal(span, &err.to_string())\n+            self.sess().emit_fatal(Spanned { span, node: err })\n         } else {\n             span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n         }\n@@ -965,7 +971,7 @@ impl<'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'_, 'tcx> {\n         fn_abi_request: FnAbiRequest<'tcx>,\n     ) -> ! {\n         if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n-            self.sess().span_fatal(span, &err.to_string())\n+            self.sess().emit_fatal(Spanned { span, node: err })\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {"}, {"sha": "8a8d889a29865960e9c1337873d5ab54879b783e", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,5 +1,6 @@\n use crate::common::CodegenCx;\n use crate::coverageinfo;\n+use crate::errors::InstrumentCoverageRequiresLLVM12;\n use crate::llvm;\n \n use llvm::coverageinfo::CounterMappingRegion;\n@@ -37,7 +38,7 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     // LLVM 12.\n     let version = coverageinfo::mapping_version();\n     if version < 4 {\n-        tcx.sess.fatal(\"rustc option `-C instrument-coverage` requires LLVM 12 or higher.\");\n+        tcx.sess.emit_fatal(InstrumentCoverageRequiresLLVM12);\n     }\n \n     debug!(\"Generating coverage map for CodegenUnit: `{}`\", cx.codegen_unit.name());"}, {"sha": "0fafc214f2f5ebdc6144ff8dbd8f154d3a3b2814", "filename": "compiler/rustc_codegen_llvm/src/errors.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ferrors.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -0,0 +1,139 @@\n+use std::borrow::Cow;\n+\n+use rustc_errors::fluent;\n+use rustc_errors::DiagnosticBuilder;\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_errors::Handler;\n+use rustc_errors::IntoDiagnostic;\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_span::Span;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_unknown_ctarget_feature_prefix)]\n+#[note]\n+pub(crate) struct UnknownCTargetFeaturePrefix<'a> {\n+    pub feature: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_unknown_ctarget_feature)]\n+#[note]\n+pub(crate) struct UnknownCTargetFeature<'a> {\n+    pub feature: &'a str,\n+    #[subdiagnostic]\n+    pub rust_feature: PossibleFeature<'a>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum PossibleFeature<'a> {\n+    #[help(possible_feature)]\n+    Some { rust_feature: &'a str },\n+    #[help(consider_filing_feature_request)]\n+    None,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_error_creating_import_library)]\n+pub(crate) struct ErrorCreatingImportLibrary<'a> {\n+    pub lib_name: &'a str,\n+    pub error: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_instrument_coverage_requires_llvm_12)]\n+pub(crate) struct InstrumentCoverageRequiresLLVM12;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_symbol_already_defined)]\n+pub(crate) struct SymbolAlreadyDefined<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub symbol_name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_branch_protection_requires_aarch64)]\n+pub(crate) struct BranchProtectionRequiresAArch64;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_invalid_minimum_alignment)]\n+pub(crate) struct InvalidMinimumAlignment {\n+    pub err: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_linkage_const_or_mut_type)]\n+pub(crate) struct LinkageConstOrMutType {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_sanitizer_memtag_requires_mte)]\n+pub(crate) struct SanitizerMemtagRequiresMte;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_archive_build_failure)]\n+pub(crate) struct ArchiveBuildFailure {\n+    pub error: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_error_writing_def_file)]\n+pub(crate) struct ErrorWritingDEFFile {\n+    pub error: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_error_calling_dlltool)]\n+pub(crate) struct ErrorCallingDllTool {\n+    pub error: std::io::Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_dlltool_fail_import_library)]\n+pub(crate) struct DlltoolFailImportLibrary<'a> {\n+    pub stdout: Cow<'a, str>,\n+    pub stderr: Cow<'a, str>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_unknown_archive_kind)]\n+pub(crate) struct UnknownArchiveKind<'a> {\n+    pub kind: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_dynamic_linking_with_lto)]\n+#[note]\n+pub(crate) struct DynamicLinkingWithLTO;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_llvm_fail_parsing_target_machine_config_to_target_machine)]\n+pub(crate) struct FailParsingTargetMachineConfigToTargetMachine {\n+    pub error: String,\n+}\n+\n+pub(crate) struct TargetFeatureDisableOrEnable<'a> {\n+    pub features: &'a [&'a str],\n+    pub span: Option<Span>,\n+    pub missing_features: Option<MissingFeatures>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(codegen_llvm_missing_features)]\n+pub(crate) struct MissingFeatures;\n+\n+impl IntoDiagnostic<'_, ErrorGuaranteed> for TargetFeatureDisableOrEnable<'_> {\n+    fn into_diagnostic(self, sess: &'_ Handler) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = sess.struct_err(fluent::codegen_llvm_target_feature_disable_or_enable);\n+        if let Some(span) = self.span {\n+            diag.set_span(span);\n+        };\n+        if let Some(missing_features) = self.missing_features {\n+            diag.subdiagnostic(missing_features);\n+        }\n+        diag.set_arg(\"features\", self.features.join(\", \"));\n+        diag\n+    }\n+}"}, {"sha": "246e82545c874811fa6552bc2286da98bc113476", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -12,6 +12,8 @@\n #![feature(iter_intersperse)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_macros;\n@@ -20,6 +22,7 @@ extern crate tracing;\n \n use back::write::{create_informational_target_machine, create_target_machine};\n \n+use errors::FailParsingTargetMachineConfigToTargetMachine;\n pub use llvm_util::target_features;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n@@ -62,6 +65,7 @@ mod context;\n mod coverageinfo;\n mod debuginfo;\n mod declare;\n+mod errors;\n mod intrinsic;\n \n // The following is a work around that replaces `pub mod llvm;` and that fixes issue 53912.\n@@ -412,7 +416,7 @@ impl ModuleLlvm {\n             let tm = match (cgcx.tm_factory)(tm_factory_config) {\n                 Ok(m) => m,\n                 Err(e) => {\n-                    handler.struct_err(&e).emit();\n+                    handler.emit_err(FailParsingTargetMachineConfigToTargetMachine { error: e });\n                     return Err(FatalError);\n                 }\n             };"}, {"sha": "e1f54356228d3ea60163ec928322caf5d82fbc88", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,4 +1,8 @@\n use crate::back::write::create_informational_target_machine;\n+use crate::errors::{\n+    PossibleFeature, TargetFeatureDisableOrEnable, UnknownCTargetFeature,\n+    UnknownCTargetFeaturePrefix,\n+};\n use crate::llvm;\n use libc::c_int;\n use rustc_codegen_ssa::target_features::{\n@@ -434,12 +438,7 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n                 Some(c @ '+' | c @ '-') => c,\n                 Some(_) => {\n                     if diagnostics {\n-                        let mut diag = sess.struct_warn(&format!(\n-                            \"unknown feature specified for `-Ctarget-feature`: `{}`\",\n-                            s\n-                        ));\n-                        diag.note(\"features must begin with a `+` to enable or `-` to disable it\");\n-                        diag.emit();\n+                        sess.emit_warning(UnknownCTargetFeaturePrefix { feature: s });\n                     }\n                     return None;\n                 }\n@@ -456,17 +455,15 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n                         None\n                     }\n                 });\n-                let mut diag = sess.struct_warn(&format!(\n-                    \"unknown feature specified for `-Ctarget-feature`: `{}`\",\n-                    feature\n-                ));\n-                diag.note(\"it is still passed through to the codegen backend\");\n-                if let Some(rust_feature) = rust_feature {\n-                    diag.help(&format!(\"you might have meant: `{}`\", rust_feature));\n+                let unknown_feature = if let Some(rust_feature) = rust_feature {\n+                    UnknownCTargetFeature {\n+                        feature,\n+                        rust_feature: PossibleFeature::Some { rust_feature },\n+                    }\n                 } else {\n-                    diag.note(\"consider filing a feature request\");\n-                }\n-                diag.emit();\n+                    UnknownCTargetFeature { feature, rust_feature: PossibleFeature::None }\n+                };\n+                sess.emit_warning(unknown_feature);\n             }\n \n             if diagnostics {\n@@ -492,10 +489,11 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n     features.extend(feats);\n \n     if diagnostics && let Some(f) = check_tied_features(sess, &featsmap) {\n-        sess.err(&format!(\n-            \"target features {} must all be enabled or disabled together\",\n-            f.join(\", \")\n-        ));\n+        sess.emit_err(TargetFeatureDisableOrEnable {\n+            features: f,\n+            span: None,\n+            missing_features: None,\n+        });\n     }\n \n     features"}, {"sha": "76f692b2016fd5ff64d4824206b856fc12811969", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,6 +1,7 @@\n use crate::attributes;\n use crate::base;\n use crate::context::CodegenCx;\n+use crate::errors::SymbolAlreadyDefined;\n use crate::llvm;\n use crate::type_of::LayoutLlvmExt;\n use rustc_codegen_ssa::traits::*;\n@@ -25,10 +26,8 @@ impl<'tcx> PreDefineMethods<'tcx> for CodegenCx<'_, 'tcx> {\n         let llty = self.layout_of(ty).llvm_type(self);\n \n         let g = self.define_global(symbol_name, llty).unwrap_or_else(|| {\n-            self.sess().span_fatal(\n-                self.tcx.def_span(def_id),\n-                &format!(\"symbol `{}` is already defined\", symbol_name),\n-            )\n+            self.sess()\n+                .emit_fatal(SymbolAlreadyDefined { span: self.tcx.def_span(def_id), symbol_name })\n         });\n \n         unsafe {"}, {"sha": "5eec7dc613028e3e25f6a50296399f20a6d8f34d", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -127,10 +127,6 @@ impl<'ll> CodegenCx<'ll, '_> {\n     pub(crate) fn type_variadic_func(&self, args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n         unsafe { llvm::LLVMFunctionType(ret, args.as_ptr(), args.len() as c_uint, True) }\n     }\n-\n-    pub(crate) fn type_array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n-        unsafe { llvm::LLVMRustArrayType(ty, len) }\n-    }\n }\n \n impl<'ll, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n@@ -231,6 +227,10 @@ impl<'ll, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn val_ty(&self, v: &'ll Value) -> &'ll Type {\n         common::val_ty(v)\n     }\n+\n+    fn type_array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n+        unsafe { llvm::LLVMRustArrayType(ty, len) }\n+    }\n }\n \n impl Type {"}, {"sha": "e3d28a1aca20eacfc1dc08ad628a58bb06b0d1a8", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -15,10 +15,8 @@ use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::Emitter;\n-use rustc_errors::{\n-    translation::{to_fluent_args, Translate},\n-    DiagnosticId, FatalError, Handler, Level,\n-};\n+use rustc_errors::{translation::Translate, DiagnosticId, FatalError, Handler, Level};\n+use rustc_errors::{DiagnosticMessage, Style};\n use rustc_fs_util::link_or_copy;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_incremental::{\n@@ -38,6 +36,7 @@ use rustc_span::{BytePos, FileName, InnerSpan, Pos, Span};\n use rustc_target::spec::{MergeFunctions, SanitizerSet};\n \n use std::any::Any;\n+use std::borrow::Cow;\n use std::fs;\n use std::io;\n use std::marker::PhantomData;\n@@ -969,8 +968,11 @@ pub enum Message<B: WriteBackendMethods> {\n     CodegenAborted,\n }\n \n+type DiagnosticArgName<'source> = Cow<'source, str>;\n+\n struct Diagnostic {\n-    msg: String,\n+    msg: Vec<(DiagnosticMessage, Style)>,\n+    args: FxHashMap<DiagnosticArgName<'static>, rustc_errors::DiagnosticArgValue<'static>>,\n     code: Option<DiagnosticId>,\n     lvl: Level,\n }\n@@ -1743,15 +1745,18 @@ impl Translate for SharedEmitter {\n \n impl Emitter for SharedEmitter {\n     fn emit_diagnostic(&mut self, diag: &rustc_errors::Diagnostic) {\n-        let fluent_args = to_fluent_args(diag.args());\n+        let args: FxHashMap<Cow<'_, str>, rustc_errors::DiagnosticArgValue<'_>> =\n+            diag.args().map(|(name, arg)| (name.clone(), arg.clone())).collect();\n         drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n-            msg: self.translate_messages(&diag.message, &fluent_args).to_string(),\n+            msg: diag.message.clone(),\n+            args: args.clone(),\n             code: diag.code.clone(),\n             lvl: diag.level(),\n         })));\n         for child in &diag.children {\n             drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n-                msg: self.translate_messages(&child.message, &fluent_args).to_string(),\n+                msg: child.message.clone(),\n+                args: args.clone(),\n                 code: None,\n                 lvl: child.level,\n             })));\n@@ -1782,10 +1787,11 @@ impl SharedEmitterMain {\n             match message {\n                 Ok(SharedEmitterMessage::Diagnostic(diag)) => {\n                     let handler = sess.diagnostic();\n-                    let mut d = rustc_errors::Diagnostic::new(diag.lvl, &diag.msg);\n+                    let mut d = rustc_errors::Diagnostic::new_with_messages(diag.lvl, diag.msg);\n                     if let Some(code) = diag.code {\n                         d.code(code);\n                     }\n+                    d.replace_args(diag.args);\n                     handler.emit_diagnostic(&mut d);\n                 }\n                 Ok(SharedEmitterMessage::InlineAsmError(cookie, msg, level, source)) => {"}, {"sha": "8647fbace2a75458988d8589c1c1c498c39f7d5d", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -59,7 +59,13 @@ fn push_debuginfo_type_name<'tcx>(\n     match *t.kind() {\n         ty::Bool => output.push_str(\"bool\"),\n         ty::Char => output.push_str(\"char\"),\n-        ty::Str => output.push_str(\"str\"),\n+        ty::Str => {\n+            if cpp_like_debuginfo {\n+                output.push_str(\"str$\")\n+            } else {\n+                output.push_str(\"str\")\n+            }\n+        }\n         ty::Never => {\n             if cpp_like_debuginfo {\n                 output.push_str(\"never$\");\n@@ -152,25 +158,19 @@ fn push_debuginfo_type_name<'tcx>(\n             }\n         }\n         ty::Ref(_, inner_type, mutbl) => {\n-            // Slices and `&str` are treated like C++ pointers when computing debug\n-            // info for MSVC debugger. However, wrapping these types' names in a synthetic type\n-            // causes the .natvis engine for WinDbg to fail to display their data, so we opt these\n-            // types out to aid debugging in MSVC.\n-            let is_slice_or_str = matches!(*inner_type.kind(), ty::Slice(_) | ty::Str);\n-\n-            if !cpp_like_debuginfo {\n-                output.push('&');\n-                output.push_str(mutbl.prefix_str());\n-            } else if !is_slice_or_str {\n+            if cpp_like_debuginfo {\n                 match mutbl {\n                     Mutability::Not => output.push_str(\"ref$<\"),\n                     Mutability::Mut => output.push_str(\"ref_mut$<\"),\n                 }\n+            } else {\n+                output.push('&');\n+                output.push_str(mutbl.prefix_str());\n             }\n \n             push_debuginfo_type_name(tcx, inner_type, qualified, output, visited);\n \n-            if cpp_like_debuginfo && !is_slice_or_str {\n+            if cpp_like_debuginfo {\n                 push_close_angle_bracket(cpp_like_debuginfo, output);\n             }\n         }\n@@ -195,7 +195,7 @@ fn push_debuginfo_type_name<'tcx>(\n         }\n         ty::Slice(inner_type) => {\n             if cpp_like_debuginfo {\n-                output.push_str(\"slice$<\");\n+                output.push_str(\"slice2$<\");\n             } else {\n                 output.push('[');\n             }"}, {"sha": "86481d5d758d6d251c5b916163079905a8dd805f", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -22,6 +22,7 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n     fn type_f32(&self) -> Self::Type;\n     fn type_f64(&self) -> Self::Type;\n \n+    fn type_array(&self, ty: Self::Type, len: u64) -> Self::Type;\n     fn type_func(&self, args: &[Self::Type], ret: Self::Type) -> Self::Type;\n     fn type_struct(&self, els: &[Self::Type], packed: bool) -> Self::Type;\n     fn type_kind(&self, ty: Self::Type) -> TypeKind;"}, {"sha": "5a8b3e30b9fc0cdaab6bc89e90bfbb3624ee2668", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -765,7 +765,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n                         let errors = ocx.select_all_or_error();\n                         if !errors.is_empty() {\n-                            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+                            infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n                         }\n                     }\n \n@@ -831,7 +831,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                                         obligation.clone(),\n                                         &obligation,\n                                         &e,\n-                                        false,\n                                     );\n                                 }\n "}, {"sha": "d995d533ca3e434ff9da5b25aba08375bfd50c61", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -146,6 +146,7 @@ impl Qualif for NeedsNonConstDrop {\n         qualifs.needs_non_const_drop\n     }\n \n+    #[instrument(level = \"trace\", skip(cx), ret)]\n     fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n         // Avoid selecting for simple cases, such as builtin types.\n         if ty::util::is_trivially_const_drop(ty) {\n@@ -174,6 +175,8 @@ impl Qualif for NeedsNonConstDrop {\n             return true;\n         };\n \n+        trace!(?impl_src);\n+\n         if !matches!(\n             impl_src,\n             ImplSource::ConstDestruct(_) | ImplSource::Param(_, ty::BoundConstness::ConstIfConst)"}, {"sha": "5afce15e26bfcc55e3fa8c7454c010dc0aca2296", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -23,7 +23,7 @@ rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n smallvec = { version = \"1.8.1\", features = [\"const_generics\", \"union\", \"may_dangle\"] }\n stable_deref_trait = \"1.0.0\"\n-stacker = \"0.1.14\"\n+stacker = \"0.1.15\"\n tempfile = \"3.2\"\n thin-vec = \"0.2.9\"\n tracing = \"0.1\""}, {"sha": "e043368fdfe0210ae475bd7b151310538ba099cc", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -6,6 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(once_cell)]\n+#![feature(decl_macro)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]\n@@ -736,26 +737,58 @@ fn print_crate_info(\n             // Any output here interferes with Cargo's parsing of other printed output\n             NativeStaticLibs => {}\n             LinkArgs => {}\n+            SplitDebuginfo => {\n+                use rustc_target::spec::SplitDebuginfo::{Off, Packed, Unpacked};\n+\n+                for split in &[Off, Packed, Unpacked] {\n+                    let stable = sess.target.options.supported_split_debuginfo.contains(split);\n+                    let unstable_ok = sess.unstable_options();\n+                    if stable || unstable_ok {\n+                        println!(\"{}\", split);\n+                    }\n+                }\n+            }\n         }\n     }\n     Compilation::Stop\n }\n \n /// Prints version information\n-pub fn version(binary: &str, matches: &getopts::Matches) {\n+///\n+/// NOTE: this is a macro to support drivers built at a different time than the main `rustc_driver` crate.\n+pub macro version($binary: literal, $matches: expr) {\n+    fn unw(x: Option<&str>) -> &str {\n+        x.unwrap_or(\"unknown\")\n+    }\n+    $crate::version_at_macro_invocation(\n+        $binary,\n+        $matches,\n+        unw(option_env!(\"CFG_VERSION\")),\n+        unw(option_env!(\"CFG_VER_HASH\")),\n+        unw(option_env!(\"CFG_VER_DATE\")),\n+        unw(option_env!(\"CFG_RELEASE\")),\n+    )\n+}\n+\n+#[doc(hidden)] // use the macro instead\n+pub fn version_at_macro_invocation(\n+    binary: &str,\n+    matches: &getopts::Matches,\n+    version: &str,\n+    commit_hash: &str,\n+    commit_date: &str,\n+    release: &str,\n+) {\n     let verbose = matches.opt_present(\"verbose\");\n \n-    println!(\"{} {}\", binary, util::version_str().unwrap_or(\"unknown version\"));\n+    println!(\"{} {}\", binary, version);\n \n     if verbose {\n-        fn unw(x: Option<&str>) -> &str {\n-            x.unwrap_or(\"unknown\")\n-        }\n         println!(\"binary: {}\", binary);\n-        println!(\"commit-hash: {}\", unw(util::commit_hash_str()));\n-        println!(\"commit-date: {}\", unw(util::commit_date_str()));\n+        println!(\"commit-hash: {}\", commit_hash);\n+        println!(\"commit-date: {}\", commit_date);\n         println!(\"host: {}\", config::host_triple());\n-        println!(\"release: {}\", unw(util::release_str()));\n+        println!(\"release: {}\", release);\n \n         let debug_flags = matches.opt_strs(\"Z\");\n         let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n@@ -1071,7 +1104,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if matches.opt_present(\"version\") {\n-        version(\"rustc\", &matches);\n+        version!(\"rustc\", &matches);\n         return None;\n     }\n \n@@ -1216,7 +1249,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n         format!(\"we would appreciate a bug report: {}\", bug_report_url).into(),\n         format!(\n             \"rustc {} running on {}\",\n-            util::version_str().unwrap_or(\"unknown_version\"),\n+            util::version_str!().unwrap_or(\"unknown_version\"),\n             config::host_triple()\n         )\n         .into(),"}, {"sha": "95e7c9fc76ce2bf00c081a386e488c4dfcf05b6e", "filename": "compiler/rustc_error_codes/src/error_codes/E0207.md", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0207.md", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0207.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0207.md?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,4 +1,5 @@\n-A type parameter that is specified for `impl` is not constrained.\n+A type, const or lifetime parameter that is specified for `impl` is not\n+constrained.\n \n Erroneous code example:\n \n@@ -14,15 +15,18 @@ impl<T: Default> Foo {\n }\n ```\n \n-Any type parameter of an `impl` must meet at least one of\n-the following criteria:\n+Any type or const parameter of an `impl` must meet at least one of the\n+following criteria:\n \n  - it appears in the _implementing type_ of the impl, e.g. `impl<T> Foo<T>`\n  - for a trait impl, it appears in the _implemented trait_, e.g.\n    `impl<T> SomeTrait<T> for Foo`\n  - it is bound as an associated type, e.g. `impl<T, U> SomeTrait for T\n    where T: AnotherTrait<AssocType=U>`\n \n+Any unconstrained lifetime parameter of an `impl` is not supported if the\n+lifetime parameter is used by an associated type.\n+\n ### Error example 1\n \n Suppose we have a struct `Foo` and we would like to define some methods for it.\n@@ -32,7 +36,6 @@ The problem is that the parameter `T` does not appear in the implementing type\n (`Foo`) of the impl. In this case, we can fix the error by moving the type\n parameter from the `impl` to the method `get`:\n \n-\n ```\n struct Foo;\n \n@@ -128,6 +131,70 @@ impl<T: Default> Maker<Foo<T>> for FooMaker {\n }\n ```\n \n+### Error example 3\n+\n+Suppose we have a struct `Foo` and we would like to define some methods for it.\n+The following code example has a definition which leads to a compiler error:\n+\n+```compile_fail,E0207\n+struct Foo;\n+\n+impl<const T: i32> Foo {\n+    // error: the const parameter `T` is not constrained by the impl trait, self\n+    // type, or predicates [E0207]\n+    fn get(&self) -> i32 {\n+        i32::default()\n+    }\n+}\n+```\n+\n+The problem is that the const parameter `T` does not appear in the implementing\n+type (`Foo`) of the impl. In this case, we can fix the error by moving the type\n+parameter from the `impl` to the method `get`:\n+\n+\n+```\n+struct Foo;\n+\n+// Move the const parameter from the impl to the method\n+impl Foo {\n+    fn get<const T: i32>(&self) -> i32 {\n+        i32::default()\n+    }\n+}\n+```\n+\n+### Error example 4\n+\n+Suppose we have a struct `Foo` and a struct `Bar` that uses lifetime `'a`. We\n+would like to implement trait `Contains` for `Foo`. The trait `Contains` have\n+the associated type `B`. The following code example has a definition which\n+leads to a compiler error:\n+\n+```compile_fail,E0207\n+struct Foo;\n+struct Bar<'a>;\n+\n+trait Contains {\n+    type B;\n+\n+    fn get(&self) -> i32;\n+}\n+\n+impl<'a> Contains for Foo {\n+    type B = Bar<'a>;\n+\n+    // error: the lifetime parameter `'a` is not constrained by the impl trait,\n+    // self type, or predicates [E0207]\n+    fn get(&self) -> i32 {\n+        i32::default()\n+    }\n+}\n+```\n+\n+Please note that unconstrained lifetime parameters are not supported if they are\n+being used by an associated type.\n+\n ### Additional information\n \n For more information, please see [RFC 447]."}, {"sha": "80fc4c6e4f5d37098456abf6449eb1d55e1c82ed", "filename": "compiler/rustc_error_messages/locales/en-US/borrowck.ftl", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fborrowck.ftl?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -58,3 +58,15 @@ borrowck_returned_lifetime_short =\n \n borrowck_used_impl_require_static =\n     the used `impl` has a `'static` requirement\n+\n+borrowck_capture_kind_label =\n+    capture is {$kind_desc} because of use here\n+\n+borrowck_var_borrow_by_use_place_in_generator =\n+    borrow occurs due to use of {$place} in closure in generator\n+\n+borrowck_var_borrow_by_use_place_in_closure =\n+    borrow occurs due to use of {$place} in closure\n+\n+borrowck_var_borrow_by_use_place =\n+    borrow occurs due to use of {$place}"}, {"sha": "68a205df6c7ad05207b41617b23b8defd7dab31c", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_llvm.ftl", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_llvm.ftl?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -0,0 +1,58 @@\n+codegen_llvm_unknown_ctarget_feature =\n+    unknown feature specified for `-Ctarget-feature`: `{$feature}`\n+    .note = it is still passed through to the codegen backend\n+    .possible_feature = you might have meant: `{$rust_feature}`\n+    .consider_filing_feature_request = consider filing a feature request\n+\n+codegen_llvm_unknown_ctarget_feature_prefix =\n+    unknown feature specified for `-Ctarget-feature`: `{$feature}`\n+    .note = features must begin with a `+` to enable or `-` to disable it\n+\n+codegen_llvm_error_creating_import_library =\n+    Error creating import library for {$lib_name}: {$error}\n+\n+codegen_llvm_instrument_coverage_requires_llvm_12 =\n+    rustc option `-C instrument-coverage` requires LLVM 12 or higher.\n+\n+codegen_llvm_symbol_already_defined =\n+    symbol `{$symbol_name}` is already defined\n+\n+codegen_llvm_branch_protection_requires_aarch64 =\n+    -Zbranch-protection is only supported on aarch64\n+\n+codegen_llvm_invalid_minimum_alignment =\n+    invalid minimum global alignment: {$err}\n+\n+codegen_llvm_linkage_const_or_mut_type =\n+    must have type `*const T` or `*mut T` due to `#[linkage]` attribute\n+\n+codegen_llvm_sanitizer_memtag_requires_mte =\n+    `-Zsanitizer=memtag` requires `-Ctarget-feature=+mte`\n+\n+codegen_llvm_archive_build_failure =\n+    failed to build archive: {$error}\n+\n+codegen_llvm_error_writing_def_file =\n+    Error writing .DEF file: {$error}\n+\n+codegen_llvm_error_calling_dlltool =\n+    Error calling dlltool: {$error}\n+\n+codegen_llvm_dlltool_fail_import_library =\n+    Dlltool could not create import library: {$stdout}\\n{$stderr}\n+\n+codegen_llvm_unknown_archive_kind =\n+    Don't know how to build archive of type: {$kind}\n+\n+codegen_llvm_target_feature_disable_or_enable =\n+    the target features {$features} must all be either enabled or disabled together\n+\n+codegen_llvm_missing_features =\n+    add the missing features in a `target_feature` attribute\n+\n+codegen_llvm_dynamic_linking_with_lto =\n+    cannot prefer dynamic linking when performing LTO\n+    .note = only 'staticlib', 'bin', and 'cdylib' outputs are supported with LTO\n+\n+codegen_llvm_fail_parsing_target_machine_config_to_target_machine =\n+    failed to parse target machine config to target machine: {$error}"}, {"sha": "fa975ff2c20cf3ba7741605ffbe01732f51e918d", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -171,3 +171,4 @@ infer_msl_introduces_static = introduces a `'static` lifetime requirement\n infer_msl_unmet_req = because this has an unmet lifetime requirement\n infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement\n+infer_suggest_add_let_for_letchains = consider adding `let`"}, {"sha": "6d42b23fb3a213b6db8495663dc23b0e4fb4898e", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -112,6 +112,9 @@ parser_missing_semicolon_before_array = expected `;`, found `[`\n parser_invalid_block_macro_segment = cannot use a `block` macro fragment here\n     .label = the `block` fragment is within this context\n \n+parser_expect_dotdot_not_dotdotdot = expected `..`, found `...`\n+    .suggestion = use `..` to fill in the rest of the fields\n+\n parser_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n     .add_then_block = add a block here\n     .condition_possibly_unfinished = this binary operation is possibly unfinished\n@@ -122,6 +125,9 @@ parser_if_expression_missing_condition = missing condition for `if` expression\n \n parser_expected_expression_found_let = expected expression, found `let` statement\n \n+parser_expect_eq_instead_of_eqeq = expected `=`, found `==`\n+    .suggestion = consider using `=` here\n+\n parser_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n     .label = expected an `if` or a block after this `else`\n     .suggestion = add an `if` if this is the condition of a chained `else if` statement"}, {"sha": "001e53d1d0e4ce52953539a295d5a3cf0ded2475", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -47,7 +47,10 @@ passes_no_coverage_not_coverable =\n \n passes_should_be_applied_to_fn =\n     attribute should be applied to a function definition\n-    .label = not a function definition\n+    .label = {$on_crate ->\n+        [true] cannot be applied to crates\n+        *[false] not a function definition\n+    }\n \n passes_naked_tracked_caller =\n     cannot use `#[track_caller]` with `#[naked]`"}, {"sha": "e34acba105776e461e74a5fb26031baec679f729", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -42,6 +42,7 @@ fluent_messages! {\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n     codegen_gcc => \"../locales/en-US/codegen_gcc.ftl\",\n+    codegen_llvm => \"../locales/en-US/codegen_llvm.ftl\",\n     codegen_ssa => \"../locales/en-US/codegen_ssa.ftl\",\n     compiletest => \"../locales/en-US/compiletest.ftl\",\n     const_eval => \"../locales/en-US/const_eval.ftl\","}, {"sha": "c450c276366e156220e09c14077eb72c23e4727b", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -52,7 +52,6 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n-            &self.source_map,\n             &mut primary_span,\n             &mut children,\n             &diag.level,"}, {"sha": "43101bbb9d31cf3de2fda20e7824592fa39e51c6", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -44,6 +44,15 @@ pub trait IntoDiagnosticArg {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static>;\n }\n \n+impl<'source> IntoDiagnosticArg for DiagnosticArgValue<'source> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        match self {\n+            DiagnosticArgValue::Str(s) => DiagnosticArgValue::Str(Cow::Owned(s.into_owned())),\n+            DiagnosticArgValue::Number(n) => DiagnosticArgValue::Number(n),\n+        }\n+    }\n+}\n+\n impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n     fn into(self) -> FluentValue<'source> {\n         match self {\n@@ -204,6 +213,22 @@ impl Diagnostic {\n         Diagnostic::new_with_code(level, None, message)\n     }\n \n+    #[track_caller]\n+    pub fn new_with_messages(level: Level, messages: Vec<(DiagnosticMessage, Style)>) -> Self {\n+        Diagnostic {\n+            level,\n+            message: messages,\n+            code: None,\n+            span: MultiSpan::new(),\n+            children: vec![],\n+            suggestions: Ok(vec![]),\n+            args: Default::default(),\n+            sort_span: DUMMY_SP,\n+            is_lint: false,\n+            emitted_at: DiagnosticLocation::caller(),\n+        }\n+    }\n+\n     #[track_caller]\n     pub fn new_with_code<M: Into<DiagnosticMessage>>(\n         level: Level,\n@@ -931,6 +956,13 @@ impl Diagnostic {\n         self\n     }\n \n+    pub fn replace_args(\n+        &mut self,\n+        args: FxHashMap<DiagnosticArgName<'static>, DiagnosticArgValue<'static>>,\n+    ) {\n+        self.args = args;\n+    }\n+\n     pub fn styled_message(&self) -> &[(DiagnosticMessage, Style)] {\n         &self.message\n     }"}, {"sha": "730061fca99369791a0791aebcab0aaa13baf36d", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -482,9 +482,9 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n     /// In the meantime, though, callsites are required to deal with the \"bug\"\n     /// locally in whichever way makes the most sense.\n     #[track_caller]\n-    pub fn delay_as_bug(&mut self) {\n+    pub fn delay_as_bug(&mut self) -> G {\n         self.downgrade_to_delayed_bug();\n-        self.emit();\n+        self.emit()\n     }\n \n     forward!("}, {"sha": "c6035705e39fa70d2022800fee8d488c82fb115b", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -107,6 +107,12 @@ impl IntoDiagnosticArg for String {\n     }\n }\n \n+impl<'a> IntoDiagnosticArg for Cow<'a, str> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.into_owned()))\n+    }\n+}\n+\n impl<'a> IntoDiagnosticArg for &'a Path {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(Cow::Owned(self.display().to_string()))"}, {"sha": "55c7997a513636bc38d48f8acfc74da9e3c61dd9", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -314,7 +314,6 @@ pub trait Emitter: Translate {\n \n     fn fix_multispans_in_extern_macros_and_render_macro_backtrace(\n         &self,\n-        source_map: &Option<Lrc<SourceMap>>,\n         span: &mut MultiSpan,\n         children: &mut Vec<SubDiagnostic>,\n         level: &Level,\n@@ -340,7 +339,7 @@ pub trait Emitter: Translate {\n             .collect();\n \n         if !backtrace {\n-            self.fix_multispans_in_extern_macros(source_map, span, children);\n+            self.fix_multispans_in_extern_macros(span, children);\n         }\n \n         self.render_multispans_macro_backtrace(span, children, backtrace);\n@@ -480,23 +479,22 @@ pub trait Emitter: Translate {\n     // this will change the span to point at the use site.\n     fn fix_multispans_in_extern_macros(\n         &self,\n-        source_map: &Option<Lrc<SourceMap>>,\n         span: &mut MultiSpan,\n         children: &mut Vec<SubDiagnostic>,\n     ) {\n-        let Some(source_map) = source_map else { return };\n         debug!(\"fix_multispans_in_extern_macros: before: span={:?} children={:?}\", span, children);\n-        self.fix_multispan_in_extern_macros(source_map, span);\n+        self.fix_multispan_in_extern_macros(span);\n         for child in children.iter_mut() {\n-            self.fix_multispan_in_extern_macros(source_map, &mut child.span);\n+            self.fix_multispan_in_extern_macros(&mut child.span);\n         }\n         debug!(\"fix_multispans_in_extern_macros: after: span={:?} children={:?}\", span, children);\n     }\n \n     // This \"fixes\" MultiSpans that contain `Span`s pointing to locations inside of external macros.\n     // Since these locations are often difficult to read,\n     // we move these spans from the external macros to their corresponding use site.\n-    fn fix_multispan_in_extern_macros(&self, source_map: &Lrc<SourceMap>, span: &mut MultiSpan) {\n+    fn fix_multispan_in_extern_macros(&self, span: &mut MultiSpan) {\n+        let Some(source_map) = self.source_map() else { return };\n         // First, find all the spans in external macros and point instead at their use site.\n         let replacements: Vec<(Span, Span)> = span\n             .primary_spans()\n@@ -544,7 +542,6 @@ impl Emitter for EmitterWriter {\n         debug!(\"emit_diagnostic: suggestions={:?}\", suggestions);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n-            &self.sm,\n             &mut primary_span,\n             &mut children,\n             &diag.level,\n@@ -2213,22 +2210,45 @@ impl FileWithAnnotatedLines {\n \n         if let Some(ref sm) = emitter.source_map() {\n             for span_label in msp.span_labels() {\n+                let fixup_lo_hi = |span: Span| {\n+                    let lo = sm.lookup_char_pos(span.lo());\n+                    let mut hi = sm.lookup_char_pos(span.hi());\n+\n+                    // Watch out for \"empty spans\". If we get a span like 6..6, we\n+                    // want to just display a `^` at 6, so convert that to\n+                    // 6..7. This is degenerate input, but it's best to degrade\n+                    // gracefully -- and the parser likes to supply a span like\n+                    // that for EOF, in particular.\n+\n+                    if lo.col_display == hi.col_display && lo.line == hi.line {\n+                        hi.col_display += 1;\n+                    }\n+                    (lo, hi)\n+                };\n+\n                 if span_label.span.is_dummy() {\n+                    if let Some(span) = msp.primary_span() {\n+                        // if we don't know where to render the annotation, emit it as a note\n+                        // on the primary span.\n+\n+                        let (lo, hi) = fixup_lo_hi(span);\n+\n+                        let ann = Annotation {\n+                            start_col: lo.col_display,\n+                            end_col: hi.col_display,\n+                            is_primary: span_label.is_primary,\n+                            label: span_label\n+                                .label\n+                                .as_ref()\n+                                .map(|m| emitter.translate_message(m, args).to_string()),\n+                            annotation_type: AnnotationType::Singleline,\n+                        };\n+                        add_annotation_to_file(&mut output, lo.file, lo.line, ann);\n+                    }\n                     continue;\n                 }\n \n-                let lo = sm.lookup_char_pos(span_label.span.lo());\n-                let mut hi = sm.lookup_char_pos(span_label.span.hi());\n-\n-                // Watch out for \"empty spans\". If we get a span like 6..6, we\n-                // want to just display a `^` at 6, so convert that to\n-                // 6..7. This is degenerate input, but it's best to degrade\n-                // gracefully -- and the parser likes to supply a span like\n-                // that for EOF, in particular.\n-\n-                if lo.col_display == hi.col_display && lo.line == hi.line {\n-                    hi.col_display += 1;\n-                }\n+                let (lo, hi) = fixup_lo_hi(span_label.span);\n \n                 if lo.line != hi.line {\n                     let ml = MultilineAnnotation {"}, {"sha": "c2aa096a993154a399c38820345c03d4a9ae51e1", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -191,6 +191,8 @@ declare_features! (\n     (accepted, infer_outlives_requirements, \"1.30.0\", Some(44493), None),\n     /// Allows irrefutable patterns in `if let` and `while let` statements (RFC 2086).\n     (accepted, irrefutable_let_patterns, \"1.33.0\", Some(44495), None),\n+    /// Allows `#[instruction_set(_)]` attribute.\n+    (accepted, isa_attribute, \"CURRENT_RUSTC_VERSION\", Some(74727), None),\n     /// Allows some increased flexibility in the name resolution rules,\n     /// especially around globs and shadowing (RFC 1560).\n     (accepted, item_like_imports, \"1.15.0\", Some(35120), None),"}, {"sha": "e94e038f9283b701a2d73d2481329b772ecf4ea1", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -152,6 +152,8 @@ declare_features! (\n     (active, anonymous_lifetime_in_impl_trait, \"1.63.0\", None, None),\n     /// Allows identifying the `compiler_builtins` crate.\n     (active, compiler_builtins, \"1.13.0\", None, None),\n+    /// Allows writing custom MIR\n+    (active, custom_mir, \"1.65.0\", None, None),\n     /// Outputs useful `assert!` messages\n     (active, generic_assert, \"1.63.0\", None, None),\n     /// Allows using the `rust-intrinsic`'s \"ABI\".\n@@ -427,8 +429,6 @@ declare_features! (\n     (incomplete, inline_const_pat, \"1.58.0\", Some(76001), None),\n     /// Allows using `pointer` and `reference` in intra-doc links\n     (active, intra_doc_pointers, \"1.51.0\", Some(80896), None),\n-    /// Allows `#[instruction_set(_)]` attribute\n-    (active, isa_attribute, \"1.48.0\", Some(74727), None),\n     // Allows setting the threshold for the `large_assignments` lint.\n     (active, large_assignments, \"1.52.0\", Some(83518), None),\n     /// Allows `if/while p && let q = r && ...` chains."}, {"sha": "dc3a74956843eb86c36f5b7e3dff6d0d33027ade", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -391,6 +391,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         DuplicatesOk, @only_local: true,\n     ),\n     ungated!(track_caller, Normal, template!(Word), WarnFollowing),\n+    ungated!(instruction_set, Normal, template!(List: \"set\"), ErrorPreceding),\n     gated!(\n         no_sanitize, Normal,\n         template!(List: \"address, memory, thread\"), DuplicatesOk,\n@@ -452,11 +453,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         optimize, Normal, template!(List: \"size|speed\"), ErrorPreceding, optimize_attribute,\n         experimental!(optimize),\n     ),\n-    // RFC 2867\n-    gated!(\n-        instruction_set, Normal, template!(List: \"set\"), ErrorPreceding,\n-        isa_attribute, experimental!(instruction_set)\n-    ),\n \n     gated!(\n         ffi_returns_twice, Normal, template!(Word), WarnFollowing, experimental!(ffi_returns_twice)\n@@ -814,6 +810,10 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_polymorphize_error, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_def_path, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_mir, Normal, template!(List: \"arg1, arg2, ...\"), DuplicatesOk),\n+    gated!(\n+        custom_mir, Normal, template!(List: r#\"dialect = \"...\", phase = \"...\"\"#),\n+        ErrorFollowing, \"the `#[custom_mir]` attribute is just used for the Rust test suite\",\n+    ),\n     rustc_attr!(TEST, rustc_dump_program_clauses, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_dump_env_program_clauses, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_object_lifetime_default, Normal, template!(Word), WarnFollowing),"}, {"sha": "82e260d158bc468acb5ec56372e53e49e1a4fb82", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -388,6 +388,8 @@ impl<'hir> GenericArgs<'hir> {\n     }\n \n     #[inline]\n+    /// This function returns the number of type and const generic params.\n+    /// It should only be used for diagnostics.\n     pub fn num_generic_params(&self) -> usize {\n         self.args.iter().filter(|arg| !matches!(arg, GenericArg::Lifetime(_))).count()\n     }"}, {"sha": "4518cf30acdd5fda428c2fa7d3ef6e9f26bacb84", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -274,7 +274,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             item_segment.args(),\n             item_segment.infer_args,\n             None,\n-            None,\n+            ty::BoundConstness::NotConst,\n         );\n         if let Some(b) = item_segment.args().bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n@@ -324,7 +324,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n-        constness: Option<ty::BoundConstness>,\n+        constness: ty::BoundConstness,\n     ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n@@ -538,7 +538,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             &mut substs_ctx,\n         );\n \n-        if let Some(ty::BoundConstness::ConstIfConst) = constness\n+        if let ty::BoundConstness::ConstIfConst = constness\n             && generics.has_self && !tcx.has_attr(def_id, sym::const_trait)\n         {\n             tcx.sess.emit_err(crate::errors::ConstBoundForNonConstTrait { span } );\n@@ -611,7 +611,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             item_segment.args(),\n             item_segment.infer_args,\n             None,\n-            None,\n+            ty::BoundConstness::NotConst,\n         );\n \n         if let Some(b) = item_segment.args().bindings.first() {\n@@ -641,7 +641,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             self_ty,\n             trait_ref.path.segments.last().unwrap(),\n             true,\n-            Some(constness),\n+            constness,\n         )\n     }\n \n@@ -668,7 +668,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             args,\n             infer_args,\n             Some(self_ty),\n-            Some(constness),\n+            constness,\n         );\n \n         let tcx = self.tcx();\n@@ -798,7 +798,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         trait_segment: &hir::PathSegment<'_>,\n         is_impl: bool,\n-        constness: Option<ty::BoundConstness>,\n+        constness: ty::BoundConstness,\n     ) -> ty::TraitRef<'tcx> {\n         let (substs, _) = self.create_substs_for_ast_trait_ref(\n             span,\n@@ -822,7 +822,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment<'a>,\n         is_impl: bool,\n-        constness: Option<ty::BoundConstness>,\n+        constness: ty::BoundConstness,\n     ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment, is_impl);\n \n@@ -1201,7 +1201,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     (_, _) => {\n                         let got = if let Some(_) = term.ty() { \"type\" } else { \"constant\" };\n                         let expected = def_kind.descr(assoc_item_def_id);\n-                        tcx.sess\n+                        let reported = tcx\n+                            .sess\n                             .struct_span_err(\n                                 binding.span,\n                                 &format!(\"expected {expected} bound, found {got}\"),\n@@ -1212,11 +1213,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             )\n                             .emit();\n                         term = match def_kind {\n-                            hir::def::DefKind::AssocTy => tcx.ty_error().into(),\n+                            hir::def::DefKind::AssocTy => {\n+                                tcx.ty_error_with_guaranteed(reported).into()\n+                            }\n                             hir::def::DefKind::AssocConst => tcx\n-                                .const_error(\n+                                .const_error_with_guaranteed(\n                                     tcx.bound_type_of(assoc_item_def_id)\n                                         .subst(tcx, projection_ty.skip_binder().substs),\n+                                    reported,\n                                 )\n                                 .into(),\n                             _ => unreachable!(),\n@@ -1334,8 +1338,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .map(|&(trait_ref, _, _)| trait_ref.def_id())\n                 .find(|&trait_ref| tcx.is_trait_alias(trait_ref))\n                 .map(|trait_ref| tcx.def_span(trait_ref));\n-            tcx.sess.emit_err(TraitObjectDeclaredWithNoTraits { span, trait_alias_span });\n-            return tcx.ty_error();\n+            let reported =\n+                tcx.sess.emit_err(TraitObjectDeclaredWithNoTraits { span, trait_alias_span });\n+            return tcx.ty_error_with_guaranteed(reported);\n         }\n \n         // Check that there are no gross object safety violations;\n@@ -1345,14 +1350,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let object_safety_violations =\n                 astconv_object_safety_violations(tcx, item.trait_ref().def_id());\n             if !object_safety_violations.is_empty() {\n-                report_object_safety_error(\n+                let reported = report_object_safety_error(\n                     tcx,\n                     span,\n                     item.trait_ref().def_id(),\n                     &object_safety_violations,\n                 )\n                 .emit();\n-                return tcx.ty_error();\n+                return tcx.ty_error_with_guaranteed(reported);\n             }\n         }\n \n@@ -2112,13 +2117,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 \"Type\"\n             };\n \n-            self.report_ambiguous_associated_type(\n+            let reported = self.report_ambiguous_associated_type(\n                 span,\n                 type_name,\n                 &path_str,\n                 item_segment.ident.name,\n             );\n-            return tcx.ty_error();\n+            return tcx.ty_error_with_guaranteed(reported)\n         };\n \n         debug!(\"qpath_to_ty: self_type={:?}\", self_ty);\n@@ -2129,7 +2134,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             self_ty,\n             trait_segment,\n             false,\n-            Some(constness),\n+            constness,\n         );\n \n         let item_substs = self.create_substs_for_associated_item(\n@@ -2560,8 +2565,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     {\n                         err.span_note(impl_.self_ty.span, \"not a concrete type\");\n                     }\n-                    err.emit();\n-                    tcx.ty_error()\n+                    tcx.ty_error_with_guaranteed(err.emit())\n                 } else {\n                     self.normalize_ty(span, ty)\n                 }\n@@ -2700,7 +2704,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     &GenericArgs::none(),\n                     true,\n                     None,\n-                    None,\n+                    ty::BoundConstness::NotConst,\n                 );\n                 EarlyBinder(self.normalize_ty(span, tcx.at(span).type_of(def_id)))\n                     .subst(tcx, substs)\n@@ -2976,15 +2980,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) {\n         for br in referenced_regions.difference(&constrained_regions) {\n             let br_name = match *br {\n-                ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(_) | ty::BrEnv => {\n+                ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(..) | ty::BrEnv => {\n                     \"an anonymous lifetime\".to_string()\n                 }\n                 ty::BrNamed(_, name) => format!(\"lifetime `{}`\", name),\n             };\n \n             let mut err = generate_err(&br_name);\n \n-            if let ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(_) = *br {\n+            if let ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(..) = *br {\n                 // The only way for an anonymous lifetime to wind up\n                 // in the return type but **also** be unconstrained is\n                 // if it only appears in \"associated types\" in the"}, {"sha": "0ba5e61510125d10e187a6269996729c21b46280", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -26,6 +26,7 @@ use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVE\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedDirective;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n@@ -471,7 +472,7 @@ fn check_opaque_meets_bounds<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n     }\n     match origin {\n         // Checked when type checking the function containing them.\n@@ -655,7 +656,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n \n pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedDirective::of_item(tcx, item.owner_id.to_def_id());\n+    let _ = OnUnimplementedDirective::of_item(tcx, item.owner_id.to_def_id());\n }\n \n pub(super) fn check_specialization_validity<'tcx>("}, {"sha": "04bf7c83b3208db9f56a14829de908370d9124fe", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,7 +1,7 @@\n use super::potentially_plural_count;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n use hir::def_id::{DefId, LocalDefId};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -256,7 +256,7 @@ fn compare_predicate_entailment<'tcx>(\n     // Compute placeholder form of impl and trait method tys.\n     let tcx = infcx.tcx;\n \n-    let mut wf_tys = FxHashSet::default();\n+    let mut wf_tys = FxIndexSet::default();\n \n     let impl_sig = infcx.replace_bound_vars_with_fresh_vars(\n         impl_m_span,\n@@ -405,7 +405,7 @@ fn compare_predicate_entailment<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return Err(reported);\n     }\n \n@@ -479,7 +479,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     let trait_sig = ocx.normalize(norm_cause.clone(), param_env, unnormalized_trait_sig);\n     let trait_return_ty = trait_sig.output();\n \n-    let wf_tys = FxHashSet::from_iter(\n+    let wf_tys = FxIndexSet::from_iter(\n         unnormalized_trait_sig.inputs_and_output.iter().chain(trait_sig.inputs_and_output.iter()),\n     );\n \n@@ -538,7 +538,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     // RPITs.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return Err(reported);\n     }\n \n@@ -611,11 +611,11 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n                 collected_tys.insert(def_id, ty);\n             }\n             Err(err) => {\n-                tcx.sess.delay_span_bug(\n+                let reported = tcx.sess.delay_span_bug(\n                     return_span,\n                     format!(\"could not fully resolve: {ty} => {err:?}\"),\n                 );\n-                collected_tys.insert(def_id, tcx.ty_error());\n+                collected_tys.insert(def_id, tcx.ty_error_with_guaranteed(reported));\n             }\n         }\n     }\n@@ -1431,7 +1431,7 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        return Err(infcx.err_ctxt().report_fulfillment_errors(&errors, None, false));\n+        return Err(infcx.err_ctxt().report_fulfillment_errors(&errors, None));\n     }\n \n     // FIXME return `ErrorReported` if region obligations error?\n@@ -1549,7 +1549,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return Err(reported);\n     }\n \n@@ -1769,7 +1769,7 @@ pub fn check_type_bounds<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return Err(reported);\n     }\n "}, {"sha": "69e54b41d4c04331081c51aaa179e1bf75f00441", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -134,15 +134,18 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let name_str = intrinsic_name.as_str();\n \n     let bound_vars = tcx.mk_bound_variable_kinds(\n-        [ty::BoundVariableKind::Region(ty::BrAnon(0)), ty::BoundVariableKind::Region(ty::BrEnv)]\n-            .iter()\n-            .copied(),\n+        [\n+            ty::BoundVariableKind::Region(ty::BrAnon(0, None)),\n+            ty::BoundVariableKind::Region(ty::BrEnv),\n+        ]\n+        .iter()\n+        .copied(),\n     );\n     let mk_va_list_ty = |mutbl| {\n         tcx.lang_items().va_list().map(|did| {\n             let region = tcx.mk_region(ty::ReLateBound(\n                 ty::INNERMOST,\n-                ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0) },\n+                ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0, None) },\n             ));\n             let env_region = tcx.mk_region(ty::ReLateBound(\n                 ty::INNERMOST,\n@@ -364,7 +367,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 );\n                 let discriminant_def_id = assoc_items[0];\n \n-                let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0) };\n+                let br =\n+                    ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0, None) };\n                 (\n                     1,\n                     vec![\n@@ -418,7 +422,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             sym::nontemporal_store => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n             sym::raw_eq => {\n-                let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0) };\n+                let br =\n+                    ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0, None) };\n                 let param_ty =\n                     tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)), param(0));\n                 (1, vec![param_ty; 2], tcx.types.bool)"}, {"sha": "8a70f41c8a840e0576a9e35232fa0a1511fccf84", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,7 +1,7 @@\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n use hir::def::DefKind;\n use rustc_ast as ast;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -21,6 +21,7 @@ use rustc_middle::ty::{GenericArgKind, InternalSubsts};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n@@ -104,7 +105,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n     f(&mut wfcx);\n     let errors = wfcx.select_all_or_error();\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return;\n     }\n \n@@ -411,7 +412,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                                 .iter()\n                                 .copied()\n                                 .collect::<Vec<_>>(),\n-                            &FxHashSet::default(),\n+                            &FxIndexSet::default(),\n                             gat_def_id.def_id,\n                             gat_generics,\n                         )\n@@ -461,10 +462,10 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n             .into_iter()\n             .filter(|clause| match clause.kind().skip_binder() {\n                 ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    !region_known_to_outlive(tcx, gat_hir, param_env, &FxHashSet::default(), a, b)\n+                    !region_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b)\n                 }\n                 ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n-                    !ty_known_to_outlive(tcx, gat_hir, param_env, &FxHashSet::default(), a, b)\n+                    !ty_known_to_outlive(tcx, gat_hir, param_env, &FxIndexSet::default(), a, b)\n                 }\n                 _ => bug!(\"Unexpected PredicateKind\"),\n             })\n@@ -546,7 +547,7 @@ fn gather_gat_bounds<'tcx, T: TypeFoldable<'tcx>>(\n     param_env: ty::ParamEnv<'tcx>,\n     item_hir: hir::HirId,\n     to_check: T,\n-    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    wf_tys: &FxIndexSet<Ty<'tcx>>,\n     gat_def_id: LocalDefId,\n     gat_generics: &'tcx ty::Generics,\n ) -> Option<FxHashSet<ty::Predicate<'tcx>>> {\n@@ -653,7 +654,7 @@ fn ty_known_to_outlive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n-    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    wf_tys: &FxIndexSet<Ty<'tcx>>,\n     ty: Ty<'tcx>,\n     region: ty::Region<'tcx>,\n ) -> bool {\n@@ -670,7 +671,7 @@ fn region_known_to_outlive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n-    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    wf_tys: &FxIndexSet<Ty<'tcx>>,\n     region_a: ty::Region<'tcx>,\n     region_b: ty::Region<'tcx>,\n ) -> bool {\n@@ -694,7 +695,7 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n-    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    wf_tys: &FxIndexSet<Ty<'tcx>>,\n     add_constraints: impl for<'a> FnOnce(&'a InferCtxt<'tcx>, &'a RegionBoundPairs<'tcx>),\n ) -> bool {\n     // Unfortunately, we have to use a new `InferCtxt` each call, because\n@@ -1542,6 +1543,33 @@ fn check_fn_or_method<'tcx>(\n         sig.output(),\n         hir_decl.output.span(),\n     );\n+\n+    if sig.abi == Abi::RustCall {\n+        let span = tcx.def_span(def_id);\n+        let has_implicit_self = hir_decl.implicit_self != hir::ImplicitSelfKind::None;\n+        let mut inputs = sig.inputs().iter().skip(if has_implicit_self { 1 } else { 0 });\n+        // Check that the argument is a tuple\n+        if let Some(ty) = inputs.next() {\n+            wfcx.register_bound(\n+                ObligationCause::new(span, wfcx.body_id, ObligationCauseCode::RustCall),\n+                wfcx.param_env,\n+                *ty,\n+                tcx.require_lang_item(hir::LangItem::Tuple, Some(span)),\n+            );\n+        } else {\n+            tcx.sess.span_err(\n+                hir_decl.inputs.last().map_or(span, |input| input.span),\n+                \"functions with the \\\"rust-call\\\" ABI must take a single non-self tuple argument\",\n+            );\n+        }\n+        // No more inputs other than the `self` type and the tuple type\n+        if inputs.next().is_some() {\n+            tcx.sess.span_err(\n+                hir_decl.inputs.last().map_or(span, |input| input.span),\n+                \"functions with the \\\"rust-call\\\" ABI must take a single non-self tuple argument\",\n+            );\n+        }\n+    }\n }\n \n /// Basically `check_associated_type_bounds`, but separated for now and should be\n@@ -1680,8 +1708,7 @@ fn receiver_is_valid<'tcx>(\n         return true;\n     }\n \n-    let mut autoderef =\n-        Autoderef::new(infcx, wfcx.param_env, wfcx.body_id, span, receiver_ty, span);\n+    let mut autoderef = Autoderef::new(infcx, wfcx.param_env, wfcx.body_id, span, receiver_ty);\n \n     // The `arbitrary_self_types` feature allows raw pointer receivers like `self: *const Self`.\n     if arbitrary_self_types_enabled {"}, {"sha": "6f74ef3ccad6d75684c5576e5861fb83ac38425f", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -321,7 +321,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n                     }),\n                 );\n                 if !errors.is_empty() {\n-                    infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+                    infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n                 }\n \n                 // Finally, resolve all regions.\n@@ -561,7 +561,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n         predicate_for_trait_def(tcx, param_env, cause, trait_def_id, 0, source, &[target.into()]);\n     let errors = traits::fully_solve_obligation(&infcx, predicate);\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n     }\n \n     // Finally, resolve all regions."}, {"sha": "4bca16c3a1ccef74d54f21cb22dd419055b6e7a7", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -512,8 +512,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n                 }\n                 _ => {}\n             }\n-            err.emit();\n-            self.tcx().ty_error()\n+            self.tcx().ty_error_with_guaranteed(err.emit())\n         }\n     }\n "}, {"sha": "c64177eea3f831f388189c3879f89ef9aa9c8567", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 99, "deletions": 5, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::bug;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n-use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, TyCtxt, TypeSuperVisitable, TypeVisitor};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -1781,7 +1781,7 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n \n     let mut late_bound = FxIndexSet::default();\n \n-    let mut constrained_by_input = ConstrainedCollector::default();\n+    let mut constrained_by_input = ConstrainedCollector { regions: Default::default(), tcx };\n     for arg_ty in decl.inputs {\n         constrained_by_input.visit_ty(arg_ty);\n     }\n@@ -1834,12 +1834,65 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n     debug!(?late_bound);\n     return Some(tcx.arena.alloc(late_bound));\n \n-    #[derive(Default)]\n-    struct ConstrainedCollector {\n+    /// Visits a `ty::Ty` collecting information about what generic parameters are constrained.\n+    ///\n+    /// The visitor does not operate on `hir::Ty` so that it can be called on the rhs of a `type Alias<...> = ...;`\n+    /// which may live in a separate crate so there would not be any hir available. Instead we use the `type_of`\n+    /// query to obtain a `ty::Ty` which will be present even in cross crate scenarios. It also naturally\n+    /// handles cycle detection as we go through the query system.\n+    ///\n+    /// This is necessary in the first place for the following case:\n+    /// ```\n+    /// type Alias<'a, T> = <T as Trait<'a>>::Assoc;\n+    /// fn foo<'a>(_: Alias<'a, ()>) -> Alias<'a, ()> { ... }\n+    /// ```\n+    ///\n+    /// If we conservatively considered `'a` unconstrained then we could break users who had written code before\n+    /// we started correctly handling aliases. If we considered `'a` constrained then it would become late bound\n+    /// causing an error during astconv as the `'a` is not constrained by the input type `<() as Trait<'a>>::Assoc`\n+    /// but appears in the output type `<() as Trait<'a>>::Assoc`.\n+    ///\n+    /// We must therefore \"look into\" the `Alias` to see whether we should consider `'a` constrained or not.\n+    ///\n+    /// See #100508 #85533 #47511 for additional context\n+    struct ConstrainedCollectorPostAstConv {\n+        arg_is_constrained: Box<[bool]>,\n+    }\n+\n+    use std::ops::ControlFlow;\n+    use ty::Ty;\n+    impl<'tcx> TypeVisitor<'tcx> for ConstrainedCollectorPostAstConv {\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<!> {\n+            match t.kind() {\n+                ty::Param(param_ty) => {\n+                    self.arg_is_constrained[param_ty.index as usize] = true;\n+                }\n+                ty::Projection(_) => return ControlFlow::Continue(()),\n+                _ => (),\n+            }\n+            t.super_visit_with(self)\n+        }\n+\n+        fn visit_const(&mut self, _: ty::Const<'tcx>) -> ControlFlow<!> {\n+            ControlFlow::Continue(())\n+        }\n+\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<!> {\n+            debug!(\"r={:?}\", r.kind());\n+            if let ty::RegionKind::ReEarlyBound(region) = r.kind() {\n+                self.arg_is_constrained[region.index as usize] = true;\n+            }\n+\n+            ControlFlow::Continue(())\n+        }\n+    }\n+\n+    struct ConstrainedCollector<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n         regions: FxHashSet<LocalDefId>,\n     }\n \n-    impl<'v> Visitor<'v> for ConstrainedCollector {\n+    impl<'v> Visitor<'v> for ConstrainedCollector<'_> {\n         fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n             match ty.kind {\n                 hir::TyKind::Path(\n@@ -1850,6 +1903,47 @@ fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxIndexSet<\n                     // (defined above)\n                 }\n \n+                hir::TyKind::Path(hir::QPath::Resolved(\n+                    None,\n+                    hir::Path { res: Res::Def(DefKind::TyAlias, alias_def), segments, span },\n+                )) => {\n+                    // See comments on `ConstrainedCollectorPostAstConv` for why this arm does not just consider\n+                    // substs to be unconstrained.\n+                    let generics = self.tcx.generics_of(alias_def);\n+                    let mut walker = ConstrainedCollectorPostAstConv {\n+                        arg_is_constrained: vec![false; generics.params.len()].into_boxed_slice(),\n+                    };\n+                    walker.visit_ty(self.tcx.type_of(alias_def));\n+\n+                    match segments.last() {\n+                        Some(hir::PathSegment { args: Some(args), .. }) => {\n+                            let tcx = self.tcx;\n+                            for constrained_arg in\n+                                args.args.iter().enumerate().flat_map(|(n, arg)| {\n+                                    match walker.arg_is_constrained.get(n) {\n+                                        Some(true) => Some(arg),\n+                                        Some(false) => None,\n+                                        None => {\n+                                            tcx.sess.delay_span_bug(\n+                                                *span,\n+                                                format!(\n+                                                    \"Incorrect generic arg count for alias {:?}\",\n+                                                    alias_def\n+                                                ),\n+                                            );\n+                                            None\n+                                        }\n+                                    }\n+                                })\n+                            {\n+                                self.visit_generic_arg(constrained_arg);\n+                            }\n+                        }\n+                        Some(_) => (),\n+                        None => bug!(\"Path with no segments or self type\"),\n+                    }\n+                }\n+\n                 hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                     // consider only the lifetimes on the final\n                     // segment; I am not sure it's even currently"}, {"sha": "2402495c2e4a6ffde84ea918a633705408a27c27", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -698,7 +698,7 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n     }\n \n     let Some(hidden) = locator.found else {\n-        tcx.sess.emit_err(UnconstrainedOpaqueType {\n+        let reported = tcx.sess.emit_err(UnconstrainedOpaqueType {\n             span: tcx.def_span(def_id),\n             name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n             what: match tcx.hir().get(scope) {\n@@ -708,7 +708,7 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n                 _ => \"item\",\n             },\n         });\n-        return tcx.ty_error();\n+        return tcx.ty_error_with_guaranteed(reported);\n     };\n \n     // Only check against typeck if we didn't already error"}, {"sha": "267077cdab4e62abe8f2a839445dc1e5df76f684", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -155,7 +155,7 @@ fn get_impl_substs<'tcx>(\n \n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        ocx.infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        ocx.infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return None;\n     }\n "}, {"sha": "664d3a3a1db84c3d5e8cefd394ee650daaff1613", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -173,7 +173,7 @@ fn require_same_types<'tcx>(\n     match &errors[..] {\n         [] => true,\n         errors => {\n-            infcx.err_ctxt().report_fulfillment_errors(errors, None, false);\n+            infcx.err_ctxt().report_fulfillment_errors(errors, None);\n             false\n         }\n     }\n@@ -336,7 +336,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         ocx.register_bound(cause, param_env, norm_return_ty, term_did);\n         let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n-            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n             error = true;\n         }\n         // now we can take the return type of the given main function"}, {"sha": "6a4a6a5b0a546716721f3bf2d9ec77cbd0a6ed5a", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 73, "deletions": 50, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,6 +1,6 @@\n use crate::coercion::{AsCoercionSite, CoerceMany};\n use crate::{Diverges, Expectation, FnCtxt, Needs};\n-use rustc_errors::{Applicability, MultiSpan};\n+use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n@@ -137,55 +137,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(&arm.body),\n                 arm_ty,\n                 Some(&mut |err| {\n-                    let Some(ret) = self\n-                        .tcx\n-                        .hir()\n-                        .find_by_def_id(self.body_id.owner.def_id)\n-                        .and_then(|owner| owner.fn_decl())\n-                        .map(|decl| decl.output.span())\n-                    else { return; };\n-                    let Expectation::IsLast(stmt) = orig_expected else {\n-                        return\n-                    };\n-                    let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n-                        Some(ret_coercion) if self.in_tail_expr => {\n-                            let ret_ty = ret_coercion.borrow().expected_ty();\n-                            let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n-                            self.can_coerce(arm_ty, ret_ty)\n-                                && prior_arm.map_or(true, |(_, t, _)| self.can_coerce(t, ret_ty))\n-                                // The match arms need to unify for the case of `impl Trait`.\n-                                && !matches!(ret_ty.kind(), ty::Opaque(..))\n-                        }\n-                        _ => false,\n-                    };\n-                    if !can_coerce_to_return_ty {\n-                        return;\n-                    }\n-\n-                    let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n-                    let mut ret_span: MultiSpan = semi_span.into();\n-                    ret_span.push_span_label(\n-                        expr.span,\n-                        \"this could be implicitly returned but it is a statement, not a \\\n-                            tail expression\",\n-                    );\n-                    ret_span\n-                        .push_span_label(ret, \"the `match` arms can conform to this return type\");\n-                    ret_span.push_span_label(\n-                        semi_span,\n-                        \"the `match` is a statement because of this semicolon, consider \\\n-                            removing it\",\n-                    );\n-                    err.span_note(\n-                        ret_span,\n-                        \"you might have meant to return the `match` expression\",\n-                    );\n-                    err.tool_only_span_suggestion(\n-                        semi_span,\n-                        \"remove this semicolon\",\n-                        \"\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    self.suggest_removing_semicolon_for_coerce(\n+                        err,\n+                        expr,\n+                        orig_expected,\n+                        arm_ty,\n+                        prior_arm,\n+                    )\n                 }),\n                 false,\n             );\n@@ -219,6 +177,71 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         coercion.complete(self)\n     }\n \n+    fn suggest_removing_semicolon_for_coerce(\n+        &self,\n+        diag: &mut Diagnostic,\n+        expr: &hir::Expr<'tcx>,\n+        expectation: Expectation<'tcx>,\n+        arm_ty: Ty<'tcx>,\n+        prior_arm: Option<(Option<hir::HirId>, Ty<'tcx>, Span)>,\n+    ) {\n+        let hir = self.tcx.hir();\n+\n+        // First, check that we're actually in the tail of a function.\n+        let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Block(block, _), .. }) =\n+            hir.get(self.body_id) else { return; };\n+        let Some(hir::Stmt { kind: hir::StmtKind::Semi(last_expr), .. })\n+            = block.innermost_block().stmts.last() else {  return; };\n+        if last_expr.hir_id != expr.hir_id {\n+            return;\n+        }\n+\n+        // Next, make sure that we have no type expectation.\n+        let Some(ret) = hir\n+            .find_by_def_id(self.body_id.owner.def_id)\n+            .and_then(|owner| owner.fn_decl())\n+            .map(|decl| decl.output.span()) else { return; };\n+        let Expectation::IsLast(stmt) = expectation else {\n+            return;\n+        };\n+\n+        let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n+            Some(ret_coercion) => {\n+                let ret_ty = ret_coercion.borrow().expected_ty();\n+                let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n+                self.can_coerce(arm_ty, ret_ty)\n+                    && prior_arm.map_or(true, |(_, ty, _)| self.can_coerce(ty, ret_ty))\n+                    // The match arms need to unify for the case of `impl Trait`.\n+                    && !matches!(ret_ty.kind(), ty::Opaque(..))\n+            }\n+            _ => false,\n+        };\n+        if !can_coerce_to_return_ty {\n+            return;\n+        }\n+\n+        let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n+        let mut ret_span: MultiSpan = semi_span.into();\n+        ret_span.push_span_label(\n+            expr.span,\n+            \"this could be implicitly returned but it is a statement, not a \\\n+                            tail expression\",\n+        );\n+        ret_span.push_span_label(ret, \"the `match` arms can conform to this return type\");\n+        ret_span.push_span_label(\n+            semi_span,\n+            \"the `match` is a statement because of this semicolon, consider \\\n+                            removing it\",\n+        );\n+        diag.span_note(ret_span, \"you might have meant to return the `match` expression\");\n+        diag.tool_only_span_suggestion(\n+            semi_span,\n+            \"remove this semicolon\",\n+            \"\",\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n     fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm<'tcx>]) {"}, {"sha": "41b52a4c4a9fcb2901c2f26a1562e65faae1a7b3", "filename": "compiler/rustc_hir_typeck/src/autoderef.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -12,18 +12,7 @@ use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn autoderef(&'a self, span: Span, base_ty: Ty<'tcx>) -> Autoderef<'a, 'tcx> {\n-        Autoderef::new(self, self.param_env, self.body_id, span, base_ty, span)\n-    }\n-\n-    /// Like `autoderef`, but provides a custom `Span` to use for calls to\n-    /// an overloaded `Deref` operator\n-    pub fn autoderef_overloaded_span(\n-        &'a self,\n-        span: Span,\n-        base_ty: Ty<'tcx>,\n-        overloaded_span: Span,\n-    ) -> Autoderef<'a, 'tcx> {\n-        Autoderef::new(self, self.param_env, self.body_id, span, base_ty, overloaded_span)\n+        Autoderef::new(self, self.param_env, self.body_id, span, base_ty)\n     }\n \n     pub fn try_overloaded_deref(\n@@ -55,11 +44,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         |InferOk { value: method, obligations: o }| {\n                             obligations.extend(o);\n                             if let ty::Ref(region, _, mutbl) = *method.sig.output().kind() {\n-                                Some(OverloadedDeref {\n-                                    region,\n-                                    mutbl,\n-                                    span: autoderef.overloaded_span(),\n-                                })\n+                                Some(OverloadedDeref { region, mutbl, span: autoderef.span() })\n                             } else {\n                                 None\n                             }"}, {"sha": "2b019c8c9b7a581f09facce0ee0c90845c9ebe0c", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -129,6 +129,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         output\n     }\n \n+    #[instrument(level = \"debug\", skip(self, call_expr, callee_expr, arg_exprs, autoderef), ret)]\n     fn try_overloaded_call_step(\n         &self,\n         call_expr: &'tcx hir::Expr<'tcx>,\n@@ -138,10 +139,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Option<CallStep<'tcx>> {\n         let adjusted_ty =\n             self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n-        debug!(\n-            \"try_overloaded_call_step(call_expr={:?}, adjusted_ty={:?})\",\n-            call_expr, adjusted_ty\n-        );\n \n         // If the callee is a bare function or a closure, then we're all set.\n         match *adjusted_ty.kind() {\n@@ -471,6 +468,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             def_id,\n         );\n \n+        if fn_sig.abi == abi::Abi::RustCall {\n+            let sp = arg_exprs.last().map_or(call_expr.span, |expr| expr.span);\n+            if let Some(ty) = fn_sig.inputs().last().copied() {\n+                self.register_bound(\n+                    ty,\n+                    self.tcx.require_lang_item(hir::LangItem::Tuple, Some(sp)),\n+                    traits::ObligationCause::new(sp, self.body_id, traits::RustCall),\n+                );\n+            } else {\n+                self.tcx.sess.span_err(\n+                        sp,\n+                        \"functions with the \\\"rust-call\\\" ABI must take a single non-self tuple argument\",\n+                    );\n+            }\n+        }\n+\n         fn_sig.output()\n     }\n "}, {"sha": "3c57e33f6f7fb164e10213569cf5a32cd538343c", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -6,13 +6,11 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{ImplicitSelfKind, ItemKind, Node};\n use rustc_hir_analysis::check::fn_maybe_err;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::RegionVariableOrigin;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::LocalDefId;\n-use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use std::cell::RefCell;\n \n@@ -56,41 +54,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     fn_maybe_err(tcx, span, fn_sig.abi);\n \n-    if fn_sig.abi == Abi::RustCall {\n-        let expected_args = if let ImplicitSelfKind::None = decl.implicit_self { 1 } else { 2 };\n-\n-        let err = || {\n-            let item = match tcx.hir().get(fn_id) {\n-                Node::Item(hir::Item { kind: ItemKind::Fn(header, ..), .. }) => Some(header),\n-                Node::ImplItem(hir::ImplItem {\n-                    kind: hir::ImplItemKind::Fn(header, ..), ..\n-                }) => Some(header),\n-                Node::TraitItem(hir::TraitItem {\n-                    kind: hir::TraitItemKind::Fn(header, ..),\n-                    ..\n-                }) => Some(header),\n-                // Closures are RustCall, but they tuple their arguments, so shouldn't be checked\n-                Node::Expr(hir::Expr { kind: hir::ExprKind::Closure { .. }, .. }) => None,\n-                node => bug!(\"Item being checked wasn't a function/closure: {:?}\", node),\n-            };\n-\n-            if let Some(header) = item {\n-                tcx.sess.span_err(header.span, \"functions with the \\\"rust-call\\\" ABI must take a single non-self argument that is a tuple\");\n-            }\n-        };\n-\n-        if fn_sig.inputs().len() != expected_args {\n-            err()\n-        } else {\n-            // FIXME(CraftSpider) Add a check on parameter expansion, so we don't just make the ICE happen later on\n-            //   This will probably require wide-scale changes to support a TupleKind obligation\n-            //   We can't resolve this without knowing the type of the param\n-            if !matches!(fn_sig.inputs()[expected_args - 1].kind(), ty::Tuple(_) | ty::Param(_)) {\n-                err()\n-            }\n-        }\n-    }\n-\n     if body.generator_kind.is_some() && can_be_generator.is_some() {\n         let yield_ty = fcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n@@ -137,7 +100,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n-    fcx.in_tail_expr = true;\n     if let ty::Dynamic(..) = declared_ret_ty.kind() {\n         // FIXME: We need to verify that the return type is `Sized` after the return expression has\n         // been evaluated so that we have types available for all the nodes being returned, but that\n@@ -156,7 +118,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n         fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n         fcx.check_return_expr(&body.value, false);\n     }\n-    fcx.in_tail_expr = false;\n \n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator."}, {"sha": "3001e7994767296fc940ee2e653953c89b0dd1a3", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -10,6 +10,7 @@ use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n+use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{self, Ty};\n@@ -22,7 +23,7 @@ use std::cmp;\n use std::iter;\n \n /// What signature do we *expect* the closure to have from context?\n-#[derive(Debug)]\n+#[derive(Debug, Clone, TypeFoldable, TypeVisitable)]\n struct ExpectedSig<'tcx> {\n     /// Span that gave us this expectation, if we know that.\n     cause_span: Option<Span>,\n@@ -241,9 +242,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if expected_sig.is_none()\n                 && let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder()\n             {\n-                expected_sig = self.deduce_sig_from_projection(\n+                expected_sig = self.normalize_associated_types_in(\n+                    obligation.cause.span,\n+                    self.deduce_sig_from_projection(\n                     Some(obligation.cause.span),\n-                    bound_predicate.rebind(proj_predicate),\n+                        bound_predicate.rebind(proj_predicate),\n+                    ),\n                 );\n             }\n "}, {"sha": "4d8ab2c1c7ad94fe15c646a3115b5655291bdd20", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -705,12 +705,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                 // Object safety violations or miscellaneous.\n                 Err(err) => {\n-                    self.err_ctxt().report_selection_error(\n-                        obligation.clone(),\n-                        &obligation,\n-                        &err,\n-                        false,\n-                    );\n+                    self.err_ctxt().report_selection_error(obligation.clone(), &obligation, &err);\n                     // Treat this like an obligation and follow through\n                     // with the unsizing - the lack of a coercion should\n                     // be silent, as it causes a type mismatch later.\n@@ -1644,9 +1639,9 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 if visitor.ret_exprs.len() > 0 && let Some(expr) = expression {\n                     self.note_unreachable_loop_return(&mut err, &expr, &visitor.ret_exprs);\n                 }\n-                err.emit_unless(unsized_return);\n+                let reported = err.emit_unless(unsized_return);\n \n-                self.final_ty = Some(fcx.tcx.ty_error());\n+                self.final_ty = Some(fcx.tcx.ty_error_with_guaranteed(reported));\n             }\n         }\n     }"}, {"sha": "43669489e69bbb86201134b513ce6155f5bc92b0", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -80,14 +80,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // coercions from ! to `expected`.\n         if ty.is_never() {\n             if let Some(adjustments) = self.typeck_results.borrow().adjustments().get(expr.hir_id) {\n-                self.tcx().sess.delay_span_bug(\n+                let reported = self.tcx().sess.delay_span_bug(\n                     expr.span,\n                     \"expression with never type wound up being adjusted\",\n                 );\n                 return if let [Adjustment { kind: Adjust::NeverToAny, target }] = &adjustments[..] {\n                     target.to_owned()\n                 } else {\n-                    self.tcx().ty_error()\n+                    self.tcx().ty_error_with_guaranteed(reported)\n                 };\n             }\n \n@@ -396,8 +396,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         {\n                             err.subdiagnostic(ExprParenthesesNeeded::surrounding(*sp));\n                         }\n-                        err.emit();\n-                        oprnd_t = tcx.ty_error();\n+                        oprnd_t = tcx.ty_error_with_guaranteed(err.emit());\n                     }\n                 }\n                 hir::UnOp::Not => {\n@@ -843,7 +842,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         {\n             // Point any obligations that were registered due to opaque type\n             // inference at the return expression.\n-            self.select_obligations_where_possible(false, |errors| {\n+            self.select_obligations_where_possible(|errors| {\n                 self.point_at_return_for_opaque_ty_error(errors, span, return_expr_ty);\n             });\n         }\n@@ -1097,12 +1096,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // If the assignment expression itself is ill-formed, don't\n             // bother emitting another error\n-            if lhs_ty.references_error() || rhs_ty.references_error() {\n-                err.delay_as_bug()\n-            } else {\n-                err.emit();\n-            }\n-            return self.tcx.ty_error();\n+            let reported = err.emit_unless(lhs_ty.references_error() || rhs_ty.references_error());\n+            return self.tcx.ty_error_with_guaranteed(reported);\n         }\n \n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n@@ -2738,7 +2733,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some((index_ty, element_ty)) => {\n                     // two-phase not needed because index_ty is never mutable\n                     self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);\n-                    self.select_obligations_where_possible(false, |errors| {\n+                    self.select_obligations_where_possible(|errors| {\n                         self.point_at_index_if_possible(errors, idx.span)\n                     });\n                     element_ty\n@@ -2777,8 +2772,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    err.emit();\n-                    self.tcx.ty_error()\n+                    let reported = err.emit();\n+                    self.tcx.ty_error_with_guaranteed(reported)\n                 }\n             }\n         }"}, {"sha": "5d44092a5f68e33c440e652e24608bf9745ba161", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -7,16 +7,16 @@ use rustc_data_structures::{\n use rustc_middle::ty::{self, Ty};\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n-    /// Performs type inference fallback, returning true if any fallback\n-    /// occurs.\n-    pub(super) fn type_inference_fallback(&self) -> bool {\n+    /// Performs type inference fallback, setting `FnCtxt::fallback_has_occurred`\n+    /// if fallback has occurred.\n+    pub(super) fn type_inference_fallback(&self) {\n         debug!(\n             \"type-inference-fallback start obligations: {:#?}\",\n             self.fulfillment_cx.borrow_mut().pending_obligations()\n         );\n \n         // All type checking constraints were added, try to fallback unsolved variables.\n-        self.select_obligations_where_possible(false, |_| {});\n+        self.select_obligations_where_possible(|_| {});\n \n         debug!(\n             \"type-inference-fallback post selection obligations: {:#?}\",\n@@ -26,18 +26,17 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // Check if we have any unsolved variables. If not, no need for fallback.\n         let unsolved_variables = self.unsolved_variables();\n         if unsolved_variables.is_empty() {\n-            return false;\n+            return;\n         }\n \n         let diverging_fallback = self.calculate_diverging_fallback(&unsolved_variables);\n \n-        let mut fallback_has_occurred = false;\n         // We do fallback in two passes, to try to generate\n         // better error messages.\n         // The first time, we do *not* replace opaque types.\n         for ty in unsolved_variables {\n             debug!(\"unsolved_variable = {:?}\", ty);\n-            fallback_has_occurred |= self.fallback_if_possible(ty, &diverging_fallback);\n+            self.fallback_if_possible(ty, &diverging_fallback);\n         }\n \n         // We now see if we can make progress. This might cause us to\n@@ -63,9 +62,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // If we had tried to fallback the opaque inference variable to `MyType`,\n         // we will generate a confusing type-check error that does not explicitly\n         // refer to opaque types.\n-        self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n-\n-        fallback_has_occurred\n+        self.select_obligations_where_possible(|_| {});\n     }\n \n     // Tries to apply a fallback to `ty` if it is an unsolved variable.\n@@ -81,12 +78,13 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     // Fallback becomes very dubious if we have encountered\n     // type-checking errors.  In that case, fallback to Error.\n     //\n-    // The return value indicates whether fallback has occurred.\n+    // Sets `FnCtxt::fallback_has_occurred` if fallback is performed\n+    // during this call.\n     fn fallback_if_possible(\n         &self,\n         ty: Ty<'tcx>,\n         diverging_fallback: &FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n-    ) -> bool {\n+    ) {\n         // Careful: we do NOT shallow-resolve `ty`. We know that `ty`\n         // is an unsolved variable, and we determine its fallback\n         // based solely on how it was created, not what other type\n@@ -111,7 +109,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n             _ => match diverging_fallback.get(&ty) {\n                 Some(&fallback_ty) => fallback_ty,\n-                None => return false,\n+                None => return,\n             },\n         };\n         debug!(\"fallback_if_possible(ty={:?}): defaulting to `{:?}`\", ty, fallback);\n@@ -122,7 +120,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             .map(|origin| origin.span)\n             .unwrap_or(rustc_span::DUMMY_SP);\n         self.demand_eqtype(span, ty, fallback);\n-        true\n+        self.fallback_has_occurred.set(true);\n     }\n \n     /// The \"diverging fallback\" system is rather complicated. This is"}, {"sha": "6ed7a93d46332f4df7da0d4dead2bcfff85f5a9d", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // possible. This can help substantially when there are\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n-        self.select_obligations_where_possible(false, mutate_fulfillment_errors);\n+        self.select_obligations_where_possible(mutate_fulfillment_errors);\n         self.resolve_vars_if_possible(ty)\n     }\n \n@@ -600,7 +600,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn resolve_generator_interiors(&self, def_id: DefId) {\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n         for (body_id, interior, kind) in generators.drain(..) {\n-            self.select_obligations_where_possible(false, |_| {});\n+            self.select_obligations_where_possible(|_| {});\n             crate::generator_interior::resolve_interior(self, def_id, body_id, interior, kind);\n         }\n     }\n@@ -611,25 +611,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if !errors.is_empty() {\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut errors);\n-            self.err_ctxt().report_fulfillment_errors(&errors, self.inh.body_id, false);\n+            self.err_ctxt().report_fulfillment_errors(&errors, self.inh.body_id);\n         }\n     }\n \n     /// Select as many obligations as we can at present.\n     pub(in super::super) fn select_obligations_where_possible(\n         &self,\n-        fallback_has_occurred: bool,\n         mutate_fulfillment_errors: impl Fn(&mut Vec<traits::FulfillmentError<'tcx>>),\n     ) {\n         let mut result = self.fulfillment_cx.borrow_mut().select_where_possible(self);\n         if !result.is_empty() {\n             mutate_fulfillment_errors(&mut result);\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut result);\n-            self.err_ctxt().report_fulfillment_errors(\n-                &result,\n-                self.inh.body_id,\n-                fallback_has_occurred,\n-            );\n+            self.err_ctxt().report_fulfillment_errors(&result, self.inh.body_id);\n         }\n     }\n \n@@ -1217,9 +1212,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                         }\n                     }\n-                    err.emit();\n-\n-                    return (tcx.ty_error(), res);\n+                    let reported = err.emit();\n+                    return (tcx.ty_error_with_guaranteed(reported), res);\n                 }\n             }\n         } else {"}, {"sha": "a7a60a19bd37e62429da2cafacb747a3e879706d", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -136,6 +136,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             tuple_arguments,\n             Some(method.def_id),\n         );\n+\n         method.sig.output()\n     }\n \n@@ -214,7 +215,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         \"cannot use call notation; the first type parameter \\\n                          for the function trait is neither a tuple nor unit\"\n                     )\n-                    .emit();\n+                    .delay_as_bug();\n                     (self.err_args(provided_args.len()), None)\n                 }\n             }\n@@ -344,7 +345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // an \"opportunistic\" trait resolution of any trait bounds on\n             // the call. This helps coercions.\n             if check_closures {\n-                self.select_obligations_where_possible(false, |_| {})\n+                self.select_obligations_where_possible(|_| {})\n             }\n \n             // Check each argument, to satisfy the input it was provided for"}, {"sha": "d5e4b6de581c3551a2af1020a282790f0807f431", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -68,10 +68,6 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// any).\n     pub(super) ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n \n-    /// Used exclusively to reduce cost of advanced evaluation used for\n-    /// more helpful diagnostics.\n-    pub(super) in_tail_expr: bool,\n-\n     /// First span of a return site that we find. Used in error messages.\n     pub(super) ret_coercion_span: Cell<Option<Span>>,\n \n@@ -115,6 +111,8 @@ pub struct FnCtxt<'a, 'tcx> {\n     pub(super) enclosing_breakables: RefCell<EnclosingBreakables<'tcx>>,\n \n     pub(super) inh: &'a Inherited<'tcx>,\n+\n+    pub(super) fallback_has_occurred: Cell<bool>,\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -128,7 +126,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n-            in_tail_expr: false,\n             ret_coercion_span: Cell::new(None),\n             resume_yield_tys: None,\n             ps: Cell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),\n@@ -138,6 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 by_id: Default::default(),\n             }),\n             inh,\n+            fallback_has_occurred: Cell::new(false),\n         }\n     }\n \n@@ -159,7 +157,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// [`InferCtxt::err_ctxt`]: infer::InferCtxt::err_ctxt\n     pub fn err_ctxt(&'a self) -> TypeErrCtxt<'a, 'tcx> {\n-        TypeErrCtxt { infcx: &self.infcx, typeck_results: Some(self.typeck_results.borrow()) }\n+        TypeErrCtxt {\n+            infcx: &self.infcx,\n+            typeck_results: Some(self.typeck_results.borrow()),\n+            fallback_has_occurred: self.fallback_has_occurred.get(),\n+        }\n     }\n \n     pub fn errors_reported_since_creation(&self) -> bool {"}, {"sha": "7bbfb70f2c3a320021cf1c3b4f104fb75f01c527", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 80, "deletions": 24, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -13,10 +13,13 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::HirIdSet;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind};\n+use rustc_infer::infer::RegionVariableOrigin;\n use rustc_middle::middle::region::{self, Scope, ScopeData, YieldData};\n-use rustc_middle::ty::{self, RvalueScopes, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::fold::FnMutDelegate;\n+use rustc_middle::ty::{self, BoundVariableKind, RvalueScopes, Ty, TyCtxt, TypeVisitable};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use smallvec::{smallvec, SmallVec};\n \n mod drop_ranges;\n \n@@ -211,43 +214,96 @@ pub fn resolve_interior<'a, 'tcx>(\n \n     debug!(\"types in generator {:?}, span = {:?}\", types, body.value.span);\n \n-    let mut counter = 0;\n+    // We want to deduplicate if the lifetimes are the same modulo some non-informative counter.\n+    // So, we need to actually do two passes: first by type to anonymize (preserving information\n+    // required for diagnostics), then a second pass over all captured types to reassign disjoint\n+    // region indices.\n     let mut captured_tys = FxHashSet::default();\n     let type_causes: Vec<_> = types\n         .into_iter()\n         .filter_map(|mut cause| {\n-            // Erase regions and canonicalize late-bound regions to deduplicate as many types as we\n-            // can.\n+            // Replace all regions inside the generator interior with late bound regions.\n+            // Note that each region slot in the types gets a new fresh late bound region,\n+            // which means that none of the regions inside relate to any other, even if\n+            // typeck had previously found constraints that would cause them to be related.\n+\n+            let mut counter = 0;\n+            let mut mk_bound_region = |span| {\n+                let kind = ty::BrAnon(counter, span);\n+                let var = ty::BoundVar::from_u32(counter);\n+                counter += 1;\n+                ty::BoundRegion { var, kind }\n+            };\n             let ty = fcx.normalize_associated_types_in(cause.span, cause.ty);\n-            let erased = fcx.tcx.erase_regions(ty);\n-            if captured_tys.insert(erased) {\n-                // Replace all regions inside the generator interior with late bound regions.\n-                // Note that each region slot in the types gets a new fresh late bound region,\n-                // which means that none of the regions inside relate to any other, even if\n-                // typeck had previously found constraints that would cause them to be related.\n-                let folded = fcx.tcx.fold_regions(erased, |_, current_depth| {\n-                    let br = ty::BoundRegion {\n-                        var: ty::BoundVar::from_u32(counter),\n-                        kind: ty::BrAnon(counter),\n-                    };\n-                    let r = fcx.tcx.mk_region(ty::ReLateBound(current_depth, br));\n-                    counter += 1;\n-                    r\n-                });\n-\n-                cause.ty = folded;\n+            let ty = fcx.tcx.fold_regions(ty, |region, current_depth| {\n+                let br = match region.kind() {\n+                    ty::ReVar(vid) => {\n+                        let origin = fcx.region_var_origin(vid);\n+                        match origin {\n+                            RegionVariableOrigin::EarlyBoundRegion(span, _) => {\n+                                mk_bound_region(Some(span))\n+                            }\n+                            _ => mk_bound_region(None),\n+                        }\n+                    }\n+                    // FIXME: these should use `BrNamed`\n+                    ty::ReEarlyBound(region) => {\n+                        mk_bound_region(Some(fcx.tcx.def_span(region.def_id)))\n+                    }\n+                    ty::ReLateBound(_, ty::BoundRegion { kind, .. })\n+                    | ty::ReFree(ty::FreeRegion { bound_region: kind, .. }) => match kind {\n+                        ty::BoundRegionKind::BrAnon(_, span) => mk_bound_region(span),\n+                        ty::BoundRegionKind::BrNamed(def_id, _) => {\n+                            mk_bound_region(Some(fcx.tcx.def_span(def_id)))\n+                        }\n+                        ty::BoundRegionKind::BrEnv => mk_bound_region(None),\n+                    },\n+                    _ => mk_bound_region(None),\n+                };\n+                let r = fcx.tcx.mk_region(ty::ReLateBound(current_depth, br));\n+                r\n+            });\n+            if captured_tys.insert(ty) {\n+                cause.ty = ty;\n                 Some(cause)\n             } else {\n                 None\n             }\n         })\n         .collect();\n \n+    let mut bound_vars: SmallVec<[BoundVariableKind; 4]> = smallvec![];\n+    let mut counter = 0;\n+    // Optimization: If there is only one captured type, then we don't actually\n+    // need to fold and reindex (since the first type doesn't change).\n+    let type_causes = if captured_tys.len() > 0 {\n+        // Optimization: Use `replace_escaping_bound_vars_uncached` instead of\n+        // `fold_regions`, since we only have late bound regions, and it skips\n+        // types without bound regions.\n+        fcx.tcx.replace_escaping_bound_vars_uncached(\n+            type_causes,\n+            FnMutDelegate {\n+                regions: &mut |br| {\n+                    let kind = match br.kind {\n+                        ty::BrAnon(_, span) => ty::BrAnon(counter, span),\n+                        _ => br.kind,\n+                    };\n+                    let var = ty::BoundVar::from_usize(bound_vars.len());\n+                    bound_vars.push(ty::BoundVariableKind::Region(kind));\n+                    counter += 1;\n+                    fcx.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { var, kind }))\n+                },\n+                types: &mut |b| bug!(\"unexpected bound ty in binder: {b:?}\"),\n+                consts: &mut |b, ty| bug!(\"unexpected bound ct in binder: {b:?} {ty}\"),\n+            },\n+        )\n+    } else {\n+        type_causes\n+    };\n+\n     // Extract type components to build the witness type.\n     let type_list = fcx.tcx.mk_type_list(type_causes.iter().map(|cause| cause.ty));\n-    let bound_vars = fcx.tcx.mk_bound_variable_kinds(\n-        (0..counter).map(|i| ty::BoundVariableKind::Region(ty::BrAnon(i))),\n-    );\n+    let bound_vars = fcx.tcx.mk_bound_variable_kinds(bound_vars.iter());\n     let witness =\n         fcx.tcx.mk_generator_witness(ty::Binder::bind_with_vars(type_list, bound_vars.clone()));\n "}, {"sha": "183e80f2e0840b610f47765a0972b3ab2d6f0e5f", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -209,6 +209,7 @@ fn diagnostic_only_typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::T\n     typeck_with_fallback(tcx, def_id, fallback)\n }\n \n+#[instrument(level = \"debug\", skip(tcx, fallback), ret)]\n fn typeck_with_fallback<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n@@ -316,12 +317,12 @@ fn typeck_with_fallback<'tcx>(\n             fcx\n         };\n \n-        let fallback_has_occurred = fcx.type_inference_fallback();\n+        fcx.type_inference_fallback();\n \n         // Even though coercion casts provide type hints, we check casts after fallback for\n         // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n         fcx.check_casts();\n-        fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n+        fcx.select_obligations_where_possible(|_| {});\n \n         // Closure and generator analysis may run after fallback\n         // because they don't constrain other type variables.\n@@ -458,7 +459,7 @@ fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, qpath: &hir::QPath<'\n /// # fn f(x: (isize, isize)) {}\n /// f((1, 2));\n /// ```\n-#[derive(Clone, Eq, PartialEq)]\n+#[derive(Copy, Clone, Eq, PartialEq)]\n enum TupleArgumentsFlag {\n     DontTupleArguments,\n     TupleArguments,"}, {"sha": "d996d6ec610bae81c64789c6f9d8d676f1c309ed", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -151,8 +151,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         // Commit the autoderefs by calling `autoderef` again, but this\n         // time writing the results into the various typeck results.\n-        let mut autoderef =\n-            self.autoderef_overloaded_span(self.span, unadjusted_self_ty, self.call_expr.span);\n+        let mut autoderef = self.autoderef(self.call_expr.span, unadjusted_self_ty);\n         let Some((ty, n)) = autoderef.nth(pick.autoderefs) else {\n             return self.tcx.ty_error_with_message(\n                 rustc_span::DUMMY_SP,"}, {"sha": "3fcd073f5979300fd1d50713b2f196c4c5c797ad", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -475,10 +475,9 @@ fn method_autoderef_steps<'tcx>(\n     let (ref infcx, goal, inference_vars) = tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n     let ParamEnvAnd { param_env, value: self_ty } = goal;\n \n-    let mut autoderef =\n-        Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty, DUMMY_SP)\n-            .include_raw_pointers()\n-            .silence_errors();\n+    let mut autoderef = Autoderef::new(infcx, param_env, hir::CRATE_HIR_ID, DUMMY_SP, self_ty)\n+        .include_raw_pointers()\n+        .silence_errors();\n     let mut reached_raw_pointer = false;\n     let mut steps: Vec<_> = autoderef\n         .by_ref()"}, {"sha": "799043842201af24de6da5abc62aae332c8c8bf8", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 117, "deletions": 21, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -14,19 +14,26 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::{\n+    type_variable::{TypeVariableOrigin, TypeVariableOriginKind},\n+    RegionVariableOrigin,\n+};\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::with_crate_prefix;\n-use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, DefIdTree, GenericArg, GenericArgKind, ToPredicate, Ty, TyCtxt, TypeVisitable,\n+};\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n use rustc_span::{lev_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n+use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedNote;\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n-    FulfillmentError, Obligation, ObligationCause, ObligationCauseCode, OnUnimplementedNote,\n+    FulfillmentError, Obligation, ObligationCause, ObligationCauseCode,\n };\n \n use std::cmp::Ordering;\n@@ -279,7 +286,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ) {\n                     return None;\n                 }\n-\n                 span = item_name.span;\n \n                 // Don't show generic arguments when the method can't be found in any implementation (#81576).\n@@ -392,28 +398,118 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     custom_span_label = true;\n                 }\n                 if static_candidates.len() == 1 {\n-                    let ty_str =\n-                        if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) {\n-                            // When the \"method\" is resolved through dereferencing, we really want the\n-                            // original type that has the associated function for accurate suggestions.\n-                            // (#61411)\n-                            let ty = tcx.at(span).type_of(*impl_did);\n-                            match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n-                                (ty::Adt(def, _), ty::Adt(def_actual, _)) if def == def_actual => {\n-                                    // Use `actual` as it will have more `substs` filled in.\n-                                    self.ty_to_value_string(actual.peel_refs())\n+                    let mut has_unsuggestable_args = false;\n+                    let ty_str = if let Some(CandidateSource::Impl(impl_did)) =\n+                        static_candidates.get(0)\n+                    {\n+                        // When the \"method\" is resolved through dereferencing, we really want the\n+                        // original type that has the associated function for accurate suggestions.\n+                        // (#61411)\n+                        let ty = tcx.at(span).type_of(*impl_did);\n+                        match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n+                            (ty::Adt(def, _), ty::Adt(def_actual, substs)) if def == def_actual => {\n+                                // If there are any inferred arguments, (`{integer}`), we should replace\n+                                // them with underscores to allow the compiler to infer them\n+                                let infer_substs: Vec<GenericArg<'_>> = substs\n+                                    .into_iter()\n+                                    .map(|arg| {\n+                                        if !arg.is_suggestable(tcx, true) {\n+                                            has_unsuggestable_args = true;\n+                                            match arg.unpack() {\n+                                            GenericArgKind::Lifetime(_) => self\n+                                                .next_region_var(RegionVariableOrigin::MiscVariable(\n+                                                    rustc_span::DUMMY_SP,\n+                                                ))\n+                                                .into(),\n+                                            GenericArgKind::Type(_) => self\n+                                                .next_ty_var(TypeVariableOrigin {\n+                                                    span: rustc_span::DUMMY_SP,\n+                                                    kind: TypeVariableOriginKind::MiscVariable,\n+                                                })\n+                                                .into(),\n+                                            GenericArgKind::Const(arg) => self\n+                                                .next_const_var(\n+                                                    arg.ty(),\n+                                                    ConstVariableOrigin {\n+                                                        span: rustc_span::DUMMY_SP,\n+                                                        kind: ConstVariableOriginKind::MiscVariable,\n+                                                    },\n+                                                )\n+                                                .into(),\n+                                            }\n+                                        } else {\n+                                            arg\n+                                        }\n+                                    })\n+                                    .collect::<Vec<_>>();\n+\n+                                tcx.value_path_str_with_substs(\n+                                    def_actual.did(),\n+                                    tcx.intern_substs(&infer_substs),\n+                                )\n+                            }\n+                            _ => self.ty_to_value_string(ty.peel_refs()),\n+                        }\n+                    } else {\n+                        self.ty_to_value_string(actual.peel_refs())\n+                    };\n+                    if let SelfSource::MethodCall(_) = source {\n+                        let first_arg = if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) &&\n+                            let Some(assoc) = self.associated_value(*impl_did, item_name) {\n+                            let sig = self.tcx.fn_sig(assoc.def_id);\n+                            if let Some(first) = sig.inputs().skip_binder().get(0) {\n+                                if first.peel_refs() == rcvr_ty.peel_refs() {\n+                                    None\n+                                } else {\n+                                    Some(if first.is_region_ptr() {\n+                                        if first.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n+                                    } else {\n+                                        \"\"\n+                                    })\n                                 }\n-                                _ => self.ty_to_value_string(ty.peel_refs()),\n+                            } else {\n+                                None\n                             }\n                         } else {\n-                            self.ty_to_value_string(actual.peel_refs())\n+                            None\n+                        };\n+                        let mut applicability = Applicability::MachineApplicable;\n+                        let args = if let Some((receiver, args)) = args {\n+                            // The first arg is the same kind as the receiver\n+                            let explicit_args = if first_arg.is_some() {\n+                                std::iter::once(receiver).chain(args.iter()).collect::<Vec<_>>()\n+                            } else {\n+                                // There is no `Self` kind to infer the arguments from\n+                                if has_unsuggestable_args {\n+                                    applicability = Applicability::HasPlaceholders;\n+                                }\n+                                args.iter().collect()\n+                            };\n+                            format!(\n+                                \"({}{})\",\n+                                first_arg.unwrap_or(\"\"),\n+                                explicit_args\n+                                    .iter()\n+                                    .map(|arg| tcx\n+                                        .sess\n+                                        .source_map()\n+                                        .span_to_snippet(arg.span)\n+                                        .unwrap_or_else(|_| {\n+                                            applicability = Applicability::HasPlaceholders;\n+                                            \"_\".to_owned()\n+                                        }))\n+                                    .collect::<Vec<_>>()\n+                                    .join(\", \"),\n+                            )\n+                        } else {\n+                            applicability = Applicability::HasPlaceholders;\n+                            \"(...)\".to_owned()\n                         };\n-                    if let SelfSource::MethodCall(expr) = source {\n                         err.span_suggestion(\n-                            expr.span.to(span),\n+                            sugg_span,\n                             \"use associated function syntax instead\",\n-                            format!(\"{}::{}\", ty_str, item_name),\n-                            Applicability::MachineApplicable,\n+                            format!(\"{}::{}{}\", ty_str, item_name, args),\n+                            applicability,\n                         );\n                     } else {\n                         err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n@@ -1826,7 +1922,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Print out the type for use in value namespace.\n     fn ty_to_value_string(&self, ty: Ty<'tcx>) -> String {\n         match ty.kind() {\n-            ty::Adt(def, substs) => format!(\"{}\", ty::Instance::new(def.did(), substs)),\n+            ty::Adt(def, substs) => self.tcx.def_path_str_with_substs(def.did(), substs),\n             _ => self.ty_to_string(ty),\n         }\n     }"}, {"sha": "38b3dd218a9719b4b28fcc41ff354c66bb50c42b", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -529,8 +529,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     }\n                 }\n-                err.emit();\n-                self.tcx.ty_error()\n+                let reported = err.emit();\n+                self.tcx.ty_error_with_guaranteed(reported)\n             }\n         };\n \n@@ -772,7 +772,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match (method, trait_did) {\n             (Some(ok), _) => {\n                 let method = self.register_infer_ok_obligations(ok);\n-                self.select_obligations_where_possible(false, |_| {});\n+                self.select_obligations_where_possible(|_| {});\n                 Ok(method)\n             }\n             (None, None) => Err(vec![]),"}, {"sha": "eb10f3e2c107f8f943b9d17c30cd8238b5fc9d8f", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -19,7 +19,6 @@ use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, DUMMY_SP};\n-use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::traits::{ObligationCause, Pattern};\n use ty::VariantDef;\n \n@@ -1278,12 +1277,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let element_tys = tcx.mk_type_list(element_tys_iter);\n         let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n         if let Some(mut err) = self.demand_eqtype_pat_diag(span, expected, pat_ty, ti) {\n-            err.emit();\n+            let reported = err.emit();\n             // Walk subpatterns with an expected type of `err` in this case to silence\n             // further errors being emitted when using the bindings. #50333\n-            let element_tys_iter = (0..max_len).map(|_| tcx.ty_error());\n+            let element_tys_iter = (0..max_len).map(|_| tcx.ty_error_with_guaranteed(reported));\n             for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, tcx.ty_error(), def_bm, ti);\n+                self.check_pat(elem, tcx.ty_error_with_guaranteed(reported), def_bm, ti);\n             }\n             tcx.mk_tup(element_tys_iter)\n         } else {\n@@ -2132,7 +2131,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             && let ty::Array(..) | ty::Slice(..) = ty.kind()\n         {\n             err.help(\"the semantics of slice patterns changed recently; see issue #62254\");\n-        } else if Autoderef::new(&self.infcx, self.param_env, self.body_id, span, expected_ty, span)\n+        } else if self.autoderef(span, expected_ty)\n             .any(|(ty, _)| matches!(ty.kind(), ty::Slice(..) | ty::Array(..)))\n             && let (Some(span), true) = (ti.span, ti.origin_expr)\n             && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)"}, {"sha": "952ea14887f7bc7f279de7c1863e523c61c0195a", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -90,8 +90,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Applicability::MachineApplicable,\n             );\n         }\n-        err.emit();\n-        Some((self.tcx.ty_error(), self.tcx.ty_error()))\n+        let reported = err.emit();\n+        Some((\n+            self.tcx.ty_error_with_guaranteed(reported),\n+            self.tcx.ty_error_with_guaranteed(reported),\n+        ))\n     }\n \n     /// To type-check `base_expr[index_expr]`, we progressively autoderef"}, {"sha": "ec4eeb8caa27c9687b2684a29fc7a5c9736c46a0", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -180,6 +180,18 @@ pub enum SourceKindMultiSuggestion<'a> {\n     },\n }\n \n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    infer_suggest_add_let_for_letchains,\n+    style = \"verbose\",\n+    applicability = \"machine-applicable\",\n+    code = \"let \"\n+)]\n+pub(crate) struct SuggAddLetForLetChains {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n impl<'a> SourceKindMultiSuggestion<'a> {\n     pub fn new_fully_qualified(\n         span: Span,"}, {"sha": "7aaa5ce2f4242bd83ded5184a09162e5a0f6b855", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -89,10 +89,13 @@ impl<'a> DescriptionCtx<'a> {\n                             };\n                             me.span = Some(sp);\n                         }\n-                        ty::BrAnon(idx) => {\n+                        ty::BrAnon(idx, span) => {\n                             me.kind = \"anon_num_here\";\n                             me.num_arg = idx+1;\n-                            me.span = Some(tcx.def_span(scope));\n+                            me.span = match span {\n+                                Some(_) => span,\n+                                None => Some(tcx.def_span(scope)),\n+                            }\n                         },\n                         _ => {\n                             me.kind = \"defined_here_reg\";"}, {"sha": "3dc0d60b1eb0fab07d2358d1cf9c2c959f5c0cbd", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -495,7 +495,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             }\n             ty::ConstKind::Bound(debruijn, _) => {\n                 if debruijn >= self.binder_index {\n-                    bug!(\"escaping bound type during canonicalization\")\n+                    bug!(\"escaping bound const during canonicalization\")\n                 } else {\n                     return ct;\n                 }\n@@ -738,7 +738,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         let var = self.canonical_var(info, r.into());\n-        let br = ty::BoundRegion { var, kind: ty::BrAnon(var.as_u32()) };\n+        let br = ty::BoundRegion { var, kind: ty::BrAnon(var.as_u32(), None) };\n         let region = ty::ReLateBound(self.binder_index, br);\n         self.tcx().mk_region(region)\n     }"}, {"sha": "22f32251f6df0bff273c0e52999c9157209dac26", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 82, "deletions": 8, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! Error Reporting Code for the inference engine\n //!\n //! Because of the way inference, and in particular region inference,\n@@ -58,12 +59,15 @@ use crate::traits::{\n     StatementAsExpression,\n };\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use crate::errors::SuggAddLetForLetChains;\n+use hir::intravisit::{walk_expr, walk_stmt};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, ErrorGuaranteed, IntoDiagnosticArg};\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Node;\n use rustc_middle::dep_graph::DepContext;\n@@ -91,6 +95,7 @@ pub mod nice_region_error;\n pub struct TypeErrCtxt<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'tcx>,\n     pub typeck_results: Option<std::cell::Ref<'a, ty::TypeckResults<'tcx>>>,\n+    pub fallback_has_occurred: bool,\n }\n \n impl TypeErrCtxt<'_, '_> {\n@@ -206,9 +211,12 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n                         };\n                         (text, sp)\n                     }\n-                    ty::BrAnon(idx) => (\n+                    ty::BrAnon(idx, span) => (\n                         format!(\"the anonymous lifetime #{} defined here\", idx + 1),\n-                        tcx.def_span(scope)\n+                        match span {\n+                            Some(span) => span,\n+                            None => tcx.def_span(scope)\n+                        }\n                     ),\n                     _ => (\n                         format!(\"the lifetime `{}` as defined here\", region),\n@@ -1498,9 +1506,9 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             values = None;\n         }\n         struct OpaqueTypesVisitor<'tcx> {\n-            types: FxHashMap<TyCategory, FxHashSet<Span>>,\n-            expected: FxHashMap<TyCategory, FxHashSet<Span>>,\n-            found: FxHashMap<TyCategory, FxHashSet<Span>>,\n+            types: FxIndexMap<TyCategory, FxIndexSet<Span>>,\n+            expected: FxIndexMap<TyCategory, FxIndexSet<Span>>,\n+            found: FxIndexMap<TyCategory, FxIndexSet<Span>>,\n             ignore_span: Span,\n             tcx: TyCtxt<'tcx>,\n         }\n@@ -1538,7 +1546,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 &self,\n                 err: &mut Diagnostic,\n                 target: &str,\n-                types: &FxHashMap<TyCategory, FxHashSet<Span>>,\n+                types: &FxIndexMap<TyCategory, FxIndexSet<Span>>,\n             ) {\n                 for (key, values) in types.iter() {\n                     let count = values.len();\n@@ -2332,6 +2340,11 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                                 }\n                             }\n                         }\n+                        // For code `if Some(..) = expr `, the type mismatch may be expected `bool` but found `()`,\n+                        // we try to suggest to add the missing `let` for `if let Some(..) = expr`\n+                        (ty::Bool, ty::Tuple(list)) => if list.len() == 0 {\n+                            self.suggest_let_for_letchains(&mut err, &trace.cause, span);\n+                        }\n                         _ => {}\n                     }\n                 }\n@@ -2356,6 +2369,67 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         diag\n     }\n \n+    /// Try to find code with pattern `if Some(..) = expr`\n+    /// use a `visitor` to mark the `if` which its span contains given error span,\n+    /// and then try to find a assignment in the `cond` part, which span is equal with error span\n+    fn suggest_let_for_letchains(\n+        &self,\n+        err: &mut Diagnostic,\n+        cause: &ObligationCause<'_>,\n+        span: Span,\n+    ) {\n+        let hir = self.tcx.hir();\n+        let fn_hir_id = hir.get_parent_node(cause.body_id);\n+        if let Some(node) = self.tcx.hir().find(fn_hir_id) &&\n+            let hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(_sig, _, body_id), ..\n+                }) = node {\n+        let body = hir.body(*body_id);\n+\n+        /// Find the if expression with given span\n+        struct IfVisitor {\n+            pub result: bool,\n+            pub found_if: bool,\n+            pub err_span: Span,\n+        }\n+\n+        impl<'v> Visitor<'v> for IfVisitor {\n+            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+                if self.result { return; }\n+                match ex.kind {\n+                    hir::ExprKind::If(cond, _, _) => {\n+                        self.found_if = true;\n+                        walk_expr(self, cond);\n+                        self.found_if = false;\n+                    }\n+                    _ => walk_expr(self, ex),\n+                }\n+            }\n+\n+            fn visit_stmt(&mut self, ex: &'v hir::Stmt<'v>) {\n+                if let hir::StmtKind::Local(hir::Local {\n+                        span, pat: hir::Pat{..}, ty: None, init: Some(_), ..\n+                    }) = &ex.kind\n+                    && self.found_if\n+                    && span.eq(&self.err_span) {\n+                        self.result = true;\n+                }\n+                walk_stmt(self, ex);\n+            }\n+\n+            fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n+                hir::intravisit::walk_body(self, body);\n+            }\n+        }\n+\n+        let mut visitor = IfVisitor { err_span: span, found_if: false, result: false };\n+        visitor.visit_body(&body);\n+        if visitor.result {\n+                err.subdiagnostic(SuggAddLetForLetChains{span: span.shrink_to_lo()});\n+            }\n+        }\n+    }\n+\n     fn emit_tuple_wrap_err(\n         &self,\n         err: &mut Diagnostic,\n@@ -3254,7 +3328,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         if blk.expr.is_some() {\n             return false;\n         }\n-        let mut shadowed = FxHashSet::default();\n+        let mut shadowed = FxIndexSet::default();\n         let mut candidate_idents = vec![];\n         let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n             if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind"}, {"sha": "1067ccda20ca0ea4a80c64960c7330ce895cf8e7", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -9,7 +9,7 @@ use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::ObligationCauseCode;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n@@ -73,7 +73,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n             // Next, let's figure out the set of trait objects with implicit static bounds\n             let ty = self.tcx().type_of(*impl_def_id);\n-            let mut v = super::static_impl_trait::TraitObjectVisitor(FxHashSet::default());\n+            let mut v = super::static_impl_trait::TraitObjectVisitor(FxIndexSet::default());\n             v.visit_ty(ty);\n             let mut traits = vec![];\n             for matching_def_id in v.0 {"}, {"sha": "8a0e332f9c704b4f5f958e6f59bd546c65fa629a", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -10,6 +10,7 @@ pub mod find_anon_type;\n mod mismatched_static_lifetime;\n mod named_anon_conflict;\n mod placeholder_error;\n+mod placeholder_relation;\n mod static_impl_trait;\n mod trait_impl_difference;\n mod util;\n@@ -52,7 +53,9 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n     pub fn try_report_from_nll(&self) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n         // Due to the improved diagnostics returned by the MIR borrow checker, only a subset of\n         // the nice region errors are required when running under the MIR borrow checker.\n-        self.try_report_named_anon_conflict().or_else(|| self.try_report_placeholder_conflict())\n+        self.try_report_named_anon_conflict()\n+            .or_else(|| self.try_report_placeholder_conflict())\n+            .or_else(|| self.try_report_placeholder_relation())\n     }\n \n     pub fn try_report(&self) -> Option<ErrorGuaranteed> {"}, {"sha": "3fe7c1598fc3fbbf2e6ad540f2b2e9a557387e40", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let is_impl_item = region_info.is_impl_item;\n \n         match br {\n-            ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(_) => {}\n+            ty::BrNamed(_, kw::UnderscoreLifetime) | ty::BrAnon(..) => {}\n             _ => {\n                 /* not an anonymous region */\n                 debug!(\"try_report_named_anon_conflict: not an anonymous region\");"}, {"sha": "c42240f21724f77bf9a798b948b06e6368744809", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_relation.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_relation.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -0,0 +1,79 @@\n+use crate::infer::{\n+    error_reporting::nice_region_error::NiceRegionError, RegionResolutionError, SubregionOrigin,\n+};\n+use rustc_data_structures::intern::Interned;\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_middle::ty::{self, RePlaceholder, Region};\n+\n+impl<'tcx> NiceRegionError<'_, 'tcx> {\n+    /// Emitted wwhen given a `ConcreteFailure` when relating two placeholders.\n+    pub(super) fn try_report_placeholder_relation(\n+        &self,\n+    ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n+        match &self.error {\n+            Some(RegionResolutionError::ConcreteFailure(\n+                SubregionOrigin::RelateRegionParamBound(span),\n+                Region(Interned(RePlaceholder(ty::Placeholder { name: sub_name, .. }), _)),\n+                Region(Interned(RePlaceholder(ty::Placeholder { name: sup_name, .. }), _)),\n+            )) => {\n+                let msg = \"lifetime bound not satisfied\";\n+                let mut err = self.tcx().sess.struct_span_err(*span, msg);\n+                let (sub_span, sub_symbol) = match sub_name {\n+                    ty::BrNamed(def_id, symbol) => {\n+                        (Some(self.tcx().def_span(def_id)), Some(symbol))\n+                    }\n+                    ty::BrAnon(_, span) => (*span, None),\n+                    ty::BrEnv => (None, None),\n+                };\n+                let (sup_span, sup_symbol) = match sup_name {\n+                    ty::BrNamed(def_id, symbol) => {\n+                        (Some(self.tcx().def_span(def_id)), Some(symbol))\n+                    }\n+                    ty::BrAnon(_, span) => (*span, None),\n+                    ty::BrEnv => (None, None),\n+                };\n+                match (sub_span, sup_span, sub_symbol, sup_symbol) {\n+                    (Some(sub_span), Some(sup_span), Some(sub_symbol), Some(sup_symbol)) => {\n+                        err.span_note(\n+                            sub_span,\n+                            format!(\"the lifetime `{sub_symbol}` defined here...\"),\n+                        );\n+                        err.span_note(\n+                            sup_span,\n+                            format!(\"...must outlive the lifetime `{sup_symbol}` defined here\"),\n+                        );\n+                    }\n+                    (Some(sub_span), Some(sup_span), _, Some(sup_symbol)) => {\n+                        err.span_note(sub_span, format!(\"the lifetime defined here...\"));\n+                        err.span_note(\n+                            sup_span,\n+                            format!(\"...must outlive the lifetime `{sup_symbol}` defined here\"),\n+                        );\n+                    }\n+                    (Some(sub_span), Some(sup_span), Some(sub_symbol), _) => {\n+                        err.span_note(\n+                            sub_span,\n+                            format!(\"the lifetime `{sub_symbol}` defined here...\"),\n+                        );\n+                        err.span_note(\n+                            sup_span,\n+                            format!(\"...must outlive the lifetime defined here\"),\n+                        );\n+                    }\n+                    (Some(sub_span), Some(sup_span), _, _) => {\n+                        err.span_note(sub_span, format!(\"the lifetime defined here...\"));\n+                        err.span_note(\n+                            sup_span,\n+                            format!(\"...must outlive the lifetime defined here\"),\n+                        );\n+                    }\n+                    _ => {}\n+                }\n+                err.note(\"this is a known limitation that will be removed in the future (see issue #100013 <https://github.com/rust-lang/rust/issues/100013> for more information)\");\n+                Some(err)\n+            }\n+\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "b4efe8da1259266507da5ddd265f1021d00d03c9", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -4,7 +4,7 @@ use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCauseCode, UnifyReceiverContext};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             // Same case of `impl Foo for dyn Bar { fn qux(&self) {} }` introducing a `'static`\n             // lifetime as above, but called using a fully-qualified path to the method:\n             // `Foo::qux(bar)`.\n-            let mut v = TraitObjectVisitor(FxHashSet::default());\n+            let mut v = TraitObjectVisitor(FxIndexSet::default());\n             v.visit_ty(param.param_ty);\n             if let Some((ident, self_ty)) =\n                 self.get_impl_ident_and_self_ty_from_trait(item_def_id, &v.0)\n@@ -408,7 +408,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     fn get_impl_ident_and_self_ty_from_trait(\n         &self,\n         def_id: DefId,\n-        trait_objects: &FxHashSet<DefId>,\n+        trait_objects: &FxIndexSet<DefId>,\n     ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n         let tcx = self.tcx();\n         match tcx.hir().get_if_local(def_id) {\n@@ -490,7 +490,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             return false;\n         };\n \n-        let mut v = TraitObjectVisitor(FxHashSet::default());\n+        let mut v = TraitObjectVisitor(FxIndexSet::default());\n         v.visit_ty(ty);\n \n         // Get the `Ident` of the method being called and the corresponding `impl` (to point at\n@@ -506,7 +506,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     fn suggest_constrain_dyn_trait_in_impl(\n         &self,\n         err: &mut Diagnostic,\n-        found_dids: &FxHashSet<DefId>,\n+        found_dids: &FxIndexSet<DefId>,\n         ident: Ident,\n         self_ty: &hir::Ty<'_>,\n     ) -> bool {\n@@ -538,7 +538,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n }\n \n /// Collect all the trait objects in a type that could have received an implicit `'static` lifetime.\n-pub struct TraitObjectVisitor(pub FxHashSet<DefId>);\n+pub struct TraitObjectVisitor(pub FxIndexSet<DefId>);\n \n impl<'tcx> TypeVisitor<'tcx> for TraitObjectVisitor {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {"}, {"sha": "fd26d7d29c5ee6ba1f13554126a8255e54323fd5", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -149,6 +149,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         region: ty::BoundRegionKind,\n     ) -> bool {\n         let late_bound_regions = self.tcx().collect_referenced_late_bound_regions(&ty);\n+        // We are only checking is any region meets the condition so order doesn't matter\n+        #[allow(rustc::potential_query_instability)]\n         late_bound_regions.iter().any(|r| *r == region)\n     }\n "}, {"sha": "ba990acfe6fc4a5991bfcba2d65c7355f25a971b", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -842,6 +842,9 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // are placeholders as upper bounds, but the universe of the\n         // variable `'a`, or some variable that `'a` has to outlive, doesn't\n         // permit those placeholders.\n+        //\n+        // We only iterate to find the min, which means it doesn't cause reproducibility issues\n+        #[allow(rustc::potential_query_instability)]\n         let min_universe = lower_vid_bounds\n             .into_iter()\n             .map(|vid| self.var_infos[vid].universe)"}, {"sha": "ccba197dc80b75c58bdb415410ed38ef4a406751", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -10,6 +10,7 @@ pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};\n \n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine, TraitEngineExt};\n \n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::Rollback;\n@@ -294,7 +295,7 @@ pub struct InferCtxt<'tcx> {\n \n     /// the set of predicates on which errors have been reported, to\n     /// avoid reporting the same error twice.\n-    pub reported_trait_errors: RefCell<FxHashMap<Span, Vec<ty::Predicate<'tcx>>>>,\n+    pub reported_trait_errors: RefCell<FxIndexMap<Span, Vec<ty::Predicate<'tcx>>>>,\n \n     pub reported_closure_mismatch: RefCell<FxHashSet<(Span, Option<Span>)>>,\n \n@@ -677,9 +678,9 @@ pub struct CombinedSnapshot<'tcx> {\n \n impl<'tcx> InferCtxt<'tcx> {\n     /// Creates a `TypeErrCtxt` for emitting various inference errors.\n-    /// During typeck, use `FnCtxt::infer_err` instead.\n+    /// During typeck, use `FnCtxt::err_ctxt` instead.\n     pub fn err_ctxt(&self) -> TypeErrCtxt<'_, 'tcx> {\n-        TypeErrCtxt { infcx: self, typeck_results: None }\n+        TypeErrCtxt { infcx: self, typeck_results: None, fallback_has_occurred: false }\n     }\n \n     /// calls `tcx.try_unify_abstract_consts` after"}, {"sha": "22b4bbb17d47fd3e38948d6dd51e545588d39ade", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,6 +1,7 @@\n use super::*;\n use crate::infer::CombinedSnapshot;\n use rustc_data_structures::{\n+    fx::FxIndexMap,\n     graph::{scc::Sccs, vec_graph::VecGraph},\n     undo_log::UndoLogs,\n };\n@@ -371,7 +372,7 @@ rustc_index::newtype_index! {\n /// an edge `R1 -> R2` in the graph.\n struct MiniGraph<'tcx> {\n     /// Map from a region to the index of the node in the graph.\n-    nodes: FxHashMap<ty::Region<'tcx>, LeakCheckNode>,\n+    nodes: FxIndexMap<ty::Region<'tcx>, LeakCheckNode>,\n \n     /// Map from node index to SCC, and stores the successors of each SCC. All\n     /// the regions in the same SCC are equal to one another, and if `S1 -> S2`,\n@@ -388,7 +389,7 @@ impl<'tcx> MiniGraph<'tcx> {\n     where\n         'tcx: 'a,\n     {\n-        let mut nodes = FxHashMap::default();\n+        let mut nodes = FxIndexMap::default();\n         let mut edges = Vec::new();\n \n         // Note that if `R2: R1`, we get a callback `r1, r2`, so `target` is first parameter.\n@@ -438,7 +439,7 @@ impl<'tcx> MiniGraph<'tcx> {\n     }\n \n     fn add_node(\n-        nodes: &mut FxHashMap<ty::Region<'tcx>, LeakCheckNode>,\n+        nodes: &mut FxIndexMap<ty::Region<'tcx>, LeakCheckNode>,\n         r: ty::Region<'tcx>,\n     ) -> LeakCheckNode {\n         let l = nodes.len();"}, {"sha": "985c5d360db8e814b4a7b9b7e69924e2ae9fabcc", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -7,7 +7,7 @@ use super::{\n     InferCtxtUndoLogs, MiscVariable, RegionVariableOrigin, Rollback, Snapshot, SubregionOrigin,\n };\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::UndoLogs;\n@@ -125,7 +125,7 @@ pub struct RegionConstraintData<'tcx> {\n     /// we record the fact that `'a <= 'b` is implied by the fn\n     /// signature, and then ignore the constraint when solving\n     /// equations. This is a bit of a hack but seems to work.\n-    pub givens: FxHashSet<(Region<'tcx>, ty::RegionVid)>,\n+    pub givens: FxIndexSet<(Region<'tcx>, ty::RegionVid)>,\n }\n \n /// Represents a constraint that influences the inference process."}, {"sha": "4c119a443555e35fcd444cd6668fb74d028c7d44", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -12,7 +12,6 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]"}, {"sha": "4d53519581b3795bdc9b7bf27e9b9820011078a4", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,7 +1,7 @@\n use super::ObjectSafetyViolation;\n \n use crate::infer::InferCtxt;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -56,7 +56,7 @@ pub fn report_object_safety_error<'tcx>(\n     );\n     err.span_label(span, format!(\"`{}` cannot be made into an object\", trait_str));\n \n-    let mut reported_violations = FxHashSet::default();\n+    let mut reported_violations = FxIndexSet::default();\n     let mut multi_span = vec![];\n     let mut messages = vec![];\n     for violation in violations {"}, {"sha": "542b638bbd7a40dcb5596aca193092332b93a811", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,4 +1,5 @@\n #![feature(box_patterns)]\n+#![feature(decl_macro)]\n #![feature(internal_output_capture)]\n #![feature(thread_spawn_unchecked)]\n #![feature(once_cell)]"}, {"sha": "9bf7778bfb29c7abd75a2a6144d12fcee9b86453", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -4,21 +4,16 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n fn proc_macro_decls_static(tcx: TyCtxt<'_>, (): ()) -> Option<LocalDefId> {\n-    let mut finder = Finder { tcx, decls: None };\n+    let mut decls = None;\n \n     for id in tcx.hir().items() {\n-        let attrs = finder.tcx.hir().attrs(id.hir_id());\n-        if finder.tcx.sess.contains_name(attrs, sym::rustc_proc_macro_decls) {\n-            finder.decls = Some(id.owner_id.def_id);\n+        let attrs = tcx.hir().attrs(id.hir_id());\n+        if tcx.sess.contains_name(attrs, sym::rustc_proc_macro_decls) {\n+            decls = Some(id.owner_id.def_id);\n         }\n     }\n \n-    finder.decls\n-}\n-\n-struct Finder<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    decls: Option<LocalDefId>,\n+    decls\n }\n \n pub(crate) fn provide(providers: &mut Providers) {"}, {"sha": "2fe3fb2fa5668013978287aa75086ea0d42480ce", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -327,7 +327,7 @@ fn get_codegen_sysroot(maybe_sysroot: &Option<PathBuf>, backend_name: &str) -> M\n     let mut file: Option<PathBuf> = None;\n \n     let expected_names = &[\n-        format!(\"rustc_codegen_{}-{}\", backend_name, release_str().expect(\"CFG_RELEASE\")),\n+        format!(\"rustc_codegen_{}-{}\", backend_name, env!(\"CFG_RELEASE\")),\n         format!(\"rustc_codegen_{}\", backend_name),\n     ];\n     for entry in d.filter_map(|e| e.ok()) {\n@@ -554,22 +554,12 @@ pub fn build_output_filenames(\n     }\n }\n \n-/// Returns a version string such as \"1.46.0 (04488afe3 2020-08-24)\"\n-pub fn version_str() -> Option<&'static str> {\n+/// Returns a version string such as \"1.46.0 (04488afe3 2020-08-24)\" when invoked by an in-tree tool.\n+pub macro version_str() {\n     option_env!(\"CFG_VERSION\")\n }\n \n-/// Returns a version string such as \"0.12.0-dev\".\n-pub fn release_str() -> Option<&'static str> {\n-    option_env!(\"CFG_RELEASE\")\n-}\n-\n-/// Returns the full SHA1 hash of HEAD of the Git repo from which rustc was built.\n-pub fn commit_hash_str() -> Option<&'static str> {\n-    option_env!(\"CFG_VER_HASH\")\n-}\n-\n-/// Returns the \"commit date\" of HEAD of the Git repo from which rustc was built as a static string.\n-pub fn commit_date_str() -> Option<&'static str> {\n-    option_env!(\"CFG_VER_DATE\")\n+/// Returns the version string for `rustc` itself (which may be different from a tool version).\n+pub fn rustc_version_str() -> Option<&'static str> {\n+    version_str!()\n }"}, {"sha": "d4140cb295f32d6977993329036bdd654319115d", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -88,7 +88,9 @@ pub enum TokenKind {\n     /// tokens.\n     UnknownPrefix,\n \n-    /// Examples: `\"12_u8\"`, `\"1.0e-40\"`, `b\"123`.\n+    /// Examples: `12u8`, `1.0e-40`, `b\"123\"`. Note that `_` is an invalid\n+    /// suffix, but may be present here on string and float literals. Users of\n+    /// this type will need to check for and reject that case.\n     ///\n     /// See [LiteralKind] for more details.\n     Literal { kind: LiteralKind, suffix_start: u32 },\n@@ -203,13 +205,13 @@ pub enum RawStrError {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Base {\n     /// Literal starts with \"0b\".\n-    Binary,\n+    Binary = 2,\n     /// Literal starts with \"0o\".\n-    Octal,\n-    /// Literal starts with \"0x\".\n-    Hexadecimal,\n+    Octal = 8,\n     /// Literal doesn't contain a prefix.\n-    Decimal,\n+    Decimal = 10,\n+    /// Literal starts with \"0x\".\n+    Hexadecimal = 16,\n }\n \n /// `rustc` allows files to have a shebang, e.g. \"#!/usr/bin/rustrun\",\n@@ -840,12 +842,13 @@ impl Cursor<'_> {\n         self.eat_decimal_digits()\n     }\n \n-    // Eats the suffix of the literal, e.g. \"_u8\".\n+    // Eats the suffix of the literal, e.g. \"u8\".\n     fn eat_literal_suffix(&mut self) {\n         self.eat_identifier();\n     }\n \n-    // Eats the identifier.\n+    // Eats the identifier. Note: succeeds on `_`, which isn't a valid\n+    // identifer.\n     fn eat_identifier(&mut self) {\n         if !is_id_start(self.first()) {\n             return;"}, {"sha": "e405013dcabf83047cb34a88c635e6d4d7ec8a28", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 51, "deletions": 79, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -52,10 +52,8 @@ pub enum EscapeError {\n \n     /// Unicode escape code in byte literal.\n     UnicodeEscapeInByte,\n-    /// Non-ascii character in byte literal.\n+    /// Non-ascii character in byte literal, byte string literal, or raw byte string literal.\n     NonAsciiCharInByte,\n-    /// Non-ascii character in byte string literal.\n-    NonAsciiCharInByteString,\n \n     /// After a line ending with '\\', the next line contains whitespace\n     /// characters that are not skipped.\n@@ -78,54 +76,33 @@ impl EscapeError {\n /// Takes a contents of a literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n /// Values are returned through invoking of the provided callback.\n-pub fn unescape_literal<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+pub fn unescape_literal<F>(src: &str, mode: Mode, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n     match mode {\n         Mode::Char | Mode::Byte => {\n-            let mut chars = literal_text.chars();\n-            let result = unescape_char_or_byte(&mut chars, mode);\n-            // The Chars iterator moved forward.\n-            callback(0..(literal_text.len() - chars.as_str().len()), result);\n+            let mut chars = src.chars();\n+            let res = unescape_char_or_byte(&mut chars, mode == Mode::Byte);\n+            callback(0..(src.len() - chars.as_str().len()), res);\n         }\n-        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(literal_text, mode, callback),\n-        // NOTE: Raw strings do not perform any explicit character escaping, here we\n-        // only translate CRLF to LF and produce errors on bare CR.\n+        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(src, mode == Mode::ByteStr, callback),\n         Mode::RawStr | Mode::RawByteStr => {\n-            unescape_raw_str_or_raw_byte_str(literal_text, mode, callback)\n+            unescape_raw_str_or_raw_byte_str(src, mode == Mode::RawByteStr, callback)\n         }\n     }\n }\n \n-/// Takes a contents of a byte, byte string or raw byte string (without quotes)\n-/// and produces a sequence of bytes or errors.\n-/// Values are returned through invoking of the provided callback.\n-pub fn unescape_byte_literal<F>(literal_text: &str, mode: Mode, callback: &mut F)\n-where\n-    F: FnMut(Range<usize>, Result<u8, EscapeError>),\n-{\n-    debug_assert!(mode.is_bytes());\n-    unescape_literal(literal_text, mode, &mut |range, result| {\n-        callback(range, result.map(byte_from_char));\n-    })\n-}\n-\n /// Takes a contents of a char literal (without quotes), and returns an\n-/// unescaped char or an error\n-pub fn unescape_char(literal_text: &str) -> Result<char, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n+/// unescaped char or an error.\n+pub fn unescape_char(src: &str) -> Result<char, EscapeError> {\n+    unescape_char_or_byte(&mut src.chars(), false)\n }\n \n /// Takes a contents of a byte literal (without quotes), and returns an\n /// unescaped byte or an error.\n-pub fn unescape_byte(literal_text: &str) -> Result<u8, (usize, EscapeError)> {\n-    let mut chars = literal_text.chars();\n-    unescape_char_or_byte(&mut chars, Mode::Byte)\n-        .map(byte_from_char)\n-        .map_err(|err| (literal_text.len() - chars.as_str().len(), err))\n+pub fn unescape_byte(src: &str) -> Result<u8, EscapeError> {\n+    unescape_char_or_byte(&mut src.chars(), true).map(byte_from_char)\n }\n \n /// What kind of literal do we parse.\n@@ -147,20 +124,17 @@ impl Mode {\n         }\n     }\n \n-    pub fn is_bytes(self) -> bool {\n+    pub fn is_byte(self) -> bool {\n         match self {\n             Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n             Mode::Char | Mode::Str | Mode::RawStr => false,\n         }\n     }\n }\n \n-fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n     // Previous character was '\\\\', unescape what follows.\n-\n-    let second_char = chars.next().ok_or(EscapeError::LoneSlash)?;\n-\n-    let res = match second_char {\n+    let res = match chars.next().ok_or(EscapeError::LoneSlash)? {\n         '\"' => '\"',\n         'n' => '\\n',\n         'r' => '\\r',\n@@ -181,7 +155,7 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n             let value = hi * 16 + lo;\n \n             // For a non-byte literal verify that it is within ASCII range.\n-            if !mode.is_bytes() && !is_ascii(value) {\n+            if !is_byte && !is_ascii(value) {\n                 return Err(EscapeError::OutOfRangeHexEscape);\n             }\n             let value = value as u8;\n@@ -217,7 +191,7 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n \n                         // Incorrect syntax has higher priority for error reporting\n                         // than unallowed value for a literal.\n-                        if mode.is_bytes() {\n+                        if is_byte {\n                             return Err(EscapeError::UnicodeEscapeInByte);\n                         }\n \n@@ -249,23 +223,22 @@ fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n }\n \n #[inline]\n-fn ascii_check(first_char: char, mode: Mode) -> Result<char, EscapeError> {\n-    if mode.is_bytes() && !first_char.is_ascii() {\n+fn ascii_check(c: char, is_byte: bool) -> Result<char, EscapeError> {\n+    if is_byte && !c.is_ascii() {\n         // Byte literal can't be a non-ascii character.\n         Err(EscapeError::NonAsciiCharInByte)\n     } else {\n-        Ok(first_char)\n+        Ok(c)\n     }\n }\n \n-fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n-    debug_assert!(mode == Mode::Char || mode == Mode::Byte);\n-    let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n-    let res = match first_char {\n-        '\\\\' => scan_escape(chars, mode),\n+fn unescape_char_or_byte(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n+    let c = chars.next().ok_or(EscapeError::ZeroChars)?;\n+    let res = match c {\n+        '\\\\' => scan_escape(chars, is_byte),\n         '\\n' | '\\t' | '\\'' => Err(EscapeError::EscapeOnlyChar),\n         '\\r' => Err(EscapeError::BareCarriageReturn),\n-        _ => ascii_check(first_char, mode),\n+        _ => ascii_check(c, is_byte),\n     }?;\n     if chars.next().is_some() {\n         return Err(EscapeError::MoreThanOneChar);\n@@ -275,20 +248,20 @@ fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, Esca\n \n /// Takes a contents of a string literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n-fn unescape_str_or_byte_str<F>(src: &str, mode: Mode, callback: &mut F)\n+fn unescape_str_or_byte_str<F>(src: &str, is_byte: bool, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    debug_assert!(mode == Mode::Str || mode == Mode::ByteStr);\n-    let initial_len = src.len();\n     let mut chars = src.chars();\n-    while let Some(first_char) = chars.next() {\n-        let start = initial_len - chars.as_str().len() - first_char.len_utf8();\n \n-        let unescaped_char = match first_char {\n+    // The `start` and `end` computation here is complicated because\n+    // `skip_ascii_whitespace` makes us to skip over chars without counting\n+    // them in the range computation.\n+    while let Some(c) = chars.next() {\n+        let start = src.len() - chars.as_str().len() - c.len_utf8();\n+        let res = match c {\n             '\\\\' => {\n-                let second_char = chars.clone().next();\n-                match second_char {\n+                match chars.clone().next() {\n                     Some('\\n') => {\n                         // Rust language specification requires us to skip whitespaces\n                         // if unescaped '\\' character is followed by '\\n'.\n@@ -297,17 +270,17 @@ where\n                         skip_ascii_whitespace(&mut chars, start, callback);\n                         continue;\n                     }\n-                    _ => scan_escape(&mut chars, mode),\n+                    _ => scan_escape(&mut chars, is_byte),\n                 }\n             }\n             '\\n' => Ok('\\n'),\n             '\\t' => Ok('\\t'),\n             '\"' => Err(EscapeError::EscapeOnlyChar),\n             '\\r' => Err(EscapeError::BareCarriageReturn),\n-            _ => ascii_check(first_char, mode),\n+            _ => ascii_check(c, is_byte),\n         };\n-        let end = initial_len - chars.as_str().len();\n-        callback(start..end, unescaped_char);\n+        let end = src.len() - chars.as_str().len();\n+        callback(start..end, res);\n     }\n \n     fn skip_ascii_whitespace<F>(chars: &mut Chars<'_>, start: usize, callback: &mut F)\n@@ -340,30 +313,29 @@ where\n /// Takes a contents of a string literal (without quotes) and produces a\n /// sequence of characters or errors.\n /// NOTE: Raw strings do not perform any explicit character escaping, here we\n-/// only translate CRLF to LF and produce errors on bare CR.\n-fn unescape_raw_str_or_raw_byte_str<F>(literal_text: &str, mode: Mode, callback: &mut F)\n+/// only produce errors on bare CR.\n+fn unescape_raw_str_or_raw_byte_str<F>(src: &str, is_byte: bool, callback: &mut F)\n where\n     F: FnMut(Range<usize>, Result<char, EscapeError>),\n {\n-    debug_assert!(mode == Mode::RawStr || mode == Mode::RawByteStr);\n-    let initial_len = literal_text.len();\n-\n-    let mut chars = literal_text.chars();\n-    while let Some(curr) = chars.next() {\n-        let start = initial_len - chars.as_str().len() - curr.len_utf8();\n+    let mut chars = src.chars();\n \n-        let result = match curr {\n+    // The `start` and `end` computation here matches the one in\n+    // `unescape_str_or_byte_str` for consistency, even though this function\n+    // doesn't have to worry about skipping any chars.\n+    while let Some(c) = chars.next() {\n+        let start = src.len() - chars.as_str().len() - c.len_utf8();\n+        let res = match c {\n             '\\r' => Err(EscapeError::BareCarriageReturnInRawString),\n-            c if mode.is_bytes() && !c.is_ascii() => Err(EscapeError::NonAsciiCharInByteString),\n-            c => Ok(c),\n+            _ => ascii_check(c, is_byte),\n         };\n-        let end = initial_len - chars.as_str().len();\n-\n-        callback(start..end, result);\n+        let end = src.len() - chars.as_str().len();\n+        callback(start..end, res);\n     }\n }\n \n-fn byte_from_char(c: char) -> u8 {\n+#[inline]\n+pub fn byte_from_char(c: char) -> u8 {\n     let res = c as u32;\n     debug_assert!(res <= u8::MAX as u32, \"guaranteed because of Mode::ByteStr\");\n     res as u8"}, {"sha": "c7ca8fd16ae479cf7978913e8a0ea961cde2afc1", "filename": "compiler/rustc_lexer/src/unescape/tests.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -3,8 +3,7 @@ use super::*;\n #[test]\n fn test_unescape_char_bad() {\n     fn check(literal_text: &str, expected_error: EscapeError) {\n-        let actual_result = unescape_char(literal_text).map_err(|(_offset, err)| err);\n-        assert_eq!(actual_result, Err(expected_error));\n+        assert_eq!(unescape_char(literal_text), Err(expected_error));\n     }\n \n     check(\"\", EscapeError::ZeroChars);\n@@ -68,8 +67,7 @@ fn test_unescape_char_bad() {\n #[test]\n fn test_unescape_char_good() {\n     fn check(literal_text: &str, expected_char: char) {\n-        let actual_result = unescape_char(literal_text);\n-        assert_eq!(actual_result, Ok(expected_char));\n+        assert_eq!(unescape_char(literal_text), Ok(expected_char));\n     }\n \n     check(\"a\", 'a');\n@@ -149,8 +147,7 @@ fn test_unescape_str_good() {\n #[test]\n fn test_unescape_byte_bad() {\n     fn check(literal_text: &str, expected_error: EscapeError) {\n-        let actual_result = unescape_byte(literal_text).map_err(|(_offset, err)| err);\n-        assert_eq!(actual_result, Err(expected_error));\n+        assert_eq!(unescape_byte(literal_text), Err(expected_error));\n     }\n \n     check(\"\", EscapeError::ZeroChars);\n@@ -219,8 +216,7 @@ fn test_unescape_byte_bad() {\n #[test]\n fn test_unescape_byte_good() {\n     fn check(literal_text: &str, expected_byte: u8) {\n-        let actual_result = unescape_byte(literal_text);\n-        assert_eq!(actual_result, Ok(expected_byte));\n+        assert_eq!(unescape_byte(literal_text), Ok(expected_byte));\n     }\n \n     check(\"a\", b'a');\n@@ -246,10 +242,10 @@ fn test_unescape_byte_good() {\n fn test_unescape_byte_str_good() {\n     fn check(literal_text: &str, expected: &[u8]) {\n         let mut buf = Ok(Vec::with_capacity(literal_text.len()));\n-        unescape_byte_literal(literal_text, Mode::ByteStr, &mut |range, c| {\n+        unescape_literal(literal_text, Mode::ByteStr, &mut |range, c| {\n             if let Ok(b) = &mut buf {\n                 match c {\n-                    Ok(c) => b.push(c),\n+                    Ok(c) => b.push(byte_from_char(c)),\n                     Err(e) => buf = Err((range, e)),\n                 }\n             }\n@@ -280,18 +276,13 @@ fn test_unescape_raw_str() {\n \n #[test]\n fn test_unescape_raw_byte_str() {\n-    fn check(literal: &str, expected: &[(Range<usize>, Result<u8, EscapeError>)]) {\n+    fn check(literal: &str, expected: &[(Range<usize>, Result<char, EscapeError>)]) {\n         let mut unescaped = Vec::with_capacity(literal.len());\n-        unescape_byte_literal(literal, Mode::RawByteStr, &mut |range, res| {\n-            unescaped.push((range, res))\n-        });\n+        unescape_literal(literal, Mode::RawByteStr, &mut |range, res| unescaped.push((range, res)));\n         assert_eq!(unescaped, expected);\n     }\n \n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n-    check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByteString))]);\n-    check(\n-        \"\ud83e\udd80a\",\n-        &[(0..4, Err(EscapeError::NonAsciiCharInByteString)), (4..5, Ok(byte_from_char('a')))],\n-    );\n+    check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByte))]);\n+    check(\"\ud83e\udd80a\", &[(0..4, Err(EscapeError::NonAsciiCharInByte)), (4..5, Ok('a'))]);\n }"}, {"sha": "28f6ac61c5bddbed6d2553ef552b69f244063b75", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -579,6 +579,7 @@ pub trait LintContext: Sized {\n     /// Return value of the `decorate` closure is ignored, see [`struct_lint_level`] for a detailed explanation.\n     ///\n     /// [`struct_lint_level`]: rustc_middle::lint::struct_lint_level#decorate-signature\n+    #[rustc_lint_diagnostics]\n     fn lookup_with_diagnostics(\n         &self,\n         lint: &'static Lint,\n@@ -882,6 +883,7 @@ pub trait LintContext: Sized {\n     /// Return value of the `decorate` closure is ignored, see [`struct_lint_level`] for a detailed explanation.\n     ///\n     /// [`struct_lint_level`]: rustc_middle::lint::struct_lint_level#decorate-signature\n+    #[rustc_lint_diagnostics]\n     fn lookup<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,\n@@ -908,6 +910,7 @@ pub trait LintContext: Sized {\n     /// Return value of the `decorate` closure is ignored, see [`struct_lint_level`] for a detailed explanation.\n     ///\n     /// [`struct_lint_level`]: rustc_middle::lint::struct_lint_level#decorate-signature\n+    #[rustc_lint_diagnostics]\n     fn struct_span_lint<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,\n@@ -933,6 +936,7 @@ pub trait LintContext: Sized {\n     /// Return value of the `decorate` closure is ignored, see [`struct_lint_level`] for a detailed explanation.\n     ///\n     /// [`struct_lint_level`]: rustc_middle::lint::struct_lint_level#decorate-signature\n+    #[rustc_lint_diagnostics]\n     fn lint(\n         &self,\n         lint: &'static Lint,"}, {"sha": "dfe52312ff00d9ba188b0ab2764a753ee0196db6", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1073,6 +1073,7 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n     /// Return value of the `decorate` closure is ignored, see [`struct_lint_level`] for a detailed explanation.\n     ///\n     /// [`struct_lint_level`]: rustc_middle::lint::struct_lint_level#decorate-signature\n+    #[rustc_lint_diagnostics]\n     pub(crate) fn struct_lint(\n         &self,\n         lint: &'static Lint,"}, {"sha": "ebb7de70e0570303252825af7696f440e8e33c26", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -36,6 +36,7 @@\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n+#![feature(rustc_attrs)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "4612f54e4b17639292af0024191668a74d41f922", "filename": "compiler/rustc_macros/src/diagnostics/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ferror.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -84,7 +84,7 @@ pub(crate) fn invalid_attr(attr: &Attribute, meta: &Meta) -> Diagnostic {\n     }\n }\n \n-/// Emit a error diagnostic for an invalid attribute (optionally performing additional decoration\n+/// Emit an error diagnostic for an invalid attribute (optionally performing additional decoration\n /// using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n ///\n /// For methods that return a `Result<_, DiagnosticDeriveError>`:\n@@ -126,7 +126,7 @@ pub(crate) fn invalid_nested_attr(attr: &Attribute, nested: &NestedMeta) -> Diag\n     }\n }\n \n-/// Emit a error diagnostic for an invalid nested attribute (optionally performing additional\n+/// Emit an error diagnostic for an invalid nested attribute (optionally performing additional\n /// decoration using the `FnOnce` passed in `diag`) and return `Err(ErrorHandled)`.\n ///\n /// For methods that return a `Result<_, DiagnosticDeriveError>`:"}, {"sha": "0331d764b38a1469bcdf81dc65129478167f5978", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -336,8 +336,10 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                         tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())).into()\n                     }\n                     GenericArgKind::Lifetime(..) => {\n-                        let br =\n-                            ty::BoundRegion { var: ty::BoundVar::from_u32(i), kind: ty::BrAnon(i) };\n+                        let br = ty::BoundRegion {\n+                            var: ty::BoundVar::from_u32(i),\n+                            kind: ty::BrAnon(i, None),\n+                        };\n                         tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n                     }\n                     GenericArgKind::Const(ct) => tcx"}, {"sha": "51df42f6d14e06a3ddfff7346d82fa3f14a85e06", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -276,7 +276,7 @@ pub fn explain_lint_level_source(\n \n /// The innermost function for emitting lints.\n ///\n-/// If you are loocking to implement a lint, look for higher level functions,\n+/// If you are looking to implement a lint, look for higher level functions,\n /// for example:\n /// - [`TyCtxt::emit_spanned_lint`]\n /// - [`TyCtxt::struct_span_lint_hir`]"}, {"sha": "3a91522d362298400438eb5ee0446c2f10522d7c", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 103, "deletions": 21, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,12 +1,14 @@\n //! A pass that checks to make sure private fields and methods aren't used\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n-use crate::ty::{DefIdTree, Visibility};\n+use crate::ty::{DefIdTree, TyCtxt, Visibility};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_hir::def::DefKind;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_span::def_id::LocalDefId;\n+use std::hash::Hash;\n \n /// Represents the levels of effective visibility an item can have.\n ///\n@@ -74,9 +76,9 @@ impl EffectiveVisibility {\n }\n \n /// Holds a map of effective visibilities for reachable HIR nodes.\n-#[derive(Default, Clone, Debug)]\n-pub struct EffectiveVisibilities {\n-    map: FxHashMap<LocalDefId, EffectiveVisibility>,\n+#[derive(Clone, Debug)]\n+pub struct EffectiveVisibilities<Id = LocalDefId> {\n+    map: FxHashMap<Id, EffectiveVisibility>,\n }\n \n impl EffectiveVisibilities {\n@@ -111,12 +113,30 @@ impl EffectiveVisibilities {\n         })\n     }\n \n-    pub fn effective_vis(&self, id: LocalDefId) -> Option<&EffectiveVisibility> {\n-        self.map.get(&id)\n-    }\n-\n-    pub fn iter(&self) -> impl Iterator<Item = (&LocalDefId, &EffectiveVisibility)> {\n-        self.map.iter()\n+    // FIXME: Share code with `fn update`.\n+    pub fn update_eff_vis(\n+        &mut self,\n+        def_id: LocalDefId,\n+        eff_vis: &EffectiveVisibility,\n+        tree: impl DefIdTree,\n+    ) {\n+        use std::collections::hash_map::Entry;\n+        match self.map.entry(def_id) {\n+            Entry::Occupied(mut occupied) => {\n+                let old_eff_vis = occupied.get_mut();\n+                for l in Level::all_levels() {\n+                    let vis_at_level = eff_vis.at_level(l);\n+                    let old_vis_at_level = old_eff_vis.at_level_mut(l);\n+                    if vis_at_level != old_vis_at_level\n+                        && vis_at_level.is_at_least(*old_vis_at_level, tree)\n+                    {\n+                        *old_vis_at_level = *vis_at_level\n+                    }\n+                }\n+                old_eff_vis\n+            }\n+            Entry::Vacant(vacant) => vacant.insert(*eff_vis),\n+        };\n     }\n \n     pub fn set_public_at_level(\n@@ -137,26 +157,82 @@ impl EffectiveVisibilities {\n         self.map.insert(id, effective_vis);\n     }\n \n+    pub fn check_invariants(&self, tcx: TyCtxt<'_>, early: bool) {\n+        if !cfg!(debug_assertions) {\n+            return;\n+        }\n+        for (&def_id, ev) in &self.map {\n+            // More direct visibility levels can never go farther than less direct ones,\n+            // neither of effective visibilities can go farther than nominal visibility,\n+            // and all effective visibilities are larger or equal than private visibility.\n+            let private_vis = Visibility::Restricted(tcx.parent_module_from_def_id(def_id));\n+            let span = tcx.def_span(def_id.to_def_id());\n+            if !ev.direct.is_at_least(private_vis, tcx) {\n+                span_bug!(span, \"private {:?} > direct {:?}\", private_vis, ev.direct);\n+            }\n+            if !ev.reexported.is_at_least(ev.direct, tcx) {\n+                span_bug!(span, \"direct {:?} > reexported {:?}\", ev.direct, ev.reexported);\n+            }\n+            if !ev.reachable.is_at_least(ev.reexported, tcx) {\n+                span_bug!(span, \"reexported {:?} > reachable {:?}\", ev.reexported, ev.reachable);\n+            }\n+            if !ev.reachable_through_impl_trait.is_at_least(ev.reachable, tcx) {\n+                span_bug!(\n+                    span,\n+                    \"reachable {:?} > reachable_through_impl_trait {:?}\",\n+                    ev.reachable,\n+                    ev.reachable_through_impl_trait\n+                );\n+            }\n+            let nominal_vis = tcx.visibility(def_id);\n+            let def_kind = tcx.opt_def_kind(def_id);\n+            // FIXME: `rustc_privacy` is not yet updated for the new logic and can set\n+            // effective visibilities that are larger than the nominal one.\n+            if !nominal_vis.is_at_least(ev.reachable_through_impl_trait, tcx) && early {\n+                span_bug!(\n+                    span,\n+                    \"{:?}: reachable_through_impl_trait {:?} > nominal {:?}\",\n+                    def_id,\n+                    ev.reachable_through_impl_trait,\n+                    nominal_vis\n+                );\n+            }\n+            // Fully private items are never put into the table, this is important for performance.\n+            // FIXME: Fully private `mod` items are currently put into the table.\n+            if ev.reachable_through_impl_trait == private_vis && def_kind != Some(DefKind::Mod) {\n+                span_bug!(span, \"fully private item in the table {:?}: {:?}\", def_id, ev.direct);\n+            }\n+        }\n+    }\n+}\n+\n+impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n+    pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n+        self.map.iter()\n+    }\n+\n+    pub fn effective_vis(&self, id: Id) -> Option<&EffectiveVisibility> {\n+        self.map.get(&id)\n+    }\n+\n     // `parent_id` is not necessarily a parent in source code tree,\n     // it is the node from which the maximum effective visibility is inherited.\n     pub fn update(\n         &mut self,\n-        id: LocalDefId,\n+        id: Id,\n         nominal_vis: Visibility,\n-        default_vis: impl FnOnce() -> Visibility,\n-        parent_id: LocalDefId,\n+        default_vis: Visibility,\n+        inherited_eff_vis: Option<EffectiveVisibility>,\n         level: Level,\n         tree: impl DefIdTree,\n     ) -> bool {\n         let mut changed = false;\n-        let mut current_effective_vis = self.effective_vis(id).copied().unwrap_or_else(|| {\n-            if id.is_top_level_module() {\n-                EffectiveVisibility::from_vis(Visibility::Public)\n-            } else {\n-                EffectiveVisibility::from_vis(default_vis())\n-            }\n-        });\n-        if let Some(inherited_effective_vis) = self.effective_vis(parent_id) {\n+        let mut current_effective_vis = self\n+            .map\n+            .get(&id)\n+            .copied()\n+            .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis));\n+        if let Some(inherited_effective_vis) = inherited_eff_vis {\n             let mut inherited_effective_vis_at_prev_level =\n                 *inherited_effective_vis.at_level(level);\n             let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;\n@@ -194,6 +270,12 @@ impl EffectiveVisibilities {\n     }\n }\n \n+impl<Id> Default for EffectiveVisibilities<Id> {\n+    fn default() -> Self {\n+        EffectiveVisibilities { map: Default::default() }\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for EffectiveVisibilities {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         let EffectiveVisibilities { ref map } = *self;"}, {"sha": "5290d5aae46cace29409d3701790972ce37b4810", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -138,6 +138,48 @@ impl MirPhase {\n             }\n         }\n     }\n+\n+    /// Parses an `MirPhase` from a pair of strings. Panics if this isn't possible for any reason.\n+    pub fn parse(dialect: String, phase: Option<String>) -> Self {\n+        match &*dialect.to_ascii_lowercase() {\n+            \"built\" => {\n+                assert!(phase.is_none(), \"Cannot specify a phase for `Built` MIR\");\n+                MirPhase::Built\n+            }\n+            \"analysis\" => Self::Analysis(AnalysisPhase::parse(phase)),\n+            \"runtime\" => Self::Runtime(RuntimePhase::parse(phase)),\n+            _ => panic!(\"Unknown MIR dialect {}\", dialect),\n+        }\n+    }\n+}\n+\n+impl AnalysisPhase {\n+    pub fn parse(phase: Option<String>) -> Self {\n+        let Some(phase) = phase else {\n+            return Self::Initial;\n+        };\n+\n+        match &*phase.to_ascii_lowercase() {\n+            \"initial\" => Self::Initial,\n+            \"post_cleanup\" | \"post-cleanup\" | \"postcleanup\" => Self::PostCleanup,\n+            _ => panic!(\"Unknown analysis phase {}\", phase),\n+        }\n+    }\n+}\n+\n+impl RuntimePhase {\n+    pub fn parse(phase: Option<String>) -> Self {\n+        let Some(phase) = phase else {\n+            return Self::Initial;\n+        };\n+\n+        match &*phase.to_ascii_lowercase() {\n+            \"initial\" => Self::Initial,\n+            \"post_cleanup\" | \"post-cleanup\" | \"postcleanup\" => Self::PostCleanup,\n+            \"optimized\" => Self::Optimized,\n+            _ => panic!(\"Unknown runtime phase {}\", phase),\n+        }\n+    }\n }\n \n impl Display for MirPhase {\n@@ -293,6 +335,13 @@ pub struct Body<'tcx> {\n     /// potentially allow things like `[u8; std::mem::size_of::<T>() * 0]` due to this.\n     pub is_polymorphic: bool,\n \n+    /// The phase at which this MIR should be \"injected\" into the compilation process.\n+    ///\n+    /// Everything that comes before this `MirPhase` should be skipped.\n+    ///\n+    /// This is only `Some` if the function that this body comes from was annotated with `rustc_custom_mir`.\n+    pub injection_phase: Option<MirPhase>,\n+\n     pub tainted_by_errors: Option<ErrorGuaranteed>,\n }\n \n@@ -339,6 +388,7 @@ impl<'tcx> Body<'tcx> {\n             span,\n             required_consts: Vec::new(),\n             is_polymorphic: false,\n+            injection_phase: None,\n             tainted_by_errors,\n         };\n         body.is_polymorphic = body.has_non_region_param();\n@@ -366,6 +416,7 @@ impl<'tcx> Body<'tcx> {\n             required_consts: Vec::new(),\n             var_debug_info: Vec::new(),\n             is_polymorphic: false,\n+            injection_phase: None,\n             tainted_by_errors: None,\n         };\n         body.is_polymorphic = body.has_non_region_param();\n@@ -508,6 +559,14 @@ impl<'tcx> Body<'tcx> {\n     pub fn generator_kind(&self) -> Option<GeneratorKind> {\n         self.generator.as_ref().map(|generator| generator.generator_kind)\n     }\n+\n+    #[inline]\n+    pub fn should_skip(&self) -> bool {\n+        let Some(injection_phase) = self.injection_phase else {\n+            return false;\n+        };\n+        injection_phase > self.phase\n+    }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug, TyEncodable, TyDecodable, HashStable)]"}, {"sha": "00242e7eed775ff925c370f6aedcf5315e186b45", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -271,6 +271,10 @@ rustc_queries! {\n         desc { |tcx| \"elaborating item bounds for `{}`\", tcx.def_path_str(key) }\n     }\n \n+    /// Look up all native libraries this crate depends on.\n+    /// These are assembled from the following places:\n+    /// - `extern` blocks (depending on their `link` attributes)\n+    /// - the `libs` (`-l`) option\n     query native_libraries(_: CrateNum) -> Vec<NativeLib> {\n         arena_cache\n         desc { \"looking up the native libraries of a linked crate\" }\n@@ -1539,6 +1543,7 @@ rustc_queries! {\n         desc { \"available upstream drop-glue for `{:?}`\", substs }\n     }\n \n+    /// Returns a list of all `extern` blocks of a crate.\n     query foreign_modules(_: CrateNum) -> FxHashMap<DefId, ForeignModule> {\n         arena_cache\n         desc { \"looking up the foreign modules of a linked crate\" }\n@@ -1550,27 +1555,37 @@ rustc_queries! {\n     query entry_fn(_: ()) -> Option<(DefId, EntryFnType)> {\n         desc { \"looking up the entry function of a crate\" }\n     }\n+\n+    /// Finds the `rustc_proc_macro_decls` item of a crate.\n     query proc_macro_decls_static(_: ()) -> Option<LocalDefId> {\n-        desc { \"looking up the derive registrar for a crate\" }\n+        desc { \"looking up the proc macro declarations for a crate\" }\n     }\n+\n     // The macro which defines `rustc_metadata::provide_extern` depends on this query's name.\n     // Changing the name should cause a compiler error, but in case that changes, be aware.\n     query crate_hash(_: CrateNum) -> Svh {\n         eval_always\n         desc { \"looking up the hash a crate\" }\n         separate_provide_extern\n     }\n+\n+    /// Gets the hash for the host proc macro. Used to support -Z dual-proc-macro.\n     query crate_host_hash(_: CrateNum) -> Option<Svh> {\n         eval_always\n         desc { \"looking up the hash of a host version of a crate\" }\n         separate_provide_extern\n     }\n+\n+    /// Gets the extra data to put in each output filename for a crate.\n+    /// For example, compiling the `foo` crate with `extra-filename=-a` creates a `libfoo-b.rlib` file.\n     query extra_filename(_: CrateNum) -> String {\n         arena_cache\n         eval_always\n         desc { \"looking up the extra filename for a crate\" }\n         separate_provide_extern\n     }\n+\n+    /// Gets the paths where the crate came from in the file system.\n     query crate_extern_paths(_: CrateNum) -> Vec<PathBuf> {\n         arena_cache\n         eval_always\n@@ -1594,6 +1609,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    /// Get the corresponding native library from the `native_libraries` query\n     query native_library(def_id: DefId) -> Option<&'tcx NativeLib> {\n         desc { |tcx| \"getting the native library for `{}`\", tcx.def_path_str(def_id) }\n     }"}, {"sha": "05382bd887cd9e2bb92b4c706109b21953e43e9c", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -438,6 +438,8 @@ pub enum ObligationCauseCode<'tcx> {\n     },\n \n     AscribeUserTypeProvePredicate(Span),\n+\n+    RustCall,\n }\n \n /// The 'location' at which we try to perform HIR-based wf checking.\n@@ -574,9 +576,6 @@ pub enum SelectionError<'tcx> {\n     /// Signaling that an error has already been emitted, to avoid\n     /// multiple errors being shown.\n     ErrorReporting,\n-    /// Multiple applicable `impl`s where found. The `DefId`s correspond to\n-    /// all the `impl`s' Items.\n-    Ambiguous(Vec<DefId>),\n }\n \n /// When performing resolution, it is typically the case that there"}, {"sha": "2a93df771e1e225c23028c0412a32442a65473b8", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1283,6 +1283,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Constructs a `TyKind::Error` type with current `ErrorGuaranteed`\n+    #[track_caller]\n+    pub fn ty_error_with_guaranteed(self, reported: ErrorGuaranteed) -> Ty<'tcx> {\n+        self.mk_ty(Error(reported))\n+    }\n+\n     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` to ensure it gets used.\n     #[track_caller]\n     pub fn ty_error(self) -> Ty<'tcx> {\n@@ -1297,6 +1303,16 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(Error(reported))\n     }\n \n+    /// Like [TyCtxt::ty_error] but for constants, with current `ErrorGuaranteed`\n+    #[track_caller]\n+    pub fn const_error_with_guaranteed(\n+        self,\n+        ty: Ty<'tcx>,\n+        reported: ErrorGuaranteed,\n+    ) -> Const<'tcx> {\n+        self.mk_const(ty::ConstKind::Error(reported), ty)\n+    }\n+\n     /// Like [TyCtxt::ty_error] but for constants.\n     #[track_caller]\n     pub fn const_error(self, ty: Ty<'tcx>) -> Const<'tcx> {\n@@ -2813,7 +2829,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         span: impl Into<MultiSpan>,\n         decorator: impl for<'a> DecorateLint<'a, ()>,\n     ) {\n-        self.struct_span_lint_hir(lint, hir_id, span, decorator.msg(), |diag| {\n+        let msg = decorator.msg();\n+        let (level, src) = self.lint_level_at_node(lint, hir_id);\n+        struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg, |diag| {\n             decorator.decorate_lint(diag)\n         })\n     }\n@@ -2823,6 +2841,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Return value of the `decorate` closure is ignored, see [`struct_lint_level`] for a detailed explanation.\n     ///\n     /// [`struct_lint_level`]: rustc_middle::lint::struct_lint_level#decorate-signature\n+    #[rustc_lint_diagnostics]\n     pub fn struct_span_lint_hir(\n         self,\n         lint: &'static Lint,\n@@ -2853,6 +2872,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Return value of the `decorate` closure is ignored, see [`struct_lint_level`] for a detailed explanation.\n     ///\n     /// [`struct_lint_level`]: rustc_middle::lint::struct_lint_level#decorate-signature\n+    #[rustc_lint_diagnostics]\n     pub fn struct_lint_node(\n         self,\n         lint: &'static Lint,"}, {"sha": "dc13374f992eb7589f6eb919b50024314ab5d1ba", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -430,7 +430,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                     (ty::Projection(_), ty::Projection(_)) => {\n                         diag.note(\"an associated type was expected, but a different one was found\");\n                     }\n-                    (ty::Param(p), ty::Projection(proj)) | (ty::Projection(proj), ty::Param(p)) => {\n+                    (ty::Param(p), ty::Projection(proj)) | (ty::Projection(proj), ty::Param(p))\n+                        if self.def_kind(proj.item_def_id) != DefKind::ImplTraitPlaceholder =>\n+                    {\n                         let generics = self.generics_of(body_owner_def_id);\n                         let p_span = self.def_span(generics.type_param(p, self).def_id);\n                         if !sp.contains(p_span) {"}, {"sha": "2842b3c3102d24cceadc3058acb654015b0b4fc7", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -598,15 +598,15 @@ impl<'tcx> TyCtxt<'tcx> {\n             .replace_late_bound_regions(sig, |_| {\n                 let br = ty::BoundRegion {\n                     var: ty::BoundVar::from_u32(counter),\n-                    kind: ty::BrAnon(counter),\n+                    kind: ty::BrAnon(counter, None),\n                 };\n                 let r = self.mk_region(ty::ReLateBound(ty::INNERMOST, br));\n                 counter += 1;\n                 r\n             })\n             .0;\n         let bound_vars = self.mk_bound_variable_kinds(\n-            (0..counter).map(|i| ty::BoundVariableKind::Region(ty::BrAnon(i))),\n+            (0..counter).map(|i| ty::BoundVariableKind::Region(ty::BrAnon(i, None))),\n         );\n         Binder::bind_with_vars(inner, bound_vars)\n     }\n@@ -626,7 +626,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let index = entry.index();\n                 let var = ty::BoundVar::from_usize(index);\n                 let kind = entry\n-                    .or_insert_with(|| ty::BoundVariableKind::Region(ty::BrAnon(index as u32)))\n+                    .or_insert_with(|| {\n+                        ty::BoundVariableKind::Region(ty::BrAnon(index as u32, None))\n+                    })\n                     .expect_region();\n                 let br = ty::BoundRegion { var, kind };\n                 self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br))"}, {"sha": "ae0f158ede99a17e1ed5f6362b98f8c41898e3d8", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -511,12 +511,12 @@ impl<'tcx> Instance<'tcx> {\n         Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap().unwrap()\n     }\n \n+    #[instrument(level = \"debug\", skip(tcx), ret)]\n     pub fn fn_once_adapter_instance(\n         tcx: TyCtxt<'tcx>,\n         closure_did: DefId,\n         substs: ty::SubstsRef<'tcx>,\n     ) -> Option<Instance<'tcx>> {\n-        debug!(\"fn_once_adapter_shim({:?}, {:?})\", closure_did, substs);\n         let fn_once = tcx.require_lang_item(LangItem::FnOnce, None);\n         let call_once = tcx\n             .associated_items(fn_once)\n@@ -536,7 +536,7 @@ impl<'tcx> Instance<'tcx> {\n         assert_eq!(sig.inputs().len(), 1);\n         let substs = tcx.mk_substs_trait(self_ty, &[sig.inputs()[0].into()]);\n \n-        debug!(\"fn_once_adapter_shim: self_ty={:?} sig={:?}\", self_ty, sig);\n+        debug!(?self_ty, ?sig);\n         Some(Instance { def, substs })\n     }\n "}, {"sha": "c74d6bc3774a2d19030b27fc481a6d363b85cb02", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -189,8 +189,8 @@ pub enum LayoutError<'tcx> {\n     NormalizationFailure(Ty<'tcx>, NormalizationError<'tcx>),\n }\n \n-impl<'a> IntoDiagnostic<'a, !> for LayoutError<'a> {\n-    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, !> {\n+impl IntoDiagnostic<'_, !> for LayoutError<'_> {\n+    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n         let mut diag = handler.struct_fatal(\"\");\n \n         match self {\n@@ -1126,8 +1126,8 @@ impl<'tcx> fmt::Display for FnAbiError<'tcx> {\n     }\n }\n \n-impl<'tcx> IntoDiagnostic<'tcx, !> for FnAbiError<'tcx> {\n-    fn into_diagnostic(self, handler: &'tcx Handler) -> DiagnosticBuilder<'tcx, !> {\n+impl IntoDiagnostic<'_, !> for FnAbiError<'_> {\n+    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n         handler.struct_fatal(self.to_string())\n     }\n }"}, {"sha": "b509ae6dd3b8527f67b2dcdcf22d160bfc4a2a63", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -2550,11 +2550,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n-    pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n-        if let Some(impl_did) = impl_did.as_local() {\n-            Ok(self.def_span(impl_did))\n+    pub fn span_of_impl(self, impl_def_id: DefId) -> Result<Span, Symbol> {\n+        if let Some(impl_def_id) = impl_def_id.as_local() {\n+            Ok(self.def_span(impl_def_id))\n         } else {\n-            Err(self.crate_name(impl_did.krate))\n+            Err(self.crate_name(impl_def_id.krate))\n         }\n     }\n "}, {"sha": "2432b5175197b791e70e305d2a8d28111a11442c", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1659,6 +1659,12 @@ impl<'t> TyCtxt<'t> {\n         debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n         FmtPrinter::new(self, ns).print_def_path(def_id, substs).unwrap().into_buffer()\n     }\n+\n+    pub fn value_path_str_with_substs(self, def_id: DefId, substs: &'t [GenericArg<'t>]) -> String {\n+        let ns = guess_def_namespace(self, def_id);\n+        debug!(\"value_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n+        FmtPrinter::new(self, ns).print_value_path(def_id, substs).unwrap().into_buffer()\n+    }\n }\n \n impl fmt::Write for FmtPrinter<'_, '_> {\n@@ -2115,7 +2121,7 @@ impl<'a, 'tcx> ty::TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n                 // If this is an anonymous placeholder, don't rename. Otherwise, in some\n                 // async fns, we get a `for<'r> Send` bound\n                 match kind {\n-                    ty::BrAnon(_) | ty::BrEnv => r,\n+                    ty::BrAnon(..) | ty::BrEnv => r,\n                     _ => {\n                         // Index doesn't matter, since this is just for naming and these never get bound\n                         let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind };\n@@ -2226,10 +2232,10 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                     let ty::BoundVariableKind::Region(var) = var else {\n                     // This doesn't really matter because it doesn't get used,\n                     // it's just an empty value\n-                    return ty::BrAnon(0);\n+                    return ty::BrAnon(0, None);\n                 };\n                     match var {\n-                        ty::BrAnon(_) | ty::BrEnv => {\n+                        ty::BrAnon(..) | ty::BrEnv => {\n                             start_or_continue(&mut self, \"for<\", \", \");\n                             let name = next_name(&self);\n                             debug!(?name);\n@@ -2271,7 +2277,7 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n                             binder_level_idx: ty::DebruijnIndex,\n                             br: ty::BoundRegion| {\n                 let (name, kind) = match br.kind {\n-                    ty::BrAnon(_) | ty::BrEnv => {\n+                    ty::BrAnon(..) | ty::BrEnv => {\n                         let name = next_name(&self);\n \n                         if let Some(lt_idx) = lifetime_idx {"}, {"sha": "9f0598d0ba86b2e461b2110c57f4465859bbc92a", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -68,7 +68,7 @@ impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n impl fmt::Debug for ty::BoundRegionKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            ty::BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n+            ty::BrAnon(n, span) => write!(f, \"BrAnon({n:?}, {span:?})\"),\n             ty::BrNamed(did, name) => {\n                 if did.is_crate_root() {\n                     write!(f, \"BrNamed({})\", name)"}, {"sha": "49d82b503a4bb9f59caee7ddf9753aa951aab749", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -59,7 +59,7 @@ pub struct FreeRegion {\n #[derive(HashStable)]\n pub enum BoundRegionKind {\n     /// An anonymous region parameter for a given fn (&T)\n-    BrAnon(u32),\n+    BrAnon(u32, Option<Span>),\n \n     /// Named region parameters for functions (a in &'a T)\n     ///"}, {"sha": "5e366ef703f254f22b9fec8a17c8813e733aafa9", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -97,7 +97,11 @@ pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n     }\n     fn error_reported(&self) -> Result<(), ErrorGuaranteed> {\n         if self.references_error() {\n-            Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n+            if let Some(reported) = ty::tls::with(|tcx| tcx.sess.has_errors()) {\n+                Err(reported)\n+            } else {\n+                bug!(\"expect tcx.sess.has_errors return true\");\n+            }\n         } else {\n             Ok(())\n         }"}, {"sha": "68d8766c9073414e507e011887a0cfd5af63785e", "filename": "compiler/rustc_mir_build/src/build/custom/mod.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -0,0 +1,155 @@\n+//! Provides the implementation of the `custom_mir` attribute.\n+//!\n+//! Up until MIR building, this attribute has absolutely no effect. The `mir!` macro is a normal\n+//! decl macro that expands like any other, and the code goes through parsing, name resolution and\n+//! type checking like all other code. In MIR building we finally detect whether this attribute is\n+//! present, and if so we branch off into this module, which implements the attribute by\n+//! implementing a custom lowering from THIR to MIR.\n+//!\n+//! The result of this lowering is returned \"normally\" from the `mir_built` query, with the only\n+//! notable difference being that the `injected` field in the body is set. Various components of the\n+//! MIR pipeline, like borrowck and the pass manager will then consult this field (via\n+//! `body.should_skip()`) to skip the parts of the MIR pipeline that precede the MIR phase the user\n+//! specified.\n+//!\n+//! This file defines the general framework for the custom parsing. The parsing for all the\n+//! \"top-level\" constructs can be found in the `parse` submodule, while the parsing for statements,\n+//! terminators, and everything below can be found in the `parse::instruction` submodule.\n+//!\n+\n+use rustc_ast::Attribute;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefId;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::{\n+    mir::*,\n+    thir::*,\n+    ty::{Ty, TyCtxt},\n+};\n+use rustc_span::Span;\n+\n+mod parse;\n+\n+pub(super) fn build_custom_mir<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    did: DefId,\n+    thir: &Thir<'tcx>,\n+    expr: ExprId,\n+    params: &IndexVec<ParamId, Param<'tcx>>,\n+    return_ty: Ty<'tcx>,\n+    return_ty_span: Span,\n+    span: Span,\n+    attr: &Attribute,\n+) -> Body<'tcx> {\n+    let mut body = Body {\n+        basic_blocks: BasicBlocks::new(IndexVec::new()),\n+        source: MirSource::item(did),\n+        phase: MirPhase::Built,\n+        source_scopes: IndexVec::new(),\n+        generator: None,\n+        local_decls: LocalDecls::new(),\n+        user_type_annotations: IndexVec::new(),\n+        arg_count: params.len(),\n+        spread_arg: None,\n+        var_debug_info: Vec::new(),\n+        span,\n+        required_consts: Vec::new(),\n+        is_polymorphic: false,\n+        tainted_by_errors: None,\n+        injection_phase: None,\n+        pass_count: 1,\n+    };\n+\n+    body.local_decls.push(LocalDecl::new(return_ty, return_ty_span));\n+    body.basic_blocks_mut().push(BasicBlockData::new(None));\n+    body.source_scopes.push(SourceScopeData {\n+        span,\n+        parent_scope: None,\n+        inlined: None,\n+        inlined_parent_scope: None,\n+        local_data: ClearCrossCrate::Clear,\n+    });\n+    body.injection_phase = Some(parse_attribute(attr));\n+\n+    let mut pctxt = ParseCtxt {\n+        tcx,\n+        thir,\n+        source_info: SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE },\n+        body: &mut body,\n+        local_map: FxHashMap::default(),\n+        block_map: FxHashMap::default(),\n+    };\n+\n+    let res = (|| {\n+        pctxt.parse_args(&params)?;\n+        pctxt.parse_body(expr)\n+    })();\n+    if let Err(err) = res {\n+        tcx.sess.diagnostic().span_fatal(\n+            err.span,\n+            format!(\"Could not parse {}, found: {:?}\", err.expected, err.item_description),\n+        )\n+    }\n+\n+    body\n+}\n+\n+fn parse_attribute(attr: &Attribute) -> MirPhase {\n+    let meta_items = attr.meta_item_list().unwrap();\n+    let mut dialect: Option<String> = None;\n+    let mut phase: Option<String> = None;\n+\n+    for nested in meta_items {\n+        let name = nested.name_or_empty();\n+        let value = nested.value_str().unwrap().as_str().to_string();\n+        match name.as_str() {\n+            \"dialect\" => {\n+                assert!(dialect.is_none());\n+                dialect = Some(value);\n+            }\n+            \"phase\" => {\n+                assert!(phase.is_none());\n+                phase = Some(value);\n+            }\n+            other => {\n+                panic!(\"Unexpected key {}\", other);\n+            }\n+        }\n+    }\n+\n+    let Some(dialect) = dialect else {\n+        assert!(phase.is_none());\n+        return MirPhase::Built;\n+    };\n+\n+    MirPhase::parse(dialect, phase)\n+}\n+\n+struct ParseCtxt<'tcx, 'body> {\n+    tcx: TyCtxt<'tcx>,\n+    thir: &'body Thir<'tcx>,\n+    source_info: SourceInfo,\n+\n+    body: &'body mut Body<'tcx>,\n+    local_map: FxHashMap<LocalVarId, Local>,\n+    block_map: FxHashMap<LocalVarId, BasicBlock>,\n+}\n+\n+struct ParseError {\n+    span: Span,\n+    item_description: String,\n+    expected: String,\n+}\n+\n+impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n+    fn expr_error(&self, expr: ExprId, expected: &'static str) -> ParseError {\n+        let expr = &self.thir[expr];\n+        ParseError {\n+            span: expr.span,\n+            item_description: format!(\"{:?}\", expr.kind),\n+            expected: expected.to_string(),\n+        }\n+    }\n+}\n+\n+type PResult<T> = Result<T, ParseError>;"}, {"sha": "52cb0a4826d071eb75801f5b2e04c3133983aa87", "filename": "compiler/rustc_mir_build/src/build/custom/parse.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -0,0 +1,245 @@\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::{mir::*, thir::*, ty::Ty};\n+use rustc_span::Span;\n+\n+use super::{PResult, ParseCtxt, ParseError};\n+\n+mod instruction;\n+\n+/// Helper macro for parsing custom MIR.\n+///\n+/// Example usage looks something like:\n+/// ```rust,ignore (incomplete example)\n+/// parse_by_kind!(\n+///     self, // : &ParseCtxt\n+///     expr_id, // what you're matching against\n+///     \"assignment\", // the thing you're trying to parse\n+///     @call(\"mir_assign\", args) => { args[0] }, // match invocations of the `mir_assign` special function\n+///     ExprKind::Assign { lhs, .. } => { lhs }, // match thir assignment expressions\n+///     // no need for fallthrough case - reasonable error is automatically generated\n+/// )\n+/// ```\n+macro_rules! parse_by_kind {\n+    (\n+        $self:ident,\n+        $expr_id:expr,\n+        $expected:literal,\n+        $(\n+            @call($name:literal, $args:ident) => $call_expr:expr,\n+        )*\n+        $(\n+            $pat:pat => $expr:expr,\n+        )*\n+    ) => {{\n+        let expr_id = $self.preparse($expr_id);\n+        let expr = &$self.thir[expr_id];\n+        match &expr.kind {\n+            $(\n+                ExprKind::Call { ty, fun: _, args: $args, .. } if {\n+                    match ty.kind() {\n+                        ty::FnDef(did, _) => {\n+                            $self.tcx.is_diagnostic_item(rustc_span::Symbol::intern($name), *did)\n+                        }\n+                        _ => false,\n+                    }\n+                } => $call_expr,\n+            )*\n+            $(\n+                $pat => $expr,\n+            )*\n+            #[allow(unreachable_patterns)]\n+            _ => return Err($self.expr_error(expr_id, $expected))\n+        }\n+    }};\n+}\n+pub(crate) use parse_by_kind;\n+\n+impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n+    /// Expressions should only ever be matched on after preparsing them. This removes extra scopes\n+    /// we don't care about.\n+    fn preparse(&self, expr_id: ExprId) -> ExprId {\n+        let expr = &self.thir[expr_id];\n+        match expr.kind {\n+            ExprKind::Scope { value, .. } => self.preparse(value),\n+            _ => expr_id,\n+        }\n+    }\n+\n+    fn statement_as_expr(&self, stmt_id: StmtId) -> PResult<ExprId> {\n+        match &self.thir[stmt_id].kind {\n+            StmtKind::Expr { expr, .. } => Ok(*expr),\n+            kind @ StmtKind::Let { pattern, .. } => {\n+                return Err(ParseError {\n+                    span: pattern.span,\n+                    item_description: format!(\"{:?}\", kind),\n+                    expected: \"expression\".to_string(),\n+                });\n+            }\n+        }\n+    }\n+\n+    pub fn parse_args(&mut self, params: &IndexVec<ParamId, Param<'tcx>>) -> PResult<()> {\n+        for param in params.iter() {\n+            let (var, span) = {\n+                let pat = param.pat.as_ref().unwrap();\n+                match &pat.kind {\n+                    PatKind::Binding { var, .. } => (*var, pat.span),\n+                    _ => {\n+                        return Err(ParseError {\n+                            span: pat.span,\n+                            item_description: format!(\"{:?}\", pat.kind),\n+                            expected: \"local\".to_string(),\n+                        });\n+                    }\n+                }\n+            };\n+            let decl = LocalDecl::new(param.ty, span);\n+            let local = self.body.local_decls.push(decl);\n+            self.local_map.insert(var, local);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Bodies are of the form:\n+    ///\n+    /// ```text\n+    /// {\n+    ///     let bb1: BasicBlock;\n+    ///     let bb2: BasicBlock;\n+    ///     {\n+    ///         let RET: _;\n+    ///         let local1;\n+    ///         let local2;\n+    ///\n+    ///         {\n+    ///             { // entry block\n+    ///                 statement1;\n+    ///                 terminator1\n+    ///             };\n+    ///\n+    ///             bb1 = {\n+    ///                 statement2;\n+    ///                 terminator2\n+    ///             };\n+    ///\n+    ///             bb2 = {\n+    ///                 statement3;\n+    ///                 terminator3\n+    ///             }\n+    ///\n+    ///             RET\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// This allows us to easily parse the basic blocks declarations, local declarations, and\n+    /// basic block definitions in order.\n+    pub fn parse_body(&mut self, expr_id: ExprId) -> PResult<()> {\n+        let body = parse_by_kind!(self, expr_id, \"whole body\",\n+            ExprKind::Block { block } => self.thir[*block].expr.unwrap(),\n+        );\n+        let (block_decls, rest) = parse_by_kind!(self, body, \"body with block decls\",\n+            ExprKind::Block { block } => {\n+                let block = &self.thir[*block];\n+                (&block.stmts, block.expr.unwrap())\n+            },\n+        );\n+        self.parse_block_decls(block_decls.iter().copied())?;\n+\n+        let (local_decls, rest) = parse_by_kind!(self, rest, \"body with local decls\",\n+            ExprKind::Block { block } => {\n+                let block = &self.thir[*block];\n+                (&block.stmts, block.expr.unwrap())\n+            },\n+        );\n+        self.parse_local_decls(local_decls.iter().copied())?;\n+\n+        let block_defs = parse_by_kind!(self, rest, \"body with block defs\",\n+            ExprKind::Block { block } => &self.thir[*block].stmts,\n+        );\n+        for (i, block_def) in block_defs.iter().enumerate() {\n+            let block = self.parse_block_def(self.statement_as_expr(*block_def)?)?;\n+            self.body.basic_blocks_mut()[BasicBlock::from_usize(i)] = block;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn parse_block_decls(&mut self, stmts: impl Iterator<Item = StmtId>) -> PResult<()> {\n+        for stmt in stmts {\n+            let (var, _, _) = self.parse_let_statement(stmt)?;\n+            let data = BasicBlockData::new(None);\n+            let block = self.body.basic_blocks_mut().push(data);\n+            self.block_map.insert(var, block);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn parse_local_decls(&mut self, mut stmts: impl Iterator<Item = StmtId>) -> PResult<()> {\n+        let (ret_var, ..) = self.parse_let_statement(stmts.next().unwrap())?;\n+        self.local_map.insert(ret_var, Local::from_u32(0));\n+\n+        for stmt in stmts {\n+            let (var, ty, span) = self.parse_let_statement(stmt)?;\n+            let decl = LocalDecl::new(ty, span);\n+            let local = self.body.local_decls.push(decl);\n+            self.local_map.insert(var, local);\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn parse_let_statement(&mut self, stmt_id: StmtId) -> PResult<(LocalVarId, Ty<'tcx>, Span)> {\n+        let pattern = match &self.thir[stmt_id].kind {\n+            StmtKind::Let { pattern, .. } => pattern,\n+            StmtKind::Expr { expr, .. } => {\n+                return Err(self.expr_error(*expr, \"let statement\"));\n+            }\n+        };\n+\n+        self.parse_var(pattern)\n+    }\n+\n+    fn parse_var(&mut self, mut pat: &Pat<'tcx>) -> PResult<(LocalVarId, Ty<'tcx>, Span)> {\n+        // Make sure we throw out any `AscribeUserType` we find\n+        loop {\n+            match &pat.kind {\n+                PatKind::Binding { var, ty, .. } => break Ok((*var, *ty, pat.span)),\n+                PatKind::AscribeUserType { subpattern, .. } => {\n+                    pat = subpattern;\n+                }\n+                _ => {\n+                    break Err(ParseError {\n+                        span: pat.span,\n+                        item_description: format!(\"{:?}\", pat.kind),\n+                        expected: \"local\".to_string(),\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n+    fn parse_block_def(&self, expr_id: ExprId) -> PResult<BasicBlockData<'tcx>> {\n+        let block = parse_by_kind!(self, expr_id, \"basic block\",\n+            ExprKind::Block { block } => &self.thir[*block],\n+        );\n+\n+        let mut data = BasicBlockData::new(None);\n+        for stmt_id in &*block.stmts {\n+            let stmt = self.statement_as_expr(*stmt_id)?;\n+            let statement = self.parse_statement(stmt)?;\n+            data.statements.push(Statement { source_info: self.source_info, kind: statement });\n+        }\n+\n+        let Some(trailing) = block.expr else {\n+            return Err(self.expr_error(expr_id, \"terminator\"))\n+        };\n+        let terminator = self.parse_terminator(trailing)?;\n+        data.terminator = Some(Terminator { source_info: self.source_info, kind: terminator });\n+\n+        Ok(data)\n+    }\n+}"}, {"sha": "6d6176584f5f47d3cadcc769843afea83350679d", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -0,0 +1,72 @@\n+use rustc_middle::{mir::*, thir::*, ty};\n+\n+use super::{parse_by_kind, PResult, ParseCtxt};\n+\n+impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n+    pub fn parse_statement(&self, expr_id: ExprId) -> PResult<StatementKind<'tcx>> {\n+        parse_by_kind!(self, expr_id, \"statement\",\n+            @call(\"mir_retag\", args) => {\n+                Ok(StatementKind::Retag(RetagKind::Default, Box::new(self.parse_place(args[0])?)))\n+            },\n+            @call(\"mir_retag_raw\", args) => {\n+                Ok(StatementKind::Retag(RetagKind::Raw, Box::new(self.parse_place(args[0])?)))\n+            },\n+            ExprKind::Assign { lhs, rhs } => {\n+                let lhs = self.parse_place(*lhs)?;\n+                let rhs = self.parse_rvalue(*rhs)?;\n+                Ok(StatementKind::Assign(Box::new((lhs, rhs))))\n+            },\n+        )\n+    }\n+\n+    pub fn parse_terminator(&self, expr_id: ExprId) -> PResult<TerminatorKind<'tcx>> {\n+        parse_by_kind!(self, expr_id, \"terminator\",\n+            @call(\"mir_return\", _args) => {\n+                Ok(TerminatorKind::Return)\n+            },\n+            @call(\"mir_goto\", args) => {\n+                Ok(TerminatorKind::Goto { target: self.parse_block(args[0])? } )\n+            },\n+        )\n+    }\n+\n+    fn parse_rvalue(&self, expr_id: ExprId) -> PResult<Rvalue<'tcx>> {\n+        parse_by_kind!(self, expr_id, \"rvalue\",\n+            ExprKind::Borrow { borrow_kind, arg } => Ok(\n+                Rvalue::Ref(self.tcx.lifetimes.re_erased, *borrow_kind, self.parse_place(*arg)?)\n+            ),\n+            ExprKind::AddressOf { mutability, arg } => Ok(\n+                Rvalue::AddressOf(*mutability, self.parse_place(*arg)?)\n+            ),\n+            _ => self.parse_operand(expr_id).map(Rvalue::Use),\n+        )\n+    }\n+\n+    fn parse_operand(&self, expr_id: ExprId) -> PResult<Operand<'tcx>> {\n+        parse_by_kind!(self, expr_id, \"operand\",\n+            @call(\"mir_move\", args) => self.parse_place(args[0]).map(Operand::Move),\n+            _ => self.parse_place(expr_id).map(Operand::Copy),\n+        )\n+    }\n+\n+    fn parse_place(&self, expr_id: ExprId) -> PResult<Place<'tcx>> {\n+        parse_by_kind!(self, expr_id, \"place\",\n+            ExprKind::Deref { arg } => Ok(\n+                self.parse_place(*arg)?.project_deeper(&[PlaceElem::Deref], self.tcx)\n+            ),\n+            _ => self.parse_local(expr_id).map(Place::from),\n+        )\n+    }\n+\n+    fn parse_local(&self, expr_id: ExprId) -> PResult<Local> {\n+        parse_by_kind!(self, expr_id, \"local\",\n+            ExprKind::VarRef { id } => Ok(self.local_map[id]),\n+        )\n+    }\n+\n+    fn parse_block(&self, expr_id: ExprId) -> PResult<BasicBlock> {\n+        parse_by_kind!(self, expr_id, \"basic block\",\n+            ExprKind::VarRef { id } => Ok(self.block_map[id]),\n+        )\n+    }\n+}"}, {"sha": "437ac8d82a1a3136bd38ff9d6f51b33f42884a77", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -481,6 +481,22 @@ fn construct_fn<'tcx>(\n         (None, fn_sig.output())\n     };\n \n+    if let Some(custom_mir_attr) =\n+        tcx.hir().attrs(fn_id).iter().find(|attr| attr.name_or_empty() == sym::custom_mir)\n+    {\n+        return custom::build_custom_mir(\n+            tcx,\n+            fn_def.did.to_def_id(),\n+            thir,\n+            expr,\n+            arguments,\n+            return_ty,\n+            return_ty_span,\n+            span,\n+            custom_mir_attr,\n+        );\n+    }\n+\n     let infcx = tcx.infer_ctxt().build();\n     let mut builder = Builder::new(\n         thir,\n@@ -1033,6 +1049,7 @@ pub(crate) fn parse_float_into_scalar(\n \n mod block;\n mod cfg;\n+mod custom;\n mod expr;\n mod matches;\n mod misc;"}, {"sha": "c4639d3a513dfb7e4e13a32c741e312988abe218", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -51,11 +51,17 @@ impl<'tcx> Cx<'tcx> {\n         trace!(?expr.ty);\n \n         // Now apply adjustments, if any.\n-        for adjustment in self.typeck_results.expr_adjustments(hir_expr) {\n-            trace!(?expr, ?adjustment);\n-            let span = expr.span;\n-            expr =\n-                self.apply_adjustment(hir_expr, expr, adjustment, adjustment_span.unwrap_or(span));\n+        if self.apply_adjustments {\n+            for adjustment in self.typeck_results.expr_adjustments(hir_expr) {\n+                trace!(?expr, ?adjustment);\n+                let span = expr.span;\n+                expr = self.apply_adjustment(\n+                    hir_expr,\n+                    expr,\n+                    adjustment,\n+                    adjustment_span.unwrap_or(span),\n+                );\n+            }\n         }\n \n         trace!(?expr.ty, \"after adjustments\");"}, {"sha": "b5c4b7b137d4c28a2ea2399e6bf1d8dfad156068", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -80,22 +80,31 @@ struct Cx<'tcx> {\n     /// for the receiver.\n     adjustment_span: Option<(HirId, Span)>,\n \n+    /// False to indicate that adjustments should not be applied. Only used for `custom_mir`\n+    apply_adjustments: bool,\n+\n     /// The `DefId` of the owner of this body.\n     body_owner: DefId,\n }\n \n impl<'tcx> Cx<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalDefId>) -> Cx<'tcx> {\n         let typeck_results = tcx.typeck_opt_const_arg(def);\n+        let did = def.did;\n+        let hir = tcx.hir();\n         Cx {\n             tcx,\n             thir: Thir::new(),\n             param_env: tcx.param_env(def.did),\n             region_scope_tree: tcx.region_scope_tree(def.did),\n             typeck_results,\n             rvalue_scopes: &typeck_results.rvalue_scopes,\n-            body_owner: def.did.to_def_id(),\n+            body_owner: did.to_def_id(),\n             adjustment_span: None,\n+            apply_adjustments: hir\n+                .attrs(hir.local_def_id_to_hir_id(did))\n+                .iter()\n+                .all(|attr| attr.name_or_empty() != rustc_span::sym::custom_mir),\n         }\n     }\n "}, {"sha": "14d265a402ef8a6bef72e9dc7129c2000148c463", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -407,9 +407,8 @@ where\n         self.drop_ladder(fields, succ, unwind).0\n     }\n \n+    #[instrument(level = \"debug\", ret)]\n     fn open_drop_for_box(&mut self, adt: ty::AdtDef<'tcx>, substs: SubstsRef<'tcx>) -> BasicBlock {\n-        debug!(\"open_drop_for_box({:?}, {:?}, {:?})\", self, adt, substs);\n-\n         // drop glue is sent straight to codegen\n         // box cannot be directly dereferenced\n         let unique_ty = adt.non_enum_variant().fields[0].ty(self.tcx(), substs);\n@@ -431,8 +430,8 @@ where\n         self.drop_subpath(interior, interior_path, succ, unwind_succ)\n     }\n \n+    #[instrument(level = \"debug\", ret)]\n     fn open_drop_for_adt(&mut self, adt: ty::AdtDef<'tcx>, substs: SubstsRef<'tcx>) -> BasicBlock {\n-        debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", self, adt, substs);\n         if adt.variants().is_empty() {\n             return self.elaborator.patch().new_block(BasicBlockData {\n                 statements: vec![],"}, {"sha": "e783d189137749cabfc28a12872bf7ff4ad64006", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -471,6 +471,14 @@ fn unsafety_check_result<'tcx>(\n     // `mir_built` force this.\n     let body = &tcx.mir_built(def).borrow();\n \n+    if body.should_skip() {\n+        return tcx.arena.alloc(UnsafetyCheckResult {\n+            violations: Vec::new(),\n+            used_unsafe_blocks: FxHashSet::default(),\n+            unused_unsafes: Some(Vec::new()),\n+        });\n+    }\n+\n     let param_env = tcx.param_env(def.did);\n \n     let mut checker = UnsafetyChecker::new(body, def.did, tcx, param_env);"}, {"sha": "27dbc3e22c97a58ac53b09eec34d355229906ce3", "filename": "compiler/rustc_mir_transform/src/pass_manager.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fpass_manager.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -96,45 +96,48 @@ fn run_passes_inner<'tcx>(\n     phase_change: Option<MirPhase>,\n     validate_each: bool,\n ) {\n-    let validate = validate_each & tcx.sess.opts.unstable_opts.validate_mir;\n+    let validate = validate_each & tcx.sess.opts.unstable_opts.validate_mir & !body.should_skip();\n     let overridden_passes = &tcx.sess.opts.unstable_opts.mir_enable_passes;\n     trace!(?overridden_passes);\n \n-    for pass in passes {\n-        let name = pass.name();\n-\n-        let overridden =\n-            overridden_passes.iter().rev().find(|(s, _)| s == &*name).map(|(_name, polarity)| {\n-                trace!(\n-                    pass = %name,\n-                    \"{} as requested by flag\",\n-                    if *polarity { \"Running\" } else { \"Not running\" },\n-                );\n-                *polarity\n-            });\n-        if !overridden.unwrap_or_else(|| pass.is_enabled(&tcx.sess)) {\n-            continue;\n+    if !body.should_skip() {\n+        for pass in passes {\n+            let name = pass.name();\n+\n+            let overridden = overridden_passes.iter().rev().find(|(s, _)| s == &*name).map(\n+                |(_name, polarity)| {\n+                    trace!(\n+                        pass = %name,\n+                        \"{} as requested by flag\",\n+                        if *polarity { \"Running\" } else { \"Not running\" },\n+                    );\n+                    *polarity\n+                },\n+            );\n+            if !overridden.unwrap_or_else(|| pass.is_enabled(&tcx.sess)) {\n+                continue;\n+            }\n+\n+            let dump_enabled = pass.is_mir_dump_enabled();\n+\n+            if dump_enabled {\n+                dump_mir_for_pass(tcx, body, &name, false);\n+            }\n+            if validate {\n+                validate_body(tcx, body, format!(\"before pass {}\", name));\n+            }\n+\n+            pass.run_pass(tcx, body);\n+\n+            if dump_enabled {\n+                dump_mir_for_pass(tcx, body, &name, true);\n+            }\n+            if validate {\n+                validate_body(tcx, body, format!(\"after pass {}\", name));\n+            }\n+\n+            body.pass_count += 1;\n         }\n-\n-        let dump_enabled = pass.is_mir_dump_enabled();\n-\n-        if dump_enabled {\n-            dump_mir_for_pass(tcx, body, &name, false);\n-        }\n-        if validate {\n-            validate_body(tcx, body, format!(\"before pass {}\", name));\n-        }\n-\n-        pass.run_pass(tcx, body);\n-\n-        if dump_enabled {\n-            dump_mir_for_pass(tcx, body, &name, true);\n-        }\n-        if validate {\n-            validate_body(tcx, body, format!(\"after pass {}\", name));\n-        }\n-\n-        body.pass_count += 1;\n     }\n \n     if let Some(new_phase) = phase_change {"}, {"sha": "a0ff7550faeb8226f057eaae989265bd931f7016", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -569,17 +569,13 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n \n /// Builds a \"call\" shim for `instance`. The shim calls the function specified by `call_kind`,\n /// first adjusting its first argument according to `rcvr_adjustment`.\n+#[instrument(level = \"debug\", skip(tcx), ret)]\n fn build_call_shim<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: ty::InstanceDef<'tcx>,\n     rcvr_adjustment: Option<Adjustment>,\n     call_kind: CallKind<'tcx>,\n ) -> Body<'tcx> {\n-    debug!(\n-        \"build_call_shim(instance={:?}, rcvr_adjustment={:?}, call_kind={:?})\",\n-        instance, rcvr_adjustment, call_kind\n-    );\n-\n     // `FnPtrShim` contains the fn pointer type that a call shim is being built for - this is used\n     // to substitute into the signature of the shim. It is not necessary for users of this\n     // MIR body to perform further substitutions (see `InstanceDef::has_polymorphic_mir_body`).\n@@ -641,7 +637,7 @@ fn build_call_shim<'tcx>(\n \n     let span = tcx.def_span(def_id);\n \n-    debug!(\"build_call_shim: sig={:?}\", sig);\n+    debug!(?sig);\n \n     let mut local_decls = local_decls_for_sig(&sig, span);\n     let source_info = SourceInfo::outermost(span);"}, {"sha": "e3acc11811f425df4d5128fdb2babeefb2f2bea7", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -368,6 +368,15 @@ pub(crate) struct MissingSemicolonBeforeArray {\n     pub semicolon: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(parser_expect_dotdot_not_dotdotdot)]\n+pub(crate) struct MissingDotDot {\n+    #[primary_span]\n+    pub token_span: Span,\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"..\", style = \"verbose\")]\n+    pub sugg_span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(parser_invalid_block_macro_segment)]\n pub(crate) struct InvalidBlockMacroSegment {\n@@ -411,6 +420,15 @@ pub(crate) struct ExpectedExpressionFoundLet {\n     pub span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(parser_expect_eq_instead_of_eqeq)]\n+pub(crate) struct ExpectedEqForLetExpr {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(applicability = \"maybe-incorrect\", code = \"=\", style = \"verbose\")]\n+    pub sugg_span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(parser_expected_else_block)]\n pub(crate) struct ExpectedElseBlock {"}, {"sha": "645262bd2f1d37dcf5d714b618457e94e3a3f81b", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 49, "deletions": 70, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -175,20 +175,10 @@ impl<'a> StringReader<'a> {\n                         if string == \"_\" {\n                             self.sess\n                                 .span_diagnostic\n-                                .struct_span_warn(\n+                                .struct_span_err(\n                                     self.mk_sp(suffix_start, self.pos),\n                                     \"underscore literal suffix is not allowed\",\n                                 )\n-                                .warn(\n-                                    \"this was previously accepted by the compiler but is \\\n-                                       being phased out; it will become a hard error in \\\n-                                       a future release!\",\n-                                )\n-                                .note(\n-                                    \"see issue #42326 \\\n-                                     <https://github.com/rust-lang/rust/issues/42326> \\\n-                                     for more information\",\n-                                )\n                                 .emit();\n                             None\n                         } else {\n@@ -363,112 +353,115 @@ impl<'a> StringReader<'a> {\n     fn cook_lexer_literal(\n         &self,\n         start: BytePos,\n-        suffix_start: BytePos,\n+        end: BytePos,\n         kind: rustc_lexer::LiteralKind,\n     ) -> (token::LitKind, Symbol) {\n-        // prefix means `\"` or `br\"` or `r###\"`, ...\n-        let (lit_kind, mode, prefix_len, postfix_len) = match kind {\n+        match kind {\n             rustc_lexer::LiteralKind::Char { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start, suffix_start),\n+                        self.mk_sp(start, end),\n                         \"unterminated character literal\",\n                         error_code!(E0762),\n                     )\n                 }\n-                (token::Char, Mode::Char, 1, 1) // ' '\n+                self.cook_quoted(token::Char, Mode::Char, start, end, 1, 1) // ' '\n             }\n             rustc_lexer::LiteralKind::Byte { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start + BytePos(1), suffix_start),\n+                        self.mk_sp(start + BytePos(1), end),\n                         \"unterminated byte constant\",\n                         error_code!(E0763),\n                     )\n                 }\n-                (token::Byte, Mode::Byte, 2, 1) // b' '\n+                self.cook_quoted(token::Byte, Mode::Byte, start, end, 2, 1) // b' '\n             }\n             rustc_lexer::LiteralKind::Str { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start, suffix_start),\n+                        self.mk_sp(start, end),\n                         \"unterminated double quote string\",\n                         error_code!(E0765),\n                     )\n                 }\n-                (token::Str, Mode::Str, 1, 1) // \" \"\n+                self.cook_quoted(token::Str, Mode::Str, start, end, 1, 1) // \" \"\n             }\n             rustc_lexer::LiteralKind::ByteStr { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start + BytePos(1), suffix_start),\n+                        self.mk_sp(start + BytePos(1), end),\n                         \"unterminated double quote byte string\",\n                         error_code!(E0766),\n                     )\n                 }\n-                (token::ByteStr, Mode::ByteStr, 2, 1) // b\" \"\n+                self.cook_quoted(token::ByteStr, Mode::ByteStr, start, end, 2, 1) // b\" \"\n             }\n             rustc_lexer::LiteralKind::RawStr { n_hashes } => {\n                 if let Some(n_hashes) = n_hashes {\n                     let n = u32::from(n_hashes);\n-                    (token::StrRaw(n_hashes), Mode::RawStr, 2 + n, 1 + n) // r##\" \"##\n+                    let kind = token::StrRaw(n_hashes);\n+                    self.cook_quoted(kind, Mode::RawStr, start, end, 2 + n, 1 + n) // r##\" \"##\n                 } else {\n                     self.report_raw_str_error(start, 1);\n                 }\n             }\n             rustc_lexer::LiteralKind::RawByteStr { n_hashes } => {\n                 if let Some(n_hashes) = n_hashes {\n                     let n = u32::from(n_hashes);\n-                    (token::ByteStrRaw(n_hashes), Mode::RawByteStr, 3 + n, 1 + n) // br##\" \"##\n+                    let kind = token::ByteStrRaw(n_hashes);\n+                    self.cook_quoted(kind, Mode::RawByteStr, start, end, 3 + n, 1 + n) // br##\" \"##\n                 } else {\n                     self.report_raw_str_error(start, 2);\n                 }\n             }\n             rustc_lexer::LiteralKind::Int { base, empty_int } => {\n-                return if empty_int {\n+                if empty_int {\n                     self.sess\n                         .span_diagnostic\n                         .struct_span_err_with_code(\n-                            self.mk_sp(start, suffix_start),\n+                            self.mk_sp(start, end),\n                             \"no valid digits found for number\",\n                             error_code!(E0768),\n                         )\n                         .emit();\n                     (token::Integer, sym::integer(0))\n                 } else {\n-                    self.validate_int_literal(base, start, suffix_start);\n-                    (token::Integer, self.symbol_from_to(start, suffix_start))\n-                };\n+                    if matches!(base, Base::Binary | Base::Octal) {\n+                        let base = base as u32;\n+                        let s = self.str_from_to(start + BytePos(2), end);\n+                        for (idx, c) in s.char_indices() {\n+                            if c != '_' && c.to_digit(base).is_none() {\n+                                self.err_span_(\n+                                    start + BytePos::from_usize(2 + idx),\n+                                    start + BytePos::from_usize(2 + idx + c.len_utf8()),\n+                                    &format!(\"invalid digit for a base {} literal\", base),\n+                                );\n+                            }\n+                        }\n+                    }\n+                    (token::Integer, self.symbol_from_to(start, end))\n+                }\n             }\n             rustc_lexer::LiteralKind::Float { base, empty_exponent } => {\n                 if empty_exponent {\n                     self.err_span_(start, self.pos, \"expected at least one digit in exponent\");\n                 }\n-\n                 match base {\n-                    Base::Hexadecimal => self.err_span_(\n-                        start,\n-                        suffix_start,\n-                        \"hexadecimal float literal is not supported\",\n-                    ),\n+                    Base::Hexadecimal => {\n+                        self.err_span_(start, end, \"hexadecimal float literal is not supported\")\n+                    }\n                     Base::Octal => {\n-                        self.err_span_(start, suffix_start, \"octal float literal is not supported\")\n+                        self.err_span_(start, end, \"octal float literal is not supported\")\n                     }\n                     Base::Binary => {\n-                        self.err_span_(start, suffix_start, \"binary float literal is not supported\")\n+                        self.err_span_(start, end, \"binary float literal is not supported\")\n                     }\n-                    _ => (),\n+                    _ => {}\n                 }\n-\n-                let id = self.symbol_from_to(start, suffix_start);\n-                return (token::Float, id);\n+                (token::Float, self.symbol_from_to(start, end))\n             }\n-        };\n-        let content_start = start + BytePos(prefix_len);\n-        let content_end = suffix_start - BytePos(postfix_len);\n-        let id = self.symbol_from_to(content_start, content_end);\n-        self.validate_literal_escape(mode, content_start, content_end, prefix_len, postfix_len);\n-        (lit_kind, id)\n+        }\n     }\n \n     #[inline]\n@@ -659,20 +652,22 @@ impl<'a> StringReader<'a> {\n         )\n     }\n \n-    fn validate_literal_escape(\n+    fn cook_quoted(\n         &self,\n+        kind: token::LitKind,\n         mode: Mode,\n-        content_start: BytePos,\n-        content_end: BytePos,\n+        start: BytePos,\n+        end: BytePos,\n         prefix_len: u32,\n         postfix_len: u32,\n-    ) {\n+    ) -> (token::LitKind, Symbol) {\n+        let content_start = start + BytePos(prefix_len);\n+        let content_end = end - BytePos(postfix_len);\n         let lit_content = self.str_from_to(content_start, content_end);\n         unescape::unescape_literal(lit_content, mode, &mut |range, result| {\n             // Here we only check for errors. The actual unescaping is done later.\n             if let Err(err) = result {\n-                let span_with_quotes = self\n-                    .mk_sp(content_start - BytePos(prefix_len), content_end + BytePos(postfix_len));\n+                let span_with_quotes = self.mk_sp(start, end);\n                 let (start, end) = (range.start as u32, range.end as u32);\n                 let lo = content_start + BytePos(start);\n                 let hi = lo + BytePos(end - start);\n@@ -688,23 +683,7 @@ impl<'a> StringReader<'a> {\n                 );\n             }\n         });\n-    }\n-\n-    fn validate_int_literal(&self, base: Base, content_start: BytePos, content_end: BytePos) {\n-        let base = match base {\n-            Base::Binary => 2,\n-            Base::Octal => 8,\n-            _ => return,\n-        };\n-        let s = self.str_from_to(content_start + BytePos(2), content_end);\n-        for (idx, c) in s.char_indices() {\n-            let idx = idx as u32;\n-            if c != '_' && c.to_digit(base).is_none() {\n-                let lo = content_start + BytePos(2 + idx);\n-                let hi = content_start + BytePos(2 + idx + c.len_utf8() as u32);\n-                self.err_span_(lo, hi, &format!(\"invalid digit for a base {} literal\", base));\n-            }\n-        }\n+        (kind, Symbol::intern(lit_content))\n     }\n }\n "}, {"sha": "6373f5b4fd6ff36f32f99b14bd80ec9326663dfc", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -108,7 +108,7 @@ pub(crate) fn emit_unescape_error(\n             }\n \n             if !has_help {\n-                let (prefix, msg) = if mode.is_bytes() {\n+                let (prefix, msg) = if mode.is_byte() {\n                     (\"b\", \"if you meant to write a byte string literal, use double quotes\")\n                 } else {\n                     (\"\", \"if you meant to write a `str` literal, use double quotes\")\n@@ -142,7 +142,7 @@ pub(crate) fn emit_unescape_error(\n         EscapeError::EscapeOnlyChar => {\n             let (c, char_span) = last_char();\n \n-            let msg = if mode.is_bytes() {\n+            let msg = if mode.is_byte() {\n                 \"byte constant must be escaped\"\n             } else {\n                 \"character constant must be escaped\"\n@@ -182,11 +182,11 @@ pub(crate) fn emit_unescape_error(\n             let (c, span) = last_char();\n \n             let label =\n-                if mode.is_bytes() { \"unknown byte escape\" } else { \"unknown character escape\" };\n+                if mode.is_byte() { \"unknown byte escape\" } else { \"unknown character escape\" };\n             let ec = escaped_char(c);\n             let mut diag = handler.struct_span_err(span, &format!(\"{}: `{}`\", label, ec));\n             diag.span_label(span, label);\n-            if c == '{' || c == '}' && !mode.is_bytes() {\n+            if c == '{' || c == '}' && !mode.is_byte() {\n                 diag.help(\n                     \"if used in a formatting string, curly braces are escaped with `{{` and `}}`\",\n                 );\n@@ -196,7 +196,7 @@ pub(crate) fn emit_unescape_error(\n                      version control settings\",\n                 );\n             } else {\n-                if !mode.is_bytes() {\n+                if !mode.is_byte() {\n                     diag.span_suggestion(\n                         span_with_quotes,\n                         \"if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\",\n@@ -231,16 +231,23 @@ pub(crate) fn emit_unescape_error(\n                 .emit();\n         }\n         EscapeError::NonAsciiCharInByte => {\n-            assert!(mode.is_bytes());\n             let (c, span) = last_char();\n-            let mut err = handler.struct_span_err(span, \"non-ASCII character in byte constant\");\n+            let desc = match mode {\n+                Mode::Byte => \"byte literal\",\n+                Mode::ByteStr => \"byte string literal\",\n+                Mode::RawByteStr => \"raw byte string literal\",\n+                _ => panic!(\"non-is_byte literal paired with NonAsciiCharInByte\"),\n+            };\n+            let mut err = handler.struct_span_err(span, format!(\"non-ASCII character in {}\", desc));\n             let postfix = if unicode_width::UnicodeWidthChar::width(c).unwrap_or(1) == 0 {\n                 format!(\" but is {:?}\", c)\n             } else {\n                 String::new()\n             };\n-            err.span_label(span, &format!(\"byte constant must be ASCII{}\", postfix));\n-            if (c as u32) <= 0xFF {\n+            err.span_label(span, &format!(\"must be ASCII{}\", postfix));\n+            // Note: the \\\\xHH suggestions are not given for raw byte string\n+            // literals, because they are araw and so cannot use any escapes.\n+            if (c as u32) <= 0xFF && mode != Mode::RawByteStr {\n                 err.span_suggestion(\n                     span,\n                     &format!(\n@@ -250,9 +257,9 @@ pub(crate) fn emit_unescape_error(\n                     format!(\"\\\\x{:X}\", c as u32),\n                     Applicability::MaybeIncorrect,\n                 );\n-            } else if matches!(mode, Mode::Byte) {\n+            } else if mode == Mode::Byte {\n                 err.span_label(span, \"this multibyte character does not fit into a single byte\");\n-            } else if matches!(mode, Mode::ByteStr) {\n+            } else if mode != Mode::RawByteStr {\n                 let mut utf8 = String::new();\n                 utf8.push(c);\n                 err.span_suggestion(\n@@ -270,19 +277,6 @@ pub(crate) fn emit_unescape_error(\n             }\n             err.emit();\n         }\n-        EscapeError::NonAsciiCharInByteString => {\n-            assert!(mode.is_bytes());\n-            let (c, span) = last_char();\n-            let postfix = if unicode_width::UnicodeWidthChar::width(c).unwrap_or(1) == 0 {\n-                format!(\" but is {:?}\", c)\n-            } else {\n-                String::new()\n-            };\n-            handler\n-                .struct_span_err(span, \"raw byte string must be ASCII\")\n-                .span_label(span, &format!(\"must be ASCII{}\", postfix))\n-                .emit();\n-        }\n         EscapeError::OutOfRangeHexEscape => {\n             handler\n                 .struct_span_err(span, \"out of range hex escape\")"}, {"sha": "c609aa93da3a75b0d9cb50637ef85e18dce8bfe5", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -2468,11 +2468,15 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(crate) fn maybe_recover_unexpected_block_label(&mut self) -> bool {\n-        let Some(label) = self.eat_label().filter(|_| {\n-            self.eat(&token::Colon) && self.token.kind == token::OpenDelim(Delimiter::Brace)\n-        }) else {\n+        // Check for `'a : {`\n+        if !(self.check_lifetime()\n+            && self.look_ahead(1, |tok| tok.kind == token::Colon)\n+            && self.look_ahead(2, |tok| tok.kind == token::OpenDelim(Delimiter::Brace)))\n+        {\n             return false;\n-        };\n+        }\n+        let label = self.eat_label().expect(\"just checked if a label exists\");\n+        self.bump(); // eat `:`\n         let span = label.ident.span.to(self.prev_token.span);\n         let mut err = self.struct_span_err(span, \"block label not supported here\");\n         err.span_label(span, \"not supported here\");"}, {"sha": "da2d20e47ee688fea9c1800b4e3592818cd293df", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -9,9 +9,9 @@ use crate::errors::{\n     ArrayBracketsInsteadOfSpaces, ArrayBracketsInsteadOfSpacesSugg, AsyncMoveOrderIncorrect,\n     BinaryFloatLiteralNotSupported, BracesForStructLiteral, CatchAfterTry, CommaAfterBaseStruct,\n     ComparisonInterpretedAsGeneric, ComparisonOrShiftInterpretedAsGenericSugg,\n-    DoCatchSyntaxRemoved, DotDotDot, EqFieldInit, ExpectedElseBlock, ExpectedExpressionFoundLet,\n-    FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart, FoundExprWouldBeStmt,\n-    HexadecimalFloatLiteralNotSupported, IfExpressionMissingCondition,\n+    DoCatchSyntaxRemoved, DotDotDot, EqFieldInit, ExpectedElseBlock, ExpectedEqForLetExpr,\n+    ExpectedExpressionFoundLet, FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart,\n+    FoundExprWouldBeStmt, HexadecimalFloatLiteralNotSupported, IfExpressionMissingCondition,\n     IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub, IntLiteralTooLarge,\n     InvalidBlockMacroSegment, InvalidComparisonOperator, InvalidComparisonOperatorSub,\n     InvalidFloatLiteralSuffix, InvalidFloatLiteralWidth, InvalidIntLiteralWidth,\n@@ -20,9 +20,9 @@ use crate::errors::{\n     InvalidNumLiteralSuffix, LabeledLoopInBreak, LeadingPlusNotSupported, LeftArrowOperator,\n     LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath, MalformedLoopLabel,\n     MatchArmBodyWithoutBraces, MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm,\n-    MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray, NoFieldsForFnCall,\n-    NotAsNegationOperator, NotAsNegationOperatorSub, OctalFloatLiteralNotSupported,\n-    OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n+    MissingDotDot, MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray,\n+    NoFieldsForFnCall, NotAsNegationOperator, NotAsNegationOperatorSub,\n+    OctalFloatLiteralNotSupported, OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n     RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric, StructLiteralNotAllowedHere,\n     StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator, UnexpectedTokenAfterLabel,\n     UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n@@ -833,16 +833,11 @@ impl<'a> Parser<'a> {\n                 (\"cast\", None)\n             };\n \n-        // Save the memory location of expr before parsing any following postfix operators.\n-        // This will be compared with the memory location of the output expression.\n-        // If they different we can assume we parsed another expression because the existing expression is not reallocated.\n-        let addr_before = &*cast_expr as *const _ as usize;\n         let with_postfix = self.parse_dot_or_call_expr_with_(cast_expr, span)?;\n-        let changed = addr_before != &*with_postfix as *const _ as usize;\n \n         // Check if an illegal postfix operator has been added after the cast.\n-        // If the resulting expression is not a cast, or has a different memory location, it is an illegal postfix operator.\n-        if !matches!(with_postfix.kind, ExprKind::Cast(_, _) | ExprKind::Type(_, _)) || changed {\n+        // If the resulting expression is not a cast, it is an illegal postfix operator.\n+        if !matches!(with_postfix.kind, ExprKind::Cast(_, _) | ExprKind::Type(_, _)) {\n             let msg = format!(\n                 \"{cast_kind} cannot be followed by {}\",\n                 match with_postfix.kind {\n@@ -2334,7 +2329,15 @@ impl<'a> Parser<'a> {\n             RecoverColon::Yes,\n             CommaRecoveryMode::LikelyTuple,\n         )?;\n-        self.expect(&token::Eq)?;\n+        if self.token == token::EqEq {\n+            self.sess.emit_err(ExpectedEqForLetExpr {\n+                span: self.token.span,\n+                sugg_span: self.token.span,\n+            });\n+            self.bump();\n+        } else {\n+            self.expect(&token::Eq)?;\n+        }\n         let expr = self.with_res(self.restrictions | Restrictions::NO_STRUCT_LITERAL, |this| {\n             this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n         })?;\n@@ -2880,7 +2883,7 @@ impl<'a> Parser<'a> {\n         };\n \n         while self.token != token::CloseDelim(close_delim) {\n-            if self.eat(&token::DotDot) {\n+            if self.eat(&token::DotDot) || self.recover_struct_field_dots(close_delim) {\n                 let exp_span = self.prev_token.span;\n                 // We permit `.. }` on the left-hand side of a destructuring assignment.\n                 if self.check(&token::CloseDelim(close_delim)) {\n@@ -3027,6 +3030,18 @@ impl<'a> Parser<'a> {\n         self.recover_stmt();\n     }\n \n+    fn recover_struct_field_dots(&mut self, close_delim: Delimiter) -> bool {\n+        if !self.look_ahead(1, |t| *t == token::CloseDelim(close_delim))\n+            && self.eat(&token::DotDotDot)\n+        {\n+            // recover from typo of `...`, suggest `..`\n+            let span = self.prev_token.span;\n+            self.sess.emit_err(MissingDotDot { token_span: span, sugg_span: span });\n+            return true;\n+        }\n+        false\n+    }\n+\n     /// Parses `ident (COLON expr)?`.\n     fn parse_expr_field(&mut self) -> PResult<'a, ExprField> {\n         let attrs = self.parse_outer_attributes()?;"}, {"sha": "54bf4d1d6b7381469d276d77b0ee66afa1663963", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -819,27 +819,27 @@ fn find_skips_from_snippet(\n     };\n \n     fn find_skips(snippet: &str, is_raw: bool) -> Vec<usize> {\n-        let mut s = snippet.char_indices().peekable();\n+        let mut s = snippet.char_indices();\n         let mut skips = vec![];\n         while let Some((pos, c)) = s.next() {\n-            match (c, s.peek()) {\n+            match (c, s.clone().next()) {\n                 // skip whitespace and empty lines ending in '\\\\'\n                 ('\\\\', Some((next_pos, '\\n'))) if !is_raw => {\n                     skips.push(pos);\n-                    skips.push(*next_pos);\n+                    skips.push(next_pos);\n                     let _ = s.next();\n \n-                    while let Some((pos, c)) = s.peek() {\n+                    while let Some((pos, c)) = s.clone().next() {\n                         if matches!(c, ' ' | '\\n' | '\\t') {\n-                            skips.push(*pos);\n+                            skips.push(pos);\n                             let _ = s.next();\n                         } else {\n                             break;\n                         }\n                     }\n                 }\n                 ('\\\\', Some((next_pos, 'n' | 't' | 'r' | '0' | '\\\\' | '\\'' | '\\\"'))) => {\n-                    skips.push(*next_pos);\n+                    skips.push(next_pos);\n                     let _ = s.next();\n                 }\n                 ('\\\\', Some((_, 'x'))) if !is_raw => {\n@@ -858,19 +858,30 @@ fn find_skips_from_snippet(\n                     }\n                     if let Some((next_pos, next_c)) = s.next() {\n                         if next_c == '{' {\n-                            skips.push(next_pos);\n-                            let mut i = 0; // consume up to 6 hexanumeric chars + closing `}`\n-                            while let (Some((next_pos, c)), true) = (s.next(), i < 7) {\n-                                if c.is_digit(16) {\n-                                    skips.push(next_pos);\n-                                } else if c == '}' {\n-                                    skips.push(next_pos);\n-                                    break;\n-                                } else {\n-                                    break;\n-                                }\n-                                i += 1;\n+                            // consume up to 6 hexanumeric chars\n+                            let digits_len =\n+                                s.clone().take(6).take_while(|(_, c)| c.is_digit(16)).count();\n+\n+                            let len_utf8 = s\n+                                .as_str()\n+                                .get(..digits_len)\n+                                .and_then(|digits| u32::from_str_radix(digits, 16).ok())\n+                                .and_then(char::from_u32)\n+                                .map_or(1, char::len_utf8);\n+\n+                            // Skip the digits, for chars that encode to more than 1 utf-8 byte\n+                            // exclude as many digits as it is greater than 1 byte\n+                            //\n+                            // So for a 3 byte character, exclude 2 digits\n+                            let required_skips =\n+                                digits_len.saturating_sub(len_utf8.saturating_sub(1));\n+\n+                            // skip '{' and '}' also\n+                            for pos in (next_pos..).take(required_skips + 2) {\n+                                skips.push(pos)\n                             }\n+\n+                            s.nth(digits_len);\n                         } else if next_c.is_digit(16) {\n                             skips.push(next_pos);\n                             // We suggest adding `{` and `}` when appropriate, accept it here as if"}, {"sha": "0c34b0e1bf3f99ddeefcef04fcf00cb459e03f1a", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -119,13 +119,13 @@ impl CheckAttrVisitor<'_> {\n                 }\n                 sym::naked => self.check_naked(hir_id, attr, span, target),\n                 sym::rustc_legacy_const_generics => {\n-                    self.check_rustc_legacy_const_generics(&attr, span, target, item)\n+                    self.check_rustc_legacy_const_generics(hir_id, &attr, span, target, item)\n                 }\n                 sym::rustc_lint_query_instability => {\n-                    self.check_rustc_lint_query_instability(&attr, span, target)\n+                    self.check_rustc_lint_query_instability(hir_id, &attr, span, target)\n                 }\n                 sym::rustc_lint_diagnostics => {\n-                    self.check_rustc_lint_diagnostics(&attr, span, target)\n+                    self.check_rustc_lint_diagnostics(hir_id, &attr, span, target)\n                 }\n                 sym::rustc_lint_opt_ty => self.check_rustc_lint_opt_ty(&attr, span, target),\n                 sym::rustc_lint_opt_deny_field_access => {\n@@ -135,7 +135,9 @@ impl CheckAttrVisitor<'_> {\n                 | sym::rustc_dirty\n                 | sym::rustc_if_this_changed\n                 | sym::rustc_then_this_would_need => self.check_rustc_dirty_clean(&attr),\n-                sym::cmse_nonsecure_entry => self.check_cmse_nonsecure_entry(attr, span, target),\n+                sym::cmse_nonsecure_entry => {\n+                    self.check_cmse_nonsecure_entry(hir_id, attr, span, target)\n+                }\n                 sym::collapse_debuginfo => self.check_collapse_debuginfo(attr, span, target),\n                 sym::const_trait => self.check_const_trait(attr, span, target),\n                 sym::must_not_suspend => self.check_must_not_suspend(&attr, span, target),\n@@ -386,21 +388,29 @@ impl CheckAttrVisitor<'_> {\n                 self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n                     attr_span: attr.span,\n                     defn_span: span,\n+                    on_crate: hir_id == CRATE_HIR_ID,\n                 });\n                 false\n             }\n         }\n     }\n \n     /// Checks if `#[cmse_nonsecure_entry]` is applied to a function definition.\n-    fn check_cmse_nonsecure_entry(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n+    fn check_cmse_nonsecure_entry(\n+        &self,\n+        hir_id: HirId,\n+        attr: &Attribute,\n+        span: Span,\n+        target: Target,\n+    ) -> bool {\n         match target {\n             Target::Fn\n             | Target::Method(MethodKind::Trait { body: true } | MethodKind::Inherent) => true,\n             _ => {\n                 self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n                     attr_span: attr.span,\n                     defn_span: span,\n+                    on_crate: hir_id == CRATE_HIR_ID,\n                 });\n                 false\n             }\n@@ -465,9 +475,11 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .emit_err(errors::TrackedCallerWrongLocation { attr_span, defn_span: span });\n+                self.tcx.sess.emit_err(errors::TrackedCallerWrongLocation {\n+                    attr_span,\n+                    defn_span: span,\n+                    on_crate: hir_id == CRATE_HIR_ID,\n+                });\n                 false\n             }\n         }\n@@ -576,6 +588,7 @@ impl CheckAttrVisitor<'_> {\n                 self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n                     attr_span: attr.span,\n                     defn_span: span,\n+                    on_crate: hir_id == CRATE_HIR_ID,\n                 });\n                 false\n             }\n@@ -1240,7 +1253,7 @@ impl CheckAttrVisitor<'_> {\n                     UNUSED_ATTRIBUTES,\n                     hir_id,\n                     attr.span,\n-                    errors::Cold { span },\n+                    errors::Cold { span, on_crate: hir_id == CRATE_HIR_ID },\n                 );\n             }\n         }\n@@ -1376,6 +1389,7 @@ impl CheckAttrVisitor<'_> {\n     /// Checks if `#[rustc_legacy_const_generics]` is applied to a function and has a valid argument.\n     fn check_rustc_legacy_const_generics(\n         &self,\n+        hir_id: HirId,\n         attr: &Attribute,\n         span: Span,\n         target: Target,\n@@ -1386,6 +1400,7 @@ impl CheckAttrVisitor<'_> {\n             self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n                 attr_span: attr.span,\n                 defn_span: span,\n+                on_crate: hir_id == CRATE_HIR_ID,\n             });\n             return false;\n         }\n@@ -1450,12 +1465,19 @@ impl CheckAttrVisitor<'_> {\n \n     /// Helper function for checking that the provided attribute is only applied to a function or\n     /// method.\n-    fn check_applied_to_fn_or_method(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n+    fn check_applied_to_fn_or_method(\n+        &self,\n+        hir_id: HirId,\n+        attr: &Attribute,\n+        span: Span,\n+        target: Target,\n+    ) -> bool {\n         let is_function = matches!(target, Target::Fn | Target::Method(..));\n         if !is_function {\n             self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n                 attr_span: attr.span,\n                 defn_span: span,\n+                on_crate: hir_id == CRATE_HIR_ID,\n             });\n             false\n         } else {\n@@ -1467,17 +1489,24 @@ impl CheckAttrVisitor<'_> {\n     /// or method.\n     fn check_rustc_lint_query_instability(\n         &self,\n+        hir_id: HirId,\n         attr: &Attribute,\n         span: Span,\n         target: Target,\n     ) -> bool {\n-        self.check_applied_to_fn_or_method(attr, span, target)\n+        self.check_applied_to_fn_or_method(hir_id, attr, span, target)\n     }\n \n     /// Checks that the `#[rustc_lint_diagnostics]` attribute is only applied to a function or\n     /// method.\n-    fn check_rustc_lint_diagnostics(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n-        self.check_applied_to_fn_or_method(attr, span, target)\n+    fn check_rustc_lint_diagnostics(\n+        &self,\n+        hir_id: HirId,\n+        attr: &Attribute,\n+        span: Span,\n+        target: Target,\n+    ) -> bool {\n+        self.check_applied_to_fn_or_method(hir_id, attr, span, target)\n     }\n \n     /// Checks that the `#[rustc_lint_opt_ty]` attribute is only applied to a struct."}, {"sha": "c6cd69add28a04837c20fa0640419cee5ccb7af7", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -81,6 +81,7 @@ pub struct AttrShouldBeAppliedToFn {\n     pub attr_span: Span,\n     #[label]\n     pub defn_span: Span,\n+    pub on_crate: bool,\n }\n \n #[derive(Diagnostic)]\n@@ -97,6 +98,7 @@ pub struct TrackedCallerWrongLocation {\n     pub attr_span: Span,\n     #[label]\n     pub defn_span: Span,\n+    pub on_crate: bool,\n }\n \n #[derive(Diagnostic)]\n@@ -367,6 +369,7 @@ pub struct MustNotSuspend {\n pub struct Cold {\n     #[label]\n     pub span: Span,\n+    pub on_crate: bool,\n }\n \n #[derive(LintDiagnostic)]"}, {"sha": "6e621b7eb5eb09c3d41870b7f5c04170100499a3", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -5,8 +5,6 @@\n //! This API is completely unstable and subject to change.\n \n #![allow(rustc::potential_query_instability)]\n-#![deny(rustc::untranslatable_diagnostic)]\n-#![deny(rustc::diagnostic_outside_of_impl)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(iter_intersperse)]\n #![feature(let_chains)]"}, {"sha": "e17f85c1aae0f14920eb49f14b32ecaa3bbfb281", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -959,13 +959,21 @@ impl<'tcx, 'a> Visitor<'tcx> for TestReachabilityVisitor<'tcx, 'a> {\n                 for variant in def.variants.iter() {\n                     let variant_id = self.tcx.hir().local_def_id(variant.id);\n                     self.effective_visibility_diagnostic(variant_id);\n+                    if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n+                        let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n+                        self.effective_visibility_diagnostic(ctor_def_id);\n+                    }\n                     for field in variant.data.fields() {\n                         let def_id = self.tcx.hir().local_def_id(field.hir_id);\n                         self.effective_visibility_diagnostic(def_id);\n                     }\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n+                if let Some(ctor_hir_id) = def.ctor_hir_id() {\n+                    let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n+                    self.effective_visibility_diagnostic(ctor_def_id);\n+                }\n                 for field in def.fields() {\n                     let def_id = self.tcx.hir().local_def_id(field.hir_id);\n                     self.effective_visibility_diagnostic(def_id);\n@@ -2131,6 +2139,7 @@ fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n         changed: false,\n     };\n \n+    visitor.effective_visibilities.check_invariants(tcx, true);\n     loop {\n         tcx.hir().walk_toplevel_module(&mut visitor);\n         if visitor.changed {\n@@ -2139,6 +2148,7 @@ fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n             break;\n         }\n     }\n+    visitor.effective_visibilities.check_invariants(tcx, false);\n \n     let mut check_visitor =\n         TestReachabilityVisitor { tcx, effective_visibilities: &visitor.effective_visibilities };"}, {"sha": "18cb0e0ca0b155695fee806e71ca57909cd9fb99", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -36,7 +36,7 @@ mod keys;\n use keys::Key;\n \n pub use rustc_query_system::query::QueryConfig;\n-pub(crate) use rustc_query_system::query::{QueryDescription, QueryVTable};\n+pub(crate) use rustc_query_system::query::QueryVTable;\n \n mod on_disk_cache;\n pub use on_disk_cache::OnDiskCache;"}, {"sha": "a6cb8f7bd5532705b929242b7e3cd24c193c8c78", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1063,7 +1063,7 @@ pub fn encode_query_results<'a, 'tcx, CTX, Q>(\n     query_result_index: &mut EncodedDepNodeIndex,\n ) where\n     CTX: QueryContext + 'tcx,\n-    Q: super::QueryDescription<CTX>,\n+    Q: super::QueryConfig<CTX>,\n     Q::Value: Encodable<CacheEncoder<'a, 'tcx>>,\n {\n     let _timer = tcx"}, {"sha": "992e777904e6b94eefe05072c5bcb3520c7a5303", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -17,8 +17,7 @@ use rustc_middle::ty::{self, TyCtxt};\n use rustc_query_system::dep_graph::{DepNodeParams, HasDepContext};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_query_system::query::{\n-    force_query, QueryConfig, QueryContext, QueryDescription, QueryJobId, QueryMap,\n-    QuerySideEffects, QueryStackFrame,\n+    force_query, QueryConfig, QueryContext, QueryJobId, QueryMap, QuerySideEffects, QueryStackFrame,\n };\n use rustc_query_system::{LayoutOfDepth, QueryOverflow, Value};\n use rustc_serialize::Decodable;\n@@ -340,7 +339,7 @@ pub(crate) fn create_query_frame<\n \n fn try_load_from_on_disk_cache<'tcx, Q>(tcx: TyCtxt<'tcx>, dep_node: DepNode)\n where\n-    Q: QueryDescription<QueryCtxt<'tcx>>,\n+    Q: QueryConfig<QueryCtxt<'tcx>>,\n     Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n {\n     debug_assert!(tcx.dep_graph.is_green(&dep_node));\n@@ -365,7 +364,7 @@ where\n \n fn force_from_dep_node<'tcx, Q>(tcx: TyCtxt<'tcx>, dep_node: DepNode) -> bool\n where\n-    Q: QueryDescription<QueryCtxt<'tcx>>,\n+    Q: QueryConfig<QueryCtxt<'tcx>>,\n     Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n     Q::Value: Value<TyCtxt<'tcx>>,\n {\n@@ -398,12 +397,9 @@ where\n     }\n }\n \n-pub(crate) fn query_callback<'tcx, Q: QueryConfig>(\n-    is_anon: bool,\n-    is_eval_always: bool,\n-) -> DepKindStruct<'tcx>\n+pub(crate) fn query_callback<'tcx, Q>(is_anon: bool, is_eval_always: bool) -> DepKindStruct<'tcx>\n where\n-    Q: QueryDescription<QueryCtxt<'tcx>>,\n+    Q: QueryConfig<QueryCtxt<'tcx>>,\n     Q::Key: DepNodeParams<TyCtxt<'tcx>>,\n {\n     let fingerprint_style = Q::Key::fingerprint_style();\n@@ -458,14 +454,12 @@ macro_rules! define_queries {\n             })*\n         }\n \n-        $(impl<'tcx> QueryConfig for queries::$name<'tcx> {\n+        $(impl<'tcx> QueryConfig<QueryCtxt<'tcx>> for queries::$name<'tcx> {\n             type Key = query_keys::$name<'tcx>;\n             type Value = query_values::$name<'tcx>;\n             type Stored = query_stored::$name<'tcx>;\n             const NAME: &'static str = stringify!($name);\n-        }\n \n-        impl<'tcx> QueryDescription<QueryCtxt<'tcx>> for queries::$name<'tcx> {\n             #[inline]\n             fn cache_on_disk(tcx: TyCtxt<'tcx>, key: &Self::Key) -> bool {\n                 ::rustc_middle::query::cached::$name(tcx, key)\n@@ -662,12 +656,15 @@ macro_rules! define_queries_struct {\n             local_providers: Box<Providers>,\n             extern_providers: Box<ExternProviders>,\n             query_structs: Vec<$crate::plumbing::QueryStruct<'tcx>>,\n-\n             pub on_disk_cache: Option<OnDiskCache<'tcx>>,\n-\n             jobs: AtomicU64,\n \n-            $($(#[$attr])*  $name: QueryState<<queries::$name<'tcx> as QueryConfig>::Key>,)*\n+            $(\n+                $(#[$attr])*\n+                $name: QueryState<\n+                    <queries::$name<'tcx> as QueryConfig<QueryCtxt<'tcx>>>::Key\n+                >,\n+            )*\n         }\n \n         impl<'tcx> Queries<'tcx> {\n@@ -704,7 +701,7 @@ macro_rules! define_queries_struct {\n                 &'tcx self,\n                 tcx: TyCtxt<'tcx>,\n                 span: Span,\n-                key: <queries::$name<'tcx> as QueryConfig>::Key,\n+                key: <queries::$name<'tcx> as QueryConfig<QueryCtxt<'tcx>>>::Key,\n                 mode: QueryMode,\n             ) -> Option<query_stored::$name<'tcx>> {\n                 let qcx = QueryCtxt { tcx, queries: self };"}, {"sha": "81114f2cd82c326dbe9a98aefb7b402b986ded0f", "filename": "compiler/rustc_query_impl/src/profiling_support.rs", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fprofiling_support.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -19,18 +19,18 @@ impl QueryKeyStringCache {\n     }\n }\n \n-struct QueryKeyStringBuilder<'p, 'c, 'tcx> {\n+struct QueryKeyStringBuilder<'p, 'tcx> {\n     profiler: &'p SelfProfiler,\n     tcx: TyCtxt<'tcx>,\n-    string_cache: &'c mut QueryKeyStringCache,\n+    string_cache: &'p mut QueryKeyStringCache,\n }\n \n-impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n+impl<'p, 'tcx> QueryKeyStringBuilder<'p, 'tcx> {\n     fn new(\n         profiler: &'p SelfProfiler,\n         tcx: TyCtxt<'tcx>,\n-        string_cache: &'c mut QueryKeyStringCache,\n-    ) -> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n+        string_cache: &'p mut QueryKeyStringCache,\n+    ) -> QueryKeyStringBuilder<'p, 'tcx> {\n         QueryKeyStringBuilder { profiler, tcx, string_cache }\n     }\n \n@@ -99,7 +99,7 @@ impl<'p, 'c, 'tcx> QueryKeyStringBuilder<'p, 'c, 'tcx> {\n }\n \n trait IntoSelfProfilingString {\n-    fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_, '_>) -> StringId;\n+    fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId;\n }\n \n // The default implementation of `IntoSelfProfilingString` just uses `Debug`\n@@ -109,68 +109,50 @@ trait IntoSelfProfilingString {\n impl<T: Debug> IntoSelfProfilingString for T {\n     default fn to_self_profile_string(\n         &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n+        builder: &mut QueryKeyStringBuilder<'_, '_>,\n     ) -> StringId {\n         let s = format!(\"{:?}\", self);\n         builder.profiler.alloc_string(&s[..])\n     }\n }\n \n impl<T: SpecIntoSelfProfilingString> IntoSelfProfilingString for T {\n-    fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_, '_>) -> StringId {\n+    fn to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         self.spec_to_self_profile_string(builder)\n     }\n }\n \n #[rustc_specialization_trait]\n trait SpecIntoSelfProfilingString: Debug {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId;\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId;\n }\n \n impl SpecIntoSelfProfilingString for DefId {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId {\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         builder.def_id_to_string_id(*self)\n     }\n }\n \n impl SpecIntoSelfProfilingString for CrateNum {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId {\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         builder.def_id_to_string_id(self.as_def_id())\n     }\n }\n \n impl SpecIntoSelfProfilingString for DefIndex {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId {\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         builder.def_id_to_string_id(DefId { krate: LOCAL_CRATE, index: *self })\n     }\n }\n \n impl SpecIntoSelfProfilingString for LocalDefId {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId {\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         builder.def_id_to_string_id(DefId { krate: LOCAL_CRATE, index: self.local_def_index })\n     }\n }\n \n impl<T: SpecIntoSelfProfilingString> SpecIntoSelfProfilingString for WithOptConstParam<T> {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId {\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         // We print `WithOptConstParam` values as tuples to make them shorter\n         // and more readable, without losing information:\n         //\n@@ -205,10 +187,7 @@ where\n     T0: SpecIntoSelfProfilingString,\n     T1: SpecIntoSelfProfilingString,\n {\n-    fn spec_to_self_profile_string(\n-        &self,\n-        builder: &mut QueryKeyStringBuilder<'_, '_, '_>,\n-    ) -> StringId {\n+    fn spec_to_self_profile_string(&self, builder: &mut QueryKeyStringBuilder<'_, '_>) -> StringId {\n         let val0 = self.0.to_self_profile_string(builder);\n         let val1 = self.1.to_self_profile_string(builder);\n "}, {"sha": "7cc885be2ba6a6319b51e783e1d03efc97f344a1", "filename": "compiler/rustc_query_system/src/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -26,7 +26,7 @@ impl<Key, Value> Cache<Key, Value> {\n }\n \n impl<Key: Eq + Hash, Value: Clone> Cache<Key, Value> {\n-    pub fn get<CTX: DepContext>(&self, key: &Key, tcx: CTX) -> Option<Value> {\n+    pub fn get<Tcx: DepContext>(&self, key: &Key, tcx: Tcx) -> Option<Value> {\n         Some(self.hashmap.borrow().get(key)?.get(tcx))\n     }\n \n@@ -46,7 +46,7 @@ impl<T: Clone> WithDepNode<T> {\n         WithDepNode { dep_node, cached_value }\n     }\n \n-    pub fn get<CTX: DepContext>(&self, tcx: CTX) -> T {\n+    pub fn get<Tcx: DepContext>(&self, tcx: Tcx) -> T {\n         tcx.dep_graph().read_index(self.dep_node);\n         self.cached_value.clone()\n     }"}, {"sha": "d79c5816a9c40bb1fc0d3aab18113ae01af46ea8", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -61,18 +61,18 @@ impl<K: DepKind> DepNode<K> {\n     /// Creates a new, parameterless DepNode. This method will assert\n     /// that the DepNode corresponding to the given DepKind actually\n     /// does not require any parameters.\n-    pub fn new_no_params<Ctxt>(tcx: Ctxt, kind: K) -> DepNode<K>\n+    pub fn new_no_params<Tcx>(tcx: Tcx, kind: K) -> DepNode<K>\n     where\n-        Ctxt: super::DepContext<DepKind = K>,\n+        Tcx: super::DepContext<DepKind = K>,\n     {\n         debug_assert_eq!(tcx.fingerprint_style(kind), FingerprintStyle::Unit);\n         DepNode { kind, hash: Fingerprint::ZERO.into() }\n     }\n \n-    pub fn construct<Ctxt, Key>(tcx: Ctxt, kind: K, arg: &Key) -> DepNode<K>\n+    pub fn construct<Tcx, Key>(tcx: Tcx, kind: K, arg: &Key) -> DepNode<K>\n     where\n-        Ctxt: super::DepContext<DepKind = K>,\n-        Key: DepNodeParams<Ctxt>,\n+        Tcx: super::DepContext<DepKind = K>,\n+        Key: DepNodeParams<Tcx>,\n     {\n         let hash = arg.to_fingerprint(tcx);\n         let dep_node = DepNode { kind, hash: hash.into() };\n@@ -93,9 +93,9 @@ impl<K: DepKind> DepNode<K> {\n     /// Construct a DepNode from the given DepKind and DefPathHash. This\n     /// method will assert that the given DepKind actually requires a\n     /// single DefId/DefPathHash parameter.\n-    pub fn from_def_path_hash<Ctxt>(tcx: Ctxt, def_path_hash: DefPathHash, kind: K) -> Self\n+    pub fn from_def_path_hash<Tcx>(tcx: Tcx, def_path_hash: DefPathHash, kind: K) -> Self\n     where\n-        Ctxt: super::DepContext<DepKind = K>,\n+        Tcx: super::DepContext<DepKind = K>,\n     {\n         debug_assert!(tcx.fingerprint_style(kind) == FingerprintStyle::DefPathHash);\n         DepNode { kind, hash: def_path_hash.0.into() }\n@@ -108,18 +108,18 @@ impl<K: DepKind> fmt::Debug for DepNode<K> {\n     }\n }\n \n-pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n+pub trait DepNodeParams<Tcx: DepContext>: fmt::Debug + Sized {\n     fn fingerprint_style() -> FingerprintStyle;\n \n     /// This method turns the parameters of a DepNodeConstructor into an opaque\n     /// Fingerprint to be used in DepNode.\n     /// Not all DepNodeParams support being turned into a Fingerprint (they\n     /// don't need to if the corresponding DepNode is anonymous).\n-    fn to_fingerprint(&self, _: Ctxt) -> Fingerprint {\n+    fn to_fingerprint(&self, _: Tcx) -> Fingerprint {\n         panic!(\"Not implemented. Accidentally called on anonymous node?\")\n     }\n \n-    fn to_debug_str(&self, _: Ctxt) -> String {\n+    fn to_debug_str(&self, _: Tcx) -> String {\n         format!(\"{:?}\", self)\n     }\n \n@@ -129,10 +129,10 @@ pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n     /// `fingerprint_style()` is not `FingerprintStyle::Opaque`.\n     /// It is always valid to return `None` here, in which case incremental\n     /// compilation will treat the query as having changed instead of forcing it.\n-    fn recover(tcx: Ctxt, dep_node: &DepNode<Ctxt::DepKind>) -> Option<Self>;\n+    fn recover(tcx: Tcx, dep_node: &DepNode<Tcx::DepKind>) -> Option<Self>;\n }\n \n-impl<Ctxt: DepContext, T> DepNodeParams<Ctxt> for T\n+impl<Tcx: DepContext, T> DepNodeParams<Tcx> for T\n where\n     T: for<'a> HashStable<StableHashingContext<'a>> + fmt::Debug,\n {\n@@ -142,7 +142,7 @@ where\n     }\n \n     #[inline(always)]\n-    default fn to_fingerprint(&self, tcx: Ctxt) -> Fingerprint {\n+    default fn to_fingerprint(&self, tcx: Tcx) -> Fingerprint {\n         tcx.with_stable_hashing_context(|mut hcx| {\n             let mut hasher = StableHasher::new();\n             self.hash_stable(&mut hcx, &mut hasher);\n@@ -151,12 +151,12 @@ where\n     }\n \n     #[inline(always)]\n-    default fn to_debug_str(&self, _: Ctxt) -> String {\n+    default fn to_debug_str(&self, _: Tcx) -> String {\n         format!(\"{:?}\", *self)\n     }\n \n     #[inline(always)]\n-    default fn recover(_: Ctxt, _: &DepNode<Ctxt::DepKind>) -> Option<Self> {\n+    default fn recover(_: Tcx, _: &DepNode<Tcx::DepKind>) -> Option<Self> {\n         None\n     }\n }\n@@ -166,7 +166,7 @@ where\n /// Information is retrieved by indexing the `DEP_KINDS` array using the integer value\n /// of the `DepKind`. Overall, this allows to implement `DepContext` using this manual\n /// jump table instead of large matches.\n-pub struct DepKindStruct<CTX: DepContext> {\n+pub struct DepKindStruct<Tcx: DepContext> {\n     /// Anonymous queries cannot be replayed from one compiler invocation to the next.\n     /// When their result is needed, it is recomputed. They are useful for fine-grained\n     /// dependency tracking, and caching within one compiler invocation.\n@@ -216,10 +216,10 @@ pub struct DepKindStruct<CTX: DepContext> {\n     /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n     /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n     /// `DefId` in `tcx.def_path_hash_to_def_id`.\n-    pub force_from_dep_node: Option<fn(tcx: CTX, dep_node: DepNode<CTX::DepKind>) -> bool>,\n+    pub force_from_dep_node: Option<fn(tcx: Tcx, dep_node: DepNode<Tcx::DepKind>) -> bool>,\n \n     /// Invoke a query to put the on-disk cached value in memory.\n-    pub try_load_from_on_disk_cache: Option<fn(CTX, DepNode<CTX::DepKind>)>,\n+    pub try_load_from_on_disk_cache: Option<fn(Tcx, DepNode<Tcx::DepKind>)>,\n }\n \n /// A \"work product\" corresponds to a `.o` (or other) file that we"}, {"sha": "d86c0bebdcdf4d2166cabe7918dca9dd925b5fba", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 38, "deletions": 63, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -377,9 +377,9 @@ impl<K: DepKind> DepGraph<K> {\n \n     /// Executes something within an \"anonymous\" task, that is, a task the\n     /// `DepNode` of which is determined by the list of inputs it read from.\n-    pub fn with_anon_task<Ctxt: DepContext<DepKind = K>, OP, R>(\n+    pub fn with_anon_task<Tcx: DepContext<DepKind = K>, OP, R>(\n         &self,\n-        cx: Ctxt,\n+        cx: Tcx,\n         dep_kind: K,\n         op: OP,\n     ) -> (R, DepNodeIndex)\n@@ -571,12 +571,12 @@ impl<K: DepKind> DepGraph<K> {\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n     /// green. This function will mark the current task as a reader of the specified node, when\n     /// a node index can be found for that node.\n-    pub fn try_mark_green<Ctxt: QueryContext<DepKind = K>>(\n+    pub fn try_mark_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n-        tcx: Ctxt,\n+        qcx: Qcx,\n         dep_node: &DepNode<K>,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n-        debug_assert!(!tcx.dep_context().is_eval_always(dep_node.kind));\n+        debug_assert!(!qcx.dep_context().is_eval_always(dep_node.kind));\n \n         // Return None if the dep graph is disabled\n         let data = self.data.as_ref()?;\n@@ -592,15 +592,16 @@ impl<K: DepKind> DepGraph<K> {\n                 // in the previous compilation session too, so we can try to\n                 // mark it as green by recursively marking all of its\n                 // dependencies green.\n-                self.try_mark_previous_green(tcx, data, prev_index, &dep_node)\n+                self.try_mark_previous_green(qcx, data, prev_index, &dep_node)\n                     .map(|dep_node_index| (prev_index, dep_node_index))\n             }\n         }\n     }\n \n-    fn try_mark_parent_green<Ctxt: QueryContext<DepKind = K>>(\n+    #[instrument(skip(self, qcx, data, parent_dep_node_index), level = \"debug\")]\n+    fn try_mark_parent_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n-        tcx: Ctxt,\n+        qcx: Qcx,\n         data: &DepGraphData<K>,\n         parent_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n@@ -613,82 +614,60 @@ impl<K: DepKind> DepGraph<K> {\n                 // This dependency has been marked as green before, we are\n                 // still fine and can continue with checking the other\n                 // dependencies.\n-                debug!(\n-                    \"try_mark_previous_green({:?}) --- found dependency {:?} to \\\n-                            be immediately green\",\n-                    dep_node, dep_dep_node,\n-                );\n+                debug!(\"dependency {dep_dep_node:?} was immediately green\");\n                 return Some(());\n             }\n             Some(DepNodeColor::Red) => {\n                 // We found a dependency the value of which has changed\n                 // compared to the previous compilation session. We cannot\n                 // mark the DepNode as green and also don't need to bother\n                 // with checking any of the other dependencies.\n-                debug!(\n-                    \"try_mark_previous_green({:?}) - END - dependency {:?} was immediately red\",\n-                    dep_node, dep_dep_node,\n-                );\n+                debug!(\"dependency {dep_dep_node:?} was immediately red\");\n                 return None;\n             }\n             None => {}\n         }\n \n         // We don't know the state of this dependency. If it isn't\n         // an eval_always node, let's try to mark it green recursively.\n-        if !tcx.dep_context().is_eval_always(dep_dep_node.kind) {\n+        if !qcx.dep_context().is_eval_always(dep_dep_node.kind) {\n             debug!(\n-                \"try_mark_previous_green({:?}) --- state of dependency {:?} ({}) \\\n-                                 is unknown, trying to mark it green\",\n-                dep_node, dep_dep_node, dep_dep_node.hash,\n+                \"state of dependency {:?} ({}) is unknown, trying to mark it green\",\n+                dep_dep_node, dep_dep_node.hash,\n             );\n \n             let node_index =\n-                self.try_mark_previous_green(tcx, data, parent_dep_node_index, dep_dep_node);\n+                self.try_mark_previous_green(qcx, data, parent_dep_node_index, dep_dep_node);\n+\n             if node_index.is_some() {\n-                debug!(\n-                    \"try_mark_previous_green({:?}) --- managed to MARK dependency {:?} as green\",\n-                    dep_node, dep_dep_node\n-                );\n+                debug!(\"managed to MARK dependency {dep_dep_node:?} as green\",);\n                 return Some(());\n             }\n         }\n \n         // We failed to mark it green, so we try to force the query.\n-        debug!(\n-            \"try_mark_previous_green({:?}) --- trying to force dependency {:?}\",\n-            dep_node, dep_dep_node\n-        );\n-        if !tcx.dep_context().try_force_from_dep_node(*dep_dep_node) {\n+        debug!(\"trying to force dependency {dep_dep_node:?}\");\n+        if !qcx.dep_context().try_force_from_dep_node(*dep_dep_node) {\n             // The DepNode could not be forced.\n-            debug!(\n-                \"try_mark_previous_green({:?}) - END - dependency {:?} could not be forced\",\n-                dep_node, dep_dep_node\n-            );\n+            debug!(\"dependency {dep_dep_node:?} could not be forced\");\n             return None;\n         }\n \n         let dep_dep_node_color = data.colors.get(parent_dep_node_index);\n \n         match dep_dep_node_color {\n             Some(DepNodeColor::Green(_)) => {\n-                debug!(\n-                    \"try_mark_previous_green({:?}) --- managed to FORCE dependency {:?} to green\",\n-                    dep_node, dep_dep_node\n-                );\n+                debug!(\"managed to FORCE dependency {dep_dep_node:?} to green\");\n                 return Some(());\n             }\n             Some(DepNodeColor::Red) => {\n-                debug!(\n-                    \"try_mark_previous_green({:?}) - END - dependency {:?} was red after forcing\",\n-                    dep_node, dep_dep_node\n-                );\n+                debug!(\"dependency {dep_dep_node:?} was red after forcing\",);\n                 return None;\n             }\n             None => {}\n         }\n \n-        if !tcx.dep_context().sess().has_errors_or_delayed_span_bugs() {\n+        if !qcx.dep_context().sess().has_errors_or_delayed_span_bugs() {\n             panic!(\"try_mark_previous_green() - Forcing the DepNode should have set its color\")\n         }\n \n@@ -702,38 +681,34 @@ impl<K: DepKind> DepGraph<K> {\n         // invalid state will not be persisted to the\n         // incremental compilation cache because of\n         // compilation errors being present.\n-        debug!(\n-            \"try_mark_previous_green({:?}) - END - dependency {:?} resulted in compilation error\",\n-            dep_node, dep_dep_node\n-        );\n+        debug!(\"dependency {dep_dep_node:?} resulted in compilation error\",);\n         return None;\n     }\n \n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n-    fn try_mark_previous_green<Ctxt: QueryContext<DepKind = K>>(\n+    #[instrument(skip(self, qcx, data, prev_dep_node_index), level = \"debug\")]\n+    fn try_mark_previous_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n-        tcx: Ctxt,\n+        qcx: Qcx,\n         data: &DepGraphData<K>,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n     ) -> Option<DepNodeIndex> {\n-        debug!(\"try_mark_previous_green({:?}) - BEGIN\", dep_node);\n-\n         #[cfg(not(parallel_compiler))]\n         {\n             debug_assert!(!self.dep_node_exists(dep_node));\n             debug_assert!(data.colors.get(prev_dep_node_index).is_none());\n         }\n \n         // We never try to mark eval_always nodes as green\n-        debug_assert!(!tcx.dep_context().is_eval_always(dep_node.kind));\n+        debug_assert!(!qcx.dep_context().is_eval_always(dep_node.kind));\n \n         debug_assert_eq!(data.previous.index_to_node(prev_dep_node_index), *dep_node);\n \n         let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n \n         for &dep_dep_node_index in prev_deps {\n-            self.try_mark_parent_green(tcx, data, dep_dep_node_index, dep_node)?\n+            self.try_mark_parent_green(qcx, data, dep_dep_node_index, dep_node)?\n         }\n \n         // If we got here without hitting a `return` that means that all\n@@ -745,7 +720,7 @@ impl<K: DepKind> DepGraph<K> {\n         // We allocating an entry for the node in the current dependency graph and\n         // adding all the appropriate edges imported from the previous graph\n         let dep_node_index = data.current.promote_node_and_deps_to_current(\n-            tcx.dep_context().profiler(),\n+            qcx.dep_context().profiler(),\n             &data.previous,\n             prev_dep_node_index,\n         );\n@@ -754,7 +729,7 @@ impl<K: DepKind> DepGraph<K> {\n \n         // FIXME: Store the fact that a node has diagnostics in a bit in the dep graph somewhere\n         // Maybe store a list on disk and encode this fact in the DepNodeState\n-        let side_effects = tcx.load_side_effects(prev_dep_node_index);\n+        let side_effects = qcx.load_side_effects(prev_dep_node_index);\n \n         #[cfg(not(parallel_compiler))]\n         debug_assert!(\n@@ -765,24 +740,24 @@ impl<K: DepKind> DepGraph<K> {\n         );\n \n         if !side_effects.is_empty() {\n-            self.emit_side_effects(tcx, data, dep_node_index, side_effects);\n+            self.emit_side_effects(qcx, data, dep_node_index, side_effects);\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map.\n         // Multiple threads can all write the same color here\n         data.colors.insert(prev_dep_node_index, DepNodeColor::Green(dep_node_index));\n \n-        debug!(\"try_mark_previous_green({:?}) - END - successfully marked as green\", dep_node);\n+        debug!(\"successfully marked {dep_node:?} as green\");\n         Some(dep_node_index)\n     }\n \n     /// Atomically emits some loaded diagnostics.\n     /// This may be called concurrently on multiple threads for the same dep node.\n     #[cold]\n     #[inline(never)]\n-    fn emit_side_effects<Ctxt: QueryContext<DepKind = K>>(\n+    fn emit_side_effects<Qcx: QueryContext<DepKind = K>>(\n         &self,\n-        tcx: Ctxt,\n+        qcx: Qcx,\n         data: &DepGraphData<K>,\n         dep_node_index: DepNodeIndex,\n         side_effects: QuerySideEffects,\n@@ -794,9 +769,9 @@ impl<K: DepKind> DepGraph<K> {\n             // must process side effects\n \n             // Promote the previous diagnostics to the current session.\n-            tcx.store_side_effects(dep_node_index, side_effects.clone());\n+            qcx.store_side_effects(dep_node_index, side_effects.clone());\n \n-            let handle = tcx.dep_context().sess().diagnostic();\n+            let handle = qcx.dep_context().sess().diagnostic();\n \n             for mut diagnostic in side_effects.diagnostics {\n                 handle.emit_diagnostic(&mut diagnostic);\n@@ -824,7 +799,7 @@ impl<K: DepKind> DepGraph<K> {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions<Ctxt: DepContext<DepKind = K>>(&self, tcx: Ctxt) {\n+    pub fn exec_cache_promotions<Tcx: DepContext<DepKind = K>>(&self, tcx: Tcx) {\n         let _prof_timer = tcx.profiler().generic_activity(\"incr_comp_query_cache_promotion\");\n \n         let data = self.data.as_ref().unwrap();"}, {"sha": "e370c6990a41353d9accc9cf09a48f20595cf0b6", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -52,9 +52,8 @@ pub trait DepContext: Copy {\n     }\n \n     /// Try to force a dep node to execute and see if it's green.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn try_force_from_dep_node(self, dep_node: DepNode<Self::DepKind>) -> bool {\n-        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n-\n         let cb = self.dep_kind_info(dep_node.kind);\n         if let Some(f) = cb.force_from_dep_node {\n             f(self, dep_node);"}, {"sha": "f40e174b7e79bf3a885843cd7d462fc29fa8f368", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -11,59 +11,57 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use std::fmt::Debug;\n use std::hash::Hash;\n \n-pub trait QueryConfig {\n+pub trait QueryConfig<Qcx: QueryContext> {\n     const NAME: &'static str;\n \n     type Key: Eq + Hash + Clone + Debug;\n     type Value;\n     type Stored: Clone;\n+\n+    type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n+\n+    // Don't use this method to access query results, instead use the methods on TyCtxt\n+    fn query_state<'a>(tcx: Qcx) -> &'a QueryState<Self::Key>\n+    where\n+        Qcx: 'a;\n+\n+    // Don't use this method to access query results, instead use the methods on TyCtxt\n+    fn query_cache<'a>(tcx: Qcx) -> &'a Self::Cache\n+    where\n+        Qcx: 'a;\n+\n+    // Don't use this method to compute query results, instead use the methods on TyCtxt\n+    fn make_vtable(tcx: Qcx, key: &Self::Key) -> QueryVTable<Qcx, Self::Key, Self::Value>;\n+\n+    fn cache_on_disk(tcx: Qcx::DepContext, key: &Self::Key) -> bool;\n+\n+    // Don't use this method to compute query results, instead use the methods on TyCtxt\n+    fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Stored;\n }\n \n #[derive(Copy, Clone)]\n-pub struct QueryVTable<CTX: QueryContext, K, V> {\n+pub struct QueryVTable<Qcx: QueryContext, K, V> {\n     pub anon: bool,\n-    pub dep_kind: CTX::DepKind,\n+    pub dep_kind: Qcx::DepKind,\n     pub eval_always: bool,\n     pub depth_limit: bool,\n \n-    pub compute: fn(CTX::DepContext, K) -> V,\n+    pub compute: fn(Qcx::DepContext, K) -> V,\n     pub hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n     pub handle_cycle_error: HandleCycleError,\n     // NOTE: this is also `None` if `cache_on_disk()` returns false, not just if it's unsupported by the query\n-    pub try_load_from_disk: Option<fn(CTX, SerializedDepNodeIndex) -> Option<V>>,\n+    pub try_load_from_disk: Option<fn(Qcx, SerializedDepNodeIndex) -> Option<V>>,\n }\n \n-impl<CTX: QueryContext, K, V> QueryVTable<CTX, K, V> {\n-    pub(crate) fn to_dep_node(&self, tcx: CTX::DepContext, key: &K) -> DepNode<CTX::DepKind>\n+impl<Qcx: QueryContext, K, V> QueryVTable<Qcx, K, V> {\n+    pub(crate) fn to_dep_node(&self, tcx: Qcx::DepContext, key: &K) -> DepNode<Qcx::DepKind>\n     where\n-        K: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n+        K: crate::dep_graph::DepNodeParams<Qcx::DepContext>,\n     {\n         DepNode::construct(tcx, self.dep_kind, key)\n     }\n \n-    pub(crate) fn compute(&self, tcx: CTX::DepContext, key: K) -> V {\n+    pub(crate) fn compute(&self, tcx: Qcx::DepContext, key: K) -> V {\n         (self.compute)(tcx, key)\n     }\n }\n-\n-pub trait QueryDescription<CTX: QueryContext>: QueryConfig {\n-    type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n-\n-    // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: CTX) -> &'a QueryState<Self::Key>\n-    where\n-        CTX: 'a;\n-\n-    // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_cache<'a>(tcx: CTX) -> &'a Self::Cache\n-    where\n-        CTX: 'a;\n-\n-    // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn make_vtable(tcx: CTX, key: &Self::Key) -> QueryVTable<CTX, Self::Key, Self::Value>;\n-\n-    fn cache_on_disk(tcx: CTX::DepContext, key: &Self::Key) -> bool;\n-\n-    // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn execute_query(tcx: CTX::DepContext, k: Self::Key) -> Self::Stored;\n-}"}, {"sha": "49bbcf57804596623ed30642d0d837d5ba1ca8af", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -596,8 +596,8 @@ pub(crate) fn report_cycle<'a>(\n     cycle_diag.into_diagnostic(&sess.parse_sess.span_diagnostic)\n }\n \n-pub fn print_query_stack<CTX: QueryContext>(\n-    tcx: CTX,\n+pub fn print_query_stack<Qcx: QueryContext>(\n+    qcx: Qcx,\n     mut current_query: Option<QueryJobId>,\n     handler: &Handler,\n     num_frames: Option<usize>,\n@@ -606,7 +606,7 @@ pub fn print_query_stack<CTX: QueryContext>(\n     // a panic hook, which means that the global `Handler` may be in a weird\n     // state if it was responsible for triggering the panic.\n     let mut i = 0;\n-    let query_map = tcx.try_collect_active_jobs();\n+    let query_map = qcx.try_collect_active_jobs();\n \n     while let Some(query) = current_query {\n         if Some(i) == num_frames {"}, {"sha": "94adef41e68fef72b732920a32dc5426306b4d1f", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -12,7 +12,7 @@ pub use self::caches::{\n };\n \n mod config;\n-pub use self::config::{QueryConfig, QueryDescription, QueryVTable};\n+pub use self::config::{QueryConfig, QueryVTable};\n \n use crate::dep_graph::{DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n use rustc_data_structures::sync::Lock;"}, {"sha": "f8d93a27d1c2bbbb3ceff184ae2702235eef9387", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 134, "deletions": 128, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -4,7 +4,7 @@\n \n use crate::dep_graph::{DepContext, DepNode, DepNodeIndex, DepNodeParams};\n use crate::query::caches::QueryCache;\n-use crate::query::config::{QueryDescription, QueryVTable};\n+use crate::query::config::QueryVTable;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n use crate::query::{QueryContext, QueryMap, QuerySideEffects, QueryStackFrame};\n use crate::values::Value;\n@@ -27,6 +27,8 @@ use std::mem;\n use std::ptr;\n use thin_vec::ThinVec;\n \n+use super::QueryConfig;\n+\n pub struct QueryState<K> {\n     #[cfg(parallel_compiler)]\n     active: Sharded<FxHashMap<K, QueryResult>>,\n@@ -60,10 +62,10 @@ where\n         }\n     }\n \n-    pub fn try_collect_active_jobs<CTX: Copy>(\n+    pub fn try_collect_active_jobs<Qcx: Copy>(\n         &self,\n-        tcx: CTX,\n-        make_query: fn(CTX, K) -> QueryStackFrame,\n+        qcx: Qcx,\n+        make_query: fn(Qcx, K) -> QueryStackFrame,\n         jobs: &mut QueryMap,\n     ) -> Option<()> {\n         #[cfg(parallel_compiler)]\n@@ -74,7 +76,7 @@ where\n             for shard in shards.iter() {\n                 for (k, v) in shard.iter() {\n                     if let QueryResult::Started(ref job) = *v {\n-                        let query = make_query(tcx, k.clone());\n+                        let query = make_query(qcx, k.clone());\n                         jobs.insert(job.id, QueryJobInfo { query, job: job.clone() });\n                     }\n                 }\n@@ -88,7 +90,7 @@ where\n             // really hurt much.)\n             for (k, v) in self.active.try_lock()?.iter() {\n                 if let QueryResult::Started(ref job) = *v {\n-                    let query = make_query(tcx, k.clone());\n+                    let query = make_query(qcx, k.clone());\n                     jobs.insert(job.id, QueryJobInfo { query, job: job.clone() });\n                 }\n             }\n@@ -117,31 +119,31 @@ where\n \n #[cold]\n #[inline(never)]\n-fn mk_cycle<CTX, V, R>(\n-    tcx: CTX,\n+fn mk_cycle<Qcx, V, R>(\n+    qcx: Qcx,\n     cycle_error: CycleError,\n     handler: HandleCycleError,\n     cache: &dyn crate::query::QueryStorage<Value = V, Stored = R>,\n ) -> R\n where\n-    CTX: QueryContext,\n-    V: std::fmt::Debug + Value<CTX::DepContext>,\n+    Qcx: QueryContext,\n+    V: std::fmt::Debug + Value<Qcx::DepContext>,\n     R: Clone,\n {\n-    let error = report_cycle(tcx.dep_context().sess(), &cycle_error);\n-    let value = handle_cycle_error(*tcx.dep_context(), &cycle_error, error, handler);\n+    let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n+    let value = handle_cycle_error(*qcx.dep_context(), &cycle_error, error, handler);\n     cache.store_nocache(value)\n }\n \n-fn handle_cycle_error<CTX, V>(\n-    tcx: CTX,\n+fn handle_cycle_error<Tcx, V>(\n+    tcx: Tcx,\n     cycle_error: &CycleError,\n     mut error: DiagnosticBuilder<'_, ErrorGuaranteed>,\n     handler: HandleCycleError,\n ) -> V\n where\n-    CTX: DepContext,\n-    V: Value<CTX>,\n+    Tcx: DepContext,\n+    V: Value<Tcx>,\n {\n     use HandleCycleError::*;\n     match handler {\n@@ -174,14 +176,14 @@ where\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    fn try_start<'b, CTX>(\n-        tcx: &'b CTX,\n+    fn try_start<'b, Qcx>(\n+        qcx: &'b Qcx,\n         state: &'b QueryState<K>,\n         span: Span,\n         key: K,\n     ) -> TryGetJob<'b, K>\n     where\n-        CTX: QueryContext,\n+        Qcx: QueryContext,\n     {\n         #[cfg(parallel_compiler)]\n         let mut state_lock = state.active.get_shard_by_value(&key).lock();\n@@ -191,8 +193,8 @@ where\n \n         match lock.entry(key) {\n             Entry::Vacant(entry) => {\n-                let id = tcx.next_job_id();\n-                let job = tcx.current_query_job();\n+                let id = qcx.next_job_id();\n+                let job = qcx.current_query_job();\n                 let job = QueryJob::new(id, span, job);\n \n                 let key = entry.key().clone();\n@@ -211,8 +213,8 @@ where\n                         // If we are single-threaded we know that we have cycle error,\n                         // so we just return the error.\n                         return TryGetJob::Cycle(id.find_cycle_in_stack(\n-                            tcx.try_collect_active_jobs().unwrap(),\n-                            &tcx.current_query_job(),\n+                            qcx.try_collect_active_jobs().unwrap(),\n+                            &qcx.current_query_job(),\n                             span,\n                         ));\n                     }\n@@ -221,7 +223,7 @@ where\n                         // For parallel queries, we'll block and wait until the query running\n                         // in another thread has completed. Record how long we wait in the\n                         // self-profiler.\n-                        let query_blocked_prof_timer = tcx.dep_context().profiler().query_blocked();\n+                        let query_blocked_prof_timer = qcx.dep_context().profiler().query_blocked();\n \n                         // Get the latch out\n                         let latch = job.latch();\n@@ -230,7 +232,7 @@ where\n \n                         // With parallel queries we might just have to wait on some other\n                         // thread.\n-                        let result = latch.wait_on(tcx.current_query_job(), span);\n+                        let result = latch.wait_on(qcx.current_query_job(), span);\n \n                         match result {\n                             Ok(()) => TryGetJob::JobCompleted(query_blocked_prof_timer),\n@@ -333,16 +335,16 @@ where\n /// which will be used if the query is not in the cache and we need\n /// to compute it.\n #[inline]\n-pub fn try_get_cached<'a, CTX, C, R, OnHit>(\n-    tcx: CTX,\n+pub fn try_get_cached<'a, Tcx, C, R, OnHit>(\n+    tcx: Tcx,\n     cache: &'a C,\n     key: &C::Key,\n     // `on_hit` can be called while holding a lock to the query cache\n     on_hit: OnHit,\n ) -> Result<R, ()>\n where\n     C: QueryCache,\n-    CTX: DepContext,\n+    Tcx: DepContext,\n     OnHit: FnOnce(&C::Stored) -> R,\n {\n     cache.lookup(&key, |value, index| {\n@@ -354,29 +356,29 @@ where\n     })\n }\n \n-fn try_execute_query<CTX, C>(\n-    tcx: CTX,\n+fn try_execute_query<Qcx, C>(\n+    qcx: Qcx,\n     state: &QueryState<C::Key>,\n     cache: &C,\n     span: Span,\n     key: C::Key,\n-    dep_node: Option<DepNode<CTX::DepKind>>,\n-    query: &QueryVTable<CTX, C::Key, C::Value>,\n+    dep_node: Option<DepNode<Qcx::DepKind>>,\n+    query: &QueryVTable<Qcx, C::Key, C::Value>,\n ) -> (C::Stored, Option<DepNodeIndex>)\n where\n     C: QueryCache,\n-    C::Key: Clone + DepNodeParams<CTX::DepContext>,\n-    C::Value: Value<CTX::DepContext>,\n-    CTX: QueryContext,\n+    C::Key: Clone + DepNodeParams<Qcx::DepContext>,\n+    C::Value: Value<Qcx::DepContext>,\n+    Qcx: QueryContext,\n {\n-    match JobOwner::<'_, C::Key>::try_start(&tcx, state, span, key.clone()) {\n+    match JobOwner::<'_, C::Key>::try_start(&qcx, state, span, key.clone()) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job(tcx, key, dep_node, query, job.id);\n+            let (result, dep_node_index) = execute_job(qcx, key, dep_node, query, job.id);\n             let result = job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n         }\n         TryGetJob::Cycle(error) => {\n-            let result = mk_cycle(tcx, error, query.handle_cycle_error, cache);\n+            let result = mk_cycle(qcx, error, query.handle_cycle_error, cache);\n             (result, None)\n         }\n         #[cfg(parallel_compiler)]\n@@ -385,8 +387,8 @@ where\n                 .lookup(&key, |value, index| (value.clone(), index))\n                 .unwrap_or_else(|_| panic!(\"value must be in cache after waiting\"));\n \n-            if std::intrinsics::unlikely(tcx.dep_context().profiler().enabled()) {\n-                tcx.dep_context().profiler().query_cache_hit(index.into());\n+            if std::intrinsics::unlikely(qcx.dep_context().profiler().enabled()) {\n+                qcx.dep_context().profiler().query_cache_hit(index.into());\n             }\n             query_blocked_prof_timer.finish_with_query_invocation_id(index.into());\n \n@@ -395,25 +397,25 @@ where\n     }\n }\n \n-fn execute_job<CTX, K, V>(\n-    tcx: CTX,\n+fn execute_job<Qcx, K, V>(\n+    qcx: Qcx,\n     key: K,\n-    mut dep_node_opt: Option<DepNode<CTX::DepKind>>,\n-    query: &QueryVTable<CTX, K, V>,\n+    mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n+    query: &QueryVTable<Qcx, K, V>,\n     job_id: QueryJobId,\n ) -> (V, DepNodeIndex)\n where\n-    K: Clone + DepNodeParams<CTX::DepContext>,\n+    K: Clone + DepNodeParams<Qcx::DepContext>,\n     V: Debug,\n-    CTX: QueryContext,\n+    Qcx: QueryContext,\n {\n-    let dep_graph = tcx.dep_context().dep_graph();\n+    let dep_graph = qcx.dep_context().dep_graph();\n \n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n-        let prof_timer = tcx.dep_context().profiler().query_provider();\n-        let result = tcx.start_query(job_id, query.depth_limit, None, || {\n-            query.compute(*tcx.dep_context(), key)\n+        let prof_timer = qcx.dep_context().profiler().query_provider();\n+        let result = qcx.start_query(job_id, query.depth_limit, None, || {\n+            query.compute(*qcx.dep_context(), key)\n         });\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -423,33 +425,33 @@ where\n     if !query.anon && !query.eval_always {\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node =\n-            dep_node_opt.get_or_insert_with(|| query.to_dep_node(*tcx.dep_context(), &key));\n+            dep_node_opt.get_or_insert_with(|| query.to_dep_node(*qcx.dep_context(), &key));\n \n         // The diagnostics for this query will be promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n-        if let Some(ret) = tcx.start_query(job_id, false, None, || {\n-            try_load_from_disk_and_cache_in_memory(tcx, &key, &dep_node, query)\n+        if let Some(ret) = qcx.start_query(job_id, false, None, || {\n+            try_load_from_disk_and_cache_in_memory(qcx, &key, &dep_node, query)\n         }) {\n             return ret;\n         }\n     }\n \n-    let prof_timer = tcx.dep_context().profiler().query_provider();\n+    let prof_timer = qcx.dep_context().profiler().query_provider();\n     let diagnostics = Lock::new(ThinVec::new());\n \n     let (result, dep_node_index) =\n-        tcx.start_query(job_id, query.depth_limit, Some(&diagnostics), || {\n+        qcx.start_query(job_id, query.depth_limit, Some(&diagnostics), || {\n             if query.anon {\n-                return dep_graph.with_anon_task(*tcx.dep_context(), query.dep_kind, || {\n-                    query.compute(*tcx.dep_context(), key)\n+                return dep_graph.with_anon_task(*qcx.dep_context(), query.dep_kind, || {\n+                    query.compute(*qcx.dep_context(), key)\n                 });\n             }\n \n             // `to_dep_node` is expensive for some `DepKind`s.\n             let dep_node =\n-                dep_node_opt.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n+                dep_node_opt.unwrap_or_else(|| query.to_dep_node(*qcx.dep_context(), &key));\n \n-            dep_graph.with_task(dep_node, *tcx.dep_context(), key, query.compute, query.hash_result)\n+            dep_graph.with_task(dep_node, *qcx.dep_context(), key, query.compute, query.hash_result)\n         });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -459,55 +461,55 @@ where\n \n     if std::intrinsics::unlikely(!side_effects.is_empty()) {\n         if query.anon {\n-            tcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n+            qcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n         } else {\n-            tcx.store_side_effects(dep_node_index, side_effects);\n+            qcx.store_side_effects(dep_node_index, side_effects);\n         }\n     }\n \n     (result, dep_node_index)\n }\n \n-fn try_load_from_disk_and_cache_in_memory<CTX, K, V>(\n-    tcx: CTX,\n+fn try_load_from_disk_and_cache_in_memory<Qcx, K, V>(\n+    qcx: Qcx,\n     key: &K,\n-    dep_node: &DepNode<CTX::DepKind>,\n-    query: &QueryVTable<CTX, K, V>,\n+    dep_node: &DepNode<Qcx::DepKind>,\n+    query: &QueryVTable<Qcx, K, V>,\n ) -> Option<(V, DepNodeIndex)>\n where\n     K: Clone,\n-    CTX: QueryContext,\n+    Qcx: QueryContext,\n     V: Debug,\n {\n     // Note this function can be called concurrently from the same query\n     // We must ensure that this is handled correctly.\n \n-    let dep_graph = tcx.dep_context().dep_graph();\n-    let (prev_dep_node_index, dep_node_index) = dep_graph.try_mark_green(tcx, &dep_node)?;\n+    let dep_graph = qcx.dep_context().dep_graph();\n+    let (prev_dep_node_index, dep_node_index) = dep_graph.try_mark_green(qcx, &dep_node)?;\n \n     debug_assert!(dep_graph.is_green(dep_node));\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n     if let Some(try_load_from_disk) = query.try_load_from_disk {\n-        let prof_timer = tcx.dep_context().profiler().incr_cache_loading();\n+        let prof_timer = qcx.dep_context().profiler().incr_cache_loading();\n \n         // The call to `with_query_deserialization` enforces that no new `DepNodes`\n         // are created during deserialization. See the docs of that method for more\n         // details.\n         let result =\n-            dep_graph.with_query_deserialization(|| try_load_from_disk(tcx, prev_dep_node_index));\n+            dep_graph.with_query_deserialization(|| try_load_from_disk(qcx, prev_dep_node_index));\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n         if let Some(result) = result {\n             if std::intrinsics::unlikely(\n-                tcx.dep_context().sess().opts.unstable_opts.query_dep_graph,\n+                qcx.dep_context().sess().opts.unstable_opts.query_dep_graph,\n             ) {\n                 dep_graph.mark_debug_loaded_from_disk(*dep_node)\n             }\n \n-            let prev_fingerprint = tcx\n+            let prev_fingerprint = qcx\n                 .dep_context()\n                 .dep_graph()\n                 .prev_fingerprint_of(dep_node)\n@@ -521,9 +523,9 @@ where\n             // give us some coverage of potential bugs though.\n             let try_verify = prev_fingerprint.as_value().1 % 32 == 0;\n             if std::intrinsics::unlikely(\n-                try_verify || tcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n+                try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n             ) {\n-                incremental_verify_ich(*tcx.dep_context(), &result, dep_node, query);\n+                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query);\n             }\n \n             return Some((result, dep_node_index));\n@@ -532,18 +534,18 @@ where\n         // We always expect to find a cached result for things that\n         // can be forced from `DepNode`.\n         debug_assert!(\n-            !tcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n+            !qcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n             \"missing on-disk cache entry for {:?}\",\n             dep_node\n         );\n     }\n \n     // We could not load a result from the on-disk cache, so\n     // recompute.\n-    let prof_timer = tcx.dep_context().profiler().query_provider();\n+    let prof_timer = qcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| query.compute(*tcx.dep_context(), key.clone()));\n+    let result = dep_graph.with_ignore(|| query.compute(*qcx.dep_context(), key.clone()));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -556,34 +558,38 @@ where\n     //\n     // See issue #82920 for an example of a miscompilation that would get turned into\n     // an ICE by this check\n-    incremental_verify_ich(*tcx.dep_context(), &result, dep_node, query);\n+    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query);\n \n     Some((result, dep_node_index))\n }\n \n-fn incremental_verify_ich<CTX, K, V: Debug>(\n-    tcx: CTX::DepContext,\n+#[instrument(skip(qcx, result, query), level = \"debug\")]\n+fn incremental_verify_ich<Qcx, K, V: Debug>(\n+    qcx: Qcx::DepContext,\n     result: &V,\n-    dep_node: &DepNode<CTX::DepKind>,\n-    query: &QueryVTable<CTX, K, V>,\n+    dep_node: &DepNode<Qcx::DepKind>,\n+    query: &QueryVTable<Qcx, K, V>,\n ) where\n-    CTX: QueryContext,\n+    Qcx: QueryContext,\n {\n     assert!(\n-        tcx.dep_graph().is_green(dep_node),\n+        qcx.dep_graph().is_green(dep_node),\n         \"fingerprint for green query instance not loaded from cache: {:?}\",\n         dep_node,\n     );\n \n-    debug!(\"BEGIN verify_ich({:?})\", dep_node);\n     let new_hash = query.hash_result.map_or(Fingerprint::ZERO, |f| {\n-        tcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n+        qcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n     });\n-    let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n-    debug!(\"END verify_ich({:?})\", dep_node);\n+\n+    let old_hash = qcx.dep_graph().prev_fingerprint_of(dep_node);\n \n     if Some(new_hash) != old_hash {\n-        incremental_verify_ich_cold(tcx.sess(), DebugArg::from(&dep_node), DebugArg::from(&result));\n+        incremental_verify_ich_failed(\n+            qcx.sess(),\n+            DebugArg::from(&dep_node),\n+            DebugArg::from(&result),\n+        );\n     }\n }\n \n@@ -629,13 +635,7 @@ impl std::fmt::Debug for DebugArg<'_> {\n // different implementations for LLVM to chew on (and filling up the final\n // binary, too).\n #[cold]\n-fn incremental_verify_ich_cold(sess: &Session, dep_node: DebugArg<'_>, result: DebugArg<'_>) {\n-    let run_cmd = if let Some(crate_name) = &sess.opts.crate_name {\n-        format!(\"`cargo clean -p {}` or `cargo clean`\", crate_name)\n-    } else {\n-        \"`cargo clean`\".to_string()\n-    };\n-\n+fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result: DebugArg<'_>) {\n     // When we emit an error message and panic, we try to debug-print the `DepNode`\n     // and query result. Unfortunately, this can cause us to run additional queries,\n     // which may result in another fingerprint mismatch while we're in the middle\n@@ -651,6 +651,12 @@ fn incremental_verify_ich_cold(sess: &Session, dep_node: DebugArg<'_>, result: D\n     if old_in_panic {\n         sess.emit_err(crate::error::Reentrant);\n     } else {\n+        let run_cmd = if let Some(crate_name) = &sess.opts.crate_name {\n+            format!(\"`cargo clean -p {}` or `cargo clean`\", crate_name)\n+        } else {\n+            \"`cargo clean`\".to_string()\n+        };\n+\n         sess.emit_err(crate::error::IncrementCompilation {\n             run_cmd,\n             dep_node: format!(\"{:?}\", dep_node),\n@@ -670,14 +676,14 @@ fn incremental_verify_ich_cold(sess: &Session, dep_node: DebugArg<'_>, result: D\n ///\n /// Note: The optimization is only available during incr. comp.\n #[inline(never)]\n-fn ensure_must_run<CTX, K, V>(\n-    tcx: CTX,\n+fn ensure_must_run<Qcx, K, V>(\n+    qcx: Qcx,\n     key: &K,\n-    query: &QueryVTable<CTX, K, V>,\n-) -> (bool, Option<DepNode<CTX::DepKind>>)\n+    query: &QueryVTable<Qcx, K, V>,\n+) -> (bool, Option<DepNode<Qcx::DepKind>>)\n where\n-    K: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n-    CTX: QueryContext,\n+    K: crate::dep_graph::DepNodeParams<Qcx::DepContext>,\n+    Qcx: QueryContext,\n {\n     if query.eval_always {\n         return (true, None);\n@@ -686,10 +692,10 @@ where\n     // Ensuring an anonymous query makes no sense\n     assert!(!query.anon);\n \n-    let dep_node = query.to_dep_node(*tcx.dep_context(), key);\n+    let dep_node = query.to_dep_node(*qcx.dep_context(), key);\n \n-    let dep_graph = tcx.dep_context().dep_graph();\n-    match dep_graph.try_mark_green(tcx, &dep_node) {\n+    let dep_graph = qcx.dep_context().dep_graph();\n+    match dep_graph.try_mark_green(qcx, &dep_node) {\n         None => {\n             // A None return from `try_mark_green` means that this is either\n             // a new dep node or that the dep node has already been marked red.\n@@ -701,7 +707,7 @@ where\n         }\n         Some((_, dep_node_index)) => {\n             dep_graph.read_index(dep_node_index);\n-            tcx.dep_context().profiler().query_cache_hit(dep_node_index.into());\n+            qcx.dep_context().profiler().query_cache_hit(dep_node_index.into());\n             (false, None)\n         }\n     }\n@@ -713,16 +719,16 @@ pub enum QueryMode {\n     Ensure,\n }\n \n-pub fn get_query<Q, CTX>(tcx: CTX, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n+pub fn get_query<Q, Qcx>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n where\n-    Q: QueryDescription<CTX>,\n-    Q::Key: DepNodeParams<CTX::DepContext>,\n-    Q::Value: Value<CTX::DepContext>,\n-    CTX: QueryContext,\n+    Q: QueryConfig<Qcx>,\n+    Q::Key: DepNodeParams<Qcx::DepContext>,\n+    Q::Value: Value<Qcx::DepContext>,\n+    Qcx: QueryContext,\n {\n-    let query = Q::make_vtable(tcx, &key);\n+    let query = Q::make_vtable(qcx, &key);\n     let dep_node = if let QueryMode::Ensure = mode {\n-        let (must_run, dep_node) = ensure_must_run(tcx, &key, &query);\n+        let (must_run, dep_node) = ensure_must_run(qcx, &key, &query);\n         if !must_run {\n             return None;\n         }\n@@ -732,33 +738,33 @@ where\n     };\n \n     let (result, dep_node_index) = try_execute_query(\n-        tcx,\n-        Q::query_state(tcx),\n-        Q::query_cache(tcx),\n+        qcx,\n+        Q::query_state(qcx),\n+        Q::query_cache(qcx),\n         span,\n         key,\n         dep_node,\n         &query,\n     );\n     if let Some(dep_node_index) = dep_node_index {\n-        tcx.dep_context().dep_graph().read_index(dep_node_index)\n+        qcx.dep_context().dep_graph().read_index(dep_node_index)\n     }\n     Some(result)\n }\n \n-pub fn force_query<Q, CTX>(tcx: CTX, key: Q::Key, dep_node: DepNode<CTX::DepKind>)\n+pub fn force_query<Q, Qcx>(qcx: Qcx, key: Q::Key, dep_node: DepNode<Qcx::DepKind>)\n where\n-    Q: QueryDescription<CTX>,\n-    Q::Key: DepNodeParams<CTX::DepContext>,\n-    Q::Value: Value<CTX::DepContext>,\n-    CTX: QueryContext,\n+    Q: QueryConfig<Qcx>,\n+    Q::Key: DepNodeParams<Qcx::DepContext>,\n+    Q::Value: Value<Qcx::DepContext>,\n+    Qcx: QueryContext,\n {\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n-    let cache = Q::query_cache(tcx);\n+    let cache = Q::query_cache(qcx);\n     let cached = cache.lookup(&key, |_, index| {\n-        if std::intrinsics::unlikely(tcx.dep_context().profiler().enabled()) {\n-            tcx.dep_context().profiler().query_cache_hit(index.into());\n+        if std::intrinsics::unlikely(qcx.dep_context().profiler().enabled()) {\n+            qcx.dep_context().profiler().query_cache_hit(index.into());\n         }\n     });\n \n@@ -767,9 +773,9 @@ where\n         Err(()) => {}\n     }\n \n-    let query = Q::make_vtable(tcx, &key);\n-    let state = Q::query_state(tcx);\n+    let query = Q::make_vtable(qcx, &key);\n+    let state = Q::query_state(qcx);\n     debug_assert!(!query.anon);\n \n-    try_execute_query(tcx, state, cache, DUMMY_SP, key, Some(dep_node), &query);\n+    try_execute_query(qcx, state, cache, DUMMY_SP, key, Some(dep_node), &query);\n }"}, {"sha": "214656abed4dfeb3d13c858faeb67eec9db82830", "filename": "compiler/rustc_query_system/src/values.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,12 +1,12 @@\n use crate::dep_graph::DepContext;\n use crate::query::QueryInfo;\n \n-pub trait Value<CTX: DepContext>: Sized {\n-    fn from_cycle_error(tcx: CTX, cycle: &[QueryInfo]) -> Self;\n+pub trait Value<Tcx: DepContext>: Sized {\n+    fn from_cycle_error(tcx: Tcx, cycle: &[QueryInfo]) -> Self;\n }\n \n-impl<CTX: DepContext, T> Value<CTX> for T {\n-    default fn from_cycle_error(tcx: CTX, _: &[QueryInfo]) -> T {\n+impl<Tcx: DepContext, T> Value<Tcx> for T {\n+    default fn from_cycle_error(tcx: Tcx, _: &[QueryInfo]) -> T {\n         tcx.sess().abort_if_errors();\n         // Ideally we would use `bug!` here. But bug! is only defined in rustc_middle, and it's\n         // non-trivial to define it earlier."}, {"sha": "a12918b2979906021789ef8f5936bc59eb42c02c", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -241,10 +241,12 @@ impl<'a> Resolver<'a> {\n         ));\n \n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n-        err.span_label(\n-            self.session.source_map().guess_head_span(old_binding.span),\n-            format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n-        );\n+        if !old_binding.span.is_dummy() && old_binding.span != span {\n+            err.span_label(\n+                self.session.source_map().guess_head_span(old_binding.span),\n+                format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n+            );\n+        }\n \n         // See https://github.com/rust-lang/rust/issues/32354\n         use NameBindingKind::Import;"}, {"sha": "fa6d34be0cc37c00a794031984ab513bb54d67f0", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 131, "deletions": 91, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,16 +1,38 @@\n-use crate::{ImportKind, NameBindingKind, Resolver};\n+use crate::{ImportKind, NameBinding, NameBindingKind, Resolver, ResolverTree};\n use rustc_ast::ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n use rustc_ast::Crate;\n use rustc_ast::EnumDef;\n+use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n-use rustc_middle::middle::privacy::Level;\n-use rustc_middle::ty::{DefIdTree, Visibility};\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility, Level};\n+use rustc_middle::ty::Visibility;\n+\n+type ImportId<'a> = Interned<'a, NameBinding<'a>>;\n+\n+#[derive(Clone, Copy)]\n+enum ParentId<'a> {\n+    Def(LocalDefId),\n+    Import(ImportId<'a>),\n+}\n+\n+impl ParentId<'_> {\n+    fn level(self) -> Level {\n+        match self {\n+            ParentId::Def(_) => Level::Direct,\n+            ParentId::Import(_) => Level::Reexported,\n+        }\n+    }\n+}\n \n pub struct EffectiveVisibilitiesVisitor<'r, 'a> {\n     r: &'r mut Resolver<'a>,\n+    /// While walking import chains we need to track effective visibilities per-binding, and def id\n+    /// keys in `Resolver::effective_visibilities` are not enough for that, because multiple\n+    /// bindings can correspond to a single def id in imports. So we keep a separate table.\n+    import_effective_visibilities: EffectiveVisibilities<ImportId<'a>>,\n     changed: bool,\n }\n \n@@ -19,21 +41,57 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n     /// need access to a TyCtxt for that.\n     pub fn compute_effective_visibilities<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n-        let mut visitor = EffectiveVisibilitiesVisitor { r, changed: false };\n+        let mut visitor = EffectiveVisibilitiesVisitor {\n+            r,\n+            import_effective_visibilities: Default::default(),\n+            changed: false,\n+        };\n \n-        visitor.update(CRATE_DEF_ID, Visibility::Public, CRATE_DEF_ID, Level::Direct);\n+        visitor.update(CRATE_DEF_ID, CRATE_DEF_ID);\n         visitor.set_bindings_effective_visibilities(CRATE_DEF_ID);\n \n         while visitor.changed {\n-            visitor.reset();\n+            visitor.changed = false;\n             visit::walk_crate(&mut visitor, krate);\n         }\n \n+        // Update visibilities for import def ids. These are not used during the\n+        // `EffectiveVisibilitiesVisitor` pass, because we have more detailed binding-based\n+        // information, but are used by later passes. Effective visibility of an import def id\n+        // is the maximum value among visibilities of bindings corresponding to that def id.\n+        for (binding, eff_vis) in visitor.import_effective_visibilities.iter() {\n+            let NameBindingKind::Import { import, .. } = binding.kind else { unreachable!() };\n+            if let Some(node_id) = import.id() {\n+                let mut update = |node_id| {\n+                    r.effective_visibilities.update_eff_vis(\n+                        r.local_def_id(node_id),\n+                        eff_vis,\n+                        ResolverTree(&r.definitions, &r.crate_loader),\n+                    )\n+                };\n+                update(node_id);\n+                if let ImportKind::Single { additional_ids: (id1, id2), .. } = import.kind {\n+                    // In theory all the single import IDs have individual visibilities and\n+                    // effective visibilities, but in practice these IDs go straigth to HIR\n+                    // where all their few uses assume that their (effective) visibility\n+                    // applies to the whole syntactic `use` item. So they all get the same\n+                    // value which is the maximum of all bindings. Maybe HIR for imports\n+                    // shouldn't use three IDs at all.\n+                    if id1 != ast::DUMMY_NODE_ID {\n+                        update(id1);\n+                    }\n+                    if id2 != ast::DUMMY_NODE_ID {\n+                        update(id2);\n+                    }\n+                }\n+            }\n+        }\n+\n         info!(\"resolve::effective_visibilities: {:#?}\", r.effective_visibilities);\n     }\n \n-    fn reset(&mut self) {\n-        self.changed = false;\n+    fn nearest_normal_mod(&mut self, def_id: LocalDefId) -> LocalDefId {\n+        self.r.get_nearest_non_block_module(def_id.to_def_id()).nearest_parent_mod().expect_local()\n     }\n \n     /// Update effective visibilities of bindings in the given module,\n@@ -48,92 +106,83 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n                 // Set the given effective visibility level to `Level::Direct` and\n                 // sets the rest of the `use` chain to `Level::Reexported` until\n                 // we hit the actual exported item.\n+                let mut parent_id = ParentId::Def(module_id);\n+                while let NameBindingKind::Import { binding: nested_binding, .. } = binding.kind {\n+                    let binding_id = ImportId::new_unchecked(binding);\n+                    self.update_import(binding_id, parent_id);\n \n-                // FIXME: tag and is_public() condition should be removed, but assertions occur.\n-                let tag = if binding.is_import() { Level::Reexported } else { Level::Direct };\n-                if binding.vis.is_public() {\n-                    let mut prev_parent_id = module_id;\n-                    let mut level = Level::Direct;\n-                    while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n-                        binding.kind\n-                    {\n-                        let mut update = |node_id| {\n-                            self.update(\n-                                self.r.local_def_id(node_id),\n-                                binding.vis.expect_local(),\n-                                prev_parent_id,\n-                                level,\n-                            )\n-                        };\n-                        match import.kind {\n-                            ImportKind::Single { id, additional_ids, .. } => {\n-                                // In theory all the import IDs have individual visibilities and\n-                                // effective visibilities, but in practice these IDs go straigth to\n-                                // HIR where all their few uses assume that their (effective)\n-                                // visibility applies to the whole syntactic `use` item. So we\n-                                // update them all to the maximum value among the potential\n-                                // individual effective visibilities. Maybe HIR for imports\n-                                // shouldn't use three IDs at all.\n-                                update(id);\n-                                update(additional_ids.0);\n-                                update(additional_ids.1);\n-                                prev_parent_id = self.r.local_def_id(id);\n-                            }\n-                            ImportKind::Glob { id, .. } | ImportKind::ExternCrate { id, .. } => {\n-                                update(id);\n-                                prev_parent_id = self.r.local_def_id(id);\n-                            }\n-                            ImportKind::MacroUse => {\n-                                // In theory we should reset the parent id to something private\n-                                // here, but `macro_use` imports always refer to external items,\n-                                // so it doesn't matter and we can just do nothing.\n-                            }\n-                            ImportKind::MacroExport => {\n-                                // In theory we should reset the parent id to something public\n-                                // here, but it has the same effect as leaving the previous parent,\n-                                // so we can just do nothing.\n-                            }\n-                        }\n-\n-                        level = Level::Reexported;\n-                        binding = nested_binding;\n-                    }\n+                    parent_id = ParentId::Import(binding_id);\n+                    binding = nested_binding;\n                 }\n \n                 if let Some(def_id) = binding.res().opt_def_id().and_then(|id| id.as_local()) {\n-                    self.update(def_id, binding.vis.expect_local(), module_id, tag);\n+                    self.update_def(def_id, binding.vis.expect_local(), parent_id);\n                 }\n             }\n         }\n     }\n \n-    fn update(\n-        &mut self,\n-        def_id: LocalDefId,\n+    fn effective_vis(&self, parent_id: ParentId<'a>) -> Option<EffectiveVisibility> {\n+        match parent_id {\n+            ParentId::Def(def_id) => self.r.effective_visibilities.effective_vis(def_id),\n+            ParentId::Import(binding) => self.import_effective_visibilities.effective_vis(binding),\n+        }\n+        .copied()\n+    }\n+\n+    /// The update is guaranteed to not change the table and we can skip it.\n+    fn is_noop_update(\n+        &self,\n+        parent_id: ParentId<'a>,\n         nominal_vis: Visibility,\n-        parent_id: LocalDefId,\n-        tag: Level,\n-    ) {\n-        let module_id = self\n-            .r\n-            .get_nearest_non_block_module(def_id.to_def_id())\n-            .nearest_parent_mod()\n-            .expect_local();\n-        if nominal_vis == Visibility::Restricted(module_id)\n-            || self.r.visibilities[&parent_id] == Visibility::Restricted(module_id)\n-        {\n+        default_vis: Visibility,\n+    ) -> bool {\n+        nominal_vis == default_vis\n+            || match parent_id {\n+                ParentId::Def(def_id) => self.r.visibilities[&def_id],\n+                ParentId::Import(binding) => binding.vis.expect_local(),\n+            } == default_vis\n+    }\n+\n+    fn update_import(&mut self, binding: ImportId<'a>, parent_id: ParentId<'a>) {\n+        let NameBindingKind::Import { import, .. } = binding.kind else { unreachable!() };\n+        let nominal_vis = binding.vis.expect_local();\n+        let default_vis = Visibility::Restricted(\n+            import\n+                .id()\n+                .map(|id| self.nearest_normal_mod(self.r.local_def_id(id)))\n+                .unwrap_or(CRATE_DEF_ID),\n+        );\n+        if self.is_noop_update(parent_id, nominal_vis, default_vis) {\n             return;\n         }\n-        let mut effective_visibilities = std::mem::take(&mut self.r.effective_visibilities);\n-        self.changed |= effective_visibilities.update(\n+        self.changed |= self.import_effective_visibilities.update(\n+            binding,\n+            nominal_vis,\n+            default_vis,\n+            self.effective_vis(parent_id),\n+            parent_id.level(),\n+            ResolverTree(&self.r.definitions, &self.r.crate_loader),\n+        );\n+    }\n+\n+    fn update_def(&mut self, def_id: LocalDefId, nominal_vis: Visibility, parent_id: ParentId<'a>) {\n+        let default_vis = Visibility::Restricted(self.nearest_normal_mod(def_id));\n+        if self.is_noop_update(parent_id, nominal_vis, default_vis) {\n+            return;\n+        }\n+        self.changed |= self.r.effective_visibilities.update(\n             def_id,\n             nominal_vis,\n-            || Visibility::Restricted(module_id),\n-            parent_id,\n-            tag,\n-            &*self.r,\n+            if def_id == CRATE_DEF_ID { Visibility::Public } else { default_vis },\n+            self.effective_vis(parent_id),\n+            parent_id.level(),\n+            ResolverTree(&self.r.definitions, &self.r.crate_loader),\n         );\n-        self.r.effective_visibilities = effective_visibilities;\n+    }\n+\n+    fn update(&mut self, def_id: LocalDefId, parent_id: LocalDefId) {\n+        self.update_def(def_id, self.r.visibilities[&def_id], ParentId::Def(parent_id));\n     }\n }\n \n@@ -151,12 +200,6 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n                 \"ast::ItemKind::MacCall encountered, this should not anymore appear at this stage\"\n             ),\n \n-            // Foreign modules inherit level from parents.\n-            ast::ItemKind::ForeignMod(..) => {\n-                let parent_id = self.r.local_parent(def_id);\n-                self.update(def_id, Visibility::Public, parent_id, Level::Direct);\n-            }\n-\n             ast::ItemKind::Mod(..) => {\n                 self.set_bindings_effective_visibilities(def_id);\n                 visit::walk_item(self, item);\n@@ -167,18 +210,14 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n                 for variant in variants {\n                     let variant_def_id = self.r.local_def_id(variant.id);\n                     for field in variant.data.fields() {\n-                        let field_def_id = self.r.local_def_id(field.id);\n-                        let vis = self.r.visibilities[&field_def_id];\n-                        self.update(field_def_id, vis, variant_def_id, Level::Direct);\n+                        self.update(self.r.local_def_id(field.id), variant_def_id);\n                     }\n                 }\n             }\n \n             ast::ItemKind::Struct(ref def, _) | ast::ItemKind::Union(ref def, _) => {\n                 for field in def.fields() {\n-                    let field_def_id = self.r.local_def_id(field.id);\n-                    let vis = self.r.visibilities[&field_def_id];\n-                    self.update(field_def_id, vis, def_id, Level::Direct);\n+                    self.update(self.r.local_def_id(field.id), def_id);\n                 }\n             }\n \n@@ -194,6 +233,7 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n             | ast::ItemKind::TyAlias(..)\n             | ast::ItemKind::TraitAlias(..)\n             | ast::ItemKind::MacroDef(..)\n+            | ast::ItemKind::ForeignMod(..)\n             | ast::ItemKind::Fn(..) => return,\n         }\n     }"}, {"sha": "346024bb5984b4ccb0eaa68e5604b9d2d7f945e4", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -322,7 +322,12 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n \n         self.suggest_bare_struct_literal(&mut err);\n-        self.suggest_pattern_match_with_let(&mut err, source, span);\n+\n+        if self.suggest_pattern_match_with_let(&mut err, source, span) {\n+            // Fallback label.\n+            err.span_label(base_error.span, &base_error.fallback_label);\n+            return (err, Vec::new());\n+        }\n \n         self.suggest_self_or_self_ref(&mut err, path, span);\n         self.detect_assoct_type_constraint_meant_as_path(&mut err, &base_error);\n@@ -341,7 +346,11 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         if !self.type_ascription_suggestion(&mut err, base_error.span) {\n             let mut fallback =\n                 self.suggest_trait_and_bounds(&mut err, source, res, span, &base_error);\n+\n+            // if we have suggested using pattern matching, then don't add needless suggestions\n+            // for typos.\n             fallback |= self.suggest_typo(&mut err, source, path, span, &base_error);\n+\n             if fallback {\n                 // Fallback label.\n                 err.span_label(base_error.span, &base_error.fallback_label);\n@@ -797,14 +806,16 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         err.code(rustc_errors::error_code!(E0411));\n         err.span_label(span, \"`Self` is only available in impls, traits, and type definitions\");\n         if let Some(item_kind) = self.diagnostic_metadata.current_item {\n-            err.span_label(\n-                item_kind.ident.span,\n-                format!(\n-                    \"`Self` not allowed in {} {}\",\n-                    item_kind.kind.article(),\n-                    item_kind.kind.descr()\n-                ),\n-            );\n+            if !item_kind.ident.span.is_dummy() {\n+                err.span_label(\n+                    item_kind.ident.span,\n+                    format!(\n+                        \"`Self` not allowed in {} {}\",\n+                        item_kind.kind.article(),\n+                        item_kind.kind.descr()\n+                    ),\n+                );\n+            }\n         }\n         true\n     }\n@@ -937,7 +948,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         err: &mut Diagnostic,\n         source: PathSource<'_>,\n         span: Span,\n-    ) {\n+    ) -> bool {\n         if let PathSource::Expr(_) = source &&\n         let Some(Expr {\n                     span: expr_span,\n@@ -954,8 +965,10 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     \"let \",\n                     Applicability::MaybeIncorrect,\n                 );\n+                return true;\n             }\n         }\n+        false\n     }\n \n     fn get_single_associated_item("}, {"sha": "a1ff477c6fefbf99859477c43bc3181b61559fc2", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1106,17 +1106,30 @@ impl<'a> AsMut<Resolver<'a>> for Resolver<'a> {\n     }\n }\n \n-impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n+/// A minimal subset of resolver that can implemenent `DefIdTree`, sometimes\n+/// required to satisfy borrow checker by avoiding borrowing the whole resolver.\n+#[derive(Clone, Copy)]\n+struct ResolverTree<'a, 'b>(&'a Definitions, &'a CrateLoader<'b>);\n+\n+impl DefIdTree for ResolverTree<'_, '_> {\n     #[inline]\n     fn opt_parent(self, id: DefId) -> Option<DefId> {\n+        let ResolverTree(definitions, crate_loader) = self;\n         match id.as_local() {\n-            Some(id) => self.definitions.def_key(id).parent,\n-            None => self.cstore().def_key(id).parent,\n+            Some(id) => definitions.def_key(id).parent,\n+            None => crate_loader.cstore().def_key(id).parent,\n         }\n         .map(|index| DefId { index, ..id })\n     }\n }\n \n+impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n+    #[inline]\n+    fn opt_parent(self, id: DefId) -> Option<DefId> {\n+        ResolverTree(&self.definitions, &self.crate_loader).opt_parent(id)\n+    }\n+}\n+\n impl Resolver<'_> {\n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n         self.node_id_to_def_id.get(&node).copied()"}, {"sha": "be084adb7b724c831ce3ec882180147ae431a53b", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -548,6 +548,7 @@ pub enum PrintRequest {\n     NativeStaticLibs,\n     StackProtectorStrategies,\n     LinkArgs,\n+    SplitDebuginfo,\n }\n \n pub enum Input {\n@@ -1806,6 +1807,7 @@ fn collect_print_requests(\n         (\"stack-protector-strategies\", PrintRequest::StackProtectorStrategies),\n         (\"target-spec-json\", PrintRequest::TargetSpec),\n         (\"link-args\", PrintRequest::LinkArgs),\n+        (\"split-debuginfo\", PrintRequest::SplitDebuginfo),\n     ];\n \n     prints.extend(matches.opt_strs(\"print\").into_iter().map(|req| {"}, {"sha": "3baa2e03cbad722a30bcae70e468cc9b7c10392d", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -855,7 +855,8 @@ impl SourceMap {\n     /// Returns a new span representing the next character after the end-point of this span.\n     /// Special cases:\n     /// - if span is a dummy one, returns the same span\n-    /// - if next_point reached the end of source, return span with lo = hi\n+    /// - if next_point reached the end of source, return a span exceeding the end of source,\n+    ///   which means sm.span_to_snippet(next_point) will get `Err`\n     /// - respect multi-byte characters\n     pub fn next_point(&self, sp: Span) -> Span {\n         if sp.is_dummy() {\n@@ -864,9 +865,6 @@ impl SourceMap {\n         let start_of_next_point = sp.hi().0;\n \n         let width = self.find_width_of_character_at_span(sp, true);\n-        if width == 0 {\n-            return Span::new(sp.hi(), sp.hi(), sp.ctxt(), None);\n-        }\n         // If the width is 1, then the next span should only contain the next char besides current ending.\n         // However, in the case of a multibyte character, where the width != 1, the next span should\n         // span multiple bytes to include the whole character.\n@@ -938,7 +936,7 @@ impl SourceMap {\n         // Ensure indexes are also not malformed.\n         if start_index > end_index || end_index > source_len - 1 {\n             debug!(\"find_width_of_character_at_span: source indexes are malformed\");\n-            return 0;\n+            return 1;\n         }\n \n         let src = local_begin.sf.external_src.borrow();"}, {"sha": "3cab59e8dbe6cf6166b90d65ad62889e852782a7", "filename": "compiler/rustc_span/src/source_map/tests.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -511,16 +511,17 @@ fn test_next_point() {\n     assert_eq!(span.lo().0, 4);\n     assert_eq!(span.hi().0, 5);\n \n-    // A non-empty span at the last byte should advance to create an empty\n-    // span pointing at the end of the file.\n+    // Reaching to the end of file, return a span that will get error with `span_to_snippet`\n     let span = Span::with_root_ctxt(BytePos(4), BytePos(5));\n     let span = sm.next_point(span);\n     assert_eq!(span.lo().0, 5);\n-    assert_eq!(span.hi().0, 5);\n+    assert_eq!(span.hi().0, 6);\n+    assert!(sm.span_to_snippet(span).is_err());\n \n-    // Empty span pointing just past the last byte.\n+    // Reaching to the end of file, return a span that will get error with `span_to_snippet`\n     let span = Span::with_root_ctxt(BytePos(5), BytePos(5));\n     let span = sm.next_point(span);\n     assert_eq!(span.lo().0, 5);\n-    assert_eq!(span.hi().0, 5);\n+    assert_eq!(span.hi().0, 6);\n+    assert!(sm.span_to_snippet(span).is_err());\n }"}, {"sha": "54a61483a11a326032c4dd4ddb7351d8e31cf7b9", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -584,6 +584,7 @@ symbols! {\n         custom_attribute,\n         custom_derive,\n         custom_inner_attributes,\n+        custom_mir,\n         custom_test_frameworks,\n         d,\n         d32,"}, {"sha": "e540e2f2a2192397be2a6571d008d4d6aaec3cd4", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -218,7 +218,7 @@ impl<'tcx> SymbolMangler<'tcx> {\n         let lifetimes = regions\n             .into_iter()\n             .map(|br| match br {\n-                ty::BrAnon(i) => i,\n+                ty::BrAnon(i, _) => i,\n                 _ => bug!(\"symbol_names: non-anonymized region `{:?}` in `{:?}`\", br, value),\n             })\n             .max()\n@@ -335,7 +335,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n \n             // Late-bound lifetimes use indices starting at 1,\n             // see `BinderLevel` for more details.\n-            ty::ReLateBound(debruijn, ty::BoundRegion { kind: ty::BrAnon(i), .. }) => {\n+            ty::ReLateBound(debruijn, ty::BoundRegion { kind: ty::BrAnon(i, _), .. }) => {\n                 let binder = &self.binders[self.binders.len() - 1 - debruijn.index()];\n                 let depth = binder.lifetime_depths.start + i;\n "}, {"sha": "0f6bbc323174cfb45dad1ffe4a388d1d323c2234", "filename": "compiler/rustc_target/src/spec/aarch64_apple_darwin.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,26 +1,25 @@\n+use super::apple_base::{macos_link_env_remove, macos_llvm_target, opts, Arch};\n use crate::spec::{FramePointer, SanitizerSet, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let arch = \"arm64\";\n-    let mut base = super::apple_base::opts(\"macos\", arch, \"\");\n+    let arch = Arch::Arm64;\n+    let mut base = opts(\"macos\", arch);\n     base.cpu = \"apple-a14\".into();\n     base.max_atomic_width = Some(128);\n \n     // FIXME: The leak sanitizer currently fails the tests, see #88132.\n     base.supported_sanitizers = SanitizerSet::ADDRESS | SanitizerSet::CFI | SanitizerSet::THREAD;\n \n-    base.link_env_remove.to_mut().extend(super::apple_base::macos_link_env_remove());\n-\n-    // Clang automatically chooses a more specific target based on\n-    // MACOSX_DEPLOYMENT_TARGET.  To enable cross-language LTO to work\n-    // correctly, we do too.\n-    let llvm_target = super::apple_base::macos_llvm_target(arch);\n+    base.link_env_remove.to_mut().extend(macos_link_env_remove());\n \n     Target {\n-        llvm_target: llvm_target.into(),\n+        // Clang automatically chooses a more specific target based on\n+        // MACOSX_DEPLOYMENT_TARGET.  To enable cross-language LTO to work\n+        // correctly, we do too.\n+        llvm_target: macos_llvm_target(arch).into(),\n         pointer_width: 64,\n         data_layout: \"e-m:o-i64:64-i128:128-n32:64-S128\".into(),\n-        arch: \"aarch64\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             mcount: \"\\u{1}mcount\".into(),\n             frame_pointer: FramePointer::NonLeaf,"}, {"sha": "b5f9eb1259dace3eaa02136daa9641416dc789aa", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,19 +1,17 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{ios_llvm_target, opts, Arch};\n use crate::spec::{FramePointer, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    // Clang automatically chooses a more specific target based on\n-    // IPHONEOS_DEPLOYMENT_TARGET.\n-    // This is required for the target to pick the right\n-    // MACH-O commands, so we do too.\n-    let arch = \"arm64\";\n-    let llvm_target = super::apple_base::ios_llvm_target(arch);\n-\n+    let arch = Arch::Arm64;\n     Target {\n-        llvm_target: llvm_target.into(),\n+        // Clang automatically chooses a more specific target based on\n+        // IPHONEOS_DEPLOYMENT_TARGET.\n+        // This is required for the target to pick the right\n+        // MACH-O commands, so we do too.\n+        llvm_target: ios_llvm_target(arch).into(),\n         pointer_width: 64,\n         data_layout: \"e-m:o-i64:64-i128:128-n32:64-S128\".into(),\n-        arch: \"aarch64\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             features: \"+neon,+fp-armv8,+apple-a7\".into(),\n             max_atomic_width: Some(128),\n@@ -30,7 +28,7 @@ pub fn target() -> Target {\n                 darwinpcs\\0\\\n                 -Os\\0\"\n                 .into(),\n-            ..opts(\"ios\", Arch::Arm64)\n+            ..opts(\"ios\", arch)\n         },\n     }\n }"}, {"sha": "0009972cf425693c9134e84e5b1cf5e786d54a06", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios_macabi.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,17 +1,18 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{opts, Arch};\n use crate::spec::{Cc, FramePointer, LinkerFlavor, Lld, Target, TargetOptions};\n \n pub fn target() -> Target {\n     let llvm_target = \"arm64-apple-ios14.0-macabi\";\n \n-    let mut base = opts(\"ios\", Arch::Arm64_macabi);\n+    let arch = Arch::Arm64_macabi;\n+    let mut base = opts(\"ios\", arch);\n     base.add_pre_link_args(LinkerFlavor::Darwin(Cc::Yes, Lld::No), &[\"-target\", llvm_target]);\n \n     Target {\n         llvm_target: llvm_target.into(),\n         pointer_width: 64,\n         data_layout: \"e-m:o-i64:64-i128:128-n32:64-S128\".into(),\n-        arch: \"aarch64\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             features: \"+neon,+fp-armv8,+apple-a12\".into(),\n             max_atomic_width: Some(128),"}, {"sha": "3374755e2dd8b9631b622e31428739b995f434b3", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios_sim.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_sim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_sim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_sim.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,21 +1,17 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{ios_sim_llvm_target, opts, Arch};\n use crate::spec::{FramePointer, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = opts(\"ios\", Arch::Arm64_sim);\n-\n-    // Clang automatically chooses a more specific target based on\n-    // IPHONEOS_DEPLOYMENT_TARGET.\n-    // This is required for the simulator target to pick the right\n-    // MACH-O commands, so we do too.\n-    let arch = \"arm64\";\n-    let llvm_target = super::apple_base::ios_sim_llvm_target(arch);\n-\n+    let arch = Arch::Arm64_sim;\n     Target {\n-        llvm_target: llvm_target.into(),\n+        // Clang automatically chooses a more specific target based on\n+        // IPHONEOS_DEPLOYMENT_TARGET.\n+        // This is required for the simulator target to pick the right\n+        // MACH-O commands, so we do too.\n+        llvm_target: ios_sim_llvm_target(arch).into(),\n         pointer_width: 64,\n         data_layout: \"e-m:o-i64:64-i128:128-n32:64-S128\".into(),\n-        arch: \"aarch64\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             features: \"+neon,+fp-armv8,+apple-a7\".into(),\n             max_atomic_width: Some(128),\n@@ -32,7 +28,7 @@ pub fn target() -> Target {\n                 darwinpcs\\0\\\n                 -Os\\0\"\n                 .into(),\n-            ..base\n+            ..opts(\"ios\", arch)\n         },\n     }\n }"}, {"sha": "bb7c39ff26bdf5eede75e1cddda83cef7cbb8ff5", "filename": "compiler/rustc_target/src/spec/aarch64_apple_tvos.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_tvos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_tvos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_tvos.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,18 +1,19 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{opts, Arch};\n use crate::spec::{FramePointer, Target, TargetOptions};\n \n pub fn target() -> Target {\n+    let arch = Arch::Arm64;\n     Target {\n         llvm_target: \"arm64-apple-tvos\".into(),\n         pointer_width: 64,\n         data_layout: \"e-m:o-i64:64-i128:128-n32:64-S128\".into(),\n-        arch: \"aarch64\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             features: \"+neon,+fp-armv8,+apple-a7\".into(),\n             max_atomic_width: Some(128),\n             forces_embed_bitcode: true,\n             frame_pointer: FramePointer::NonLeaf,\n-            ..opts(\"tvos\", Arch::Arm64)\n+            ..opts(\"tvos\", arch)\n         },\n     }\n }"}, {"sha": "e4af4127c2223114f98a2442942e4eac3fab40b8", "filename": "compiler/rustc_target/src/spec/aarch64_apple_watchos_sim.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_watchos_sim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_watchos_sim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_watchos_sim.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,21 +1,17 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{opts, watchos_sim_llvm_target, Arch};\n use crate::spec::{FramePointer, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = opts(\"watchos\", Arch::Arm64_sim);\n-\n-    // Clang automatically chooses a more specific target based on\n-    // WATCHOS_DEPLOYMENT_TARGET.\n-    // This is required for the simulator target to pick the right\n-    // MACH-O commands, so we do too.\n-    let arch = \"arm64\";\n-    let llvm_target = super::apple_base::watchos_sim_llvm_target(arch);\n-\n+    let arch = Arch::Arm64_sim;\n     Target {\n-        llvm_target: llvm_target.into(),\n+        // Clang automatically chooses a more specific target based on\n+        // WATCHOS_DEPLOYMENT_TARGET.\n+        // This is required for the simulator target to pick the right\n+        // MACH-O commands, so we do too.\n+        llvm_target: watchos_sim_llvm_target(arch).into(),\n         pointer_width: 64,\n         data_layout: \"e-m:o-i64:64-i128:128-n32:64-S128\".into(),\n-        arch: \"aarch64\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             features: \"+neon,+fp-armv8,+apple-a7\".into(),\n             max_atomic_width: Some(128),\n@@ -32,7 +28,7 @@ pub fn target() -> Target {\n                 darwinpcs\\0\\\n                 -Os\\0\"\n                 .into(),\n-            ..base\n+            ..opts(\"watchos\", arch)\n         },\n     }\n }"}, {"sha": "23c826cb1bda2922558bc2859845a16ec52c26cf", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 107, "deletions": 18, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -3,7 +3,88 @@ use std::{borrow::Cow, env};\n use crate::spec::{cvs, Cc, DebuginfoKind, FramePointer, LinkArgs};\n use crate::spec::{LinkerFlavor, Lld, SplitDebuginfo, StaticCow, TargetOptions};\n \n-fn pre_link_args(os: &'static str, arch: &'static str, abi: &'static str) -> LinkArgs {\n+#[cfg(test)]\n+#[path = \"apple/tests.rs\"]\n+mod tests;\n+\n+use Arch::*;\n+#[allow(non_camel_case_types)]\n+#[derive(Copy, Clone)]\n+pub enum Arch {\n+    Armv7,\n+    Armv7k,\n+    Armv7s,\n+    Arm64,\n+    Arm64_32,\n+    I386,\n+    I686,\n+    X86_64,\n+    X86_64_sim,\n+    X86_64_macabi,\n+    Arm64_macabi,\n+    Arm64_sim,\n+}\n+\n+impl Arch {\n+    pub fn target_name(self) -> &'static str {\n+        match self {\n+            Armv7 => \"armv7\",\n+            Armv7k => \"armv7k\",\n+            Armv7s => \"armv7s\",\n+            Arm64 | Arm64_macabi | Arm64_sim => \"arm64\",\n+            Arm64_32 => \"arm64_32\",\n+            I386 => \"i386\",\n+            I686 => \"i686\",\n+            X86_64 | X86_64_sim | X86_64_macabi => \"x86_64\",\n+        }\n+    }\n+\n+    pub fn target_arch(self) -> Cow<'static, str> {\n+        Cow::Borrowed(match self {\n+            Armv7 | Armv7k | Armv7s => \"arm\",\n+            Arm64 | Arm64_32 | Arm64_macabi | Arm64_sim => \"aarch64\",\n+            I386 | I686 => \"x86\",\n+            X86_64 | X86_64_sim | X86_64_macabi => \"x86_64\",\n+        })\n+    }\n+\n+    fn target_abi(self) -> &'static str {\n+        match self {\n+            Armv7 | Armv7k | Armv7s | Arm64 | Arm64_32 | I386 | I686 | X86_64 => \"\",\n+            X86_64_macabi | Arm64_macabi => \"macabi\",\n+            // x86_64-apple-ios is a simulator target, even though it isn't\n+            // declared that way in the target like the other ones...\n+            Arm64_sim | X86_64_sim => \"sim\",\n+        }\n+    }\n+\n+    fn target_cpu(self) -> &'static str {\n+        match self {\n+            Armv7 => \"cortex-a8\", // iOS7 is supported on iPhone 4 and higher\n+            Armv7k => \"cortex-a8\",\n+            Armv7s => \"cortex-a9\",\n+            Arm64 => \"apple-a7\",\n+            Arm64_32 => \"apple-s4\",\n+            I386 | I686 => \"yonah\",\n+            X86_64 | X86_64_sim => \"core2\",\n+            X86_64_macabi => \"core2\",\n+            Arm64_macabi => \"apple-a12\",\n+            Arm64_sim => \"apple-a12\",\n+        }\n+    }\n+\n+    fn link_env_remove(self) -> StaticCow<[StaticCow<str>]> {\n+        match self {\n+            Armv7 | Armv7k | Armv7s | Arm64 | Arm64_32 | I386 | I686 | X86_64 | X86_64_sim\n+            | Arm64_sim => {\n+                cvs![\"MACOSX_DEPLOYMENT_TARGET\"]\n+            }\n+            X86_64_macabi | Arm64_macabi => cvs![\"IPHONEOS_DEPLOYMENT_TARGET\"],\n+        }\n+    }\n+}\n+\n+fn pre_link_args(os: &'static str, arch: Arch, abi: &'static str) -> LinkArgs {\n     let platform_name: StaticCow<str> = match abi {\n         \"sim\" => format!(\"{}-simulator\", os).into(),\n         \"macabi\" => \"mac-catalyst\".into(),\n@@ -19,6 +100,8 @@ fn pre_link_args(os: &'static str, arch: &'static str, abi: &'static str) -> Lin\n     }\n     .into();\n \n+    let arch = arch.target_name();\n+\n     let mut args = TargetOptions::link_args(\n         LinkerFlavor::Darwin(Cc::No, Lld::No),\n         &[\"-arch\", arch, \"-platform_version\"],\n@@ -35,24 +118,29 @@ fn pre_link_args(os: &'static str, arch: &'static str, abi: &'static str) -> Lin\n     args\n }\n \n-pub fn opts(os: &'static str, arch: &'static str, abi: &'static str) -> TargetOptions {\n-    // ELF TLS is only available in macOS 10.7+. If you try to compile for 10.6\n+pub fn opts(os: &'static str, arch: Arch) -> TargetOptions {\n+    // Static TLS is only available in macOS 10.7+. If you try to compile for 10.6\n     // either the linker will complain if it is used or the binary will end up\n     // segfaulting at runtime when run on 10.6. Rust by default supports macOS\n     // 10.7+, but there is a standard environment variable,\n     // MACOSX_DEPLOYMENT_TARGET, which is used to signal targeting older\n     // versions of macOS. For example compiling on 10.10 with\n     // MACOSX_DEPLOYMENT_TARGET set to 10.6 will cause the linker to generate\n-    // warnings about the usage of ELF TLS.\n+    // warnings about the usage of static TLS.\n     //\n-    // Here we detect what version is being requested, defaulting to 10.7. ELF\n+    // Here we detect what version is being requested, defaulting to 10.7. Static\n     // TLS is flagged as enabled if it looks to be supported. The architecture\n     // only matters for default deployment target which is 11.0 for ARM64 and\n     // 10.7 for everything else.\n-    let has_thread_local = macos_deployment_target(\"x86_64\") >= (10, 7);\n+    let has_thread_local = os == \"macos\" && macos_deployment_target(Arch::X86_64) >= (10, 7);\n+\n+    let abi = arch.target_abi();\n \n     TargetOptions {\n+        abi: abi.into(),\n         os: os.into(),\n+        cpu: arch.target_cpu().into(),\n+        link_env_remove: arch.link_env_remove(),\n         vendor: \"apple\".into(),\n         linker_flavor: LinkerFlavor::Darwin(Cc::Yes, Lld::No),\n         // macOS has -dead_strip, which doesn't rely on function_sections\n@@ -103,23 +191,24 @@ fn deployment_target(var_name: &str) -> Option<(u32, u32)> {\n         .and_then(|(a, b)| a.parse::<u32>().and_then(|a| b.parse::<u32>().map(|b| (a, b))).ok())\n }\n \n-fn macos_default_deployment_target(arch: &str) -> (u32, u32) {\n-    if arch == \"arm64\" { (11, 0) } else { (10, 7) }\n+fn macos_default_deployment_target(arch: Arch) -> (u32, u32) {\n+    // Note: Arm64_sim is not included since macOS has no simulator.\n+    if matches!(arch, Arm64 | Arm64_macabi) { (11, 0) } else { (10, 7) }\n }\n \n-fn macos_deployment_target(arch: &str) -> (u32, u32) {\n+fn macos_deployment_target(arch: Arch) -> (u32, u32) {\n     deployment_target(\"MACOSX_DEPLOYMENT_TARGET\")\n         .unwrap_or_else(|| macos_default_deployment_target(arch))\n }\n \n-fn macos_lld_platform_version(arch: &str) -> String {\n+fn macos_lld_platform_version(arch: Arch) -> String {\n     let (major, minor) = macos_deployment_target(arch);\n     format!(\"{}.{}\", major, minor)\n }\n \n-pub fn macos_llvm_target(arch: &str) -> String {\n+pub fn macos_llvm_target(arch: Arch) -> String {\n     let (major, minor) = macos_deployment_target(arch);\n-    format!(\"{}-apple-macosx{}.{}.0\", arch, major, minor)\n+    format!(\"{}-apple-macosx{}.{}.0\", arch.target_name(), major, minor)\n }\n \n pub fn macos_link_env_remove() -> Vec<StaticCow<str>> {\n@@ -142,25 +231,25 @@ fn ios_deployment_target() -> (u32, u32) {\n     deployment_target(\"IPHONEOS_DEPLOYMENT_TARGET\").unwrap_or((7, 0))\n }\n \n-pub fn ios_llvm_target(arch: &str) -> String {\n+pub fn ios_llvm_target(arch: Arch) -> String {\n     // Modern iOS tooling extracts information about deployment target\n     // from LC_BUILD_VERSION. This load command will only be emitted when\n     // we build with a version specific `llvm_target`, with the version\n     // set high enough. Luckily one LC_BUILD_VERSION is enough, for Xcode\n     // to pick it up (since std and core are still built with the fallback\n     // of version 7.0 and hence emit the old LC_IPHONE_MIN_VERSION).\n     let (major, minor) = ios_deployment_target();\n-    format!(\"{}-apple-ios{}.{}.0\", arch, major, minor)\n+    format!(\"{}-apple-ios{}.{}.0\", arch.target_name(), major, minor)\n }\n \n fn ios_lld_platform_version() -> String {\n     let (major, minor) = ios_deployment_target();\n     format!(\"{}.{}\", major, minor)\n }\n \n-pub fn ios_sim_llvm_target(arch: &str) -> String {\n+pub fn ios_sim_llvm_target(arch: Arch) -> String {\n     let (major, minor) = ios_deployment_target();\n-    format!(\"{}-apple-ios{}.{}.0-simulator\", arch, major, minor)\n+    format!(\"{}-apple-ios{}.{}.0-simulator\", arch.target_name(), major, minor)\n }\n \n fn tvos_deployment_target() -> (u32, u32) {\n@@ -181,7 +270,7 @@ fn watchos_lld_platform_version() -> String {\n     format!(\"{}.{}\", major, minor)\n }\n \n-pub fn watchos_sim_llvm_target(arch: &str) -> String {\n+pub fn watchos_sim_llvm_target(arch: Arch) -> String {\n     let (major, minor) = watchos_deployment_target();\n-    format!(\"{}-apple-watchos{}.{}.0-simulator\", arch, major, minor)\n+    format!(\"{}-apple-watchos{}.{}.0-simulator\", arch.target_name(), major, minor)\n }"}, {"sha": "148031b1569768eca63e872d67ae5f0ff00906da", "filename": "compiler/rustc_target/src/spec/apple_sdk_base.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/71c3ecf31f1adf920d2cfd577392b8a45ac9c808/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c3ecf31f1adf920d2cfd577392b8a45ac9c808/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs?ref=71c3ecf31f1adf920d2cfd577392b8a45ac9c808", "patch": "@@ -1,81 +0,0 @@\n-use crate::spec::{cvs, TargetOptions};\n-use std::borrow::Cow;\n-\n-#[cfg(test)]\n-#[path = \"apple/tests.rs\"]\n-mod tests;\n-\n-use Arch::*;\n-#[allow(non_camel_case_types)]\n-#[derive(Copy, Clone)]\n-pub enum Arch {\n-    Armv7,\n-    Armv7k,\n-    Armv7s,\n-    Arm64,\n-    Arm64_32,\n-    I386,\n-    #[allow(dead_code)] // Some targets don't use this enum...\n-    X86_64,\n-    X86_64_sim,\n-    X86_64_macabi,\n-    Arm64_macabi,\n-    Arm64_sim,\n-}\n-\n-fn target_arch_name(arch: Arch) -> &'static str {\n-    match arch {\n-        Armv7 => \"armv7\",\n-        Armv7k => \"armv7k\",\n-        Armv7s => \"armv7s\",\n-        Arm64 | Arm64_macabi | Arm64_sim => \"arm64\",\n-        Arm64_32 => \"arm64_32\",\n-        I386 => \"i386\",\n-        X86_64 | X86_64_sim | X86_64_macabi => \"x86_64\",\n-    }\n-}\n-\n-fn target_abi(arch: Arch) -> &'static str {\n-    match arch {\n-        Armv7 | Armv7k | Armv7s | Arm64 | Arm64_32 | I386 | X86_64 => \"\",\n-        X86_64_macabi | Arm64_macabi => \"macabi\",\n-        // x86_64-apple-ios is a simulator target, even though it isn't\n-        // declared that way in the target like the other ones...\n-        Arm64_sim | X86_64_sim => \"sim\",\n-    }\n-}\n-\n-fn target_cpu(arch: Arch) -> &'static str {\n-    match arch {\n-        Armv7 => \"cortex-a8\", // iOS7 is supported on iPhone 4 and higher\n-        Armv7k => \"cortex-a8\",\n-        Armv7s => \"cortex-a9\",\n-        Arm64 => \"apple-a7\",\n-        Arm64_32 => \"apple-s4\",\n-        I386 => \"yonah\",\n-        X86_64 | X86_64_sim => \"core2\",\n-        X86_64_macabi => \"core2\",\n-        Arm64_macabi => \"apple-a12\",\n-        Arm64_sim => \"apple-a12\",\n-    }\n-}\n-\n-fn link_env_remove(arch: Arch) -> Cow<'static, [Cow<'static, str>]> {\n-    match arch {\n-        Armv7 | Armv7k | Armv7s | Arm64 | Arm64_32 | I386 | X86_64 | X86_64_sim | Arm64_sim => {\n-            cvs![\"MACOSX_DEPLOYMENT_TARGET\"]\n-        }\n-        X86_64_macabi | Arm64_macabi => cvs![\"IPHONEOS_DEPLOYMENT_TARGET\"],\n-    }\n-}\n-\n-pub fn opts(os: &'static str, arch: Arch) -> TargetOptions {\n-    let abi = target_abi(arch);\n-    TargetOptions {\n-        abi: abi.into(),\n-        cpu: target_cpu(arch).into(),\n-        link_env_remove: link_env_remove(arch),\n-        has_thread_local: false,\n-        ..super::apple_base::opts(os, target_arch_name(arch), abi)\n-    }\n-}"}, {"sha": "2cf2cbc7510009dec797f7137eabca3bb741bf4e", "filename": "compiler/rustc_target/src/spec/arm64_32_apple_watchos.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm64_32_apple_watchos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm64_32_apple_watchos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farm64_32_apple_watchos.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,4 +1,4 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{opts, Arch};\n use crate::spec::{Target, TargetOptions};\n \n pub fn target() -> Target {"}, {"sha": "3259c854791ce1849c465e03dbf691038c6b18f4", "filename": "compiler/rustc_target/src/spec/armv7_apple_ios.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_apple_ios.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,18 +1,21 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{ios_llvm_target, opts, Arch};\n use crate::spec::{Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let llvm_target = super::apple_base::ios_llvm_target(\"armv7\");\n-\n+    let arch = Arch::Armv7;\n     Target {\n-        llvm_target: llvm_target.into(),\n+        // Clang automatically chooses a more specific target based on\n+        // IPHONEOS_DEPLOYMENT_TARGET.\n+        // This is required for the target to pick the right\n+        // MACH-O commands, so we do too.\n+        llvm_target: ios_llvm_target(arch).into(),\n         pointer_width: 32,\n         data_layout: \"e-m:o-p:32:32-Fi8-f64:32:64-v64:32:64-v128:32:128-a:0:32-n32-S32\".into(),\n-        arch: \"arm\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             features: \"+v7,+vfp3,+neon\".into(),\n             max_atomic_width: Some(64),\n-            ..opts(\"ios\", Arch::Armv7)\n+            ..opts(\"ios\", arch)\n         },\n     }\n }"}, {"sha": "45ead8d65aba9919c6dc65d742b860c308d30c82", "filename": "compiler/rustc_target/src/spec/armv7k_apple_watchos.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7k_apple_watchos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7k_apple_watchos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7k_apple_watchos.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,13 +1,13 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{opts, Arch};\n use crate::spec::{Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = opts(\"watchos\", Arch::Armv7k);\n+    let arch = Arch::Armv7k;\n     Target {\n         llvm_target: \"armv7k-apple-watchos\".into(),\n         pointer_width: 32,\n         data_layout: \"e-m:o-p:32:32-Fi8-i64:64-a:0:32-n32-S128\".into(),\n-        arch: \"arm\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             features: \"+v7,+vfp4,+neon\".into(),\n             max_atomic_width: Some(64),\n@@ -22,7 +22,7 @@ pub fn target() -> Target {\n                 darwinpcs\\0\\\n                 -Os\\0\"\n                 .into(),\n-            ..base\n+            ..opts(\"watchos\", arch)\n         },\n     }\n }"}, {"sha": "be4bc6758443ec7ee51ea2c1fd67bde666581650", "filename": "compiler/rustc_target/src/spec/armv7s_apple_ios.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7s_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7s_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7s_apple_ios.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,16 +1,17 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{opts, Arch};\n use crate::spec::{Target, TargetOptions};\n \n pub fn target() -> Target {\n+    let arch = Arch::Armv7s;\n     Target {\n         llvm_target: \"armv7s-apple-ios\".into(),\n         pointer_width: 32,\n         data_layout: \"e-m:o-p:32:32-Fi8-f64:32:64-v64:32:64-v128:32:128-a:0:32-n32-S32\".into(),\n-        arch: \"arm\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             features: \"+v7,+vfp4,+neon\".into(),\n             max_atomic_width: Some(64),\n-            ..opts(\"ios\", Arch::Armv7s)\n+            ..opts(\"ios\", arch)\n         },\n     }\n }"}, {"sha": "5819981612e84a8a322ece52007d089f333f7a7d", "filename": "compiler/rustc_target/src/spec/i386_apple_ios.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi386_apple_ios.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,21 +1,23 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{ios_sim_llvm_target, opts, Arch};\n use crate::spec::{StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = opts(\"ios\", Arch::I386);\n-    let llvm_target = super::apple_base::ios_sim_llvm_target(\"i386\");\n-\n+    let arch = Arch::I386;\n     Target {\n-        llvm_target: llvm_target.into(),\n+        // Clang automatically chooses a more specific target based on\n+        // IPHONEOS_DEPLOYMENT_TARGET.\n+        // This is required for the target to pick the right\n+        // MACH-O commands, so we do too.\n+        llvm_target: ios_sim_llvm_target(arch).into(),\n         pointer_width: 32,\n         data_layout: \"e-m:o-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:128-n8:16:32-S128\"\n             .into(),\n-        arch: \"x86\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             max_atomic_width: Some(64),\n             stack_probes: StackProbeType::X86,\n-            ..base\n+            ..opts(\"ios\", arch)\n         },\n     }\n }"}, {"sha": "8b968af5eccff330a51e7aef34044de6b6b3ef82", "filename": "compiler/rustc_target/src/spec/i686_apple_darwin.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_apple_darwin.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,28 +1,28 @@\n+use super::apple_base::{macos_link_env_remove, macos_llvm_target, opts, Arch};\n use crate::spec::{Cc, FramePointer, LinkerFlavor, Lld, StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    // ld64 only understand i386 and not i686\n-    let mut base = super::apple_base::opts(\"macos\", \"i386\", \"\");\n-    base.cpu = \"yonah\".into();\n+    // ld64 only understands i386 and not i686\n+    let arch = Arch::I386;\n+    let mut base = opts(\"macos\", arch);\n     base.max_atomic_width = Some(64);\n     base.add_pre_link_args(LinkerFlavor::Darwin(Cc::Yes, Lld::No), &[\"-m32\"]);\n-    base.link_env_remove.to_mut().extend(super::apple_base::macos_link_env_remove());\n+    base.link_env_remove.to_mut().extend(macos_link_env_remove());\n     base.stack_probes = StackProbeType::X86;\n     base.frame_pointer = FramePointer::Always;\n \n-    // Clang automatically chooses a more specific target based on\n-    // MACOSX_DEPLOYMENT_TARGET.  To enable cross-language LTO to work\n-    // correctly, we do too.\n-    let arch = \"i686\";\n-    let llvm_target = super::apple_base::macos_llvm_target(&arch);\n-\n     Target {\n-        llvm_target: llvm_target.into(),\n+        // Clang automatically chooses a more specific target based on\n+        // MACOSX_DEPLOYMENT_TARGET.  To enable cross-language LTO to work\n+        // correctly, we do too.\n+        //\n+        // While ld64 doesn't understand i686, LLVM does.\n+        llvm_target: macos_llvm_target(Arch::I686).into(),\n         pointer_width: 32,\n         data_layout: \"e-m:o-p:32:32-p270:32:32-p271:32:32-p272:64:64-\\\n             f64:32:64-f80:128-n8:16:32-S128\"\n             .into(),\n-        arch: \"x86\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions { mcount: \"\\u{1}mcount\".into(), ..base },\n     }\n }"}, {"sha": "f41533a9548fe459aa0431e94a78ca210541d4af", "filename": "compiler/rustc_target/src/spec/linux_kernel_base.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/71c3ecf31f1adf920d2cfd577392b8a45ac9c808/compiler%2Frustc_target%2Fsrc%2Fspec%2Flinux_kernel_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c3ecf31f1adf920d2cfd577392b8a45ac9c808/compiler%2Frustc_target%2Fsrc%2Fspec%2Flinux_kernel_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Flinux_kernel_base.rs?ref=71c3ecf31f1adf920d2cfd577392b8a45ac9c808", "patch": "@@ -1,18 +0,0 @@\n-use crate::spec::TargetOptions;\n-use crate::spec::{FramePointer, PanicStrategy, RelocModel, RelroLevel, StackProbeType};\n-\n-pub fn opts() -> TargetOptions {\n-    TargetOptions {\n-        env: \"gnu\".into(),\n-        disable_redzone: true,\n-        panic_strategy: PanicStrategy::Abort,\n-        stack_probes: StackProbeType::X86,\n-        frame_pointer: FramePointer::Always,\n-        position_independent_executables: true,\n-        needs_plt: true,\n-        relro_level: RelroLevel::Full,\n-        relocation_model: RelocModel::Static,\n-\n-        ..Default::default()\n-    }\n-}"}, {"sha": "1bcb02ecb305356e7922f130e004b6a7e160219b", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -59,7 +59,6 @@ pub mod crt_objects;\n \n mod android_base;\n mod apple_base;\n-mod apple_sdk_base;\n mod avr_gnu_base;\n mod bpf_base;\n mod dragonfly_base;\n@@ -71,7 +70,6 @@ mod illumos_base;\n mod l4re_base;\n mod linux_base;\n mod linux_gnu_base;\n-mod linux_kernel_base;\n mod linux_musl_base;\n mod linux_uclibc_base;\n mod msvc_base;\n@@ -1003,7 +1001,7 @@ macro_rules! supported_targets {\n             $(\n                 #[test] // `#[test]`\n                 fn $module() {\n-                    tests_impl::test_target(super::$module::target(), $triple);\n+                    tests_impl::test_target(super::$module::target());\n                 }\n             )+\n         }\n@@ -1071,8 +1069,6 @@ supported_targets! {\n     (\"thumbv7neon-linux-androideabi\", thumbv7neon_linux_androideabi),\n     (\"aarch64-linux-android\", aarch64_linux_android),\n \n-    (\"x86_64-unknown-none-linuxkernel\", x86_64_unknown_none_linuxkernel),\n-\n     (\"aarch64-unknown-freebsd\", aarch64_unknown_freebsd),\n     (\"armv6-unknown-freebsd\", armv6_unknown_freebsd),\n     (\"armv7-unknown-freebsd\", armv7_unknown_freebsd),\n@@ -1941,8 +1937,10 @@ impl Target {\n             | PlatformIntrinsic\n             | Unadjusted\n             | Cdecl { .. }\n-            | EfiApi\n             | RustCold => true,\n+            EfiApi => {\n+                [\"arm\", \"aarch64\", \"riscv32\", \"riscv64\", \"x86\", \"x86_64\"].contains(&&self.arch[..])\n+            }\n             X86Interrupt => [\"x86\", \"x86_64\"].contains(&&self.arch[..]),\n             Aapcs { .. } => \"arm\" == self.arch,\n             CCmseNonSecureCall => [\"arm\", \"aarch64\"].contains(&&self.arch[..]),"}, {"sha": "8281bac10f88feba01ee04bd28bdbd3858bd34b8", "filename": "compiler/rustc_target/src/spec/riscv64gc_unknown_freebsd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_freebsd.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -4,7 +4,7 @@ pub fn target() -> Target {\n     Target {\n         llvm_target: \"riscv64-unknown-freebsd\".into(),\n         pointer_width: 64,\n-        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\".into(),\n+        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\".into(),\n         arch: \"riscv64\".into(),\n         options: TargetOptions {\n             code_model: Some(CodeModel::Medium),"}, {"sha": "90dccb28063dc955e7029939ca36d3f1a6429348", "filename": "compiler/rustc_target/src/spec/riscv64gc_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_linux_gnu.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -4,7 +4,7 @@ pub fn target() -> Target {\n     Target {\n         llvm_target: \"riscv64-unknown-linux-gnu\".into(),\n         pointer_width: 64,\n-        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\".into(),\n+        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\".into(),\n         arch: \"riscv64\".into(),\n         options: TargetOptions {\n             code_model: Some(CodeModel::Medium),"}, {"sha": "1a56c78e6852421e6eafd144d1835cccb4ec7edb", "filename": "compiler/rustc_target/src/spec/riscv64gc_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_linux_musl.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -4,7 +4,7 @@ pub fn target() -> Target {\n     Target {\n         llvm_target: \"riscv64-unknown-linux-musl\".into(),\n         pointer_width: 64,\n-        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\".into(),\n+        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\".into(),\n         arch: \"riscv64\".into(),\n         options: TargetOptions {\n             code_model: Some(CodeModel::Medium),"}, {"sha": "409b0b2696152305a411713bace7a52f22f9bd88", "filename": "compiler/rustc_target/src/spec/riscv64gc_unknown_none_elf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_none_elf.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -3,7 +3,7 @@ use crate::spec::{RelocModel, Target, TargetOptions};\n \n pub fn target() -> Target {\n     Target {\n-        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\".into(),\n+        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\".into(),\n         llvm_target: \"riscv64\".into(),\n         pointer_width: 64,\n         arch: \"riscv64\".into(),"}, {"sha": "ade9d77624bdb4840bff24c6768d54c323bfeaea", "filename": "compiler/rustc_target/src/spec/riscv64gc_unknown_openbsd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64gc_unknown_openbsd.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -4,7 +4,7 @@ pub fn target() -> Target {\n     Target {\n         llvm_target: \"riscv64-unknown-openbsd\".into(),\n         pointer_width: 64,\n-        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\".into(),\n+        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\".into(),\n         arch: \"riscv64\".into(),\n         options: TargetOptions {\n             code_model: Some(CodeModel::Medium),"}, {"sha": "87aba9171b41679976e92c0c7e1f517941b0965a", "filename": "compiler/rustc_target/src/spec/riscv64imac_unknown_none_elf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64imac_unknown_none_elf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64imac_unknown_none_elf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Friscv64imac_unknown_none_elf.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -3,7 +3,7 @@ use crate::spec::{RelocModel, Target, TargetOptions};\n \n pub fn target() -> Target {\n     Target {\n-        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n64-S128\".into(),\n+        data_layout: \"e-m:e-p:64:64-i64:64-i128:128-n32:64-S128\".into(),\n         llvm_target: \"riscv64\".into(),\n         pointer_width: 64,\n         arch: \"riscv64\".into(),"}, {"sha": "e0ecf8037c3e59a4086582342b9a18342ae6a67c", "filename": "compiler/rustc_target/src/spec/tests/tests_impl.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Ftests%2Ftests_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Ftests%2Ftests_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Ftests%2Ftests_impl.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -2,15 +2,15 @@ use super::super::*;\n use std::assert_matches::assert_matches;\n \n // Test target self-consistency and JSON encoding/decoding roundtrip.\n-pub(super) fn test_target(mut target: Target, triple: &str) {\n+pub(super) fn test_target(mut target: Target) {\n     let recycled_target = Target::from_json(target.to_json()).map(|(j, _)| j);\n     target.update_to_cli();\n-    target.check_consistency(triple);\n+    target.check_consistency();\n     assert_eq!(recycled_target, Ok(target));\n }\n \n impl Target {\n-    fn check_consistency(&self, triple: &str) {\n+    fn check_consistency(&self) {\n         assert_eq!(self.is_like_osx, self.vendor == \"apple\");\n         assert_eq!(self.is_like_solaris, self.os == \"solaris\" || self.os == \"illumos\");\n         assert_eq!(self.is_like_windows, self.os == \"windows\" || self.os == \"uefi\");\n@@ -129,8 +129,7 @@ impl Target {\n         if self.dynamic_linking && !(self.is_like_wasm && self.os != \"emscripten\") {\n             assert_eq!(self.relocation_model, RelocModel::Pic);\n         }\n-        // PIEs are supported but not enabled by default with linuxkernel target.\n-        if self.position_independent_executables && !triple.ends_with(\"-linuxkernel\") {\n+        if self.position_independent_executables {\n             assert_eq!(self.relocation_model, RelocModel::Pic);\n         }\n         // The UEFI targets do not support dynamic linking but still require PIC (#101377)."}, {"sha": "cada28652f98a79db8df2ac514a8fac9d22bc13a", "filename": "compiler/rustc_target/src/spec/windows_gnullvm_base.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnullvm_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnullvm_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnullvm_base.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,4 +1,5 @@\n-use crate::spec::{cvs, Cc, LinkerFlavor, Lld, TargetOptions};\n+use crate::spec::{cvs, Cc, DebuginfoKind, LinkerFlavor, Lld, SplitDebuginfo, TargetOptions};\n+use std::borrow::Cow;\n \n pub fn opts() -> TargetOptions {\n     // We cannot use `-nodefaultlibs` because compiler-rt has to be passed\n@@ -36,7 +37,10 @@ pub fn opts() -> TargetOptions {\n         eh_frame_header: false,\n         no_default_libraries: false,\n         has_thread_local: true,\n-\n+        // FIXME(davidtwco): Support Split DWARF on Windows GNU - may require LLVM changes to\n+        // output DWO, despite using DWARF, doesn't use ELF..\n+        debuginfo_kind: DebuginfoKind::Pdb,\n+        supported_split_debuginfo: Cow::Borrowed(&[SplitDebuginfo::Off]),\n         ..Default::default()\n     }\n }"}, {"sha": "c053031612ce5369575731e710bdcfd395b76116", "filename": "compiler/rustc_target/src/spec/x86_64_apple_darwin.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_darwin.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,29 +1,27 @@\n+use super::apple_base::{macos_link_env_remove, macos_llvm_target, opts, Arch};\n use crate::spec::{Cc, FramePointer, LinkerFlavor, Lld, SanitizerSet};\n use crate::spec::{StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let arch = \"x86_64\";\n-    let mut base = super::apple_base::opts(\"macos\", arch, \"\");\n-    base.cpu = \"core2\".into();\n-    base.max_atomic_width = Some(128); // core2 support cmpxchg16b\n+    let arch = Arch::X86_64;\n+    let mut base = opts(\"macos\", arch);\n+    base.max_atomic_width = Some(128); // core2 supports cmpxchg16b\n     base.frame_pointer = FramePointer::Always;\n     base.add_pre_link_args(LinkerFlavor::Darwin(Cc::Yes, Lld::No), &[\"-m64\"]);\n-    base.link_env_remove.to_mut().extend(super::apple_base::macos_link_env_remove());\n+    base.link_env_remove.to_mut().extend(macos_link_env_remove());\n     base.stack_probes = StackProbeType::X86;\n     base.supported_sanitizers =\n         SanitizerSet::ADDRESS | SanitizerSet::CFI | SanitizerSet::LEAK | SanitizerSet::THREAD;\n \n-    // Clang automatically chooses a more specific target based on\n-    // MACOSX_DEPLOYMENT_TARGET.  To enable cross-language LTO to work\n-    // correctly, we do too.\n-    let llvm_target = super::apple_base::macos_llvm_target(&arch);\n-\n     Target {\n-        llvm_target: llvm_target.into(),\n+        // Clang automatically chooses a more specific target based on\n+        // MACOSX_DEPLOYMENT_TARGET.  To enable cross-language LTO to work\n+        // correctly, we do too.\n+        llvm_target: macos_llvm_target(arch).into(),\n         pointer_width: 64,\n         data_layout: \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n             .into(),\n-        arch: arch.into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions { mcount: \"\\u{1}mcount\".into(), ..base },\n     }\n }"}, {"sha": "fbd3ebd4d0431eba64044605b1d8b8a9beba7640", "filename": "compiler/rustc_target/src/spec/x86_64_apple_ios.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,20 +1,18 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{ios_sim_llvm_target, opts, Arch};\n use crate::spec::{StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = opts(\"ios\", Arch::X86_64_sim);\n-    let llvm_target = super::apple_base::ios_sim_llvm_target(\"x86_64\");\n-\n+    let arch = Arch::X86_64_sim;\n     Target {\n-        llvm_target: llvm_target.into(),\n+        llvm_target: ios_sim_llvm_target(arch).into(),\n         pointer_width: 64,\n         data_layout: \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n             .into(),\n-        arch: \"x86_64\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             max_atomic_width: Some(64),\n             stack_probes: StackProbeType::X86,\n-            ..base\n+            ..opts(\"ios\", arch)\n         },\n     }\n }"}, {"sha": "0f3f8519963778d172d4ef5b164c100d71da2139", "filename": "compiler/rustc_target/src/spec/x86_64_apple_ios_macabi.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,18 +1,19 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{opts, Arch};\n use crate::spec::{Cc, LinkerFlavor, Lld, StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n     let llvm_target = \"x86_64-apple-ios13.0-macabi\";\n \n-    let mut base = opts(\"ios\", Arch::X86_64_macabi);\n+    let arch = Arch::X86_64_macabi;\n+    let mut base = opts(\"ios\", arch);\n     base.add_pre_link_args(LinkerFlavor::Darwin(Cc::Yes, Lld::No), &[\"-target\", llvm_target]);\n \n     Target {\n         llvm_target: llvm_target.into(),\n         pointer_width: 64,\n         data_layout: \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n             .into(),\n-        arch: \"x86_64\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             max_atomic_width: Some(64),\n             stack_probes: StackProbeType::X86,"}, {"sha": "550ce0b9ce577e0584a020d92a42d186ea9d2974", "filename": "compiler/rustc_target/src/spec/x86_64_apple_tvos.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_tvos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_tvos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_tvos.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,17 +1,17 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{opts, Arch};\n use crate::spec::{StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = opts(\"tvos\", Arch::X86_64_sim);\n+    let arch = Arch::X86_64_sim;\n     Target {\n         llvm_target: \"x86_64-apple-tvos\".into(),\n         pointer_width: 64,\n         data_layout: \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\".into(),\n-        arch: \"x86_64\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             max_atomic_width: Some(64),\n             stack_probes: StackProbeType::X86,\n-            ..base\n+            ..opts(\"tvos\", arch)\n         },\n     }\n }"}, {"sha": "75ce02cba1de0623be381ab2b4b396860b69b23a", "filename": "compiler/rustc_target/src/spec/x86_64_apple_watchos_sim.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_watchos_sim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_watchos_sim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_watchos_sim.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,18 +1,14 @@\n-use super::apple_sdk_base::{opts, Arch};\n+use super::apple_base::{opts, watchos_sim_llvm_target, Arch};\n use crate::spec::{StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let base = opts(\"watchos\", Arch::X86_64_sim);\n-\n-    let arch = \"x86_64\";\n-    let llvm_target = super::apple_base::watchos_sim_llvm_target(arch);\n-\n+    let arch = Arch::X86_64_sim;\n     Target {\n-        llvm_target: llvm_target.into(),\n+        llvm_target: watchos_sim_llvm_target(arch).into(),\n         pointer_width: 64,\n         data_layout: \"e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n             .into(),\n-        arch: \"x86_64\".into(),\n+        arch: arch.target_arch(),\n         options: TargetOptions {\n             max_atomic_width: Some(64),\n             stack_probes: StackProbeType::X86,\n@@ -28,7 +24,7 @@ pub fn target() -> Target {\n                 darwinpcs\\0\\\n                 -Os\\0\"\n                 .into(),\n-            ..base\n+            ..opts(\"watchos\", arch)\n         },\n     }\n }"}, {"sha": "ebd9636ff5102094a7df96f5f1327d842f28e64e", "filename": "compiler/rustc_target/src/spec/x86_64_unknown_none_linuxkernel.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/71c3ecf31f1adf920d2cfd577392b8a45ac9c808/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none_linuxkernel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c3ecf31f1adf920d2cfd577392b8a45ac9c808/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none_linuxkernel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_unknown_none_linuxkernel.rs?ref=71c3ecf31f1adf920d2cfd577392b8a45ac9c808", "patch": "@@ -1,28 +0,0 @@\n-// This defines the amd64 target for the Linux Kernel. See the linux-kernel-base module for\n-// generic Linux kernel options.\n-\n-use crate::spec::{Cc, CodeModel, LinkerFlavor, Lld, Target};\n-\n-pub fn target() -> Target {\n-    let mut base = super::linux_kernel_base::opts();\n-    base.cpu = \"x86-64\".into();\n-    base.max_atomic_width = Some(64);\n-    base.features =\n-        \"-mmx,-sse,-sse2,-sse3,-ssse3,-sse4.1,-sse4.2,-3dnow,-3dnowa,-avx,-avx2,+soft-float\".into();\n-    base.code_model = Some(CodeModel::Kernel);\n-    base.add_pre_link_args(LinkerFlavor::Gnu(Cc::Yes, Lld::No), &[\"-m64\"]);\n-\n-    Target {\n-        // FIXME: Some dispute, the linux-on-clang folks think this should use\n-        // \"Linux\". We disagree because running *on* Linux is nothing like\n-        // running *as\" linux, and historically the \"os\" component as has always\n-        // been used to mean the \"on\" part.\n-        llvm_target: \"x86_64-unknown-none-elf\".into(),\n-        pointer_width: 64,\n-        data_layout: \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\"\n-            .into(),\n-        arch: \"x86_64\".into(),\n-\n-        options: base,\n-    }\n-}"}, {"sha": "46ee2f35976a7be6dedee04590aa4fd7e4325d89", "filename": "compiler/rustc_trait_selection/src/autoderef.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -27,7 +27,6 @@ pub struct Autoderef<'a, 'tcx> {\n     // Meta infos:\n     infcx: &'a InferCtxt<'tcx>,\n     span: Span,\n-    overloaded_span: Span,\n     body_id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n \n@@ -99,12 +98,10 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         body_id: hir::HirId,\n         span: Span,\n         base_ty: Ty<'tcx>,\n-        overloaded_span: Span,\n     ) -> Autoderef<'a, 'tcx> {\n         Autoderef {\n             infcx,\n             span,\n-            overloaded_span,\n             body_id,\n             param_env,\n             state: AutoderefSnapshot {\n@@ -193,10 +190,6 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         self.span\n     }\n \n-    pub fn overloaded_span(&self) -> Span {\n-        self.overloaded_span\n-    }\n-\n     pub fn reached_recursion_limit(&self) -> bool {\n         self.state.reached_recursion_limit\n     }"}, {"sha": "0f2e22604dc7ed285a018370358a350c7e144d2d", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -93,6 +93,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n \n     /// Normalizes associated types in `value`, potentially returning\n     /// new obligations that must further be processed.\n+    #[instrument(level = \"debug\", skip(self, cause, param_env), ret)]\n     fn partially_normalize_associated_types_in<T>(\n         &self,\n         cause: ObligationCause<'tcx>,\n@@ -102,29 +103,20 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n         let mut selcx = traits::SelectionContext::new(self);\n         let traits::Normalized { value, obligations } =\n             traits::normalize(&mut selcx, param_env, cause, value);\n-        debug!(\n-            \"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n-            value, obligations\n-        );\n         InferOk { value, obligations }\n     }\n \n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn type_implements_trait(\n         &self,\n         trait_def_id: DefId,\n         ty: Ty<'tcx>,\n         params: SubstsRef<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> traits::EvaluationResult {\n-        debug!(\n-            \"type_implements_trait: trait_def_id={:?}, type={:?}, params={:?}, param_env={:?}\",\n-            trait_def_id, ty, params, param_env\n-        );\n-\n         let trait_ref =\n             ty::TraitRef { def_id: trait_def_id, substs: self.tcx.mk_substs_trait(ty, params) };\n "}, {"sha": "2dce18e2d3cad263dc36aeacd3469aa18c1ec9ac", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -10,7 +10,6 @@\n //!\n //! This API is completely unstable and subject to change.\n \n-#![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]"}, {"sha": "188f8bb7e2a58cd9815015a278b35dc4154936e9", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{PolyTraitRef, Region, RegionVid};\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n \n use std::collections::hash_map::Entry;\n use std::collections::VecDeque;\n@@ -27,8 +27,8 @@ pub enum RegionTarget<'tcx> {\n \n #[derive(Default, Debug, Clone)]\n pub struct RegionDeps<'tcx> {\n-    larger: FxHashSet<RegionTarget<'tcx>>,\n-    smaller: FxHashSet<RegionTarget<'tcx>>,\n+    larger: FxIndexSet<RegionTarget<'tcx>>,\n+    smaller: FxIndexSet<RegionTarget<'tcx>>,\n }\n \n pub enum AutoTraitResult<A> {\n@@ -266,7 +266,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         }));\n \n         let computed_preds = param_env.caller_bounds().iter();\n-        let mut user_computed_preds: FxHashSet<_> = user_env.caller_bounds().iter().collect();\n+        let mut user_computed_preds: FxIndexSet<_> = user_env.caller_bounds().iter().collect();\n \n         let mut new_env = param_env;\n         let dummy_cause = ObligationCause::dummy();\n@@ -389,7 +389,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n     /// not just one specific lifetime (e.g., `'static`).\n     fn add_user_pred(\n         &self,\n-        user_computed_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n+        user_computed_preds: &mut FxIndexSet<ty::Predicate<'tcx>>,\n         new_pred: ty::Predicate<'tcx>,\n     ) {\n         let mut should_add_new = true;\n@@ -585,7 +585,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         &self,\n         ty: Ty<'_>,\n         nested: impl Iterator<Item = Obligation<'tcx, ty::Predicate<'tcx>>>,\n-        computed_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n+        computed_preds: &mut FxIndexSet<ty::Predicate<'tcx>>,\n         fresh_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n         predicates: &mut VecDeque<ty::PolyTraitPredicate<'tcx>>,\n         select: &mut SelectionContext<'_, 'tcx>,"}, {"sha": "d32a990f182dc45409d12f6ea9077df6e1686626", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -14,15 +14,22 @@ pub struct FulfillmentContext<'tcx> {\n     obligations: FxIndexSet<PredicateObligation<'tcx>>,\n \n     relationships: FxHashMap<ty::TyVid, ty::FoundRelationships>,\n+\n+    usable_in_snapshot: bool,\n }\n \n impl FulfillmentContext<'_> {\n     pub(crate) fn new() -> Self {\n         FulfillmentContext {\n             obligations: FxIndexSet::default(),\n             relationships: FxHashMap::default(),\n+            usable_in_snapshot: false,\n         }\n     }\n+\n+    pub(crate) fn new_in_snapshot() -> Self {\n+        FulfillmentContext { usable_in_snapshot: true, ..Self::new() }\n+    }\n }\n \n impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n@@ -41,7 +48,9 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         infcx: &InferCtxt<'tcx>,\n         obligation: PredicateObligation<'tcx>,\n     ) {\n-        assert!(!infcx.is_in_snapshot());\n+        if !self.usable_in_snapshot {\n+            assert!(!infcx.is_in_snapshot());\n+        }\n         let obligation = infcx.resolve_vars_if_possible(obligation);\n \n         super::relationships::update(self, infcx, &obligation);\n@@ -72,7 +81,9 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     }\n \n     fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n-        assert!(!infcx.is_in_snapshot());\n+        if !self.usable_in_snapshot {\n+            assert!(!infcx.is_in_snapshot());\n+        }\n \n         let mut errors = Vec::new();\n         let mut next_round = FxIndexSet::default();"}, {"sha": "ae29c9f5617911245a6d733ddab8647f1d45204b", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -4,7 +4,7 @@ use std::fmt::Debug;\n use super::TraitEngine;\n use super::{ChalkFulfillmentContext, FulfillmentContext};\n use crate::infer::InferCtxtExt;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{\n@@ -38,7 +38,7 @@ impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n \n     fn new_in_snapshot(tcx: TyCtxt<'tcx>) -> Box<Self> {\n         if tcx.sess.opts.unstable_opts.chalk {\n-            Box::new(ChalkFulfillmentContext::new())\n+            Box::new(ChalkFulfillmentContext::new_in_snapshot())\n         } else {\n             Box::new(FulfillmentContext::new_in_snapshot())\n         }\n@@ -119,13 +119,10 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         expected: T,\n         actual: T,\n     ) -> Result<(), TypeError<'tcx>> {\n-        match self.infcx.at(cause, param_env).eq(expected, actual) {\n-            Ok(InferOk { obligations, value: () }) => {\n-                self.register_obligations(obligations);\n-                Ok(())\n-            }\n-            Err(e) => Err(e),\n-        }\n+        self.infcx\n+            .at(cause, param_env)\n+            .eq(expected, actual)\n+            .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n     pub fn sup<T: ToTrace<'tcx>>(\n@@ -144,6 +141,10 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub fn select_where_possible(&self) -> Vec<FulfillmentError<'tcx>> {\n+        self.engine.borrow_mut().select_where_possible(self.infcx)\n+    }\n+\n     pub fn select_all_or_error(&self) -> Vec<FulfillmentError<'tcx>> {\n         self.engine.borrow_mut().select_all_or_error(self.infcx)\n     }\n@@ -153,10 +154,10 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         span: Span,\n         def_id: LocalDefId,\n-    ) -> FxHashSet<Ty<'tcx>> {\n+    ) -> FxIndexSet<Ty<'tcx>> {\n         let tcx = self.infcx.tcx;\n         let assumed_wf_types = tcx.assumed_wf_types(def_id);\n-        let mut implied_bounds = FxHashSet::default();\n+        let mut implied_bounds = FxIndexSet::default();\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let cause = ObligationCause::misc(span, hir_id);\n         for ty in assumed_wf_types {"}, {"sha": "58da54afb75b95b01b1467f32020e813a0a021f9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/ambiguity.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fambiguity.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -0,0 +1,52 @@\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::InferCtxt;\n+use rustc_infer::traits::{Obligation, ObligationCause, TraitObligation};\n+use rustc_span::DUMMY_SP;\n+\n+use crate::traits::ObligationCtxt;\n+\n+pub fn recompute_applicable_impls<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    obligation: &TraitObligation<'tcx>,\n+) -> Vec<DefId> {\n+    let tcx = infcx.tcx;\n+    let param_env = obligation.param_env;\n+    let dummy_cause = ObligationCause::dummy();\n+    let impl_may_apply = |impl_def_id| {\n+        let ocx = ObligationCtxt::new_in_snapshot(infcx);\n+        let placeholder_obligation =\n+            infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n+        let obligation_trait_ref =\n+            ocx.normalize(dummy_cause.clone(), param_env, placeholder_obligation.trait_ref);\n+\n+        let impl_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+        let impl_trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap().subst(tcx, impl_substs);\n+        let impl_trait_ref = ocx.normalize(ObligationCause::dummy(), param_env, impl_trait_ref);\n+\n+        if let Err(_) = ocx.eq(&dummy_cause, param_env, obligation_trait_ref, impl_trait_ref) {\n+            return false;\n+        }\n+\n+        let impl_predicates = tcx.predicates_of(impl_def_id).instantiate(tcx, impl_substs);\n+        ocx.register_obligations(\n+            impl_predicates\n+                .predicates\n+                .iter()\n+                .map(|&predicate| Obligation::new(dummy_cause.clone(), param_env, predicate)),\n+        );\n+\n+        ocx.select_where_possible().is_empty()\n+    };\n+\n+    let mut impls = Vec::new();\n+    tcx.for_each_relevant_impl(\n+        obligation.predicate.def_id(),\n+        obligation.predicate.skip_binder().trait_ref.self_ty(),\n+        |impl_def_id| {\n+            if infcx.probe(move |_snapshot| impl_may_apply(impl_def_id)) {\n+                impls.push(impl_def_id)\n+            }\n+        },\n+    );\n+    impls\n+}"}, {"sha": "e64586407c923c1b2d78e8fcdcc028158161f8d3", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,17 +1,21 @@\n+mod ambiguity;\n pub mod on_unimplemented;\n pub mod suggestions;\n \n use super::{\n     FulfillmentContext, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n-    Obligation, ObligationCause, ObligationCauseCode, OnUnimplementedDirective,\n-    OnUnimplementedNote, OutputTypeParameterMismatch, Overflow, PredicateObligation,\n-    SelectionContext, SelectionError, TraitNotObjectSafe,\n+    Obligation, ObligationCause, ObligationCauseCode, OutputTypeParameterMismatch, Overflow,\n+    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n };\n-\n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n-use rustc_data_structures::fx::FxHashMap;\n+use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n+use crate::traits::query::normalize::AtExt as _;\n+use crate::traits::specialize::to_pretty_impl_header;\n+use on_unimplemented::OnUnimplementedNote;\n+use on_unimplemented::TypeErrCtxtExt as _;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n     MultiSpan, Style,\n@@ -40,11 +44,6 @@ use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n use std::iter;\n use std::ops::ControlFlow;\n-\n-use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use crate::traits::query::normalize::AtExt as _;\n-use crate::traits::specialize::to_pretty_impl_header;\n-use on_unimplemented::TypeErrCtxtExt as _;\n use suggestions::TypeErrCtxtExt as _;\n \n pub use rustc_infer::traits::error_reporting::*;\n@@ -101,7 +100,6 @@ pub trait TypeErrCtxtExt<'tcx> {\n         &self,\n         errors: &[FulfillmentError<'tcx>],\n         body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n     ) -> ErrorGuaranteed;\n \n     fn report_overflow_error<T>(\n@@ -124,7 +122,6 @@ pub trait TypeErrCtxtExt<'tcx> {\n         obligation: PredicateObligation<'tcx>,\n         root_obligation: &PredicateObligation<'tcx>,\n         error: &SelectionError<'tcx>,\n-        fallback_has_occurred: bool,\n     );\n }\n \n@@ -375,15 +372,14 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         &self,\n         errors: &[FulfillmentError<'tcx>],\n         body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n     ) -> ErrorGuaranteed {\n         #[derive(Debug)]\n         struct ErrorDescriptor<'tcx> {\n             predicate: ty::Predicate<'tcx>,\n             index: Option<usize>, // None if this is an old error\n         }\n \n-        let mut error_map: FxHashMap<_, Vec<_>> = self\n+        let mut error_map: FxIndexMap<_, Vec<_>> = self\n             .reported_trait_errors\n             .borrow()\n             .iter()\n@@ -452,7 +448,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         for (error, suppressed) in iter::zip(errors, is_suppressed) {\n             if !suppressed {\n-                self.report_fulfillment_error(error, body_id, fallback_has_occurred);\n+                self.report_fulfillment_error(error, body_id);\n             }\n         }\n \n@@ -534,22 +530,12 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         mut obligation: PredicateObligation<'tcx>,\n         root_obligation: &PredicateObligation<'tcx>,\n         error: &SelectionError<'tcx>,\n-        fallback_has_occurred: bool,\n     ) {\n         self.set_tainted_by_errors();\n         let tcx = self.tcx;\n         let mut span = obligation.cause.span;\n \n         let mut err = match *error {\n-            SelectionError::Ambiguous(ref impls) => {\n-                let mut err = self.tcx.sess.struct_span_err(\n-                    obligation.cause.span,\n-                    &format!(\"multiple applicable `impl`s for `{}`\", obligation.predicate),\n-                );\n-                self.annotate_source_of_ambiguity(&mut err, impls, obligation.predicate);\n-                err.emit();\n-                return;\n-            }\n             SelectionError::Unimplemented => {\n                 // If this obligation was generated as a result of well-formedness checking, see if we\n                 // can get a better error message by performing HIR-based well-formedness checking.\n@@ -700,6 +686,25 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             }\n                         }\n \n+                        if Some(trait_ref.def_id()) == tcx.lang_items().tuple_trait() {\n+                            match obligation.cause.code().peel_derives() {\n+                                ObligationCauseCode::RustCall => {\n+                                    err.set_primary_message(\"functions with the \\\"rust-call\\\" ABI must take a single non-self tuple argument\");\n+                                }\n+                                ObligationCauseCode::BindingObligation(def_id, _)\n+                                | ObligationCauseCode::ItemObligation(def_id)\n+                                    if ty::ClosureKind::from_def_id(tcx, *def_id).is_some() =>\n+                                {\n+                                    err.code(rustc_errors::error_code!(E0059));\n+                                    err.set_primary_message(format!(\n+                                        \"type parameter to bare `{}` trait must be a tuple\",\n+                                        tcx.def_path_str(*def_id)\n+                                    ));\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+\n                         if Some(trait_ref.def_id()) == tcx.lang_items().drop_trait()\n                             && predicate_is_const\n                         {\n@@ -848,12 +853,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             );\n                         }\n \n-                        let is_fn_trait = [\n-                            self.tcx.lang_items().fn_trait(),\n-                            self.tcx.lang_items().fn_mut_trait(),\n-                            self.tcx.lang_items().fn_once_trait(),\n-                        ]\n-                        .contains(&Some(trait_ref.def_id()));\n+                        let is_fn_trait =\n+                            ty::ClosureKind::from_def_id(tcx, trait_ref.def_id()).is_some();\n                         let is_target_feature_fn = if let ty::FnDef(def_id, _) =\n                             *trait_ref.skip_binder().self_ty().kind()\n                         {\n@@ -1000,7 +1001,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         // variable that used to fallback to `()` now falling back to `!`. Issue a\n                         // note informing about the change in behaviour.\n                         if trait_predicate.skip_binder().self_ty().is_never()\n-                            && fallback_has_occurred\n+                            && self.fallback_has_occurred\n                         {\n                             let predicate = trait_predicate.map_bound(|mut trait_pred| {\n                                 trait_pred.trait_ref.substs = self.tcx.mk_substs_trait(\n@@ -1366,7 +1367,6 @@ trait InferCtxtPrivExt<'tcx> {\n         &self,\n         error: &FulfillmentError<'tcx>,\n         body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n     );\n \n     fn report_projection_error(\n@@ -1516,15 +1516,13 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         &self,\n         error: &FulfillmentError<'tcx>,\n         body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n     ) {\n         match error.code {\n             FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n                 self.report_selection_error(\n                     error.obligation.clone(),\n                     &error.root_obligation,\n                     selection_error,\n-                    fallback_has_occurred,\n                 );\n             }\n             FulfillmentErrorCode::CodeProjectionError(ref e) => {\n@@ -2138,12 +2136,25 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     crate::traits::TraitQueryMode::Standard,\n                 );\n                 match selcx.select_from_obligation(&obligation) {\n-                    Err(SelectionError::Ambiguous(impls)) if impls.len() > 1 => {\n-                        self.annotate_source_of_ambiguity(&mut err, &impls, predicate);\n+                    Ok(None) => {\n+                        let impls = ambiguity::recompute_applicable_impls(self.infcx, &obligation);\n+                        let has_non_region_infer =\n+                            trait_ref.skip_binder().substs.types().any(|t| !t.is_ty_infer());\n+                        // It doesn't make sense to talk about applicable impls if there are more\n+                        // than a handful of them.\n+                        if impls.len() > 1 && impls.len() < 5 && has_non_region_infer {\n+                            self.annotate_source_of_ambiguity(&mut err, &impls, predicate);\n+                        } else {\n+                            if self.is_tainted_by_errors() {\n+                                err.delay_as_bug();\n+                                return;\n+                            }\n+                            err.note(&format!(\"cannot satisfy `{}`\", predicate));\n+                        }\n                     }\n                     _ => {\n                         if self.is_tainted_by_errors() {\n-                            err.cancel();\n+                            err.delay_as_bug();\n                             return;\n                         }\n                         err.note(&format!(\"cannot satisfy `{}`\", predicate));\n@@ -2435,7 +2446,6 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n         }\n-        let msg = format!(\"multiple `impl`s satisfying `{}` found\", predicate);\n         let mut crate_names: Vec<_> = crates.iter().map(|n| format!(\"`{}`\", n)).collect();\n         crate_names.sort();\n         crate_names.dedup();\n@@ -2456,13 +2466,9 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             err.downgrade_to_delayed_bug();\n             return;\n         }\n-        let post = if post.len() > 4 {\n-            format!(\n-                \":\\n{}\\nand {} more\",\n-                post.iter().map(|p| format!(\"- {}\", p)).take(4).collect::<Vec<_>>().join(\"\\n\"),\n-                post.len() - 4,\n-            )\n-        } else if post.len() > 1 || (post.len() == 1 && post[0].contains('\\n')) {\n+\n+        let msg = format!(\"multiple `impl`s satisfying `{}` found\", predicate);\n+        let post = if post.len() > 1 || (post.len() == 1 && post[0].contains('\\n')) {\n             format!(\":\\n{}\", post.iter().map(|p| format!(\"- {}\", p)).collect::<Vec<_>>().join(\"\\n\"),)\n         } else if post.len() == 1 {\n             format!(\": `{}`\", post[0])"}, {"sha": "82f0440b3078bb17efbb8d7406f528986eab5b9f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 393, "deletions": 5, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,14 +1,22 @@\n-use super::{\n-    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote, PredicateObligation,\n-};\n+use super::{ObligationCauseCode, PredicateObligation};\n use crate::infer::error_reporting::TypeErrCtxt;\n+use rustc_ast::{MetaItem, NestedMetaItem};\n+use rustc_attr as attr;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::{struct_span_err, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::SubstsRef;\n-use rustc_middle::ty::{self, GenericParamDefKind};\n-use rustc_span::symbol::sym;\n+use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n+use rustc_parse_format::{ParseMode, Parser, Piece, Position};\n+use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::{Span, DUMMY_SP};\n use std::iter;\n \n+use crate::errors::{\n+    EmptyOnClauseInOnUnimplemented, InvalidOnClauseInOnUnimplemented, NoValueInOnUnimplemented,\n+};\n+\n use super::InferCtxtPrivExt;\n \n pub trait TypeErrCtxtExt<'tcx> {\n@@ -276,3 +284,383 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n }\n+\n+#[derive(Clone, Debug)]\n+pub struct OnUnimplementedFormatString(Symbol);\n+\n+#[derive(Debug)]\n+pub struct OnUnimplementedDirective {\n+    pub condition: Option<MetaItem>,\n+    pub subcommands: Vec<OnUnimplementedDirective>,\n+    pub message: Option<OnUnimplementedFormatString>,\n+    pub label: Option<OnUnimplementedFormatString>,\n+    pub note: Option<OnUnimplementedFormatString>,\n+    pub parent_label: Option<OnUnimplementedFormatString>,\n+    pub append_const_msg: Option<Option<Symbol>>,\n+}\n+\n+/// For the `#[rustc_on_unimplemented]` attribute\n+#[derive(Default)]\n+pub struct OnUnimplementedNote {\n+    pub message: Option<String>,\n+    pub label: Option<String>,\n+    pub note: Option<String>,\n+    pub parent_label: Option<String>,\n+    /// Append a message for `~const Trait` errors. `None` means not requested and\n+    /// should fallback to a generic message, `Some(None)` suggests using the default\n+    /// appended message, `Some(Some(s))` suggests use the `s` message instead of the\n+    /// default one..\n+    pub append_const_msg: Option<Option<Symbol>>,\n+}\n+\n+impl<'tcx> OnUnimplementedDirective {\n+    fn parse(\n+        tcx: TyCtxt<'tcx>,\n+        item_def_id: DefId,\n+        items: &[NestedMetaItem],\n+        span: Span,\n+        is_root: bool,\n+    ) -> Result<Self, ErrorGuaranteed> {\n+        let mut errored = None;\n+        let mut item_iter = items.iter();\n+\n+        let parse_value = |value_str| {\n+            OnUnimplementedFormatString::try_parse(tcx, item_def_id, value_str, span).map(Some)\n+        };\n+\n+        let condition = if is_root {\n+            None\n+        } else {\n+            let cond = item_iter\n+                .next()\n+                .ok_or_else(|| tcx.sess.emit_err(EmptyOnClauseInOnUnimplemented { span }))?\n+                .meta_item()\n+                .ok_or_else(|| tcx.sess.emit_err(InvalidOnClauseInOnUnimplemented { span }))?;\n+            attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |cfg| {\n+                if let Some(value) = cfg.value && let Err(guar) = parse_value(value) {\n+                    errored = Some(guar);\n+                }\n+                true\n+            });\n+            Some(cond.clone())\n+        };\n+\n+        let mut message = None;\n+        let mut label = None;\n+        let mut note = None;\n+        let mut parent_label = None;\n+        let mut subcommands = vec![];\n+        let mut append_const_msg = None;\n+\n+        for item in item_iter {\n+            if item.has_name(sym::message) && message.is_none() {\n+                if let Some(message_) = item.value_str() {\n+                    message = parse_value(message_)?;\n+                    continue;\n+                }\n+            } else if item.has_name(sym::label) && label.is_none() {\n+                if let Some(label_) = item.value_str() {\n+                    label = parse_value(label_)?;\n+                    continue;\n+                }\n+            } else if item.has_name(sym::note) && note.is_none() {\n+                if let Some(note_) = item.value_str() {\n+                    note = parse_value(note_)?;\n+                    continue;\n+                }\n+            } else if item.has_name(sym::parent_label) && parent_label.is_none() {\n+                if let Some(parent_label_) = item.value_str() {\n+                    parent_label = parse_value(parent_label_)?;\n+                    continue;\n+                }\n+            } else if item.has_name(sym::on)\n+                && is_root\n+                && message.is_none()\n+                && label.is_none()\n+                && note.is_none()\n+            {\n+                if let Some(items) = item.meta_item_list() {\n+                    match Self::parse(tcx, item_def_id, &items, item.span(), false) {\n+                        Ok(subcommand) => subcommands.push(subcommand),\n+                        Err(reported) => errored = Some(reported),\n+                    };\n+                    continue;\n+                }\n+            } else if item.has_name(sym::append_const_msg) && append_const_msg.is_none() {\n+                if let Some(msg) = item.value_str() {\n+                    append_const_msg = Some(Some(msg));\n+                    continue;\n+                } else if item.is_word() {\n+                    append_const_msg = Some(None);\n+                    continue;\n+                }\n+            }\n+\n+            // nothing found\n+            tcx.sess.emit_err(NoValueInOnUnimplemented { span: item.span() });\n+        }\n+\n+        if let Some(reported) = errored {\n+            Err(reported)\n+        } else {\n+            Ok(OnUnimplementedDirective {\n+                condition,\n+                subcommands,\n+                message,\n+                label,\n+                note,\n+                parent_label,\n+                append_const_msg,\n+            })\n+        }\n+    }\n+\n+    pub fn of_item(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> Result<Option<Self>, ErrorGuaranteed> {\n+        let Some(attr) = tcx.get_attr(item_def_id, sym::rustc_on_unimplemented) else {\n+            return Ok(None);\n+        };\n+\n+        let result = if let Some(items) = attr.meta_item_list() {\n+            Self::parse(tcx, item_def_id, &items, attr.span, true).map(Some)\n+        } else if let Some(value) = attr.value_str() {\n+            Ok(Some(OnUnimplementedDirective {\n+                condition: None,\n+                message: None,\n+                subcommands: vec![],\n+                label: Some(OnUnimplementedFormatString::try_parse(\n+                    tcx,\n+                    item_def_id,\n+                    value,\n+                    attr.span,\n+                )?),\n+                note: None,\n+                parent_label: None,\n+                append_const_msg: None,\n+            }))\n+        } else {\n+            let reported =\n+                tcx.sess.delay_span_bug(DUMMY_SP, \"of_item: neither meta_item_list nor value_str\");\n+            return Err(reported);\n+        };\n+        debug!(\"of_item({:?}) = {:?}\", item_def_id, result);\n+        result\n+    }\n+\n+    pub fn evaluate(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        options: &[(Symbol, Option<String>)],\n+    ) -> OnUnimplementedNote {\n+        let mut message = None;\n+        let mut label = None;\n+        let mut note = None;\n+        let mut parent_label = None;\n+        let mut append_const_msg = None;\n+        info!(\"evaluate({:?}, trait_ref={:?}, options={:?})\", self, trait_ref, options);\n+\n+        let options_map: FxHashMap<Symbol, String> =\n+            options.iter().filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned()))).collect();\n+\n+        for command in self.subcommands.iter().chain(Some(self)).rev() {\n+            if let Some(ref condition) = command.condition && !attr::eval_condition(\n+                condition,\n+                &tcx.sess.parse_sess,\n+                Some(tcx.features()),\n+                &mut |cfg| {\n+                    let value = cfg.value.map(|v| {\n+                        OnUnimplementedFormatString(v).format(tcx, trait_ref, &options_map)\n+                    });\n+\n+                    options.contains(&(cfg.name, value))\n+                },\n+            ) {\n+                debug!(\"evaluate: skipping {:?} due to condition\", command);\n+                continue;\n+            }\n+            debug!(\"evaluate: {:?} succeeded\", command);\n+            if let Some(ref message_) = command.message {\n+                message = Some(message_.clone());\n+            }\n+\n+            if let Some(ref label_) = command.label {\n+                label = Some(label_.clone());\n+            }\n+\n+            if let Some(ref note_) = command.note {\n+                note = Some(note_.clone());\n+            }\n+\n+            if let Some(ref parent_label_) = command.parent_label {\n+                parent_label = Some(parent_label_.clone());\n+            }\n+\n+            append_const_msg = command.append_const_msg;\n+        }\n+\n+        OnUnimplementedNote {\n+            label: label.map(|l| l.format(tcx, trait_ref, &options_map)),\n+            message: message.map(|m| m.format(tcx, trait_ref, &options_map)),\n+            note: note.map(|n| n.format(tcx, trait_ref, &options_map)),\n+            parent_label: parent_label.map(|e_s| e_s.format(tcx, trait_ref, &options_map)),\n+            append_const_msg,\n+        }\n+    }\n+}\n+\n+impl<'tcx> OnUnimplementedFormatString {\n+    fn try_parse(\n+        tcx: TyCtxt<'tcx>,\n+        item_def_id: DefId,\n+        from: Symbol,\n+        err_sp: Span,\n+    ) -> Result<Self, ErrorGuaranteed> {\n+        let result = OnUnimplementedFormatString(from);\n+        result.verify(tcx, item_def_id, err_sp)?;\n+        Ok(result)\n+    }\n+\n+    fn verify(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        item_def_id: DefId,\n+        span: Span,\n+    ) -> Result<(), ErrorGuaranteed> {\n+        let trait_def_id = if tcx.is_trait(item_def_id) {\n+            item_def_id\n+        } else {\n+            tcx.trait_id_of_impl(item_def_id)\n+                .expect(\"expected `on_unimplemented` to correspond to a trait\")\n+        };\n+        let trait_name = tcx.item_name(trait_def_id);\n+        let generics = tcx.generics_of(item_def_id);\n+        let s = self.0.as_str();\n+        let parser = Parser::new(s, None, None, false, ParseMode::Format);\n+        let mut result = Ok(());\n+        for token in parser {\n+            match token {\n+                Piece::String(_) => (), // Normal string, no need to check it\n+                Piece::NextArgument(a) => match a.position {\n+                    Position::ArgumentNamed(s) => {\n+                        match Symbol::intern(s) {\n+                            // `{Self}` is allowed\n+                            kw::SelfUpper => (),\n+                            // `{ThisTraitsName}` is allowed\n+                            s if s == trait_name => (),\n+                            // `{from_method}` is allowed\n+                            sym::from_method => (),\n+                            // `{from_desugaring}` is allowed\n+                            sym::from_desugaring => (),\n+                            // `{ItemContext}` is allowed\n+                            sym::ItemContext => (),\n+                            // `{integral}` and `{integer}` and `{float}` are allowed\n+                            sym::integral | sym::integer_ | sym::float => (),\n+                            // So is `{A}` if A is a type parameter\n+                            s => match generics.params.iter().find(|param| param.name == s) {\n+                                Some(_) => (),\n+                                None => {\n+                                    let reported = struct_span_err!(\n+                                        tcx.sess,\n+                                        span,\n+                                        E0230,\n+                                        \"there is no parameter `{}` on {}\",\n+                                        s,\n+                                        if trait_def_id == item_def_id {\n+                                            format!(\"trait `{}`\", trait_name)\n+                                        } else {\n+                                            \"impl\".to_string()\n+                                        }\n+                                    )\n+                                    .emit();\n+                                    result = Err(reported);\n+                                }\n+                            },\n+                        }\n+                    }\n+                    // `{:1}` and `{}` are not to be used\n+                    Position::ArgumentIs(..) | Position::ArgumentImplicitlyIs(_) => {\n+                        let reported = struct_span_err!(\n+                            tcx.sess,\n+                            span,\n+                            E0231,\n+                            \"only named substitution parameters are allowed\"\n+                        )\n+                        .emit();\n+                        result = Err(reported);\n+                    }\n+                },\n+            }\n+        }\n+\n+        result\n+    }\n+\n+    pub fn format(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        options: &FxHashMap<Symbol, String>,\n+    ) -> String {\n+        let name = tcx.item_name(trait_ref.def_id);\n+        let trait_str = tcx.def_path_str(trait_ref.def_id);\n+        let generics = tcx.generics_of(trait_ref.def_id);\n+        let generic_map = generics\n+            .params\n+            .iter()\n+            .filter_map(|param| {\n+                let value = match param.kind {\n+                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                        trait_ref.substs[param.index as usize].to_string()\n+                    }\n+                    GenericParamDefKind::Lifetime => return None,\n+                };\n+                let name = param.name;\n+                Some((name, value))\n+            })\n+            .collect::<FxHashMap<Symbol, String>>();\n+        let empty_string = String::new();\n+\n+        let s = self.0.as_str();\n+        let parser = Parser::new(s, None, None, false, ParseMode::Format);\n+        let item_context = (options.get(&sym::ItemContext)).unwrap_or(&empty_string);\n+        parser\n+            .map(|p| match p {\n+                Piece::String(s) => s,\n+                Piece::NextArgument(a) => match a.position {\n+                    Position::ArgumentNamed(s) => {\n+                        let s = Symbol::intern(s);\n+                        match generic_map.get(&s) {\n+                            Some(val) => val,\n+                            None if s == name => &trait_str,\n+                            None => {\n+                                if let Some(val) = options.get(&s) {\n+                                    val\n+                                } else if s == sym::from_desugaring || s == sym::from_method {\n+                                    // don't break messages using these two arguments incorrectly\n+                                    &empty_string\n+                                } else if s == sym::ItemContext {\n+                                    &item_context\n+                                } else if s == sym::integral {\n+                                    \"{integral}\"\n+                                } else if s == sym::integer_ {\n+                                    \"{integer}\"\n+                                } else if s == sym::float {\n+                                    \"{float}\"\n+                                } else {\n+                                    bug!(\n+                                        \"broken on_unimplemented {:?} for {:?}: \\\n+                                      no argument matching {:?}\",\n+                                        self.0,\n+                                        trait_ref,\n+                                        s\n+                                    )\n+                                }\n+                            }\n+                        }\n+                    }\n+                    _ => bug!(\"broken on_unimplemented {:?} - bad format arg\", self.0),\n+                },\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "02e880a8e6e95f1afc79dbd79f45c499c05011c0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -714,7 +714,6 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     obligation.cause.body_id,\n                     span,\n                     base_ty,\n-                    span,\n                 );\n                 if let Some(steps) = autoderef.find_map(|(ty, steps)| {\n                     // Re-add the `&`\n@@ -2407,7 +2406,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             | ObligationCauseCode::CheckAssociatedTypeBounds { .. }\n             | ObligationCauseCode::LetElse\n             | ObligationCauseCode::BinOp { .. }\n-            | ObligationCauseCode::AscribeUserTypeProvePredicate(..) => {}\n+            | ObligationCauseCode::AscribeUserTypeProvePredicate(..)\n+            | ObligationCauseCode::RustCall => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }\n@@ -2445,12 +2445,12 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             (Ok(l), Ok(r)) => l.line == r.line,\n                             _ => true,\n                         };\n-                    if !ident.span.overlaps(span) && !same_line {\n+                    if !ident.span.is_dummy() && !ident.span.overlaps(span) && !same_line {\n                         multispan.push_span_label(ident.span, \"required by a bound in this\");\n                     }\n                 }\n                 let descr = format!(\"required by a bound in `{}`\", item_name);\n-                if span != DUMMY_SP {\n+                if !span.is_dummy() {\n                     let msg = format!(\"required by this bound in `{}`\", item_name);\n                     multispan.push_span_label(span, msg);\n                     err.span_note(multispan, &descr);"}, {"sha": "b6ded4ce5a3962e0d252dd81b0b226c72017174e", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -70,7 +70,7 @@ pub fn can_type_implement_copy<'tcx>(\n                     }\n                 }\n                 Err(errors) => {\n-                    infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+                    infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n                 }\n             };\n         }"}, {"sha": "10e48610e3abb46287812cd87e0a0a7ddd722fd8", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 12, "deletions": 50, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -12,7 +12,6 @@ pub mod error_reporting;\n mod fulfill;\n pub mod misc;\n mod object_safety;\n-mod on_unimplemented;\n pub mod outlives_bounds;\n mod project;\n pub mod query;\n@@ -58,7 +57,6 @@ pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::is_vtable_safe_method;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n-pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::project::{normalize, normalize_projection_type, normalize_to};\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n@@ -117,14 +115,12 @@ pub enum TraitQueryMode {\n }\n \n /// Creates predicate obligations from the generic bounds.\n+#[instrument(level = \"debug\", skip(cause, param_env))]\n pub fn predicates_for_generics<'tcx>(\n     cause: impl Fn(usize, Span) -> ObligationCause<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     generic_bounds: ty::InstantiatedPredicates<'tcx>,\n ) -> impl Iterator<Item = PredicateObligation<'tcx>> {\n-    let generic_bounds = generic_bounds;\n-    debug!(\"predicates_for_generics(generic_bounds={:?})\", generic_bounds);\n-\n     std::iter::zip(generic_bounds.predicates, generic_bounds.spans).enumerate().map(\n         move |(idx, (predicate, span))| Obligation {\n             cause: cause(idx, span),\n@@ -140,19 +136,14 @@ pub fn predicates_for_generics<'tcx>(\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n+#[instrument(level = \"debug\", skip(infcx, param_env, span), ret)]\n pub fn type_known_to_meet_bound_modulo_regions<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n     def_id: DefId,\n     span: Span,\n ) -> bool {\n-    debug!(\n-        \"type_known_to_meet_bound_modulo_regions(ty={:?}, bound={:?})\",\n-        ty,\n-        infcx.tcx.def_path_str(def_id)\n-    );\n-\n     let trait_ref =\n         ty::Binder::dummy(ty::TraitRef { def_id, substs: infcx.tcx.mk_substs_trait(ty, &[]) });\n     let obligation = Obligation {\n@@ -163,12 +154,7 @@ pub fn type_known_to_meet_bound_modulo_regions<'tcx>(\n     };\n \n     let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n-    debug!(\n-        \"type_known_to_meet_ty={:?} bound={} => {:?}\",\n-        ty,\n-        infcx.tcx.def_path_str(def_id),\n-        result\n-    );\n+    debug!(?result);\n \n     if result && ty.has_non_region_infer() {\n         // Because of inference \"guessing\", selection can sometimes claim\n@@ -190,21 +176,9 @@ pub fn type_known_to_meet_bound_modulo_regions<'tcx>(\n         // *definitively* show that it implements `Copy`. Otherwise,\n         // assume it is move; linear is always ok.\n         match &errors[..] {\n-            [] => {\n-                debug!(\n-                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n-                    ty,\n-                    infcx.tcx.def_path_str(def_id)\n-                );\n-                true\n-            }\n+            [] => true,\n             errors => {\n-                debug!(\n-                    ?ty,\n-                    bound = %infcx.tcx.def_path_str(def_id),\n-                    ?errors,\n-                    \"type_known_to_meet_bound_modulo_regions\"\n-                );\n+                debug!(?errors);\n                 false\n             }\n         }\n@@ -238,7 +212,7 @@ fn do_normalize_predicates<'tcx>(\n     let predicates = match fully_normalize(&infcx, cause, elaborated_env, predicates) {\n         Ok(predicates) => predicates,\n         Err(errors) => {\n-            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n             return Err(reported);\n         }\n     };\n@@ -924,25 +898,13 @@ pub fn vtable_trait_upcasting_coercion_new_vptr_slot<'tcx>(\n         def_id: unsize_trait_did,\n         substs: tcx.mk_substs_trait(source, &[target.into()]),\n     };\n-    let obligation = Obligation::new(\n-        ObligationCause::dummy(),\n-        ty::ParamEnv::reveal_all(),\n-        ty::Binder::dummy(ty::TraitPredicate {\n-            trait_ref,\n-            constness: ty::BoundConstness::NotConst,\n-            polarity: ty::ImplPolarity::Positive,\n-        }),\n-    );\n-\n-    let infcx = tcx.infer_ctxt().build();\n-    let mut selcx = SelectionContext::new(&infcx);\n-    let implsrc = selcx.select(&obligation).unwrap();\n \n-    let Some(ImplSource::TraitUpcasting(implsrc_traitcasting)) = implsrc else {\n-        bug!();\n-    };\n-\n-    implsrc_traitcasting.vtable_vptr_slot\n+    match tcx.codegen_select_candidate((ty::ParamEnv::reveal_all(), ty::Binder::dummy(trait_ref))) {\n+        Ok(ImplSource::TraitUpcasting(implsrc_traitcasting)) => {\n+            implsrc_traitcasting.vtable_vptr_slot\n+        }\n+        otherwise => bug!(\"expected TraitUpcasting candidate, got {otherwise:?}\"),\n+    }\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "fb062ea71c4ce775bf6c74cf4c153dde6a74a1f3", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "removed", "additions": 0, "deletions": 393, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/71c3ecf31f1adf920d2cfd577392b8a45ac9c808/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71c3ecf31f1adf920d2cfd577392b8a45ac9c808/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=71c3ecf31f1adf920d2cfd577392b8a45ac9c808", "patch": "@@ -1,393 +0,0 @@\n-use rustc_ast::{MetaItem, NestedMetaItem};\n-use rustc_attr as attr;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, ErrorGuaranteed};\n-use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n-use rustc_parse_format::{ParseMode, Parser, Piece, Position};\n-use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n-\n-use crate::errors::{\n-    EmptyOnClauseInOnUnimplemented, InvalidOnClauseInOnUnimplemented, NoValueInOnUnimplemented,\n-};\n-\n-#[derive(Clone, Debug)]\n-pub struct OnUnimplementedFormatString(Symbol);\n-\n-#[derive(Debug)]\n-pub struct OnUnimplementedDirective {\n-    pub condition: Option<MetaItem>,\n-    pub subcommands: Vec<OnUnimplementedDirective>,\n-    pub message: Option<OnUnimplementedFormatString>,\n-    pub label: Option<OnUnimplementedFormatString>,\n-    pub note: Option<OnUnimplementedFormatString>,\n-    pub parent_label: Option<OnUnimplementedFormatString>,\n-    pub append_const_msg: Option<Option<Symbol>>,\n-}\n-\n-#[derive(Default)]\n-/// For the `#[rustc_on_unimplemented]` attribute\n-pub struct OnUnimplementedNote {\n-    pub message: Option<String>,\n-    pub label: Option<String>,\n-    pub note: Option<String>,\n-    pub parent_label: Option<String>,\n-    /// Append a message for `~const Trait` errors. `None` means not requested and\n-    /// should fallback to a generic message, `Some(None)` suggests using the default\n-    /// appended message, `Some(Some(s))` suggests use the `s` message instead of the\n-    /// default one..\n-    pub append_const_msg: Option<Option<Symbol>>,\n-}\n-\n-impl<'tcx> OnUnimplementedDirective {\n-    fn parse(\n-        tcx: TyCtxt<'tcx>,\n-        item_def_id: DefId,\n-        items: &[NestedMetaItem],\n-        span: Span,\n-        is_root: bool,\n-    ) -> Result<Self, ErrorGuaranteed> {\n-        let mut errored = None;\n-        let mut item_iter = items.iter();\n-\n-        let parse_value = |value_str| {\n-            OnUnimplementedFormatString::try_parse(tcx, item_def_id, value_str, span).map(Some)\n-        };\n-\n-        let condition = if is_root {\n-            None\n-        } else {\n-            let cond = item_iter\n-                .next()\n-                .ok_or_else(|| tcx.sess.emit_err(EmptyOnClauseInOnUnimplemented { span }))?\n-                .meta_item()\n-                .ok_or_else(|| tcx.sess.emit_err(InvalidOnClauseInOnUnimplemented { span }))?;\n-            attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |cfg| {\n-                if let Some(value) = cfg.value && let Err(guar) = parse_value(value) {\n-                    errored = Some(guar);\n-                }\n-                true\n-            });\n-            Some(cond.clone())\n-        };\n-\n-        let mut message = None;\n-        let mut label = None;\n-        let mut note = None;\n-        let mut parent_label = None;\n-        let mut subcommands = vec![];\n-        let mut append_const_msg = None;\n-\n-        for item in item_iter {\n-            if item.has_name(sym::message) && message.is_none() {\n-                if let Some(message_) = item.value_str() {\n-                    message = parse_value(message_)?;\n-                    continue;\n-                }\n-            } else if item.has_name(sym::label) && label.is_none() {\n-                if let Some(label_) = item.value_str() {\n-                    label = parse_value(label_)?;\n-                    continue;\n-                }\n-            } else if item.has_name(sym::note) && note.is_none() {\n-                if let Some(note_) = item.value_str() {\n-                    note = parse_value(note_)?;\n-                    continue;\n-                }\n-            } else if item.has_name(sym::parent_label) && parent_label.is_none() {\n-                if let Some(parent_label_) = item.value_str() {\n-                    parent_label = parse_value(parent_label_)?;\n-                    continue;\n-                }\n-            } else if item.has_name(sym::on)\n-                && is_root\n-                && message.is_none()\n-                && label.is_none()\n-                && note.is_none()\n-            {\n-                if let Some(items) = item.meta_item_list() {\n-                    match Self::parse(tcx, item_def_id, &items, item.span(), false) {\n-                        Ok(subcommand) => subcommands.push(subcommand),\n-                        Err(reported) => errored = Some(reported),\n-                    };\n-                    continue;\n-                }\n-            } else if item.has_name(sym::append_const_msg) && append_const_msg.is_none() {\n-                if let Some(msg) = item.value_str() {\n-                    append_const_msg = Some(Some(msg));\n-                    continue;\n-                } else if item.is_word() {\n-                    append_const_msg = Some(None);\n-                    continue;\n-                }\n-            }\n-\n-            // nothing found\n-            tcx.sess.emit_err(NoValueInOnUnimplemented { span: item.span() });\n-        }\n-\n-        if let Some(reported) = errored {\n-            Err(reported)\n-        } else {\n-            Ok(OnUnimplementedDirective {\n-                condition,\n-                subcommands,\n-                message,\n-                label,\n-                note,\n-                parent_label,\n-                append_const_msg,\n-            })\n-        }\n-    }\n-\n-    pub fn of_item(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> Result<Option<Self>, ErrorGuaranteed> {\n-        let Some(attr) = tcx.get_attr(item_def_id, sym::rustc_on_unimplemented) else {\n-            return Ok(None);\n-        };\n-\n-        let result = if let Some(items) = attr.meta_item_list() {\n-            Self::parse(tcx, item_def_id, &items, attr.span, true).map(Some)\n-        } else if let Some(value) = attr.value_str() {\n-            Ok(Some(OnUnimplementedDirective {\n-                condition: None,\n-                message: None,\n-                subcommands: vec![],\n-                label: Some(OnUnimplementedFormatString::try_parse(\n-                    tcx,\n-                    item_def_id,\n-                    value,\n-                    attr.span,\n-                )?),\n-                note: None,\n-                parent_label: None,\n-                append_const_msg: None,\n-            }))\n-        } else {\n-            let reported =\n-                tcx.sess.delay_span_bug(DUMMY_SP, \"of_item: neither meta_item_list nor value_str\");\n-            return Err(reported);\n-        };\n-        debug!(\"of_item({:?}) = {:?}\", item_def_id, result);\n-        result\n-    }\n-\n-    pub fn evaluate(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_ref: ty::TraitRef<'tcx>,\n-        options: &[(Symbol, Option<String>)],\n-    ) -> OnUnimplementedNote {\n-        let mut message = None;\n-        let mut label = None;\n-        let mut note = None;\n-        let mut parent_label = None;\n-        let mut append_const_msg = None;\n-        info!(\"evaluate({:?}, trait_ref={:?}, options={:?})\", self, trait_ref, options);\n-\n-        let options_map: FxHashMap<Symbol, String> =\n-            options.iter().filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned()))).collect();\n-\n-        for command in self.subcommands.iter().chain(Some(self)).rev() {\n-            if let Some(ref condition) = command.condition && !attr::eval_condition(\n-                condition,\n-                &tcx.sess.parse_sess,\n-                Some(tcx.features()),\n-                &mut |cfg| {\n-                    let value = cfg.value.map(|v| {\n-                        OnUnimplementedFormatString(v).format(tcx, trait_ref, &options_map)\n-                    });\n-\n-                    options.contains(&(cfg.name, value))\n-                },\n-            ) {\n-                debug!(\"evaluate: skipping {:?} due to condition\", command);\n-                continue;\n-            }\n-            debug!(\"evaluate: {:?} succeeded\", command);\n-            if let Some(ref message_) = command.message {\n-                message = Some(message_.clone());\n-            }\n-\n-            if let Some(ref label_) = command.label {\n-                label = Some(label_.clone());\n-            }\n-\n-            if let Some(ref note_) = command.note {\n-                note = Some(note_.clone());\n-            }\n-\n-            if let Some(ref parent_label_) = command.parent_label {\n-                parent_label = Some(parent_label_.clone());\n-            }\n-\n-            append_const_msg = command.append_const_msg;\n-        }\n-\n-        OnUnimplementedNote {\n-            label: label.map(|l| l.format(tcx, trait_ref, &options_map)),\n-            message: message.map(|m| m.format(tcx, trait_ref, &options_map)),\n-            note: note.map(|n| n.format(tcx, trait_ref, &options_map)),\n-            parent_label: parent_label.map(|e_s| e_s.format(tcx, trait_ref, &options_map)),\n-            append_const_msg,\n-        }\n-    }\n-}\n-\n-impl<'tcx> OnUnimplementedFormatString {\n-    fn try_parse(\n-        tcx: TyCtxt<'tcx>,\n-        item_def_id: DefId,\n-        from: Symbol,\n-        err_sp: Span,\n-    ) -> Result<Self, ErrorGuaranteed> {\n-        let result = OnUnimplementedFormatString(from);\n-        result.verify(tcx, item_def_id, err_sp)?;\n-        Ok(result)\n-    }\n-\n-    fn verify(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        item_def_id: DefId,\n-        span: Span,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        let trait_def_id = if tcx.is_trait(item_def_id) {\n-            item_def_id\n-        } else {\n-            tcx.trait_id_of_impl(item_def_id)\n-                .expect(\"expected `on_unimplemented` to correspond to a trait\")\n-        };\n-        let trait_name = tcx.item_name(trait_def_id);\n-        let generics = tcx.generics_of(item_def_id);\n-        let s = self.0.as_str();\n-        let parser = Parser::new(s, None, None, false, ParseMode::Format);\n-        let mut result = Ok(());\n-        for token in parser {\n-            match token {\n-                Piece::String(_) => (), // Normal string, no need to check it\n-                Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s) => {\n-                        match Symbol::intern(s) {\n-                            // `{Self}` is allowed\n-                            kw::SelfUpper => (),\n-                            // `{ThisTraitsName}` is allowed\n-                            s if s == trait_name => (),\n-                            // `{from_method}` is allowed\n-                            sym::from_method => (),\n-                            // `{from_desugaring}` is allowed\n-                            sym::from_desugaring => (),\n-                            // `{ItemContext}` is allowed\n-                            sym::ItemContext => (),\n-                            // `{integral}` and `{integer}` and `{float}` are allowed\n-                            sym::integral | sym::integer_ | sym::float => (),\n-                            // So is `{A}` if A is a type parameter\n-                            s => match generics.params.iter().find(|param| param.name == s) {\n-                                Some(_) => (),\n-                                None => {\n-                                    let reported = struct_span_err!(\n-                                        tcx.sess,\n-                                        span,\n-                                        E0230,\n-                                        \"there is no parameter `{}` on {}\",\n-                                        s,\n-                                        if trait_def_id == item_def_id {\n-                                            format!(\"trait `{}`\", trait_name)\n-                                        } else {\n-                                            \"impl\".to_string()\n-                                        }\n-                                    )\n-                                    .emit();\n-                                    result = Err(reported);\n-                                }\n-                            },\n-                        }\n-                    }\n-                    // `{:1}` and `{}` are not to be used\n-                    Position::ArgumentIs(..) | Position::ArgumentImplicitlyIs(_) => {\n-                        let reported = struct_span_err!(\n-                            tcx.sess,\n-                            span,\n-                            E0231,\n-                            \"only named substitution parameters are allowed\"\n-                        )\n-                        .emit();\n-                        result = Err(reported);\n-                    }\n-                },\n-            }\n-        }\n-\n-        result\n-    }\n-\n-    pub fn format(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_ref: ty::TraitRef<'tcx>,\n-        options: &FxHashMap<Symbol, String>,\n-    ) -> String {\n-        let name = tcx.item_name(trait_ref.def_id);\n-        let trait_str = tcx.def_path_str(trait_ref.def_id);\n-        let generics = tcx.generics_of(trait_ref.def_id);\n-        let generic_map = generics\n-            .params\n-            .iter()\n-            .filter_map(|param| {\n-                let value = match param.kind {\n-                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n-                        trait_ref.substs[param.index as usize].to_string()\n-                    }\n-                    GenericParamDefKind::Lifetime => return None,\n-                };\n-                let name = param.name;\n-                Some((name, value))\n-            })\n-            .collect::<FxHashMap<Symbol, String>>();\n-        let empty_string = String::new();\n-\n-        let s = self.0.as_str();\n-        let parser = Parser::new(s, None, None, false, ParseMode::Format);\n-        let item_context = (options.get(&sym::ItemContext)).unwrap_or(&empty_string);\n-        parser\n-            .map(|p| match p {\n-                Piece::String(s) => s,\n-                Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s) => {\n-                        let s = Symbol::intern(s);\n-                        match generic_map.get(&s) {\n-                            Some(val) => val,\n-                            None if s == name => &trait_str,\n-                            None => {\n-                                if let Some(val) = options.get(&s) {\n-                                    val\n-                                } else if s == sym::from_desugaring || s == sym::from_method {\n-                                    // don't break messages using these two arguments incorrectly\n-                                    &empty_string\n-                                } else if s == sym::ItemContext {\n-                                    &item_context\n-                                } else if s == sym::integral {\n-                                    \"{integral}\"\n-                                } else if s == sym::integer_ {\n-                                    \"{integer}\"\n-                                } else if s == sym::float {\n-                                    \"{float}\"\n-                                } else {\n-                                    bug!(\n-                                        \"broken on_unimplemented {:?} for {:?}: \\\n-                                      no argument matching {:?}\",\n-                                        self.0,\n-                                        trait_ref,\n-                                        s\n-                                    )\n-                                }\n-                            }\n-                        }\n-                    }\n-                    _ => bug!(\"broken on_unimplemented {:?} - bad format arg\", self.0),\n-                },\n-            })\n-            .collect()\n-    }\n-}"}, {"sha": "e1092a788e32b5df96786eb40146d485a096a43f", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -2,7 +2,7 @@ use crate::infer::InferCtxt;\n use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use crate::traits::query::NoSolution;\n use crate::traits::ObligationCause;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir as hir;\n use rustc_hir::HirId;\n use rustc_middle::ty::{self, ParamEnv, Ty};\n@@ -22,7 +22,7 @@ pub trait InferCtxtExt<'a, 'tcx> {\n         &'a self,\n         param_env: ty::ParamEnv<'tcx>,\n         body_id: hir::HirId,\n-        tys: FxHashSet<Ty<'tcx>>,\n+        tys: FxIndexSet<Ty<'tcx>>,\n     ) -> Bounds<'a, 'tcx>;\n }\n \n@@ -103,7 +103,7 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n         &'a self,\n         param_env: ParamEnv<'tcx>,\n         body_id: HirId,\n-        tys: FxHashSet<Ty<'tcx>>,\n+        tys: FxIndexSet<Ty<'tcx>>,\n     ) -> Bounds<'a, 'tcx> {\n         tys.into_iter()\n             .map(move |ty| {"}, {"sha": "572f82117cc0e701440b9b0308f6848b539ed214", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -647,7 +647,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     fn fold_const(&mut self, constant: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         let tcx = self.selcx.tcx();\n-        if tcx.lazy_normalization() {\n+        if tcx.lazy_normalization() || !needs_normalization(&constant, self.param_env.reveal()) {\n             constant\n         } else {\n             let constant = constant.super_fold_with(self);\n@@ -2187,7 +2187,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n // Verify that the trait item and its implementation have compatible substs lists\n fn check_substs_compatible<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    assoc_ty: &ty::AssocItem,\n+    assoc_item: &ty::AssocItem,\n     substs: ty::SubstsRef<'tcx>,\n ) -> bool {\n     fn check_substs_compatible_inner<'tcx>(\n@@ -2219,7 +2219,10 @@ fn check_substs_compatible<'tcx>(\n         true\n     }\n \n-    check_substs_compatible_inner(tcx, tcx.generics_of(assoc_ty.def_id), substs.as_slice())\n+    let generics = tcx.generics_of(assoc_item.def_id);\n+    // Chop off any additional substs (RPITIT) substs\n+    let substs = &substs[0..generics.count().min(substs.len())];\n+    check_substs_compatible_inner(tcx, generics, substs)\n }\n \n fn confirm_impl_trait_in_trait_candidate<'tcx>(\n@@ -2248,11 +2251,27 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n         };\n     }\n \n-    let impl_fn_def_id = leaf_def.item.def_id;\n     // Rebase from {trait}::{fn}::{opaque} to {impl}::{fn}::{opaque},\n     // since `data.substs` are the impl substs.\n     let impl_fn_substs =\n         obligation.predicate.substs.rebase_onto(tcx, tcx.parent(trait_fn_def_id), data.substs);\n+    let impl_fn_substs = translate_substs(\n+        selcx.infcx(),\n+        obligation.param_env,\n+        data.impl_def_id,\n+        impl_fn_substs,\n+        leaf_def.defining_node,\n+    );\n+\n+    if !check_substs_compatible(tcx, &leaf_def.item, impl_fn_substs) {\n+        let err = tcx.ty_error_with_message(\n+            obligation.cause.span,\n+            \"impl method and trait method have different parameters\",\n+        );\n+        return Progress { term: err.into(), obligations };\n+    }\n+\n+    let impl_fn_def_id = leaf_def.item.def_id;\n \n     let cause = ObligationCause::new(\n         obligation.cause.span,"}, {"sha": "a7932b332c94b1ca0c360b36ed3a1b4174836975", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -353,6 +353,10 @@ impl<'cx, 'tcx> FallibleTypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n         &mut self,\n         constant: ty::Const<'tcx>,\n     ) -> Result<ty::Const<'tcx>, Self::Error> {\n+        if !needs_normalization(&constant, self.param_env.reveal()) {\n+            return Ok(constant);\n+        }\n+\n         let constant = constant.try_super_fold_with(self)?;\n         debug!(?constant, ?self.param_env);\n         Ok(crate::traits::project::with_replaced_escaping_bound_vars("}, {"sha": "3671a0d87df57408b3f5db09a6c032019f5f53cd", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -20,7 +20,7 @@ use crate::traits;\n use crate::traits::coherence::Conflict;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{util, SelectionResult};\n-use crate::traits::{Ambiguous, ErrorReporting, Overflow, Unimplemented};\n+use crate::traits::{ErrorReporting, Overflow, Unimplemented};\n \n use super::BuiltinImplConditions;\n use super::IntercrateAmbiguityCause;\n@@ -200,15 +200,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // and report ambiguity.\n                     if i > 1 {\n                         debug!(\"multiple matches, ambig\");\n-                        return Err(Ambiguous(\n-                            candidates\n-                                .into_iter()\n-                                .filter_map(|c| match c.candidate {\n-                                    SelectionCandidate::ImplCandidate(def_id) => Some(def_id),\n-                                    _ => None,\n-                                })\n-                                .collect(),\n-                        ));\n+                        return Ok(None);\n                     }\n                 }\n             }"}, {"sha": "de158a15d54b8563d1c514e287744bf5c24103f7", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -2,6 +2,12 @@\n //!\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/resolution.html#selection\n \n+// FIXME: The `map` field in ProvisionalEvaluationCache should be changed to\n+// a `FxIndexMap` to avoid query instability, but right now it causes a perf regression. This would be\n+// fixed or at least lightened by the addition of the `drain_filter` method to `FxIndexMap`\n+// Relevant: https://github.com/rust-lang/rust/pull/103723 and https://github.com/bluss/indexmap/issues/242\n+#![allow(rustc::potential_query_instability)]\n+\n use self::EvaluationResult::*;\n use self::SelectionCandidate::*;\n \n@@ -24,7 +30,8 @@ use crate::traits::error_reporting::TypeErrCtxtExt;\n use crate::traits::project::ProjectAndUnifyResult;\n use crate::traits::project::ProjectionCacheKeyExt;\n use crate::traits::ProjectionCacheKey;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n@@ -294,9 +301,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 assert!(self.query_mode == TraitQueryMode::Canonical);\n                 return Err(SelectionError::Overflow(OverflowError::Canonical));\n             }\n-            Err(SelectionError::Ambiguous(_)) => {\n-                return Ok(None);\n-            }\n             Err(e) => {\n                 return Err(e);\n             }\n@@ -931,7 +935,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match self.candidate_from_obligation(stack) {\n             Ok(Some(c)) => self.evaluate_candidate(stack, &c),\n-            Err(SelectionError::Ambiguous(_)) => Ok(EvaluatedToAmbig),\n             Ok(None) => Ok(EvaluatedToAmbig),\n             Err(Overflow(OverflowError::Canonical)) => Err(OverflowError::Canonical),\n             Err(ErrorReporting) => Err(OverflowError::ErrorReporting),\n@@ -1132,12 +1135,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// filter_impls filters constant trait obligations and candidates that have a positive impl\n     /// for a negative goal and a negative impl for a positive goal\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self, candidates))]\n     fn filter_impls(\n         &mut self,\n         candidates: Vec<SelectionCandidate<'tcx>>,\n         obligation: &TraitObligation<'tcx>,\n     ) -> Vec<SelectionCandidate<'tcx>> {\n+        trace!(\"{candidates:#?}\");\n         let tcx = self.tcx();\n         let mut result = Vec::with_capacity(candidates.len());\n \n@@ -1177,6 +1181,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         }\n \n+        trace!(\"{result:#?}\");\n         result\n     }\n \n@@ -1973,6 +1978,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Bar<i32> where struct Bar<T> { x: T, y: u32 } -> [i32, u32]\n     /// Zed<i32> where enum Zed { A(T), B(u32) } -> [i32, u32]\n     /// ```\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn constituent_types_for_ty(\n         &self,\n         t: ty::Binder<'tcx, Ty<'tcx>>,"}, {"sha": "43819b3f490b1907655d5da45d252cff2210803c", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -16,7 +16,7 @@ use crate::errors::NegativePositiveConflict;\n use crate::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause};\n-use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{struct_span_err, DiagnosticBuilder, EmissionGuarantee};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::{self, ImplSubject, TyCtxt};\n@@ -435,7 +435,7 @@ pub(crate) fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Opti\n \n     // FIXME: Currently only handles ?Sized.\n     //        Needs to support ?Move and ?DynSized when they are implemented.\n-    let mut types_without_default_bounds = FxHashSet::default();\n+    let mut types_without_default_bounds = FxIndexSet::default();\n     let sized_trait = tcx.lang_items().sized_trait();\n \n     if !substs.is_empty() {"}, {"sha": "fc0a9f69003363dfd447a006f9a19b183e9a97af", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -547,7 +547,7 @@ impl<'tcx> WfPredicates<'tcx> {\n                 }\n \n                 ty::FnDef(did, substs) => {\n-                    let obligations = self.nominal_obligations(did, substs);\n+                    let obligations = self.nominal_obligations_without_const(did, substs);\n                     self.out.extend(obligations);\n                 }\n "}, {"sha": "07f92299f72b43326f5195dd87fbe87e9ae704de", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -728,7 +728,7 @@ fn bound_vars_for_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx\n         ty::GenericParamDefKind::Lifetime => {\n             let br = ty::BoundRegion {\n                 var: ty::BoundVar::from_usize(substs.len()),\n-                kind: ty::BrAnon(substs.len() as u32),\n+                kind: ty::BrAnon(substs.len() as u32, None),\n             };\n             tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n         }"}, {"sha": "b64d53e60dee6d8211103c879d713f58f4b33ba1", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -498,13 +498,13 @@ impl<'tcx> LowerInto<'tcx, Region<'tcx>> for &chalk_ir::Lifetime<RustInterner<'t\n                 ty::DebruijnIndex::from_u32(var.debruijn.depth()),\n                 ty::BoundRegion {\n                     var: ty::BoundVar::from_usize(var.index),\n-                    kind: ty::BrAnon(var.index as u32),\n+                    kind: ty::BrAnon(var.index as u32, None),\n                 },\n             ),\n             chalk_ir::LifetimeData::InferenceVar(_var) => unimplemented!(),\n             chalk_ir::LifetimeData::Placeholder(p) => ty::RePlaceholder(ty::Placeholder {\n                 universe: ty::UniverseIndex::from_usize(p.ui.counter),\n-                name: ty::BoundRegionKind::BrAnon(p.idx as u32),\n+                name: ty::BoundRegionKind::BrAnon(p.idx as u32, None),\n             }),\n             chalk_ir::LifetimeData::Static => return interner.tcx.lifetimes.re_static,\n             chalk_ir::LifetimeData::Empty(_) => {\n@@ -933,7 +933,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n                     }\n                 }\n \n-                ty::BoundRegionKind::BrAnon(var) => match self.parameters.entry(var) {\n+                ty::BoundRegionKind::BrAnon(var, _) => match self.parameters.entry(var) {\n                     Entry::Vacant(entry) => {\n                         entry.insert(chalk_ir::VariableKind::Lifetime);\n                     }\n@@ -991,13 +991,13 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n             ty::ReLateBound(index, br) if index == self.binder_index => match br.kind {\n                 ty::BrNamed(def_id, _name) => match self.named_parameters.get(&def_id) {\n                     Some(idx) => {\n-                        let new_br = ty::BoundRegion { var: br.var, kind: ty::BrAnon(*idx) };\n+                        let new_br = ty::BoundRegion { var: br.var, kind: ty::BrAnon(*idx, None) };\n                         return self.tcx.mk_region(ty::ReLateBound(index, new_br));\n                     }\n                     None => panic!(\"Missing `BrNamed`.\"),\n                 },\n                 ty::BrEnv => unimplemented!(),\n-                ty::BrAnon(_) => {}\n+                ty::BrAnon(..) => {}\n             },\n             _ => (),\n         };\n@@ -1072,14 +1072,16 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n                 Some(idx) => {\n                     let br = ty::BoundRegion {\n                         var: ty::BoundVar::from_u32(*idx),\n-                        kind: ty::BrAnon(*idx),\n+                        kind: ty::BrAnon(*idx, None),\n                     };\n                     self.tcx.mk_region(ty::ReLateBound(self.binder_index, br))\n                 }\n                 None => {\n                     let idx = self.named_regions.len() as u32;\n-                    let br =\n-                        ty::BoundRegion { var: ty::BoundVar::from_u32(idx), kind: ty::BrAnon(idx) };\n+                    let br = ty::BoundRegion {\n+                        var: ty::BoundVar::from_u32(idx),\n+                        kind: ty::BrAnon(idx, None),\n+                    };\n                     self.named_regions.insert(_re.def_id, idx);\n                     self.tcx.mk_region(ty::ReLateBound(self.binder_index, br))\n                 }\n@@ -1156,7 +1158,7 @@ impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n     fn visit_region(&mut self, r: Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *r {\n             ty::RePlaceholder(p) if p.universe == self.universe_index => {\n-                if let ty::BoundRegionKind::BrAnon(anon) = p.name {\n+                if let ty::BoundRegionKind::BrAnon(anon, _) = p.name {\n                     self.next_anon_region_placeholder = self.next_anon_region_placeholder.max(anon);\n                 }\n             }"}, {"sha": "30e20ba6f586899cc1dd6eff3a12d3cb8b3da9b2", "filename": "compiler/rustc_transmute/src/layout/tree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_transmute%2Fsrc%2Flayout%2Ftree.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -436,8 +436,8 @@ pub(crate) mod rustc {\n \n             // finally: padding\n             let padding_span = trace_span!(\"adding trailing padding\").entered();\n-            let padding_needed = layout_summary.total_size - variant_layout.size();\n-            if padding_needed > 0 {\n+            if layout_summary.total_size > variant_layout.size() {\n+                let padding_needed = layout_summary.total_size - variant_layout.size();\n                 tree = tree.then(Self::padding(padding_needed));\n             };\n             drop(padding_span);"}, {"sha": "1a5938fd34cf17d2b58d8c836be0f7d6c387af58", "filename": "library/alloc/src/alloc/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc%2Ftests.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -22,7 +22,6 @@ fn allocate_zeroed() {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn alloc_owned_small(b: &mut Bencher) {\n     b.iter(|| {\n         let _: Box<_> = Box::new(10);"}, {"sha": "66f4c19e0f91ab44df2e8991bad69ec58219428a", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -158,6 +158,8 @@ use core::hash::{Hash, Hasher};\n #[cfg(not(no_global_oom_handling))]\n use core::iter::FromIterator;\n use core::iter::{FusedIterator, Iterator};\n+#[cfg(not(bootstrap))]\n+use core::marker::Tuple;\n use core::marker::{Destruct, Unpin, Unsize};\n use core::mem;\n use core::ops::{\n@@ -1979,6 +1981,7 @@ impl<I: ExactSizeIterator + ?Sized, A: Allocator> ExactSizeIterator for Box<I, A\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator + ?Sized, A: Allocator> FusedIterator for Box<I, A> {}\n \n+#[cfg(bootstrap)]\n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n impl<Args, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F, A> {\n     type Output = <F as FnOnce<Args>>::Output;\n@@ -1988,20 +1991,48 @@ impl<Args, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F, A> {\n     }\n }\n \n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n+impl<Args: Tuple, F: FnOnce<Args> + ?Sized, A: Allocator> FnOnce<Args> for Box<F, A> {\n+    type Output = <F as FnOnce<Args>>::Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output {\n+        <F as FnOnce<Args>>::call_once(*self, args)\n+    }\n+}\n+\n+#[cfg(bootstrap)]\n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n impl<Args, F: FnMut<Args> + ?Sized, A: Allocator> FnMut<Args> for Box<F, A> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output {\n         <F as FnMut<Args>>::call_mut(self, args)\n     }\n }\n \n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n+impl<Args: Tuple, F: FnMut<Args> + ?Sized, A: Allocator> FnMut<Args> for Box<F, A> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output {\n+        <F as FnMut<Args>>::call_mut(self, args)\n+    }\n+}\n+\n+#[cfg(bootstrap)]\n #[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n impl<Args, F: Fn<Args> + ?Sized, A: Allocator> Fn<Args> for Box<F, A> {\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output {\n         <F as Fn<Args>>::call(self, args)\n     }\n }\n \n+#[cfg(not(bootstrap))]\n+#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n+impl<Args: Tuple, F: Fn<Args> + ?Sized, A: Allocator> Fn<Args> for Box<F, A> {\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output {\n+        <F as Fn<Args>>::call(self, args)\n+    }\n+}\n+\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized, A: Allocator> CoerceUnsized<Box<U, A>> for Box<T, A> {}\n "}, {"sha": "64bce0ff8c0483f805179f10d61e69f7b52feba2", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -94,6 +94,7 @@ fn test_partial_eq() {\n \n #[test]\n #[cfg(target_arch = \"x86_64\")]\n+#[cfg_attr(miri, ignore)] // We'd like to run Miri with layout randomization\n fn test_sizes() {\n     assert_eq!(core::mem::size_of::<LeafNode<(), ()>>(), 16);\n     assert_eq!(core::mem::size_of::<LeafNode<i64, i64>>(), 16 + CAPACITY * 2 * 8);"}, {"sha": "3e0b0f735508e5859c382937b2bced3e8597eb95", "filename": "library/alloc/src/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -139,7 +139,7 @@ impl Display for TryReserveError {\n                 \" because the computed capacity exceeded the collection's maximum\"\n             }\n             TryReserveErrorKind::AllocError { .. } => {\n-                \" because the memory allocator returned a error\"\n+                \" because the memory allocator returned an error\"\n             }\n         };\n         fmt.write_str(reason)"}, {"sha": "6e0f83020f9574de20c56761a70ca4978941574a", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -3,7 +3,6 @@ use core::iter::TrustedLen;\n use super::*;\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_push_back_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::with_capacity(101);\n     b.iter(|| {\n@@ -16,7 +15,6 @@ fn bench_push_back_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_push_front_100(b: &mut test::Bencher) {\n     let mut deq = VecDeque::with_capacity(101);\n     b.iter(|| {\n@@ -29,12 +27,15 @@ fn bench_push_front_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_pop_back_100(b: &mut test::Bencher) {\n-    let mut deq = VecDeque::<i32>::with_capacity(101);\n+    let size = 100;\n+    let mut deq = VecDeque::<i32>::with_capacity(size + 1);\n+    // We'll mess with private state to pretend like `deq` is filled.\n+    // Make sure the buffer is initialized so that we don't read uninit memory.\n+    unsafe { deq.ptr().write_bytes(0u8, size + 1) };\n \n     b.iter(|| {\n-        deq.head = 100;\n+        deq.head = size;\n         deq.tail = 0;\n         while !deq.is_empty() {\n             test::black_box(deq.pop_back());\n@@ -43,9 +44,9 @@ fn bench_pop_back_100(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_retain_whole_10000(b: &mut test::Bencher) {\n-    let v = (1..100000).collect::<VecDeque<u32>>();\n+    let size = if cfg!(miri) { 1000 } else { 100000 };\n+    let v = (1..size).collect::<VecDeque<u32>>();\n \n     b.iter(|| {\n         let mut v = v.clone();\n@@ -54,9 +55,9 @@ fn bench_retain_whole_10000(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_retain_odd_10000(b: &mut test::Bencher) {\n-    let v = (1..100000).collect::<VecDeque<u32>>();\n+    let size = if cfg!(miri) { 1000 } else { 100000 };\n+    let v = (1..size).collect::<VecDeque<u32>>();\n \n     b.iter(|| {\n         let mut v = v.clone();\n@@ -65,23 +66,26 @@ fn bench_retain_odd_10000(b: &mut test::Bencher) {\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_retain_half_10000(b: &mut test::Bencher) {\n-    let v = (1..100000).collect::<VecDeque<u32>>();\n+    let size = if cfg!(miri) { 1000 } else { 100000 };\n+    let v = (1..size).collect::<VecDeque<u32>>();\n \n     b.iter(|| {\n         let mut v = v.clone();\n-        v.retain(|x| *x > 50000)\n+        v.retain(|x| *x > size / 2)\n     })\n }\n \n #[bench]\n-#[cfg_attr(miri, ignore)] // isolated Miri does not support benchmarks\n fn bench_pop_front_100(b: &mut test::Bencher) {\n-    let mut deq = VecDeque::<i32>::with_capacity(101);\n+    let size = 100;\n+    let mut deq = VecDeque::<i32>::with_capacity(size + 1);\n+    // We'll mess with private state to pretend like `deq` is filled.\n+    // Make sure the buffer is initialized so that we don't read uninit memory.\n+    unsafe { deq.ptr().write_bytes(0u8, size + 1) };\n \n     b.iter(|| {\n-        deq.head = 100;\n+        deq.head = size;\n         deq.tail = 0;\n         while !deq.is_empty() {\n             test::black_box(deq.pop_front());"}, {"sha": "008926666c136d5f04fc2a8104d2bbd56e195fda", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -150,6 +150,7 @@\n #![feature(trusted_len)]\n #![feature(trusted_random_access)]\n #![feature(try_trait_v2)]\n+#![cfg_attr(not(bootstrap), feature(tuple_trait))]\n #![feature(unchecked_math)]\n #![feature(unicode_internals)]\n #![feature(unsize)]"}, {"sha": "766006939fa48ccd14c37e482596424267c111dd", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -2780,7 +2780,7 @@ impl<T, A: Allocator> IntoIterator for Vec<T, A> {\n     /// assert_eq!(v_iter.next(), None);\n     /// ```\n     #[inline]\n-    fn into_iter(self) -> IntoIter<T, A> {\n+    fn into_iter(self) -> Self::IntoIter {\n         unsafe {\n             let mut me = ManuallyDrop::new(self);\n             let alloc = ManuallyDrop::new(ptr::read(me.allocator()));\n@@ -2808,7 +2808,7 @@ impl<'a, T, A: Allocator> IntoIterator for &'a Vec<T, A> {\n     type Item = &'a T;\n     type IntoIter = slice::Iter<'a, T>;\n \n-    fn into_iter(self) -> slice::Iter<'a, T> {\n+    fn into_iter(self) -> Self::IntoIter {\n         self.iter()\n     }\n }\n@@ -2818,7 +2818,7 @@ impl<'a, T, A: Allocator> IntoIterator for &'a mut Vec<T, A> {\n     type Item = &'a mut T;\n     type IntoIter = slice::IterMut<'a, T>;\n \n-    fn into_iter(self) -> slice::IterMut<'a, T> {\n+    fn into_iter(self) -> Self::IntoIter {\n         self.iter_mut()\n     }\n }"}, {"sha": "9193c79bee875daf690d6f3af31e252cee70ff21", "filename": "library/core/benches/iter.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fiter.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,3 +1,4 @@\n+use core::borrow::Borrow;\n use core::iter::*;\n use core::mem;\n use core::num::Wrapping;\n@@ -403,13 +404,31 @@ fn bench_trusted_random_access_adapters(b: &mut Bencher) {\n \n /// Exercises the iter::Copied specialization for slice::Iter\n #[bench]\n-fn bench_copied_array_chunks(b: &mut Bencher) {\n+fn bench_copied_chunks(b: &mut Bencher) {\n+    let v = vec![1u8; 1024];\n+\n+    b.iter(|| {\n+        let mut iter = black_box(&v).iter().copied();\n+        let mut acc = Wrapping(0);\n+        // This uses a while-let loop to side-step the TRA specialization in ArrayChunks\n+        while let Ok(chunk) = iter.next_chunk::<{ mem::size_of::<u64>() }>() {\n+            let d = u64::from_ne_bytes(chunk);\n+            acc += Wrapping(d.rotate_left(7).wrapping_add(1));\n+        }\n+        acc\n+    })\n+}\n+\n+/// Exercises the TrustedRandomAccess specialization in ArrayChunks\n+#[bench]\n+fn bench_trusted_random_access_chunks(b: &mut Bencher) {\n     let v = vec![1u8; 1024];\n \n     b.iter(|| {\n         black_box(&v)\n             .iter()\n-            .copied()\n+            // this shows that we're not relying on the slice::Iter specialization in Copied\n+            .map(|b| *b.borrow())\n             .array_chunks::<{ mem::size_of::<u64>() }>()\n             .map(|ary| {\n                 let d = u64::from_ne_bytes(ary);"}, {"sha": "f1244d93285e30ba8777f0de2719eead94a960d2", "filename": "library/core/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,10 +1,10 @@\n // wasm32 does not support benches (no time).\n #![cfg(not(target_arch = \"wasm32\"))]\n #![feature(flt2dec)]\n-#![feature(int_log)]\n #![feature(test)]\n #![feature(trusted_random_access)]\n #![feature(iter_array_chunks)]\n+#![feature(iter_next_chunk)]\n \n extern crate test;\n "}, {"sha": "2090756d7a3ec82252be10dc39e91d16cdff1234", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 52, "deletions": 23, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -865,24 +865,6 @@ where\n         return Ok(Try::from_output(unsafe { mem::zeroed() }));\n     }\n \n-    struct Guard<'a, T, const N: usize> {\n-        array_mut: &'a mut [MaybeUninit<T>; N],\n-        initialized: usize,\n-    }\n-\n-    impl<T, const N: usize> Drop for Guard<'_, T, N> {\n-        fn drop(&mut self) {\n-            debug_assert!(self.initialized <= N);\n-\n-            // SAFETY: this slice will contain only initialized objects.\n-            unsafe {\n-                crate::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n-                    &mut self.array_mut.get_unchecked_mut(..self.initialized),\n-                ));\n-            }\n-        }\n-    }\n-\n     let mut array = MaybeUninit::uninit_array::<N>();\n     let mut guard = Guard { array_mut: &mut array, initialized: 0 };\n \n@@ -896,13 +878,11 @@ where\n                     ControlFlow::Continue(elem) => elem,\n                 };\n \n-                // SAFETY: `guard.initialized` starts at 0, is increased by one in the\n-                // loop and the loop is aborted once it reaches N (which is\n-                // `array.len()`).\n+                // SAFETY: `guard.initialized` starts at 0, which means push can be called\n+                // at most N times, which this loop does.\n                 unsafe {\n-                    guard.array_mut.get_unchecked_mut(guard.initialized).write(item);\n+                    guard.push_unchecked(item);\n                 }\n-                guard.initialized += 1;\n             }\n             None => {\n                 let alive = 0..guard.initialized;\n@@ -920,6 +900,55 @@ where\n     Ok(Try::from_output(output))\n }\n \n+/// Panic guard for incremental initialization of arrays.\n+///\n+/// Disarm the guard with `mem::forget` once the array has been initialized.\n+///\n+/// # Safety\n+///\n+/// All write accesses to this structure are unsafe and must maintain a correct\n+/// count of `initialized` elements.\n+///\n+/// To minimize indirection fields are still pub but callers should at least use\n+/// `push_unchecked` to signal that something unsafe is going on.\n+pub(crate) struct Guard<'a, T, const N: usize> {\n+    /// The array to be initialized.\n+    pub array_mut: &'a mut [MaybeUninit<T>; N],\n+    /// The number of items that have been initialized so far.\n+    pub initialized: usize,\n+}\n+\n+impl<T, const N: usize> Guard<'_, T, N> {\n+    /// Adds an item to the array and updates the initialized item counter.\n+    ///\n+    /// # Safety\n+    ///\n+    /// No more than N elements must be initialized.\n+    #[inline]\n+    pub unsafe fn push_unchecked(&mut self, item: T) {\n+        // SAFETY: If `initialized` was correct before and the caller does not\n+        // invoke this method more than N times then writes will be in-bounds\n+        // and slots will not be initialized more than once.\n+        unsafe {\n+            self.array_mut.get_unchecked_mut(self.initialized).write(item);\n+            self.initialized = self.initialized.unchecked_add(1);\n+        }\n+    }\n+}\n+\n+impl<T, const N: usize> Drop for Guard<'_, T, N> {\n+    fn drop(&mut self) {\n+        debug_assert!(self.initialized <= N);\n+\n+        // SAFETY: this slice will contain only initialized objects.\n+        unsafe {\n+            crate::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n+                &mut self.array_mut.get_unchecked_mut(..self.initialized),\n+            ));\n+        }\n+    }\n+}\n+\n /// Returns the next chunk of `N` items from the iterator or errors with an\n /// iterator over the remainder. Used for `Iterator::next_chunk`.\n #[inline]"}, {"sha": "f2975d054572cee34e28c0b8954ff7ec99a5a5f6", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1936,7 +1936,7 @@ impl<T> UnsafeCell<T> {\n     /// Constructs a new instance of `UnsafeCell` which will wrap the specified\n     /// value.\n     ///\n-    /// All access to the inner value through methods is `unsafe`.\n+    /// All access to the inner value through `&UnsafeCell<T>` requires `unsafe` code.\n     ///\n     /// # Examples\n     ///"}, {"sha": "151c8e6d8986ab58f0baaebb17bcb07ca6748563", "filename": "library/core/src/const_closure.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fconst_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fconst_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconst_closure.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,4 +1,6 @@\n use crate::marker::Destruct;\n+#[cfg(not(bootstrap))]\n+use crate::marker::Tuple;\n \n /// Struct representing a closure with mutably borrowed data.\n ///\n@@ -44,6 +46,7 @@ impl<'a, CapturedData: ?Sized, Function> ConstFnMutClosure<&'a mut CapturedData,\n \n macro_rules! impl_fn_mut_tuple {\n     ($($var:ident)*) => {\n+        #[cfg(bootstrap)]\n         #[allow(unused_parens)]\n         impl<'a, $($var,)* ClosureArguments, Function, ClosureReturnValue> const\n             FnOnce<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n@@ -56,6 +59,7 @@ macro_rules! impl_fn_mut_tuple {\n             self.call_mut(args)\n             }\n         }\n+        #[cfg(bootstrap)]\n         #[allow(unused_parens)]\n         impl<'a, $($var,)* ClosureArguments, Function, ClosureReturnValue> const\n             FnMut<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n@@ -68,6 +72,32 @@ macro_rules! impl_fn_mut_tuple {\n                 (self.func)(($($var),*), args)\n             }\n         }\n+        #[cfg(not(bootstrap))]\n+        #[allow(unused_parens)]\n+        impl<'a, $($var,)* ClosureArguments: Tuple, Function, ClosureReturnValue> const\n+            FnOnce<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n+        where\n+            Function: ~const Fn(($(&mut $var),*), ClosureArguments) -> ClosureReturnValue+ ~const Destruct,\n+        {\n+            type Output = ClosureReturnValue;\n+\n+            extern \"rust-call\" fn call_once(mut self, args: ClosureArguments) -> Self::Output {\n+            self.call_mut(args)\n+            }\n+        }\n+        #[cfg(not(bootstrap))]\n+        #[allow(unused_parens)]\n+        impl<'a, $($var,)* ClosureArguments: Tuple, Function, ClosureReturnValue> const\n+            FnMut<ClosureArguments> for ConstFnMutClosure<($(&'a mut $var),*), Function>\n+        where\n+            Function: ~const Fn(($(&mut $var),*), ClosureArguments)-> ClosureReturnValue,\n+        {\n+            extern \"rust-call\" fn call_mut(&mut self, args: ClosureArguments) -> Self::Output {\n+                #[allow(non_snake_case)]\n+                let ($($var),*) = &mut self.data;\n+                (self.func)(($($var),*), args)\n+            }\n+        }\n     };\n }\n impl_fn_mut_tuple!(A);"}, {"sha": "cec603dcb10edc8718f677f9ef5cd7d5563a2c12", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -55,8 +55,13 @@\n #![allow(missing_docs)]\n \n use crate::marker::DiscriminantKind;\n+#[cfg(not(bootstrap))]\n+use crate::marker::Tuple;\n use crate::mem;\n \n+#[cfg(not(bootstrap))]\n+pub mod mir;\n+\n // These imports are used for simplifying intra-doc links\n #[allow(unused_imports)]\n #[cfg(all(target_has_atomic = \"8\", target_has_atomic = \"32\", target_has_atomic = \"ptr\"))]\n@@ -2169,11 +2174,75 @@ extern \"rust-intrinsic\" {\n     /// `unreachable_unchecked` is actually being reached. The bug is in *crate A*,\n     /// which violates the principle that a `const fn` must behave the same at\n     /// compile-time and at run-time. The unsafe code in crate B is fine.\n+    #[cfg(bootstrap)]\n     #[rustc_const_unstable(feature = \"const_eval_select\", issue = \"none\")]\n     pub fn const_eval_select<ARG, F, G, RET>(arg: ARG, called_in_const: F, called_at_rt: G) -> RET\n     where\n         G: FnOnce<ARG, Output = RET>,\n         F: FnOnce<ARG, Output = RET>;\n+\n+    /// Selects which function to call depending on the context.\n+    ///\n+    /// If this function is evaluated at compile-time, then a call to this\n+    /// intrinsic will be replaced with a call to `called_in_const`. It gets\n+    /// replaced with a call to `called_at_rt` otherwise.\n+    ///\n+    /// # Type Requirements\n+    ///\n+    /// The two functions must be both function items. They cannot be function\n+    /// pointers or closures. The first function must be a `const fn`.\n+    ///\n+    /// `arg` will be the tupled arguments that will be passed to either one of\n+    /// the two functions, therefore, both functions must accept the same type of\n+    /// arguments. Both functions must return RET.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The two functions must behave observably equivalent. Safe code in other\n+    /// crates may assume that calling a `const fn` at compile-time and at run-time\n+    /// produces the same result. A function that produces a different result when\n+    /// evaluated at run-time, or has any other observable side-effects, is\n+    /// *unsound*.\n+    ///\n+    /// Here is an example of how this could cause a problem:\n+    /// ```no_run\n+    /// #![feature(const_eval_select)]\n+    /// #![feature(core_intrinsics)]\n+    /// use std::hint::unreachable_unchecked;\n+    /// use std::intrinsics::const_eval_select;\n+    ///\n+    /// // Crate A\n+    /// pub const fn inconsistent() -> i32 {\n+    ///     fn runtime() -> i32 { 1 }\n+    ///     const fn compiletime() -> i32 { 2 }\n+    ///\n+    ///     unsafe {\n+    //          // \u26a0 This code violates the required equivalence of `compiletime`\n+    ///         // and `runtime`.\n+    ///         const_eval_select((), compiletime, runtime)\n+    ///     }\n+    /// }\n+    ///\n+    /// // Crate B\n+    /// const X: i32 = inconsistent();\n+    /// let x = inconsistent();\n+    /// if x != X { unsafe { unreachable_unchecked(); }}\n+    /// ```\n+    ///\n+    /// This code causes Undefined Behavior when being run, since the\n+    /// `unreachable_unchecked` is actually being reached. The bug is in *crate A*,\n+    /// which violates the principle that a `const fn` must behave the same at\n+    /// compile-time and at run-time. The unsafe code in crate B is fine.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_unstable(feature = \"const_eval_select\", issue = \"none\")]\n+    pub fn const_eval_select<ARG: Tuple, F, G, RET>(\n+        arg: ARG,\n+        called_in_const: F,\n+        called_at_rt: G,\n+    ) -> RET\n+    where\n+        G: FnOnce<ARG, Output = RET>,\n+        F: FnOnce<ARG, Output = RET>;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "1bacdc39148a1cef5e79673cd9379366eddf98c0", "filename": "library/core/src/intrinsics/mir.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -0,0 +1,123 @@\n+//! Rustc internal tooling for hand-writing MIR.\n+//!\n+//! If for some reasons you are not writing rustc tests and have found yourself considering using\n+//! this feature, turn back. This is *exceptionally* unstable. There is no attempt at all to make\n+//! anything work besides those things which the rustc test suite happened to need. If you make a\n+//! typo you'll probably ICE. Really, this is not the solution to your problems. Consider instead\n+//! supporting the [stable MIR project group](https://github.com/rust-lang/project-stable-mir).\n+//!\n+//! The documentation for this module describes how to use this feature. If you are interested in\n+//! hacking on the implementation, most of that documentation lives at\n+//! `rustc_mir_building/src/build/custom/mod.rs`.\n+//!\n+//! Typical usage will look like this:\n+//!\n+//! ```rust\n+//! #![feature(core_intrinsics, custom_mir)]\n+//!\n+//! extern crate core;\n+//! use core::intrinsics::mir::*;\n+//!\n+//! #[custom_mir(dialect = \"built\")]\n+//! pub fn simple(x: i32) -> i32 {\n+//!     mir!(\n+//!         let temp1: i32;\n+//!         let temp2: _;\n+//!\n+//!         {\n+//!             temp1 = x;\n+//!             Goto(exit)\n+//!         }\n+//!\n+//!         exit = {\n+//!             temp2 = Move(temp1);\n+//!             RET = temp2;\n+//!             Return()\n+//!         }\n+//!     )\n+//! }\n+//! ```\n+//!\n+//! Hopefully most of this is fairly self-explanatory. Expanding on some notable details:\n+//!\n+//!  - The `custom_mir` attribute tells the compiler to treat the function as being custom MIR. This\n+//!    attribute only works on functions - there is no way to insert custom MIR into the middle of\n+//!    another function.\n+//!  - The `dialect` and `phase` parameters indicate which version of MIR you are inserting here.\n+//!    This will normally be the phase that corresponds to the thing you are trying to test. The\n+//!    phase can be omitted for dialects that have just one.\n+//!  - You should define your function signature like you normally would. Externally, this function\n+//!    can be called like any other function.\n+//!  - Type inference works - you don't have to spell out the type of all of your locals.\n+//!\n+//! For now, all statements and terminators are parsed from nested invocations of the special\n+//! functions provided in this module. We additionally want to (but do not yet) support more\n+//! \"normal\" Rust syntax in places where it makes sense. Also, most kinds of instructions are not\n+//! supported yet.\n+//!\n+\n+#![unstable(\n+    feature = \"custom_mir\",\n+    reason = \"MIR is an implementation detail and extremely unstable\",\n+    issue = \"none\"\n+)]\n+#![allow(unused_variables, non_snake_case, missing_debug_implementations)]\n+\n+/// Type representing basic blocks.\n+///\n+/// All terminators will have this type as a return type. It helps achieve some type safety.\n+pub struct BasicBlock;\n+\n+macro_rules! define {\n+    ($name:literal, $($sig:tt)*) => {\n+        #[rustc_diagnostic_item = $name]\n+        pub $($sig)* { panic!() }\n+    }\n+}\n+\n+define!(\"mir_return\", fn Return() -> BasicBlock);\n+define!(\"mir_goto\", fn Goto(destination: BasicBlock) -> BasicBlock);\n+define!(\"mir_retag\", fn Retag<T>(place: T));\n+define!(\"mir_retag_raw\", fn RetagRaw<T>(place: T));\n+define!(\"mir_move\", fn Move<T>(place: T) -> T);\n+\n+/// Convenience macro for generating custom MIR.\n+///\n+/// See the module documentation for syntax details. This macro is not magic - it only transforms\n+/// your MIR into something that is easier to parse in the compiler.\n+#[rustc_macro_transparency = \"transparent\"]\n+pub macro mir {\n+    (\n+        $(let $local_decl:ident $(: $local_decl_ty:ty)? ;)*\n+\n+        $entry_block:block\n+\n+        $(\n+            $block_name:ident = $block:block\n+        )*\n+    ) => {{\n+        // First, we declare all basic blocks.\n+        $(\n+            let $block_name: ::core::intrinsics::mir::BasicBlock;\n+        )*\n+\n+        {\n+            // Now all locals\n+            #[allow(non_snake_case)]\n+            let RET;\n+            $(\n+                let $local_decl $(: $local_decl_ty)? ;\n+            )*\n+\n+            {\n+                // Finally, the contents of the basic blocks\n+                $entry_block;\n+                $(\n+                    $block;\n+                )*\n+\n+                RET\n+            }\n+        }\n+    }}\n+}"}, {"sha": "5e4211058aa6f2b8bcd0182ef18fc340f54c771d", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,6 +1,8 @@\n use crate::array;\n-use crate::iter::{ByRefSized, FusedIterator, Iterator};\n-use crate::ops::{ControlFlow, Try};\n+use crate::const_closure::ConstFnMutClosure;\n+use crate::iter::{ByRefSized, FusedIterator, Iterator, TrustedRandomAccessNoCoerce};\n+use crate::mem::{self, MaybeUninit};\n+use crate::ops::{ControlFlow, NeverShortCircuit, Try};\n \n /// An iterator over `N` elements of the iterator at a time.\n ///\n@@ -82,7 +84,13 @@ where\n         }\n     }\n \n-    impl_fold_via_try_fold! { fold -> try_fold }\n+    fn fold<B, F>(self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        <Self as SpecFold>::fold(self, init, f)\n+    }\n }\n \n #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n@@ -168,3 +176,64 @@ where\n         self.iter.len() < N\n     }\n }\n+\n+trait SpecFold: Iterator {\n+    fn fold<B, F>(self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B;\n+}\n+\n+impl<I, const N: usize> SpecFold for ArrayChunks<I, N>\n+where\n+    I: Iterator,\n+{\n+    #[inline]\n+    default fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        let fold = ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp);\n+        self.try_fold(init, fold).0\n+    }\n+}\n+\n+impl<I, const N: usize> SpecFold for ArrayChunks<I, N>\n+where\n+    I: Iterator + TrustedRandomAccessNoCoerce,\n+{\n+    #[inline]\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        let mut accum = init;\n+        let inner_len = self.iter.size();\n+        let mut i = 0;\n+        // Use a while loop because (0..len).step_by(N) doesn't optimize well.\n+        while inner_len - i >= N {\n+            let mut chunk = MaybeUninit::uninit_array();\n+            let mut guard = array::Guard { array_mut: &mut chunk, initialized: 0 };\n+            while guard.initialized < N {\n+                // SAFETY: The method consumes the iterator and the loop condition ensures that\n+                // all accesses are in bounds and only happen once.\n+                unsafe {\n+                    let idx = i + guard.initialized;\n+                    guard.push_unchecked(self.iter.__iterator_get_unchecked(idx));\n+                }\n+            }\n+            mem::forget(guard);\n+            // SAFETY: The loop above initialized all elements\n+            let chunk = unsafe { MaybeUninit::array_assume_init(chunk) };\n+            accum = f(accum, chunk);\n+            i += N;\n+        }\n+\n+        // unlike try_fold this method does not need to take care of the remainder\n+        // since `self` will be dropped\n+\n+        accum\n+    }\n+}"}, {"sha": "404ddff4f9dab44cde4497c18671480afce09bd4", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -2271,15 +2271,16 @@ macro_rules! int_impl {\n         /// # Panics\n         ///\n         /// This function will panic if `self` is less than or equal to zero,\n-        /// or if `base` is less then 2.\n+        /// or if `base` is less than 2.\n         ///\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2298,10 +2299,11 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2319,10 +2321,11 @@ macro_rules! int_impl {\n         /// # Example\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2343,10 +2346,10 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2379,10 +2382,10 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -2403,10 +2406,10 @@ macro_rules! int_impl {\n         /// # Example\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "5b7521220acdb2d99ac15aeac715d45c7d4cde1b", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -460,14 +460,14 @@ macro_rules! nonzero_unsigned_operations {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(int_log)]\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(7).unwrap().ilog2(), 2);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(8).unwrap().ilog2(), 3);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(9).unwrap().ilog2(), 3);\")]\n                 /// ```\n-                #[unstable(feature = \"int_log\", issue = \"70887\")]\n+                #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n                 #[must_use = \"this returns the result of the operation, \\\n                               without modifying the original\"]\n                 #[inline]\n@@ -485,14 +485,14 @@ macro_rules! nonzero_unsigned_operations {\n                 /// # Examples\n                 ///\n                 /// ```\n-                /// #![feature(int_log)]\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(99).unwrap().ilog10(), 1);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(100).unwrap().ilog10(), 2);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(101).unwrap().ilog10(), 2);\")]\n                 /// ```\n-                #[unstable(feature = \"int_log\", issue = \"70887\")]\n+                #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+                #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n                 #[must_use = \"this returns the result of the operation, \\\n                               without modifying the original\"]\n                 #[inline]"}, {"sha": "0563f28278d36e8da710808b0cf6ac7246632be2", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -692,15 +692,16 @@ macro_rules! uint_impl {\n         ///\n         /// # Panics\n         ///\n-        /// This function will panic if `self` is zero, or if `base` is less then 2.\n+        /// This function will panic if `self` is zero, or if `base` is less than 2.\n         ///\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -719,10 +720,11 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -740,10 +742,11 @@ macro_rules! uint_impl {\n         /// # Example\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_allow_const_fn_unstable(const_option)]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -764,10 +767,10 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -800,10 +803,10 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -822,10 +825,10 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_log)]\n         #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n         /// ```\n-        #[unstable(feature = \"int_log\", issue = \"70887\")]\n+        #[stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n+        #[rustc_const_stable(feature = \"int_log\", since = \"CURRENT_RUSTC_VERSION\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "11b43b621c7b883029cbc6d8b9db546bc21d72d0", "filename": "library/core/src/ops/function.rs", "status": "modified", "additions": 326, "deletions": 3, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,3 +1,6 @@\n+#[cfg(not(bootstrap))]\n+use crate::marker::Tuple;\n+\n /// The version of the call operator that takes an immutable receiver.\n ///\n /// Instances of `Fn` can be called repeatedly without mutating state.\n@@ -51,6 +54,7 @@\n /// let double = |x| x * 2;\n /// assert_eq!(call_with_one(double), 2);\n /// ```\n+#[cfg(bootstrap)]\n #[lang = \"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"Fn\"]\n@@ -71,13 +75,93 @@\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n-#[cfg_attr(not(bootstrap), const_trait)]\n pub trait Fn<Args>: FnMut<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n }\n \n+/// The version of the call operator that takes an immutable receiver.\n+///\n+/// Instances of `Fn` can be called repeatedly without mutating state.\n+///\n+/// *This trait (`Fn`) is not to be confused with [function pointers]\n+/// (`fn`).*\n+///\n+/// `Fn` is implemented automatically by closures which only take immutable\n+/// references to captured variables or don't capture anything at all, as well\n+/// as (safe) [function pointers] (with some caveats, see their documentation\n+/// for more details). Additionally, for any type `F` that implements `Fn`, `&F`\n+/// implements `Fn`, too.\n+///\n+/// Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\n+/// instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`]\n+/// is expected.\n+///\n+/// Use `Fn` as a bound when you want to accept a parameter of function-like\n+/// type and need to call it repeatedly and without mutating state (e.g., when\n+/// calling it concurrently). If you do not need such strict requirements, use\n+/// [`FnMut`] or [`FnOnce`] as bounds.\n+///\n+/// See the [chapter on closures in *The Rust Programming Language*][book] for\n+/// some more information on this topic.\n+///\n+/// Also of note is the special syntax for `Fn` traits (e.g.\n+/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n+///\n+/// [book]: ../../book/ch13-01-closures.html\n+/// [function pointers]: fn\n+/// [nomicon]: ../../nomicon/hrtb.html\n+///\n+/// # Examples\n+///\n+/// ## Calling a closure\n+///\n+/// ```\n+/// let square = |x| x * x;\n+/// assert_eq!(square(5), 25);\n+/// ```\n+///\n+/// ## Using a `Fn` parameter\n+///\n+/// ```\n+/// fn call_with_one<F>(func: F) -> usize\n+///     where F: Fn(usize) -> usize {\n+///     func(1)\n+/// }\n+///\n+/// let double = |x| x * 2;\n+/// assert_eq!(call_with_one(double), 2);\n+/// ```\n+#[cfg(not(bootstrap))]\n+#[lang = \"fn\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"Fn\"]\n+#[rustc_paren_sugar]\n+#[rustc_on_unimplemented(\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n+    ),\n+    on(\n+        _Self = \"unsafe fn\",\n+        note = \"unsafe function cannot be called generically without an unsafe block\",\n+        // SAFETY: tidy is not smart enough to tell that the below unsafe block is a string\n+        label = \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"\n+    ),\n+    message = \"expected a `{Fn}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `Fn<{Args}>` closure, found `{Self}`\"\n+)]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n+#[must_use = \"closures are lazy and do nothing unless called\"]\n+#[const_trait]\n+pub trait Fn<Args: Tuple>: FnMut<Args> {\n+    /// Performs the call operation.\n+    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n+\n /// The version of the call operator that takes a mutable receiver.\n ///\n /// Instances of `FnMut` can be called repeatedly and may mutate state.\n@@ -139,6 +223,7 @@ pub trait Fn<Args>: FnMut<Args> {\n ///\n /// assert_eq!(x, 5);\n /// ```\n+#[cfg(bootstrap)]\n #[lang = \"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"FnMut\"]\n@@ -159,13 +244,101 @@ pub trait Fn<Args>: FnMut<Args> {\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n-#[cfg_attr(not(bootstrap), const_trait)]\n pub trait FnMut<Args>: FnOnce<Args> {\n     /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n+/// The version of the call operator that takes a mutable receiver.\n+///\n+/// Instances of `FnMut` can be called repeatedly and may mutate state.\n+///\n+/// `FnMut` is implemented automatically by closures which take mutable\n+/// references to captured variables, as well as all types that implement\n+/// [`Fn`], e.g., (safe) [function pointers] (since `FnMut` is a supertrait of\n+/// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\n+/// implements `FnMut`, too.\n+///\n+/// Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be\n+/// used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of\n+/// `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.\n+///\n+/// Use `FnMut` as a bound when you want to accept a parameter of function-like\n+/// type and need to call it repeatedly, while allowing it to mutate state.\n+/// If you don't want the parameter to mutate state, use [`Fn`] as a\n+/// bound; if you don't need to call it repeatedly, use [`FnOnce`].\n+///\n+/// See the [chapter on closures in *The Rust Programming Language*][book] for\n+/// some more information on this topic.\n+///\n+/// Also of note is the special syntax for `Fn` traits (e.g.\n+/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n+///\n+/// [book]: ../../book/ch13-01-closures.html\n+/// [function pointers]: fn\n+/// [nomicon]: ../../nomicon/hrtb.html\n+///\n+/// # Examples\n+///\n+/// ## Calling a mutably capturing closure\n+///\n+/// ```\n+/// let mut x = 5;\n+/// {\n+///     let mut square_x = || x *= x;\n+///     square_x();\n+/// }\n+/// assert_eq!(x, 25);\n+/// ```\n+///\n+/// ## Using a `FnMut` parameter\n+///\n+/// ```\n+/// fn do_twice<F>(mut func: F)\n+///     where F: FnMut()\n+/// {\n+///     func();\n+///     func();\n+/// }\n+///\n+/// let mut x: usize = 1;\n+/// {\n+///     let add_two_to_x = || x += 2;\n+///     do_twice(add_two_to_x);\n+/// }\n+///\n+/// assert_eq!(x, 5);\n+/// ```\n+#[cfg(not(bootstrap))]\n+#[lang = \"fn_mut\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"FnMut\"]\n+#[rustc_paren_sugar]\n+#[rustc_on_unimplemented(\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n+    ),\n+    on(\n+        _Self = \"unsafe fn\",\n+        note = \"unsafe function cannot be called generically without an unsafe block\",\n+        // SAFETY: tidy is not smart enough to tell that the below unsafe block is a string\n+        label = \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"\n+    ),\n+    message = \"expected a `{FnMut}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `FnMut<{Args}>` closure, found `{Self}`\"\n+)]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n+#[must_use = \"closures are lazy and do nothing unless called\"]\n+#[const_trait]\n+pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n+    /// Performs the call operation.\n+    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n /// The version of the call operator that takes a by-value receiver.\n ///\n /// Instances of `FnOnce` can be called, but might not be callable multiple\n@@ -219,6 +392,7 @@ pub trait FnMut<Args>: FnOnce<Args> {\n ///\n /// // `consume_and_return_x` can no longer be invoked at this point\n /// ```\n+#[cfg(bootstrap)]\n #[lang = \"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_diagnostic_item = \"FnOnce\"]\n@@ -239,7 +413,6 @@ pub trait FnMut<Args>: FnOnce<Args> {\n )]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n #[must_use = \"closures are lazy and do nothing unless called\"]\n-#[cfg_attr(not(bootstrap), const_trait)]\n pub trait FnOnce<Args> {\n     /// The returned type after the call operator is used.\n     #[lang = \"fn_once_output\"]\n@@ -251,6 +424,93 @@ pub trait FnOnce<Args> {\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n \n+/// The version of the call operator that takes a by-value receiver.\n+///\n+/// Instances of `FnOnce` can be called, but might not be callable multiple\n+/// times. Because of this, if the only thing known about a type is that it\n+/// implements `FnOnce`, it can only be called once.\n+///\n+/// `FnOnce` is implemented automatically by closures that might consume captured\n+/// variables, as well as all types that implement [`FnMut`], e.g., (safe)\n+/// [function pointers] (since `FnOnce` is a supertrait of [`FnMut`]).\n+///\n+/// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n+/// [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n+///\n+/// Use `FnOnce` as a bound when you want to accept a parameter of function-like\n+/// type and only need to call it once. If you need to call the parameter\n+/// repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate\n+/// state, use [`Fn`].\n+///\n+/// See the [chapter on closures in *The Rust Programming Language*][book] for\n+/// some more information on this topic.\n+///\n+/// Also of note is the special syntax for `Fn` traits (e.g.\n+/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n+///\n+/// [book]: ../../book/ch13-01-closures.html\n+/// [function pointers]: fn\n+/// [nomicon]: ../../nomicon/hrtb.html\n+///\n+/// # Examples\n+///\n+/// ## Using a `FnOnce` parameter\n+///\n+/// ```\n+/// fn consume_with_relish<F>(func: F)\n+///     where F: FnOnce() -> String\n+/// {\n+///     // `func` consumes its captured variables, so it cannot be run more\n+///     // than once.\n+///     println!(\"Consumed: {}\", func());\n+///\n+///     println!(\"Delicious!\");\n+///\n+///     // Attempting to invoke `func()` again will throw a `use of moved\n+///     // value` error for `func`.\n+/// }\n+///\n+/// let x = String::from(\"x\");\n+/// let consume_and_return_x = move || x;\n+/// consume_with_relish(consume_and_return_x);\n+///\n+/// // `consume_and_return_x` can no longer be invoked at this point\n+/// ```\n+#[cfg(not(bootstrap))]\n+#[lang = \"fn_once\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"FnOnce\"]\n+#[rustc_paren_sugar]\n+#[rustc_on_unimplemented(\n+    on(\n+        Args = \"()\",\n+        note = \"wrap the `{Self}` in a closure with no arguments: `|| {{ /* code */ }}`\"\n+    ),\n+    on(\n+        _Self = \"unsafe fn\",\n+        note = \"unsafe function cannot be called generically without an unsafe block\",\n+        // SAFETY: tidy is not smart enough to tell that the below unsafe block is a string\n+        label = \"call the function in a closure: `|| unsafe {{ /* code */ }}`\"\n+    ),\n+    message = \"expected a `{FnOnce}<{Args}>` closure, found `{Self}`\",\n+    label = \"expected an `FnOnce<{Args}>` closure, found `{Self}`\"\n+)]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n+#[must_use = \"closures are lazy and do nothing unless called\"]\n+#[const_trait]\n+pub trait FnOnce<Args: Tuple> {\n+    /// The returned type after the call operator is used.\n+    #[lang = \"fn_once_output\"]\n+    #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n+    type Output;\n+\n+    /// Performs the call operation.\n+    #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+#[cfg(bootstrap)]\n mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n@@ -310,3 +570,66 @@ mod impls {\n         }\n     }\n }\n+\n+#[cfg(not(bootstrap))]\n+mod impls {\n+    use crate::marker::Tuple;\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+    impl<A: Tuple, F: ?Sized> const Fn<A> for &F\n+    where\n+        F: ~const Fn<A>,\n+    {\n+        extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n+            (**self).call(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+    impl<A: Tuple, F: ?Sized> const FnMut<A> for &F\n+    where\n+        F: ~const Fn<A>,\n+    {\n+        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+            (**self).call(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+    impl<A: Tuple, F: ?Sized> const FnOnce<A> for &F\n+    where\n+        F: ~const Fn<A>,\n+    {\n+        type Output = F::Output;\n+\n+        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n+            (*self).call(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+    impl<A: Tuple, F: ?Sized> const FnMut<A> for &mut F\n+    where\n+        F: ~const FnMut<A>,\n+    {\n+        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+            (*self).call_mut(args)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_fn_trait_ref_impls\", issue = \"101803\")]\n+    impl<A: Tuple, F: ?Sized> const FnOnce<A> for &mut F\n+    where\n+        F: ~const FnMut<A>,\n+    {\n+        type Output = F::Output;\n+        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n+            (*self).call_mut(args)\n+        }\n+    }\n+}"}, {"sha": "f0258640e2aec4c508b421cdd87d031e34adfa9a", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1059,7 +1059,7 @@ impl<P, U> DispatchFromDyn<Pin<U>> for Pin<P> where P: DispatchFromDyn<U> {}\n /// 8  | let x: Pin<&mut Foo> = {\n ///    |     - borrow later stored here\n /// 9  |     let x: Pin<&mut Foo> = pin!(Foo { /* \u2026 */ });\n-///    |                            ^^^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n+///    |                            ^^^^^^^^^^^^^^^^^^^^^ creates a temporary value which is freed while still in use\n /// 10 |     x\n /// 11 | }; // <- Foo is dropped\n ///    | - temporary value is freed at the end of this statement"}, {"sha": "926d2ae51139864944c44d843ba81f6c176d9bd5", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -568,6 +568,31 @@ impl<T: ?Sized> *const T {\n     ///\n     /// For non-`Sized` pointees this operation changes only the data pointer,\n     /// leaving the metadata untouched.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```\n+    /// #![feature(ptr_mask, strict_provenance)]\n+    /// let v = 17_u32;\n+    /// let ptr: *const u32 = &v;\n+    ///\n+    /// // `u32` is 4 bytes aligned,\n+    /// // which means that lower 2 bits are always 0.\n+    /// let tag_mask = 0b11;\n+    /// let ptr_mask = !tag_mask;\n+    ///\n+    /// // We can store something in these lower bits\n+    /// let tagged_ptr = ptr.map_addr(|a| a | 0b10);\n+    ///\n+    /// // Get the \"tag\" back\n+    /// let tag = tagged_ptr.addr() & tag_mask;\n+    /// assert_eq!(tag, 0b10);\n+    ///\n+    /// // Note that `tagged_ptr` is unaligned, it's UB to read from it.\n+    /// // To get original pointer `mask` can be used:\n+    /// let masked_ptr = tagged_ptr.mask(ptr_mask);\n+    /// assert_eq!(unsafe { *masked_ptr }, 17);\n+    /// ```\n     #[unstable(feature = \"ptr_mask\", issue = \"98290\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[inline(always)]"}, {"sha": "f71696e9ca0fa9e1b072d6e0f31c1386cc6508e3", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -588,6 +588,34 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// For non-`Sized` pointees this operation changes only the data pointer,\n     /// leaving the metadata untouched.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```\n+    /// #![feature(ptr_mask, strict_provenance)]\n+    /// let mut v = 17_u32;\n+    /// let ptr: *mut u32 = &mut v;\n+    ///\n+    /// // `u32` is 4 bytes aligned,\n+    /// // which means that lower 2 bits are always 0.\n+    /// let tag_mask = 0b11;\n+    /// let ptr_mask = !tag_mask;\n+    ///\n+    /// // We can store something in these lower bits\n+    /// let tagged_ptr = ptr.map_addr(|a| a | 0b10);\n+    ///\n+    /// // Get the \"tag\" back\n+    /// let tag = tagged_ptr.addr() & tag_mask;\n+    /// assert_eq!(tag, 0b10);\n+    ///\n+    /// // Note that `tagged_ptr` is unaligned, it's UB to read from/write to it.\n+    /// // To get original pointer `mask` can be used:\n+    /// let masked_ptr = tagged_ptr.mask(ptr_mask);\n+    /// assert_eq!(unsafe { *masked_ptr }, 17);\n+    ///\n+    /// unsafe { *masked_ptr = 0 };\n+    /// assert_eq!(v, 0);\n+    /// ```\n     #[unstable(feature = \"ptr_mask\", issue = \"98290\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[inline(always)]"}, {"sha": "0f58bc643d9655a8aaa299f61efcecf462a5d29e", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -3524,8 +3524,8 @@ impl<T> [T] {\n         }\n     }\n \n-    /// Transmute the slice to a slice of another type, ensuring alignment of the types is\n-    /// maintained.\n+    /// Transmute the mutable slice to a mutable slice of another type, ensuring alignment of the\n+    /// types is maintained.\n     ///\n     /// This method splits the slice into three distinct slices: prefix, correctly aligned middle\n     /// slice of a new type, and the suffix slice. The method may make the middle slice the greatest\n@@ -3667,7 +3667,8 @@ impl<T> [T] {\n         unsafe { self.align_to() }\n     }\n \n-    /// Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n+    /// Split a mutable slice into a mutable prefix, a middle of aligned SIMD types,\n+    /// and a mutable suffix.\n     ///\n     /// This is a safe wrapper around [`slice::align_to_mut`], so has the same weak\n     /// postconditions as that method.  You're only assured that"}, {"sha": "28275798f751ed16d151649d491985b0de83c7ac", "filename": "library/core/src/tuple.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Fsrc%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftuple.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -22,7 +22,8 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:PartialEq),+> PartialEq for ($($T,)+)\n+            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+            impl<$($T: ~const PartialEq),+> const PartialEq for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {\n@@ -40,7 +41,7 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Eq),+> Eq for ($($T,)+)\n+            impl<$($T: Eq),+> Eq for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {}\n@@ -49,7 +50,8 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:PartialOrd + PartialEq),+> PartialOrd for ($($T,)+)\n+            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+            impl<$($T: ~const PartialOrd + ~const PartialEq),+> const PartialOrd for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {\n@@ -79,7 +81,8 @@ macro_rules! tuple_impls {\n         maybe_tuple_doc! {\n             $($T)+ @\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            impl<$($T:Ord),+> Ord for ($($T,)+)\n+            #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+            impl<$($T: ~const Ord),+> const Ord for ($($T,)+)\n             where\n                 last_type!($($T,)+): ?Sized\n             {"}, {"sha": "ef4a7e53bdd339caa6f7b22fbfb37fb16927b201", "filename": "library/core/tests/iter/adapters/array_chunks.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -139,7 +139,8 @@ fn test_iterator_array_chunks_fold() {\n     let result =\n         (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>().fold(0, |acc, _item| acc + 1);\n     assert_eq!(result, 3);\n-    assert_eq!(count.get(), 10);\n+    // fold impls may or may not process the remainder\n+    assert!(count.get() <= 10 && count.get() >= 9);\n }\n \n #[test]"}, {"sha": "a7db2a02bd74383ad2e8cfa4fb800d52f7e8307a", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -64,7 +64,6 @@\n #![feature(try_trait_v2)]\n #![feature(slice_internals)]\n #![feature(slice_partition_dedup)]\n-#![feature(int_log)]\n #![feature(iter_advance_by)]\n #![feature(iter_array_chunks)]\n #![feature(iter_collect_into)]"}, {"sha": "daa6976c301431aeb6e579a00e6d26fd4146b4db", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -23,11 +23,11 @@ hashbrown = { version = \"0.12\", default-features = false, features = ['rustc-dep\n std_detect = { path = \"../stdarch/crates/std_detect\", default-features = false, features = ['rustc-dep-of-std'] }\n \n # Dependencies of the `backtrace` crate\n-addr2line = { version = \"0.16.0\", optional = true, default-features = false }\n+addr2line = { version = \"0.17.0\", optional = true, default-features = false }\n rustc-demangle = { version = \"0.1.21\", features = ['rustc-dep-of-std'] }\n-miniz_oxide = { version = \"0.4.0\", optional = true, default-features = false }\n+miniz_oxide = { version = \"0.5.0\", optional = true, default-features = false }\n [dependencies.object]\n-version = \"0.26.1\"\n+version = \"0.29.0\"\n optional = true\n default-features = false\n features = ['read_core', 'elf', 'macho', 'pe', 'unaligned', 'archive']"}, {"sha": "4127c4056f24ed8125bfe974439616a5394b1c53", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -77,9 +77,11 @@ impl f32 {\n     /// ```\n     /// let f = 3.3_f32;\n     /// let g = -3.3_f32;\n+    /// let h = -3.7_f32;\n     ///\n     /// assert_eq!(f.round(), 3.0);\n     /// assert_eq!(g.round(), -3.0);\n+    /// assert_eq!(h.round(), -4.0);\n     /// ```\n     #[rustc_allow_incoherent_impl]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]"}, {"sha": "cc64258da60d1a63fdc44ef0f72f41d07e2ab976", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -77,9 +77,11 @@ impl f64 {\n     /// ```\n     /// let f = 3.3_f64;\n     /// let g = -3.3_f64;\n+    /// let h = -3.7_f64;\n     ///\n     /// assert_eq!(f.round(), 3.0);\n     /// assert_eq!(g.round(), -3.0);\n+    /// assert_eq!(h.round(), -4.0);\n     /// ```\n     #[rustc_allow_incoherent_impl]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]"}, {"sha": "7322512e3b4585346b96d8b31bf29a94f673eb7c", "filename": "library/std/src/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -8,8 +8,15 @@\n //! method, and see the method for more information about it. Due to this\n //! caveat, this queue might not be appropriate for all use-cases.\n \n-// https://www.1024cores.net/home/lock-free-algorithms\n-//                          /queues/non-intrusive-mpsc-node-based-queue\n+// The original implementation is based off:\n+// https://www.1024cores.net/home/lock-free-algorithms/queues/non-intrusive-mpsc-node-based-queue\n+//\n+// Note that back when the code was imported, it was licensed under the BSD-2-Clause license:\n+// http://web.archive.org/web/20110411011612/https://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n+//\n+// The original author of the code agreed to relicense it under `MIT OR Apache-2.0` in 2017, so as\n+// of today the license of this file is the same as the rest of the codebase:\n+// https://github.com/rust-lang/rust/pull/42149\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;"}, {"sha": "61f91313ea96d79f645c4cfee272826ee5947de3", "filename": "library/std/src/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -4,7 +4,15 @@\n //! concurrently between two threads. This data structure is safe to use and\n //! enforces the semantics that there is one pusher and one popper.\n \n+// The original implementation is based off:\n // https://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n+//\n+// Note that back when the code was imported, it was licensed under the BSD-2-Clause license:\n+// http://web.archive.org/web/20110411011612/https://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n+//\n+// The original author of the code agreed to relicense it under `MIT OR Apache-2.0` in 2017, so as\n+// of today the license of this file is the same as the rest of the codebase:\n+// https://github.com/rust-lang/rust/pull/42149\n \n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;"}, {"sha": "32c0ef3e11688ebff944201ee8891608eaf91939", "filename": "library/unwind/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Funwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/library%2Funwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flib.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -15,7 +15,6 @@ cfg_if::cfg_if! {\n         target_os = \"espidf\",\n     ))] {\n         // These \"unix\" family members do not have unwinder.\n-        // Note this also matches x86_64-unknown-none-linuxkernel.\n     } else if #[cfg(any(\n         unix,\n         windows,"}, {"sha": "e1a108cea9574a6a772ce946215cef328a8facf1", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 66, "deletions": 9, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -224,13 +224,13 @@ dependencies = [\n \n [[package]]\n name = \"fd-lock\"\n-version = \"3.0.6\"\n+version = \"3.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e11dcc7e4d79a8c89b9ab4c6f5c30b1fc4a83c420792da3542fd31179ed5f517\"\n+checksum = \"0c93a581058d957dc4176875aad04f82f81613e6611d64aa1a9c755bdfb16711\"\n dependencies = [\n  \"cfg-if\",\n  \"rustix\",\n- \"windows-sys\",\n+ \"windows-sys 0.42.0\",\n ]\n \n [[package]]\n@@ -528,7 +528,7 @@ dependencies = [\n  \"io-lifetimes\",\n  \"libc\",\n  \"linux-raw-sys\",\n- \"windows-sys\",\n+ \"windows-sys 0.36.1\",\n ]\n \n [[package]]\n@@ -721,43 +721,100 @@ version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ea04155a16a59f9eab786fe12a4a450e75cdb175f9e0d80da1e17db09f55b8d2\"\n dependencies = [\n- \"windows_aarch64_msvc\",\n- \"windows_i686_gnu\",\n- \"windows_i686_msvc\",\n- \"windows_x86_64_gnu\",\n- \"windows_x86_64_msvc\",\n+ \"windows_aarch64_msvc 0.36.1\",\n+ \"windows_i686_gnu 0.36.1\",\n+ \"windows_i686_msvc 0.36.1\",\n+ \"windows_x86_64_gnu 0.36.1\",\n+ \"windows_x86_64_msvc 0.36.1\",\n ]\n \n+[[package]]\n+name = \"windows-sys\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n+dependencies = [\n+ \"windows_aarch64_gnullvm\",\n+ \"windows_aarch64_msvc 0.42.0\",\n+ \"windows_i686_gnu 0.42.0\",\n+ \"windows_i686_msvc 0.42.0\",\n+ \"windows_x86_64_gnu 0.42.0\",\n+ \"windows_x86_64_gnullvm\",\n+ \"windows_x86_64_msvc 0.42.0\",\n+]\n+\n+[[package]]\n+name = \"windows_aarch64_gnullvm\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n+\n [[package]]\n name = \"windows_aarch64_msvc\"\n version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9bb8c3fd39ade2d67e9874ac4f3db21f0d710bee00fe7cab16949ec184eeaa47\"\n \n+[[package]]\n+name = \"windows_aarch64_msvc\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n+\n [[package]]\n name = \"windows_i686_gnu\"\n version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"180e6ccf01daf4c426b846dfc66db1fc518f074baa793aa7d9b9aaeffad6a3b6\"\n \n+[[package]]\n+name = \"windows_i686_gnu\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n+\n [[package]]\n name = \"windows_i686_msvc\"\n version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e2e7917148b2812d1eeafaeb22a97e4813dfa60a3f8f78ebe204bcc88f12f024\"\n \n+[[package]]\n+name = \"windows_i686_msvc\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n+\n [[package]]\n name = \"windows_x86_64_gnu\"\n version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4dcd171b8776c41b97521e5da127a2d86ad280114807d0b2ab1e462bc764d9e1\"\n \n+[[package]]\n+name = \"windows_x86_64_gnu\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+\n+[[package]]\n+name = \"windows_x86_64_gnullvm\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n+\n [[package]]\n name = \"windows_x86_64_msvc\"\n version = \"0.36.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c811ca4a8c853ef420abd8592ba53ddbbac90410fab6903b3e79972a631f7680\"\n \n+[[package]]\n+name = \"windows_x86_64_msvc\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\"\n+\n [[package]]\n name = \"xattr\"\n version = \"0.2.3\""}, {"sha": "f74738437ea3a2e7ac0bd91b536b9ed8236e6c42", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -36,7 +36,7 @@ test = false\n \n [dependencies]\n cmake = \"0.1.38\"\n-fd-lock = \"3.0.6\"\n+fd-lock = \"3.0.7\"\n filetime = \"0.2\"\n getopts = \"0.2.19\"\n cc = \"1.0.69\""}, {"sha": "be69f819c6428f8e88332ab7889656ec7482a88a", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -35,7 +35,7 @@ fn main() {\n \n     // NOTE: Since `./configure` generates a `config.toml`, distro maintainers will see the\n     // changelog warning, not the `x.py setup` message.\n-    let suggest_setup = !config.config.exists() && !matches!(config.cmd, Subcommand::Setup { .. });\n+    let suggest_setup = config.config.is_none() && !matches!(config.cmd, Subcommand::Setup { .. });\n     if suggest_setup {\n         println!(\"warning: you have not made a `config.toml`\");\n         println!("}, {"sha": "6fd363935079dcd001ba778f96242efcc7550a17", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -2208,6 +2208,24 @@ impl<'a> Builder<'a> {\n \n         false\n     }\n+\n+    pub(crate) fn maybe_open_in_browser<S: Step>(&self, path: impl AsRef<Path>) {\n+        if self.was_invoked_explicitly::<S>(Kind::Doc) {\n+            self.open_in_browser(path);\n+        }\n+    }\n+\n+    pub(crate) fn open_in_browser(&self, path: impl AsRef<Path>) {\n+        if self.config.dry_run || !self.config.cmd.open() {\n+            return;\n+        }\n+\n+        let path = path.as_ref();\n+        self.info(&format!(\"Opening doc {}\", path.display()));\n+        if let Err(err) = opener::open(path) {\n+            self.info(&format!(\"{}\\n\", err));\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "ba50ce9ec2426e99c362a666afdd5f2524995058", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -80,7 +80,7 @@ pub struct Config {\n     pub keep_stage_std: Vec<u32>,\n     pub src: PathBuf,\n     /// defaults to `config.toml`\n-    pub config: PathBuf,\n+    pub config: Option<PathBuf>,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n@@ -926,8 +926,10 @@ impl Config {\n         // Give a hard error if `--config` or `RUST_BOOTSTRAP_CONFIG` are set to a missing path,\n         // but not if `config.toml` hasn't been created.\n         let mut toml = if !using_default_path || toml_path.exists() {\n+            config.config = Some(toml_path.clone());\n             get_toml(&toml_path)\n         } else {\n+            config.config = None;\n             TomlConfig::default()\n         };\n \n@@ -942,7 +944,6 @@ impl Config {\n         }\n \n         config.changelog_seen = toml.changelog_seen;\n-        config.config = toml_path;\n \n         let build = toml.build.unwrap_or_default();\n "}, {"sha": "110a3ee4918da2d1ee6a1f359533f91ade9b4244", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -19,6 +19,7 @@ use crate::cache::{Interned, INTERNER};\n use crate::channel;\n use crate::compile;\n use crate::config::TargetSelection;\n+use crate::doc::DocumentationFormat;\n use crate::tarball::{GeneratedTarball, OverlayKind, Tarball};\n use crate::tool::{self, Tool};\n use crate::util::{exe, is_dylib, output, t, timeit};\n@@ -97,7 +98,11 @@ impl Step for JsonDocs {\n     /// Builds the `rust-docs-json` installer component.\n     fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let host = self.host;\n-        builder.ensure(crate::doc::JsonStd { stage: builder.top_stage, target: host });\n+        builder.ensure(crate::doc::Std {\n+            stage: builder.top_stage,\n+            target: host,\n+            format: DocumentationFormat::JSON,\n+        });\n \n         let dest = \"share/doc/rust/json\";\n "}, {"sha": "280e232ca2dd02e7a67a4c5d84b584af0b7bd38a", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 42, "deletions": 76, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -85,18 +85,6 @@ book!(\n     StyleGuide, \"src/doc/style-guide\", \"style-guide\";\n );\n \n-fn open(builder: &Builder<'_>, path: impl AsRef<Path>) {\n-    if builder.config.dry_run || !builder.config.cmd.open() {\n-        return;\n-    }\n-\n-    let path = path.as_ref();\n-    builder.info(&format!(\"Opening doc {}\", path.display()));\n-    if let Err(err) = opener::open(path) {\n-        builder.info(&format!(\"{}\\n\", err));\n-    }\n-}\n-\n // \"library/std\" -> [\"library\", \"std\"]\n //\n // Used for deciding whether a particular step is one requested by the user on\n@@ -240,11 +228,9 @@ impl Step for TheBook {\n             invoke_rustdoc(builder, compiler, &shared_assets, target, path);\n         }\n \n-        if builder.was_invoked_explicitly::<Self>(Kind::Doc) {\n-            let out = builder.doc_out(target);\n-            let index = out.join(\"book\").join(\"index.html\");\n-            open(builder, &index);\n-        }\n+        let out = builder.doc_out(target);\n+        let index = out.join(\"book\").join(\"index.html\");\n+        builder.maybe_open_in_browser::<Self>(index);\n     }\n }\n \n@@ -386,7 +372,7 @@ impl Step for Standalone {\n         // with no particular explicit doc requested (e.g. library/core).\n         if builder.paths.is_empty() || builder.was_invoked_explicitly::<Self>(Kind::Doc) {\n             let index = out.join(\"index.html\");\n-            open(builder, &index);\n+            builder.open_in_browser(&index);\n         }\n     }\n }\n@@ -434,6 +420,7 @@ impl Step for SharedAssets {\n pub struct Std {\n     pub stage: u32,\n     pub target: TargetSelection,\n+    pub format: DocumentationFormat,\n }\n \n impl Step for Std {\n@@ -446,7 +433,15 @@ impl Step for Std {\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Std { stage: run.builder.top_stage, target: run.target });\n+        run.builder.ensure(Std {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+            format: if run.builder.config.cmd.json() {\n+                DocumentationFormat::JSON\n+            } else {\n+                DocumentationFormat::HTML\n+            },\n+        });\n     }\n \n     /// Compile all standard library documentation.\n@@ -456,19 +451,26 @@ impl Step for Std {\n     fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n-        let out = builder.doc_out(target);\n+        let out = match self.format {\n+            DocumentationFormat::HTML => builder.doc_out(target),\n+            DocumentationFormat::JSON => builder.json_doc_out(target),\n+        };\n+\n         t!(fs::create_dir_all(&out));\n \n         builder.ensure(SharedAssets { target: self.target });\n \n         let index_page = builder.src.join(\"src/doc/index.md\").into_os_string();\n-        let mut extra_args = vec![\n-            OsStr::new(\"--markdown-css\"),\n-            OsStr::new(\"rust.css\"),\n-            OsStr::new(\"--markdown-no-toc\"),\n-            OsStr::new(\"--index-page\"),\n-            &index_page,\n-        ];\n+        let mut extra_args = match self.format {\n+            DocumentationFormat::HTML => vec![\n+                OsStr::new(\"--markdown-css\"),\n+                OsStr::new(\"rust.css\"),\n+                OsStr::new(\"--markdown-no-toc\"),\n+                OsStr::new(\"--index-page\"),\n+                &index_page,\n+            ],\n+            DocumentationFormat::JSON => vec![OsStr::new(\"--output-format\"), OsStr::new(\"json\")],\n+        };\n \n         if !builder.config.docs_minification {\n             extra_args.push(OsStr::new(\"--disable-minification\"));\n@@ -492,59 +494,24 @@ impl Step for Std {\n             })\n             .collect::<Vec<_>>();\n \n-        doc_std(\n-            builder,\n-            DocumentationFormat::HTML,\n-            stage,\n-            target,\n-            &out,\n-            &extra_args,\n-            &requested_crates,\n-        );\n+        doc_std(builder, self.format, stage, target, &out, &extra_args, &requested_crates);\n+\n+        // Don't open if the format is json\n+        if let DocumentationFormat::JSON = self.format {\n+            return;\n+        }\n \n         // Look for library/std, library/core etc in the `x.py doc` arguments and\n         // open the corresponding rendered docs.\n         for requested_crate in requested_crates {\n             if STD_PUBLIC_CRATES.iter().any(|k| *k == requested_crate.as_str()) {\n                 let index = out.join(requested_crate).join(\"index.html\");\n-                open(builder, &index);\n+                builder.open_in_browser(index);\n             }\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct JsonStd {\n-    pub stage: u32,\n-    pub target: TargetSelection,\n-}\n-\n-impl Step for JsonStd {\n-    type Output = ();\n-    const DEFAULT: bool = false;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let default = run.builder.config.docs && run.builder.config.cmd.json();\n-        run.all_krates(\"test\").path(\"library\").default_condition(default)\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Std { stage: run.builder.top_stage, target: run.target });\n-    }\n-\n-    /// Build JSON documentation for the standard library crates.\n-    ///\n-    /// This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n-        let target = self.target;\n-        let out = builder.json_doc_out(target);\n-        t!(fs::create_dir_all(&out));\n-        let extra_args = [OsStr::new(\"--output-format\"), OsStr::new(\"json\")];\n-        doc_std(builder, DocumentationFormat::JSON, stage, target, &out, &extra_args, &[])\n-    }\n-}\n-\n /// Name of the crates that are visible to consumers of the standard library.\n /// Documentation for internal crates is handled by the rustc step, so internal crates will show\n /// up there.\n@@ -557,7 +524,7 @@ impl Step for JsonStd {\n const STD_PUBLIC_CRATES: [&str; 5] = [\"core\", \"alloc\", \"std\", \"proc_macro\", \"test\"];\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-enum DocumentationFormat {\n+pub enum DocumentationFormat {\n     HTML,\n     JSON,\n }\n@@ -759,7 +726,7 @@ impl Step for Rustc {\n         // Let's open the first crate documentation page:\n         if let Some(krate) = to_open {\n             let index = out.join(krate).join(\"index.html\");\n-            open(builder, &index);\n+            builder.open_in_browser(index);\n         }\n     }\n }\n@@ -1019,10 +986,9 @@ impl Step for RustcBook {\n             name: INTERNER.intern_str(\"rustc\"),\n             src: INTERNER.intern_path(out_base),\n         });\n-        if builder.was_invoked_explicitly::<Self>(Kind::Doc) {\n-            let out = builder.doc_out(self.target);\n-            let index = out.join(\"rustc\").join(\"index.html\");\n-            open(builder, &index);\n-        }\n+\n+        let out = builder.doc_out(self.target);\n+        let index = out.join(\"rustc\").join(\"index.html\");\n+        builder.maybe_open_in_browser::<Self>(index);\n     }\n }"}, {"sha": "bdfd5fe5c421c0e72f168103c7053d286d5f30c5", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -155,6 +155,14 @@ than building it.\n             continue;\n         }\n \n+        // Some environments don't want or need these tools, such as when testing Miri.\n+        // FIXME: it would be better to refactor this code to split necessary setup from pure sanity\n+        // checks, and have a regular flag for skipping the latter. Also see\n+        // <https://github.com/rust-lang/rust/pull/103569#discussion_r1008741742>.\n+        if env::var_os(\"BOOTSTRAP_SKIP_TARGET_SANITY\").is_some() {\n+            continue;\n+        }\n+\n         if !build.config.dry_run {\n             cmd_finder.must_have(build.cc(*target));\n             if let Some(ar) = build.ar(*target) {\n@@ -212,6 +220,14 @@ than building it.\n             }\n         }\n \n+        // Some environments don't want or need these tools, such as when testing Miri.\n+        // FIXME: it would be better to refactor this code to split necessary setup from pure sanity\n+        // checks, and have a regular flag for skipping the latter. Also see\n+        // <https://github.com/rust-lang/rust/pull/103569#discussion_r1008741742>.\n+        if env::var_os(\"BOOTSTRAP_SKIP_TARGET_SANITY\").is_some() {\n+            continue;\n+        }\n+\n         if need_cmake && target.contains(\"msvc\") {\n             // There are three builds of cmake on windows: MSVC, MinGW, and\n             // Cygwin. The Cygwin build does not have generators for Visual"}, {"sha": "04480277fe0474cb8b3dd97993d8f4bdaf1162e0", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -82,7 +82,7 @@ impl fmt::Display for Profile {\n }\n \n pub fn setup(config: &Config, profile: Profile) {\n-    let path = &config.config;\n+    let path = &config.config.clone().unwrap_or(PathBuf::from(\"config.toml\"));\n \n     if path.exists() {\n         eprintln!("}, {"sha": "46ad04708127377fe5e19bde0601428b083604b8", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -16,6 +16,7 @@ use crate::cache::Interned;\n use crate::compile;\n use crate::config::TargetSelection;\n use crate::dist;\n+use crate::doc::DocumentationFormat;\n use crate::flags::Subcommand;\n use crate::native;\n use crate::tool::{self, SourceType, Tool};\n@@ -826,7 +827,11 @@ impl Step for RustdocJSStd {\n                     command.arg(\"--test-file\").arg(path);\n                 }\n             }\n-            builder.ensure(crate::doc::Std { target: self.target, stage: builder.top_stage });\n+            builder.ensure(crate::doc::Std {\n+                target: self.target,\n+                stage: builder.top_stage,\n+                format: DocumentationFormat::HTML,\n+            });\n             builder.run(&mut command);\n         } else {\n             builder.info(\"No nodejs found, skipping \\\"src/test/rustdoc-js-std\\\" tests\");"}, {"sha": "e1adabaac9b568b32723e98201603bc30187ff47", "filename": "src/ci/docker/host-x86_64/dist-various-2/Dockerfile", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2FDockerfile?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -118,6 +118,9 @@ ENV TARGETS=$TARGETS,armv7-unknown-linux-gnueabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,i686-unknown-freebsd\n ENV TARGETS=$TARGETS,x86_64-unknown-none\n+ENV TARGETS=$TARGETS,aarch64-unknown-uefi\n+ENV TARGETS=$TARGETS,i686-unknown-uefi\n+ENV TARGETS=$TARGETS,x86_64-unknown-uefi\n \n # As per https://bugs.launchpad.net/ubuntu/+source/gcc-defaults/+bug/1300211\n # we need asm in the search path for gcc-8 (for gnux32) but not in the search path of the"}, {"sha": "7dde6370904bb91f4613ae12b33eea6885c4fffa", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -27,10 +27,7 @@ python3 \"$X_PY\" test --stage 2 src/tools/rustfmt\n python3 \"$X_PY\" test --stage 2 src/tools/miri\n # We natively run this script on x86_64-unknown-linux-gnu and x86_64-pc-windows-msvc.\n # Also cover some other targets (on both of these hosts) via cross-testing.\n-#\n-# Currently disabled -- we end up pulling in a cross-compile of LLVM (maybe\n-# just overly eager sanity checks), but in any case this won't work when\n-# building LLVM as of this comment.\n-#python3 \"$X_PY\" test --stage 2 src/tools/miri --target i686-pc-windows-msvc\n-#FIXME(https://github.com/rust-lang/rust/issues/103519): macOS testing is currently disabled\n-# python3 \"$X_PY\" test --stage 2 src/tools/miri --target aarch64-apple-darwin\n+export BOOTSTRAP_SKIP_TARGET_SANITY=1 # we don't need `cc` for these targets\n+python3 \"$X_PY\" test --stage 2 src/tools/miri --target i686-pc-windows-msvc\n+python3 \"$X_PY\" test --stage 2 src/tools/miri --target aarch64-apple-darwin\n+unset BOOTSTRAP_SKIP_TARGET_SANITY"}, {"sha": "3f64052c048c6def93b94a2b514ee88bba918744", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1 +1 @@\n-Subproject commit aa5ee485bd6bd80d205da7c82fcdd776f92fdd51\n+Subproject commit 3f64052c048c6def93b94a2b514ee88bba918744"}, {"sha": "05532356e7a4dbea2330aabb77611f5179493bb8", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1 +1 @@\n-Subproject commit 9c73283775466d22208a0b28afcab44db4c0cc10\n+Subproject commit 05532356e7a4dbea2330aabb77611f5179493bb8"}, {"sha": "9f0cc13ffcd27c1fbe1ab766a9491e15ddcf4d19", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1 +1 @@\n-Subproject commit 4ea7c5def38ac81df33a9e48e5637a82a5ac404d\n+Subproject commit 9f0cc13ffcd27c1fbe1ab766a9491e15ddcf4d19"}, {"sha": "2b15c0abf2bada6e00553814336bc3e2d8399097", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1 +1 @@\n-Subproject commit 03491f33375c5a2a1661c7fa4be671fe95ce1249\n+Subproject commit 2b15c0abf2bada6e00553814336bc3e2d8399097"}, {"sha": "d0dc6c97a6486f68bac782fff135086eae6d77ec", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1 +1 @@\n-Subproject commit 51a37ad19a15709d0601afbac6581f5aea6a45da\n+Subproject commit d0dc6c97a6486f68bac782fff135086eae6d77ec"}, {"sha": "9272b9ac9b2d45be95b2278b97dc36b0b5c00446", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -131,24 +131,47 @@ able to get around this problem by setting `-Clinker=lld-link` in RUSTFLAGS\n \n ## Toolchain Compatibility\n \n-<!-- NOTE: to update the below table, you can use this shell script:\n-\n-```sh\n-rustup toolchain install --profile minimal nightly\n-MINOR_VERSION=$(rustc +nightly --version | cut -d . -f 2)\n-LOWER_BOUND=61\n-\n-llvm_version() {\n-    toolchain=\"$1\"\n-    printf \"Rust $toolchain    |    Clang \"\n-    rustc +\"$toolchain\" -Vv | grep LLVM | cut -d ':' -f 2 | tr -d ' '\n-}\n-\n-for version in `seq $LOWER_BOUND $((MINOR_VERSION - 2))`; do\n-    toolchain=1.$version.0\n-    rustup toolchain install --no-self-update --profile  minimal $toolchain >/dev/null 2>&1\n-    llvm_version $toolchain\n-done\n+<!-- NOTE: to update the below table, you can use this Python script:\n+\n+```python\n+from collections import defaultdict\n+import subprocess\n+\n+def minor_version(version):\n+    return int(version.split('.')[1])\n+\n+INSTALL_TOOLCHAIN = [\"rustup\", \"toolchain\", \"install\", \"--profile\", \"minimal\"]\n+subprocess.run(INSTALL_TOOLCHAIN + [\"nightly\"])\n+\n+LOWER_BOUND = 65\n+NIGHTLY_VERSION = minor_version(subprocess.run(\n+    [\"rustc\", \"+nightly\", \"--version\"],\n+    capture_output=True,\n+    text=True).stdout)\n+\n+def llvm_version(toolchain):\n+    version_text = subprocess.run(\n+        [\"rustc\", \"+{}\".format(toolchain), \"-Vv\"],\n+        capture_output=True,\n+        text=True).stdout\n+    return int(version_text.split(\"LLVM\")[1].split(':')[1].split('.')[0])\n+\n+version_map = defaultdict(lambda: [])\n+for version in range(LOWER_BOUND, NIGHTLY_VERSION - 1):\n+    toolchain = \"1.{}.0\".format(version)\n+    subprocess.run(\n+        INSTALL_TOOLCHAIN + [\"--no-self-update\", toolchain],\n+        capture_output=True)\n+    version_map[llvm_version(toolchain)].append(version)\n+\n+print(\"| Rust Version | Clang Version |\")\n+print(\"|--------------|---------------|\")\n+for clang, rust in sorted(version_map.items()):\n+    if len(rust) > 1:\n+        rust_range = \"1.{} - 1.{}\".format(rust[0], rust[-1])\n+    else:\n+        rust_range = \"1.{}       \".format(rust[0])\n+    print(\"| {}  |      {}       |\".format(rust_range, clang))\n ```\n \n -->\n@@ -166,32 +189,13 @@ The following table shows known good combinations of toolchain versions.\n \n | Rust Version | Clang Version |\n |--------------|---------------|\n-| Rust 1.34    |    Clang 8    |\n-| Rust 1.35    |    Clang 8    |\n-| Rust 1.36    |    Clang 8    |\n-| Rust 1.37    |    Clang 8    |\n-| Rust 1.38    |    Clang 9    |\n-| Rust 1.39    |    Clang 9    |\n-| Rust 1.40    |    Clang 9    |\n-| Rust 1.41    |    Clang 9    |\n-| Rust 1.42    |    Clang 9    |\n-| Rust 1.43    |    Clang 9    |\n-| Rust 1.44    |    Clang 9    |\n-| Rust 1.45    |    Clang 10   |\n-| Rust 1.46    |    Clang 10   |\n-| Rust 1.47    |    Clang 11   |\n-| Rust 1.48    |    Clang 11   |\n-| Rust 1.49    |    Clang 11   |\n-| Rust 1.50    |    Clang 11   |\n-| Rust 1.51    |    Clang 11   |\n-| Rust 1.52    |    Clang 12   |\n-| Rust 1.53    |    Clang 12   |\n-| Rust 1.54    |    Clang 12   |\n-| Rust 1.55    |    Clang 12   |\n-| Rust 1.56    |    Clang 13   |\n-| Rust 1.57    |    Clang 13   |\n-| Rust 1.58    |    Clang 13   |\n-| Rust 1.59    |    Clang 13   |\n-| Rust 1.60    |    Clang 14   |\n+| 1.34 - 1.37  |       8       |\n+| 1.38 - 1.44  |       9       |\n+| 1.45 - 1.46  |      10       |\n+| 1.47 - 1.51  |      11       |\n+| 1.52 - 1.55  |      12       |\n+| 1.56 - 1.59  |      13       |\n+| 1.60 - 1.64  |      14       |\n+| 1.65         |      15       |\n \n Note that the compatibility policy for this feature might change in the future."}, {"sha": "0315f1e3725ffe91970a3a10735202ef862549ec", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -128,6 +128,7 @@ target | std | notes\n [`aarch64-linux-android`](platform-support/android.md) | \u2713 | ARM64 Android\n `aarch64-unknown-none-softfloat` | * | Bare ARM64, softfloat\n `aarch64-unknown-none` | * | Bare ARM64, hardfloat\n+[`aarch64-unknown-uefi`](platform-support/unknown-uefi.md) | * | ARM64 UEFI\n [`arm-linux-androideabi`](platform-support/android.md) | \u2713 | ARMv7 Android\n `arm-unknown-linux-musleabi` | \u2713 | ARMv6 Linux with MUSL\n `arm-unknown-linux-musleabihf` | \u2713 | ARMv6 Linux with MUSL, hardfloat\n@@ -149,6 +150,7 @@ target | std | notes\n [`i686-linux-android`](platform-support/android.md) | \u2713 | 32-bit x86 Android\n `i686-unknown-freebsd` | \u2713 | 32-bit FreeBSD\n `i686-unknown-linux-musl` | \u2713 | 32-bit Linux with MUSL\n+[`i686-unknown-uefi`](platform-support/unknown-uefi.md) | * | 32-bit UEFI\n `mips-unknown-linux-musl` | \u2713 | MIPS Linux with MUSL\n `mips64-unknown-linux-muslabi64` | \u2713 | MIPS64 Linux, n64 ABI, MUSL\n `mips64el-unknown-linux-muslabi64` | \u2713 | MIPS64 (LE) Linux, n64 ABI, MUSL\n@@ -181,6 +183,7 @@ target | std | notes\n `x86_64-unknown-linux-gnux32` | \u2713 | 64-bit Linux (x32 ABI) (kernel 4.15, glibc 2.27)\n [`x86_64-unknown-none`](platform-support/x86_64-unknown-none.md) | * | Freestanding/bare-metal x86_64, softfloat\n `x86_64-unknown-redox` | \u2713 | Redox OS\n+[`x86_64-unknown-uefi`](platform-support/unknown-uefi.md) | * | 64-bit UEFI\n \n [Fortanix ABI]: https://edp.fortanix.com/\n \n@@ -213,7 +216,6 @@ target | std | host | notes\n [`aarch64-pc-windows-gnullvm`](platform-support/pc-windows-gnullvm.md) | \u2713 | \u2713 |\n `aarch64-unknown-freebsd` | \u2713 | \u2713 | ARM64 FreeBSD\n `aarch64-unknown-hermit` | \u2713 |  | ARM64 HermitCore\n-[`aarch64-unknown-uefi`](platform-support/unknown-uefi.md) | * |  | ARM64 UEFI\n `aarch64-unknown-linux-gnu_ilp32` | \u2713 | \u2713 | ARM64 Linux (ILP32 ABI)\n `aarch64-unknown-netbsd` | \u2713 | \u2713 |\n [`aarch64-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | ARM64 OpenBSD\n@@ -252,7 +254,6 @@ target | std | host | notes\n `i686-unknown-haiku` | \u2713 | \u2713 | 32-bit Haiku\n `i686-unknown-netbsd` | \u2713 | \u2713 | NetBSD/i386 with SSE2\n [`i686-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | 32-bit OpenBSD\n-[`i686-unknown-uefi`](platform-support/unknown-uefi.md) | * |  | 32-bit UEFI\n `i686-uwp-windows-gnu` | ? |  |\n `i686-uwp-windows-msvc` | ? |  |\n `i686-wrs-vxworks` | ? |  |\n@@ -309,9 +310,7 @@ target | std | host | notes\n `x86_64-unknown-haiku` | \u2713 | \u2713 | 64-bit Haiku\n `x86_64-unknown-hermit` | \u2713 |  | HermitCore\n `x86_64-unknown-l4re-uclibc` | ? |  |\n-`x86_64-unknown-none-linuxkernel` | * |  | Linux kernel modules\n [`x86_64-unknown-openbsd`](platform-support/openbsd.md) | \u2713 | \u2713 | 64-bit OpenBSD\n-[`x86_64-unknown-uefi`](platform-support/unknown-uefi.md) | * |  | 64-bit UEFI\n `x86_64-uwp-windows-gnu` | \u2713 |  |\n `x86_64-uwp-windows-msvc` | \u2713 |  |\n `x86_64-wrs-vxworks` | ? |  |"}, {"sha": "e2bdf73a92990cc4879e44ad7cb3ab6118c8adf3", "filename": "src/doc/rustc/src/platform-support/unknown-uefi.md", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Funknown-uefi.md", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Funknown-uefi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Funknown-uefi.md?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,6 +1,6 @@\n # `*-unknown-uefi`\n \n-**Tier: 3**\n+**Tier: 2**\n \n Unified Extensible Firmware Interface (UEFI) targets for application, driver,\n and core UEFI binaries.\n@@ -72,28 +72,14 @@ target = [\"x86_64-unknown-uefi\"]\n \n ## Building Rust programs\n \n-Rust does not yet ship pre-compiled artifacts for this target. To compile for\n-this target, you will either need to build Rust with the target enabled (see\n-\"Building rust for UEFI targets\" above), or build your own copy of `core` by\n-using `build-std`, `cargo-buildx`, or similar.\n-\n-A native build with the unstable `build-std`-feature can be achieved via:\n-\n-```sh\n-cargo +nightly build \\\n-    -Zbuild-std=core,compiler_builtins \\\n-    -Zbuild-std-features=compiler-builtins-mem \\\n-    --target x86_64-unknown-uefi\n-```\n-\n-Alternatively, you can install `cargo-xbuild` via\n-`cargo install --force cargo-xbuild` and build for the UEFI targets via:\n+Starting with Rust 1.67, precompiled artifacts are provided via\n+`rustup`. For example, to use `x86_64-unknown-uefi`:\n \n ```sh\n-cargo \\\n-    +nightly \\\n-    xbuild \\\n-    --target x86_64-unknown-uefi\n+# install cross-compile toolchain\n+rustup target add x86_64-unknown-uefi\n+# target flag may be used with any cargo or rustc command\n+cargo build --target x86_64-unknown-uefi\n ```\n \n ## Testing\n@@ -167,18 +153,10 @@ The following code is a valid UEFI application returning immediately upon\n execution with an exit code of 0. A panic handler is provided. This is executed\n by rust on panic. For simplicity, we simply end up in an infinite loop.\n \n-Note that as of rust-1.31.0, all features used here are stabilized. No unstable\n-features are required, nor do we rely on nightly compilers. However, if you do\n-not compile rustc for the UEFI targets, you need a nightly compiler to support\n-the `-Z build-std` flag.\n-\n This example can be compiled as binary crate via `cargo`:\n \n ```sh\n-cargo +nightly build \\\n-    -Zbuild-std=core,compiler_builtins \\\n-    -Zbuild-std-features=compiler-builtins-mem \\\n-    --target x86_64-unknown-uefi\n+cargo build --target x86_64-unknown-uefi\n ```\n \n ```rust,ignore (platform-specific,eh-personality-is-unstable)"}, {"sha": "8c16a562e349e5fd7c339cad1d5358c405945878", "filename": "src/etc/natvis/intrinsic.natvis", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fetc%2Fnatvis%2Fintrinsic.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fetc%2Fnatvis%2Fintrinsic.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fintrinsic.natvis?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,6 +1,10 @@\n \ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n <AutoVisualizer xmlns=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\">\n-  <Type Name=\"str\">\n+  <Type Name=\"ref$&lt;str$&gt;\">\n+    <AlternativeType Name=\"ref_mut$&lt;str$&gt;\" />\n+    <AlternativeType Name=\"ptr_const$&lt;str$&gt;\" />\n+    <AlternativeType Name=\"ptr_mut$&lt;str$&gt;\" />\n+\n     <DisplayString>{(char*)data_ptr,[length]s8}</DisplayString>\n     <StringView>(char*)data_ptr,[length]s8</StringView>\n     <Expand>\n@@ -15,7 +19,11 @@\n       </Synthetic>\n     </Expand>\n   </Type>\n-  <Type Name=\"slice$&lt;*&gt;\">\n+  <Type Name=\"ref$&lt;slice2$&lt;*&gt; &gt;\">\n+    <AlternativeType Name=\"ref_mut$&lt;slice2$&lt;*&gt; &gt;\" />\n+    <AlternativeType Name=\"ptr_const$&lt;slice2$&lt;*&gt; &gt;\" />\n+    <AlternativeType Name=\"ptr_mut$&lt;slice2$&lt;*&gt; &gt;\" />\n+\n     <DisplayString>{{ len={length} }}</DisplayString>\n     <Expand>\n       <Item Name=\"[len]\" ExcludeView=\"simple\">length</Item>"}, {"sha": "41f4a3767f59974c959bee9b0e5c3d8fda3f0d35", "filename": "src/etc/natvis/liballoc.natvis", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fliballoc.natvis?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -85,7 +85,7 @@\n   </Type>\n \n   <!-- alloc::rc::Rc<[T]> -->\n-  <Type Name=\"alloc::rc::Rc&lt;slice$&lt;*&gt; &gt;\">\n+  <Type Name=\"alloc::rc::Rc&lt;slice2$&lt;*&gt; &gt;\">\n     <DisplayString>{{ len={ptr.pointer.length} }}</DisplayString>\n     <Expand>\n       <Item Name=\"[Length]\" ExcludeView=\"simple\">ptr.pointer.length</Item>\n@@ -115,7 +115,7 @@\n   </Type>\n \n   <!-- alloc::rc::Weak<[T]> -->\n-  <Type Name=\"alloc::rc::Weak&lt;slice$&lt;*&gt; &gt;\">\n+  <Type Name=\"alloc::rc::Weak&lt;slice2$&lt;*&gt; &gt;\">\n     <DisplayString>{{ len={ptr.pointer.length} }}</DisplayString>\n     <Expand>\n       <Item Name=\"[Length]\" ExcludeView=\"simple\">ptr.pointer.length</Item>\n@@ -144,7 +144,7 @@\n   </Type>\n \n   <!-- alloc::sync::Arc<[T]> -->\n-  <Type Name=\"alloc::sync::Arc&lt;slice$&lt;*&gt; &gt;\">\n+  <Type Name=\"alloc::sync::Arc&lt;slice2$&lt;*&gt; &gt;\">\n     <DisplayString>{{ len={ptr.pointer.length} }}</DisplayString>\n     <Expand>\n       <Item Name=\"[Length]\" ExcludeView=\"simple\">ptr.pointer.length</Item>\n@@ -173,7 +173,7 @@\n   </Type>\n \n   <!-- alloc::sync::Weak<[T]> -->\n-  <Type Name=\"alloc::sync::Weak&lt;slice$&lt;*&gt; &gt;\">\n+  <Type Name=\"alloc::sync::Weak&lt;slice2$&lt;*&gt; &gt;\">\n     <DisplayString>{{ len={ptr.pointer.length} }}</DisplayString>\n     <Expand>\n       <Item Name=\"[Length]\" ExcludeView=\"simple\">ptr.pointer.length</Item>"}, {"sha": "85bd8446640dd70a8e7428b94de2e1993af163ea", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -336,10 +336,7 @@ where\n                 match br {\n                     // We only care about named late bound regions, as we need to add them\n                     // to the 'for<>' section\n-                    ty::BrNamed(_, name) => Some(GenericParamDef {\n-                        name,\n-                        kind: GenericParamDefKind::Lifetime { outlives: vec![] },\n-                    }),\n+                    ty::BrNamed(_, name) => Some(GenericParamDef::lifetime(name)),\n                     _ => None,\n                 }\n             })"}, {"sha": "3fc4aae923a60aa2cc0ed8794bb22eccbc89a0e9", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -3,7 +3,7 @@\n use std::iter::once;\n use std::sync::Arc;\n \n-use thin_vec::ThinVec;\n+use thin_vec::{thin_vec, ThinVec};\n \n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n@@ -243,10 +243,19 @@ pub(crate) fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean\n fn build_external_function<'tcx>(cx: &mut DocContext<'tcx>, did: DefId) -> Box<clean::Function> {\n     let sig = cx.tcx.fn_sig(did);\n \n-    let predicates = cx.tcx.predicates_of(did);\n+    let late_bound_regions = sig.bound_vars().into_iter().filter_map(|var| match var {\n+        ty::BoundVariableKind::Region(ty::BrNamed(_, name)) if name != kw::UnderscoreLifetime => {\n+            Some(clean::GenericParamDef::lifetime(name))\n+        }\n+        _ => None,\n+    });\n+\n+    let predicates = cx.tcx.explicit_predicates_of(did);\n     let (generics, decl) = clean::enter_impl_trait(cx, |cx| {\n         // NOTE: generics need to be cleaned before the decl!\n-        let generics = clean_ty_generics(cx, cx.tcx.generics_of(did), predicates);\n+        let mut generics = clean_ty_generics(cx, cx.tcx.generics_of(did), predicates);\n+        // FIXME: This does not place parameters in source order (late-bound ones come last)\n+        generics.params.extend(late_bound_regions);\n         let decl = clean_fn_decl_from_did_and_sig(cx, Some(did), sig);\n         (generics, decl)\n     });\n@@ -596,7 +605,7 @@ fn build_module_items(\n                         clean::ImportSource {\n                             path: clean::Path {\n                                 res,\n-                                segments: vec![clean::PathSegment {\n+                                segments: thin_vec![clean::PathSegment {\n                                     name: prim_ty.as_sym(),\n                                     args: clean::GenericArgs::AngleBracketed {\n                                         args: Default::default(),"}, {"sha": "56a873e3e8236ba8440ed8ee211fd061097857c3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 65, "deletions": 24, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -12,7 +12,7 @@ pub(crate) mod utils;\n \n use rustc_ast as ast;\n use rustc_attr as attr;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n@@ -182,10 +182,9 @@ fn clean_poly_trait_ref_with_bindings<'tcx>(\n         .collect_referenced_late_bound_regions(&poly_trait_ref)\n         .into_iter()\n         .filter_map(|br| match br {\n-            ty::BrNamed(_, name) if name != kw::UnderscoreLifetime => Some(GenericParamDef {\n-                name,\n-                kind: GenericParamDefKind::Lifetime { outlives: vec![] },\n-            }),\n+            ty::BrNamed(_, name) if name != kw::UnderscoreLifetime => {\n+                Some(GenericParamDef::lifetime(name))\n+            }\n             _ => None,\n         })\n         .collect();\n@@ -227,7 +226,7 @@ pub(crate) fn clean_middle_const<'tcx>(\n     // FIXME: instead of storing the stringified expression, store `self` directly instead.\n     Constant {\n         type_: clean_middle_ty(constant.ty(), cx, None),\n-        kind: ConstantKind::TyConst { expr: constant.to_string() },\n+        kind: ConstantKind::TyConst { expr: constant.to_string().into() },\n     }\n }\n \n@@ -741,10 +740,7 @@ fn clean_ty_generics<'tcx>(\n                             p.get_bound_params()\n                                 .into_iter()\n                                 .flatten()\n-                                .map(|param| GenericParamDef {\n-                                    name: param.0,\n-                                    kind: GenericParamDefKind::Lifetime { outlives: Vec::new() },\n-                                })\n+                                .map(|param| GenericParamDef::lifetime(param.0))\n                                 .collect(),\n                         ));\n                     }\n@@ -957,12 +953,14 @@ fn clean_args_from_types_and_names<'tcx>(\n         values: types\n             .iter()\n             .enumerate()\n-            .map(|(i, ty)| {\n-                let mut name = names.get(i).map_or(kw::Empty, |ident| ident.name);\n-                if name.is_empty() {\n-                    name = kw::Underscore;\n-                }\n-                Argument { name, type_: clean_ty(ty, cx), is_const: false }\n+            .map(|(i, ty)| Argument {\n+                type_: clean_ty(ty, cx),\n+                name: names\n+                    .get(i)\n+                    .map(|ident| ident.name)\n+                    .filter(|ident| !ident.is_empty())\n+                    .unwrap_or(kw::Underscore),\n+                is_const: false,\n             })\n             .collect(),\n     }\n@@ -1024,7 +1022,11 @@ fn clean_fn_decl_from_did_and_sig<'tcx>(\n                 .iter()\n                 .map(|t| Argument {\n                     type_: clean_middle_ty(*t, cx, None),\n-                    name: names.next().map_or(kw::Empty, |i| i.name),\n+                    name: names\n+                        .next()\n+                        .map(|i| i.name)\n+                        .filter(|i| !i.is_empty())\n+                        .unwrap_or(kw::Underscore),\n                     is_const: false,\n                 })\n                 .collect(),\n@@ -1144,12 +1146,25 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n             }\n         }\n         ty::AssocKind::Fn => {\n-            let generics = clean_ty_generics(\n+            let sig = tcx.fn_sig(assoc_item.def_id);\n+\n+            let late_bound_regions = sig.bound_vars().into_iter().filter_map(|var| match var {\n+                ty::BoundVariableKind::Region(ty::BrNamed(_, name))\n+                    if name != kw::UnderscoreLifetime =>\n+                {\n+                    Some(GenericParamDef::lifetime(name))\n+                }\n+                _ => None,\n+            });\n+\n+            let mut generics = clean_ty_generics(\n                 cx,\n                 tcx.generics_of(assoc_item.def_id),\n                 tcx.explicit_predicates_of(assoc_item.def_id),\n             );\n-            let sig = tcx.fn_sig(assoc_item.def_id);\n+            // FIXME: This does not place parameters in source order (late-bound ones come last)\n+            generics.params.extend(late_bound_regions);\n+\n             let mut decl = clean_fn_decl_from_did_and_sig(cx, Some(assoc_item.def_id), sig);\n \n             if assoc_item.fn_has_self_parameter {\n@@ -1200,7 +1215,7 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                         true\n                     }\n                     (GenericParamDefKind::Const { .. }, GenericArg::Const(c)) => match &c.kind {\n-                        ConstantKind::TyConst { expr } => expr == param.name.as_str(),\n+                        ConstantKind::TyConst { expr } => **expr == *param.name.as_str(),\n                         _ => false,\n                     },\n                     _ => false,\n@@ -1281,7 +1296,16 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n                         ..\n                     }) = generics.params.iter_mut().find(|param| &param.name == arg)\n                     {\n-                        param_bounds.extend(mem::take(bounds));\n+                        param_bounds.append(bounds);\n+                    } else if let WherePredicate::RegionPredicate { lifetime: Lifetime(arg), bounds } = &mut pred\n+                    && let Some(GenericParamDef {\n+                        kind: GenericParamDefKind::Lifetime { outlives: param_bounds },\n+                        ..\n+                    }) = generics.params.iter_mut().find(|param| &param.name == arg) {\n+                        param_bounds.extend(bounds.drain(..).map(|bound| match bound {\n+                            GenericBound::Outlives(lifetime) => lifetime,\n+                            _ => unreachable!(),\n+                        }));\n                     } else {\n                         where_predicates.push(pred);\n                     }\n@@ -1530,7 +1554,7 @@ pub(crate) fn clean_ty<'tcx>(ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> T\n                 }\n             };\n \n-            Array(Box::new(clean_ty(ty, cx)), length)\n+            Array(Box::new(clean_ty(ty, cx)), length.into())\n         }\n         TyKind::Tup(tys) => Tuple(tys.iter().map(|ty| clean_ty(ty, cx)).collect()),\n         TyKind::OpaqueDef(item_id, _, _) => {\n@@ -1602,7 +1626,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n         ty::Array(ty, mut n) => {\n             n = n.eval(cx.tcx, ty::ParamEnv::reveal_all());\n             let n = print_const(cx, n);\n-            Array(Box::new(clean_middle_ty(ty, cx, None)), n)\n+            Array(Box::new(clean_middle_ty(ty, cx, None)), n.into())\n         }\n         ty::RawPtr(mt) => RawPointer(mt.mutbl, Box::new(clean_middle_ty(mt.ty, cx, None))),\n         ty::Ref(r, ty, mutbl) => BorrowedRef {\n@@ -1653,6 +1677,9 @@ pub(crate) fn clean_middle_ty<'tcx>(\n \n             inline::record_extern_fqn(cx, did, ItemType::Trait);\n \n+            // FIXME(fmease): Hide the trait-object lifetime bound if it coincides with its default\n+            // to partially address #44306. Follow the rules outlined at\n+            // https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes\n             let lifetime = clean_middle_region(*reg);\n             let mut bounds = dids\n                 .map(|did| {\n@@ -1680,8 +1707,22 @@ pub(crate) fn clean_middle_ty<'tcx>(\n                 })\n                 .collect();\n \n+            let late_bound_regions: FxIndexSet<_> = obj\n+                .iter()\n+                .flat_map(|pb| pb.bound_vars())\n+                .filter_map(|br| match br {\n+                    ty::BoundVariableKind::Region(ty::BrNamed(_, name))\n+                        if name != kw::UnderscoreLifetime =>\n+                    {\n+                        Some(GenericParamDef::lifetime(name))\n+                    }\n+                    _ => None,\n+                })\n+                .collect();\n+            let late_bound_regions = late_bound_regions.into_iter().collect();\n+\n             let path = external_path(cx, did, false, bindings, substs);\n-            bounds.insert(0, PolyTrait { trait_: path, generic_params: Vec::new() });\n+            bounds.insert(0, PolyTrait { trait_: path, generic_params: late_bound_regions });\n \n             DynTrait(bounds, lifetime)\n         }"}, {"sha": "7d97d2994e460ee3d46ba6d1169032109ea9d245", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -51,10 +51,7 @@ pub(crate) fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> ThinVec<WP\n         let Some((bounds, _)) = tybounds.get_mut(ty) else { return true };\n         let bound_params = bound_params\n             .into_iter()\n-            .map(|param| clean::GenericParamDef {\n-                name: param.0,\n-                kind: clean::GenericParamDefKind::Lifetime { outlives: Vec::new() },\n-            })\n+            .map(|param| clean::GenericParamDef::lifetime(param.0))\n             .collect();\n         merge_bounds(cx, bounds, bound_params, trait_did, name, rhs)\n     });\n@@ -99,9 +96,8 @@ pub(crate) fn merge_bounds(\n         let last = trait_ref.trait_.segments.last_mut().expect(\"segments were empty\");\n \n         trait_ref.generic_params.append(&mut bound_params);\n-        // Since the parameters (probably) originate from `tcx.collect_*_late_bound_regions` which\n-        // returns a hash set, sort them alphabetically to guarantee a stable and deterministic\n-        // output (and to fully deduplicate them).\n+        // Sort parameters (likely) originating from a hashset alphabetically to\n+        // produce predictable output (and to allow for full deduplication).\n         trait_ref.generic_params.sort_unstable_by(|p, q| p.name.as_str().cmp(q.name.as_str()));\n         trait_ref.generic_params.dedup_by_key(|p| p.name);\n "}, {"sha": "3d13f7463cbb09d5428251cf416e01ac1c1c3e3b", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1437,6 +1437,10 @@ pub(crate) struct GenericParamDef {\n }\n \n impl GenericParamDef {\n+    pub(crate) fn lifetime(name: Symbol) -> Self {\n+        Self { name, kind: GenericParamDefKind::Lifetime { outlives: Vec::new() } }\n+    }\n+\n     pub(crate) fn is_synthetic_type_param(&self) -> bool {\n         match self.kind {\n             GenericParamDefKind::Lifetime { .. } | GenericParamDefKind::Const { .. } => false,\n@@ -1621,7 +1625,7 @@ pub(crate) enum Type {\n     /// An array type.\n     ///\n     /// The `String` field is a stringified version of the array's length parameter.\n-    Array(Box<Type>, String),\n+    Array(Box<Type>, Box<str>),\n     /// A raw pointer type: `*const i32`, `*mut i32`\n     RawPointer(Mutability, Box<Type>),\n     /// A reference type: `&i32`, `&'a mut Foo`\n@@ -2206,7 +2210,7 @@ impl Span {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub(crate) struct Path {\n     pub(crate) res: Res,\n-    pub(crate) segments: Vec<PathSegment>,\n+    pub(crate) segments: ThinVec<PathSegment>,\n }\n \n impl Path {\n@@ -2356,7 +2360,7 @@ pub(crate) enum ConstantKind {\n     ///\n     /// Note that `ty::Const` includes generic parameters, and may not always be uniquely identified\n     /// by a DefId. So this field must be different from `Extern`.\n-    TyConst { expr: String },\n+    TyConst { expr: Box<str> },\n     /// A constant (expression) that's not an item or associated item. These are usually found\n     /// nested inside types (e.g., array lengths) or expressions (e.g., repeat counts), and also\n     /// used to define explicit discriminant values for enum variants.\n@@ -2384,7 +2388,7 @@ impl Constant {\n impl ConstantKind {\n     pub(crate) fn expr(&self, tcx: TyCtxt<'_>) -> String {\n         match *self {\n-            ConstantKind::TyConst { ref expr } => expr.clone(),\n+            ConstantKind::TyConst { ref expr } => expr.to_string(),\n             ConstantKind::Extern { def_id } => print_inlined_const(tcx, def_id),\n             ConstantKind::Local { body, .. } | ConstantKind::Anonymous { body } => {\n                 print_const_expr(tcx, body)\n@@ -2570,13 +2574,13 @@ mod size_asserts {\n     // tidy-alphabetical-start\n     static_assert_size!(Crate, 72); // frequently moved by-value\n     static_assert_size!(DocFragment, 32);\n-    static_assert_size!(GenericArg, 48);\n+    static_assert_size!(GenericArg, 32);\n     static_assert_size!(GenericArgs, 32);\n     static_assert_size!(GenericParamDef, 56);\n     static_assert_size!(Generics, 16);\n     static_assert_size!(Item, 56);\n-    static_assert_size!(ItemKind, 88);\n+    static_assert_size!(ItemKind, 64);\n     static_assert_size!(PathSegment, 40);\n-    static_assert_size!(Type, 48);\n+    static_assert_size!(Type, 32);\n     // tidy-alphabetical-end\n }"}, {"sha": "21f8fbe36f173fdf318079caa785f9d4116f9dca", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -4,7 +4,7 @@ use crate::clean::render_macro_matchers::render_macro_matcher;\n use crate::clean::{\n     clean_doc_module, clean_middle_const, clean_middle_region, clean_middle_ty, inline, Crate,\n     ExternalCrate, Generic, GenericArg, GenericArgs, ImportSource, Item, ItemKind, Lifetime, Path,\n-    PathSegment, Primitive, PrimitiveType, Type, TypeBinding,\n+    PathSegment, Primitive, PrimitiveType, Term, Type, TypeBinding, TypeBindingKind,\n };\n use crate::core::DocContext;\n use crate::html::format::visibility_to_src_with_space;\n@@ -21,7 +21,7 @@ use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_span::symbol::{kw, sym, Symbol};\n use std::fmt::Write as _;\n use std::mem;\n-use thin_vec::ThinVec;\n+use thin_vec::{thin_vec, ThinVec};\n \n #[cfg(test)]\n mod tests;\n@@ -113,12 +113,12 @@ fn external_generic_args<'tcx>(\n                 ty::Tuple(tys) => tys.iter().map(|t| clean_middle_ty(t, cx, None)).collect::<Vec<_>>().into(),\n                 _ => return GenericArgs::AngleBracketed { args: args.into(), bindings },\n             };\n-        let output = None;\n-        // FIXME(#20299) return type comes from a projection now\n-        // match types[1].kind {\n-        //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n-        //     _ => Some(types[1].clean(cx))\n-        // };\n+        let output = bindings.into_iter().next().and_then(|binding| match binding.kind {\n+            TypeBindingKind::Equality { term: Term::Type(ty) } if ty != Type::Tuple(Vec::new()) => {\n+                Some(Box::new(ty))\n+            }\n+            _ => None,\n+        });\n         GenericArgs::Parenthesized { inputs, output }\n     } else {\n         GenericArgs::AngleBracketed { args: args.into(), bindings: bindings.into() }\n@@ -136,7 +136,7 @@ pub(super) fn external_path<'tcx>(\n     let name = cx.tcx.item_name(did);\n     Path {\n         res: Res::Def(def_kind, did),\n-        segments: vec![PathSegment {\n+        segments: thin_vec![PathSegment {\n             name,\n             args: external_generic_args(cx, did, has_self, bindings, substs),\n         }],\n@@ -242,19 +242,13 @@ pub(crate) fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n \n             s\n         }\n-        _ => {\n-            let mut s = n.to_string();\n-            // array lengths are obviously usize\n-            if s.ends_with(\"_usize\") {\n-                let n = s.len() - \"_usize\".len();\n-                s.truncate(n);\n-                if s.ends_with(\": \") {\n-                    let n = s.len() - \": \".len();\n-                    s.truncate(n);\n-                }\n-            }\n-            s\n+        // array lengths are obviously usize\n+        ty::ConstKind::Value(ty::ValTree::Leaf(scalar))\n+            if *n.ty().kind() == ty::Uint(ty::UintTy::Usize) =>\n+        {\n+            scalar.to_string()\n         }\n+        _ => n.to_string(),\n     }\n }\n "}, {"sha": "789dd398be50d7298da6dd2bdbfae5e9df742142", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -239,9 +239,6 @@ pub(crate) struct RenderOptions {\n     pub(crate) default_settings: FxHashMap<String, String>,\n     /// If present, suffix added to CSS/JavaScript files when referencing them in generated pages.\n     pub(crate) resource_suffix: String,\n-    /// Whether to run the static CSS/JavaScript through a minifier when outputting them. `true` by\n-    /// default.\n-    pub(crate) enable_minification: bool,\n     /// Whether to create an index page in the root of the output directory. If this is true but\n     /// `enable_index_page` is None, generate a static listing of crates instead.\n     pub(crate) enable_index_page: bool,\n@@ -329,7 +326,7 @@ impl Options {\n             crate::usage(\"rustdoc\");\n             return Err(0);\n         } else if matches.opt_present(\"version\") {\n-            rustc_driver::version(\"rustdoc\", matches);\n+            rustc_driver::version!(\"rustdoc\", matches);\n             return Err(0);\n         }\n \n@@ -416,7 +413,9 @@ impl Options {\n \n         let to_check = matches.opt_strs(\"check-theme\");\n         if !to_check.is_empty() {\n-            let paths = match theme::load_css_paths(static_files::themes::LIGHT) {\n+            let paths = match theme::load_css_paths(\n+                std::str::from_utf8(static_files::STATIC_FILES.theme_light_css.bytes).unwrap(),\n+            ) {\n                 Ok(p) => p,\n                 Err(e) => {\n                     diag.struct_err(&e.to_string()).emit();\n@@ -557,7 +556,9 @@ impl Options {\n \n         let mut themes = Vec::new();\n         if matches.opt_present(\"theme\") {\n-            let paths = match theme::load_css_paths(static_files::themes::LIGHT) {\n+            let paths = match theme::load_css_paths(\n+                std::str::from_utf8(static_files::STATIC_FILES.theme_light_css.bytes).unwrap(),\n+            ) {\n                 Ok(p) => p,\n                 Err(e) => {\n                     diag.struct_err(&e.to_string()).emit();\n@@ -675,7 +676,6 @@ impl Options {\n             ModuleSorting::Alphabetical\n         };\n         let resource_suffix = matches.opt_str(\"resource-suffix\").unwrap_or_default();\n-        let enable_minification = !matches.opt_present(\"disable-minification\");\n         let markdown_no_toc = matches.opt_present(\"markdown-no-toc\");\n         let markdown_css = matches.opt_strs(\"markdown-css\");\n         let markdown_playground_url = matches.opt_str(\"markdown-playground-url\");\n@@ -768,7 +768,6 @@ impl Options {\n             extern_html_root_takes_precedence,\n             default_settings,\n             resource_suffix,\n-            enable_minification,\n             enable_index_page,\n             index_page,\n             static_root_path,"}, {"sha": "a5c3d35b1b594ec9bcbc3ba401c23d7fccfb4944", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1232,9 +1232,8 @@ impl clean::Arguments {\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             for (i, input) in self.values.iter().enumerate() {\n-                if !input.name.is_empty() {\n-                    write!(f, \"{}: \", input.name)?;\n-                }\n+                write!(f, \"{}: \", input.name)?;\n+\n                 if f.alternate() {\n                     write!(f, \"{:#}\", input.type_.print(cx))?;\n                 } else {\n@@ -1367,10 +1366,8 @@ impl clean::FnDecl {\n                     args.push_str(\"const \");\n                     args_plain.push_str(\"const \");\n                 }\n-                if !input.name.is_empty() {\n-                    write!(args, \"{}: \", input.name);\n-                    write!(args_plain, \"{}: \", input.name);\n-                }\n+                write!(args, \"{}: \", input.name);\n+                write!(args_plain, \"{}: \", input.name);\n \n                 if f.alternate() {\n                     write!(args, \"{:#}\", input.type_.print(cx));"}, {"sha": "a60e7cb10fa515c8b4f17745808f7f8d3d575f70", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -2,13 +2,14 @@ use std::path::PathBuf;\n \n use rustc_data_structures::fx::FxHashMap;\n \n-use crate::error::Error;\n use crate::externalfiles::ExternalHtml;\n use crate::html::format::{Buffer, Print};\n use crate::html::render::{ensure_trailing_slash, StylePath};\n \n use askama::Template;\n \n+use super::static_files::{StaticFiles, STATIC_FILES};\n+\n #[derive(Clone)]\n pub(crate) struct Layout {\n     pub(crate) logo: String,\n@@ -34,17 +35,23 @@ pub(crate) struct Page<'a> {\n }\n \n impl<'a> Page<'a> {\n-    pub(crate) fn get_static_root_path(&self) -> &str {\n-        self.static_root_path.unwrap_or(self.root_path)\n+    pub(crate) fn get_static_root_path(&self) -> String {\n+        match self.static_root_path {\n+            Some(s) => s.to_string(),\n+            None => format!(\"{}static.files/\", self.root_path),\n+        }\n     }\n }\n \n #[derive(Template)]\n #[template(path = \"page.html\")]\n struct PageLayout<'a> {\n-    static_root_path: &'a str,\n+    static_root_path: String,\n     page: &'a Page<'a>,\n     layout: &'a Layout,\n+\n+    files: &'static StaticFiles,\n+\n     themes: Vec<String>,\n     sidebar: String,\n     content: String,\n@@ -61,19 +68,17 @@ pub(crate) fn render<T: Print, S: Print>(\n ) -> String {\n     let static_root_path = page.get_static_root_path();\n     let krate_with_trailing_slash = ensure_trailing_slash(&layout.krate).to_string();\n-    let mut themes: Vec<String> = style_files\n-        .iter()\n-        .map(StylePath::basename)\n-        .collect::<Result<_, Error>>()\n-        .unwrap_or_default();\n+    let mut themes: Vec<String> = style_files.iter().map(|s| s.basename().unwrap()).collect();\n     themes.sort();\n-    let rustdoc_version = rustc_interface::util::version_str().unwrap_or(\"unknown version\");\n+\n+    let rustdoc_version = rustc_interface::util::version_str!().unwrap_or(\"unknown version\");\n     let content = Buffer::html().to_display(t); // Note: This must happen before making the sidebar.\n     let sidebar = Buffer::html().to_display(sidebar);\n     PageLayout {\n         static_root_path,\n         page,\n         layout,\n+        files: &STATIC_FILES,\n         themes,\n         sidebar,\n         content,"}, {"sha": "51843a505f7095963ed97be0ba98f946439c869a", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -32,7 +32,7 @@ use crate::html::escape::Escape;\n use crate::html::format::{join_with_double_colon, Buffer};\n use crate::html::markdown::{self, plain_text_summary, ErrorCodes, IdMap};\n use crate::html::url_parts_builder::UrlPartsBuilder;\n-use crate::html::{layout, sources};\n+use crate::html::{layout, sources, static_files};\n use crate::scrape_examples::AllCallLocations;\n use crate::try_err;\n \n@@ -498,7 +498,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         );\n \n         let (sender, receiver) = channel();\n-        let mut scx = SharedContext {\n+        let scx = SharedContext {\n             tcx,\n             src_root,\n             local_sources,\n@@ -521,19 +521,6 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             call_locations,\n         };\n \n-        // Add the default themes to the `Vec` of stylepaths\n-        //\n-        // Note that these must be added before `sources::render` is called\n-        // so that the resulting source pages are styled\n-        //\n-        // `light.css` is not disabled because it is the stylesheet that stays loaded\n-        // by the browser as the theme stylesheet. The theme system (hackily) works by\n-        // changing the href to this stylesheet. All other themes are disabled to\n-        // prevent rule conflicts\n-        scx.style_files.push(StylePath { path: PathBuf::from(\"light.css\") });\n-        scx.style_files.push(StylePath { path: PathBuf::from(\"dark.css\") });\n-        scx.style_files.push(StylePath { path: PathBuf::from(\"ayu.css\") });\n-\n         let dst = output;\n         scx.ensure_dir(&dst)?;\n \n@@ -647,10 +634,11 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n                         </section>\\\n                      </noscript>\\\n                      <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" \\\n-                         href=\\\"{root_path}settings{suffix}.css\\\">\\\n-                     <script defer src=\\\"{root_path}settings{suffix}.js\\\"></script>\",\n-                    root_path = page.static_root_path.unwrap_or(\"\"),\n-                    suffix = page.resource_suffix,\n+                         href=\\\"{static_root_path}{settings_css}\\\">\\\n+                     <script defer src=\\\"{static_root_path}{settings_js}\\\"></script>\",\n+                    static_root_path = page.get_static_root_path(),\n+                    settings_css = static_files::STATIC_FILES.settings_css,\n+                    settings_js = static_files::STATIC_FILES.settings_js,\n                 )\n             },\n             &shared.style_files,"}, {"sha": "ce4fc4d68fac2452ff2aad0307af05ef4ff77871", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -30,10 +30,10 @@ use crate::html::format::{\n     join_with_double_colon, print_abi_with_space, print_constness_with_space, print_where_clause,\n     visibility_print_with_space, Buffer, Ending, PrintWithSpace,\n };\n-use crate::html::highlight;\n use crate::html::layout::Page;\n use crate::html::markdown::{HeadingOffset, MarkdownSummaryLine};\n use crate::html::url_parts_builder::UrlPartsBuilder;\n+use crate::html::{highlight, static_files};\n \n use askama::Template;\n use itertools::Itertools;\n@@ -52,8 +52,8 @@ struct PathComponent {\n #[derive(Template)]\n #[template(path = \"print_item.html\")]\n struct ItemVars<'a> {\n-    page: &'a Page<'a>,\n     static_root_path: &'a str,\n+    clipboard_svg: &'static static_files::StaticFile,\n     typ: &'a str,\n     name: &'a str,\n     item_type: &'a str,\n@@ -147,8 +147,8 @@ pub(super) fn print_item(\n     };\n \n     let item_vars = ItemVars {\n-        page,\n-        static_root_path: page.get_static_root_path(),\n+        static_root_path: &page.get_static_root_path(),\n+        clipboard_svg: &static_files::STATIC_FILES.clipboard_svg,\n         typ,\n         name: item.name.as_ref().unwrap().as_str(),\n         item_type: &item.type_().to_string(),"}, {"sha": "94d8a9feca69d5010c0a36f4670547856dda22bf", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 49, "deletions": 241, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -1,10 +1,8 @@\n-use std::ffi::OsStr;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n-use std::path::{Component, Path, PathBuf};\n+use std::path::{Component, Path};\n use std::rc::Rc;\n-use std::sync::LazyLock as Lazy;\n \n use itertools::Itertools;\n use rustc_data_structures::flock;\n@@ -20,123 +18,20 @@ use crate::error::Error;\n use crate::html::{layout, static_files};\n use crate::{try_err, try_none};\n \n-static FILES_UNVERSIONED: Lazy<FxHashMap<&str, &[u8]>> = Lazy::new(|| {\n-    map! {\n-        \"FiraSans-Regular.woff2\" => static_files::fira_sans::REGULAR,\n-        \"FiraSans-Medium.woff2\" => static_files::fira_sans::MEDIUM,\n-        \"FiraSans-LICENSE.txt\" => static_files::fira_sans::LICENSE,\n-        \"SourceSerif4-Regular.ttf.woff2\" => static_files::source_serif_4::REGULAR,\n-        \"SourceSerif4-Bold.ttf.woff2\" => static_files::source_serif_4::BOLD,\n-        \"SourceSerif4-It.ttf.woff2\" => static_files::source_serif_4::ITALIC,\n-        \"SourceSerif4-LICENSE.md\" => static_files::source_serif_4::LICENSE,\n-        \"SourceCodePro-Regular.ttf.woff2\" => static_files::source_code_pro::REGULAR,\n-        \"SourceCodePro-Semibold.ttf.woff2\" => static_files::source_code_pro::SEMIBOLD,\n-        \"SourceCodePro-It.ttf.woff2\" => static_files::source_code_pro::ITALIC,\n-        \"SourceCodePro-LICENSE.txt\" => static_files::source_code_pro::LICENSE,\n-        \"NanumBarunGothic.ttf.woff2\" => static_files::nanum_barun_gothic::REGULAR,\n-        \"NanumBarunGothic-LICENSE.txt\" => static_files::nanum_barun_gothic::LICENSE,\n-        \"LICENSE-MIT.txt\" => static_files::LICENSE_MIT,\n-        \"LICENSE-APACHE.txt\" => static_files::LICENSE_APACHE,\n-        \"COPYRIGHT.txt\" => static_files::COPYRIGHT,\n-    }\n-});\n-\n-enum SharedResource<'a> {\n-    /// This file will never change, no matter what toolchain is used to build it.\n-    ///\n-    /// It does not have a resource suffix.\n-    Unversioned { name: &'static str },\n-    /// This file may change depending on the toolchain.\n-    ///\n-    /// It has a resource suffix.\n-    ToolchainSpecific { basename: &'static str },\n-    /// This file may change for any crate within a build, or based on the CLI arguments.\n-    ///\n-    /// This differs from normal invocation-specific files because it has a resource suffix.\n-    InvocationSpecific { basename: &'a str },\n-}\n-\n-impl SharedResource<'_> {\n-    fn extension(&self) -> Option<&OsStr> {\n-        use SharedResource::*;\n-        match self {\n-            Unversioned { name }\n-            | ToolchainSpecific { basename: name }\n-            | InvocationSpecific { basename: name } => Path::new(name).extension(),\n-        }\n-    }\n-\n-    fn path(&self, cx: &Context<'_>) -> PathBuf {\n-        match self {\n-            SharedResource::Unversioned { name } => cx.dst.join(name),\n-            SharedResource::ToolchainSpecific { basename } => cx.suffix_path(basename),\n-            SharedResource::InvocationSpecific { basename } => cx.suffix_path(basename),\n-        }\n-    }\n-\n-    fn should_emit(&self, emit: &[EmitType]) -> bool {\n-        if emit.is_empty() {\n-            return true;\n-        }\n-        let kind = match self {\n-            SharedResource::Unversioned { .. } => EmitType::Unversioned,\n-            SharedResource::ToolchainSpecific { .. } => EmitType::Toolchain,\n-            SharedResource::InvocationSpecific { .. } => EmitType::InvocationSpecific,\n-        };\n-        emit.contains(&kind)\n-    }\n-}\n-\n-impl Context<'_> {\n-    fn suffix_path(&self, filename: &str) -> PathBuf {\n-        // We use splitn vs Path::extension here because we might get a filename\n-        // like `style.min.css` and we want to process that into\n-        // `style-suffix.min.css`.  Path::extension would just return `css`\n-        // which would result in `style.min-suffix.css` which isn't what we\n-        // want.\n-        let (base, ext) = filename.split_once('.').unwrap();\n-        let filename = format!(\"{}{}.{}\", base, self.shared.resource_suffix, ext);\n-        self.dst.join(&filename)\n-    }\n-\n-    fn write_shared(\n-        &self,\n-        resource: SharedResource<'_>,\n-        contents: impl 'static + Send + AsRef<[u8]>,\n-        emit: &[EmitType],\n-    ) -> Result<(), Error> {\n-        if resource.should_emit(emit) {\n-            self.shared.fs.write(resource.path(self), contents)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn write_minify(\n-        &self,\n-        resource: SharedResource<'_>,\n-        contents: impl 'static + Send + AsRef<str> + AsRef<[u8]>,\n-        minify: bool,\n-        emit: &[EmitType],\n-    ) -> Result<(), Error> {\n-        if minify {\n-            let contents = contents.as_ref();\n-            let contents = if resource.extension() == Some(OsStr::new(\"css\")) {\n-                minifier::css::minify(contents)\n-                    .map_err(|e| {\n-                        Error::new(format!(\"failed to minify CSS file: {}\", e), resource.path(self))\n-                    })?\n-                    .to_string()\n-            } else {\n-                minifier::js::minify(contents).to_string()\n-            };\n-            self.write_shared(resource, contents, emit)\n-        } else {\n-            self.write_shared(resource, contents, emit)\n-        }\n-    }\n-}\n-\n+/// Rustdoc writes out two kinds of shared files:\n+///  - Static files, which are embedded in the rustdoc binary and are written with a\n+///    filename that includes a hash of their contents. These will always have a new\n+///    URL if the contents change, so they are safe to cache with the\n+///    `Cache-Control: immutable` directive. They are written under the static.files/\n+///    directory and are written when --emit-type is empty (default) or contains\n+///    \"toolchain-specific\". If using the --static-root-path flag, it should point\n+///    to a URL path prefix where each of these filenames can be fetched.\n+///  - Invocation specific files. These are generated based on the crate(s) being\n+///    documented. Their filenames need to be predictable without knowing their\n+///    contents, so they do not include a hash in their filename and are not safe to\n+///    cache with `Cache-Control: immutable`. They include the contents of the\n+///    --resource-suffix flag and are emitted when --emit-type is empty (default)\n+///    or contains \"invocation-specific\".\n pub(super) fn write_shared(\n     cx: &mut Context<'_>,\n     krate: &Crate,\n@@ -149,139 +44,52 @@ pub(super) fn write_shared(\n     let lock_file = cx.dst.join(\".lock\");\n     let _lock = try_err!(flock::Lock::new(&lock_file, true, true, true), &lock_file);\n \n-    // Minified resources are usually toolchain resources. If they're not, they should use `cx.write_minify` directly.\n-    fn write_minify(\n-        basename: &'static str,\n-        contents: impl 'static + Send + AsRef<str> + AsRef<[u8]>,\n-        cx: &Context<'_>,\n-        options: &RenderOptions,\n-    ) -> Result<(), Error> {\n-        cx.write_minify(\n-            SharedResource::ToolchainSpecific { basename },\n-            contents,\n-            options.enable_minification,\n-            &options.emit,\n-        )\n-    }\n-\n-    // Toolchain resources should never be dynamic.\n-    let write_toolchain = |p: &'static _, c: &'static _| {\n-        cx.write_shared(SharedResource::ToolchainSpecific { basename: p }, c, &options.emit)\n-    };\n-\n-    // Crate resources should always be dynamic.\n-    let write_crate = |p: &_, make_content: &dyn Fn() -> Result<Vec<u8>, Error>| {\n+    // InvocationSpecific resources should always be dynamic.\n+    let write_invocation_specific = |p: &str, make_content: &dyn Fn() -> Result<Vec<u8>, Error>| {\n         let content = make_content()?;\n-        cx.write_shared(SharedResource::InvocationSpecific { basename: p }, content, &options.emit)\n+        if options.emit.is_empty() || options.emit.contains(&EmitType::InvocationSpecific) {\n+            let output_filename = static_files::suffix_path(p, &cx.shared.resource_suffix);\n+            cx.shared.fs.write(cx.dst.join(output_filename), content)\n+        } else {\n+            Ok(())\n+        }\n     };\n \n-    // Given \"foo.svg\", return e.g. \"url(\\\"foo1.58.0.svg\\\")\"\n-    fn ver_url(cx: &Context<'_>, basename: &'static str) -> String {\n-        format!(\n-            \"url(\\\"{}\\\")\",\n-            SharedResource::ToolchainSpecific { basename }\n-                .path(cx)\n-                .file_name()\n-                .unwrap()\n-                .to_str()\n-                .unwrap()\n-        )\n-    }\n-\n-    // We use the AUTOREPLACE mechanism to inject into our static JS and CSS certain\n-    // values that are only known at doc build time. Since this mechanism is somewhat\n-    // surprising when reading the code, please limit it to rustdoc.css.\n-    write_minify(\n-        \"rustdoc.css\",\n-        static_files::RUSTDOC_CSS\n-            .replace(\n-                \"/* AUTOREPLACE: */url(\\\"toggle-minus.svg\\\")\",\n-                &ver_url(cx, \"toggle-minus.svg\"),\n-            )\n-            .replace(\"/* AUTOREPLACE: */url(\\\"toggle-plus.svg\\\")\", &ver_url(cx, \"toggle-plus.svg\"))\n-            .replace(\"/* AUTOREPLACE: */url(\\\"down-arrow.svg\\\")\", &ver_url(cx, \"down-arrow.svg\")),\n-        cx,\n-        options,\n-    )?;\n-\n-    // Add all the static files. These may already exist, but we just\n-    // overwrite them anyway to make sure that they're fresh and up-to-date.\n-    write_minify(\"settings.css\", static_files::SETTINGS_CSS, cx, options)?;\n-    write_minify(\"noscript.css\", static_files::NOSCRIPT_CSS, cx, options)?;\n-\n-    // To avoid \"light.css\" to be overwritten, we'll first run over the received themes and only\n-    // then we'll run over the \"official\" styles.\n-    let mut themes: FxHashSet<String> = FxHashSet::default();\n+    cx.shared\n+        .fs\n+        .create_dir_all(cx.dst.join(\"static.files\"))\n+        .map_err(|e| PathError::new(e, \"static.files\"))?;\n \n+    // Handle added third-party themes\n     for entry in &cx.shared.style_files {\n         let theme = entry.basename()?;\n         let extension =\n             try_none!(try_none!(entry.path.extension(), &entry.path).to_str(), &entry.path);\n \n-        // Handle the official themes\n-        match theme.as_str() {\n-            \"light\" => write_minify(\"light.css\", static_files::themes::LIGHT, cx, options)?,\n-            \"dark\" => write_minify(\"dark.css\", static_files::themes::DARK, cx, options)?,\n-            \"ayu\" => write_minify(\"ayu.css\", static_files::themes::AYU, cx, options)?,\n-            _ => {\n-                // Handle added third-party themes\n-                let filename = format!(\"{}.{}\", theme, extension);\n-                write_crate(&filename, &|| Ok(try_err!(fs::read(&entry.path), &entry.path)))?;\n-            }\n-        };\n-\n-        themes.insert(theme.to_owned());\n-    }\n-\n-    if (*cx.shared).layout.logo.is_empty() {\n-        write_toolchain(\"rust-logo.svg\", static_files::RUST_LOGO_SVG)?;\n-    }\n-    if (*cx.shared).layout.favicon.is_empty() {\n-        write_toolchain(\"favicon.svg\", static_files::RUST_FAVICON_SVG)?;\n-        write_toolchain(\"favicon-16x16.png\", static_files::RUST_FAVICON_PNG_16)?;\n-        write_toolchain(\"favicon-32x32.png\", static_files::RUST_FAVICON_PNG_32)?;\n-    }\n-    write_toolchain(\"wheel.svg\", static_files::WHEEL_SVG)?;\n-    write_toolchain(\"clipboard.svg\", static_files::CLIPBOARD_SVG)?;\n-    write_toolchain(\"down-arrow.svg\", static_files::DOWN_ARROW_SVG)?;\n-    write_toolchain(\"toggle-minus.svg\", static_files::TOGGLE_MINUS_PNG)?;\n-    write_toolchain(\"toggle-plus.svg\", static_files::TOGGLE_PLUS_PNG)?;\n-\n-    let mut themes: Vec<&String> = themes.iter().collect();\n-    themes.sort();\n-\n-    write_minify(\"main.js\", static_files::MAIN_JS, cx, options)?;\n-    write_minify(\"search.js\", static_files::SEARCH_JS, cx, options)?;\n-    write_minify(\"settings.js\", static_files::SETTINGS_JS, cx, options)?;\n-\n-    if cx.include_sources {\n-        write_minify(\"source-script.js\", static_files::sidebar::SOURCE_SCRIPT, cx, options)?;\n-    }\n-\n-    write_minify(\"storage.js\", static_files::STORAGE_JS, cx, options)?;\n+        // Skip the official themes. They are written below as part of STATIC_FILES_LIST.\n+        if matches!(theme.as_str(), \"light\" | \"dark\" | \"ayu\") {\n+            continue;\n+        }\n \n-    if cx.shared.layout.scrape_examples_extension {\n-        cx.write_minify(\n-            SharedResource::InvocationSpecific { basename: \"scrape-examples.js\" },\n-            static_files::SCRAPE_EXAMPLES_JS,\n-            options.enable_minification,\n-            &options.emit,\n-        )?;\n+        let bytes = try_err!(fs::read(&entry.path), &entry.path);\n+        let filename = format!(\"{}{}.{}\", theme, cx.shared.resource_suffix, extension);\n+        cx.shared.fs.write(cx.dst.join(filename), bytes)?;\n     }\n \n+    // When the user adds their own CSS files with --extend-css, we write that as an\n+    // invocation-specific file (that is, with a resource suffix).\n     if let Some(ref css) = cx.shared.layout.css_file_extension {\n         let buffer = try_err!(fs::read_to_string(css), css);\n-        // This varies based on the invocation, so it can't go through the write_minify wrapper.\n-        cx.write_minify(\n-            SharedResource::InvocationSpecific { basename: \"theme.css\" },\n-            buffer,\n-            options.enable_minification,\n-            &options.emit,\n-        )?;\n+        let path = static_files::suffix_path(\"theme.css\", &cx.shared.resource_suffix);\n+        cx.shared.fs.write(cx.dst.join(path), buffer)?;\n     }\n-    write_minify(\"normalize.css\", static_files::NORMALIZE_CSS, cx, options)?;\n-    for (name, contents) in &*FILES_UNVERSIONED {\n-        cx.write_shared(SharedResource::Unversioned { name }, contents, &options.emit)?;\n+\n+    if options.emit.is_empty() || options.emit.contains(&EmitType::Toolchain) {\n+        let static_dir = cx.dst.join(Path::new(\"static.files\"));\n+        static_files::for_each(|f: &static_files::StaticFile| {\n+            let filename = static_dir.join(f.output_filename());\n+            cx.shared.fs.write(filename, f.minified())\n+        })?;\n     }\n \n     /// Read a file and return all lines that match the `\"{crate}\":{data},` format,\n@@ -463,7 +271,7 @@ pub(super) fn write_shared(\n             v.push_str(\"\\\\\\n}');\\ncreateSourceSidebar();\\n\");\n             Ok(v.into_bytes())\n         };\n-        write_crate(\"source-files.js\", &make_sources)?;\n+        write_invocation_specific(\"source-files.js\", &make_sources)?;\n     }\n \n     // Update the search index and crate list.\n@@ -477,7 +285,7 @@ pub(super) fn write_shared(\n     // Sort the indexes by crate so the file will be generated identically even\n     // with rustdoc running in parallel.\n     all_indexes.sort();\n-    write_crate(\"search-index.js\", &|| {\n+    write_invocation_specific(\"search-index.js\", &|| {\n         let mut v = String::from(\"var searchIndex = JSON.parse('{\\\\\\n\");\n         v.push_str(&all_indexes.join(\",\\\\\\n\"));\n         v.push_str(\n@@ -490,7 +298,7 @@ if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};\n         Ok(v.into_bytes())\n     })?;\n \n-    write_crate(\"crates.js\", &|| {\n+    write_invocation_specific(\"crates.js\", &|| {\n         let krates = krates.iter().map(|k| format!(\"\\\"{}\\\"\", k)).join(\",\");\n         Ok(format!(\"window.ALL_CRATES = [{}];\", krates).into_bytes())\n     })?;"}, {"sha": "f58d2c609426d87a27f94947c7bc18ddc2e2e3ce", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -4,15 +4,15 @@\n \tfont-style: normal;\n \tfont-weight: 400;\n \tsrc: local('Fira Sans'),\n-\t\turl(\"FiraSans-Regular.woff2\") format(\"woff2\");\n+\t\turl(\"FiraSans-Regular-018c141bf0843ffd.woff2\") format(\"woff2\");\n \tfont-display: swap;\n }\n @font-face {\n \tfont-family: 'Fira Sans';\n \tfont-style: normal;\n \tfont-weight: 500;\n \tsrc: local('Fira Sans Medium'),\n-\t\turl(\"FiraSans-Medium.woff2\") format(\"woff2\");\n+\t\turl(\"FiraSans-Medium-8f9a781e4970d388.woff2\") format(\"woff2\");\n \tfont-display: swap;\n }\n \n@@ -22,23 +22,23 @@\n \tfont-style: normal;\n \tfont-weight: 400;\n \tsrc: local('Source Serif 4'),\n-\t\turl(\"SourceSerif4-Regular.ttf.woff2\") format(\"woff2\");\n+\t\turl(\"SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2\") format(\"woff2\");\n \tfont-display: swap;\n }\n @font-face {\n \tfont-family: 'Source Serif 4';\n \tfont-style: italic;\n \tfont-weight: 400;\n \tsrc: local('Source Serif 4 Italic'),\n-\t\turl(\"SourceSerif4-It.ttf.woff2\") format(\"woff2\");\n+\t\turl(\"SourceSerif4-It-d034fe4ef9d0fa00.ttf.woff2\") format(\"woff2\");\n \tfont-display: swap;\n }\n @font-face {\n \tfont-family: 'Source Serif 4';\n \tfont-style: normal;\n \tfont-weight: 700;\n \tsrc: local('Source Serif 4 Bold'),\n-\t\turl(\"SourceSerif4-Bold.ttf.woff2\") format(\"woff2\");\n+\t\turl(\"SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2\") format(\"woff2\");\n \tfont-display: swap;\n }\n \n@@ -49,28 +49,28 @@\n \tfont-weight: 400;\n \t/* Avoid using locally installed font because bad versions are in circulation:\n \t * see https://github.com/rust-lang/rust/issues/24355 */\n-\tsrc: url(\"SourceCodePro-Regular.ttf.woff2\") format(\"woff2\");\n+\tsrc: url(\"SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2\") format(\"woff2\");\n \tfont-display: swap;\n }\n @font-face {\n \tfont-family: 'Source Code Pro';\n \tfont-style: italic;\n \tfont-weight: 400;\n-\tsrc: url(\"SourceCodePro-It.ttf.woff2\") format(\"woff2\");\n+\tsrc: url(\"SourceCodePro-It-1cc31594bf4f1f79.ttf.woff2\") format(\"woff2\");\n \tfont-display: swap;\n }\n @font-face {\n \tfont-family: 'Source Code Pro';\n \tfont-style: normal;\n \tfont-weight: 600;\n-\tsrc: url(\"SourceCodePro-Semibold.ttf.woff2\") format(\"woff2\");\n+\tsrc: url(\"SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2\") format(\"woff2\");\n \tfont-display: swap;\n }\n \n /* Avoid using legacy CJK serif fonts in Windows like Batang. */\n @font-face {\n \tfont-family: 'NanumBarunGothic';\n-\tsrc: url(\"NanumBarunGothic.ttf.woff2\") format(\"woff2\");\n+\tsrc: url(\"NanumBarunGothic-0f09457c7a19b7c6.ttf.woff2\") format(\"woff2\");\n \tfont-display: swap;\n \tunicode-range: U+AC00-D7AF, U+1100-11FF, U+3130-318F, U+A960-A97F, U+D7B0-D7FF;\n }\n@@ -367,7 +367,8 @@ img {\n \toverflow: visible;\n }\n \n-.sub-logo-container {\n+.sub-logo-container, .logo-container {\n+\t/* zero text boxes so that computed line height = image height exactly */\n \tline-height: 0;\n }\n \n@@ -377,6 +378,10 @@ img {\n \tobject-fit: contain;\n }\n \n+.rust-logo {\n+\tfilter: var(--rust-logo-filter);\n+}\n+\n .sidebar, .mobile-topbar, .sidebar-menu-toggle {\n \tbackground-color: var(--sidebar-background-color);\n }\n@@ -465,10 +470,9 @@ img {\n }\n \n .sidebar .logo-container {\n-\tdisplay: flex;\n \tmargin-top: 10px;\n \tmargin-bottom: 10px;\n-\tjustify-content: center;\n+\ttext-align: center;\n }\n \n .version {\n@@ -850,7 +854,7 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \tbackground-size: 20px;\n \tbackground-position: calc(100% - 2px) 56%;\n \t/* image is black color, themes should apply a \"filter\" property to change the color */\n-\tbackground-image: /* AUTOREPLACE: */url(\"down-arrow.svg\");\n+\tbackground-image: url(\"down-arrow-927217e04c7463ac.svg\");\n }\n #crate-search > option {\n \tfont-size: 1rem;\n@@ -886,7 +890,7 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \t/* A little margin ensures the browser's outlining of focused links has room to display. */\n \tmargin-left: 2px;\n \tmargin-right: 2px;\n-\tborder-bottom: 1px solid var(--border-color);\n+\tborder-bottom: 1px solid var(--search-result-border-color);\n \tgap: 1em;\n }\n \n@@ -1204,6 +1208,12 @@ a.test-arrow {\n \ttop: 5px;\n \tright: 5px;\n \tz-index: 1;\n+\tcolor: var(--test-arrow-color);\n+\tbackground-color: var(--test-arrow-background-color);\n+}\n+a.test-arrow:hover {\n+\tcolor: var(--test-arrow-hover-color);\n+\tbackground-color: var(--test-arrow-hover-background-color);\n }\n .example-wrap:hover .test-arrow {\n \tvisibility: visible;\n@@ -1617,11 +1627,11 @@ details.rustdoc-toggle[open] > summary.hideme > span {\n \n details.rustdoc-toggle[open] > summary::before,\n details.rustdoc-toggle[open] > summary.hideme::before {\n-\tbackground-image: /* AUTOREPLACE: */url(\"toggle-minus.svg\");\n+\tbackground-image: url(\"toggle-minus-31bbd6e4c77f5c96.svg\");\n }\n \n details.rustdoc-toggle > summary::before {\n-\tbackground-image: /* AUTOREPLACE: */url(\"toggle-plus.svg\");\n+\tbackground-image: url(\"toggle-plus-1092eb4930d581b0.svg\");\n }\n \n details.rustdoc-toggle[open] > summary::before,\n@@ -1755,10 +1765,6 @@ in storage.js\n \t\twhite-space: nowrap;\n \t}\n \n-\t.mobile-topbar .logo-container {\n-\t\tmax-height: 45px;\n-\t}\n-\n \t.mobile-topbar .logo-container > img {\n \t\tmax-width: 35px;\n \t\tmax-height: 35px;\n@@ -1802,21 +1808,6 @@ in storage.js\n \t\tdisplay: block;\n \t}\n \n-\t/* Because of ios, we need to actually have a full height sidebar title so the\n-\t * actual sidebar can show up. But then we need to make it transparent so we don't\n-\t * hide content. The filler just allows to create the background for the sidebar\n-\t * title. But because of the absolute position, I had to lower the z-index.\n-\t */\n-\t#sidebar-filler {\n-\t\tposition: fixed;\n-\t\tleft: 45px;\n-\t\twidth: calc(100% - 45px);\n-\t\ttop: 0;\n-\t\theight: 45px;\n-\t\tz-index: -1;\n-\t\tborder-bottom: 1px solid;\n-\t}\n-\n \t#main-content > details.rustdoc-toggle > summary::before,\n \t#main-content > div > details.rustdoc-toggle > summary::before {\n \t\tleft: -11px;"}, {"sha": "bf8a60affaa227f980ca8eece943da8ba76005fa", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -38,6 +38,7 @@ Original by Dempfi (https://github.com/dempfi/ayu)\n \t--sidebar-link-color: #53b1db;\n \t--sidebar-current-link-background-color: transparent;\n \t--search-result-link-focus-background-color: #3c3c3c;\n+\t--search-result-border-color: #aaa3;\n \t--stab-background-color: #314559;\n \t--stab-code-color: #e6e1cf;\n \t--search-color: #fff;\n@@ -58,6 +59,14 @@ Original by Dempfi (https://github.com/dempfi/ayu)\n \t--example-line-numbers-border-color: none;\n \t--src-line-numbers-span-color: #5c6773;\n \t--src-line-number-highlighted-background-color: rgba(255, 236, 164, 0.06);\n+\t--test-arrow-color: #788797;\n+\t--test-arrow-background-color: rgba(57, 175, 215, 0.09);\n+\t--test-arrow-hover-color: #c5c5c5;\n+\t--test-arrow-hover-background-color: rgba(57, 175, 215, 0.368);\n+\t--rust-logo-filter: drop-shadow(1px 0 0px #fff)\n+\t\tdrop-shadow(0 1px 0 #fff)\n+\t\tdrop-shadow(-1px 0 0 #fff)\n+\t\tdrop-shadow(0 -1px 0 #fff);\n }\n \n .slider {\n@@ -99,13 +108,6 @@ pre, .rustdoc.source .example-wrap {\n \tcolor: #e6e1cf;\n }\n \n-.rust-logo {\n-\tfilter: drop-shadow(1px 0 0px #fff)\n-\t\tdrop-shadow(0 1px 0 #fff)\n-\t\tdrop-shadow(-1px 0 0 #fff)\n-\t\tdrop-shadow(0 -1px 0 #fff);\n-}\n-\n .sidebar .current,\n .sidebar a:hover {\n \tcolor: #ffb44c;\n@@ -171,18 +173,6 @@ details.rustdoc-toggle > summary::before {\n \tcolor: #788797;\n }\n \n-a.test-arrow {\n-\tfont-size: 100%;\n-\tcolor: #788797;\n-\tborder-radius: 4px;\n-\tbackground-color: rgba(57, 175, 215, 0.09);\n-}\n-\n-a.test-arrow:hover {\n-\tbackground-color: rgba(57, 175, 215, 0.368);\n-\tcolor: #c5c5c5;\n-}\n-\n :target {\n \tbackground: rgba(255, 236, 164, 0.06);\n \tborder-right: 3px solid rgba(255, 180, 76, 0.85);"}, {"sha": "ac6e527848f613e4853a64708cd4a10e86c09101", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -33,6 +33,7 @@\n \t--sidebar-link-color: #fdbf35;\n \t--sidebar-current-link-background-color: #444;\n \t--search-result-link-focus-background-color: #616161;\n+\t--search-result-border-color: #aaa3;\n \t--stab-background-color: #314559;\n \t--stab-code-color: #e6e1cf;\n \t--search-color: #111;\n@@ -53,6 +54,14 @@\n \t--example-line-numbers-border-color: #4a4949;\n \t--src-line-numbers-span-color: #3b91e2;\n \t--src-line-number-highlighted-background-color: #0a042f;\n+\t--test-arrow-color: #dedede;\n+\t--test-arrow-background-color: rgba(78, 139, 202, 0.2);\n+\t--test-arrow-hover-color: #dedede;\n+\t--test-arrow-hover-background-color: #4e8bca;\n+\t--rust-logo-filter: drop-shadow(1px 0 0px #fff)\n+\t\tdrop-shadow(0 1px 0 #fff)\n+\t\tdrop-shadow(-1px 0 0 #fff)\n+\t\tdrop-shadow(0 -1px 0 #fff);\n }\n \n .slider {\n@@ -65,13 +74,6 @@ input:focus + .slider {\n \tbox-shadow: 0 0 0 2px #0a84ff, 0 0 0 6px rgba(10, 132, 255, 0.3);\n }\n \n-.rust-logo {\n-\tfilter: drop-shadow(1px 0 0px #fff)\n-\t\tdrop-shadow(0 1px 0 #fff)\n-\t\tdrop-shadow(-1px 0 0 #fff)\n-\t\tdrop-shadow(0 -1px 0 #fff)\n-}\n-\n .content .item-info::before { color: #ccc; }\n \n body.source .example-wrap pre.rust a {\n@@ -93,15 +95,6 @@ details.rustdoc-toggle > summary::before {\n \tfilter: invert(69%) sepia(60%) saturate(6613%) hue-rotate(184deg) brightness(100%) contrast(91%);\n }\n \n-a.test-arrow {\n-\tcolor: #dedede;\n-\tbackground-color: rgba(78, 139, 202, 0.2);\n-}\n-\n-a.test-arrow:hover{\n-\tbackground-color: #4e8bca;\n-}\n-\n :target {\n \tbackground-color: #494a3d;\n \tborder-right: 3px solid #bb7410;"}, {"sha": "608fc5aba7fd3f6e2bd2ee4c70cd565dca569e10", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -33,6 +33,7 @@\n \t--sidebar-link-color: #356da4;\n \t--sidebar-current-link-background-color: #fff;\n \t--search-result-link-focus-background-color: #ccc;\n+\t--search-result-border-color: #aaa3;\n \t--stab-background-color: #fff5d6;\n \t--stab-code-color: #000;\n \t--search-color: #000;\n@@ -53,6 +54,11 @@\n \t--example-line-numbers-border-color: #c7c7c7;\n \t--src-line-numbers-span-color: #c67e2d;\n \t--src-line-number-highlighted-background-color: #fdffd3;\n+\t--test-arrow-color: #f5f5f5;\n+\t--test-arrow-background-color: rgba(78, 139, 202, 0.2);\n+\t--test-arrow-hover-color: #f5f5f5;\n+\t--test-arrow-hover-background-color: #4e8bca;\n+\t--rust-logo-filter: initial;\n }\n \n .slider {\n@@ -65,12 +71,6 @@ input:focus + .slider {\n \tbox-shadow: 0 0 0 2px #0a84ff, 0 0 0 6px rgba(10, 132, 255, 0.3);\n }\n \n-.rust-logo {\n-\t/* This rule exists to force other themes to explicitly style the logo.\n-\t * Rustdoc has a custom linter for this purpose.\n-\t */\n-}\n-\n .content .item-info::before { color: #ccc; }\n \n body.source .example-wrap pre.rust a {\n@@ -88,15 +88,6 @@ body.source .example-wrap pre.rust a {\n \tfilter: invert(44%) sepia(18%) saturate(23%) hue-rotate(317deg) brightness(96%) contrast(93%);\n }\n \n-a.test-arrow {\n-\tcolor: #f5f5f5;\n-\tbackground-color: rgba(78, 139, 202, 0.2);\n-}\n-\n-a.test-arrow:hover{\n-\tbackground-color: #4e8bca;\n-}\n-\n :target {\n \tbackground: #FDFFD3;\n \tborder-right: 3px solid #AD7C37;"}, {"sha": "0db15996d2ec129c8a5b1b88b6453f6804240892", "filename": "src/librustdoc/html/static/fonts/README.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FREADME.txt?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -0,0 +1,12 @@\n+The Nanum Barun Gothic fonts are shipped with rustdoc because the default fonts\n+on many Windows installs render Korean very badly. See:\n+ - https://github.com/rust-lang/rust/pull/84048,\n+ - https://github.com/rust-lang/rust/issues/84035\n+ - https://github.com/rust-lang/rust/pull/90232\n+\n+The font files were generated with these commands:\n+\n+```sh\n+pyftsubset NanumBarunGothic.ttf \\\n+--unicodes=U+AC00-D7AF:U+1100-11FF,U+3130-318F,U+A960-A97F,U+D7B0-D7FF \\\n+--output-file=NanumBarunGothic.ttf.woff2 --flavor=woff2"}, {"sha": "1c84393cb4e6f890661f398220cd35bcf2a7fe38", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -183,9 +183,9 @@ function browserSupportsHistoryApi() {\n }\n \n // eslint-disable-next-line no-unused-vars\n-function loadCss(cssFileName) {\n+function loadCss(cssUrl) {\n     const link = document.createElement(\"link\");\n-    link.href = resourcePath(cssFileName, \".css\");\n+    link.href = cssUrl;\n     link.type = \"text/css\";\n     link.rel = \"stylesheet\";\n     document.getElementsByTagName(\"head\")[0].appendChild(link);\n@@ -208,8 +208,8 @@ function loadCss(cssFileName) {\n         event.preventDefault();\n         // Sending request for the CSS and the JS files at the same time so it will\n         // hopefully be loaded when the JS will generate the settings content.\n-        loadCss(\"settings\");\n-        loadScript(resourcePath(\"settings\", \".js\"));\n+        loadCss(getVar(\"static-root-path\") + getVar(\"settings-css\"));\n+        loadScript(getVar(\"static-root-path\") + getVar(\"settings-js\"));\n     };\n \n     window.searchState = {\n@@ -286,7 +286,7 @@ function loadCss(cssFileName) {\n             function loadSearch() {\n                 if (!searchLoaded) {\n                     searchLoaded = true;\n-                    loadScript(resourcePath(\"search\", \".js\"));\n+                    loadScript(getVar(\"static-root-path\") + getVar(\"search-js\"));\n                     loadScript(resourcePath(\"search-index\", \".js\"));\n                 }\n             }"}, {"sha": "141563bd46a19796184109af2590d791561f6202", "filename": "src/librustdoc/html/static/js/settings.js", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -154,7 +154,9 @@\n      * @return {HTMLElement}\n      */\n     function buildSettingsPage() {\n-        const themes = getVar(\"themes\").split(\",\");\n+        const theme_names = getVar(\"themes\").split(\",\").filter(t => t);\n+        theme_names.push(\"light\", \"dark\", \"ayu\");\n+\n         const settings = [\n             {\n                 \"name\": \"Use system theme\",\n@@ -165,19 +167,19 @@\n                 \"name\": \"Theme\",\n                 \"js_name\": \"theme\",\n                 \"default\": \"light\",\n-                \"options\": themes,\n+                \"options\": theme_names,\n             },\n             {\n                 \"name\": \"Preferred light theme\",\n                 \"js_name\": \"preferred-light-theme\",\n                 \"default\": \"light\",\n-                \"options\": themes,\n+                \"options\": theme_names,\n             },\n             {\n                 \"name\": \"Preferred dark theme\",\n                 \"js_name\": \"preferred-dark-theme\",\n                 \"default\": \"dark\",\n-                \"options\": themes,\n+                \"options\": theme_names,\n             },\n             {\n                 \"name\": \"Auto-hide item contents for large items\","}, {"sha": "db2db83ca631008030a6f30f447011c8363211fb", "filename": "src/librustdoc/html/static/js/storage.js", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -126,33 +126,29 @@ function getCurrentValue(name) {\n     }\n }\n \n-function switchTheme(styleElem, mainStyleElem, newTheme, saveTheme) {\n-    const newHref = mainStyleElem.href.replace(\n-        /\\/rustdoc([^/]*)\\.css/, \"/\" + newTheme + \"$1\" + \".css\");\n-\n+function switchTheme(styleElem, mainStyleElem, newThemeName, saveTheme) {\n     // If this new value comes from a system setting or from the previously\n     // saved theme, no need to save it.\n     if (saveTheme) {\n-        updateLocalStorage(\"theme\", newTheme);\n-    }\n-\n-    if (styleElem.href === newHref) {\n-        return;\n+        updateLocalStorage(\"theme\", newThemeName);\n     }\n \n-    let found = false;\n     if (savedHref.length === 0) {\n         onEachLazy(document.getElementsByTagName(\"link\"), el => {\n             savedHref.push(el.href);\n         });\n     }\n-    onEach(savedHref, el => {\n-        if (el === newHref) {\n-            found = true;\n+    const newHref = savedHref.find(url => {\n+        const m = url.match(/static\\.files\\/(.*)-[a-f0-9]{16}\\.css$/);\n+        if (m && m[1] === newThemeName) {\n+            return true;\n+        }\n+        const m2 = url.match(/\\/([^/]*)\\.css$/);\n+        if (m2 && m2[1].startsWith(newThemeName)) {\n             return true;\n         }\n     });\n-    if (found) {\n+    if (newHref && newHref !== styleElem.href) {\n         styleElem.href = newHref;\n     }\n }"}, {"sha": "afe920b7fa1e0a4d57519b7a3e049435e4302c9e", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 110, "deletions": 149, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -2,167 +2,128 @@\n //!\n //! All the static files are included here for centralized access in case anything other than the\n //! HTML rendering code (say, the theme checker) needs to access one of these files.\n-//!\n-//! Note about types: CSS and JavaScript files are included as `&'static str` to allow for the\n-//! minifier to run on them. All other files are included as `&'static [u8]` so they can be\n-//! directly written to a `Write` handle.\n-\n-/// The file contents of the main `rustdoc.css` file, responsible for the core layout of the page.\n-pub(crate) static RUSTDOC_CSS: &str = include_str!(\"static/css/rustdoc.css\");\n-\n-/// The file contents of `settings.css`, responsible for the items on the settings page.\n-pub(crate) static SETTINGS_CSS: &str = include_str!(\"static/css/settings.css\");\n-\n-/// The file contents of the `noscript.css` file, used in case JS isn't supported or is disabled.\n-pub(crate) static NOSCRIPT_CSS: &str = include_str!(\"static/css/noscript.css\");\n-\n-/// The file contents of `normalize.css`, included to even out standard elements between browser\n-/// implementations.\n-pub(crate) static NORMALIZE_CSS: &str = include_str!(\"static/css/normalize.css\");\n-\n-/// The file contents of `main.js`, which contains the core JavaScript used on documentation pages,\n-/// including search behavior and docblock folding, among others.\n-pub(crate) static MAIN_JS: &str = include_str!(\"static/js/main.js\");\n-\n-/// The file contents of `search.js`, which contains the search behavior.\n-pub(crate) static SEARCH_JS: &str = include_str!(\"static/js/search.js\");\n-\n-/// The file contents of `settings.js`, which contains the JavaScript used to handle the settings\n-/// page.\n-pub(crate) static SETTINGS_JS: &str = include_str!(\"static/js/settings.js\");\n-\n-/// The file contents of `storage.js`, which contains functionality related to browser Local\n-/// Storage, used to store documentation settings.\n-pub(crate) static STORAGE_JS: &str = include_str!(\"static/js/storage.js\");\n-\n-/// The file contents of `scraped-examples.js`, which contains functionality related to the\n-/// --scrape-examples flag that inserts automatically-found examples of usages of items.\n-pub(crate) static SCRAPE_EXAMPLES_JS: &str = include_str!(\"static/js/scrape-examples.js\");\n-\n-pub(crate) static SCRAPE_EXAMPLES_HELP_MD: &str = include_str!(\"static/scrape-examples-help.md\");\n-\n-/// The file contents of `wheel.svg`, the icon used for the settings button.\n-pub(crate) static WHEEL_SVG: &[u8] = include_bytes!(\"static/images/wheel.svg\");\n-\n-/// The file contents of `clipboard.svg`, the icon used for the \"copy path\" button.\n-pub(crate) static CLIPBOARD_SVG: &[u8] = include_bytes!(\"static/images/clipboard.svg\");\n-\n-/// The file contents of `down-arrow.svg`, the icon used for the crate choice combobox.\n-pub(crate) static DOWN_ARROW_SVG: &[u8] = include_bytes!(\"static/images/down-arrow.svg\");\n-\n-/// The file contents of `toggle-minus.svg`, the icon used for opened toggles.\n-pub(crate) static TOGGLE_MINUS_PNG: &[u8] = include_bytes!(\"static/images/toggle-minus.svg\");\n-\n-/// The file contents of `toggle-plus.svg`, the icon used for closed toggles.\n-pub(crate) static TOGGLE_PLUS_PNG: &[u8] = include_bytes!(\"static/images/toggle-plus.svg\");\n \n-/// The contents of `COPYRIGHT.txt`, the license listing for files distributed with documentation\n-/// output.\n-pub(crate) static COPYRIGHT: &[u8] = include_bytes!(\"static/COPYRIGHT.txt\");\n+use rustc_data_structures::fx::FxHasher;\n+use std::hash::Hasher;\n+use std::path::{Path, PathBuf};\n+use std::{fmt, str};\n \n-/// The contents of `LICENSE-APACHE.txt`, the text of the Apache License, version 2.0.\n-pub(crate) static LICENSE_APACHE: &[u8] = include_bytes!(\"static/LICENSE-APACHE.txt\");\n-\n-/// The contents of `LICENSE-MIT.txt`, the text of the MIT License.\n-pub(crate) static LICENSE_MIT: &[u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n-\n-/// The contents of `rust-logo.svg`, the default icon of the documentation.\n-pub(crate) static RUST_LOGO_SVG: &[u8] = include_bytes!(\"static/images/rust-logo.svg\");\n-\n-/// The default documentation favicons (SVG and PNG fallbacks)\n-pub(crate) static RUST_FAVICON_SVG: &[u8] = include_bytes!(\"static/images/favicon.svg\");\n-pub(crate) static RUST_FAVICON_PNG_16: &[u8] = include_bytes!(\"static/images/favicon-16x16.png\");\n-pub(crate) static RUST_FAVICON_PNG_32: &[u8] = include_bytes!(\"static/images/favicon-32x32.png\");\n-\n-/// The built-in themes given to every documentation site.\n-pub(crate) mod themes {\n-    /// The \"light\" theme, selected by default when no setting is available. Used as the basis for\n-    /// the `--check-theme` functionality.\n-    pub(crate) static LIGHT: &str = include_str!(\"static/css/themes/light.css\");\n-\n-    /// The \"dark\" theme.\n-    pub(crate) static DARK: &str = include_str!(\"static/css/themes/dark.css\");\n-\n-    /// The \"ayu\" theme.\n-    pub(crate) static AYU: &str = include_str!(\"static/css/themes/ayu.css\");\n+pub(crate) struct StaticFile {\n+    pub(crate) filename: PathBuf,\n+    pub(crate) bytes: &'static [u8],\n }\n \n-/// Files related to the Fira Sans font.\n-pub(crate) mod fira_sans {\n-    /// The file `FiraSans-Regular.woff2`, the Regular variant of the Fira Sans font in woff2.\n-    pub(crate) static REGULAR: &[u8] = include_bytes!(\"static/fonts/FiraSans-Regular.woff2\");\n-\n-    /// The file `FiraSans-Medium.woff2`, the Medium variant of the Fira Sans font in woff2.\n-    pub(crate) static MEDIUM: &[u8] = include_bytes!(\"static/fonts/FiraSans-Medium.woff2\");\n-\n-    /// The file `FiraSans-LICENSE.txt`, the license text for the Fira Sans font.\n-    pub(crate) static LICENSE: &[u8] = include_bytes!(\"static/fonts/FiraSans-LICENSE.txt\");\n+impl StaticFile {\n+    fn new(filename: &str, bytes: &'static [u8]) -> StaticFile {\n+        Self { filename: static_filename(filename, bytes), bytes }\n+    }\n+\n+    pub(crate) fn minified(&self) -> Vec<u8> {\n+        if self.filename.ends_with(\".css\") {\n+            minifier::css::minify(str::from_utf8(self.bytes).unwrap()).unwrap().to_string().into()\n+        } else if self.filename.ends_with(\".js\") {\n+            minifier::js::minify(str::from_utf8(self.bytes).unwrap()).to_string().into()\n+        } else {\n+            self.bytes.to_owned()\n+        }\n+    }\n+\n+    pub(crate) fn output_filename(&self) -> &Path {\n+        &self.filename\n+    }\n }\n \n-/// Files related to the Source Serif 4 font.\n-pub(crate) mod source_serif_4 {\n-    /// The file `SourceSerif4-Regular.ttf.woff2`, the Regular variant of the Source Serif 4 font in\n-    /// woff2.\n-    pub(crate) static REGULAR: &[u8] =\n-        include_bytes!(\"static/fonts/SourceSerif4-Regular.ttf.woff2\");\n-\n-    /// The file `SourceSerif4-Bold.ttf.woff2`, the Bold variant of the Source Serif 4 font in\n-    /// woff2.\n-    pub(crate) static BOLD: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-Bold.ttf.woff2\");\n-\n-    /// The file `SourceSerif4-It.ttf.woff2`, the Italic variant of the Source Serif 4 font in\n-    /// woff2.\n-    pub(crate) static ITALIC: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-It.ttf.woff2\");\n-\n-    /// The file `SourceSerif4-LICENSE.txt`, the license text for the Source Serif 4 font.\n-    pub(crate) static LICENSE: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-LICENSE.md\");\n+/// The Display implementation for a StaticFile outputs its filename. This makes it\n+/// convenient to interpolate static files into HTML templates.\n+impl fmt::Display for StaticFile {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", self.output_filename().display())\n+    }\n }\n \n-/// Files related to the Source Code Pro font.\n-pub(crate) mod source_code_pro {\n-    /// The file `SourceCodePro-Regular.ttf.woff2`, the Regular variant of the Source Code Pro font\n-    /// in woff2.\n-    pub(crate) static REGULAR: &[u8] =\n-        include_bytes!(\"static/fonts/SourceCodePro-Regular.ttf.woff2\");\n-\n-    /// The file `SourceCodePro-Semibold.ttf.woff2`, the Semibold variant of the Source Code Pro\n-    /// font in woff2.\n-    pub(crate) static SEMIBOLD: &[u8] =\n-        include_bytes!(\"static/fonts/SourceCodePro-Semibold.ttf.woff2\");\n-\n-    /// The file `SourceCodePro-It.ttf.woff2`, the Italic variant of the Source Code Pro font in\n-    /// woff2.\n-    pub(crate) static ITALIC: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-It.ttf.woff2\");\n+/// Insert the provided suffix into a filename just before the extension.\n+pub(crate) fn suffix_path(filename: &str, suffix: &str) -> PathBuf {\n+    // We use splitn vs Path::extension here because we might get a filename\n+    // like `style.min.css` and we want to process that into\n+    // `style-suffix.min.css`.  Path::extension would just return `css`\n+    // which would result in `style.min-suffix.css` which isn't what we\n+    // want.\n+    let (base, ext) = filename.split_once('.').unwrap();\n+    let filename = format!(\"{}{}.{}\", base, suffix, ext);\n+    filename.into()\n+}\n \n-    /// The file `SourceCodePro-LICENSE.txt`, the license text of the Source Code Pro font.\n-    pub(crate) static LICENSE: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-LICENSE.txt\");\n+pub(crate) fn static_filename(filename: &str, contents: &[u8]) -> PathBuf {\n+    let filename = filename.rsplit(\"/\").next().unwrap();\n+    suffix_path(filename, &static_suffix(contents))\n }\n \n-/// Files related to the Nanum Barun Gothic font.\n-///\n-/// These files are used to avoid some legacy CJK serif fonts in Windows.\n-///\n-/// Note that the Noto Sans KR font, which was used previously but was not very readable on Windows,\n-/// has been replaced by the Nanum Barun Gothic font. This is due to Windows' implementation of font\n-/// rendering that distorts OpenType fonts too much.\n-///\n-/// The font files were generated with these commands:\n-///\n-/// ```sh\n-/// pyftsubset NanumBarunGothic.ttf \\\n-/// --unicodes=U+AC00-D7AF,U+1100-11FF,U+3130-318F,U+A960-A97F,U+D7B0-D7FF \\\n-/// --output-file=NanumBarunGothic.ttf.woff2 --flavor=woff2\n-/// ```\n-pub(crate) mod nanum_barun_gothic {\n-    /// The file `NanumBarunGothic.ttf.woff2`, the Regular variant of the Nanum Barun Gothic font.\n-    pub(crate) static REGULAR: &[u8] = include_bytes!(\"static/fonts/NanumBarunGothic.ttf.woff2\");\n+fn static_suffix(bytes: &[u8]) -> String {\n+    let mut hasher = FxHasher::default();\n+    hasher.write(bytes);\n+    format!(\"-{:016x}\", hasher.finish())\n+}\n \n-    /// The file `NanumBarunGothic-LICENSE.txt`, the license text of the Nanum Barun Gothic font.\n-    pub(crate) static LICENSE: &[u8] = include_bytes!(\"static/fonts/NanumBarunGothic-LICENSE.txt\");\n+macro_rules! static_files {\n+    ($($field:ident => $file_path:literal,)+) => {\n+        pub(crate) struct StaticFiles {\n+            $(pub $field: StaticFile,)+\n+        }\n+\n+        pub(crate) static STATIC_FILES: std::sync::LazyLock<StaticFiles> = std::sync::LazyLock::new(|| StaticFiles {\n+            $($field: StaticFile::new($file_path, include_bytes!($file_path)),)+\n+        });\n+\n+        pub(crate) fn for_each<E>(f: impl Fn(&StaticFile) -> Result<(), E>) -> Result<(), E> {\n+            for sf in [\n+            $(&STATIC_FILES.$field,)+\n+            ] {\n+                f(sf)?\n+            }\n+            Ok(())\n+        }\n+    }\n }\n \n-/// Files related to the sidebar in rustdoc sources.\n-pub(crate) mod sidebar {\n-    /// File script to handle sidebar.\n-    pub(crate) static SOURCE_SCRIPT: &str = include_str!(\"static/js/source-script.js\");\n+static_files! {\n+    rustdoc_css => \"static/css/rustdoc.css\",\n+    settings_css => \"static/css/settings.css\",\n+    noscript_css => \"static/css/noscript.css\",\n+    normalize_css => \"static/css/normalize.css\",\n+    main_js => \"static/js/main.js\",\n+    search_js => \"static/js/search.js\",\n+    settings_js => \"static/js/settings.js\",\n+    source_script_js => \"static/js/source-script.js\",\n+    storage_js => \"static/js/storage.js\",\n+    scrape_examples_js => \"static/js/scrape-examples.js\",\n+    wheel_svg => \"static/images/wheel.svg\",\n+    clipboard_svg => \"static/images/clipboard.svg\",\n+    down_arrow_svg => \"static/images/down-arrow.svg\",\n+    toggle_minus_png => \"static/images/toggle-minus.svg\",\n+    toggle_plus_png => \"static/images/toggle-plus.svg\",\n+    copyright => \"static/COPYRIGHT.txt\",\n+    license_apache => \"static/LICENSE-APACHE.txt\",\n+    license_mit => \"static/LICENSE-MIT.txt\",\n+    rust_logo_svg => \"static/images/rust-logo.svg\",\n+    rust_favicon_svg => \"static/images/favicon.svg\",\n+    rust_favicon_png_16 => \"static/images/favicon-16x16.png\",\n+    rust_favicon_png_32 => \"static/images/favicon-32x32.png\",\n+    theme_light_css => \"static/css/themes/light.css\",\n+    theme_dark_css => \"static/css/themes/dark.css\",\n+    theme_ayu_css => \"static/css/themes/ayu.css\",\n+    fira_sans_regular => \"static/fonts/FiraSans-Regular.woff2\",\n+    fira_sans_medium => \"static/fonts/FiraSans-Medium.woff2\",\n+    fira_sans_license => \"static/fonts/FiraSans-LICENSE.txt\",\n+    source_serif_4_regular => \"static/fonts/SourceSerif4-Regular.ttf.woff2\",\n+    source_serif_4_bold => \"static/fonts/SourceSerif4-Bold.ttf.woff2\",\n+    source_serif_4_italic => \"static/fonts/SourceSerif4-It.ttf.woff2\",\n+    source_serif_4_license => \"static/fonts/SourceSerif4-LICENSE.md\",\n+    source_code_pro_regular => \"static/fonts/SourceCodePro-Regular.ttf.woff2\",\n+    source_code_pro_semibold => \"static/fonts/SourceCodePro-Semibold.ttf.woff2\",\n+    source_code_pro_italic => \"static/fonts/SourceCodePro-It.ttf.woff2\",\n+    source_code_pro_license => \"static/fonts/SourceCodePro-LICENSE.txt\",\n+    nanum_barun_gothic_regular => \"static/fonts/NanumBarunGothic.ttf.woff2\",\n+    nanum_barun_gothic_license => \"static/fonts/NanumBarunGothic-LICENSE.txt\",\n }\n+\n+pub(crate) static SCRAPE_EXAMPLES_HELP_MD: &str = include_str!(\"static/js/scrape-examples.js\");"}, {"sha": "4efcfc510a255c67420218592c9ee0832e48c6f0", "filename": "src/librustdoc/html/templates/page.html", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -7,48 +7,44 @@\n     <meta name=\"description\" content=\"{{page.description}}\"> {#- -#}\n     <meta name=\"keywords\" content=\"{{page.keywords}}\"> {#- -#}\n     <title>{{page.title}}</title> {#- -#}\n-    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}SourceSerif4-Regular.ttf.woff2\"> {#- -#}\n-    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}FiraSans-Regular.woff2\"> {#- -#}\n-    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}FiraSans-Medium.woff2\"> {#- -#}\n-    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}SourceCodePro-Regular.ttf.woff2\"> {#- -#}\n-    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}SourceSerif4-Bold.ttf.woff2\"> {#- -#}\n-    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}SourceCodePro-Semibold.ttf.woff2\"> {#- -#}\n+    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.source_serif_4_regular}}\"> {#- -#}\n+    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.fira_sans_regular}}\"> {#- -#}\n+    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.fira_sans_medium}}\"> {#- -#}\n+    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.source_code_pro_regular}}\"> {#- -#}\n+    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.source_serif_4_bold}}\"> {#- -#}\n+    <link rel=\"preload\" as=\"font\" type=\"font/woff2\" crossorigin href=\"{{static_root_path|safe}}{{files.source_code_pro_semibold}}\"> {#- -#}\n     <link rel=\"stylesheet\" {# -#}\n-          href=\"{{static_root_path|safe}}normalize{{page.resource_suffix}}.css\"> {#- -#}\n+          href=\"{{static_root_path|safe}}{{files.normalize_css}}\"> {#- -#}\n     <link rel=\"stylesheet\" {# -#}\n-          href=\"{{static_root_path|safe}}rustdoc{{page.resource_suffix}}.css\" {# -#}\n+          href=\"{{static_root_path|safe}}{{files.rustdoc_css}}\" {# -#}\n           id=\"mainThemeStyle\"> {#- -#}\n+    <link rel=\"stylesheet\" id=\"themeStyle\" href=\"{{static_root_path|safe}}{{files.theme_light_css}}\"> {#- -#}\n+    <link rel=\"stylesheet\" disabled href=\"{{static_root_path|safe}}{{files.theme_dark_css}}\"> {#- -#}\n+    <link rel=\"stylesheet\" disabled href=\"{{static_root_path|safe}}{{files.theme_ayu_css}}\"> {#- -#}\n     {%- for theme in themes -%}\n-        <link rel=\"stylesheet\" {# -#}\n-            href=\"{{static_root_path|safe}}{{theme}}{{page.resource_suffix}}.css\" {# -#}\n-        {%- if theme == \"light\" -%}\n-            id=\"themeStyle\"\n-        {%- else -%}\n-            disabled\n-        {%- endif -%}\n-        >\n+        <link rel=\"stylesheet\" disabled href=\"{{page.root_path|safe}}{{theme}}{{page.resource_suffix}}.css\"> {#- -#}\n     {%- endfor -%}\n     <script id=\"default-settings\" {# -#}\n       {% for (k, v) in layout.default_settings %}\n         data-{{k}}=\"{{v}}\"\n       {%- endfor -%}\n     ></script> {#- -#}\n-    <script src=\"{{static_root_path|safe}}storage{{page.resource_suffix}}.js\"></script> {#- -#}\n+    <script src=\"{{static_root_path|safe}}{{files.storage_js}}\"></script> {#- -#}\n     {%- if page.css_class.contains(\"crate\") -%}\n     <script defer src=\"{{page.root_path|safe}}crates{{page.resource_suffix}}.js\"></script> {#- -#}\n     {%- else if page.css_class == \"source\" -%}\n-    <script defer src=\"{{static_root_path|safe}}source-script{{page.resource_suffix}}.js\"></script> {#- -#}\n+    <script defer src=\"{{static_root_path|safe}}{{files.source_script_js}}\"></script> {#- -#}\n     <script defer src=\"{{page.root_path|safe}}source-files{{page.resource_suffix}}.js\"></script> {#- -#}\n     {%- else if !page.css_class.contains(\"mod\") -%}\n     <script defer src=\"sidebar-items{{page.resource_suffix}}.js\"></script> {#- -#}\n     {%- endif -%}\n-    <script defer src=\"{{static_root_path|safe}}main{{page.resource_suffix}}.js\"></script> {#- -#}\n+    <script defer src=\"{{static_root_path|safe}}{{files.main_js}}\"></script> {#- -#}\n     {%- if layout.scrape_examples_extension -%}\n-    <script defer src=\"{{page.root_path|safe}}scrape-examples{{page.resource_suffix}}.js\"></script> {#- -#}\n+    <script defer src=\"{{page.root_path|safe}}{{files.scrape_examples_js}}\"></script> {#- -#}\n     {%- endif -%}\n     <noscript> {#- -#}\n         <link rel=\"stylesheet\" {# -#}\n-           href=\"{{static_root_path|safe}}noscript{{page.resource_suffix}}.css\"> {#- -#}\n+           href=\"{{static_root_path|safe}}{{files.noscript_css}}\"> {#- -#}\n     </noscript> {#- -#}\n     {%- if layout.css_file_extension.is_some() -%}\n         <link rel=\"stylesheet\" {# -#}\n@@ -58,11 +54,11 @@\n         <link rel=\"icon\" href=\"{{layout.favicon}}\"> {#- -#}\n     {%- else -%}\n         <link rel=\"alternate icon\" type=\"image/png\" {# -#}\n-            href=\"{{static_root_path|safe}}favicon-16x16{{page.resource_suffix}}.png\"> {#- -#}\n+            href=\"{{static_root_path|safe}}{{files.rust_favicon_png_16}}\"> {#- -#}\n         <link rel=\"alternate icon\" type=\"image/png\" {# -#}\n-            href=\"{{static_root_path|safe}}favicon-32x32{{page.resource_suffix}}.png\"> {#- -#}\n+            href=\"{{static_root_path|safe}}{{files.rust_favicon_png_32}}\"> {#- -#}\n         <link rel=\"icon\" type=\"image/svg+xml\" {# -#}\n-            href=\"{{static_root_path|safe}}favicon{{page.resource_suffix}}.svg\"> {#- -#}\n+            href=\"{{static_root_path|safe}}{{files.rust_favicon_svg}}\"> {#- -#}\n     {%- endif -%}\n     {{- layout.external_html.in_header|safe -}}\n </head> {#- -#}\n@@ -81,7 +77,7 @@\n             {%- if !layout.logo.is_empty() -%}\n                 <img src=\"{{layout.logo}}\" alt=\"logo\"> {#- -#}\n             {%- else -%}\n-                <img class=\"rust-logo\" src=\"{{static_root_path|safe}}rust-logo{{page.resource_suffix}}.svg\" alt=\"logo\"> {#- -#}\n+                <img class=\"rust-logo\" src=\"{{static_root_path|safe}}{{files.rust_logo_svg}}\" alt=\"logo\"> {#- -#}\n             {%- endif -%}\n             </div> {#- -#}\n         </a> {#- -#}\n@@ -95,7 +91,7 @@ <h2></h2> {#- -#}\n                 {%- if !layout.logo.is_empty()  %}\n                     <img src=\"{{layout.logo}}\" alt=\"logo\"> {#- -#}\n                 {%- else -%}\n-                    <img class=\"rust-logo\" src=\"{{static_root_path|safe}}rust-logo{{page.resource_suffix}}.svg\" alt=\"logo\"> {#- -#}\n+                    <img class=\"rust-logo\" src=\"{{static_root_path|safe}}{{files.rust_logo_svg}}\" alt=\"logo\"> {#- -#}\n                 {%- endif -%}\n             </div> {#- -#}\n         </a> {#- -#}\n@@ -110,7 +106,7 @@ <h2></h2> {#- -#}\n                     {%- if !layout.logo.is_empty()  %}\n                         <img src=\"{{layout.logo}}\" alt=\"logo\"> {#- -#}\n                     {%- else -%}\n-                        <img class=\"rust-logo\" src=\"{{static_root_path|safe}}rust-logo{{page.resource_suffix}}.svg\" alt=\"logo\"> {#- -#}\n+                        <img class=\"rust-logo\" src=\"{{static_root_path|safe}}{{files.rust_logo_svg}}\" alt=\"logo\"> {#- -#}\n                     {%- endif -%}\n                 </a> {#- -#}\n                 {%- endif -%}\n@@ -129,7 +125,7 @@ <h2></h2> {#- -#}\n                     <div id=\"settings-menu\" tabindex=\"-1\"> {#- -#}\n                         <a href=\"{{page.root_path|safe}}settings.html\" title=\"settings\"> {#- -#}\n                             <img width=\"22\" height=\"22\" alt=\"Change settings\" {# -#}\n-                             src=\"{{static_root_path|safe}}wheel{{page.resource_suffix}}.svg\"> {#- -#}\n+                            src=\"{{static_root_path|safe}}{{files.wheel_svg}}\"> {#- -#}\n                         </a> {#- -#}\n                     </div> {#- -#}\n                 </form> {#- -#}\n@@ -140,10 +136,14 @@ <h2></h2> {#- -#}\n     {{- layout.external_html.after_content|safe -}}\n     <div id=\"rustdoc-vars\" {# -#}\n          data-root-path=\"{{page.root_path|safe}}\" {# -#}\n+         data-static-root-path=\"{{static_root_path|safe}}\" {# -#}\n          data-current-crate=\"{{layout.krate}}\" {# -#}\n          data-themes=\"{{themes|join(\",\") }}\" {# -#}\n          data-resource-suffix=\"{{page.resource_suffix}}\" {# -#}\n          data-rustdoc-version=\"{{rustdoc_version}}\" {# -#}\n+         data-search-js=\"{{files.search_js}}\" {# -#}\n+         data-settings-js=\"{{files.settings_js}}\" {# -#}\n+         data-settings-css=\"{{files.settings_css}}\" {# -#}\n     > {#- -#}\n     </div> {#- -#}\n </body> {#- -#}"}, {"sha": "611d124d4b91bedc99a68472752817b222517bf9", "filename": "src/librustdoc/html/templates/print_item.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fprint_item.html", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fprint_item.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fprint_item.html?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -7,7 +7,7 @@ <h1 class=\"fqn\"> {#- -#}\n         {%- endfor -%}\n         <a class=\"{{item_type}}\" href=\"#\">{{name}}</a> {#- -#}\n         <button id=\"copy-path\" onclick=\"copy_path(this)\" title=\"Copy item path to clipboard\"> {#- -#}\n-            <img src=\"{{static_root_path|safe}}clipboard{{page.resource_suffix}}.svg\" {# -#}\n+        <img src=\"{{static_root_path|safe}}{{clipboard_svg}}\" {# -#}\n                 width=\"19\" height=\"18\" {# -#}\n                 alt=\"Copy item path\"> {#- -#}\n         </button> {#- -#}"}, {"sha": "091a1ba70cab7d2a3691acb17dde6d8cd1c9220c", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c02fa89007e47b4e99764e6f5bef7a7c3262139a/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=c02fa89007e47b4e99764e6f5bef7a7c3262139a", "patch": "@@ -485,7 +485,7 @@ impl FromWithTcx<clean::Type> for Type {\n             BareFunction(f) => Type::FunctionPointer(Box::new((*f).into_tcx(tcx))),\n             Tuple(t) => Type::Tuple(t.into_tcx(tcx)),\n             Slice(t) => Type::Slice(Box::new((*t).into_tcx(tcx))),\n-            Array(t, s) => Type::Array { type_: Box::new((*t).into_tcx(tcx)), len: s },\n+            Array(t, s) => Type::Array { type_: Box::new((*t).into_tcx(tcx)), len: s.to_string() },\n             ImplTrait(g) => Type::ImplTrait(g.into_tcx(tcx)),\n             Infer => Type::Infer,\n             RawPointer(mutability, type_) => Type::RawPointer {"}]}