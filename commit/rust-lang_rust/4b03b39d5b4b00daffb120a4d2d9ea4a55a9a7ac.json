{"sha": "4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMDNiMzlkNWI0YjAwZGFmZmIxMjBhNGQyZDllYTRhNTVhOWE3YWM=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-22T13:07:06Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-24T14:53:16Z"}, "message": "draw the rest of the owl", "tree": {"sha": "85431e53ce86bbcf16ba9b38fcc5f2ad27378722", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85431e53ce86bbcf16ba9b38fcc5f2ad27378722"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "html_url": "https://github.com/rust-lang/rust/commit/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b94caeb88b4aab7219d4b2f5c8c6c668199247fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b94caeb88b4aab7219d4b2f5c8c6c668199247fb", "html_url": "https://github.com/rust-lang/rust/commit/b94caeb88b4aab7219d4b2f5c8c6c668199247fb"}], "stats": {"total": 1362, "additions": 953, "deletions": 409}, "files": [{"sha": "a379b9f49ba648d3d0caaec637963f1bd1eec60e", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -31,10 +31,7 @@ use hir_ty::{\n };\n use ra_db::{CrateId, CrateName, Edition, FileId};\n use ra_prof::profile;\n-use ra_syntax::{\n-    ast::{self, AttrsOwner, NameOwner},\n-    AstNode,\n-};\n+use ra_syntax::ast::{self, AttrsOwner, NameOwner};\n use rustc_hash::FxHashSet;\n \n use crate::{\n@@ -205,7 +202,8 @@ impl ModuleDef {\n }\n \n pub use hir_def::{\n-    attr::Attrs, item_scope::ItemInNs, visibility::Visibility, AssocItemId, AssocItemLoc,\n+    attr::Attrs, item_scope::ItemInNs, item_tree::ItemTreeNode, visibility::Visibility,\n+    AssocItemId, AssocItemLoc,\n };\n \n impl Module {\n@@ -872,7 +870,7 @@ where\n     ID: Lookup<Data = AssocItemLoc<AST>>,\n     DEF: From<ID>,\n     CTOR: FnOnce(DEF) -> AssocItem,\n-    AST: AstNode,\n+    AST: ItemTreeNode,\n {\n     match id.lookup(db.upcast()).container {\n         AssocContainerId::TraitId(_) | AssocContainerId::ImplId(_) => Some(ctor(DEF::from(id))),"}, {"sha": "9c5272c2d9c58b435e45573661697fe51fb788fc", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -243,7 +243,7 @@ impl Body {\n             }\n         };\n         let expander = Expander::new(db, file_id, module);\n-        let (body, source_map) = Body::new(db, def, expander, params, body);\n+        let (body, source_map) = Body::new(db, file_id, def, expander, params, body);\n         (Arc::new(body), Arc::new(source_map))\n     }\n \n@@ -253,12 +253,13 @@ impl Body {\n \n     fn new(\n         db: &dyn DefDatabase,\n+        file_id: HirFileId,\n         def: DefWithBodyId,\n         expander: Expander,\n         params: Option<ast::ParamList>,\n         body: Option<ast::Expr>,\n     ) -> (Body, BodySourceMap) {\n-        lower::lower(db, def, expander, params, body)\n+        lower::lower(db, file_id, def, expander, params, body)\n     }\n }\n "}, {"sha": "e7cf80676ba76851ff4ccd4389355cba346403b8", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 122, "deletions": 51, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -5,7 +5,7 @@ use either::Either;\n use hir_expand::{\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    HirFileId, MacroDefId, MacroDefKind,\n+    AstId, HirFileId, MacroDefId, MacroDefKind,\n };\n use ra_arena::Arena;\n use ra_syntax::{\n@@ -27,6 +27,7 @@ use crate::{\n         LogicOp, MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n+    item_tree::{FileItemTreeId, ItemTree, ItemTreeSource},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n     AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern, ModuleDefId,\n@@ -35,6 +36,7 @@ use crate::{\n \n use super::{ExprSource, PatSource};\n use ast::AstChildren;\n+use std::sync::Arc;\n \n pub(crate) struct LowerCtx {\n     hygiene: Hygiene,\n@@ -55,11 +57,13 @@ impl LowerCtx {\n \n pub(super) fn lower(\n     db: &dyn DefDatabase,\n+    file_id: HirFileId,\n     def: DefWithBodyId,\n     expander: Expander,\n     params: Option<ast::ParamList>,\n     body: Option<ast::Expr>,\n ) -> (Body, BodySourceMap) {\n+    let item_tree = db.item_tree(file_id);\n     ExprCollector {\n         db,\n         def,\n@@ -72,6 +76,7 @@ pub(super) fn lower(\n             body_expr: dummy_expr_id(),\n             item_scope: Default::default(),\n         },\n+        item_trees: vec![(file_id, item_tree)],\n     }\n     .collect(params, body)\n }\n@@ -82,6 +87,8 @@ struct ExprCollector<'a> {\n     expander: Expander,\n     body: Body,\n     source_map: BodySourceMap,\n+\n+    item_trees: Vec<(HirFileId, Arc<ItemTree>)>,\n }\n \n impl ExprCollector<'_> {\n@@ -533,6 +540,9 @@ impl ExprCollector<'_> {\n                             self.source_map\n                                 .expansions\n                                 .insert(macro_call, self.expander.current_file_id);\n+\n+                            let item_tree = self.db.item_tree(self.expander.current_file_id);\n+                            self.item_trees.push((self.expander.current_file_id, item_tree));\n                             let id = self.collect_expr(expansion);\n                             self.expander.exit(self.db, mark);\n                             id\n@@ -547,6 +557,21 @@ impl ExprCollector<'_> {\n         }\n     }\n \n+    fn find_inner_item<S: ItemTreeSource>(&self, id: AstId<ast::ModuleItem>) -> FileItemTreeId<S> {\n+        let index =\n+            self.item_trees.iter().position(|(file, _)| *file == id.file_id).unwrap_or_else(|| {\n+                panic!(\"couldn't find item tree for file {:?}\", id.file_id);\n+            });\n+        let tree = &self.item_trees[index].1;\n+\n+        // Root file (non-macro).\n+        tree.all_inner_items()\n+            .chain(tree.top_level_items().iter().copied())\n+            .filter_map(|mod_item| mod_item.downcast::<S>())\n+            .find(|tree_id| tree[*tree_id].ast_id().upcast() == id.value)\n+            .unwrap()\n+    }\n+\n     fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n         if let Some(expr) = expr {\n             self.collect_expr(expr)\n@@ -578,56 +603,102 @@ impl ExprCollector<'_> {\n \n     fn collect_block_items(&mut self, block: &ast::BlockExpr) {\n         let container = ContainerId::DefWithBodyId(self.def);\n-        for item in block.items() {\n-            let (def, name): (ModuleDefId, Option<ast::Name>) = match item {\n-                ast::ModuleItem::FnDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (\n-                        FunctionLoc { container: container.into(), ast_id }.intern(self.db).into(),\n-                        def.name(),\n-                    )\n-                }\n-                ast::ModuleItem::TypeAliasDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (\n-                        TypeAliasLoc { container: container.into(), ast_id }.intern(self.db).into(),\n-                        def.name(),\n-                    )\n-                }\n-                ast::ModuleItem::ConstDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (\n-                        ConstLoc { container: container.into(), ast_id }.intern(self.db).into(),\n-                        def.name(),\n-                    )\n-                }\n-                ast::ModuleItem::StaticDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (StaticLoc { container, ast_id }.intern(self.db).into(), def.name())\n-                }\n-                ast::ModuleItem::StructDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (StructLoc { container, ast_id }.intern(self.db).into(), def.name())\n-                }\n-                ast::ModuleItem::EnumDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (EnumLoc { container, ast_id }.intern(self.db).into(), def.name())\n-                }\n-                ast::ModuleItem::UnionDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (UnionLoc { container, ast_id }.intern(self.db).into(), def.name())\n-                }\n-                ast::ModuleItem::TraitDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (TraitLoc { container, ast_id }.intern(self.db).into(), def.name())\n-                }\n-                ast::ModuleItem::ExternBlock(_) => continue, // FIXME: collect from extern blocks\n-                ast::ModuleItem::ImplDef(_)\n-                | ast::ModuleItem::UseItem(_)\n-                | ast::ModuleItem::ExternCrateItem(_)\n-                | ast::ModuleItem::Module(_)\n-                | ast::ModuleItem::MacroCall(_) => continue,\n-            };\n+\n+        let items = block\n+            .items()\n+            .filter_map(|item| {\n+                let (def, name): (ModuleDefId, Option<ast::Name>) = match item {\n+                    ast::ModuleItem::FnDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            FunctionLoc { container: container.into(), id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::TypeAliasDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            TypeAliasLoc { container: container.into(), id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::ConstDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            ConstLoc { container: container.into(), id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::StaticDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            StaticLoc { container, id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::StructDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            StructLoc { container, id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::EnumDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            EnumLoc { container, id: ast_id.with_value(id) }.intern(self.db).into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::UnionDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            UnionLoc { container, id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::TraitDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            TraitLoc { container, id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::ExternBlock(_) => return None, // FIXME: collect from extern blocks\n+                    ast::ModuleItem::ImplDef(_)\n+                    | ast::ModuleItem::UseItem(_)\n+                    | ast::ModuleItem::ExternCrateItem(_)\n+                    | ast::ModuleItem::Module(_)\n+                    | ast::ModuleItem::MacroCall(_) => return None,\n+                };\n+\n+                Some((def, name))\n+            })\n+            .collect::<Vec<_>>();\n+\n+        for (def, name) in items {\n             self.body.item_scope.define_def(def);\n             if let Some(name) = name {\n                 let vis = crate::visibility::Visibility::Public; // FIXME determine correctly"}, {"sha": "697fde3d21a24bf5417c1f3fd0fd9b956a58b0e4", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 96, "deletions": 124, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -5,24 +5,23 @@ use std::sync::Arc;\n use hir_expand::{\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    AstId, InFile,\n+    InFile,\n };\n use ra_prof::profile;\n-use ra_syntax::ast::{\n-    self, AssocItem, AstNode, ModuleItemOwner, NameOwner, TypeAscriptionOwner, TypeBoundsOwner,\n-    VisibilityOwner,\n-};\n+use ra_syntax::ast::{self, NameOwner, TypeAscriptionOwner, TypeBoundsOwner, VisibilityOwner};\n \n use crate::{\n     attr::Attrs,\n+    body::Expander,\n     body::LowerCtx,\n     db::DefDatabase,\n+    item_tree::{AssocItem, ItemTreeId, ModItem},\n     path::{path, AssociatedTypeBinding, GenericArgs, Path},\n     src::HasSource,\n     type_ref::{Mutability, TypeBound, TypeRef},\n     visibility::RawVisibility,\n-    AssocContainerId, AssocItemId, ConstId, ConstLoc, Expander, FunctionId, FunctionLoc, HasModule,\n-    ImplId, Intern, Lookup, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n+    AssocContainerId, AssocItemId, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n+    Intern, Lookup, ModuleId, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -155,30 +154,24 @@ pub struct TraitData {\n impl TraitData {\n     pub(crate) fn trait_data_query(db: &dyn DefDatabase, tr: TraitId) -> Arc<TraitData> {\n         let tr_loc = tr.lookup(db);\n-        let src = tr_loc.source(db);\n-        let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let auto = src.value.auto_token().is_some();\n+        let item_tree = db.item_tree(tr_loc.id.file_id);\n+        let tr_def = &item_tree[tr_loc.id.value];\n+        let name = tr_def.name.clone();\n+        let auto = tr_def.auto;\n         let module_id = tr_loc.container.module(db);\n-\n         let container = AssocContainerId::TraitId(tr);\n-        let mut items = Vec::new();\n-\n-        if let Some(item_list) = src.value.item_list() {\n-            let mut expander = Expander::new(db, tr_loc.ast_id.file_id, module_id);\n-            items.extend(collect_items(\n-                db,\n-                &mut expander,\n-                item_list.assoc_items(),\n-                src.file_id,\n-                container,\n-            ));\n-            items.extend(collect_items_in_macros(\n-                db,\n-                &mut expander,\n-                &src.with_value(item_list),\n-                container,\n-            ));\n-        }\n+        let mut expander = Expander::new(db, tr_loc.id.file_id, module_id);\n+\n+        let items = collect_items(\n+            db,\n+            module_id,\n+            &mut expander,\n+            tr_def.items.iter().copied(),\n+            tr_loc.id.file_id,\n+            container,\n+            100,\n+        );\n+\n         Arc::new(TraitData { name, items, auto })\n     }\n \n@@ -209,33 +202,28 @@ impl ImplData {\n     pub(crate) fn impl_data_query(db: &dyn DefDatabase, id: ImplId) -> Arc<ImplData> {\n         let _p = profile(\"impl_data_query\");\n         let impl_loc = id.lookup(db);\n-        let src = impl_loc.source(db);\n-        let lower_ctx = LowerCtx::new(db, src.file_id);\n \n-        let target_trait = src.value.target_trait().map(|it| TypeRef::from_ast(&lower_ctx, it));\n-        let target_type = TypeRef::from_ast_opt(&lower_ctx, src.value.target_type());\n-        let is_negative = src.value.excl_token().is_some();\n+        let item_tree = db.item_tree(impl_loc.id.file_id);\n+        let impl_def = &item_tree[impl_loc.id.value];\n+        let target_trait = impl_def.target_trait.clone();\n+        let target_type = impl_def.target_type.clone();\n+        let is_negative = impl_def.is_negative;\n         let module_id = impl_loc.container.module(db);\n         let container = AssocContainerId::ImplId(id);\n+        let mut expander = Expander::new(db, impl_loc.id.file_id, module_id);\n \n-        let mut items: Vec<AssocItemId> = Vec::new();\n-\n-        if let Some(item_list) = src.value.item_list() {\n-            let mut expander = Expander::new(db, impl_loc.ast_id.file_id, module_id);\n-            items.extend(\n-                collect_items(db, &mut expander, item_list.assoc_items(), src.file_id, container)\n-                    .into_iter()\n-                    .map(|(_, item)| item),\n-            );\n-            items.extend(\n-                collect_items_in_macros(db, &mut expander, &src.with_value(item_list), container)\n-                    .into_iter()\n-                    .map(|(_, item)| item),\n-            );\n-        }\n+        let items = collect_items(\n+            db,\n+            module_id,\n+            &mut expander,\n+            impl_def.items.iter().copied(),\n+            impl_loc.id.file_id,\n+            container,\n+            100,\n+        );\n+        let items = items.into_iter().map(|(_, item)| item).collect();\n \n-        let res = ImplData { target_trait, target_type, items, is_negative };\n-        Arc::new(res)\n+        Arc::new(ImplData { target_trait, target_type, items, is_negative })\n     }\n }\n \n@@ -295,91 +283,75 @@ impl StaticData {\n     }\n }\n \n-fn collect_items_in_macros(\n-    db: &dyn DefDatabase,\n-    expander: &mut Expander,\n-    impl_def: &InFile<ast::ItemList>,\n-    container: AssocContainerId,\n-) -> Vec<(Name, AssocItemId)> {\n-    let mut res = Vec::new();\n-\n-    // We set a limit to protect against infinite recursion\n-    let limit = 100;\n-\n-    for m in impl_def.value.syntax().children().filter_map(ast::MacroCall::cast) {\n-        res.extend(collect_items_in_macro(db, expander, m, container, limit))\n-    }\n-\n-    res\n-}\n-\n-fn collect_items_in_macro(\n+fn collect_items(\n     db: &dyn DefDatabase,\n+    module: ModuleId,\n     expander: &mut Expander,\n-    m: ast::MacroCall,\n+    assoc_items: impl Iterator<Item = AssocItem>,\n+    file_id: crate::HirFileId,\n     container: AssocContainerId,\n     limit: usize,\n ) -> Vec<(Name, AssocItemId)> {\n     if limit == 0 {\n         return Vec::new();\n     }\n \n-    if let Some((mark, items)) = expander.enter_expand(db, None, m) {\n-        let items: InFile<ast::MacroItems> = expander.to_source(items);\n-        let mut res = collect_items(\n-            db,\n-            expander,\n-            items.value.items().filter_map(|it| AssocItem::cast(it.syntax().clone())),\n-            items.file_id,\n-            container,\n-        );\n-\n-        // Recursive collect macros\n-        // Note that ast::ModuleItem do not include ast::MacroCall\n-        // We cannot use ModuleItemOwner::items here\n-        for it in items.value.syntax().children().filter_map(ast::MacroCall::cast) {\n-            res.extend(collect_items_in_macro(db, expander, it, container, limit - 1))\n-        }\n-        expander.exit(db, mark);\n-        res\n-    } else {\n-        Vec::new()\n-    }\n-}\n+    let item_tree = db.item_tree(file_id);\n+    let cfg_options = db.crate_graph()[module.krate].cfg_options.clone();\n \n-fn collect_items(\n-    db: &dyn DefDatabase,\n-    expander: &mut Expander,\n-    assoc_items: impl Iterator<Item = AssocItem>,\n-    file_id: crate::HirFileId,\n-    container: AssocContainerId,\n-) -> Vec<(Name, AssocItemId)> {\n-    let items = db.ast_id_map(file_id);\n-\n-    assoc_items\n-        .filter_map(|item_node| match item_node {\n-            ast::AssocItem::FnDef(it) => {\n-                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                if !expander.is_cfg_enabled(&it) {\n-                    return None;\n+    let mut items = Vec::new();\n+    for item in assoc_items {\n+        match item {\n+            AssocItem::Function(id) => {\n+                let item = &item_tree[id];\n+                if !item.attrs.is_cfg_enabled(&cfg_options) {\n+                    continue;\n                 }\n-                let def = FunctionLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n-                    .intern(db);\n-                Some((name, def.into()))\n+                let def = FunctionLoc { container, id: ItemTreeId::new(file_id, id) }.intern(db);\n+                items.push((item.name.clone(), def.into()));\n             }\n-            ast::AssocItem::ConstDef(it) => {\n-                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                let def = ConstLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n-                    .intern(db);\n-                Some((name, def.into()))\n+            // FIXME: cfg?\n+            AssocItem::Const(id) => {\n+                let item = &item_tree[id];\n+                let name = if let Some(name) = item.name.clone() {\n+                    name\n+                } else {\n+                    continue;\n+                };\n+                let def = ConstLoc { container, id: ItemTreeId::new(file_id, id) }.intern(db);\n+                items.push((name, def.into()));\n             }\n-            ast::AssocItem::TypeAliasDef(it) => {\n-                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                let def =\n-                    TypeAliasLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n-                        .intern(db);\n-                Some((name, def.into()))\n+            AssocItem::TypeAlias(id) => {\n+                let item = &item_tree[id];\n+                let def = TypeAliasLoc { container, id: ItemTreeId::new(file_id, id) }.intern(db);\n+                items.push((item.name.clone(), def.into()));\n             }\n-        })\n-        .collect()\n+            AssocItem::MacroCall(call) => {\n+                let call = &item_tree[call];\n+                let ast_id_map = db.ast_id_map(file_id);\n+                let root = db.parse_or_expand(file_id).unwrap();\n+                let call = ast_id_map.get(call.ast_id).to_node(&root);\n+\n+                if let Some((mark, mac)) = expander.enter_expand(db, None, call) {\n+                    let src: InFile<ast::MacroItems> = expander.to_source(mac);\n+                    let item_tree = db.item_tree(src.file_id);\n+                    let iter =\n+                        item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item);\n+                    items.extend(collect_items(\n+                        db,\n+                        module,\n+                        expander,\n+                        iter,\n+                        src.file_id,\n+                        container,\n+                        limit - 1,\n+                    ));\n+\n+                    expander.exit(db, mark);\n+                }\n+            }\n+        }\n+    }\n+\n+    items\n }"}, {"sha": "9a5dd701eb6ce322d221c251ed60f1559712bff8", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "modified", "additions": 116, "deletions": 17, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -1,6 +1,8 @@\n //! A simplified AST that only contains items.\n \n mod lower;\n+#[cfg(test)]\n+mod tests;\n \n use std::{\n     fmt::{self, Debug},\n@@ -31,16 +33,20 @@ use crate::{\n     type_ref::{Mutability, TypeBound, TypeRef},\n     visibility::RawVisibility,\n };\n+use smallvec::SmallVec;\n \n /// The item tree of a source file.\n-#[derive(Debug, Default, Eq, PartialEq)]\n+#[derive(Debug, Eq, PartialEq)]\n pub struct ItemTree {\n+    file_id: HirFileId,\n     top_level: Vec<ModItem>,\n     top_attrs: Attrs,\n     attrs: FxHashMap<ModItem, Attrs>,\n     empty_attrs: Attrs,\n+    inner_items: FxHashMap<FileAstId<ast::ModuleItem>, SmallVec<[ModItem; 1]>>,\n \n     imports: Arena<Import>,\n+    extern_crates: Arena<ExternCrate>,\n     functions: Arena<Function>,\n     structs: Arena<Struct>,\n     fields: Arena<Field>,\n@@ -63,7 +69,7 @@ impl ItemTree {\n         let syntax = if let Some(node) = db.parse_or_expand(file_id) {\n             node\n         } else {\n-            return Default::default();\n+            return Arc::new(Self::empty(file_id));\n         };\n \n         let hygiene = Hygiene::new(db.upcast(), file_id);\n@@ -80,20 +86,41 @@ impl ItemTree {\n                     file_storage = file;\n                     &file_storage\n                 },\n-                _ => return Default::default(),\n+                _ => return Arc::new(Self::empty(file_id)),\n             }\n         };\n \n-        let map = db.ast_id_map(file_id);\n-        let mut ctx = lower::Ctx {\n-            tree: ItemTree::default(),\n-            hygiene,\n-            file: file_id,\n-            source_ast_id_map: map,\n-            body_ctx: crate::body::LowerCtx::new(db, file_id),\n-        };\n-        ctx.tree.top_attrs = top_attrs.unwrap_or_default();\n-        Arc::new(ctx.lower(item_owner))\n+        let ctx = lower::Ctx::new(db, hygiene, file_id);\n+        let mut item_tree = ctx.lower(item_owner);\n+        item_tree.top_attrs = top_attrs.unwrap_or_default();\n+        Arc::new(item_tree)\n+    }\n+\n+    fn empty(file_id: HirFileId) -> Self {\n+        Self {\n+            file_id,\n+            top_level: Default::default(),\n+            top_attrs: Default::default(),\n+            attrs: Default::default(),\n+            empty_attrs: Default::default(),\n+            inner_items: Default::default(),\n+            imports: Default::default(),\n+            extern_crates: Default::default(),\n+            functions: Default::default(),\n+            structs: Default::default(),\n+            fields: Default::default(),\n+            unions: Default::default(),\n+            enums: Default::default(),\n+            variants: Default::default(),\n+            consts: Default::default(),\n+            statics: Default::default(),\n+            traits: Default::default(),\n+            impls: Default::default(),\n+            type_aliases: Default::default(),\n+            mods: Default::default(),\n+            macro_calls: Default::default(),\n+            exprs: Default::default(),\n+        }\n     }\n \n     /// Returns an iterator over all items located at the top level of the `HirFileId` this\n@@ -110,17 +137,49 @@ impl ItemTree {\n     pub fn attrs(&self, of: ModItem) -> &Attrs {\n         self.attrs.get(&of).unwrap_or(&self.empty_attrs)\n     }\n+\n+    /// Returns the lowered inner items that `ast` corresponds to.\n+    ///\n+    /// Most AST items are lowered to a single `ModItem`, but some (eg. `use` items) may be lowered\n+    /// to multiple items in the `ItemTree`.\n+    pub fn inner_items(&self, ast: FileAstId<ast::ModuleItem>) -> &[ModItem] {\n+        &self.inner_items[&ast]\n+    }\n+\n+    pub fn all_inner_items(&self) -> impl Iterator<Item = ModItem> + '_ {\n+        self.inner_items.values().flatten().copied()\n+    }\n+\n+    pub fn source<S: ItemTreeSource>(\n+        &self,\n+        db: &dyn DefDatabase,\n+        of: FileItemTreeId<S>,\n+    ) -> S::Source {\n+        // This unwrap cannot fail, since it has either succeeded above, or resulted in an empty\n+        // ItemTree (in which case there is no valid `FileItemTreeId` to call this method with).\n+        let root = db\n+            .parse_or_expand(self.file_id)\n+            .expect(\"parse_or_expand failed on constructed ItemTree\");\n+\n+        let id = self[of].ast_id();\n+        let map = db.ast_id_map(self.file_id);\n+        let ptr = map.get(id);\n+        ptr.to_node(&root)\n+    }\n }\n \n /// Trait implemented by all nodes in the item tree.\n pub trait ItemTreeNode: Clone {\n     /// Looks up an instance of `Self` in an item tree.\n     fn lookup(tree: &ItemTree, index: Idx<Self>) -> &Self;\n+\n+    /// Downcasts a `ModItem` to a `FileItemTreeId` specific to this type.\n+    fn id_from_mod_item(mod_item: ModItem) -> Option<FileItemTreeId<Self>>;\n }\n \n /// Trait for item tree nodes that allow accessing the original AST node.\n pub trait ItemTreeSource: ItemTreeNode {\n-    type Source: AstNode;\n+    type Source: AstNode + Into<ast::ModuleItem>;\n \n     fn ast_id(&self) -> FileAstId<Self::Source>;\n }\n@@ -164,12 +223,22 @@ macro_rules! nodes {\n             fn lookup(tree: &ItemTree, index: Idx<Self>) -> &Self {\n                 &tree.$fld[index]\n             }\n+\n+\n+            fn id_from_mod_item(mod_item: ModItem) -> Option<FileItemTreeId<Self>> {\n+                if let ModItem::$node(id) = mod_item {\n+                    Some(id)\n+                } else {\n+                    None\n+                }\n+            }\n         }\n     )+ };\n }\n \n nodes!(\n     Import in imports,\n+    ExternCrate in extern_crates,\n     Function in functions,\n     Struct in structs,\n     Union in unions,\n@@ -196,6 +265,8 @@ macro_rules! source {\n }\n \n source! {\n+    Import -> ast::UseItem,\n+    ExternCrate -> ast::ExternCrateItem,\n     Function -> ast::FnDef,\n     Struct -> ast::StructDef,\n     Union -> ast::UnionDef,\n@@ -248,16 +319,27 @@ impl<N: ItemTreeNode> Index<FileItemTreeId<N>> for ItemTree {\n     }\n }\n \n-/// A desugared `extern crate` or `use` import.\n+/// A desugared `use` import.\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Import {\n     pub path: ModPath,\n     pub alias: Option<ImportAlias>,\n     pub visibility: RawVisibility,\n     pub is_glob: bool,\n     pub is_prelude: bool,\n-    pub is_extern_crate: bool,\n+    /// AST ID of the `use` or `extern crate` item this import was derived from. Note that many\n+    /// `Import`s can map to the same `use` item.\n+    pub ast_id: FileAstId<ast::UseItem>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct ExternCrate {\n+    pub path: ModPath,\n+    pub alias: Option<ImportAlias>,\n+    pub visibility: RawVisibility,\n+    /// Whether this is a `#[macro_use] extern crate ...`.\n     pub is_macro_use: bool,\n+    pub ast_id: FileAstId<ast::ExternCrateItem>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -270,7 +352,6 @@ pub struct Function {\n     pub params: Vec<TypeRef>,\n     pub ret_type: TypeRef,\n     pub ast_id: FileAstId<ast::FnDef>,\n-    // FIXME inner items\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -412,6 +493,7 @@ macro_rules! impl_froms {\n #[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n pub enum ModItem {\n     Import(FileItemTreeId<Import>),\n+    ExternCrate(FileItemTreeId<ExternCrate>),\n     Function(FileItemTreeId<Function>),\n     Struct(FileItemTreeId<Struct>),\n     Union(FileItemTreeId<Union>),\n@@ -429,6 +511,7 @@ impl ModItem {\n     pub fn as_assoc_item(&self) -> Option<AssocItem> {\n         match self {\n             ModItem::Import(_)\n+            | ModItem::ExternCrate(_)\n             | ModItem::Struct(_)\n             | ModItem::Union(_)\n             | ModItem::Enum(_)\n@@ -442,10 +525,15 @@ impl ModItem {\n             ModItem::Function(func) => Some(AssocItem::Function(*func)),\n         }\n     }\n+\n+    pub fn downcast<N: ItemTreeNode>(self) -> Option<FileItemTreeId<N>> {\n+        N::id_from_mod_item(self)\n+    }\n }\n \n impl_froms!(ModItem {\n     Import(FileItemTreeId<Import>),\n+    ExternCrate(FileItemTreeId<ExternCrate>),\n     Function(FileItemTreeId<Function>),\n     Struct(FileItemTreeId<Struct>),\n     Union(FileItemTreeId<Union>),\n@@ -474,6 +562,17 @@ impl_froms!(AssocItem {\n     MacroCall(FileItemTreeId<MacroCall>),\n });\n \n+impl From<AssocItem> for ModItem {\n+    fn from(item: AssocItem) -> Self {\n+        match item {\n+            AssocItem::Function(it) => it.into(),\n+            AssocItem::TypeAlias(it) => it.into(),\n+            AssocItem::Const(it) => it.into(),\n+            AssocItem::MacroCall(it) => it.into(),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Eq, PartialEq)]\n pub struct Variant {\n     pub name: Name,"}, {"sha": "f2b8a941822ea50ee60189c4ee2cf7caf714178b", "filename": "crates/ra_hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 155, "deletions": 116, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -7,9 +7,12 @@ use crate::{\n };\n use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, HirFileId};\n use ra_arena::map::ArenaMap;\n-use ra_syntax::ast::{self, ModuleItemOwner};\n+use ra_syntax::{\n+    ast::{self, ModuleItemOwner},\n+    SyntaxNode,\n+};\n use smallvec::SmallVec;\n-use std::sync::Arc;\n+use std::{mem, sync::Arc};\n \n fn id<N: ItemTreeNode>(index: Idx<N>) -> FileItemTreeId<N> {\n     FileItemTreeId { index, _p: PhantomData }\n@@ -27,78 +30,81 @@ where\n }\n \n pub(super) struct Ctx {\n-    pub tree: ItemTree,\n-    pub hygiene: Hygiene,\n-    pub file: HirFileId,\n-    pub source_ast_id_map: Arc<AstIdMap>,\n-    pub body_ctx: crate::body::LowerCtx,\n+    tree: ItemTree,\n+    hygiene: Hygiene,\n+    file: HirFileId,\n+    source_ast_id_map: Arc<AstIdMap>,\n+    body_ctx: crate::body::LowerCtx,\n+    inner_items: Vec<ModItem>,\n }\n \n impl Ctx {\n+    pub(super) fn new(db: &dyn DefDatabase, hygiene: Hygiene, file: HirFileId) -> Self {\n+        Self {\n+            tree: ItemTree::empty(file),\n+            hygiene,\n+            file,\n+            source_ast_id_map: db.ast_id_map(file),\n+            body_ctx: crate::body::LowerCtx::new(db, file),\n+            inner_items: Vec::new(),\n+        }\n+    }\n+\n     pub(super) fn lower(mut self, item_owner: &dyn ModuleItemOwner) -> ItemTree {\n         self.tree.top_level = item_owner\n             .items()\n-            .flat_map(|item| self.lower_mod_item(&item))\n+            .flat_map(|item| self.lower_mod_item(&item, false))\n             .flat_map(|items| items.0)\n             .collect();\n         self.tree\n     }\n \n-    fn lower_mod_item(&mut self, item: &ast::ModuleItem) -> Option<ModItems> {\n+    fn lower_mod_item(&mut self, item: &ast::ModuleItem, inner: bool) -> Option<ModItems> {\n+        assert!(inner || self.inner_items.is_empty());\n+\n+        // Collect inner items for 1-to-1-lowered items.\n+        match item {\n+            ast::ModuleItem::StructDef(_)\n+            | ast::ModuleItem::UnionDef(_)\n+            | ast::ModuleItem::EnumDef(_)\n+            | ast::ModuleItem::FnDef(_)\n+            | ast::ModuleItem::TypeAliasDef(_)\n+            | ast::ModuleItem::ConstDef(_)\n+            | ast::ModuleItem::StaticDef(_)\n+            | ast::ModuleItem::MacroCall(_) => self.collect_inner_items(item.syntax()),\n+\n+            // These are handled in their respective `lower_X` method (since we can't just blindly\n+            // walk them).\n+            ast::ModuleItem::TraitDef(_)\n+            | ast::ModuleItem::ImplDef(_)\n+            | ast::ModuleItem::ExternBlock(_) => {}\n+\n+            // These don't have inner items.\n+            ast::ModuleItem::Module(_)\n+            | ast::ModuleItem::ExternCrateItem(_)\n+            | ast::ModuleItem::UseItem(_) => {}\n+        };\n+\n         let attrs = Attrs::new(item, &self.hygiene);\n         let items = match item {\n-            ast::ModuleItem::StructDef(ast) => {\n-                self.lower_struct(ast).map(|data| id(self.tree.structs.alloc(data)).into())\n-            }\n-            ast::ModuleItem::UnionDef(ast) => {\n-                self.lower_union(ast).map(|data| id(self.tree.unions.alloc(data)).into())\n-            }\n-            ast::ModuleItem::EnumDef(ast) => {\n-                self.lower_enum(ast).map(|data| id(self.tree.enums.alloc(data)).into())\n-            }\n-            ast::ModuleItem::FnDef(ast) => {\n-                self.lower_function(ast).map(|data| id(self.tree.functions.alloc(data)).into())\n-            }\n-            ast::ModuleItem::TypeAliasDef(ast) => {\n-                self.lower_type_alias(ast).map(|data| id(self.tree.type_aliases.alloc(data)).into())\n-            }\n-            ast::ModuleItem::StaticDef(ast) => {\n-                self.lower_static(ast).map(|data| id(self.tree.statics.alloc(data)).into())\n-            }\n-            ast::ModuleItem::ConstDef(ast) => {\n-                let data = self.lower_const(ast);\n-                Some(id(self.tree.consts.alloc(data)).into())\n-            }\n-            ast::ModuleItem::Module(ast) => {\n-                self.lower_module(ast).map(|data| id(self.tree.mods.alloc(data)).into())\n-            }\n-            ast::ModuleItem::TraitDef(ast) => {\n-                self.lower_trait(ast).map(|data| id(self.tree.traits.alloc(data)).into())\n-            }\n-            ast::ModuleItem::ImplDef(ast) => {\n-                self.lower_impl(ast).map(|data| id(self.tree.impls.alloc(data)).into())\n-            }\n+            ast::ModuleItem::StructDef(ast) => self.lower_struct(ast).map(Into::into),\n+            ast::ModuleItem::UnionDef(ast) => self.lower_union(ast).map(Into::into),\n+            ast::ModuleItem::EnumDef(ast) => self.lower_enum(ast).map(Into::into),\n+            ast::ModuleItem::FnDef(ast) => self.lower_function(ast).map(Into::into),\n+            ast::ModuleItem::TypeAliasDef(ast) => self.lower_type_alias(ast).map(Into::into),\n+            ast::ModuleItem::StaticDef(ast) => self.lower_static(ast).map(Into::into),\n+            ast::ModuleItem::ConstDef(ast) => Some(self.lower_const(ast).into()),\n+            ast::ModuleItem::Module(ast) => self.lower_module(ast).map(Into::into),\n+            ast::ModuleItem::TraitDef(ast) => self.lower_trait(ast).map(Into::into),\n+            ast::ModuleItem::ImplDef(ast) => self.lower_impl(ast).map(Into::into),\n             ast::ModuleItem::UseItem(ast) => Some(ModItems(\n-                self.lower_use(ast)\n-                    .into_iter()\n-                    .map(|data| id(self.tree.imports.alloc(data)).into())\n-                    .collect::<SmallVec<_>>(),\n+                self.lower_use(ast).into_iter().map(Into::into).collect::<SmallVec<_>>(),\n             )),\n-            ast::ModuleItem::ExternCrateItem(ast) => {\n-                self.lower_extern_crate(ast).map(|data| id(self.tree.imports.alloc(data)).into())\n+            ast::ModuleItem::ExternCrateItem(ast) => self.lower_extern_crate(ast).map(Into::into),\n+            ast::ModuleItem::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n+            ast::ModuleItem::ExternBlock(ast) => {\n+                Some(ModItems(self.lower_extern_block(ast).into_iter().collect::<SmallVec<_>>()))\n             }\n-            ast::ModuleItem::MacroCall(ast) => {\n-                self.lower_macro_call(ast).map(|data| id(self.tree.macro_calls.alloc(data)).into())\n-            }\n-            ast::ModuleItem::ExternBlock(ast) => Some(ModItems(\n-                self.lower_extern_block(ast)\n-                    .into_iter()\n-                    .map(|item| match item {\n-                        Either::Left(func) => id(self.tree.functions.alloc(func)).into(),\n-                        Either::Right(statik) => id(self.tree.statics.alloc(statik)).into(),\n-                    })\n-                    .collect::<SmallVec<_>>(),\n-            )),\n         };\n \n         if !attrs.is_empty() {\n@@ -110,22 +116,28 @@ impl Ctx {\n         items\n     }\n \n-    fn lower_assoc_item(&mut self, item: &ast::AssocItem) -> Option<AssocItem> {\n+    fn collect_inner_items(&mut self, container: &SyntaxNode) {\n+        let mut inner_items = mem::replace(&mut self.tree.inner_items, FxHashMap::default());\n+        inner_items.extend(\n+            container.descendants().skip(1).filter_map(ast::ModuleItem::cast).filter_map(|item| {\n+                let ast_id = self.source_ast_id_map.ast_id(&item);\n+                Some((ast_id, self.lower_mod_item(&item, true)?.0))\n+            }),\n+        );\n+        self.tree.inner_items = inner_items;\n+    }\n+\n+    fn lower_assoc_item(&mut self, item: &ast::ModuleItem) -> Option<AssocItem> {\n         match item {\n-            ast::AssocItem::FnDef(ast) => {\n-                self.lower_function(ast).map(|data| id(self.tree.functions.alloc(data)).into())\n-            }\n-            ast::AssocItem::TypeAliasDef(ast) => {\n-                self.lower_type_alias(ast).map(|data| id(self.tree.type_aliases.alloc(data)).into())\n-            }\n-            ast::AssocItem::ConstDef(ast) => {\n-                let data = self.lower_const(ast);\n-                Some(id(self.tree.consts.alloc(data)).into())\n-            }\n+            ast::ModuleItem::FnDef(ast) => self.lower_function(ast).map(Into::into),\n+            ast::ModuleItem::TypeAliasDef(ast) => self.lower_type_alias(ast).map(Into::into),\n+            ast::ModuleItem::ConstDef(ast) => Some(self.lower_const(ast).into()),\n+            ast::ModuleItem::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n+            _ => None,\n         }\n     }\n \n-    fn lower_struct(&mut self, strukt: &ast::StructDef) -> Option<Struct> {\n+    fn lower_struct(&mut self, strukt: &ast::StructDef) -> Option<FileItemTreeId<Struct>> {\n         let attrs = self.lower_attrs(strukt);\n         let visibility = self.lower_visibility(strukt);\n         let name = strukt.name()?.as_name();\n@@ -138,7 +150,7 @@ impl Ctx {\n             ast::StructKind::Unit => StructDefKind::Unit,\n         };\n         let res = Struct { name, attrs, visibility, generic_params, fields, ast_id, kind };\n-        Some(res)\n+        Some(id(self.tree.structs.alloc(res)))\n     }\n \n     fn lower_fields(&mut self, strukt_kind: &ast::StructKind) -> Fields {\n@@ -193,7 +205,7 @@ impl Ctx {\n         Some(res)\n     }\n \n-    fn lower_union(&mut self, union: &ast::UnionDef) -> Option<Union> {\n+    fn lower_union(&mut self, union: &ast::UnionDef) -> Option<FileItemTreeId<Union>> {\n         let attrs = self.lower_attrs(union);\n         let visibility = self.lower_visibility(union);\n         let name = union.name()?.as_name();\n@@ -206,10 +218,10 @@ impl Ctx {\n         };\n         let ast_id = self.source_ast_id_map.ast_id(union);\n         let res = Union { name, attrs, visibility, generic_params, fields, ast_id };\n-        Some(res)\n+        Some(id(self.tree.unions.alloc(res)))\n     }\n \n-    fn lower_enum(&mut self, enum_: &ast::EnumDef) -> Option<Enum> {\n+    fn lower_enum(&mut self, enum_: &ast::EnumDef) -> Option<FileItemTreeId<Enum>> {\n         let attrs = self.lower_attrs(enum_);\n         let visibility = self.lower_visibility(enum_);\n         let name = enum_.name()?.as_name();\n@@ -220,7 +232,7 @@ impl Ctx {\n         };\n         let ast_id = self.source_ast_id_map.ast_id(enum_);\n         let res = Enum { name, attrs, visibility, generic_params, variants, ast_id };\n-        Some(res)\n+        Some(id(self.tree.enums.alloc(res)))\n     }\n \n     fn lower_variants(&mut self, variants: &ast::EnumVariantList) -> Range<Idx<Variant>> {\n@@ -241,7 +253,7 @@ impl Ctx {\n         Some(res)\n     }\n \n-    fn lower_function(&mut self, func: &ast::FnDef) -> Option<Function> {\n+    fn lower_function(&mut self, func: &ast::FnDef) -> Option<FileItemTreeId<Function>> {\n         let attrs = self.lower_attrs(func);\n         let visibility = self.lower_visibility(func);\n         let name = func.name()?.as_name();\n@@ -297,37 +309,42 @@ impl Ctx {\n             ast_id,\n         };\n         res.generic_params = self.lower_generic_params(GenericsOwner::Function(&res), func);\n-        Some(res)\n+\n+        Some(id(self.tree.functions.alloc(res)))\n     }\n \n-    fn lower_type_alias(&mut self, type_alias: &ast::TypeAliasDef) -> Option<TypeAlias> {\n+    fn lower_type_alias(\n+        &mut self,\n+        type_alias: &ast::TypeAliasDef,\n+    ) -> Option<FileItemTreeId<TypeAlias>> {\n         let name = type_alias.name()?.as_name();\n         let type_ref = type_alias.type_ref().map(|it| self.lower_type_ref(&it));\n         let visibility = self.lower_visibility(type_alias);\n         let generic_params = self.lower_generic_params(GenericsOwner::TypeAlias, type_alias);\n         let ast_id = self.source_ast_id_map.ast_id(type_alias);\n         let res = TypeAlias { name, visibility, generic_params, type_ref, ast_id };\n-        Some(res)\n+        Some(id(self.tree.type_aliases.alloc(res)))\n     }\n \n-    fn lower_static(&mut self, static_: &ast::StaticDef) -> Option<Static> {\n+    fn lower_static(&mut self, static_: &ast::StaticDef) -> Option<FileItemTreeId<Static>> {\n         let name = static_.name()?.as_name();\n         let type_ref = self.lower_type_ref_opt(static_.ascribed_type());\n         let visibility = self.lower_visibility(static_);\n         let ast_id = self.source_ast_id_map.ast_id(static_);\n         let res = Static { name, visibility, type_ref, ast_id };\n-        Some(res)\n+        Some(id(self.tree.statics.alloc(res)))\n     }\n \n-    fn lower_const(&mut self, konst: &ast::ConstDef) -> Const {\n+    fn lower_const(&mut self, konst: &ast::ConstDef) -> FileItemTreeId<Const> {\n         let name = konst.name().map(|it| it.as_name());\n         let type_ref = self.lower_type_ref_opt(konst.ascribed_type());\n         let visibility = self.lower_visibility(konst);\n         let ast_id = self.source_ast_id_map.ast_id(konst);\n-        Const { name, visibility, type_ref, ast_id }\n+        let res = Const { name, visibility, type_ref, ast_id };\n+        id(self.tree.consts.alloc(res))\n     }\n \n-    fn lower_module(&mut self, module: &ast::Module) -> Option<Mod> {\n+    fn lower_module(&mut self, module: &ast::Module) -> Option<FileItemTreeId<Mod>> {\n         let name = module.name()?.as_name();\n         let visibility = self.lower_visibility(module);\n         let kind = if module.semicolon_token().is_some() {\n@@ -338,7 +355,7 @@ impl Ctx {\n                     .item_list()\n                     .map(|list| {\n                         list.items()\n-                            .flat_map(|item| self.lower_mod_item(&item))\n+                            .flat_map(|item| self.lower_mod_item(&item, false))\n                             .flat_map(|items| items.0)\n                             .collect()\n                     })\n@@ -349,90 +366,101 @@ impl Ctx {\n             }\n         };\n         let ast_id = self.source_ast_id_map.ast_id(module);\n-        Some(Mod { name, visibility, kind, ast_id })\n+        let res = Mod { name, visibility, kind, ast_id };\n+        Some(id(self.tree.mods.alloc(res)))\n     }\n \n-    fn lower_trait(&mut self, trait_def: &ast::TraitDef) -> Option<Trait> {\n+    fn lower_trait(&mut self, trait_def: &ast::TraitDef) -> Option<FileItemTreeId<Trait>> {\n         let name = trait_def.name()?.as_name();\n         let visibility = self.lower_visibility(trait_def);\n         let generic_params = self.lower_generic_params(GenericsOwner::Trait(trait_def), trait_def);\n         let auto = trait_def.auto_token().is_some();\n         let items = trait_def.item_list().map(|list| {\n-            // FIXME: Does not handle macros\n-            list.assoc_items().flat_map(|item| self.lower_assoc_item(&item)).collect()\n+            list.items()\n+                .flat_map(|item| {\n+                    self.collect_inner_items(item.syntax());\n+                    self.lower_assoc_item(&item)\n+                })\n+                .collect()\n         });\n         let ast_id = self.source_ast_id_map.ast_id(trait_def);\n-        Some(Trait {\n+        let res = Trait {\n             name,\n             visibility,\n             generic_params,\n             auto,\n             items: items.unwrap_or_default(),\n             ast_id,\n-        })\n+        };\n+        Some(id(self.tree.traits.alloc(res)))\n     }\n \n-    fn lower_impl(&mut self, impl_def: &ast::ImplDef) -> Option<Impl> {\n+    fn lower_impl(&mut self, impl_def: &ast::ImplDef) -> Option<FileItemTreeId<Impl>> {\n         let generic_params = self.lower_generic_params(GenericsOwner::Impl, impl_def);\n         let target_trait = impl_def.target_trait().map(|tr| self.lower_type_ref(&tr));\n         let target_type = self.lower_type_ref(&impl_def.target_type()?);\n         let is_negative = impl_def.excl_token().is_some();\n+\n+        // We cannot use `assoc_items()` here as that does not include macro calls.\n         let items = impl_def\n             .item_list()?\n-            .assoc_items()\n-            .filter_map(|item| self.lower_assoc_item(&item))\n+            .items()\n+            .filter_map(|item| {\n+                self.collect_inner_items(item.syntax());\n+                let assoc = self.lower_assoc_item(&item)?;\n+                Some(assoc)\n+            })\n             .collect();\n         let ast_id = self.source_ast_id_map.ast_id(impl_def);\n-        Some(Impl { generic_params, target_trait, target_type, is_negative, items, ast_id })\n+        let res = Impl { generic_params, target_trait, target_type, is_negative, items, ast_id };\n+        Some(id(self.tree.impls.alloc(res)))\n     }\n \n-    fn lower_use(&mut self, use_item: &ast::UseItem) -> Vec<Import> {\n+    fn lower_use(&mut self, use_item: &ast::UseItem) -> Vec<FileItemTreeId<Import>> {\n         // FIXME: cfg_attr\n         let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n         let visibility = self.lower_visibility(use_item);\n+        let ast_id = self.source_ast_id_map.ast_id(use_item);\n \n         // Every use item can expand to many `Import`s.\n         let mut imports = Vec::new();\n+        let tree = &mut self.tree;\n         ModPath::expand_use_item(\n             InFile::new(self.file, use_item.clone()),\n             &self.hygiene,\n             |path, _tree, is_glob, alias| {\n-                imports.push(Import {\n+                imports.push(id(tree.imports.alloc(Import {\n                     path,\n                     alias,\n                     visibility: visibility.clone(),\n                     is_glob,\n                     is_prelude,\n-                    is_extern_crate: false,\n-                    is_macro_use: false,\n-                });\n+                    ast_id,\n+                })));\n             },\n         );\n \n         imports\n     }\n \n-    fn lower_extern_crate(&mut self, extern_crate: &ast::ExternCrateItem) -> Option<Import> {\n+    fn lower_extern_crate(\n+        &mut self,\n+        extern_crate: &ast::ExternCrateItem,\n+    ) -> Option<FileItemTreeId<ExternCrate>> {\n         let path = ModPath::from_name_ref(&extern_crate.name_ref()?);\n         let alias = extern_crate.alias().map(|a| {\n             a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n         });\n         let visibility = self.lower_visibility(extern_crate);\n+        let ast_id = self.source_ast_id_map.ast_id(extern_crate);\n         // FIXME: cfg_attr\n         let is_macro_use = extern_crate.has_atom_attr(\"macro_use\");\n \n-        Some(Import {\n-            path,\n-            alias,\n-            visibility,\n-            is_glob: false,\n-            is_prelude: false,\n-            is_extern_crate: true,\n-            is_macro_use,\n-        })\n+        let res = ExternCrate { path, alias, visibility, is_macro_use, ast_id };\n+        Some(id(self.tree.extern_crates.alloc(res)))\n     }\n \n-    fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<MacroCall> {\n+    fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<FileItemTreeId<MacroCall>> {\n         let name = m.name().map(|it| it.as_name());\n         let attrs = Attrs::new(m, &self.hygiene);\n         let path = ModPath::from_src(m.path()?, &self.hygiene)?;\n@@ -455,15 +483,26 @@ impl Ctx {\n         };\n \n         let is_builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n-        Some(MacroCall { name, path, is_export, is_builtin, is_local_inner, ast_id })\n+        let res = MacroCall { name, path, is_export, is_builtin, is_local_inner, ast_id };\n+        Some(id(self.tree.macro_calls.alloc(res)))\n     }\n \n-    fn lower_extern_block(&mut self, block: &ast::ExternBlock) -> Vec<Either<Function, Static>> {\n+    fn lower_extern_block(&mut self, block: &ast::ExternBlock) -> Vec<ModItem> {\n         block.extern_item_list().map_or(Vec::new(), |list| {\n             list.extern_items()\n-                .filter_map(|item| match item {\n-                    ast::ExternItem::FnDef(ast) => self.lower_function(&ast).map(Either::Left),\n-                    ast::ExternItem::StaticDef(ast) => self.lower_static(&ast).map(Either::Right),\n+                .filter_map(|item| {\n+                    self.collect_inner_items(item.syntax());\n+                    let id = match item {\n+                        ast::ExternItem::FnDef(ast) => {\n+                            let func = self.lower_function(&ast)?;\n+                            func.into()\n+                        }\n+                        ast::ExternItem::StaticDef(ast) => {\n+                            let statik = self.lower_static(&ast)?;\n+                            statik.into()\n+                        }\n+                    };\n+                    Some(id)\n                 })\n                 .collect()\n         })"}, {"sha": "b60e6cbb0c06328705bb648defdc9a99122c1d7d", "filename": "crates/ra_hir_def/src/item_tree/tests.rs", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -0,0 +1,254 @@\n+use super::{ItemTree, ModItem, ModKind};\n+use crate::{db::DefDatabase, test_db::TestDB};\n+use hir_expand::db::AstDatabase;\n+use insta::assert_snapshot;\n+use ra_db::fixture::WithFixture;\n+use ra_syntax::{ast, AstNode};\n+use rustc_hash::FxHashSet;\n+use std::sync::Arc;\n+use stdx::format_to;\n+\n+fn test_inner_items(ra_fixture: &str) {\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    let tree = db.item_tree(file_id.into());\n+    let root = db.parse_or_expand(file_id.into()).unwrap();\n+    let ast_id_map = db.ast_id_map(file_id.into());\n+\n+    // Traverse the item tree and collect all module/impl/trait-level items as AST nodes.\n+    let mut outer_items = FxHashSet::default();\n+    let mut worklist = tree.top_level_items().to_vec();\n+    while let Some(item) = worklist.pop() {\n+        let node: ast::ModuleItem = match item {\n+            ModItem::Import(it) => tree.source(&db, it).into(),\n+            ModItem::ExternCrate(it) => tree.source(&db, it).into(),\n+            ModItem::Function(it) => tree.source(&db, it).into(),\n+            ModItem::Struct(it) => tree.source(&db, it).into(),\n+            ModItem::Union(it) => tree.source(&db, it).into(),\n+            ModItem::Enum(it) => tree.source(&db, it).into(),\n+            ModItem::Const(it) => tree.source(&db, it).into(),\n+            ModItem::Static(it) => tree.source(&db, it).into(),\n+            ModItem::TypeAlias(it) => tree.source(&db, it).into(),\n+            ModItem::Mod(it) => {\n+                if let ModKind::Inline { items } = &tree[it].kind {\n+                    worklist.extend(items);\n+                }\n+                tree.source(&db, it).into()\n+            }\n+            ModItem::Trait(it) => {\n+                worklist.extend(tree[it].items.iter().map(|item| ModItem::from(*item)));\n+                tree.source(&db, it).into()\n+            }\n+            ModItem::Impl(it) => {\n+                worklist.extend(tree[it].items.iter().map(|item| ModItem::from(*item)));\n+                tree.source(&db, it).into()\n+            }\n+            ModItem::MacroCall(_) => continue,\n+        };\n+\n+        outer_items.insert(node);\n+    }\n+\n+    // Now descend the root node and check that all `ast::ModuleItem`s are either recorded above, or\n+    // registered as inner items.\n+    for item in root.descendants().skip(1).filter_map(ast::ModuleItem::cast) {\n+        if outer_items.contains(&item) {\n+            continue;\n+        }\n+\n+        let ast_id = ast_id_map.ast_id(&item);\n+        assert!(!tree.inner_items(ast_id).is_empty());\n+    }\n+}\n+\n+fn item_tree(ra_fixture: &str) -> Arc<ItemTree> {\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    db.item_tree(file_id.into())\n+}\n+\n+fn print_item_tree(ra_fixture: &str) -> String {\n+    let tree = item_tree(ra_fixture);\n+    let mut out = String::new();\n+\n+    format_to!(out, \"inner attrs: {:?}\\n\\n\", tree.top_level_attrs());\n+    format_to!(out, \"top-level items:\\n\");\n+    for item in tree.top_level_items() {\n+        fmt_mod_item(&mut out, &tree, *item);\n+        format_to!(out, \"\\n\");\n+    }\n+\n+    if !tree.inner_items.is_empty() {\n+        format_to!(out, \"\\ninner items:\\n\");\n+        for (ast_id, items) in &tree.inner_items {\n+            format_to!(out, \"{:?}:\\n\", ast_id);\n+            for inner in items {\n+                format_to!(out, \"- \");\n+                fmt_mod_item(&mut out, &tree, *inner);\n+                format_to!(out, \"\\n\");\n+            }\n+        }\n+    }\n+\n+    out\n+}\n+\n+fn fmt_mod_item(out: &mut String, tree: &ItemTree, item: ModItem) {\n+    match item {\n+        ModItem::ExternCrate(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Import(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Function(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Struct(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Union(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Enum(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Const(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Static(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Trait(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Impl(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::TypeAlias(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Mod(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::MacroCall(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn smoke() {\n+    assert_snapshot!(print_item_tree(r\"\n+        #![attr]\n+\n+        use {a, b::*};\n+        extern crate krate;\n+\n+        trait Tr<U> {\n+            type AssocTy: Tr<()>;\n+            const CONST: u8;\n+            fn method(&self);\n+            fn dfl_method(&mut self) {}\n+        }\n+\n+        struct Struct0<T = ()>;\n+        struct Struct1<T>(u8);\n+        struct Struct2<T> {\n+            fld: (T, ),\n+        }\n+\n+        enum En {\n+            Variant {\n+                field: u8,\n+            },\n+        }\n+\n+        union Un {\n+            fld: u16,\n+        }\n+    \"), @r###\"\n+inner attrs: Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr\"))] }, input: None }]) }\n+\n+top-level items:\n+Import { path: ModPath { kind: Plain, segments: [Name(Text(\"a\"))] }, alias: None, visibility: Module(ModPath { kind: Super(0), segments: [] }), is_glob: false, is_prelude: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::UseItem>(0) }\n+Import { path: ModPath { kind: Plain, segments: [Name(Text(\"b\"))] }, alias: None, visibility: Module(ModPath { kind: Super(0), segments: [] }), is_glob: true, is_prelude: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::UseItem>(0) }\n+ExternCrate { path: ModPath { kind: Plain, segments: [Name(Text(\"krate\"))] }, alias: None, visibility: Module(ModPath { kind: Super(0), segments: [] }), is_macro_use: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ExternCrateItem>(1) }\n+Trait { name: Name(Text(\"Tr\")), visibility: Module(ModPath { kind: Super(0), segments: [] }), generic_params: GenericParams { types: Arena { len: 2, data: [TypeParamData { name: Some(Name(Text(\"Self\"))), default: None, provenance: TraitSelf }, TypeParamData { name: Some(Name(Text(\"U\"))), default: None, provenance: TypeParamList }] }, where_predicates: [] }, auto: false, items: [TypeAlias(Idx::<TypeAlias>(0)), Const(Idx::<Const>(0)), Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::TraitDef>(2) }\n+Struct { name: Name(Text(\"Struct0\")), attrs: Attrs { entries: None }, visibility: Module(ModPath { kind: Super(0), segments: [] }), generic_params: GenericParams { types: Arena { len: 1, data: [TypeParamData { name: Some(Name(Text(\"T\"))), default: Some(Tuple([])), provenance: TypeParamList }] }, where_predicates: [] }, fields: Unit, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(3), kind: Unit }\n+Struct { name: Name(Text(\"Struct1\")), attrs: Attrs { entries: None }, visibility: Module(ModPath { kind: Super(0), segments: [] }), generic_params: GenericParams { types: Arena { len: 1, data: [TypeParamData { name: Some(Name(Text(\"T\"))), default: None, provenance: TypeParamList }] }, where_predicates: [] }, fields: Tuple(Idx::<Field>(0)..Idx::<Field>(1)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(4), kind: Tuple }\n+Struct { name: Name(Text(\"Struct2\")), attrs: Attrs { entries: None }, visibility: Module(ModPath { kind: Super(0), segments: [] }), generic_params: GenericParams { types: Arena { len: 1, data: [TypeParamData { name: Some(Name(Text(\"T\"))), default: None, provenance: TypeParamList }] }, where_predicates: [] }, fields: Record(Idx::<Field>(1)..Idx::<Field>(2)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(5), kind: Record }\n+Enum { name: Name(Text(\"En\")), attrs: Attrs { entries: None }, visibility: Module(ModPath { kind: Super(0), segments: [] }), generic_params: GenericParams { types: Arena { len: 0, data: [] }, where_predicates: [] }, variants: Idx::<Variant>(0)..Idx::<Variant>(1), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::EnumDef>(6) }\n+Union { name: Name(Text(\"Un\")), attrs: Attrs { entries: None }, visibility: Module(ModPath { kind: Super(0), segments: [] }), generic_params: GenericParams { types: Arena { len: 0, data: [] }, where_predicates: [] }, fields: Record(Idx::<Field>(3)..Idx::<Field>(4)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::UnionDef>(7) }\n+    \"###);\n+}\n+\n+#[test]\n+fn simple_inner_items() {\n+    let tree = print_item_tree(\n+        r\"\n+        impl<T:A> D for Response<T> {\n+            fn foo() {\n+                end();\n+                fn end<W: Write>() {\n+                    let _x: T = loop {};\n+                }\n+            }\n+        }\n+    \",\n+    );\n+\n+    assert_snapshot!(tree, @r###\"\n+inner attrs: Attrs { entries: None }\n+\n+top-level items:\n+Impl { generic_params: GenericParams { types: Arena { len: 0, data: [] }, where_predicates: [] }, target_trait: Some(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"D\"))] }, generic_args: [None] })), target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Response\"))] }, generic_args: [Some(GenericArgs { args: [Type(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"T\"))] }, generic_args: [None] }))], has_self_type: false, bindings: [] })] }), is_negative: false, items: [Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ImplDef>(0) }\n+\n+inner items:\n+FileAstId::<ra_syntax::ast::generated::nodes::ModuleItem>(2):\n+- Function { name: Name(Text(\"end\")), attrs: Attrs { entries: None }, visibility: Module(ModPath { kind: Super(0), segments: [] }), generic_params: GenericParams { types: Arena { len: 1, data: [TypeParamData { name: Some(Name(Text(\"W\"))), default: None, provenance: TypeParamList }] }, where_predicates: [WherePredicate { target: TypeRef(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"W\"))] }, generic_args: [None] })), bound: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Write\"))] }, generic_args: [None] }) }] }, has_self_param: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(2) }\n+    \"###);\n+}\n+\n+#[test]\n+fn cursed_inner_items() {\n+    test_inner_items(\n+        r\"\n+        struct S<T: Trait = [u8; { fn f() {} 0 }]>(T);\n+\n+        enum En {\n+            Var1 {\n+                t: [(); { trait Inner {} 0 }],\n+            },\n+\n+            Var2([u16; { enum Inner {} 0 }]),\n+        }\n+\n+        type Ty = [En; { struct Inner; 0 }];\n+\n+        impl En {\n+            fn assoc() {\n+                trait InnerTrait {}\n+                struct InnerStruct {}\n+                impl InnerTrait for InnerStruct {}\n+            }\n+        }\n+    \",\n+    );\n+}\n+\n+#[test]\n+fn assoc_item_macros() {\n+    let tree = print_item_tree(\n+        r\"\n+        impl S {\n+            items!();\n+        }\n+    \",\n+    );\n+\n+    assert_snapshot!(tree, @r###\"\n+inner attrs: Attrs { entries: None }\n+\n+top-level items:\n+Impl { generic_params: GenericParams { types: Arena { len: 0, data: [] }, where_predicates: [] }, target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"S\"))] }, generic_args: [None] }), is_negative: false, items: [MacroCall(Idx::<MacroCall>(0))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ImplDef>(0) }\n+    \"###);\n+}"}, {"sha": "564434cccf0e79748b9446d6118528cfb8e56961", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 78, "deletions": 19, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -50,18 +50,21 @@ pub mod import_map;\n #[cfg(test)]\n mod test_db;\n \n-use std::hash::Hash;\n+use std::hash::{Hash, Hasher};\n \n use hir_expand::{\n     ast_id_map::FileAstId, eager::expand_eager_macro, hygiene::Hygiene, AstId, HirFileId, InFile,\n     MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use ra_arena::Idx;\n use ra_db::{impl_intern_key, salsa, CrateId};\n-use ra_syntax::{ast, AstNode};\n+use ra_syntax::ast;\n \n-use crate::body::Expander;\n use crate::builtin_type::BuiltinType;\n+use item_tree::{\n+    Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, ModItem, Static, Struct, Trait,\n+    TypeAlias, Union,\n+};\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ModuleId {\n@@ -72,16 +75,62 @@ pub struct ModuleId {\n /// An ID of a module, **local** to a specific crate\n pub type LocalModuleId = Idx<nameres::ModuleData>;\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ItemLoc<N: AstNode> {\n+#[derive(Debug)]\n+pub struct ItemLoc<N: ItemTreeNode> {\n     pub container: ContainerId,\n-    pub ast_id: AstId<N>,\n+    pub id: ItemTreeId<N>,\n+}\n+\n+impl<N: ItemTreeNode> Clone for ItemLoc<N> {\n+    fn clone(&self) -> Self {\n+        Self { container: self.container, id: self.id }\n+    }\n+}\n+\n+impl<N: ItemTreeNode> Copy for ItemLoc<N> {}\n+\n+impl<N: ItemTreeNode> PartialEq for ItemLoc<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.container == other.container && self.id == other.id\n+    }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct AssocItemLoc<N: AstNode> {\n+impl<N: ItemTreeNode> Eq for ItemLoc<N> {}\n+\n+impl<N: ItemTreeNode> Hash for ItemLoc<N> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.container.hash(state);\n+        self.id.hash(state);\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct AssocItemLoc<N: ItemTreeNode> {\n     pub container: AssocContainerId,\n-    pub ast_id: AstId<N>,\n+    pub id: ItemTreeId<N>,\n+}\n+\n+impl<N: ItemTreeNode> Clone for AssocItemLoc<N> {\n+    fn clone(&self) -> Self {\n+        Self { container: self.container, id: self.id }\n+    }\n+}\n+\n+impl<N: ItemTreeNode> Copy for AssocItemLoc<N> {}\n+\n+impl<N: ItemTreeNode> PartialEq for AssocItemLoc<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.container == other.container && self.id == other.id\n+    }\n+}\n+\n+impl<N: ItemTreeNode> Eq for AssocItemLoc<N> {}\n+\n+impl<N: ItemTreeNode> Hash for AssocItemLoc<N> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.container.hash(state);\n+        self.id.hash(state);\n+    }\n }\n \n macro_rules! impl_intern {\n@@ -106,22 +155,22 @@ macro_rules! impl_intern {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct FunctionId(salsa::InternId);\n-type FunctionLoc = AssocItemLoc<ast::FnDef>;\n+type FunctionLoc = AssocItemLoc<Function>;\n impl_intern!(FunctionId, FunctionLoc, intern_function, lookup_intern_function);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StructId(salsa::InternId);\n-type StructLoc = ItemLoc<ast::StructDef>;\n+type StructLoc = ItemLoc<Struct>;\n impl_intern!(StructId, StructLoc, intern_struct, lookup_intern_struct);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct UnionId(salsa::InternId);\n-pub type UnionLoc = ItemLoc<ast::UnionDef>;\n+pub type UnionLoc = ItemLoc<Union>;\n impl_intern!(UnionId, UnionLoc, intern_union, lookup_intern_union);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct EnumId(salsa::InternId);\n-pub type EnumLoc = ItemLoc<ast::EnumDef>;\n+pub type EnumLoc = ItemLoc<Enum>;\n impl_intern!(EnumId, EnumLoc, intern_enum, lookup_intern_enum);\n \n // FIXME: rename to `VariantId`, only enums can ave variants\n@@ -143,27 +192,27 @@ pub type LocalFieldId = Idx<adt::FieldData>;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ConstId(salsa::InternId);\n-type ConstLoc = AssocItemLoc<ast::ConstDef>;\n+type ConstLoc = AssocItemLoc<Const>;\n impl_intern!(ConstId, ConstLoc, intern_const, lookup_intern_const);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StaticId(salsa::InternId);\n-pub type StaticLoc = ItemLoc<ast::StaticDef>;\n+pub type StaticLoc = ItemLoc<Static>;\n impl_intern!(StaticId, StaticLoc, intern_static, lookup_intern_static);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TraitId(salsa::InternId);\n-pub type TraitLoc = ItemLoc<ast::TraitDef>;\n+pub type TraitLoc = ItemLoc<Trait>;\n impl_intern!(TraitId, TraitLoc, intern_trait, lookup_intern_trait);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeAliasId(salsa::InternId);\n-type TypeAliasLoc = AssocItemLoc<ast::TypeAliasDef>;\n+type TypeAliasLoc = AssocItemLoc<TypeAlias>;\n impl_intern!(TypeAliasId, TypeAliasLoc, intern_type_alias, lookup_intern_type_alias);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\n pub struct ImplId(salsa::InternId);\n-type ImplLoc = ItemLoc<ast::ImplDef>;\n+type ImplLoc = ItemLoc<Impl>;\n impl_intern!(ImplId, ImplLoc, intern_impl, lookup_intern_impl);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -367,7 +416,7 @@ impl HasModule for AssocContainerId {\n     }\n }\n \n-impl<N: AstNode> HasModule for AssocItemLoc<N> {\n+impl<N: ItemTreeNode> HasModule for AssocItemLoc<N> {\n     fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         self.container.module(db)\n     }\n@@ -394,6 +443,16 @@ impl HasModule for DefWithBodyId {\n     }\n }\n \n+impl DefWithBodyId {\n+    pub fn as_mod_item(self, db: &dyn db::DefDatabase) -> ModItem {\n+        match self {\n+            DefWithBodyId::FunctionId(it) => it.lookup(db).id.value.into(),\n+            DefWithBodyId::StaticId(it) => it.lookup(db).id.value.into(),\n+            DefWithBodyId::ConstId(it) => it.lookup(db).id.value.into(),\n+        }\n+    }\n+}\n+\n impl HasModule for GenericDefId {\n     fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         match self {"}, {"sha": "40aff830f071e06064224db6f9eafb82076383a3", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 84, "deletions": 50, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -20,9 +20,7 @@ use test_utils::mark;\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n-    item_tree::{\n-        FileItemTreeId, Import, ItemTree, MacroCall, Mod, ModItem, ModKind, StructDefKind,\n-    },\n+    item_tree::{self, ItemTree, ItemTreeId, MacroCall, Mod, ModItem, ModKind, StructDefKind},\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n         BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, ResolveMode,\n@@ -105,10 +103,48 @@ impl PartialResolvedImport {\n     }\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq)]\n+struct Import {\n+    pub path: ModPath,\n+    pub alias: Option<ImportAlias>,\n+    pub visibility: RawVisibility,\n+    pub is_glob: bool,\n+    pub is_prelude: bool,\n+    pub is_extern_crate: bool,\n+    pub is_macro_use: bool,\n+}\n+\n+impl From<item_tree::Import> for Import {\n+    fn from(it: item_tree::Import) -> Self {\n+        Self {\n+            path: it.path,\n+            alias: it.alias,\n+            visibility: it.visibility,\n+            is_glob: it.is_glob,\n+            is_prelude: it.is_prelude,\n+            is_extern_crate: false,\n+            is_macro_use: false,\n+        }\n+    }\n+}\n+\n+impl From<item_tree::ExternCrate> for Import {\n+    fn from(it: item_tree::ExternCrate) -> Self {\n+        Self {\n+            path: it.path,\n+            alias: it.alias,\n+            visibility: it.visibility,\n+            is_glob: false,\n+            is_prelude: false,\n+            is_extern_crate: true,\n+            is_macro_use: it.is_macro_use,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug, Eq, PartialEq)]\n struct ImportDirective {\n     module_id: LocalModuleId,\n-    import_id: FileItemTreeId<Import>,\n     import: Import,\n     status: PartialResolvedImport,\n }\n@@ -297,7 +333,7 @@ impl DefCollector<'_> {\n     fn import_macros_from_extern_crate(\n         &mut self,\n         current_module_id: LocalModuleId,\n-        import: &Import,\n+        import: &item_tree::ExternCrate,\n     ) {\n         log::debug!(\n             \"importing macros from extern crate: {:?} ({:?})\",\n@@ -703,9 +739,9 @@ impl ModCollector<'_, '_> {\n         // any other items.\n         for item in items {\n             if self.is_cfg_enabled(self.item_tree.attrs(*item)) {\n-                if let ModItem::Import(import_id) = item {\n-                    let import = self.item_tree[*import_id].clone();\n-                    if import.is_extern_crate && import.is_macro_use {\n+                if let ModItem::ExternCrate(id) = item {\n+                    let import = self.item_tree[*id].clone();\n+                    if import.is_macro_use {\n                         self.def_collector.import_macros_from_extern_crate(self.module_id, &import);\n                     }\n                 }\n@@ -725,8 +761,14 @@ impl ModCollector<'_, '_> {\n                     ModItem::Import(import_id) => {\n                         self.def_collector.unresolved_imports.push(ImportDirective {\n                             module_id: self.module_id,\n-                            import_id,\n-                            import: self.item_tree[import_id].clone(),\n+                            import: self.item_tree[import_id].clone().into(),\n+                            status: PartialResolvedImport::Unresolved,\n+                        })\n+                    }\n+                    ModItem::ExternCrate(import_id) => {\n+                        self.def_collector.unresolved_imports.push(ImportDirective {\n+                            module_id: self.module_id,\n+                            import: self.item_tree[import_id].clone().into(),\n                             status: PartialResolvedImport::Unresolved,\n                         })\n                     }\n@@ -737,90 +779,85 @@ impl ModCollector<'_, '_> {\n                             local_id: self.module_id,\n                         };\n                         let container = ContainerId::ModuleId(module);\n-                        let ast_id = self.item_tree[imp].ast_id;\n-                        let impl_id =\n-                            ImplLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                                .intern(self.def_collector.db);\n+                        let impl_id = ImplLoc { container, id: ItemTreeId::new(self.file_id, imp) }\n+                            .intern(self.def_collector.db);\n                         self.def_collector.def_map.modules[self.module_id]\n                             .scope\n                             .define_impl(impl_id)\n                     }\n-                    ModItem::Function(it) => {\n-                        let it = &self.item_tree[it];\n+                    ModItem::Function(id) => {\n+                        let func = &self.item_tree[id];\n                         def = Some(DefData {\n                             id: FunctionLoc {\n                                 container: container.into(),\n-                                ast_id: AstId::new(self.file_id, it.ast_id),\n+                                id: ItemTreeId::new(self.file_id, id),\n                             }\n                             .intern(self.def_collector.db)\n                             .into(),\n-                            name: &it.name,\n-                            visibility: &it.visibility,\n+                            name: &func.name,\n+                            visibility: &func.visibility,\n                             has_constructor: false,\n                         });\n                     }\n-                    ModItem::Struct(it) => {\n-                        let it = &self.item_tree[it];\n+                    ModItem::Struct(id) => {\n+                        let it = &self.item_tree[id];\n \n                         // FIXME: check attrs to see if this is an attribute macro invocation;\n                         // in which case we don't add the invocation, just a single attribute\n                         // macro invocation\n                         self.collect_derives(attrs, it.ast_id.upcast());\n \n                         def = Some(DefData {\n-                            id: StructLoc {\n-                                container,\n-                                ast_id: AstId::new(self.file_id, it.ast_id),\n-                            }\n-                            .intern(self.def_collector.db)\n-                            .into(),\n+                            id: StructLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                                .intern(self.def_collector.db)\n+                                .into(),\n                             name: &it.name,\n                             visibility: &it.visibility,\n                             has_constructor: it.kind != StructDefKind::Record,\n                         });\n                     }\n-                    ModItem::Union(it) => {\n-                        let it = &self.item_tree[it];\n+                    ModItem::Union(id) => {\n+                        let it = &self.item_tree[id];\n \n                         // FIXME: check attrs to see if this is an attribute macro invocation;\n                         // in which case we don't add the invocation, just a single attribute\n                         // macro invocation\n                         self.collect_derives(attrs, it.ast_id.upcast());\n \n                         def = Some(DefData {\n-                            id: UnionLoc { container, ast_id: AstId::new(self.file_id, it.ast_id) }\n+                            id: UnionLoc { container, id: ItemTreeId::new(self.file_id, id) }\n                                 .intern(self.def_collector.db)\n                                 .into(),\n                             name: &it.name,\n                             visibility: &it.visibility,\n                             has_constructor: false,\n                         });\n                     }\n-                    ModItem::Enum(it) => {\n-                        let it = &self.item_tree[it];\n+                    ModItem::Enum(id) => {\n+                        let it = &self.item_tree[id];\n \n                         // FIXME: check attrs to see if this is an attribute macro invocation;\n                         // in which case we don't add the invocation, just a single attribute\n                         // macro invocation\n                         self.collect_derives(attrs, it.ast_id.upcast());\n \n                         def = Some(DefData {\n-                            id: EnumLoc { container, ast_id: AstId::new(self.file_id, it.ast_id) }\n+                            id: EnumLoc { container, id: ItemTreeId::new(self.file_id, id) }\n                                 .intern(self.def_collector.db)\n                                 .into(),\n                             name: &it.name,\n                             visibility: &it.visibility,\n                             has_constructor: false,\n                         });\n                     }\n-                    ModItem::Const(it) => {\n-                        let it = &self.item_tree[it];\n+                    ModItem::Const(id) => {\n+                        let it = &self.item_tree[id];\n \n                         if let Some(name) = &it.name {\n                             def = Some(DefData {\n                                 id: ConstLoc {\n                                     container: container.into(),\n-                                    ast_id: AstId::new(self.file_id, it.ast_id),\n+                                    id: ItemTreeId::new(self.file_id, id),\n                                 }\n                                 .intern(self.def_collector.db)\n                                 .into(),\n@@ -830,40 +867,37 @@ impl ModCollector<'_, '_> {\n                             });\n                         }\n                     }\n-                    ModItem::Static(it) => {\n-                        let it = &self.item_tree[it];\n+                    ModItem::Static(id) => {\n+                        let it = &self.item_tree[id];\n \n                         def = Some(DefData {\n-                            id: StaticLoc {\n-                                container,\n-                                ast_id: AstId::new(self.file_id, it.ast_id),\n-                            }\n-                            .intern(self.def_collector.db)\n-                            .into(),\n+                            id: StaticLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                                .intern(self.def_collector.db)\n+                                .into(),\n                             name: &it.name,\n                             visibility: &it.visibility,\n                             has_constructor: false,\n                         });\n                     }\n-                    ModItem::Trait(it) => {\n-                        let it = &self.item_tree[it];\n+                    ModItem::Trait(id) => {\n+                        let it = &self.item_tree[id];\n \n                         def = Some(DefData {\n-                            id: TraitLoc { container, ast_id: AstId::new(self.file_id, it.ast_id) }\n+                            id: TraitLoc { container, id: ItemTreeId::new(self.file_id, id) }\n                                 .intern(self.def_collector.db)\n                                 .into(),\n                             name: &it.name,\n                             visibility: &it.visibility,\n                             has_constructor: false,\n                         });\n                     }\n-                    ModItem::TypeAlias(it) => {\n-                        let it = &self.item_tree[it];\n+                    ModItem::TypeAlias(id) => {\n+                        let it = &self.item_tree[id];\n \n                         def = Some(DefData {\n                             id: TypeAliasLoc {\n                                 container: container.into(),\n-                                ast_id: AstId::new(self.file_id, it.ast_id),\n+                                id: ItemTreeId::new(self.file_id, id),\n                             }\n                             .intern(self.def_collector.db)\n                             .into(),"}, {"sha": "e9a5e4cba1b2b6b6f7800fa77c1874af3c04c962", "filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -722,10 +722,7 @@ fn unresolved_module_diagnostics() {\n                         ),\n                     ),\n                 ),\n-                value: FileAstId {\n-                    raw: Idx::<SyntaxNodePtr>(1),\n-                    _ty: PhantomData,\n-                },\n+                value: FileAstId::<ra_syntax::ast::generated::nodes::Module>(1),\n             },\n             candidate: \"bar.rs\",\n         },"}, {"sha": "10e21d48e61a2ac6b95ada5508c3f05bede29a84", "filename": "crates/ra_hir_def/src/src.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_def%2Fsrc%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fsrc.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -2,30 +2,37 @@\n \n use hir_expand::InFile;\n use ra_arena::map::ArenaMap;\n-use ra_syntax::AstNode;\n \n-use crate::{db::DefDatabase, AssocItemLoc, ItemLoc};\n+use crate::{db::DefDatabase, item_tree::ItemTreeSource, AssocItemLoc, ItemLoc};\n \n pub trait HasSource {\n     type Value;\n     fn source(&self, db: &dyn DefDatabase) -> InFile<Self::Value>;\n }\n \n-impl<N: AstNode> HasSource for AssocItemLoc<N> {\n-    type Value = N;\n+impl<N: ItemTreeSource> HasSource for AssocItemLoc<N> {\n+    type Value = N::Source;\n \n-    fn source(&self, db: &dyn DefDatabase) -> InFile<N> {\n-        let node = self.ast_id.to_node(db.upcast());\n-        InFile::new(self.ast_id.file_id, node)\n+    fn source(&self, db: &dyn DefDatabase) -> InFile<N::Source> {\n+        let tree = db.item_tree(self.id.file_id);\n+        let ast_id_map = db.ast_id_map(self.id.file_id);\n+        let root = db.parse_or_expand(self.id.file_id).unwrap();\n+        let node = &tree[self.id.value];\n+\n+        InFile::new(self.id.file_id, ast_id_map.get(node.ast_id()).to_node(&root))\n     }\n }\n \n-impl<N: AstNode> HasSource for ItemLoc<N> {\n-    type Value = N;\n+impl<N: ItemTreeSource> HasSource for ItemLoc<N> {\n+    type Value = N::Source;\n+\n+    fn source(&self, db: &dyn DefDatabase) -> InFile<N::Source> {\n+        let tree = db.item_tree(self.id.file_id);\n+        let ast_id_map = db.ast_id_map(self.id.file_id);\n+        let root = db.parse_or_expand(self.id.file_id).unwrap();\n+        let node = &tree[self.id.value];\n \n-    fn source(&self, db: &dyn DefDatabase) -> InFile<N> {\n-        let node = self.ast_id.to_node(db.upcast());\n-        InFile::new(self.ast_id.file_id, node)\n+        InFile::new(self.id.file_id, ast_id_map.get(node.ast_id()).to_node(&root))\n     }\n }\n "}, {"sha": "f4d31526a62e4d2cb9f3667afb231a400935b2c5", "filename": "crates/ra_hir_expand/src/ast_id_map.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -6,6 +6,8 @@\n //! changes.\n \n use std::{\n+    any::type_name,\n+    fmt,\n     hash::{Hash, Hasher},\n     marker::PhantomData,\n };\n@@ -14,7 +16,6 @@ use ra_arena::{Arena, Idx};\n use ra_syntax::{ast, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr};\n \n /// `AstId` points to an AST node in a specific file.\n-#[derive(Debug)]\n pub struct FileAstId<N: AstNode> {\n     raw: ErasedFileAstId,\n     _ty: PhantomData<fn() -> N>,\n@@ -39,11 +40,17 @@ impl<N: AstNode> Hash for FileAstId<N> {\n     }\n }\n \n+impl<N: AstNode> fmt::Debug for FileAstId<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"FileAstId::<{}>({})\", type_name::<N>(), self.raw.into_raw())\n+    }\n+}\n+\n impl<N: AstNode> FileAstId<N> {\n     // Can't make this a From implementation because of coherence\n     pub fn upcast<M: AstNode>(self) -> FileAstId<M>\n     where\n-        M: From<N>,\n+        N: Into<M>,\n     {\n         FileAstId { raw: self.raw, _ty: PhantomData }\n     }\n@@ -89,7 +96,7 @@ impl AstIdMap {\n         }\n     }\n \n-    pub(crate) fn get<N: AstNode>(&self, id: FileAstId<N>) -> AstPtr<N> {\n+    pub fn get<N: AstNode>(&self, id: FileAstId<N>) -> AstPtr<N> {\n         self.arena[id.raw].clone().cast::<N>().unwrap()\n     }\n "}, {"sha": "e82f2c11e2a512209ecab7ab9dfd1766480c1b3c", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=4b03b39d5b4b00daffb120a4d2d9ea4a55a9a7ac", "patch": "@@ -67,8 +67,8 @@ fn type_at_pos_displayed(\n     panic!(\"Can't find expression\")\n }\n \n-fn type_at(content: &str) -> String {\n-    let (db, file_pos) = TestDB::with_position(content);\n+fn type_at(ra_fixture: &str) -> String {\n+    let (db, file_pos) = TestDB::with_position(ra_fixture);\n     type_at_pos(&db, file_pos)\n }\n \n@@ -164,13 +164,19 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n     visit_module(&db, &crate_def_map, module.local_id, &mut |it| defs.push(it));\n     defs.sort_by_key(|def| match def {\n         DefWithBodyId::FunctionId(it) => {\n-            it.lookup(&db).ast_id.to_node(&db).syntax().text_range().start()\n+            let loc = it.lookup(&db);\n+            let tree = db.item_tree(loc.id.file_id);\n+            tree.source(&db, loc.id.value).syntax().text_range().start()\n         }\n         DefWithBodyId::ConstId(it) => {\n-            it.lookup(&db).ast_id.to_node(&db).syntax().text_range().start()\n+            let loc = it.lookup(&db);\n+            let tree = db.item_tree(loc.id.file_id);\n+            tree.source(&db, loc.id.value).syntax().text_range().start()\n         }\n         DefWithBodyId::StaticId(it) => {\n-            it.lookup(&db).ast_id.to_node(&db).syntax().text_range().start()\n+            let loc = it.lookup(&db);\n+            let tree = db.item_tree(loc.id.file_id);\n+            tree.source(&db, loc.id.value).syntax().text_range().start()\n         }\n     });\n     for def in defs {"}]}