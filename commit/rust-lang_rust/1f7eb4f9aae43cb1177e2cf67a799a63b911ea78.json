{"sha": "1f7eb4f9aae43cb1177e2cf67a799a63b911ea78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmN2ViNGY5YWFlNDNjYjExNzdlMmNmNjdhNzk5YTYzYjkxMWVhNzg=", "commit": {"author": {"name": "David Creswick", "email": "dcrewi@gyrae.net", "date": "2013-11-12T04:17:47Z"}, "committer": {"name": "David Creswick", "email": "dcrewi@gyrae.net", "date": "2013-11-13T17:31:59Z"}, "message": "make missing_doc lint respect the visibility rules\n\nPreviously, the `exported_items` set created by the privacy pass was\nincomplete. Specifically, it did not include items that had been defined\nat a private path but then `pub use`d at a public path. This commit\nfinds all crate exports during the privacy pass. Consequently, some code\nin the reachable pass and in rustdoc is no longer necessary. This commit\nthen removes the separate `MissingDocLintVisitor` lint pass, opting to\ncheck missing_doc lint in the same pass as the other lint checkers using\nthe visibility result computed by the privacy pass.\n\nFixes #9777.", "tree": {"sha": "0e17edd4ee83da9638cb94025d172fc414fe4bee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e17edd4ee83da9638cb94025d172fc414fe4bee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78", "html_url": "https://github.com/rust-lang/rust/commit/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/comments", "author": {"login": "dcrewi", "id": 1852207, "node_id": "MDQ6VXNlcjE4NTIyMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/1852207?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dcrewi", "html_url": "https://github.com/dcrewi", "followers_url": "https://api.github.com/users/dcrewi/followers", "following_url": "https://api.github.com/users/dcrewi/following{/other_user}", "gists_url": "https://api.github.com/users/dcrewi/gists{/gist_id}", "starred_url": "https://api.github.com/users/dcrewi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dcrewi/subscriptions", "organizations_url": "https://api.github.com/users/dcrewi/orgs", "repos_url": "https://api.github.com/users/dcrewi/repos", "events_url": "https://api.github.com/users/dcrewi/events{/privacy}", "received_events_url": "https://api.github.com/users/dcrewi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dcrewi", "id": 1852207, "node_id": "MDQ6VXNlcjE4NTIyMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/1852207?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dcrewi", "html_url": "https://github.com/dcrewi", "followers_url": "https://api.github.com/users/dcrewi/followers", "following_url": "https://api.github.com/users/dcrewi/following{/other_user}", "gists_url": "https://api.github.com/users/dcrewi/gists{/gist_id}", "starred_url": "https://api.github.com/users/dcrewi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dcrewi/subscriptions", "organizations_url": "https://api.github.com/users/dcrewi/orgs", "repos_url": "https://api.github.com/users/dcrewi/repos", "events_url": "https://api.github.com/users/dcrewi/events{/privacy}", "received_events_url": "https://api.github.com/users/dcrewi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d9b95fada7c97ac1c63099bab1d45ba120958ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d9b95fada7c97ac1c63099bab1d45ba120958ec", "html_url": "https://github.com/rust-lang/rust/commit/4d9b95fada7c97ac1c63099bab1d45ba120958ec"}], "stats": {"total": 497, "additions": 253, "deletions": 244}, "files": [{"sha": "772b322a0e564ee6e30c6887094fc42ed217203e", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=1f7eb4f9aae43cb1177e2cf67a799a63b911ea78", "patch": "@@ -305,11 +305,10 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n \n     let reachable_map =\n         time(time_passes, \"reachability checking\", (), |_|\n-             reachable::find_reachable(ty_cx, method_map, exp_map2,\n-                                       &exported_items));\n+             reachable::find_reachable(ty_cx, method_map, &exported_items));\n \n     time(time_passes, \"lint checking\", (), |_|\n-         lint::check_crate(ty_cx, crate));\n+         lint::check_crate(ty_cx, &exported_items, crate));\n \n     CrateAnalysis {\n         exp_map2: exp_map2,"}, {"sha": "64438906dae3932bb978020f04b084d12c640c64", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 128, "deletions": 117, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=1f7eb4f9aae43cb1177e2cf67a799a63b911ea78", "patch": "@@ -34,6 +34,7 @@\n //! Context itself, span_lint should be used instead of add_lint.\n \n use driver::session;\n+use middle::privacy;\n use middle::trans::adt; // for `adt::is_ffi_safe`\n use middle::ty;\n use middle::pat_util;\n@@ -317,21 +318,28 @@ pub fn get_lint_dict() -> LintDict {\n     return map;\n }\n \n-struct Context {\n+struct Context<'self> {\n     // All known lint modes (string versions)\n     dict: @LintDict,\n     // Current levels of each lint warning\n     cur: SmallIntMap<(level, LintSource)>,\n     // context we're checking in (used to access fields like sess)\n     tcx: ty::ctxt,\n+    // Items exported by the crate; used by the missing_doc lint.\n+    exported_items: &'self privacy::ExportedItems,\n+    // The id of the current `ast::struct_def` being walked.\n+    cur_struct_def_id: ast::NodeId,\n+    // Whether some ancestor of the current node was marked\n+    // #[doc(hidden)].\n+    is_doc_hidden: bool,\n \n     // When recursing into an attributed node of the ast which modifies lint\n     // levels, this stack keeps track of the previous lint levels of whatever\n     // was modified.\n     lint_stack: ~[(lint, level, LintSource)],\n }\n \n-impl Context {\n+impl<'self> Context<'self> {\n     fn get_level(&self, lint: lint) -> level {\n         match self.cur.find(&(lint as uint)) {\n           Some(&(lvl, _)) => lvl,\n@@ -440,9 +448,16 @@ impl Context {\n             true\n         };\n \n+        let old_is_doc_hidden = self.is_doc_hidden;\n+        self.is_doc_hidden = self.is_doc_hidden ||\n+            attrs.iter().any(|attr| (\"doc\" == attr.name() && match attr.meta_item_list()\n+                                     { None => false,\n+                                       Some(l) => attr::contains_name(l, \"hidden\") }));\n+\n         f(self);\n \n         // rollback\n+        self.is_doc_hidden = old_is_doc_hidden;\n         do pushed.times {\n             let (lint, lvl, src) = self.lint_stack.pop();\n             self.set_level(lint, lvl, src);\n@@ -870,125 +885,83 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n     }\n }\n \n-struct MissingDocLintVisitor(ty::ctxt);\n-\n-impl MissingDocLintVisitor {\n-    fn check_attrs(&self, attrs: &[ast::Attribute], id: ast::NodeId,\n-                   sp: Span, msg: ~str) {\n-        if !attrs.iter().any(|a| a.node.is_sugared_doc) {\n-            self.sess.add_lint(missing_doc, id, sp, msg);\n-        }\n-    }\n-\n-    fn check_struct(&self, sdef: &ast::struct_def) {\n-        for field in sdef.fields.iter() {\n-            match field.node.kind {\n-                ast::named_field(_, vis) if vis != ast::private => {\n-                    self.check_attrs(field.node.attrs, field.node.id, field.span,\n-                                     ~\"missing documentation for a field\");\n-                }\n-                ast::unnamed_field | ast::named_field(*) => {}\n-            }\n-        }\n-    }\n-\n-    fn doc_hidden(&self, attrs: &[ast::Attribute]) -> bool {\n-        do attrs.iter().any |attr| {\n-            \"doc\" == attr.name() &&\n-                match attr.meta_item_list() {\n-                    Some(l) => attr::contains_name(l, \"hidden\"),\n-                    None    => false // not of the form #[doc(...)]\n-                }\n-        }\n+fn check_missing_doc_attrs(cx: &Context,\n+                           id: ast::NodeId,\n+                           attrs: &[ast::Attribute],\n+                           sp: Span,\n+                           desc: &'static str) {\n+    // If we're building a test harness, then warning about\n+    // documentation is probably not really relevant right now.\n+    if cx.tcx.sess.opts.test { return }\n+\n+    // `#[doc(hidden)]` disables missing_doc check.\n+    if cx.is_doc_hidden { return }\n+\n+    // Only check publicly-visible items, using the result from the\n+    // privacy pass.\n+    if !cx.exported_items.contains(&id) { return }\n+\n+    if !attrs.iter().any(|a| a.node.is_sugared_doc) {\n+        cx.span_lint(missing_doc, sp,\n+                     format!(\"missing documentation for {}\", desc));\n     }\n }\n \n-impl Visitor<()> for MissingDocLintVisitor {\n-    fn visit_ty_method(&mut self, m:&ast::TypeMethod, _: ()) {\n-        if self.doc_hidden(m.attrs) { return }\n-\n-        // All ty_method objects are linted about because they're part of a\n-        // trait (no visibility)\n-        self.check_attrs(m.attrs, m.id, m.span,\n-                         ~\"missing documentation for a method\");\n-        visit::walk_ty_method(self, m, ());\n-    }\n+fn check_missing_doc_item(cx: &mut Context, it: &ast::item) { // XXX doesn't need to be mut\n+    let desc = match it.node {\n+        ast::item_fn(*) => \"a function\",\n+        ast::item_mod(*) => \"a module\",\n+        ast::item_enum(*) => \"an enum\",\n+        ast::item_struct(*) => \"a struct\",\n+        ast::item_trait(*) => \"a trait\",\n+        _ => return\n+    };\n+    check_missing_doc_attrs(cx, it.id, it.attrs, it.span, desc);\n+}\n \n-    fn visit_fn(&mut self, fk: &visit::fn_kind, d: &ast::fn_decl,\n-                b: &ast::Block, sp: Span, id: ast::NodeId, _: ()) {\n-        // Only warn about explicitly public methods.\n-        match *fk {\n-            visit::fk_method(_, _, m) => {\n-                if self.doc_hidden(m.attrs) {\n-                    return;\n-                }\n-                // If we're in a trait implementation, no need to duplicate\n-                // documentation\n-                if m.vis == ast::public {\n-                    self.check_attrs(m.attrs, id, sp,\n-                                     ~\"missing documentation for a method\");\n+fn check_missing_doc_method(cx: &Context, m: &ast::method) {\n+    let did = ast::DefId {\n+        crate: ast::LOCAL_CRATE,\n+        node: m.id\n+    };\n+    match cx.tcx.methods.find(&did) {\n+        None => cx.tcx.sess.span_bug(m.span, \"missing method descriptor?!\"),\n+        Some(md) => {\n+            match md.container {\n+                // Always check default methods defined on traits.\n+                ty::TraitContainer(*) => {}\n+                // For methods defined on impls, it depends on whether\n+                // it is an implementation for a trait or is a plain\n+                // impl.\n+                ty::ImplContainer(cid) => {\n+                    match ty::impl_trait_ref(cx.tcx, cid) {\n+                        Some(*) => return, // impl for trait: don't doc\n+                        None => {} // plain impl: doc according to privacy\n+                    }\n                 }\n             }\n-            _ => {}\n         }\n-        visit::walk_fn(self, fk, d, b, sp, id, ());\n     }\n+    check_missing_doc_attrs(cx, m.id, m.attrs, m.span, \"a method\");\n+}\n \n-    fn visit_item(&mut self, it: @ast::item, _: ()) {\n-        // If we're building a test harness, then warning about documentation is\n-        // probably not really relevant right now\n-        if self.sess.opts.test { return }\n-        if self.doc_hidden(it.attrs) { return }\n-\n-        match it.node {\n-            ast::item_struct(sdef, _) if it.vis == ast::public => {\n-                self.check_attrs(it.attrs, it.id, it.span,\n-                                 ~\"missing documentation for a struct\");\n-                self.check_struct(sdef);\n-            }\n-\n-            // Skip implementations because they inherit documentation from the\n-            // trait (which was already linted)\n-            ast::item_impl(_, Some(*), _, _) => return,\n-\n-            ast::item_trait(*) if it.vis != ast::public => return,\n-            ast::item_trait(*) => self.check_attrs(it.attrs, it.id, it.span,\n-                                                   ~\"missing documentation for a trait\"),\n-\n-            ast::item_fn(*) if it.vis == ast::public => {\n-                self.check_attrs(it.attrs, it.id, it.span,\n-                                 ~\"missing documentation for a function\");\n-            }\n-\n-            ast::item_mod(*) if it.vis == ast::public => {\n-                self.check_attrs(it.attrs, it.id, it.span,\n-                                 ~\"missing documentation for a module\");\n-            }\n-\n-            ast::item_enum(ref edef, _) if it.vis == ast::public => {\n-                self.check_attrs(it.attrs, it.id, it.span,\n-                                 ~\"missing documentation for an enum\");\n-                for variant in edef.variants.iter() {\n-                    if variant.node.vis == ast::private { continue; }\n-\n-                    self.check_attrs(variant.node.attrs, variant.node.id,\n-                                     variant.span,\n-                                     ~\"missing documentation for a variant\");\n-                    match variant.node.kind {\n-                        ast::struct_variant_kind(sdef) => {\n-                            self.check_struct(sdef);\n-                        }\n-                        _ => ()\n-                    }\n-                }\n-            }\n+fn check_missing_doc_ty_method(cx: &Context, tm: &ast::TypeMethod) {\n+    check_missing_doc_attrs(cx, tm.id, tm.attrs, tm.span, \"a type method\");\n+}\n \n-            _ => {}\n-        }\n-        visit::walk_item(self, it, ());\n+fn check_missing_doc_struct_field(cx: &Context, sf: &ast::struct_field) {\n+    match sf.node.kind {\n+        ast::named_field(_, vis) if vis != ast::private =>\n+            check_missing_doc_attrs(cx, cx.cur_struct_def_id, sf.node.attrs,\n+                                    sf.span, \"a struct field\"),\n+        _ => {}\n     }\n }\n \n+fn check_missing_doc_variant(cx: &Context, v: &ast::variant) {\n+    check_missing_doc_attrs(cx, v.node.id, v.node.attrs, v.span, \"a variant\");\n+}\n+\n /// Checks for use of items with #[deprecated], #[experimental] and\n /// #[unstable] (or none of them) attributes.\n fn check_stability(cx: &Context, e: &ast::Expr) {\n@@ -1062,13 +1035,14 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n     cx.span_lint(lint, e.span, msg);\n }\n \n-impl Visitor<()> for Context {\n+impl<'self> Visitor<()> for Context<'self> {\n     fn visit_item(&mut self, it: @ast::item, _: ()) {\n         do self.with_lint_attrs(it.attrs) |cx| {\n             check_item_ctypes(cx, it);\n             check_item_non_camel_case_types(cx, it);\n             check_item_non_uppercase_statics(cx, it);\n             check_heap_item(cx, it);\n+            check_missing_doc_item(cx, it);\n \n             do cx.visit_ids |v| {\n                 v.visit_item(it, ());\n@@ -1111,6 +1085,8 @@ impl Visitor<()> for Context {\n         match *fk {\n             visit::fk_method(_, _, m) => {\n                 do self.with_lint_attrs(m.attrs) |cx| {\n+                    check_missing_doc_method(cx, m);\n+\n                     do cx.visit_ids |v| {\n                         v.visit_fn(fk, decl, body, span, id, ());\n                     }\n@@ -1120,9 +1096,45 @@ impl Visitor<()> for Context {\n             _ => recurse(self),\n         }\n     }\n+\n+    fn visit_ty_method(&mut self, t: &ast::TypeMethod, _: ()) {\n+        do self.with_lint_attrs(t.attrs) |cx| {\n+            check_missing_doc_ty_method(cx, t);\n+\n+            visit::walk_ty_method(cx, t, ());\n+        }\n+    }\n+\n+    fn visit_struct_def(&mut self,\n+                        s: @ast::struct_def,\n+                        i: ast::Ident,\n+                        g: &ast::Generics,\n+                        id: ast::NodeId,\n+                        _: ()) {\n+        let old_id = self.cur_struct_def_id;\n+        self.cur_struct_def_id = id;\n+        visit::walk_struct_def(self, s, i, g, id, ());\n+        self.cur_struct_def_id = old_id;\n+    }\n+\n+    fn visit_struct_field(&mut self, s: @ast::struct_field, _: ()) {\n+        do self.with_lint_attrs(s.node.attrs) |cx| {\n+            check_missing_doc_struct_field(cx, s);\n+\n+            visit::walk_struct_field(cx, s, ());\n+        }\n+    }\n+\n+    fn visit_variant(&mut self, v: &ast::variant, g: &ast::Generics, _: ()) {\n+        do self.with_lint_attrs(v.node.attrs) |cx| {\n+            check_missing_doc_variant(cx, v);\n+\n+            visit::walk_variant(cx, v, g, ());\n+        }\n+    }\n }\n \n-impl ast_util::IdVisitingOperation for Context {\n+impl<'self> ast_util::IdVisitingOperation for Context<'self> {\n     fn visit_id(&self, id: ast::NodeId) {\n         match self.tcx.sess.lints.pop(&id) {\n             None => {}\n@@ -1135,17 +1147,16 @@ impl ast_util::IdVisitingOperation for Context {\n     }\n }\n \n-pub fn check_crate(tcx: ty::ctxt, crate: &ast::Crate) {\n-    // This visitor contains more state than is currently maintained in Context,\n-    // and there's no reason for the Context to keep track of this information\n-    // really\n-    let mut dox = MissingDocLintVisitor(tcx);\n-    visit::walk_crate(&mut dox, crate, ());\n-\n+pub fn check_crate(tcx: ty::ctxt,\n+                   exported_items: &privacy::ExportedItems,\n+                   crate: &ast::Crate) {\n     let mut cx = Context {\n         dict: @get_lint_dict(),\n         cur: SmallIntMap::new(),\n         tcx: tcx,\n+        exported_items: exported_items,\n+        cur_struct_def_id: -1,\n+        is_doc_hidden: false,\n         lint_stack: ~[],\n     };\n "}, {"sha": "d516483dec38d9f8fa3f8ea9b85d6237ba6f7649", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 58, "deletions": 20, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=1f7eb4f9aae43cb1177e2cf67a799a63b911ea78", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -31,8 +31,7 @@ use syntax::visit::Visitor;\n \n type Context<'self> = (&'self method_map, &'self resolve::ExportMap2);\n \n-// A set of all nodes in the ast which can be considered \"publicly exported\" in\n-// the sense that they are accessible from anywhere in any hierarchy.\n+/// A set of AST nodes exported by the crate.\n pub type ExportedItems = HashSet<ast::NodeId>;\n \n // This visitor is used to determine the parent of all nodes in question when it\n@@ -141,11 +140,28 @@ impl<'self> Visitor<()> for ParentVisitor<'self> {\n // This visitor is used to determine which items of the ast are embargoed,\n // otherwise known as not exported.\n struct EmbargoVisitor<'self> {\n+    tcx: ty::ctxt,\n+    // A set of all nodes in the ast which can be considered \"publicly\n+    // exported\" in the sense that they are accessible from anywhere\n+    // in any hierarchy. They are public items whose ancestors are all\n+    // public.\n+    path_all_public_items: &'self mut ExportedItems,\n+    // A set of all nodes in the ast that can be reached via a public\n+    // path. This includes everything in `path_all_public_items` as\n+    // well as re-exported private nodes (`pub use`ing a private\n+    // path).\n     exported_items: &'self mut ExportedItems,\n     exp_map2: &'self resolve::ExportMap2,\n     path_all_public: bool,\n }\n \n+impl<'self> EmbargoVisitor<'self> {\n+    fn add_path_all_public_item(&mut self, id: ast::NodeId) {\n+        self.path_all_public_items.insert(id);\n+        self.exported_items.insert(id);\n+    }\n+}\n+\n impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n     fn visit_item(&mut self, item: @ast::item, _: ()) {\n         let orig_all_pub = self.path_all_public;\n@@ -162,7 +178,7 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n         }\n \n         if self.path_all_public {\n-            self.exported_items.insert(item.id);\n+            self.add_path_all_public_item(item.id);\n         }\n \n         match item.node {\n@@ -171,7 +187,7 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n             ast::item_enum(ref def, _) if self.path_all_public => {\n                 for variant in def.variants.iter() {\n                     if variant.node.vis != ast::private {\n-                        self.exported_items.insert(variant.node.id);\n+                        self.add_path_all_public_item(variant.node.id);\n                     }\n                 }\n             }\n@@ -184,7 +200,7 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n                         _ => true,\n                     } && method.vis == ast::public;\n                     if public {\n-                        self.exported_items.insert(method.id);\n+                        self.add_path_all_public_item(method.id);\n                     }\n                 }\n             }\n@@ -193,7 +209,7 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n             ast::item_impl(_, Some(*), _, ref methods) => {\n                 for method in methods.iter() {\n                     debug!(\"exporting: {}\", method.id);\n-                    self.exported_items.insert(method.id);\n+                    self.add_path_all_public_item(method.id);\n                 }\n             }\n \n@@ -204,21 +220,20 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n                     match *method {\n                         ast::provided(ref m) => {\n                             debug!(\"provided {}\", m.id);\n-                            self.exported_items.insert(m.id);\n+                            self.add_path_all_public_item(m.id);\n                         }\n                         ast::required(ref m) => {\n                             debug!(\"required {}\", m.id);\n-                            self.exported_items.insert(m.id);\n+                            self.add_path_all_public_item(m.id);\n                         }\n                     }\n                 }\n             }\n \n-            // Default methods on traits are all public so long as the trait is\n-            // public\n+            // Struct constructors are public if the struct is all public.\n             ast::item_struct(ref def, _) if self.path_all_public => {\n                 match def.ctor_id {\n-                    Some(id) => { self.exported_items.insert(id); }\n+                    Some(id) => { self.add_path_all_public_item(id); }\n                     None => {}\n                 }\n             }\n@@ -233,17 +248,36 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n \n     fn visit_foreign_item(&mut self, a: @ast::foreign_item, _: ()) {\n         if self.path_all_public && a.vis == ast::public {\n-            self.exported_items.insert(a.id);\n+            self.add_path_all_public_item(a.id);\n+        }\n+    }\n+\n+    fn visit_mod(&mut self, m: &ast::_mod, sp: Span, id: ast::NodeId, _: ()) {\n+        // This code is here instead of in visit_item so that the\n+        // crate module gets processed as well.\n+        if self.path_all_public {\n+            match self.exp_map2.find(&id) {\n+                Some(exports) => {\n+                    for export in exports.iter() {\n+                        if is_local(export.def_id) && export.reexport {\n+                            self.exported_items.insert(export.def_id.node);\n+                        }\n+                    }\n+                }\n+                None => self.tcx.sess.span_bug(sp, \"missing exp_map2 entry \\\n+                                               for module\"),\n+            }\n         }\n+        visit::walk_mod(self, m, ())\n     }\n }\n \n struct PrivacyVisitor<'self> {\n     tcx: ty::ctxt,\n     curitem: ast::NodeId,\n \n-    // Results of previous analyses necessary for privacy checking.\n-    exported_items: &'self ExportedItems,\n+    // See comments on the same field in `EmbargoVisitor`.\n+    path_all_public_items: &'self ExportedItems,\n     method_map: &'self method_map,\n     parents: &'self HashMap<ast::NodeId, ast::NodeId>,\n     external_exports: resolve::ExternalExports,\n@@ -303,7 +337,7 @@ impl<'self> PrivacyVisitor<'self> {\n                     ExternallyDenied\n                 }\n             };\n-        } else if self.exported_items.contains(&did.node) {\n+        } else if self.path_all_public_items.contains(&did.node) {\n             debug!(\"privacy - exported item {}\", self.nodestr(did.node));\n             return Allowable;\n         }\n@@ -842,6 +876,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                    last_private_map: resolve::LastPrivateMap,\n                    crate: &ast::Crate) -> ExportedItems {\n     let mut parents = HashMap::new();\n+    let mut path_all_public_items = HashSet::new();\n     let mut exported_items = HashSet::new();\n \n     // First, figure out who everyone's parent is\n@@ -855,14 +890,16 @@ pub fn check_crate(tcx: ty::ctxt,\n \n     // Next, build up the list of all exported items from this crate\n     {\n-        // Initialize the exported items with resolve's id for the \"root crate\"\n-        // to resolve references to `super` leading to the root and such.\n-        exported_items.insert(ast::CRATE_NODE_ID);\n         let mut visitor = EmbargoVisitor {\n+            tcx: tcx,\n+            path_all_public_items: &mut path_all_public_items,\n             exported_items: &mut exported_items,\n             exp_map2: exp_map2,\n             path_all_public: true, // start out as public\n         };\n+        // Initialize the exported items with resolve's id for the \"root crate\"\n+        // to resolve references to `super` leading to the root and such.\n+        visitor.add_path_all_public_item(ast::CRATE_NODE_ID);\n         visit::walk_crate(&mut visitor, crate, ());\n     }\n \n@@ -871,13 +908,14 @@ pub fn check_crate(tcx: ty::ctxt,\n         let mut visitor = PrivacyVisitor {\n             curitem: ast::DUMMY_NODE_ID,\n             tcx: tcx,\n-            exported_items: &exported_items,\n+            path_all_public_items: &path_all_public_items,\n             parents: &parents,\n             method_map: method_map,\n             external_exports: external_exports,\n             last_private_map: last_private_map,\n         };\n         visit::walk_crate(&mut visitor, crate, ());\n     }\n+\n     return exported_items;\n }"}, {"sha": "09b3e8163fd10dde26a0d176e821cbba7739fc84", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 33, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=1f7eb4f9aae43cb1177e2cf67a799a63b911ea78", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -18,7 +18,6 @@\n use middle::ty;\n use middle::typeck;\n use middle::privacy;\n-use middle::resolve;\n \n use std::hashmap::HashSet;\n use syntax::ast;\n@@ -105,8 +104,6 @@ struct ReachableContext {\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n     worklist: @mut ~[ast::NodeId],\n-    // Known reexports of modules\n-    exp_map2: resolve::ExportMap2,\n }\n \n struct MarkSymbolVisitor {\n@@ -173,14 +170,12 @@ impl Visitor<()> for MarkSymbolVisitor {\n \n impl ReachableContext {\n     // Creates a new reachability computation context.\n-    fn new(tcx: ty::ctxt, method_map: typeck::method_map,\n-           exp_map2: resolve::ExportMap2) -> ReachableContext {\n+    fn new(tcx: ty::ctxt, method_map: typeck::method_map) -> ReachableContext {\n         ReachableContext {\n             tcx: tcx,\n             method_map: method_map,\n             reachable_symbols: @mut HashSet::new(),\n             worklist: @mut ~[],\n-            exp_map2: exp_map2,\n         }\n     }\n \n@@ -255,19 +250,6 @@ impl ReachableContext {\n         }\n     }\n \n-    fn propagate_mod(&self, id: ast::NodeId) {\n-        match self.exp_map2.find(&id) {\n-            Some(l) => {\n-                for reexport in l.iter() {\n-                    if reexport.reexport && is_local(reexport.def_id) {\n-                        self.worklist.push(reexport.def_id.node);\n-                    }\n-                }\n-            }\n-            None => {}\n-        }\n-    }\n-\n     // Step 2: Mark all symbols that the symbols on the worklist touch.\n     fn propagate(&self) {\n         let mut visitor = self.init_visitor();\n@@ -292,13 +274,6 @@ impl ReachableContext {\n                             }\n                         }\n \n-                        // Our recursion into modules involves looking up their\n-                        // public reexports and the destinations of those\n-                        // exports. Privacy will put them in the worklist, but\n-                        // we won't find them in the ast_map, so this is where\n-                        // we deal with publicly re-exported items instead.\n-                        ast::item_mod(*) => self.propagate_mod(item.id),\n-\n                         // Implementations of exported structs/enums need to get\n                         // added to the worklist (as all their methods should be\n                         // accessible)\n@@ -339,7 +314,7 @@ impl ReachableContext {\n                         // inherently and their children are already in the\n                         // worklist\n                         ast::item_static(*) | ast::item_ty(*) |\n-                            ast::item_foreign_mod(*) => {}\n+                            ast::item_mod(*) | ast::item_foreign_mod(*) => {}\n \n                         _ => {\n                             self.tcx.sess.span_bug(item.span,\n@@ -376,9 +351,7 @@ impl ReachableContext {\n                                                worklist: {}\",\n                                                desc))\n                 }\n-                None if search_item == ast::CRATE_NODE_ID => {\n-                    self.propagate_mod(search_item);\n-                }\n+                None if search_item == ast::CRATE_NODE_ID => {}\n                 None => {\n                     self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n                                                {}\",\n@@ -404,10 +377,9 @@ impl ReachableContext {\n \n pub fn find_reachable(tcx: ty::ctxt,\n                       method_map: typeck::method_map,\n-                      exp_map2: resolve::ExportMap2,\n                       exported_items: &privacy::ExportedItems)\n                       -> @mut HashSet<ast::NodeId> {\n-    let reachable_context = ReachableContext::new(tcx, method_map, exp_map2);\n+    let reachable_context = ReachableContext::new(tcx, method_map);\n \n     // Step 1: Seed the worklist with all nodes which were found to be public as\n     //         a result of the privacy pass"}, {"sha": "c802d41bcee135a4b5b4226a37f305edf1916af8", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=1f7eb4f9aae43cb1177e2cf67a799a63b911ea78", "patch": "@@ -13,14 +13,13 @@ use rustc::{driver, middle};\n use rustc::middle::privacy;\n \n use syntax::ast;\n-use syntax::ast_util::is_local;\n use syntax::diagnostic;\n use syntax::parse;\n use syntax;\n \n use std::os;\n use std::local_data;\n-use std::hashmap::{HashMap,HashSet};\n+use std::hashmap::{HashSet};\n \n use visit_ast::RustdocVisitor;\n use clean;\n@@ -34,7 +33,6 @@ pub struct DocContext {\n \n pub struct CrateAnalysis {\n     exported_items: privacy::ExportedItems,\n-    reexports: HashMap<ast::NodeId, ~[ast::NodeId]>,\n }\n \n /// Parses, resolves, and typechecks the given crate\n@@ -73,20 +71,12 @@ fn get_ast_and_resolve(cpath: &Path,\n     let mut crate = phase_1_parse_input(sess, cfg.clone(), &input);\n     crate = phase_2_configure_and_expand(sess, cfg, crate);\n     let driver::driver::CrateAnalysis {\n-        exported_items, ty_cx, exp_map2, _\n+        exported_items, ty_cx, _\n     } = phase_3_run_analysis_passes(sess, &crate);\n \n-    let mut reexports = HashMap::new();\n-    for (&module, nodes) in exp_map2.iter() {\n-        reexports.insert(module, nodes.iter()\n-                                      .filter(|e| e.reexport && is_local(e.def_id))\n-                                      .map(|e| e.def_id.node)\n-                                      .to_owned_vec());\n-    }\n-\n     debug!(\"crate: {:?}\", crate);\n     return (DocContext { crate: crate, tycx: ty_cx, sess: sess },\n-            CrateAnalysis { reexports: reexports, exported_items: exported_items });\n+            CrateAnalysis { exported_items: exported_items });\n }\n \n pub fn run_core (libs: HashSet<Path>, path: &Path) -> (clean::Crate, CrateAnalysis) {"}, {"sha": "72e2b1d12a4b6116c9a55a39400fd91b3d89fa76", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=1f7eb4f9aae43cb1177e2cf67a799a63b911ea78", "patch": "@@ -16,7 +16,6 @@ use std::local_data;\n \n use syntax::ast;\n \n-use core;\n use clean;\n use clean::Item;\n use plugins;\n@@ -59,17 +58,7 @@ pub fn strip_private(crate: clean::Crate) -> plugins::PluginResult {\n     let mut retained = HashSet::new();\n     let crate = Cell::new(crate);\n     let exported_items = do local_data::get(super::analysiskey) |analysis| {\n-        let analysis = analysis.unwrap();\n-        let mut exported_items = analysis.exported_items.clone();\n-        {\n-            let mut finder = ExportedItemsFinder {\n-                exported_items: &mut exported_items,\n-                analysis: analysis,\n-            };\n-            let c = finder.fold_crate(crate.take());\n-            crate.put_back(c);\n-        }\n-        exported_items\n+        analysis.unwrap().exported_items.clone()\n     };\n     let mut crate = crate.take();\n \n@@ -90,32 +79,6 @@ pub fn strip_private(crate: clean::Crate) -> plugins::PluginResult {\n     (crate, None)\n }\n \n-struct ExportedItemsFinder<'self> {\n-    exported_items: &'self mut HashSet<ast::NodeId>,\n-    analysis: &'self core::CrateAnalysis,\n-}\n-\n-impl<'self> fold::DocFolder for ExportedItemsFinder<'self> {\n-    fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.inner {\n-            clean::ModuleItem(*) => {\n-                if self.analysis.exported_items.contains(&i.id) {\n-                    match self.analysis.reexports.find(&i.id) {\n-                        Some(l) => {\n-                            for &id in l.iter() {\n-                                self.exported_items.insert(id);\n-                            }\n-                        }\n-                        None => {}\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-        return self.fold_item_recur(i);\n-    }\n-}\n-\n struct Stripper<'self> {\n     retained: &'self mut HashSet<ast::NodeId>,\n     exported_items: &'self HashSet<ast::NodeId>,"}, {"sha": "a195bfb77177cf22fb53b08e45a4dcc5b8133d5d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1f7eb4f9aae43cb1177e2cf67a799a63b911ea78", "patch": "@@ -90,6 +90,7 @@ pub trait Visitor<E:Clone> {\n         walk_struct_def(self, s, i, g, n, e)\n     }\n     fn visit_struct_field(&mut self, s:@struct_field, e:E) { walk_struct_field(self, s, e) }\n+    fn visit_variant(&mut self, v:&variant, g:&Generics, e:E) { walk_variant(self, v, g, e) }\n     fn visit_opt_lifetime_ref(&mut self,\n                               _span: Span,\n                               opt_lifetime: &Option<Lifetime>,\n@@ -234,20 +235,27 @@ pub fn walk_enum_def<E:Clone, V:Visitor<E>>(visitor: &mut V,\n                                generics: &Generics,\n                                env: E) {\n     for variant in enum_definition.variants.iter() {\n-        match variant.node.kind {\n-            tuple_variant_kind(ref variant_arguments) => {\n-                for variant_argument in variant_arguments.iter() {\n-                    visitor.visit_ty(&variant_argument.ty, env.clone())\n-                }\n-            }\n-            struct_variant_kind(struct_definition) => {\n-                visitor.visit_struct_def(struct_definition,\n-                                         variant.node.name,\n-                                         generics,\n-                                         variant.node.id,\n-                                         env.clone())\n+        visitor.visit_variant(variant, generics, env.clone());\n+    }\n+}\n+\n+pub fn walk_variant<E:Clone, V:Visitor<E>>(visitor:&mut V,\n+                                           variant: &variant,\n+                                           generics: &Generics,\n+                                           env: E) {\n+    match variant.node.kind {\n+        tuple_variant_kind(ref variant_arguments) => {\n+            for variant_argument in variant_arguments.iter() {\n+                visitor.visit_ty(&variant_argument.ty, env.clone())\n             }\n         }\n+        struct_variant_kind(struct_definition) => {\n+            visitor.visit_struct_def(struct_definition,\n+                                     variant.node.name,\n+                                     generics,\n+                                     variant.node.id,\n+                                     env.clone())\n+        }\n     }\n }\n "}, {"sha": "c866462a3e9a62afe5a6012d0ae7744d3a332bcc", "filename": "src/test/compile-fail/lint-missing-doc.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7eb4f9aae43cb1177e2cf67a799a63b911ea78/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-missing-doc.rs?ref=1f7eb4f9aae43cb1177e2cf67a799a63b911ea78", "patch": "@@ -11,6 +11,7 @@\n // When denying at the crate level, be sure to not get random warnings from the\n // injected intrinsics by the compiler.\n #[feature(struct_variant)];\n+#[feature(globs)];\n #[deny(missing_doc)];\n \n struct Foo {\n@@ -39,16 +40,21 @@ fn foo3() {}\n #[allow(missing_doc)] pub fn foo4() {}\n \n /// dox\n-pub trait A {}\n-trait B {}\n-pub trait C {} //~ ERROR: missing documentation\n-#[allow(missing_doc)] pub trait D {}\n-\n-trait Bar {\n+pub trait A {\n+    /// dox\n     fn foo();\n-    fn foo_with_impl() {\n-    }\n+    /// dox\n+    fn foo_with_impl() {}\n }\n+trait B {\n+    fn foo();\n+    fn foo_with_impl() {}\n+}\n+pub trait C { //~ ERROR: missing documentation\n+    fn foo(); //~ ERROR: missing documentation\n+    fn foo_with_impl() {} //~ ERROR: missing documentation\n+}\n+#[allow(missing_doc)] pub trait D {}\n \n impl Foo {\n     pub fn foo() {} //~ ERROR: missing documentation\n@@ -120,4 +126,26 @@ pub enum PubBaz3 {\n #[doc(hidden)]\n pub fn baz() {}\n \n+mod internal_impl {\n+    /// dox\n+    pub fn documented() {}\n+    pub fn undocumented1() {} //~ ERROR: missing documentation\n+    pub fn undocumented2() {} //~ ERROR: missing documentation\n+    fn undocumented3() {}\n+    /// dox\n+    pub mod globbed {\n+        /// dox\n+        pub fn also_documented() {}\n+        pub fn also_undocumented1() {} //~ ERROR: missing documentation\n+        fn also_undocumented2() {}\n+    }\n+}\n+/// dox\n+pub mod public_interface {\n+    pub use foo = internal_impl::documented;\n+    pub use bar = internal_impl::undocumented1;\n+    pub use internal_impl::{documented, undocumented2};\n+    pub use internal_impl::globbed::*;\n+}\n+\n fn main() {}"}]}