{"sha": "f886520d2468507cc80ceb40a26594265052603e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ODY1MjBkMjQ2ODUwN2NjODBjZWI0MGEyNjU5NDI2NTA1MjYwM2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-21T23:01:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-21T23:01:59Z"}, "message": "auto merge of #7219 : sstewartgallus/rust/cleanup, r=graydon", "tree": {"sha": "5500ec0416cc1e739ad651ce184079ef409ac166", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5500ec0416cc1e739ad651ce184079ef409ac166"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f886520d2468507cc80ceb40a26594265052603e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f886520d2468507cc80ceb40a26594265052603e", "html_url": "https://github.com/rust-lang/rust/commit/f886520d2468507cc80ceb40a26594265052603e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f886520d2468507cc80ceb40a26594265052603e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "544f6159f730467e768143b974729bcc340c7dad", "url": "https://api.github.com/repos/rust-lang/rust/commits/544f6159f730467e768143b974729bcc340c7dad", "html_url": "https://github.com/rust-lang/rust/commit/544f6159f730467e768143b974729bcc340c7dad"}, {"sha": "b8efa2ebe02eb59c6d493b3c428f40804011d413", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8efa2ebe02eb59c6d493b3c428f40804011d413", "html_url": "https://github.com/rust-lang/rust/commit/b8efa2ebe02eb59c6d493b3c428f40804011d413"}], "stats": {"total": 158, "additions": 73, "deletions": 85}, "files": [{"sha": "5df63d650e9041ff610b56e1147c166bcedbf0b4", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 67, "deletions": 76, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/f886520d2468507cc80ceb40a26594265052603e/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f886520d2468507cc80ceb40a26594265052603e/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=f886520d2468507cc80ceb40a26594265052603e", "patch": "@@ -129,14 +129,12 @@ pub mod jit {\n \n                 debug!(\"linking: %s\", path);\n \n-                let _: () = str::as_c_str(\n-                    path,\n-                    |buf_t| {\n-                        if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n-                            llvm_err(sess, ~\"Could not link\");\n-                        }\n-                        debug!(\"linked: %s\", path);\n-                    });\n+                do str::as_c_str(path) |buf_t| {\n+                    if !llvm::LLVMRustLoadCrate(manager, buf_t) {\n+                        llvm_err(sess, ~\"Could not link\");\n+                    }\n+                    debug!(\"linked: %s\", path);\n+                }\n             }\n \n             // We custom-build a JIT execution engine via some rust wrappers\n@@ -203,11 +201,10 @@ pub mod write {\n     use core::str;\n \n     pub fn is_object_or_assembly_or_exe(ot: output_type) -> bool {\n-        if ot == output_type_assembly || ot == output_type_object ||\n-               ot == output_type_exe {\n-            return true;\n+        match ot {\n+            output_type_assembly | output_type_object | output_type_exe => true,\n+            _ => false\n         }\n-        return false;\n     }\n \n     pub fn run_passes(sess: Session,\n@@ -290,11 +287,11 @@ pub mod write {\n                   session::Aggressive => LLVMOptAggressive\n                 };\n \n-                let FileType;\n-                if output_type == output_type_object ||\n-                       output_type == output_type_exe {\n-                   FileType = lib::llvm::ObjectFile;\n-                } else { FileType = lib::llvm::AssemblyFile; }\n+                let FileType = match output_type {\n+                    output_type_object | output_type_exe => lib::llvm::ObjectFile,\n+                    _ => lib::llvm::AssemblyFile\n+                };\n+\n                 // Write optimized bitcode if --save-temps was on.\n \n                 if opts.save_temps {\n@@ -384,11 +381,11 @@ pub mod write {\n                             (--android-cross-path)\")\n             }\n         };\n-        let mut cc_args = ~[];\n-        cc_args.push(~\"-c\");\n-        cc_args.push(~\"-o\");\n-        cc_args.push(object.to_str());\n-        cc_args.push(assembly.to_str());\n+\n+        let cc_args = ~[\n+            ~\"-c\",\n+            ~\"-o\", object.to_str(),\n+            assembly.to_str()];\n \n         let prog = run::process_output(cc_prog, cc_args);\n \n@@ -474,19 +471,19 @@ pub fn build_link_meta(sess: Session,\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each |meta| {\n-            if \"name\" == attr::get_meta_item_name(*meta) {\n-                match attr::get_meta_item_value_str(*meta) {\n-                  // Changing attr would avoid the need for the copy\n-                  // here\n-                  Some(v) => { name = Some(v); }\n-                  None => cmh_items.push(*meta)\n-                }\n-            } else if \"vers\" == attr::get_meta_item_name(*meta) {\n-                match attr::get_meta_item_value_str(*meta) {\n-                  Some(v) => { vers = Some(v); }\n-                  None => cmh_items.push(*meta)\n-                }\n-            } else { cmh_items.push(*meta); }\n+            match attr::get_meta_item_value_str(*meta) {\n+                Some(value) => {\n+                    let item_name : &str = attr::get_meta_item_name(*meta);\n+                    match item_name {\n+                        // Changing attr would avoid the need for the copy\n+                        // here\n+                        \"name\" => name = Some(value),\n+                        \"vers\" => vers = Some(value),\n+                        _ => cmh_items.push(*meta)\n+                    }\n+                },\n+                None => cmh_items.push(*meta)\n+            }\n         }\n \n         ProvidedMetas {\n@@ -548,32 +545,32 @@ pub fn build_link_meta(sess: Session,\n     }\n \n     fn crate_meta_name(sess: Session, output: &Path, opt_name: Option<@str>)\n-                    -> @str {\n-        return match opt_name {\n-              Some(v) => v,\n-              None => {\n+        -> @str {\n+        match opt_name {\n+            Some(v) => v,\n+            None => {\n                 // to_managed could go away if there was a version of\n                 // filestem that returned an @str\n                 let name = session::expect(sess,\n-                                  output.filestem(),\n-                                  || fmt!(\"output file name `%s` doesn't\\\n-                                           appear to have a stem\",\n-                                          output.to_str())).to_managed();\n+                                           output.filestem(),\n+                                           || fmt!(\"output file name `%s` doesn't\\\n+                                                    appear to have a stem\",\n+                                                   output.to_str())).to_managed();\n                 warn_missing(sess, \"name\", name);\n                 name\n-              }\n-            };\n+            }\n+        }\n     }\n \n     fn crate_meta_vers(sess: Session, opt_vers: Option<@str>) -> @str {\n-        return match opt_vers {\n-              Some(v) => v,\n-              None => {\n+        match opt_vers {\n+            Some(v) => v,\n+            None => {\n                 let vers = @\"0.0\";\n                 warn_missing(sess, \"vers\", vers);\n                 vers\n-              }\n-            };\n+            }\n+        }\n     }\n \n     let ProvidedMetas {\n@@ -699,10 +696,10 @@ pub fn exported_name(sess: Session,\n                      path: path,\n                      hash: &str,\n                      vers: &str) -> ~str {\n-    return mangle(sess,\n-            vec::append_one(\n-            vec::append_one(path, path_name(sess.ident_of(hash))),\n-            path_name(sess.ident_of(vers))));\n+    mangle(sess,\n+           vec::append_one(\n+               vec::append_one(path, path_name(sess.ident_of(hash))),\n+               path_name(sess.ident_of(vers))))\n }\n \n pub fn mangle_exported_name(ccx: &mut CrateContext,\n@@ -739,16 +736,16 @@ pub fn mangle_internal_name_by_type_and_seq(ccx: &mut CrateContext,\n pub fn mangle_internal_name_by_path_and_seq(ccx: &mut CrateContext,\n                                             path: path,\n                                             flav: &str) -> ~str {\n-    return mangle(ccx.sess,\n-                  vec::append_one(path, path_name((ccx.names)(flav))));\n+    mangle(ccx.sess,\n+           vec::append_one(path, path_name((ccx.names)(flav))))\n }\n \n pub fn mangle_internal_name_by_path(ccx: &mut CrateContext, path: path) -> ~str {\n-    return mangle(ccx.sess, path);\n+    mangle(ccx.sess, path)\n }\n \n pub fn mangle_internal_name_by_seq(ccx: &mut CrateContext, flav: &str) -> ~str {\n-    return fmt!(\"%s_%u\", flav, (ccx.names)(flav).name);\n+    fmt!(\"%s_%u\", flav, (ccx.names)(flav).name)\n }\n \n \n@@ -776,8 +773,8 @@ pub fn link_binary(sess: Session,\n     // so we add a condition to make it use gcc.\n     let cc_prog: ~str = match sess.opts.linker {\n         Some(ref linker) => copy *linker,\n-        None => {\n-            if sess.targ_cfg.os == session::os_android {\n+        None => match sess.targ_cfg.os {\n+            session::os_android =>\n                 match &sess.opts.android_cross_path {\n                     &Some(ref path) => {\n                         fmt!(\"%s/bin/arm-linux-androideabi-gcc\", *path)\n@@ -786,12 +783,9 @@ pub fn link_binary(sess: Session,\n                         sess.fatal(\"need Android NDK path for linking \\\n                                     (--android-cross-path)\")\n                     }\n-                }\n-            } else if sess.targ_cfg.os == session::os_win32 {\n-                ~\"gcc\"\n-            } else {\n-                ~\"cc\"\n-            }\n+                },\n+            session::os_win32 => ~\"gcc\",\n+            _ => ~\"cc\"\n         }\n     };\n     // The invocations of cc share some flags across platforms\n@@ -866,17 +860,14 @@ pub fn link_args(sess: Session,\n \n     let mut args = vec::append(~[stage], sess.targ_cfg.target_strs.cc_args);\n \n-    args.push(~\"-o\");\n-    args.push(output.to_str());\n-    args.push(obj_filename.to_str());\n+    args.push_all([\n+        ~\"-o\", output.to_str(),\n+        obj_filename.to_str()]);\n \n-    let lib_cmd;\n-    let os = sess.targ_cfg.os;\n-    if os == session::os_macos {\n-        lib_cmd = ~\"-dynamiclib\";\n-    } else {\n-        lib_cmd = ~\"-shared\";\n-    }\n+    let lib_cmd = match sess.targ_cfg.os {\n+        session::os_macos => ~\"-dynamiclib\",\n+        _ => ~\"-shared\"\n+    };\n \n     // # Crate linking\n "}, {"sha": "bf88b88b058102236eb175d028b7b68f92748007", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f886520d2468507cc80ceb40a26594265052603e/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f886520d2468507cc80ceb40a26594265052603e/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=f886520d2468507cc80ceb40a26594265052603e", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -21,10 +21,7 @@ use core::util;\n use core::vec;\n \n fn not_win32(os: session::os) -> bool {\n-  match os {\n-      session::os_win32 => false,\n-      _ => true\n-  }\n+  os != session::os_win32\n }\n \n pub fn get_rpath_flags(sess: session::Session, out_filename: &Path)\n@@ -122,7 +119,7 @@ pub fn get_rpath_relative_to_output(os: session::os,\n \n     // Mac doesn't appear to support $ORIGIN\n     let prefix = match os {\n-        session::os_android |session::os_linux | session::os_freebsd\n+        session::os_android | session::os_linux | session::os_freebsd\n                           => \"$ORIGIN\",\n         session::os_macos => \"@executable_path\",\n         session::os_win32 => util::unreachable()\n@@ -159,10 +156,10 @@ pub fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n \n     path.push_all(vec::slice(split2, start_idx, len2 - 1));\n \n-    if !path.is_empty() {\n-        return Path(\"\").push_many(path);\n+    return if !path.is_empty() {\n+        Path(\"\").push_many(path)\n     } else {\n-        return Path(\".\");\n+        Path(\".\")\n     }\n }\n "}]}