{"sha": "c62d65cfbfbcac57b46fd650cb8b367094857be6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MmQ2NWNmYmZiY2FjNTdiNDZmZDY1MGNiOGIzNjcwOTQ4NTdiZTY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-14T09:57:49Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-14T09:57:49Z"}, "message": "Rollup merge of #33574 - michaelwoerister:collector-cleanup, r=nikomatsakis\n\ntrans-collector: Assorted fixes and refactorings needed for making trans collector-driven.\n\nAs the title says. The messages on the individual commits should do a good job of explaining what they are about.\n\nr? @nikomatsakis", "tree": {"sha": "5501fadba6788321227d52a1d2f94d3ca13fb6fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5501fadba6788321227d52a1d2f94d3ca13fb6fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c62d65cfbfbcac57b46fd650cb8b367094857be6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c62d65cfbfbcac57b46fd650cb8b367094857be6", "html_url": "https://github.com/rust-lang/rust/commit/c62d65cfbfbcac57b46fd650cb8b367094857be6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c62d65cfbfbcac57b46fd650cb8b367094857be6/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8845592514ea229a09dd152d2801363046749fb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8845592514ea229a09dd152d2801363046749fb3", "html_url": "https://github.com/rust-lang/rust/commit/8845592514ea229a09dd152d2801363046749fb3"}, {"sha": "802bb578e40111d08726bd5930b90f8873c94257", "url": "https://api.github.com/repos/rust-lang/rust/commits/802bb578e40111d08726bd5930b90f8873c94257", "html_url": "https://github.com/rust-lang/rust/commit/802bb578e40111d08726bd5930b90f8873c94257"}], "stats": {"total": 1159, "additions": 634, "deletions": 525}, "files": [{"sha": "65c3aa12ba6c895b61b09213ed4a9bb6d124f215", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -59,7 +59,7 @@ use callee::{Callee, CallArgs, ArgExprs, ArgVals};\n use cleanup::{self, CleanupMethods, DropHint};\n use closure;\n use common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n-use collector::{self, TransItem, TransItemState, TransItemCollectionMode};\n+use collector::{self, TransItemState, TransItemCollectionMode};\n use common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use common::{CrateContext, DropFlagHintsMap, Field, FunctionContext};\n use common::{Result, NodeIdAndSpan, VariantInfo};\n@@ -80,8 +80,9 @@ use machine::{llalign_of_min, llsize_of, llsize_of_real};\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n-use partitioning::{self, PartitioningStrategy, InstantiationMode, CodegenUnit};\n+use partitioning::{self, PartitioningStrategy, CodegenUnit};\n use symbol_names_test;\n+use trans_item::TransItem;\n use tvec;\n use type_::Type;\n use type_of;\n@@ -2941,8 +2942,8 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         None => TransItemCollectionMode::Lazy\n     };\n \n-    let (items, reference_map) = time(time_passes, \"translation item collection\", || {\n-        collector::collect_crate_translation_items(scx, collection_mode)\n+    let (items, inlining_map) = time(time_passes, \"translation item collection\", || {\n+        collector::collect_crate_translation_items(&scx, collection_mode)\n     });\n \n     let strategy = if scx.sess().opts.debugging_opts.incremental.is_some() {\n@@ -2955,7 +2956,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         partitioning::partition(scx.tcx(),\n                                 items.iter().cloned(),\n                                 strategy,\n-                                &reference_map)\n+                                &inlining_map)\n     });\n \n     if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n@@ -2983,18 +2984,17 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n                     output.push_str(&cgu_name[..]);\n \n                     let linkage_abbrev = match linkage {\n-                        InstantiationMode::Def(llvm::ExternalLinkage) => \"External\",\n-                        InstantiationMode::Def(llvm::AvailableExternallyLinkage) => \"Available\",\n-                        InstantiationMode::Def(llvm::LinkOnceAnyLinkage) => \"OnceAny\",\n-                        InstantiationMode::Def(llvm::LinkOnceODRLinkage) => \"OnceODR\",\n-                        InstantiationMode::Def(llvm::WeakAnyLinkage) => \"WeakAny\",\n-                        InstantiationMode::Def(llvm::WeakODRLinkage) => \"WeakODR\",\n-                        InstantiationMode::Def(llvm::AppendingLinkage) => \"Appending\",\n-                        InstantiationMode::Def(llvm::InternalLinkage) => \"Internal\",\n-                        InstantiationMode::Def(llvm::PrivateLinkage) => \"Private\",\n-                        InstantiationMode::Def(llvm::ExternalWeakLinkage) => \"ExternalWeak\",\n-                        InstantiationMode::Def(llvm::CommonLinkage) => \"Common\",\n-                        InstantiationMode::Decl => \"Declaration\",\n+                        llvm::ExternalLinkage => \"External\",\n+                        llvm::AvailableExternallyLinkage => \"Available\",\n+                        llvm::LinkOnceAnyLinkage => \"OnceAny\",\n+                        llvm::LinkOnceODRLinkage => \"OnceODR\",\n+                        llvm::WeakAnyLinkage => \"WeakAny\",\n+                        llvm::WeakODRLinkage => \"WeakODR\",\n+                        llvm::AppendingLinkage => \"Appending\",\n+                        llvm::InternalLinkage => \"Internal\",\n+                        llvm::PrivateLinkage => \"Private\",\n+                        llvm::ExternalWeakLinkage => \"ExternalWeak\",\n+                        llvm::CommonLinkage => \"Common\",\n                     };\n \n                     output.push_str(\"[\");"}, {"sha": "b56027447a094271b42267199b2f2d4c7c37dc13", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -494,7 +494,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => bug!(\"expected fn item type, found {}\", ty)\n     };\n \n-    let instance = Instance::mono(ccx.tcx(), def_id);\n+    let instance = Instance::mono(ccx.shared(), def_id);\n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n         return immediate_rvalue(llfn, fn_ptr_ty);\n     }"}, {"sha": "d278c3c8320fdc243b383b2d36fd43dfd6b96242", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 111, "deletions": 423, "changes": 534, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -188,8 +188,6 @@\n //! this is not implemented however: a translation item will be produced\n //! regardless of whether it is actually needed or not.\n \n-use rustc_data_structures::bitvec::BitVector;\n-\n use rustc::hir;\n use rustc::hir::intravisit as hir_visit;\n \n@@ -198,99 +196,60 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::{ExchangeFreeFnLangItem, ExchangeMallocFnLangItem};\n use rustc::traits;\n use rustc::ty::subst::{self, Substs, Subst};\n-use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n+use rustc::ty::{self, TypeFoldable, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::repr as mir;\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n \n-use syntax::ast::{self, NodeId};\n+use syntax::abi::Abi;\n use syntax::codemap::DUMMY_SP;\n-use syntax::{attr, errors};\n-use syntax::parse::token;\n-\n-use base::{custom_coerce_unsize_info, llvm_linkage_by_name};\n+use syntax::errors;\n+use base::custom_coerce_unsize_info;\n use context::SharedCrateContext;\n use common::{fulfill_obligation, normalize_and_test_predicates, type_is_sized};\n use glue::{self, DropGlueKind};\n-use llvm;\n use meth;\n use monomorphize::{self, Instance};\n use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n \n-use std::hash::{Hash, Hasher};\n+use trans_item::{TransItem, type_to_string, def_id_to_string};\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n     Eager,\n     Lazy\n }\n \n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub enum TransItem<'tcx> {\n-    DropGlue(DropGlueKind<'tcx>),\n-    Fn(Instance<'tcx>),\n-    Static(NodeId)\n-}\n-\n-impl<'tcx> Hash for TransItem<'tcx> {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        match *self {\n-            TransItem::DropGlue(t) => {\n-                0u8.hash(s);\n-                t.hash(s);\n-            },\n-            TransItem::Fn(instance) => {\n-                1u8.hash(s);\n-                instance.def.hash(s);\n-                (instance.substs as *const _ as usize).hash(s);\n-            }\n-            TransItem::Static(node_id) => {\n-                2u8.hash(s);\n-                node_id.hash(s);\n-            }\n-        };\n-    }\n-}\n-\n /// Maps every translation item to all translation items it references in its\n /// body.\n-pub struct ReferenceMap<'tcx> {\n-    // Maps a source translation item to a range of target translation items.\n+pub struct InliningMap<'tcx> {\n+    // Maps a source translation item to a range of target translation items\n+    // that are potentially inlined by LLVM into the source.\n     // The two numbers in the tuple are the start (inclusive) and\n-    // end index (exclusive) within the `targets` and the `inlined` vecs.\n+    // end index (exclusive) within the `targets` vecs.\n     index: FnvHashMap<TransItem<'tcx>, (usize, usize)>,\n     targets: Vec<TransItem<'tcx>>,\n-    inlined: BitVector\n }\n \n-impl<'tcx> ReferenceMap<'tcx> {\n+impl<'tcx> InliningMap<'tcx> {\n \n-    fn new() -> ReferenceMap<'tcx> {\n-        ReferenceMap {\n+    fn new() -> InliningMap<'tcx> {\n+        InliningMap {\n             index: FnvHashMap(),\n             targets: Vec::new(),\n-            inlined: BitVector::new(64 * 256),\n         }\n     }\n \n-    fn record_references<I>(&mut self, source: TransItem<'tcx>, targets: I)\n-        where I: Iterator<Item=(TransItem<'tcx>, bool)>\n+    fn record_inlining_canditates<I>(&mut self,\n+                                     source: TransItem<'tcx>,\n+                                     targets: I)\n+        where I: Iterator<Item=TransItem<'tcx>>\n     {\n         assert!(!self.index.contains_key(&source));\n \n         let start_index = self.targets.len();\n-\n-        for (target, inlined) in targets {\n-            let index = self.targets.len();\n-            self.targets.push(target);\n-            self.inlined.grow(index + 1);\n-\n-            if inlined {\n-                self.inlined.insert(index);\n-            }\n-        }\n-\n+        self.targets.extend(targets);\n         let end_index = self.targets.len();\n         self.index.insert(source, (start_index, end_index));\n     }\n@@ -301,28 +260,17 @@ impl<'tcx> ReferenceMap<'tcx> {\n         where F: FnMut(TransItem<'tcx>) {\n         if let Some(&(start_index, end_index)) = self.index.get(&source)\n         {\n-            for index in start_index .. end_index {\n-                if self.inlined.contains(index) {\n-                    f(self.targets[index])\n-                }\n+            for candidate in &self.targets[start_index .. end_index] {\n+                f(*candidate)\n             }\n         }\n     }\n-\n-    pub fn get_direct_references_from(&self, source: TransItem<'tcx>) -> &[TransItem<'tcx>]\n-    {\n-        if let Some(&(start_index, end_index)) = self.index.get(&source) {\n-            &self.targets[start_index .. end_index]\n-        } else {\n-            &self.targets[0 .. 0]\n-        }\n-    }\n }\n \n pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n                                                  -> (FnvHashSet<TransItem<'tcx>>,\n-                                                     ReferenceMap<'tcx>) {\n+                                                     InliningMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n     scx.tcx().dep_graph.with_ignore(|| {\n@@ -331,17 +279,17 @@ pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FnvHashSet();\n         let mut recursion_depths = DefIdMap();\n-        let mut reference_map = ReferenceMap::new();\n+        let mut inlining_map = InliningMap::new();\n \n         for root in roots {\n             collect_items_rec(scx,\n                               root,\n                               &mut visited,\n                               &mut recursion_depths,\n-                              &mut reference_map);\n+                              &mut inlining_map);\n         }\n \n-        (visited, reference_map)\n+        (visited, inlining_map)\n     })\n }\n \n@@ -372,7 +320,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n                                    visited: &mut FnvHashSet<TransItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n-                                   reference_map: &mut ReferenceMap<'tcx>) {\n+                                   inlining_map: &mut InliningMap<'tcx>) {\n     if !visited.insert(starting_point.clone()) {\n         // We've been here already, no need to search again.\n         return;\n@@ -392,7 +340,26 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n             let ty = scx.tcx().lookup_item_type(def_id).ty;\n             let ty = glue::get_drop_glue_type(scx.tcx(), ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n+\n             recursion_depth_reset = None;\n+\n+            // Scan the MIR in order to find function calls, closures, and\n+            // drop-glue\n+            let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(def_id),\n+                || format!(\"Could not find MIR for static: {:?}\", def_id));\n+\n+            let empty_substs = scx.empty_substs_for_def_id(def_id);\n+            let mut visitor = MirNeighborCollector {\n+                scx: scx,\n+                mir: &mir,\n+                output: &mut neighbors,\n+                param_substs: empty_substs\n+            };\n+\n+            visitor.visit_mir(&mir);\n+            for promoted in &mir.promoted {\n+                visitor.visit_mir(promoted);\n+            }\n         }\n         TransItem::Fn(instance) => {\n             // Keep track of the monomorphization recursion depth\n@@ -419,10 +386,10 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n     }\n \n-    record_references(scx.tcx(), starting_point, &neighbors[..], reference_map);\n+    record_inlining_canditates(scx.tcx(), starting_point, &neighbors[..], inlining_map);\n \n     for neighbour in neighbors {\n-        collect_items_rec(scx, neighbour, visited, recursion_depths, reference_map);\n+        collect_items_rec(scx, neighbour, visited, recursion_depths, inlining_map);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n@@ -432,17 +399,19 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n }\n \n-fn record_references<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               caller: TransItem<'tcx>,\n-                               callees: &[TransItem<'tcx>],\n-                               reference_map: &mut ReferenceMap<'tcx>) {\n-    let iter = callees.into_iter()\n-                      .map(|callee| {\n-                        let is_inlining_candidate = callee.is_from_extern_crate() ||\n-                                                    callee.requests_inline(tcx);\n-                        (*callee, is_inlining_candidate)\n-                      });\n-    reference_map.record_references(caller, iter);\n+fn record_inlining_canditates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        caller: TransItem<'tcx>,\n+                                        callees: &[TransItem<'tcx>],\n+                                        inlining_map: &mut InliningMap<'tcx>) {\n+    let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n+        trans_item.is_from_extern_crate() || trans_item.requests_inline(tcx)\n+    };\n+\n+    let inlining_candidates = callees.into_iter()\n+                                     .map(|x| *x)\n+                                     .filter(is_inlining_candidate);\n+\n+    inlining_map.record_inlining_canditates(caller, inlining_candidates);\n }\n \n fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -527,10 +496,11 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                         .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n \n                 assert!(can_have_local_instance(self.scx.tcx(), exchange_malloc_fn_def_id));\n+                let empty_substs = self.scx.empty_substs_for_def_id(exchange_malloc_fn_def_id);\n                 let exchange_malloc_fn_trans_item =\n                     create_fn_trans_item(self.scx.tcx(),\n                                          exchange_malloc_fn_def_id,\n-                                         self.scx.tcx().mk_substs(Substs::empty()),\n+                                         empty_substs,\n                                          self.param_substs);\n \n                 self.output.push(exchange_malloc_fn_trans_item);\n@@ -633,6 +603,49 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             can_have_local_instance(tcx, def_id)\n         }\n     }\n+\n+    // This takes care of the \"drop_in_place\" intrinsic for which we otherwise\n+    // we would not register drop-glues.\n+    fn visit_terminator_kind(&mut self,\n+                             block: mir::BasicBlock,\n+                             kind: &mir::TerminatorKind<'tcx>) {\n+        let tcx = self.scx.tcx();\n+        match *kind {\n+            mir::TerminatorKind::Call {\n+                func: mir::Operand::Constant(ref constant),\n+                ref args,\n+                ..\n+            } => {\n+                match constant.ty.sty {\n+                    ty::TyFnDef(def_id, _, bare_fn_ty)\n+                        if is_drop_in_place_intrinsic(tcx, def_id, bare_fn_ty) => {\n+                        let operand_ty = self.mir.operand_ty(tcx, &args[0]);\n+                        if let ty::TyRawPtr(mt) = operand_ty.sty {\n+                            let operand_ty = monomorphize::apply_param_substs(tcx,\n+                                                                              self.param_substs,\n+                                                                              &mt.ty);\n+                            self.output.push(TransItem::DropGlue(DropGlueKind::Ty(operand_ty)));\n+                        } else {\n+                            bug!(\"Has the drop_in_place() intrinsic's signature changed?\")\n+                        }\n+                    }\n+                    _ => { /* Nothing to do. */ }\n+                }\n+            }\n+            _ => { /* Nothing to do. */ }\n+        }\n+\n+        self.super_terminator_kind(block, kind);\n+\n+        fn is_drop_in_place_intrinsic<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                def_id: DefId,\n+                                                bare_fn_ty: &ty::BareFnTy<'tcx>)\n+                                                -> bool {\n+            (bare_fn_ty.abi == Abi::RustIntrinsic ||\n+             bare_fn_ty.abi == Abi::PlatformIntrinsic) &&\n+            tcx.item_name(def_id).as_str() == \"drop_in_place\"\n+        }\n+    }\n }\n \n fn can_have_local_instance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -667,10 +680,11 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                          .unwrap_or_else(|e| scx.sess().fatal(&e));\n \n         assert!(can_have_local_instance(scx.tcx(), exchange_free_fn_def_id));\n+        let fn_substs = scx.empty_substs_for_def_id(exchange_free_fn_def_id);\n         let exchange_free_fn_trans_item =\n             create_fn_trans_item(scx.tcx(),\n                                  exchange_free_fn_def_id,\n-                                 scx.tcx().mk_substs(Substs::empty()),\n+                                 fn_substs,\n                                  scx.tcx().mk_substs(Substs::empty()));\n \n         output.push(exchange_free_fn_trans_item);\n@@ -730,7 +744,6 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         ty::TyRef(..)   |\n         ty::TyFnDef(..) |\n         ty::TyFnPtr(_)  |\n-        ty::TySlice(_)  |\n         ty::TyTrait(_)  => {\n             /* nothing to do */\n         }\n@@ -756,6 +769,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             }\n         }\n         ty::TyBox(inner_type)      |\n+        ty::TySlice(inner_type)    |\n         ty::TyArray(inner_type, _) => {\n             let inner_type = glue::get_drop_glue_type(scx.tcx(), inner_type);\n             if glue::type_needs_drop(scx.tcx(), inner_type) {\n@@ -777,6 +791,8 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             bug!(\"encountered unexpected type\");\n         }\n     }\n+\n+\n }\n \n fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n@@ -1097,7 +1113,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                     debug!(\"RootCollector: ItemFn({})\",\n                            def_id_to_string(self.scx.tcx(), def_id));\n \n-                    let instance = Instance::mono(self.scx.tcx(), def_id);\n+                    let instance = Instance::mono(self.scx, def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -1134,7 +1150,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                     debug!(\"RootCollector: MethodImplItem({})\",\n                            def_id_to_string(self.scx.tcx(), def_id));\n \n-                    let instance = Instance::mono(self.scx.tcx(), def_id);\n+                    let instance = Instance::mono(self.scx, def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -1210,334 +1226,6 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-//=-----------------------------------------------------------------------------\n-// TransItem String Keys\n-//=-----------------------------------------------------------------------------\n-\n-// The code below allows for producing a unique string key for a trans item.\n-// These keys are used by the handwritten auto-tests, so they need to be\n-// predictable and human-readable.\n-//\n-// Note: A lot of this could looks very similar to what's already in the\n-//       ppaux module. It would be good to refactor things so we only have one\n-//       parameterizable implementation for printing types.\n-\n-/// Same as `unique_type_name()` but with the result pushed onto the given\n-/// `output` parameter.\n-pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       t: ty::Ty<'tcx>,\n-                                       output: &mut String) {\n-    match t.sty {\n-        ty::TyBool              => output.push_str(\"bool\"),\n-        ty::TyChar              => output.push_str(\"char\"),\n-        ty::TyStr               => output.push_str(\"str\"),\n-        ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n-        ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n-        ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n-        ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n-        ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n-        ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n-        ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n-        ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n-        ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n-        ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n-        ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n-        ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n-        ty::TyStruct(adt_def, substs) |\n-        ty::TyEnum(adt_def, substs) => {\n-            push_item_name(tcx, adt_def.did, output);\n-            push_type_params(tcx, &substs.types, &[], output);\n-        },\n-        ty::TyTuple(component_types) => {\n-            output.push('(');\n-            for &component_type in component_types {\n-                push_unique_type_name(tcx, component_type, output);\n-                output.push_str(\", \");\n-            }\n-            if !component_types.is_empty() {\n-                output.pop();\n-                output.pop();\n-            }\n-            output.push(')');\n-        },\n-        ty::TyBox(inner_type) => {\n-            output.push_str(\"Box<\");\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push('>');\n-        },\n-        ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n-            output.push('*');\n-            match mutbl {\n-                hir::MutImmutable => output.push_str(\"const \"),\n-                hir::MutMutable => output.push_str(\"mut \"),\n-            }\n-\n-            push_unique_type_name(tcx, inner_type, output);\n-        },\n-        ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n-            output.push('&');\n-            if mutbl == hir::MutMutable {\n-                output.push_str(\"mut \");\n-            }\n-\n-            push_unique_type_name(tcx, inner_type, output);\n-        },\n-        ty::TyArray(inner_type, len) => {\n-            output.push('[');\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push_str(&format!(\"; {}\", len));\n-            output.push(']');\n-        },\n-        ty::TySlice(inner_type) => {\n-            output.push('[');\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push(']');\n-        },\n-        ty::TyTrait(ref trait_data) => {\n-            push_item_name(tcx, trait_data.principal.skip_binder().def_id, output);\n-            push_type_params(tcx,\n-                             &trait_data.principal.skip_binder().substs.types,\n-                             &trait_data.bounds.projection_bounds,\n-                             output);\n-        },\n-        ty::TyFnDef(_, _, &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n-        ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n-            if unsafety == hir::Unsafety::Unsafe {\n-                output.push_str(\"unsafe \");\n-            }\n-\n-            if abi != ::abi::Abi::Rust {\n-                output.push_str(\"extern \\\"\");\n-                output.push_str(abi.name());\n-                output.push_str(\"\\\" \");\n-            }\n-\n-            output.push_str(\"fn(\");\n-\n-            let sig = tcx.erase_late_bound_regions(sig);\n-            if !sig.inputs.is_empty() {\n-                for &parameter_type in &sig.inputs {\n-                    push_unique_type_name(tcx, parameter_type, output);\n-                    output.push_str(\", \");\n-                }\n-                output.pop();\n-                output.pop();\n-            }\n-\n-            if sig.variadic {\n-                if !sig.inputs.is_empty() {\n-                    output.push_str(\", ...\");\n-                } else {\n-                    output.push_str(\"...\");\n-                }\n-            }\n-\n-            output.push(')');\n-\n-            match sig.output {\n-                ty::FnConverging(result_type) if result_type.is_nil() => {}\n-                ty::FnConverging(result_type) => {\n-                    output.push_str(\" -> \");\n-                    push_unique_type_name(tcx, result_type, output);\n-                }\n-                ty::FnDiverging => {\n-                    output.push_str(\" -> !\");\n-                }\n-            }\n-        },\n-        ty::TyClosure(def_id, ref closure_substs) => {\n-            push_item_name(tcx, def_id, output);\n-            output.push_str(\"{\");\n-            output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n-            output.push_str(\"}\");\n-            push_type_params(tcx, &closure_substs.func_substs.types, &[], output);\n-        }\n-        ty::TyError |\n-        ty::TyInfer(_) |\n-        ty::TyProjection(..) |\n-        ty::TyParam(_) => {\n-            bug!(\"debuginfo: Trying to create type name for \\\n-                  unexpected type: {:?}\", t);\n-        }\n-    }\n-}\n-\n-fn push_item_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            def_id: DefId,\n-                            output: &mut String) {\n-    let def_path = tcx.def_path(def_id);\n-\n-    // some_crate::\n-    output.push_str(&tcx.crate_name(def_path.krate));\n-    output.push_str(\"::\");\n-\n-    // foo::bar::ItemName::\n-    for part in tcx.def_path(def_id).data {\n-        output.push_str(&format!(\"{}[{}]::\",\n-                        part.data.as_interned_str(),\n-                        part.disambiguator));\n-    }\n-\n-    // remove final \"::\"\n-    output.pop();\n-    output.pop();\n-}\n-\n-fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n-                              projections: &[ty::PolyProjectionPredicate<'tcx>],\n-                              output: &mut String) {\n-    if types.is_empty() && projections.is_empty() {\n-        return;\n-    }\n-\n-    output.push('<');\n-\n-    for &type_parameter in types {\n-        push_unique_type_name(tcx, type_parameter, output);\n-        output.push_str(\", \");\n-    }\n-\n-    for projection in projections {\n-        let projection = projection.skip_binder();\n-        let name = token::get_ident_interner().get(projection.projection_ty.item_name);\n-        output.push_str(&name[..]);\n-        output.push_str(\"=\");\n-        push_unique_type_name(tcx, projection.ty, output);\n-        output.push_str(\", \");\n-    }\n-\n-    output.pop();\n-    output.pop();\n-\n-    output.push('>');\n-}\n-\n-fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     instance: Instance<'tcx>,\n-                                     output: &mut String) {\n-    push_item_name(tcx, instance.def, output);\n-    push_type_params(tcx, &instance.substs.types, &[], output);\n-}\n-\n-pub fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  def_id: DefId) -> String {\n-    let mut output = String::new();\n-    push_item_name(tcx, def_id, &mut output);\n-    output\n-}\n-\n-fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty: ty::Ty<'tcx>)\n-                            -> String {\n-    let mut output = String::new();\n-    push_unique_type_name(tcx, ty, &mut output);\n-    output\n-}\n-\n-impl<'a, 'tcx> TransItem<'tcx> {\n-    pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => {\n-                let attributes = tcx.get_attrs(instance.def);\n-                attr::requests_inline(&attributes[..])\n-            }\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn is_from_extern_crate(&self) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => !instance.def.is_local(),\n-            TransItem::DropGlue(..) |\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn is_lazily_instantiated(&self) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n-        let def_id = match *self {\n-            TransItem::Fn(ref instance) => instance.def,\n-            TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n-            TransItem::DropGlue(..) => return None,\n-        };\n-\n-        let attributes = tcx.get_attrs(def_id);\n-        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n-            if let Some(linkage) = llvm_linkage_by_name(&name) {\n-                Some(linkage)\n-            } else {\n-                let span = tcx.map.span_if_local(def_id);\n-                if let Some(span) = span {\n-                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n-                } else {\n-                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n-                }\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n-        let hir_map = &tcx.map;\n-\n-        return match *self {\n-            TransItem::DropGlue(dg) => {\n-                let mut s = String::with_capacity(32);\n-                match dg {\n-                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n-                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n-                };\n-                push_unique_type_name(tcx, dg.ty(), &mut s);\n-                s\n-            }\n-            TransItem::Fn(instance) => {\n-                to_string_internal(tcx, \"fn \", instance)\n-            },\n-            TransItem::Static(node_id) => {\n-                let def_id = hir_map.local_def_id(node_id);\n-                let instance = Instance::mono(tcx, def_id);\n-                to_string_internal(tcx, \"static \", instance)\n-            },\n-        };\n-\n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        prefix: &str,\n-                                        instance: Instance<'tcx>)\n-                                        -> String {\n-            let mut result = String::with_capacity(32);\n-            result.push_str(prefix);\n-            push_instance_as_string(tcx, instance, &mut result);\n-            result\n-        }\n-    }\n-\n-    fn to_raw_string(&self) -> String {\n-        match *self {\n-            TransItem::DropGlue(dg) => {\n-                format!(\"DropGlue({})\", dg.ty() as *const _ as usize)\n-            }\n-            TransItem::Fn(instance) => {\n-                format!(\"Fn({:?}, {})\",\n-                         instance.def,\n-                         instance.substs as *const _ as usize)\n-            }\n-            TransItem::Static(id) => {\n-                format!(\"Static({:?})\", id)\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum TransItemState {\n     PredictedAndGenerated,\n@@ -1546,7 +1234,7 @@ pub enum TransItemState {\n }\n \n pub fn collecting_debug_information(scx: &SharedCrateContext) -> bool {\n-    return cfg!(debug_assertions) &&\n+    return scx.sess().opts.cg.debug_assertions == Some(true) &&\n            scx.sess().opts.debugging_opts.print_trans_items.is_some();\n }\n "}, {"sha": "3e876eb3d7de079fc53d08ddd73d72711ac611b9", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -21,7 +21,8 @@ use rustc::hir::map as hir_map;\n use {abi, adt, closure, debuginfo, expr, machine};\n use base::{self, exported_name, imported_name, push_ctxt};\n use callee::Callee;\n-use collector::{self, TransItem};\n+use collector;\n+use trans_item::TransItem;\n use common::{type_is_sized, C_nil, const_get_elt};\n use common::{CrateContext, C_integral, C_floating, C_bool, C_str_slice, C_bytes, val_ty};\n use common::{C_struct, C_undef, const_to_opt_int, const_to_opt_uint, VariantInfo, C_uint};\n@@ -1011,7 +1012,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                             -> Datum<'tcx, Lvalue> {\n     let ty = ccx.tcx().lookup_item_type(def_id).ty;\n \n-    let instance = Instance::mono(ccx.tcx(), def_id);\n+    let instance = Instance::mono(ccx.shared(), def_id);\n     if let Some(&g) = ccx.instances().borrow().get(&instance) {\n         return Datum::new(g, ty, Lvalue::new(\"static\"));\n     }"}, {"sha": "60c6af84ebbb6ecf8f56d1d1776a4cc19787614d", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -27,8 +27,9 @@ use glue::DropGlueKind;\n use mir::CachedMir;\n use monomorphize::Instance;\n \n-use collector::{TransItem, TransItemState};\n use partitioning::CodegenUnit;\n+use collector::TransItemState;\n+use trans_item::TransItem;\n use type_::{Type, TypeNames};\n use rustc::ty::subst::{Substs, VecPerParamSpace};\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -487,6 +488,21 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn translation_items(&self) -> &RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>> {\n         &self.translation_items\n     }\n+\n+    /// Given the def-id of some item that has no type parameters, make\n+    /// a suitable \"empty substs\" for it.\n+    pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n+        let scheme = self.tcx().lookup_item_type(item_def_id);\n+        self.empty_substs_for_scheme(&scheme)\n+    }\n+\n+    pub fn empty_substs_for_scheme(&self, scheme: &ty::TypeScheme<'tcx>)\n+                                   -> &'tcx Substs<'tcx> {\n+        assert!(scheme.generics.types.is_empty());\n+        self.tcx().mk_substs(\n+            Substs::new(VecPerParamSpace::empty(),\n+                        scheme.generics.regions.map(|_| ty::ReStatic)))\n+    }\n }\n \n impl<'tcx> LocalCrateContext<'tcx> {\n@@ -901,16 +917,12 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        let scheme = self.tcx().lookup_item_type(item_def_id);\n-        self.empty_substs_for_scheme(&scheme)\n+        self.shared().empty_substs_for_def_id(item_def_id)\n     }\n \n     pub fn empty_substs_for_scheme(&self, scheme: &ty::TypeScheme<'tcx>)\n                                    -> &'tcx Substs<'tcx> {\n-        assert!(scheme.generics.types.is_empty());\n-        self.tcx().mk_substs(\n-            Substs::new(VecPerParamSpace::empty(),\n-                        scheme.generics.regions.map(|_| ty::ReStatic)))\n+        self.shared().empty_substs_for_scheme(scheme)\n     }\n }\n "}, {"sha": "10e33195305f616bfbf29975417b028ae413d9d4", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -29,13 +29,14 @@ use build::*;\n use callee::{Callee, ArgVals};\n use cleanup;\n use cleanup::CleanupMethods;\n-use collector::{self, TransItem};\n+use collector;\n use common::*;\n use debuginfo::DebugLoc;\n use declare;\n use expr;\n use machine::*;\n use monomorphize;\n+use trans_item::TransItem;\n use type_of::{type_of, sizing_type_of, align_of};\n use type_::Type;\n use value::Value;"}, {"sha": "bccb5aa050b511c60ffe7356efd6d3fd47b4d6c3", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -123,6 +123,7 @@ mod mir;\n mod monomorphize;\n mod partitioning;\n mod symbol_names_test;\n+mod trans_item;\n mod tvec;\n mod type_;\n mod type_of;"}, {"sha": "0403c7b1f757b89fb166b9744c869af6fa67627b", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -854,6 +854,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n                                 -> Result<ValueRef, ConstEvalFailure> {\n-    let instance = Instance::mono(ccx.tcx(), def_id);\n+    let instance = Instance::mono(ccx.shared(), def_id);\n     MirConstContext::trans_def(ccx, instance, vec![]).map(|c| c.llval)\n }"}, {"sha": "dfaf84ecef02397faabed4ace6926b0140c51f97", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -183,8 +183,8 @@ impl<'tcx> Instance<'tcx> {\n         assert!(substs.regions.iter().all(|&r| r == ty::ReStatic));\n         Instance { def: def_id, substs: substs }\n     }\n-    pub fn mono<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n-        Instance::new(def_id, tcx.mk_substs(Substs::empty()))\n+    pub fn mono<'a>(scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n+        Instance::new(def_id, scx.empty_substs_for_def_id(def_id))\n     }\n }\n "}, {"sha": "098ba759247be44d8a4b128cc290921f7e067994", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 17, "deletions": 59, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -116,30 +116,20 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n-use collector::{TransItem, ReferenceMap};\n+use collector::InliningMap;\n+use llvm;\n use monomorphize;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::ty::TyCtxt;\n use rustc::ty::item_path::characteristic_def_id_of_type;\n-use llvm;\n use syntax::parse::token::{self, InternedString};\n+use trans_item::TransItem;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n-#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n-pub enum InstantiationMode {\n-    /// This variant indicates that a translation item should be placed in some\n-    /// codegen unit as a definition and with the given linkage.\n-    Def(llvm::Linkage),\n-\n-    /// This variant indicates that only a declaration of some translation item\n-    /// should be placed in a given codegen unit.\n-    Decl\n-}\n-\n pub struct CodegenUnit<'tcx> {\n     pub name: InternedString,\n-    pub items: FnvHashMap<TransItem<'tcx>, InstantiationMode>,\n+    pub items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n }\n \n pub enum PartitioningStrategy {\n@@ -156,7 +146,7 @@ const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               trans_items: I,\n                               strategy: PartitioningStrategy,\n-                              reference_map: &ReferenceMap<'tcx>)\n+                              inlining_map: &InliningMap<'tcx>)\n                               -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n@@ -176,13 +166,8 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // translation items can be drop-glue, functions from external crates, and\n     // local functions the definition of which is marked with #[inline].\n     let post_inlining = place_inlined_translation_items(initial_partitioning,\n-                                                        reference_map);\n-\n-    // Now we know all *definitions* within all codegen units, thus we can\n-    // easily determine which declarations need to be placed within each one.\n-    let post_declarations = place_declarations(post_inlining, reference_map);\n-\n-    post_declarations.0\n+                                                        inlining_map);\n+    post_inlining.0\n }\n \n struct PreInliningPartitioning<'tcx> {\n@@ -191,7 +176,6 @@ struct PreInliningPartitioning<'tcx> {\n }\n \n struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n-struct PostDeclarationsPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n \n fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              trans_items: I)\n@@ -239,8 +223,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n             };\n \n-            codegen_unit.items.insert(trans_item,\n-                                      InstantiationMode::Def(linkage));\n+            codegen_unit.items.insert(trans_item, linkage);\n             roots.insert(trans_item);\n         }\n     }\n@@ -294,15 +277,15 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n }\n \n fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartitioning<'tcx>,\n-                                         reference_map: &ReferenceMap<'tcx>)\n+                                         inlining_map: &InliningMap<'tcx>)\n                                          -> PostInliningPartitioning<'tcx> {\n     let mut new_partitioning = Vec::new();\n \n     for codegen_unit in &initial_partitioning.codegen_units[..] {\n         // Collect all items that need to be available in this codegen unit\n         let mut reachable = FnvHashSet();\n         for root in codegen_unit.items.keys() {\n-            follow_inlining(*root, reference_map, &mut reachable);\n+            follow_inlining(*root, inlining_map, &mut reachable);\n         }\n \n         let mut new_codegen_unit = CodegenUnit {\n@@ -312,22 +295,22 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n \n         // Add all translation items that are not already there\n         for trans_item in reachable {\n-            if let Some(instantiation_mode) = codegen_unit.items.get(&trans_item) {\n+            if let Some(linkage) = codegen_unit.items.get(&trans_item) {\n                 // This is a root, just copy it over\n-                new_codegen_unit.items.insert(trans_item, *instantiation_mode);\n+                new_codegen_unit.items.insert(trans_item, *linkage);\n             } else {\n                 if initial_partitioning.roots.contains(&trans_item) {\n                     // This item will be instantiated in some other codegen unit,\n                     // so we just add it here with AvailableExternallyLinkage\n                     new_codegen_unit.items.insert(trans_item,\n-                        InstantiationMode::Def(llvm::AvailableExternallyLinkage));\n+                                                  llvm::AvailableExternallyLinkage);\n                 } else {\n                     // We can't be sure if this will also be instantiated\n                     // somewhere else, so we add an instance here with\n                     // LinkOnceODRLinkage. That way the item can be discarded if\n                     // it's not needed (inlined) after all.\n                     new_codegen_unit.items.insert(trans_item,\n-                        InstantiationMode::Def(llvm::LinkOnceODRLinkage));\n+                                                  llvm::LinkOnceODRLinkage);\n                 }\n             }\n         }\n@@ -338,43 +321,18 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n     return PostInliningPartitioning(new_partitioning);\n \n     fn follow_inlining<'tcx>(trans_item: TransItem<'tcx>,\n-                             reference_map: &ReferenceMap<'tcx>,\n+                             inlining_map: &InliningMap<'tcx>,\n                              visited: &mut FnvHashSet<TransItem<'tcx>>) {\n         if !visited.insert(trans_item) {\n             return;\n         }\n \n-        reference_map.with_inlining_candidates(trans_item, |target| {\n-            follow_inlining(target, reference_map, visited);\n+        inlining_map.with_inlining_candidates(trans_item, |target| {\n+            follow_inlining(target, inlining_map, visited);\n         });\n     }\n }\n \n-fn place_declarations<'tcx>(codegen_units: PostInliningPartitioning<'tcx>,\n-                            reference_map: &ReferenceMap<'tcx>)\n-                            -> PostDeclarationsPartitioning<'tcx> {\n-    let PostInliningPartitioning(mut codegen_units) = codegen_units;\n-\n-    for codegen_unit in codegen_units.iter_mut() {\n-        let mut declarations = FnvHashSet();\n-\n-        for (trans_item, _) in &codegen_unit.items {\n-            for referenced_item in reference_map.get_direct_references_from(*trans_item) {\n-                if !codegen_unit.items.contains_key(referenced_item) {\n-                    declarations.insert(*referenced_item);\n-                }\n-            }\n-        }\n-\n-        codegen_unit.items\n-                    .extend(declarations.iter()\n-                                        .map(|trans_item| (*trans_item,\n-                                                           InstantiationMode::Decl)));\n-    }\n-\n-    PostDeclarationsPartitioning(codegen_units)\n-}\n-\n fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  trans_item: TransItem<'tcx>)\n                                                  -> Option<DefId> {"}, {"sha": "284a227276dd0f2b2b1172bd169199b2f86e4f2b", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n-                let instance = Instance::mono(tcx, def_id);\n+                let instance = Instance::mono(self.ccx.shared(), def_id);\n                 let name = symbol_names::exported_name(self.ccx, &instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {"}, {"sha": "d7c5c41a156ba4c239780301a87881fc42087953", "filename": "src/librustc_trans/trans_item.rs", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -0,0 +1,384 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Walks the crate looking for items/impl-items/trait-items that have\n+//! either a `rustc_symbol_name` or `rustc_item_path` attribute and\n+//! generates an error giving, respectively, the symbol name or\n+//! item-path. This is used for unit testing the code that generates\n+//! paths etc in all kinds of annoying scenarios.\n+\n+use base::llvm_linkage_by_name;\n+use glue::DropGlueKind;\n+use llvm;\n+use monomorphize::Instance;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst;\n+use std::hash::{Hash, Hasher};\n+use syntax::ast::{self, NodeId};\n+use syntax::attr;\n+use syntax::parse::token;\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub enum TransItem<'tcx> {\n+    DropGlue(DropGlueKind<'tcx>),\n+    Fn(Instance<'tcx>),\n+    Static(NodeId)\n+}\n+\n+impl<'tcx> Hash for TransItem<'tcx> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        match *self {\n+            TransItem::DropGlue(t) => {\n+                0u8.hash(s);\n+                t.hash(s);\n+            },\n+            TransItem::Fn(instance) => {\n+                1u8.hash(s);\n+                instance.def.hash(s);\n+                (instance.substs as *const _ as usize).hash(s);\n+            }\n+            TransItem::Static(node_id) => {\n+                2u8.hash(s);\n+                node_id.hash(s);\n+            }\n+        };\n+    }\n+}\n+\n+//=-----------------------------------------------------------------------------\n+// TransItem String Keys\n+//=-----------------------------------------------------------------------------\n+\n+// The code below allows for producing a unique string key for a trans item.\n+// These keys are used by the handwritten auto-tests, so they need to be\n+// predictable and human-readable.\n+//\n+// Note: A lot of this could looks very similar to what's already in the\n+//       ppaux module. It would be good to refactor things so we only have one\n+//       parameterizable implementation for printing types.\n+\n+/// Same as `unique_type_name()` but with the result pushed onto the given\n+/// `output` parameter.\n+pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       t: ty::Ty<'tcx>,\n+                                       output: &mut String) {\n+    match t.sty {\n+        ty::TyBool              => output.push_str(\"bool\"),\n+        ty::TyChar              => output.push_str(\"char\"),\n+        ty::TyStr               => output.push_str(\"str\"),\n+        ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n+        ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n+        ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n+        ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n+        ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n+        ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n+        ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n+        ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n+        ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n+        ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n+        ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n+        ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n+        ty::TyStruct(adt_def, substs) |\n+        ty::TyEnum(adt_def, substs) => {\n+            push_item_name(tcx, adt_def.did, output);\n+            push_type_params(tcx, &substs.types, &[], output);\n+        },\n+        ty::TyTuple(component_types) => {\n+            output.push('(');\n+            for &component_type in component_types {\n+                push_unique_type_name(tcx, component_type, output);\n+                output.push_str(\", \");\n+            }\n+            if !component_types.is_empty() {\n+                output.pop();\n+                output.pop();\n+            }\n+            output.push(')');\n+        },\n+        ty::TyBox(inner_type) => {\n+            output.push_str(\"Box<\");\n+            push_unique_type_name(tcx, inner_type, output);\n+            output.push('>');\n+        },\n+        ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n+            output.push('*');\n+            match mutbl {\n+                hir::MutImmutable => output.push_str(\"const \"),\n+                hir::MutMutable => output.push_str(\"mut \"),\n+            }\n+\n+            push_unique_type_name(tcx, inner_type, output);\n+        },\n+        ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n+            output.push('&');\n+            if mutbl == hir::MutMutable {\n+                output.push_str(\"mut \");\n+            }\n+\n+            push_unique_type_name(tcx, inner_type, output);\n+        },\n+        ty::TyArray(inner_type, len) => {\n+            output.push('[');\n+            push_unique_type_name(tcx, inner_type, output);\n+            output.push_str(&format!(\"; {}\", len));\n+            output.push(']');\n+        },\n+        ty::TySlice(inner_type) => {\n+            output.push('[');\n+            push_unique_type_name(tcx, inner_type, output);\n+            output.push(']');\n+        },\n+        ty::TyTrait(ref trait_data) => {\n+            push_item_name(tcx, trait_data.principal.skip_binder().def_id, output);\n+            push_type_params(tcx,\n+                             &trait_data.principal.skip_binder().substs.types,\n+                             &trait_data.bounds.projection_bounds,\n+                             output);\n+        },\n+        ty::TyFnDef(_, _, &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n+        ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            if unsafety == hir::Unsafety::Unsafe {\n+                output.push_str(\"unsafe \");\n+            }\n+\n+            if abi != ::abi::Abi::Rust {\n+                output.push_str(\"extern \\\"\");\n+                output.push_str(abi.name());\n+                output.push_str(\"\\\" \");\n+            }\n+\n+            output.push_str(\"fn(\");\n+\n+            let sig = tcx.erase_late_bound_regions(sig);\n+            if !sig.inputs.is_empty() {\n+                for &parameter_type in &sig.inputs {\n+                    push_unique_type_name(tcx, parameter_type, output);\n+                    output.push_str(\", \");\n+                }\n+                output.pop();\n+                output.pop();\n+            }\n+\n+            if sig.variadic {\n+                if !sig.inputs.is_empty() {\n+                    output.push_str(\", ...\");\n+                } else {\n+                    output.push_str(\"...\");\n+                }\n+            }\n+\n+            output.push(')');\n+\n+            match sig.output {\n+                ty::FnConverging(result_type) if result_type.is_nil() => {}\n+                ty::FnConverging(result_type) => {\n+                    output.push_str(\" -> \");\n+                    push_unique_type_name(tcx, result_type, output);\n+                }\n+                ty::FnDiverging => {\n+                    output.push_str(\" -> !\");\n+                }\n+            }\n+        },\n+        ty::TyClosure(def_id, ref closure_substs) => {\n+            push_item_name(tcx, def_id, output);\n+            output.push_str(\"{\");\n+            output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n+            output.push_str(\"}\");\n+            push_type_params(tcx, &closure_substs.func_substs.types, &[], output);\n+        }\n+        ty::TyError |\n+        ty::TyInfer(_) |\n+        ty::TyProjection(..) |\n+        ty::TyParam(_) => {\n+            bug!(\"debuginfo: Trying to create type name for \\\n+                  unexpected type: {:?}\", t);\n+        }\n+    }\n+}\n+\n+fn push_item_name(tcx: TyCtxt,\n+                  def_id: DefId,\n+                  output: &mut String) {\n+    let def_path = tcx.def_path(def_id);\n+\n+    // some_crate::\n+    output.push_str(&tcx.crate_name(def_path.krate));\n+    output.push_str(\"::\");\n+\n+    // foo::bar::ItemName::\n+    for part in tcx.def_path(def_id).data {\n+        output.push_str(&format!(\"{}[{}]::\",\n+                        part.data.as_interned_str(),\n+                        part.disambiguator));\n+    }\n+\n+    // remove final \"::\"\n+    output.pop();\n+    output.pop();\n+}\n+\n+fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n+                              projections: &[ty::PolyProjectionPredicate<'tcx>],\n+                              output: &mut String) {\n+    if types.is_empty() && projections.is_empty() {\n+        return;\n+    }\n+\n+    output.push('<');\n+\n+    for &type_parameter in types {\n+        push_unique_type_name(tcx, type_parameter, output);\n+        output.push_str(\", \");\n+    }\n+\n+    for projection in projections {\n+        let projection = projection.skip_binder();\n+        let name = token::get_ident_interner().get(projection.projection_ty.item_name);\n+        output.push_str(&name[..]);\n+        output.push_str(\"=\");\n+        push_unique_type_name(tcx, projection.ty, output);\n+        output.push_str(\", \");\n+    }\n+\n+    output.pop();\n+    output.pop();\n+\n+    output.push('>');\n+}\n+\n+fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     instance: Instance<'tcx>,\n+                                     output: &mut String) {\n+    push_item_name(tcx, instance.def, output);\n+    push_type_params(tcx, &instance.substs.types, &[], output);\n+}\n+\n+pub fn def_id_to_string(tcx: TyCtxt, def_id: DefId) -> String {\n+    let mut output = String::new();\n+    push_item_name(tcx, def_id, &mut output);\n+    output\n+}\n+\n+pub fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                ty: ty::Ty<'tcx>)\n+                                -> String {\n+    let mut output = String::new();\n+    push_unique_type_name(tcx, ty, &mut output);\n+    output\n+}\n+\n+impl<'tcx> TransItem<'tcx> {\n+\n+    pub fn requests_inline<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => {\n+                let attributes = tcx.get_attrs(instance.def);\n+                attr::requests_inline(&attributes[..])\n+            }\n+            TransItem::DropGlue(..) => true,\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_from_extern_crate(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.def.is_local(),\n+            TransItem::DropGlue(..) |\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_lazily_instantiated(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n+            TransItem::DropGlue(..) => true,\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn explicit_linkage<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n+        let def_id = match *self {\n+            TransItem::Fn(ref instance) => instance.def,\n+            TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n+            TransItem::DropGlue(..) => return None,\n+        };\n+\n+        let attributes = tcx.get_attrs(def_id);\n+        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n+            if let Some(linkage) = llvm_linkage_by_name(&name) {\n+                Some(linkage)\n+            } else {\n+                let span = tcx.map.span_if_local(def_id);\n+                if let Some(span) = span {\n+                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n+                } else {\n+                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn to_string<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+        let hir_map = &tcx.map;\n+\n+        return match *self {\n+            TransItem::DropGlue(dg) => {\n+                let mut s = String::with_capacity(32);\n+                match dg {\n+                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n+                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n+                };\n+                push_unique_type_name(tcx, dg.ty(), &mut s);\n+                s\n+            }\n+            TransItem::Fn(instance) => {\n+                to_string_internal(tcx, \"fn \", instance)\n+            },\n+            TransItem::Static(node_id) => {\n+                let def_id = hir_map.local_def_id(node_id);\n+                let empty_substs = tcx.mk_substs(subst::Substs::empty());\n+                let instance = Instance::new(def_id, empty_substs);\n+                to_string_internal(tcx, \"static \", instance)\n+            },\n+        };\n+\n+        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        prefix: &str,\n+                                        instance: Instance<'tcx>)\n+                                        -> String {\n+            let mut result = String::with_capacity(32);\n+            result.push_str(prefix);\n+            push_instance_as_string(tcx, instance, &mut result);\n+            result\n+        }\n+    }\n+\n+    pub fn to_raw_string(&self) -> String {\n+        match *self {\n+            TransItem::DropGlue(dg) => {\n+                format!(\"DropGlue({})\", dg.ty() as *const _ as usize)\n+            }\n+            TransItem::Fn(instance) => {\n+                format!(\"Fn({:?}, {})\",\n+                         instance.def,\n+                         instance.substs as *const _ as usize)\n+            }\n+            TransItem::Static(id) => {\n+                format!(\"Static({:?})\", id)\n+            }\n+        }\n+    }\n+}"}, {"sha": "db940b680473a46606685c898f2c1f3d8d953343", "filename": "src/test/codegen-units/item-collection/drop_in_place_intrinsic.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+//~ TRANS_ITEM drop-glue drop_in_place_intrinsic::StructWithDtor[0]\n+//~ TRANS_ITEM drop-glue-contents drop_in_place_intrinsic::StructWithDtor[0]\n+struct StructWithDtor(u32);\n+\n+impl Drop for StructWithDtor {\n+    //~ TRANS_ITEM fn drop_in_place_intrinsic::{{impl}}[0]::drop[0]\n+    fn drop(&mut self) {}\n+}\n+\n+//~ TRANS_ITEM fn drop_in_place_intrinsic::main[0]\n+fn main() {\n+\n+    //~ TRANS_ITEM drop-glue [drop_in_place_intrinsic::StructWithDtor[0]; 2]\n+    let x = [StructWithDtor(0), StructWithDtor(1)];\n+\n+    drop_slice_in_place(&x);\n+}\n+\n+//~ TRANS_ITEM fn drop_in_place_intrinsic::drop_slice_in_place[0]\n+fn drop_slice_in_place(x: &[StructWithDtor]) {\n+    unsafe {\n+        // This is the interesting thing in this test case: Normally we would\n+        // not have drop-glue for the unsized [StructWithDtor]. This has to be\n+        // generated though when the drop_in_place() intrinsic is used.\n+        //~ TRANS_ITEM drop-glue [drop_in_place_intrinsic::StructWithDtor[0]]\n+        ::std::ptr::drop_in_place(x as *const _ as *mut [StructWithDtor]);\n+    }\n+}"}, {"sha": "41c0f46f80bfb2ad4c6e22c6e40b06aa93f10c95", "filename": "src/test/codegen-units/item-collection/static-init.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Zprint-trans-items=eager\n+\n+pub static FN : fn() = foo::<i32>;\n+\n+pub fn foo<T>() { }\n+\n+//~ TRANS_ITEM fn static_init::foo[0]<i32>\n+//~ TRANS_ITEM static static_init::FN[0]\n+\n+fn main() { }\n+\n+//~ TRANS_ITEM fn static_init::main[0]\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "04ebef645ec9836ec648b279ec1548f30128b070", "filename": "src/test/codegen-units/partitioning/local-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -23,7 +23,7 @@ struct Struct {\n }\n \n impl Drop for Struct {\n-    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[WeakODR] local_drop_glue-mod1[Declaration]\n+    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[WeakODR]\n     fn drop(&mut self) {}\n }\n "}, {"sha": "e38e676b95c617b9d4d18dd11346a9d70d91e324", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -19,10 +19,10 @@\n // Used in different modules/codegen units but always instantiated in the same\n // codegen unit.\n \n-//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[WeakODR] local_generic[Declaration]\n-//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[WeakODR] local_generic-mod1[Declaration]\n-//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[WeakODR] local_generic-mod1-mod1[Declaration]\n-//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[WeakODR] local_generic-mod2[Declaration]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[WeakODR]\n pub fn generic<T>(x: T) -> T { x }\n \n //~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[WeakODR]"}, {"sha": "99dda0e38bad7aeb63ac64262a91136f9f4b1fcf", "filename": "src/test/codegen-units/partitioning/methods-are-with-self-type.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c62d65cfbfbcac57b46fd650cb8b367094857be6/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs?ref=c62d65cfbfbcac57b46fd650cb8b367094857be6", "patch": "@@ -61,19 +61,19 @@ mod type2 {\n //~ TRANS_ITEM fn methods_are_with_self_type::main[0]\n fn main()\n {\n-    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR]\n     SomeGenericType(0u32, 0u64).method();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR]\n     SomeGenericType::associated_fn('c', \"&str\");\n \n-    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n     type1::Struct.foo();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n     type2::Struct.foo();\n \n-    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n     type1::Struct.default();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n     type2::Struct.default();\n }\n "}]}