{"sha": "4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNDQyNjM3N2U4ZjFhZDYxZGQ2ZDRiYjM1MjViYmYyOTk3ODg5Yjk=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-13T16:32:57Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-23T17:50:35Z"}, "message": "Box ItemKind to reduce the size of `Item`\n\nThis brings the size of `Item` from\n\n```\n[src/librustdoc/lib.rs:103] std::mem::size_of::<Item>() = 680\n```\n\nto\n\n```\n[src/librustdoc/lib.rs:103] std::mem::size_of::<Item>() = 280\n```", "tree": {"sha": "a67eca9cc86d9b3ec90ca0569794785d879c2238", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a67eca9cc86d9b3ec90ca0569794785d879c2238"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "html_url": "https://github.com/rust-lang/rust/commit/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ffea60dd5a2260004cc4f487401ae7c7db1aa0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ffea60dd5a2260004cc4f487401ae7c7db1aa0e", "html_url": "https://github.com/rust-lang/rust/commit/3ffea60dd5a2260004cc4f487401ae7c7db1aa0e"}], "stats": {"total": 182, "additions": 89, "deletions": 93}, "files": [{"sha": "3ca02b61063469c6b695b37b2cd6c5d92e858067", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     attrs: Default::default(),\n                     visibility: Inherited,\n                     def_id: self.cx.next_def_id(param_env_def_id.krate),\n-                    kind: ImplItem(Impl {\n+                    kind: box ImplItem(Impl {\n                         unsafety: hir::Unsafety::Normal,\n                         generics: new_generics,\n                         provided_trait_methods: Default::default(),"}, {"sha": "ba3eb007e384ddf0d52db01945750af0a2452c06", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                     attrs: Default::default(),\n                     visibility: Inherited,\n                     def_id: self.cx.next_def_id(impl_def_id.krate),\n-                    kind: ImplItem(Impl {\n+                    kind: box ImplItem(Impl {\n                         unsafety: hir::Unsafety::Normal,\n                         generics: (\n                             self.cx.tcx.generics_of(impl_def_id),"}, {"sha": "c168c56d30d0d18fe0fee1dce8fccffcb5440cf8", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -482,7 +482,7 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n                         source: clean::Span::dummy(),\n                         def_id: DefId::local(CRATE_DEF_INDEX),\n                         visibility: clean::Public,\n-                        kind: clean::ImportItem(clean::Import::new_simple(\n+                        kind: box clean::ImportItem(clean::Import::new_simple(\n                             item.ident.name,\n                             clean::ImportSource {\n                                 path: clean::Path {"}, {"sha": "a81ea1630cd41176ccb783d901d8812489b2f1f8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -2144,7 +2144,7 @@ fn clean_extern_crate(\n         source: krate.span.clean(cx),\n         def_id: crate_def_id,\n         visibility: krate.vis.clean(cx),\n-        kind: ExternCrateItem(name, orig_name),\n+        kind: box ExternCrateItem(name, orig_name),\n     }]\n }\n \n@@ -2212,7 +2212,7 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n                         source: self.span.clean(cx),\n                         def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n                         visibility: self.vis.clean(cx),\n-                        kind: ImportItem(Import::new_simple(\n+                        kind: box ImportItem(Import::new_simple(\n                             self.name,\n                             resolve_use_source(cx, path),\n                             false,\n@@ -2230,7 +2230,7 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir().local_def_id(self.id).to_def_id(),\n             visibility: self.vis.clean(cx),\n-            kind: ImportItem(inner),\n+            kind: box ImportItem(inner),\n         }]\n     }\n }"}, {"sha": "fc977704e44969a0192ba95dc2f0d2ca39e55d57", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -84,7 +84,7 @@ crate struct Item {\n     crate name: Option<Symbol>,\n     crate attrs: Attributes,\n     crate visibility: Visibility,\n-    crate kind: ItemKind,\n+    crate kind: Box<ItemKind>,\n     crate def_id: DefId,\n }\n \n@@ -152,7 +152,7 @@ impl Item {\n \n         Item {\n             def_id,\n-            kind,\n+            kind: box kind,\n             name,\n             source: source.clean(cx),\n             attrs: cx.tcx.get_attrs(def_id).clean(cx),\n@@ -171,7 +171,7 @@ impl Item {\n     }\n \n     crate fn is_crate(&self) -> bool {\n-        match self.kind {\n+        match *self.kind {\n             StrippedItem(box ModuleItem(Module { is_crate: true, .. }))\n             | ModuleItem(Module { is_crate: true, .. }) => true,\n             _ => false,\n@@ -223,14 +223,14 @@ impl Item {\n         self.type_() == ItemType::Keyword\n     }\n     crate fn is_stripped(&self) -> bool {\n-        match self.kind {\n+        match *self.kind {\n             StrippedItem(..) => true,\n             ImportItem(ref i) => !i.should_be_displayed,\n             _ => false,\n         }\n     }\n     crate fn has_stripped_fields(&self) -> Option<bool> {\n-        match self.kind {\n+        match *self.kind {\n             StructItem(ref _struct) => Some(_struct.fields_stripped),\n             UnionItem(ref union) => Some(union.fields_stripped),\n             VariantItem(Variant { kind: VariantKind::Struct(ref vstruct) }) => {\n@@ -281,7 +281,7 @@ impl Item {\n     }\n \n     crate fn is_default(&self) -> bool {\n-        match self.kind {\n+        match *self.kind {\n             ItemKind::MethodItem(_, Some(defaultness)) => {\n                 defaultness.has_value() && !defaultness.is_final()\n             }"}, {"sha": "2e479d25203d9fb6fe58719e0be645d49b15e4d5", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -43,7 +43,7 @@ crate fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n     let mut module = module.clean(cx);\n     let mut masked_crates = FxHashSet::default();\n \n-    match module.kind {\n+    match *module.kind {\n         ItemKind::ModuleItem(ref module) => {\n             for it in &module.items {\n                 // `compiler_builtins` should be masked too, but we can't apply\n@@ -61,7 +61,7 @@ crate fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n \n     let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n     {\n-        let m = match module.kind {\n+        let m = match *module.kind {\n             ItemKind::ModuleItem(ref mut m) => m,\n             _ => unreachable!(),\n         };\n@@ -338,7 +338,7 @@ crate fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut\n     let tcx = cx.tcx;\n \n     for item in items {\n-        let target = match item.kind {\n+        let target = match *item.kind {\n             ItemKind::TypedefItem(ref t, true) => &t.type_,\n             _ => continue,\n         };"}, {"sha": "343c6e779c157c11b136678dca12b2573b810ad5", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -5,9 +5,9 @@ crate struct StripItem(pub Item);\n impl StripItem {\n     crate fn strip(self) -> Option<Item> {\n         match self.0 {\n-            Item { kind: StrippedItem(..), .. } => Some(self.0),\n+            Item { kind: box StrippedItem(..), .. } => Some(self.0),\n             mut i => {\n-                i.kind = StrippedItem(box i.kind);\n+                i.kind = box StrippedItem(i.kind);\n                 Some(i)\n             }\n         }\n@@ -72,9 +72,9 @@ crate trait DocFolder: Sized {\n \n     /// don't override!\n     fn fold_item_recur(&mut self, mut item: Item) -> Item {\n-        item.kind = match item.kind {\n+        item.kind = box match *item.kind {\n             StrippedItem(box i) => StrippedItem(box self.fold_inner_recur(i)),\n-            _ => self.fold_inner_recur(item.kind),\n+            _ => self.fold_inner_recur(*item.kind),\n         };\n         item\n     }"}, {"sha": "899d61d8e43dfe191da3a3dd0600a237f2fc5e6c", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -219,7 +219,7 @@ impl DocFolder for Cache {\n \n         // If this is a stripped module,\n         // we don't want it or its children in the search index.\n-        let orig_stripped_mod = match item.kind {\n+        let orig_stripped_mod = match *item.kind {\n             clean::StrippedItem(box clean::ModuleItem(..)) => {\n                 mem::replace(&mut self.stripped_mod, true)\n             }\n@@ -228,7 +228,7 @@ impl DocFolder for Cache {\n \n         // If the impl is from a masked crate or references something from a\n         // masked crate then remove it completely.\n-        if let clean::ImplItem(ref i) = item.kind {\n+        if let clean::ImplItem(ref i) = *item.kind {\n             if self.masked_crates.contains(&item.def_id.krate)\n                 || i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n                 || i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n@@ -239,12 +239,12 @@ impl DocFolder for Cache {\n \n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n-        if let clean::TraitItem(ref t) = item.kind {\n+        if let clean::TraitItem(ref t) = *item.kind {\n             self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n         }\n \n         // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = item.kind {\n+        if let clean::ImplItem(ref i) = *item.kind {\n             if let Some(did) = i.trait_.def_id() {\n                 if i.blanket_impl.is_none() {\n                     self.implementors\n@@ -257,7 +257,7 @@ impl DocFolder for Cache {\n \n         // Index this method for searching later on.\n         if let Some(ref s) = item.name {\n-            let (parent, is_inherent_impl_item) = match item.kind {\n+            let (parent, is_inherent_impl_item) = match *item.kind {\n                 clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n                     if self.parent_is_trait_impl =>\n@@ -348,7 +348,7 @@ impl DocFolder for Cache {\n             _ => false,\n         };\n \n-        match item.kind {\n+        match *item.kind {\n             clean::StructItem(..)\n             | clean::EnumItem(..)\n             | clean::TypedefItem(..)\n@@ -387,7 +387,7 @@ impl DocFolder for Cache {\n \n         // Maintain the parent stack\n         let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n-        let parent_pushed = match item.kind {\n+        let parent_pushed = match *item.kind {\n             clean::TraitItem(..)\n             | clean::EnumItem(..)\n             | clean::ForeignTypeItem\n@@ -425,38 +425,33 @@ impl DocFolder for Cache {\n         // Once we've recursively found all the generics, hoard off all the\n         // implementations elsewhere.\n         let item = self.fold_item_recur(item);\n-        let ret = if let clean::Item { kind: clean::ImplItem(_), .. } = item {\n+        let ret = if let clean::Item { kind: box clean::ImplItem(ref i), .. } = item {\n             // Figure out the id of this impl. This may map to a\n             // primitive rather than always to a struct/enum.\n             // Note: matching twice to restrict the lifetime of the `i` borrow.\n             let mut dids = FxHashSet::default();\n-            if let clean::Item { kind: clean::ImplItem(ref i), .. } = item {\n-                match i.for_ {\n-                    clean::ResolvedPath { did, .. }\n-                    | clean::BorrowedRef { type_: box clean::ResolvedPath { did, .. }, .. } => {\n-                        dids.insert(did);\n-                    }\n-                    ref t => {\n-                        let did = t\n-                            .primitive_type()\n-                            .and_then(|t| self.primitive_locations.get(&t).cloned());\n+            match i.for_ {\n+                clean::ResolvedPath { did, .. }\n+                | clean::BorrowedRef { type_: box clean::ResolvedPath { did, .. }, .. } => {\n+                    dids.insert(did);\n+                }\n+                ref t => {\n+                    let did =\n+                        t.primitive_type().and_then(|t| self.primitive_locations.get(&t).cloned());\n \n-                        if let Some(did) = did {\n-                            dids.insert(did);\n-                        }\n+                    if let Some(did) = did {\n+                        dids.insert(did);\n                     }\n                 }\n+            }\n \n-                if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n-                    for bound in generics {\n-                        if let Some(did) = bound.def_id() {\n-                            dids.insert(did);\n-                        }\n+            if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n+                for bound in generics {\n+                    if let Some(did) = bound.def_id() {\n+                        dids.insert(did);\n                     }\n                 }\n-            } else {\n-                unreachable!()\n-            };\n+            }\n             let impl_item = Impl { impl_item: item };\n             if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n                 for did in dids {"}, {"sha": "ad51adf2fe3f5aa2d2d404f58fdec59ecf4cdba2", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -60,7 +60,7 @@ impl Serialize for ItemType {\n \n impl<'a> From<&'a clean::Item> for ItemType {\n     fn from(item: &'a clean::Item) -> ItemType {\n-        let kind = match item.kind {\n+        let kind = match *item.kind {\n             clean::StrippedItem(box ref item) => item,\n             ref kind => kind,\n         };"}, {"sha": "58b9f5fbf0f6ca842e4e7c9ea2f438a7bc06988e", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -32,7 +32,7 @@ crate struct Impl {\n \n impl Impl {\n     crate fn inner_impl(&self) -> &clean::Impl {\n-        match self.impl_item.kind {\n+        match *self.impl_item.kind {\n             clean::ImplItem(ref impl_) => impl_,\n             _ => panic!(\"non-impl item found in impl\"),\n         }"}, {"sha": "e84a9853d9b7c0fd11ebd69a84920fdc5ff9bd14", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -89,7 +89,7 @@ crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n             }\n \n             cx.mod_item_in(&item, &name, &cache)?;\n-            let module = match item.kind {\n+            let module = match *item.kind {\n                 clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n                 _ => unreachable!(),\n             };"}, {"sha": "c408e576639d9f3f0648efad5f3bb74612683964", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -165,7 +165,7 @@ crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n }\n \n crate fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n-    let (all_types, ret_types) = match item.kind {\n+    let (all_types, ret_types) = match *item.kind {\n         clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n         clean::MethodItem(ref m, _) => (&m.all_types, &m.ret_types),\n         clean::TyMethodItem(ref m) => (&m.all_types, &m.ret_types),"}, {"sha": "db1744f28539aee513748754f43abd6230da1c40", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -633,7 +633,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n \n         // Render sidebar-items.js used throughout this module.\n         if !self.render_redirect_pages {\n-            let module = match item.kind {\n+            let module = match *item.kind {\n                 clean::StrippedItem(box clean::ModuleItem(ref m)) | clean::ModuleItem(ref m) => m,\n                 _ => unreachable!(),\n             };\n@@ -1739,7 +1739,7 @@ fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer, cache: &Ca\n \n     write!(buf, \"</span>\"); // out-of-band\n     write!(buf, \"<span class=\\\"in-band\\\">\");\n-    let name = match item.kind {\n+    let name = match *item.kind {\n         clean::ModuleItem(ref m) => {\n             if m.is_crate {\n                 \"Crate \"\n@@ -1788,7 +1788,7 @@ fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer, cache: &Ca\n \n     write!(buf, \"</span></h1>\"); // in-band\n \n-    match item.kind {\n+    match *item.kind {\n         clean::ModuleItem(ref m) => item_module(buf, cx, item, &m.items),\n         clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n             item_function(buf, cx, item, f)\n@@ -2149,7 +2149,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n             );\n         }\n \n-        match myitem.kind {\n+        match *myitem.kind {\n             clean::ExternCrateItem(ref name, ref src) => {\n                 use crate::html::format::anchor;\n \n@@ -2185,7 +2185,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                     continue;\n                 }\n \n-                let unsafety_flag = match myitem.kind {\n+                let unsafety_flag = match *myitem.kind {\n                     clean::FunctionItem(ref func) | clean::ForeignFunctionItem(ref func)\n                         if func.header.unsafety == hir::Unsafety::Unsafe =>\n                     {\n@@ -2624,7 +2624,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             }\n             for (pos, m) in provided.iter().enumerate() {\n                 render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait, cx);\n-                match m.kind {\n+                match *m.kind {\n                     clean::MethodItem(ref inner, _)\n                         if !inner.generics.where_predicates.is_empty() =>\n                     {\n@@ -3051,7 +3051,7 @@ fn render_assoc_item(\n             where_clause = WhereClause { gens: g, indent, end_newline }\n         )\n     }\n-    match item.kind {\n+    match *item.kind {\n         clean::StrippedItem(..) => {}\n         clean::TyMethodItem(ref m) => {\n             method(w, item, m.header, &m.generics, &m.decl, link, parent, cx)\n@@ -3098,7 +3098,7 @@ fn item_struct(\n     let mut fields = s\n         .fields\n         .iter()\n-        .filter_map(|f| match f.kind {\n+        .filter_map(|f| match *f.kind {\n             clean::StructFieldItem(ref ty) => Some((f, ty)),\n             _ => None,\n         })\n@@ -3148,7 +3148,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n     let mut fields = s\n         .fields\n         .iter()\n-        .filter_map(|f| match f.kind {\n+        .filter_map(|f| match *f.kind {\n             clean::StructFieldItem(ref ty) => Some((f, ty)),\n             _ => None,\n         })\n@@ -3201,7 +3201,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             for v in &e.variants {\n                 write!(w, \"    \");\n                 let name = v.name.as_ref().unwrap();\n-                match v.kind {\n+                match *v.kind {\n                     clean::VariantItem(ref var) => match var.kind {\n                         clean::VariantKind::CLike => write!(w, \"{}\", name),\n                         clean::VariantKind::Tuple(ref tys) => {\n@@ -3251,7 +3251,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                 id = id,\n                 name = variant.name.as_ref().unwrap()\n             );\n-            if let clean::VariantItem(ref var) = variant.kind {\n+            if let clean::VariantItem(ref var) = *variant.kind {\n                 if let clean::VariantKind::Tuple(ref tys) = var.kind {\n                     write!(w, \"(\");\n                     for (i, ty) in tys.iter().enumerate() {\n@@ -3268,7 +3268,8 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             document_non_exhaustive(w, variant);\n \n             use crate::clean::{Variant, VariantKind};\n-            if let clean::VariantItem(Variant { kind: VariantKind::Struct(ref s) }) = variant.kind {\n+            if let clean::VariantItem(Variant { kind: VariantKind::Struct(ref s) }) = *variant.kind\n+            {\n                 let variant_id = cx.derive_id(format!(\n                     \"{}.{}.fields\",\n                     ItemType::Variant,\n@@ -3282,7 +3283,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                 );\n                 for field in &s.fields {\n                     use crate::clean::StructFieldItem;\n-                    if let StructFieldItem(ref ty) = field.kind {\n+                    if let StructFieldItem(ref ty) = *field.kind {\n                         let id = cx.derive_id(format!(\n                             \"variant.{}.field.{}\",\n                             variant.name.as_ref().unwrap(),\n@@ -3379,7 +3380,7 @@ fn render_struct(\n             let mut has_visible_fields = false;\n             write!(w, \" {{\");\n             for field in fields {\n-                if let clean::StructFieldItem(ref ty) = field.kind {\n+                if let clean::StructFieldItem(ref ty) = *field.kind {\n                     write!(\n                         w,\n                         \"\\n{}    {}{}: {},\",\n@@ -3410,7 +3411,7 @@ fn render_struct(\n                 if i > 0 {\n                     write!(w, \", \");\n                 }\n-                match field.kind {\n+                match *field.kind {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => write!(w, \"_\"),\n                     clean::StructFieldItem(ref ty) => {\n                         write!(w, \"{}{}\", field.visibility.print_with_space(cx.tcx()), ty.print())\n@@ -3457,7 +3458,7 @@ fn render_union(\n \n     write!(w, \" {{\\n{}\", tab);\n     for field in fields {\n-        if let clean::StructFieldItem(ref ty) = field.kind {\n+        if let clean::StructFieldItem(ref ty) = *field.kind {\n             write!(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n@@ -3619,7 +3620,7 @@ fn render_deref_methods(\n         .inner_impl()\n         .items\n         .iter()\n-        .find_map(|item| match item.kind {\n+        .find_map(|item| match *item.kind {\n             clean::TypedefItem(ref t, true) => Some(match *t {\n                 clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n                 _ => (&t.type_, &t.type_),\n@@ -3641,7 +3642,7 @@ fn render_deref_methods(\n }\n \n fn should_render_item(item: &clean::Item, deref_mut_: bool) -> bool {\n-    let self_type_opt = match item.kind {\n+    let self_type_opt = match *item.kind {\n         clean::MethodItem(ref method, _) => method.decl.self_type(),\n         clean::TyMethodItem(ref method) => method.decl.self_type(),\n         _ => None,\n@@ -3692,7 +3693,7 @@ fn spotlight_decl(decl: &clean::FnDecl) -> String {\n                     ));\n                     let t_did = impl_.trait_.def_id().unwrap();\n                     for it in &impl_.items {\n-                        if let clean::TypedefItem(ref tydef, _) = it.kind {\n+                        if let clean::TypedefItem(ref tydef, _) = *it.kind {\n                             out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n                             assoc_type(\n                                 &mut out,\n@@ -3764,7 +3765,7 @@ fn render_impl(\n             fmt_impl_for_trait_page(&i.inner_impl(), w, use_absolute);\n             if show_def_docs {\n                 for it in &i.inner_impl().items {\n-                    if let clean::TypedefItem(ref tydef, _) = it.kind {\n+                    if let clean::TypedefItem(ref tydef, _) = *it.kind {\n                         write!(w, \"<span class=\\\"where fmt-newline\\\">  \");\n                         assoc_type(w, it, &[], Some(&tydef.type_), AssocItemLink::Anchor(None), \"\");\n                         write!(w, \";</span>\");\n@@ -3846,7 +3847,7 @@ fn render_impl(\n             } else {\n                 (true, \" hidden\")\n             };\n-        match item.kind {\n+        match *item.kind {\n             clean::MethodItem(..) | clean::TyMethodItem(_) => {\n                 // Only render when the method is not static or we allow static methods\n                 if render_method_item {\n@@ -4123,7 +4124,7 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer, cache:\n         write!(\n             buffer,\n             \"<p class=\\\"location\\\">{}{}</p>\",\n-            match it.kind {\n+            match *it.kind {\n                 clean::StructItem(..) => \"Struct \",\n                 clean::TraitItem(..) => \"Trait \",\n                 clean::PrimitiveItem(..) => \"Primitive Type \",\n@@ -4163,7 +4164,7 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer, cache:\n             it.name.as_ref().expect(\"crates always have a name\")\n         );\n     }\n-    match it.kind {\n+    match *it.kind {\n         clean::StructItem(ref s) => sidebar_struct(buffer, it, s),\n         clean::TraitItem(ref t) => sidebar_trait(buffer, it, t),\n         clean::PrimitiveItem(_) => sidebar_primitive(buffer, it),\n@@ -4303,7 +4304,7 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                 .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n             {\n                 if let Some((target, real_target)) =\n-                    impl_.inner_impl().items.iter().find_map(|item| match item.kind {\n+                    impl_.inner_impl().items.iter().find_map(|item| match *item.kind {\n                         clean::TypedefItem(ref t, true) => Some(match *t {\n                             clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n                             _ => (&t.type_, &t.type_),\n@@ -4442,7 +4443,7 @@ fn get_id_for_impl_on_foreign_type(for_: &clean::Type, trait_: &clean::Type) ->\n }\n \n fn extract_for_impl_name(item: &clean::Item) -> Option<(String, String)> {\n-    match item.kind {\n+    match *item.kind {\n         clean::ItemKind::ImplItem(ref i) => {\n             if let Some(ref trait_) = i.trait_ {\n                 Some((\n@@ -4593,7 +4594,7 @@ fn sidebar_typedef(buf: &mut Buffer, it: &clean::Item) {\n fn get_struct_fields_name(fields: &[clean::Item]) -> String {\n     let mut fields = fields\n         .iter()\n-        .filter(|f| if let clean::StructFieldItem(..) = f.kind { true } else { false })\n+        .filter(|f| matches!(*f.kind, clean::StructFieldItem(..)))\n         .filter_map(|f| match f.name {\n             Some(ref name) => {\n                 Some(format!(\"<a href=\\\"#structfield.{name}\\\">{name}</a>\", name = name))"}, {"sha": "e347f7f84116073f81af4a471a5e8f4ae1801c8b", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -19,9 +19,9 @@ impl JsonRenderer<'_> {\n         let item_type = ItemType::from(&item);\n         let deprecation = item.deprecation(self.tcx);\n         let clean::Item { source, name, attrs, kind, visibility, def_id } = item;\n-        match kind {\n+        match *kind {\n             clean::StrippedItem(_) => None,\n-            _ => Some(Item {\n+            kind => Some(Item {\n                 id: def_id.into(),\n                 crate_id: def_id.krate.as_u32(),\n                 name: name.map(|sym| sym.to_string()),"}, {"sha": "df7ab9b7361a01af8b5992e59c817c2a65bfad92", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -178,9 +178,9 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         cache: &Cache,\n     ) -> Result<(), Error> {\n         use clean::types::ItemKind::*;\n-        if let ModuleItem(m) = &item.kind {\n+        if let ModuleItem(m) = &*item.kind {\n             for item in &m.items {\n-                match &item.kind {\n+                match &*item.kind {\n                     // These don't have names so they don't get added to the output by default\n                     ImportItem(_) => self.item(item.clone(), cache).unwrap(),\n                     ExternCrateItem(_, _) => self.item(item.clone(), cache).unwrap(),"}, {"sha": "6951b01e03d216f1e15ee81511661ee1a9a2cce9", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -187,7 +187,7 @@ impl<'a, 'b> CoverageCalculator<'a, 'b> {\n \n impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n     fn fold_item(&mut self, i: clean::Item) -> Option<clean::Item> {\n-        match i.kind {\n+        match *i.kind {\n             _ if !i.def_id.is_local() => {\n                 // non-local items are skipped because they can be out of the users control,\n                 // especially in the case of trait impls, which rustdoc eagerly inlines"}, {"sha": "9b0ae09cb3fd57c9f660faf22a5f6514ebc2b7f2", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -58,11 +58,11 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n \n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in &new_items {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = it.kind {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n             if cleaner.keep_item(for_) && trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n                 let target = items\n                     .iter()\n-                    .find_map(|item| match item.kind {\n+                    .find_map(|item| match *item.kind {\n                         TypedefItem(ref t, true) => Some(&t.type_),\n                         _ => None,\n                     })\n@@ -78,7 +78,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n \n     new_items.retain(|it| {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = it.kind {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n             cleaner.keep_item(for_)\n                 || trait_.as_ref().map_or(false, |t| cleaner.keep_item(t))\n                 || blanket_impl.is_some()\n@@ -124,7 +124,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n \n     if let Some(ref mut it) = krate.module {\n-        if let ModuleItem(Module { ref mut items, .. }) = it.kind {\n+        if let ModuleItem(Module { ref mut items, .. }) = *it.kind {\n             items.extend(synth.impls);\n             items.extend(new_items);\n         } else {"}, {"sha": "68ce73f944b8ec5e95d97591c1f49f17be177151", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -59,7 +59,7 @@ impl crate::doctest::Tester for Tests {\n \n crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n     if matches!(\n-        item.kind,\n+        *item.kind,\n         clean::StructFieldItem(_)\n             | clean::VariantItem(_)\n             | clean::AssocConstItem(_, _)"}, {"sha": "5694ce27de84bb7dd81eb5b0c5c3ce964e166325", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -41,7 +41,7 @@ impl<'a> DocFolder for Stripper<'a> {\n         if i.attrs.lists(sym::doc).has_word(sym::hidden) {\n             debug!(\"strip_hidden: stripping {:?} {:?}\", i.type_(), i.name);\n             // use a dedicated hidden item for given item type if any\n-            match i.kind {\n+            match *i.kind {\n                 clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n                     // We need to recurse into stripped modules to\n                     // strip things like impl methods but when doing so"}, {"sha": "f872e403ab0fcf63c0ec43a25b7f895327145737", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a4426377e8f1ad61dd6d4bb3525bbf2997889b9/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=4a4426377e8f1ad61dd6d4bb3525bbf2997889b9", "patch": "@@ -13,7 +13,7 @@ crate struct Stripper<'a> {\n \n impl<'a> DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.kind {\n+        match *i.kind {\n             clean::StrippedItem(..) => {\n                 // We need to recurse into stripped modules to strip things\n                 // like impl methods but when doing so we must not add any\n@@ -86,7 +86,7 @@ impl<'a> DocFolder for Stripper<'a> {\n             clean::KeywordItem(..) => {}\n         }\n \n-        let fastreturn = match i.kind {\n+        let fastreturn = match *i.kind {\n             // nothing left to do for traits (don't want to filter their\n             // methods out, visibility controlled by the trait)\n             clean::TraitItem(..) => true,\n@@ -121,7 +121,7 @@ crate struct ImplStripper<'a> {\n \n impl<'a> DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        if let clean::ImplItem(ref imp) = i.kind {\n+        if let clean::ImplItem(ref imp) = *i.kind {\n             // emptied none trait impls can be stripped\n             if imp.trait_.is_none() && imp.items.is_empty() {\n                 return None;\n@@ -160,7 +160,7 @@ crate struct ImportStripper;\n \n impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n-        match i.kind {\n+        match *i.kind {\n             clean::ExternCrateItem(..) | clean::ImportItem(..) if !i.visibility.is_public() => None,\n             _ => Some(self.fold_item_recur(i)),\n         }"}]}