{"sha": "fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66", "node_id": "C_kwDOAAsO6NoAKGZjNTZjYWNmYzFjMGU5NGU1ZmVlNmQ4NzZmZGNkY2YzZTAxZjZiNjY", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-01-14T17:36:26Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-01-16T11:55:56Z"}, "message": "Test `TraitRef` equality before generating missing impl method body", "tree": {"sha": "99a498b74b28d6d129790f7a210c304e311a8c25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99a498b74b28d6d129790f7a210c304e311a8c25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmPFO0wACgkQ4laYqTBY\nYXFL9g//aKlnbKiwB0yN9lvPkqk8W2BBkKWxs0OCoGKVeXT28LOXDSsX6SkdASVo\n4gwJ9dBjS/X7qZ8nysPGFYVkLoKKsDuIPrka+E/PbXZCM7+czjCeSrpzAm6ePitk\nVVGjEcFnYU6sZBkS750OMVTyTodl2TVMkvL+/GRkGOciB41EDjaJmAbz2PaCbsNB\ncThLcsPZYoX2lJtXj+j78FgZS6i2jgeAkAg7ieVQzwFRzXy/JQBMVmYd9oBlXOpd\nEJwAvLB/E9jPWLLqeXF7Gm1lPocvPvto6EAxH2AzHJoQzX82xWaPWLMU5JawPCcn\n+/ivBGAsWE51hHlmvVsTP2XrA1WzKIN35m6X0gNiSH0aE/4/Cvz7bvDDZuIII8fj\nqS92h0FQLmIDpnEG48JmcvK0FORz1BT3kH0jNqu9dQ79KuWehHm9fKQ3V37024t9\nxK6Rjc+GuB4SmM/StaZ6X+s63GczwG6NsPBFwH1IDKNU25T0ENLOSJJaLeiX/+0q\nayXwnQZO4qwRwZVWopRhF+oosA6iM+aHNlE3h757HvBKaRVaetP/8THLGXXfhPSq\ns265YoEXKlROdO0mpfw7q0kJlZGS+GINoe8Px1V+LVeK5mMjgXVr2g8/EKoPA++W\npJ4rr69F4uEUcja04cLy09DWvTXpiyTrzSKIVTVwcg19/LAs9ig=\n=pVzq\n-----END PGP SIGNATURE-----", "payload": "tree 99a498b74b28d6d129790f7a210c304e311a8c25\nparent 8afaaa54b0fc920780011d74723b44e2e8a760a4\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1673717786 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1673870156 +0900\n\nTest `TraitRef` equality before generating missing impl method body\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66", "html_url": "https://github.com/rust-lang/rust/commit/fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8afaaa54b0fc920780011d74723b44e2e8a760a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8afaaa54b0fc920780011d74723b44e2e8a760a4", "html_url": "https://github.com/rust-lang/rust/commit/8afaaa54b0fc920780011d74723b44e2e8a760a4"}], "stats": {"total": 98, "additions": 80, "deletions": 18}, "files": [{"sha": "627a9852fc8b8f0a3de7144ac99b9647b2d33550", "filename": "crates/ide-assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66", "patch": "@@ -1,7 +1,5 @@\n use hir::HasSource;\n-use ide_db::{\n-    syntax_helpers::insert_whitespace_into_node::insert_ws_into, traits::resolve_target_trait,\n-};\n+use ide_db::syntax_helpers::insert_whitespace_into_node::insert_ws_into;\n use syntax::ast::{self, make, AstNode};\n \n use crate::{\n@@ -107,6 +105,7 @@ fn add_missing_impl_members_inner(\n ) -> Option<()> {\n     let _p = profile::span(\"add_missing_impl_members_inner\");\n     let impl_def = ctx.find_node_at_offset::<ast::Impl>()?;\n+    let impl_ = ctx.sema.to_def(&impl_def)?;\n \n     if ctx.token_at_offset().all(|t| {\n         t.parent_ancestors()\n@@ -116,7 +115,8 @@ fn add_missing_impl_members_inner(\n     }\n \n     let target_scope = ctx.sema.scope(impl_def.syntax())?;\n-    let trait_ = resolve_target_trait(&ctx.sema, &impl_def)?;\n+    let trait_ref = impl_.trait_ref(ctx.db())?;\n+    let trait_ = trait_ref.trait_();\n \n     let missing_items = filter_assoc_items(\n         &ctx.sema,\n@@ -155,7 +155,7 @@ fn add_missing_impl_members_inner(\n                 let placeholder;\n                 if let DefaultMethods::No = mode {\n                     if let ast::AssocItem::Fn(func) = &first_new_item {\n-                        if try_gen_trait_body(ctx, func, &trait_, &impl_def).is_none() {\n+                        if try_gen_trait_body(ctx, func, trait_ref, &impl_def).is_none() {\n                             if let Some(m) =\n                                 func.syntax().descendants().find_map(ast::MacroCall::cast)\n                             {\n@@ -180,13 +180,13 @@ fn add_missing_impl_members_inner(\n fn try_gen_trait_body(\n     ctx: &AssistContext<'_>,\n     func: &ast::Fn,\n-    trait_: &hir::Trait,\n+    trait_ref: hir::TraitRef,\n     impl_def: &ast::Impl,\n ) -> Option<()> {\n-    let trait_path = make::ext::ident_path(&trait_.name(ctx.db()).to_string());\n+    let trait_path = make::ext::ident_path(&trait_ref.trait_().name(ctx.db()).to_string());\n     let hir_ty = ctx.sema.resolve_type(&impl_def.self_ty()?)?;\n     let adt = hir_ty.as_adt()?.source(ctx.db())?;\n-    gen_trait_fn_body(func, &trait_path, &adt.value)\n+    gen_trait_fn_body(func, &trait_path, &adt.value, Some(trait_ref))\n }\n \n #[cfg(test)]\n@@ -1352,6 +1352,50 @@ impl PartialEq for SomeStruct {\n         );\n     }\n \n+    #[test]\n+    fn test_partial_eq_body_when_types_semantically_match() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+//- minicore: eq\n+struct S<T, U>(T, U);\n+type Alias<T> = S<T, T>;\n+impl<T> PartialEq<Alias<T>> for S<T, T> {$0}\n+\"#,\n+            r#\"\n+struct S<T, U>(T, U);\n+type Alias<T> = S<T, T>;\n+impl<T> PartialEq<Alias<T>> for S<T, T> {\n+    $0fn eq(&self, other: &Alias<T>) -> bool {\n+        self.0 == other.0 && self.1 == other.1\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_partial_eq_body_when_types_dont_match() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+//- minicore: eq\n+struct S<T, U>(T, U);\n+type Alias<T> = S<T, T>;\n+impl<T> PartialEq<Alias<T>> for S<T, i32> {$0}\n+\"#,\n+            r#\"\n+struct S<T, U>(T, U);\n+type Alias<T> = S<T, T>;\n+impl<T> PartialEq<Alias<T>> for S<T, i32> {\n+    fn eq(&self, other: &Alias<T>) -> bool {\n+        ${0:todo!()}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_ignore_function_body() {\n         check_assist_not_applicable("}, {"sha": "4cfae0c7212c2c2c48d00f343bf06b6364c5a9f5", "filename": "crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66", "patch": "@@ -214,7 +214,7 @@ fn impl_def_from_trait(\n \n     // Generate a default `impl` function body for the derived trait.\n     if let ast::AssocItem::Fn(ref func) = first_assoc_item {\n-        let _ = gen_trait_fn_body(func, trait_path, adt);\n+        let _ = gen_trait_fn_body(func, trait_path, adt, None);\n     };\n \n     Some((impl_def, first_assoc_item))"}, {"sha": "808b23405951c6f0910087ada1081123e2e615b8", "filename": "crates/ide-assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=fc56cacfc1c0e94e5fee6d876fdcdcf3e01f6b66", "patch": "@@ -1,27 +1,31 @@\n //! This module contains functions to generate default trait impl function bodies where possible.\n \n+use hir::TraitRef;\n use syntax::{\n     ast::{self, edit::AstNodeEdit, make, AstNode, BinaryOp, CmpOp, HasName, LogicOp},\n     ted,\n };\n \n /// Generate custom trait bodies without default implementation where possible.\n ///\n+/// If `func` is defined within an existing impl block, pass [`TraitRef`]. Otherwise pass `None`.\n+///\n /// Returns `Option` so that we can use `?` rather than `if let Some`. Returning\n /// `None` means that generating a custom trait body failed, and the body will remain\n /// as `todo!` instead.\n pub(crate) fn gen_trait_fn_body(\n     func: &ast::Fn,\n     trait_path: &ast::Path,\n     adt: &ast::Adt,\n+    trait_ref: Option<TraitRef>,\n ) -> Option<()> {\n     match trait_path.segment()?.name_ref()?.text().as_str() {\n         \"Clone\" => gen_clone_impl(adt, func),\n         \"Debug\" => gen_debug_impl(adt, func),\n         \"Default\" => gen_default_impl(adt, func),\n         \"Hash\" => gen_hash_impl(adt, func),\n-        \"PartialEq\" => gen_partial_eq(adt, func),\n-        \"PartialOrd\" => gen_partial_ord(adt, func),\n+        \"PartialEq\" => gen_partial_eq(adt, func, trait_ref),\n+        \"PartialOrd\" => gen_partial_ord(adt, func, trait_ref),\n         _ => None,\n     }\n }\n@@ -395,7 +399,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n }\n \n /// Generate a `PartialEq` impl based on the fields and members of the target type.\n-fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn, trait_ref: Option<TraitRef>) -> Option<()> {\n     stdx::always!(func.name().map_or(false, |name| name.text() == \"eq\"));\n     fn gen_eq_chain(expr: Option<ast::Expr>, cmp: ast::Expr) -> Option<ast::Expr> {\n         match expr {\n@@ -423,8 +427,15 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         ast::Pat::IdentPat(make::ident_pat(false, false, make::name(field_name)))\n     }\n \n-    // FIXME: return `None` if the trait carries a generic type; we can only\n-    // generate this code `Self` for the time being.\n+    // Check that self type and rhs type match. We don't know how to implement the method\n+    // automatically otherwise.\n+    if let Some(trait_ref) = trait_ref {\n+        let self_ty = trait_ref.self_ty();\n+        let rhs_ty = trait_ref.get_type_argument(1)?;\n+        if self_ty != rhs_ty {\n+            return None;\n+        }\n+    }\n \n     let body = match adt {\n         // `PartialEq` cannot be derived for unions, so no default impl can be provided.\n@@ -568,7 +579,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 make::block_expr(None, expr).indent(ast::edit::IndentLevel(1))\n             }\n \n-            // No fields in the body means there's nothing to hash.\n+            // No fields in the body means there's nothing to compare.\n             None => {\n                 let expr = make::expr_literal(\"true\").into();\n                 make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n@@ -580,7 +591,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     Some(())\n }\n \n-fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn, trait_ref: Option<TraitRef>) -> Option<()> {\n     stdx::always!(func.name().map_or(false, |name| name.text() == \"partial_cmp\"));\n     fn gen_partial_eq_match(match_target: ast::Expr) -> Option<ast::Stmt> {\n         let mut arms = vec![];\n@@ -605,8 +616,15 @@ fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         make::expr_method_call(lhs, method, make::arg_list(Some(rhs)))\n     }\n \n-    // FIXME: return `None` if the trait carries a generic type; we can only\n-    // generate this code `Self` for the time being.\n+    // Check that self type and rhs type match. We don't know how to implement the method\n+    // automatically otherwise.\n+    if let Some(trait_ref) = trait_ref {\n+        let self_ty = trait_ref.self_ty();\n+        let rhs_ty = trait_ref.get_type_argument(1)?;\n+        if self_ty != rhs_ty {\n+            return None;\n+        }\n+    }\n \n     let body = match adt {\n         // `PartialOrd` cannot be derived for unions, so no default impl can be provided."}]}