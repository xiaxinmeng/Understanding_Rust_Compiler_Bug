{"sha": "4a3edb320dd515fd98431997d4bdb1ffa31446bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhM2VkYjMyMGRkNTE1ZmQ5ODQzMTk5N2Q0YmRiMWZmYTMxNDQ2YmQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-19T01:19:16Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-19T01:19:16Z"}, "message": "Store items and decls in vecs to preserve input order, index externally. Implement block-local name lookup.", "tree": {"sha": "40c4741c51e070a326cbc7643657cd288260bcbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40c4741c51e070a326cbc7643657cd288260bcbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a3edb320dd515fd98431997d4bdb1ffa31446bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a3edb320dd515fd98431997d4bdb1ffa31446bd", "html_url": "https://github.com/rust-lang/rust/commit/4a3edb320dd515fd98431997d4bdb1ffa31446bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a3edb320dd515fd98431997d4bdb1ffa31446bd/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "865bbae685fbf9bd1583a3f1715dd8093c0cbda2", "url": "https://api.github.com/repos/rust-lang/rust/commits/865bbae685fbf9bd1583a3f1715dd8093c0cbda2", "html_url": "https://github.com/rust-lang/rust/commit/865bbae685fbf9bd1583a3f1715dd8093c0cbda2"}], "stats": {"total": 369, "additions": 232, "deletions": 137}, "files": [{"sha": "047bdd06bed69b3c8676d6ec0d8d3e1ee911195d", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4a3edb320dd515fd98431997d4bdb1ffa31446bd/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3edb320dd515fd98431997d4bdb1ffa31446bd/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=4a3edb320dd515fd98431997d4bdb1ffa31446bd", "patch": "@@ -29,7 +29,8 @@ type crate = spanned[crate_];\n type crate_ = rec(_mod module);\n \n type block = spanned[block_];\n-type block_ = vec[@stmt];\n+type block_ = rec(vec[@stmt] stmts,\n+                  hashmap[ident,uint] index);\n \n tag binop {\n     add;\n@@ -69,10 +70,16 @@ tag stmt_ {\n     stmt_expr(@expr);\n }\n \n+type local = rec(option[@ty] ty,\n+                 bool infer,\n+                 ident ident,\n+                 option[@expr] init,\n+                 def_id id);\n+\n type decl = spanned[decl_];\n tag decl_ {\n-    decl_local(ident, option[@ty], option[@expr]);\n-    decl_item(ident, @item);\n+    decl_local(local);\n+    decl_item(@item);\n }\n \n type expr = spanned[expr_];\n@@ -125,16 +132,17 @@ tag mode {\n \n type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n type _fn = rec(vec[arg] inputs,\n-               ty output,\n+               @ty output,\n                block body);\n \n-type _mod = hashmap[ident,@item];\n+type _mod = rec(vec[@item] items,\n+                hashmap[ident,uint] index);\n \n type item = spanned[item_];\n tag item_ {\n-    item_fn(_fn, def_id);\n-    item_mod(_mod, def_id);\n-    item_ty(@ty, def_id);\n+    item_fn(ident, _fn, def_id);\n+    item_mod(ident, _mod, def_id);\n+    item_ty(ident, @ty, def_id);\n }\n \n "}, {"sha": "4aa71743e9289d6620f0308c06f07d0b902a9ff8", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 90, "deletions": 33, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/4a3edb320dd515fd98431997d4bdb1ffa31446bd/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3edb320dd515fd98431997d4bdb1ffa31446bd/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=4a3edb320dd515fd98431997d4bdb1ffa31446bd", "patch": "@@ -2,9 +2,11 @@ import std._io;\n import std.util.option;\n import std.util.some;\n import std.util.none;\n+import std.map.hashmap;\n \n import driver.session;\n import util.common;\n+import util.common.append;\n import util.common.span;\n import util.common.new_str_hash;\n \n@@ -610,13 +612,38 @@ io fn parse_let(parser p) -> @ast.decl {\n \n     expect(p, token.LET);\n     auto ty = parse_ty(p);\n-    auto id = parse_ident(p);\n+    auto ident = parse_ident(p);\n     auto init = parse_initializer(p);\n \n     auto hi = p.get_span();\n     expect(p, token.SEMI);\n \n-    ret @spanned(lo, hi, ast.decl_local(id, some(ty), init));\n+    let ast.local local = rec(ty = some(ty),\n+                              infer = false,\n+                              ident = ident,\n+                              init = init,\n+                              id = p.next_def_id());\n+\n+    ret @spanned(lo, hi, ast.decl_local(local));\n+}\n+\n+io fn parse_auto(parser p) -> @ast.decl {\n+    auto lo = p.get_span();\n+\n+    expect(p, token.AUTO);\n+    auto ident = parse_ident(p);\n+    auto init = parse_initializer(p);\n+\n+    auto hi = p.get_span();\n+    expect(p, token.SEMI);\n+\n+    let ast.local local = rec(ty = none[@ast.ty],\n+                              infer = true,\n+                              ident = ident,\n+                              init = init,\n+                              id = p.next_def_id());\n+\n+    ret @spanned(lo, hi, ast.decl_local(local));\n }\n \n io fn parse_stmt(parser p) -> @ast.stmt {\n@@ -632,20 +659,15 @@ io fn parse_stmt(parser p) -> @ast.stmt {\n         }\n \n         case (token.LET) {\n-            auto leht = parse_let(p);\n+            auto decl = parse_let(p);\n             auto hi = p.get_span();\n-            ret @spanned(lo, hi, ast.stmt_decl(leht));\n+            ret @spanned(lo, hi, ast.stmt_decl(decl));\n         }\n \n         case (token.AUTO) {\n-            p.bump();\n-            auto id = parse_ident(p);\n-            auto init = parse_initializer(p);\n+            auto decl = parse_auto(p);\n             auto hi = p.get_span();\n-            expect(p, token.SEMI);\n-\n-            auto decl = ast.decl_local(id, none[@ast.ty], init);\n-            ret @spanned(lo, hi, ast.stmt_decl(@spanned(lo, hi, decl)));\n+            ret @spanned(lo, hi, ast.stmt_decl(decl));\n         }\n \n         // Handle the (few) block-expr stmts first.\n@@ -677,10 +699,41 @@ io fn parse_stmt(parser p) -> @ast.stmt {\n io fn parse_block(parser p) -> ast.block {\n     auto f = parse_stmt;\n     // FIXME: passing parse_stmt as an lval doesn't work at the moment.\n-    ret parse_seq[@ast.stmt](token.LBRACE,\n-                             token.RBRACE,\n-                             none[token.token],\n-                             f, p);\n+    auto stmts = parse_seq[@ast.stmt](token.LBRACE,\n+                                      token.RBRACE,\n+                                      none[token.token],\n+                                      f, p);\n+    auto index = new_str_hash[uint]();\n+    auto u = 0u;\n+    for (@ast.stmt s in stmts.node) {\n+        // FIXME: typestate bug requires we do this up top, not\n+        // down below loop. Sigh.\n+        u += 1u;\n+        alt (s.node) {\n+            case (ast.stmt_decl(?d)) {\n+                alt (d.node) {\n+                    case (ast.decl_local(?loc)) {\n+                        index.insert(loc.ident, u-1u);\n+                    }\n+                    case (ast.decl_item(?it)) {\n+                        alt (it.node) {\n+                            case (ast.item_fn(?i, _, _)) {\n+                                index.insert(i, u-1u);\n+                            }\n+                            case (ast.item_mod(?i, _, _)) {\n+                                index.insert(i, u-1u);\n+                            }\n+                            case (ast.item_ty(?i, _, _)) {\n+                                index.insert(i, u-1u);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    let ast.block_ b = rec(stmts=stmts.node, index=index);\n+    ret spanned(stmts.span, stmts.span, b);\n }\n \n io fn parse_fn(parser p) -> tup(ast.ident, @ast.item) {\n@@ -697,12 +750,12 @@ io fn parse_fn(parser p) -> tup(ast.ident, @ast.item) {\n          some(token.COMMA),\n          pf, p);\n \n-    let ast.ty output;\n+    let @ast.ty output;\n     if (p.peek() == token.RARROW) {\n         p.bump();\n-        output = *parse_ty(p);\n+        output = parse_ty(p);\n     } else {\n-        output = spanned(lo, inputs.span, ast.ty_nil);\n+        output = @spanned(lo, inputs.span, ast.ty_nil);\n     }\n \n     auto body = parse_block(p);\n@@ -711,24 +764,33 @@ io fn parse_fn(parser p) -> tup(ast.ident, @ast.item) {\n                         output = output,\n                         body = body);\n \n-    let @ast.item i = @spanned(lo, body.span,\n-                               ast.item_fn(f, p.next_def_id()));\n-    ret tup(id, i);\n+    auto item = ast.item_fn(id, f, p.next_def_id());\n+    ret tup(id, @spanned(lo, body.span, item));\n }\n \n+io fn parse_mod_items(parser p, token.token term) -> ast._mod {\n+   let vec[@ast.item] items = vec();\n+    let hashmap[ast.ident,uint] index = new_str_hash[uint]();\n+    let uint u = 0u;\n+    while (p.peek() != term) {\n+        auto pair = parse_item(p);\n+        append[@ast.item](items, pair._1);\n+        index.insert(pair._0, u);\n+        u += 1u;\n+    }\n+    ret rec(items=items, index=index);\n+ }\n+\n io fn parse_mod(parser p) -> tup(ast.ident, @ast.item) {\n     auto lo = p.get_span();\n     expect(p, token.MOD);\n     auto id = parse_ident(p);\n     expect(p, token.LBRACE);\n-    let ast._mod m = new_str_hash[@ast.item]();\n-    while (p.peek() != token.RBRACE) {\n-        auto i = parse_item(p);\n-        m.insert(i._0, i._1);\n-    }\n+    auto m = parse_mod_items(p, token.RBRACE);\n     auto hi = p.get_span();\n     expect(p, token.RBRACE);\n-    ret tup(id, @spanned(lo, hi, ast.item_mod(m, p.next_def_id())));\n+    auto item = ast.item_mod(id, m, p.next_def_id());\n+    ret tup(id, @spanned(lo, hi, item));\n }\n \n io fn parse_item(parser p) -> tup(ast.ident, @ast.item) {\n@@ -747,12 +809,7 @@ io fn parse_item(parser p) -> tup(ast.ident, @ast.item) {\n io fn parse_crate(parser p) -> @ast.crate {\n     auto lo = p.get_span();\n     auto hi = lo;\n-    let ast._mod m = new_str_hash[@ast.item]();\n-    while (p.peek() != token.EOF) {\n-        auto i = parse_item(p);\n-        m.insert(i._0, i._1);\n-        hi = i._1.span;\n-    }\n+    auto m = parse_mod_items(p, token.EOF);\n     ret @spanned(lo, hi, rec(module=m));\n }\n "}, {"sha": "2ed931600245fb198559373509cbe0efa6ed3802", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 66, "deletions": 75, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/4a3edb320dd515fd98431997d4bdb1ffa31446bd/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3edb320dd515fd98431997d4bdb1ffa31446bd/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=4a3edb320dd515fd98431997d4bdb1ffa31446bd", "patch": "@@ -7,6 +7,7 @@ import util.common.new_str_hash;\n import util.common.spanned;\n import util.common.span;\n import util.common.ty_mach;\n+import util.common.append;\n \n import front.ast;\n import front.ast.ident;\n@@ -20,6 +21,7 @@ import front.ast.item;\n import front.ast.arg;\n import front.ast.decl;\n import front.ast.def;\n+import front.ast.def_id;\n \n import std._vec;\n \n@@ -70,11 +72,11 @@ type ast_fold[ENV] =\n          @ast.lit) -> @expr)                      fold_expr_lit,\n \n      (fn(&ENV e, &span sp,\n-         @expr cond, block thn,\n+         @expr cond, &block thn,\n          &option[block] els) -> @expr)            fold_expr_if,\n \n      (fn(&ENV e, &span sp,\n-         block blk) -> @expr)                     fold_expr_block,\n+         &block blk) -> @expr)                    fold_expr_block,\n \n      (fn(&ENV e, &span sp,\n          @expr lhs, @expr rhs) -> @expr)          fold_expr_assign,\n@@ -91,11 +93,10 @@ type ast_fold[ENV] =\n \n      // Decl folds.\n      (fn(&ENV e, &span sp,\n-         ident ident, &option[@ty] ty,\n-         &option[@expr]) -> @decl)                fold_decl_local,\n+         &ast.local local) -> @decl)              fold_decl_local,\n \n      (fn(&ENV e, &span sp,\n-         ident ident, @item item) -> @decl)        fold_decl_item,\n+         @item item) -> @decl)                    fold_decl_item,\n \n \n      // Stmt folds.\n@@ -112,21 +113,21 @@ type ast_fold[ENV] =\n          @expr e) -> @stmt)                       fold_stmt_expr,\n \n      // Item folds.\n-     (fn(&ENV e, &span sp,\n-         &ast._fn f, ast.def_id id) -> @item)     fold_item_fn,\n+     (fn(&ENV e, &span sp, ident ident,\n+         &ast._fn f, def_id id) -> @item)         fold_item_fn,\n \n-     (fn(&ENV e, &span sp,\n-         &ast._mod m, ast.def_id id) -> @item)    fold_item_mod,\n+     (fn(&ENV e, &span sp, ident ident,\n+         &ast._mod m, def_id id) -> @item)        fold_item_mod,\n \n-     (fn(&ENV e, &span sp,\n-         @ty t, ast.def_id id) -> @item)          fold_item_ty,\n+     (fn(&ENV e, &span sp, ident ident,\n+         @ty t, def_id id) -> @item)              fold_item_ty,\n \n      // Additional nodes.\n      (fn(&ENV e, &span sp,\n-         vec[@stmt] stmts) -> block)              fold_block,\n+         &ast.block_) -> block)                   fold_block,\n \n      (fn(&ENV e, vec[arg] inputs,\n-         &ty output, block body) -> ast._fn)      fold_fn,\n+         @ty output, &block body) -> ast._fn)     fold_fn,\n \n      (fn(&ENV e, &ast._mod m) -> ast._mod)        fold_mod,\n \n@@ -136,7 +137,7 @@ type ast_fold[ENV] =\n      // Env updates.\n      (fn(&ENV e, @ast.crate c) -> ENV) update_env_for_crate,\n      (fn(&ENV e, @item i) -> ENV) update_env_for_item,\n-     (fn(&ENV e, block b) -> ENV) update_env_for_block,\n+     (fn(&ENV e, &block b) -> ENV) update_env_for_block,\n      (fn(&ENV e, @stmt s) -> ENV) update_env_for_stmt,\n      (fn(&ENV e, @decl i) -> ENV) update_env_for_decl,\n      (fn(&ENV e, @expr x) -> ENV) update_env_for_expr,\n@@ -214,39 +215,32 @@ fn fold_decl[ENV](&ENV env, ast_fold[ENV] fld, @decl d) -> @decl {\n     }\n \n     alt (d.node) {\n-        case (ast.decl_local(?id, ?ty_opt, ?expr_opt)) {\n-            auto ty_opt_ = none[@ast.ty];\n-            auto expr_opt_ = none[@ast.expr];\n-            alt (ty_opt) {\n+        case (ast.decl_local(?local)) {\n+            auto ty_ = none[@ast.ty];\n+            auto init_ = none[@ast.expr];\n+            alt (local.ty) {\n                 case (some[@ast.ty](?t)) {\n-                    ty_opt_ = some[@ast.ty](fold_ty(env, fld, t));\n+                    ty_ = some[@ast.ty](fold_ty(env, fld, t));\n                 }\n             }\n-            alt (expr_opt) {\n+            alt (local.init) {\n                 case (some[@ast.expr](?e)) {\n-                    expr_opt_ = some[@ast.expr](fold_expr(env, fld, e));\n+                    init_ = some[@ast.expr](fold_expr(env, fld, e));\n                 }\n             }\n-            ret fld.fold_decl_local(env_, d.span, id, ty_opt_, expr_opt_);\n+            let ast.local local_ = rec(ty=ty_, init=init_ with local);\n+            ret fld.fold_decl_local(env_, d.span, local_);\n         }\n \n-        case (ast.decl_item(?id, ?item)) {\n+        case (ast.decl_item(?item)) {\n             auto item_ = fold_item(env_, fld, item);\n-            ret fld.fold_decl_item(env_, d.span, id, item_);\n+            ret fld.fold_decl_item(env_, d.span, item_);\n         }\n     }\n \n     fail;\n }\n \n-// FIXME: Weird bug. Due to the way we auto-deref + in +=, we can't append a\n-// boxed value to a vector-of-boxes using +=.  Best to figure out a way to fix\n-// this. Deref-on-demand or something? It's a hazard of the ambiguity between\n-// single-element and vector append.\n-fn append[T](&vec[T] v, &T t) {\n-    v += t;\n-}\n-\n fn fold_exprs[ENV](&ENV env, ast_fold[ENV] fld, vec[@expr] es) -> vec[@expr] {\n     let vec[@expr] exprs = vec();\n     for (@expr e in es) {\n@@ -406,10 +400,10 @@ fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n     }\n \n     let vec[@ast.stmt] stmts = vec();\n-    for (@ast.stmt s in blk.node) {\n+    for (@ast.stmt s in blk.node.stmts) {\n         append[@ast.stmt](stmts, fold_stmt[ENV](env_, fld, s));\n     }\n-    ret respan(blk.span, stmts);\n+    ret respan(blk.span, rec(stmts=stmts with blk.node));\n }\n \n fn fold_arg[ENV](&ENV env, ast_fold[ENV] fld, &arg a) -> arg {\n@@ -424,10 +418,10 @@ fn fold_fn[ENV](&ENV env, ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n     for (ast.arg a in f.inputs) {\n         inputs += fold_arg(env, fld, a);\n     }\n-    auto output = fold_ty[ENV](env, fld, @f.output);\n+    auto output = fold_ty[ENV](env, fld, f.output);\n     auto body = fold_block[ENV](env, fld, f.body);\n \n-    ret fld.fold_fn(env, inputs, *output, body);\n+    ret fld.fold_fn(env, inputs, output, body);\n }\n \n fn fold_item[ENV](&ENV env, ast_fold[ENV] fld, @item i) -> @item {\n@@ -440,36 +434,35 @@ fn fold_item[ENV](&ENV env, ast_fold[ENV] fld, @item i) -> @item {\n \n     alt (i.node) {\n \n-        case (ast.item_fn(?ff, ?id)) {\n+        case (ast.item_fn(?ident, ?ff, ?id)) {\n             let ast._fn ff_ = fold_fn[ENV](env_, fld, ff);\n-            ret fld.fold_item_fn(env_, i.span, ff_, id);\n+            ret fld.fold_item_fn(env_, i.span, ident, ff_, id);\n         }\n \n-        case (ast.item_mod(?mm, ?id)) {\n+        case (ast.item_mod(?ident, ?mm, ?id)) {\n             let ast._mod mm_ = fold_mod[ENV](env_, fld, mm);\n-            ret fld.fold_item_mod(env_, i.span, mm_, id);\n+            ret fld.fold_item_mod(env_, i.span, ident, mm_, id);\n         }\n \n-        case (ast.item_ty(?ty, ?id)) {\n+        case (ast.item_ty(?ident, ?ty, ?id)) {\n             let @ast.ty ty_ = fold_ty[ENV](env_, fld, ty);\n-            ret fld.fold_item_ty(env_, i.span, ty_, id);\n+            ret fld.fold_item_ty(env_, i.span, ident, ty_, id);\n         }\n     }\n \n     fail;\n }\n \n \n-fn fold_mod[ENV](&ENV e, ast_fold[ENV] fld, &ast._mod m_in) -> ast._mod {\n+fn fold_mod[ENV](&ENV e, ast_fold[ENV] fld, &ast._mod m) -> ast._mod {\n \n-    auto m_out = new_str_hash[@item]();\n+    let vec[@item] items = vec();\n \n-    for each (tup(ident, @item) pairs in m_in.items()) {\n-        auto i = fold_item[ENV](e, fld, pairs._1);\n-        m_out.insert(pairs._0, i);\n+    for (@item i in m.items) {\n+        append[@item](items, fold_item[ENV](e, fld, i));\n     }\n \n-    ret fld.fold_mod(e, m_out);\n+    ret fld.fold_mod(e, rec(items=items with m));\n  }\n \n fn fold_crate[ENV](&ENV env, ast_fold[ENV] fld, @ast.crate c) -> @ast.crate {\n@@ -578,12 +571,12 @@ fn identity_fold_expr_lit[ENV](&ENV env, &span sp, @ast.lit lit) -> @expr {\n }\n \n fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n-                              @expr cond, block thn,\n+                              @expr cond, &block thn,\n                               &option[block] els) -> @expr {\n     ret @respan(sp, ast.expr_if(cond, thn, els));\n }\n \n-fn identity_fold_expr_block[ENV](&ENV env, &span sp, block blk) -> @expr {\n+fn identity_fold_expr_block[ENV](&ENV env, &span sp, &block blk) -> @expr {\n     ret @respan(sp, ast.expr_block(blk));\n }\n \n@@ -611,14 +604,12 @@ fn identity_fold_expr_name[ENV](&ENV env, &span sp,\n // Decl identities.\n \n fn identity_fold_decl_local[ENV](&ENV e, &span sp,\n-                                 ident i, &option[@ty] t,\n-                                 &option[@expr] init) -> @decl {\n-    ret @respan(sp, ast.decl_local(i, t, init));\n+                                 &ast.local local) -> @decl {\n+    ret @respan(sp, ast.decl_local(local));\n }\n \n-fn identity_fold_decl_item[ENV](&ENV e, &span sp,\n-                                ident id, @item i) -> @decl {\n-    ret @respan(sp, ast.decl_item(id, i));\n+fn identity_fold_decl_item[ENV](&ENV e, &span sp, @item i) -> @decl {\n+    ret @respan(sp, ast.decl_item(i));\n }\n \n \n@@ -644,32 +635,32 @@ fn identity_fold_stmt_expr[ENV](&ENV e, &span sp, @expr x) -> @stmt {\n \n // Item identities.\n \n-fn identity_fold_item_fn[ENV](&ENV e, &span sp, &ast._fn f,\n-                              ast.def_id id) -> @item {\n-    ret @respan(sp, ast.item_fn(f, id));\n+fn identity_fold_item_fn[ENV](&ENV e, &span sp, ident i,\n+                              &ast._fn f, def_id id) -> @item {\n+    ret @respan(sp, ast.item_fn(i, f, id));\n }\n \n-fn identity_fold_item_mod[ENV](&ENV e, &span sp, &ast._mod m,\n-                               ast.def_id id) -> @item {\n-    ret @respan(sp, ast.item_mod(m, id));\n+fn identity_fold_item_mod[ENV](&ENV e, &span sp, ident i,\n+                               &ast._mod m, def_id id) -> @item {\n+    ret @respan(sp, ast.item_mod(i, m, id));\n }\n \n-fn identity_fold_item_ty[ENV](&ENV e, &span sp, @ty t,\n-                              ast.def_id id) -> @item {\n-    ret @respan(sp, ast.item_ty(t, id));\n+fn identity_fold_item_ty[ENV](&ENV e, &span sp, ident i,\n+                              @ty t, def_id id) -> @item {\n+    ret @respan(sp, ast.item_ty(i, t, id));\n }\n \n \n // Additional identities.\n \n-fn identity_fold_block[ENV](&ENV e, &span sp, vec[@stmt] stmts) -> block {\n-    ret respan(sp, stmts);\n+fn identity_fold_block[ENV](&ENV e, &span sp, &ast.block_ blk) -> block {\n+    ret respan(sp, blk);\n }\n \n fn identity_fold_fn[ENV](&ENV e,\n                          vec[arg] inputs,\n-                         &ast.ty output,\n-                         block body) -> ast._fn {\n+                         @ast.ty output,\n+                         &block body) -> ast._fn {\n     ret rec(inputs=inputs, output=output, body=body);\n }\n \n@@ -692,7 +683,7 @@ fn identity_update_env_for_item[ENV](&ENV e, @item i) -> ENV {\n     ret e;\n }\n \n-fn identity_update_env_for_block[ENV](&ENV e, block b) -> ENV {\n+fn identity_update_env_for_block[ENV](&ENV e, &block b) -> ENV {\n     ret e;\n }\n \n@@ -751,17 +742,17 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_index  = bind identity_fold_expr_index[ENV](_,_,_,_),\n          fold_expr_name   = bind identity_fold_expr_name[ENV](_,_,_,_),\n \n-         fold_decl_local  = bind identity_fold_decl_local[ENV](_,_,_,_,_),\n-         fold_decl_item   = bind identity_fold_decl_item[ENV](_,_,_,_),\n+         fold_decl_local  = bind identity_fold_decl_local[ENV](_,_,_),\n+         fold_decl_item   = bind identity_fold_decl_item[ENV](_,_,_),\n \n          fold_stmt_decl   = bind identity_fold_stmt_decl[ENV](_,_,_),\n          fold_stmt_ret    = bind identity_fold_stmt_ret[ENV](_,_,_),\n          fold_stmt_log    = bind identity_fold_stmt_log[ENV](_,_,_),\n          fold_stmt_expr   = bind identity_fold_stmt_expr[ENV](_,_,_),\n \n-         fold_item_fn   = bind identity_fold_item_fn[ENV](_,_,_,_),\n-         fold_item_mod  = bind identity_fold_item_mod[ENV](_,_,_,_),\n-         fold_item_ty   = bind identity_fold_item_ty[ENV](_,_,_,_),\n+         fold_item_fn   = bind identity_fold_item_fn[ENV](_,_,_,_,_),\n+         fold_item_mod  = bind identity_fold_item_mod[ENV](_,_,_,_,_),\n+         fold_item_ty   = bind identity_fold_item_ty[ENV](_,_,_,_,_),\n \n          fold_block = bind identity_fold_block[ENV](_,_,_),\n          fold_fn = bind identity_fold_fn[ENV](_,_,_,_),"}, {"sha": "82cdf3fa3c35ec277f8b92c31b61fef9fcbb0c45", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 43, "deletions": 14, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4a3edb320dd515fd98431997d4bdb1ffa31446bd/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3edb320dd515fd98431997d4bdb1ffa31446bd/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=4a3edb320dd515fd98431997d4bdb1ffa31446bd", "patch": "@@ -24,25 +24,46 @@ fn lookup_name(&env e, ast.ident i) -> option[def] {\n \n     log \"resolving name \" + i;\n \n-    fn check_mod(ast.ident i, ast._mod m) -> option[def] {\n-        alt (m.find(i)) {\n-            case (some[@ast.item](?it)) {\n-                alt (it.node) {\n-                    case (ast.item_fn(_, ?id)) {\n-                        ret some[def](ast.def_fn(id));\n-                    }\n-                    case (ast.item_mod(_, ?id)) {\n-                        ret some[def](ast.def_mod(id));\n+    fn found_def_item(@ast.item i) -> option[def] {\n+        alt (i.node) {\n+            case (ast.item_fn(_, _, ?id)) {\n+                ret some[def](ast.def_fn(id));\n+            }\n+            case (ast.item_mod(_, _, ?id)) {\n+                ret some[def](ast.def_mod(id));\n+            }\n+            case (ast.item_ty(_, _, ?id)) {\n+                ret some[def](ast.def_ty(id));\n+            }\n+        }\n+    }\n+\n+    fn found_decl_stmt(@ast.stmt s) -> option[def] {\n+        alt (s.node) {\n+            case (ast.stmt_decl(?d)) {\n+                alt (d.node) {\n+                    case (ast.decl_local(?loc)) {\n+                        ret some[def](ast.def_local(loc.id));\n                     }\n-                    case (ast.item_ty(_, ?id)) {\n-                        ret some[def](ast.def_ty(id));\n+                    case (ast.decl_item(?it)) {\n+                        ret found_def_item(it);\n                     }\n                 }\n             }\n         }\n         ret none[def];\n     }\n \n+    fn check_mod(ast.ident i, ast._mod m) -> option[def] {\n+        alt (m.index.find(i)) {\n+            case (some[uint](?ix)) {\n+                ret found_def_item(m.items.(ix));\n+            }\n+        }\n+        ret none[def];\n+    }\n+\n+\n     fn in_scope(ast.ident i, &scope s) -> option[def] {\n         alt (s) {\n \n@@ -52,18 +73,26 @@ fn lookup_name(&env e, ast.ident i) -> option[def] {\n \n             case (scope_item(?it)) {\n                 alt (it.node) {\n-                    case (ast.item_fn(?f, _)) {\n+                    case (ast.item_fn(_, ?f, _)) {\n                         for (ast.arg a in f.inputs) {\n                             if (_str.eq(a.ident, i)) {\n                                 ret some[def](ast.def_arg(a.id));\n                             }\n                         }\n                     }\n-                    case (ast.item_mod(?m, _)) {\n+                    case (ast.item_mod(_, ?m, _)) {\n                         ret check_mod(i, m);\n                     }\n                 }\n             }\n+\n+            case (scope_block(?b)) {\n+                alt (b.node.index.find(i)) {\n+                    case (some[uint](?ix)) {\n+                        ret found_decl_stmt(b.node.stmts.(ix));\n+                    }\n+                }\n+            }\n         }\n         ret none[def];\n     }\n@@ -96,7 +125,7 @@ fn update_env_for_item(&env e, @ast.item i) -> env {\n     ret cons[scope](scope_item(i), @e);\n }\n \n-fn update_env_for_block(&env e, ast.block b) -> env {\n+fn update_env_for_block(&env e, &ast.block b) -> env {\n     ret cons[scope](scope_block(b), @e);\n }\n "}, {"sha": "095990fa50ca762fd7788d4148283cd2ac7c33f6", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4a3edb320dd515fd98431997d4bdb1ffa31446bd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3edb320dd515fd98431997d4bdb1ffa31446bd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4a3edb320dd515fd98431997d4bdb1ffa31446bd", "patch": "@@ -688,7 +688,7 @@ fn trans_block_cleanups(@block_ctxt cx) -> @block_ctxt {\n fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n     auto bcx = cx;\n \n-    for (@ast.stmt s in b.node) {\n+    for (@ast.stmt s in b.node.stmts) {\n         bcx = trans_stmt(bcx, *s).bcx;\n     }\n \n@@ -724,21 +724,22 @@ fn trans_fn(@trans_ctxt cx, &ast._fn f) {\n     trans_block(new_top_block_ctxt(fcx), f.body);\n }\n \n-fn trans_item(@trans_ctxt cx, &str name, &ast.item item) {\n-    auto sub_cx = @rec(path=cx.path + \".\" + name with *cx);\n+fn trans_item(@trans_ctxt cx, &ast.item item) {\n     alt (item.node) {\n-        case (ast.item_fn(?f, _)) {\n+        case (ast.item_fn(?name, ?f, _)) {\n+            auto sub_cx = @rec(path=cx.path + \".\" + name with *cx);\n             trans_fn(sub_cx, f);\n         }\n-        case (ast.item_mod(?m, _)) {\n+        case (ast.item_mod(?name, ?m, _)) {\n+            auto sub_cx = @rec(path=cx.path + \".\" + name with *cx);\n             trans_mod(sub_cx, m);\n         }\n     }\n }\n \n fn trans_mod(@trans_ctxt cx, &ast._mod m) {\n-    for each (tup(str, @ast.item) pair in m.items()) {\n-        trans_item(cx, pair._0, *pair._1);\n+    for (@ast.item item in m.items) {\n+        trans_item(cx, *item);\n     }\n }\n "}, {"sha": "a5b77c0e793dc9396205b02789463b078d87d23c", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4a3edb320dd515fd98431997d4bdb1ffa31446bd/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3edb320dd515fd98431997d4bdb1ffa31446bd/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=4a3edb320dd515fd98431997d4bdb1ffa31446bd", "patch": "@@ -47,6 +47,15 @@ fn istr(int i) -> str {\n     ret _int.to_str(i, 10u);\n }\n \n+\n+// FIXME: Weird bug. Due to the way we auto-deref + in +=, we can't append a\n+// boxed value to a vector-of-boxes using +=.  Best to figure out a way to fix\n+// this. Deref-on-demand or something? It's a hazard of the ambiguity between\n+// single-element and vector append.\n+fn append[T](&vec[T] v, &T t) {\n+    v += t;\n+}\n+\n //\n // Local Variables:\n // mode: rust"}]}