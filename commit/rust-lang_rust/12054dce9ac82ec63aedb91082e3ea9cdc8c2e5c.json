{"sha": "12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyMDU0ZGNlOWFjODJlYzYzYWVkYjkxMDgyZTNlYTljZGM4YzJlNWM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-26T11:00:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-26T12:34:02Z"}, "message": "miri: validity visitor comments and path printing improvements", "tree": {"sha": "f4199c75c4f9f11419452994be4574627d288906", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4199c75c4f9f11419452994be4574627d288906"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c", "html_url": "https://github.com/rust-lang/rust/commit/12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc92ad4d5bd06f7c62a924090001d1620fc74f3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc92ad4d5bd06f7c62a924090001d1620fc74f3e", "html_url": "https://github.com/rust-lang/rust/commit/dc92ad4d5bd06f7c62a924090001d1620fc74f3e"}], "stats": {"total": 71, "additions": 47, "deletions": 24}, "files": [{"sha": "263883d56399ad4f8d6120700fe8457bf65dbef5", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c", "patch": "@@ -67,11 +67,12 @@ pub enum PathElem {\n     Field(Symbol),\n     Variant(Symbol),\n     GeneratorState(VariantIdx),\n-    ClosureVar(Symbol),\n+    CapturedVar(Symbol),\n     ArrayElem(usize),\n     TupleElem(usize),\n     Deref,\n-    Tag,\n+    EnumTag,\n+    GeneratorTag,\n     DynDowncast,\n }\n \n@@ -109,17 +110,18 @@ fn write_path(out: &mut String, path: &Vec<PathElem>) {\n     for elem in path.iter() {\n         match elem {\n             Field(name) => write!(out, \".{}\", name),\n-            Variant(name) => write!(out, \".<downcast-variant({})>\", name),\n+            EnumTag => write!(out, \".<enum-tag>\"),\n+            Variant(name) => write!(out, \".<enum-variant({})>\", name),\n+            GeneratorTag => write!(out, \".<generator-tag>\"),\n             GeneratorState(idx) => write!(out, \".<generator-state({})>\", idx.index()),\n-            ClosureVar(name) => write!(out, \".<closure-var({})>\", name),\n+            CapturedVar(name) => write!(out, \".<captured-var({})>\", name),\n             TupleElem(idx) => write!(out, \".{}\", idx),\n             ArrayElem(idx) => write!(out, \"[{}]\", idx),\n             // `.<deref>` does not match Rust syntax, but it is more readable for long paths -- and\n             // some of the other items here also are not Rust syntax.  Actually we can't\n             // even use the usual syntax because we are just showing the projections,\n             // not the root.\n             Deref => write!(out, \".<deref>\"),\n-            Tag => write!(out, \".<enum-tag>\"),\n             DynDowncast => write!(out, \".<dyn-downcast>\"),\n         }\n         .unwrap()\n@@ -170,6 +172,21 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n \n impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M> {\n     fn aggregate_field_path_elem(&mut self, layout: TyLayout<'tcx>, field: usize) -> PathElem {\n+        // First, check if we are projecting to a variant.\n+        match layout.variants {\n+            layout::Variants::Multiple { discr_index, .. } => {\n+                if discr_index == field {\n+                    return match layout.ty.kind {\n+                        ty::Adt(def, ..) if def.is_enum() => PathElem::EnumTag,\n+                        ty::Generator(..) => PathElem::GeneratorTag,\n+                        _ => bug!(\"non-variant type {:?}\", layout.ty),\n+                    };\n+                }\n+            }\n+            layout::Variants::Single { .. } => {}\n+        }\n+\n+        // Now we know we are projecting to a field, so figure out which one.\n         match layout.ty.kind {\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n@@ -190,7 +207,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                     }\n                 }\n \n-                PathElem::ClosureVar(name.unwrap_or_else(|| {\n+                PathElem::CapturedVar(name.unwrap_or_else(|| {\n                     // Fall back to showing the field index.\n                     sym::integer(field)\n                 }))\n@@ -207,10 +224,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                         // Inside a variant\n                         PathElem::Field(def.variants[index].fields[field].ident.name)\n                     }\n-                    layout::Variants::Multiple { discr_index, .. } => {\n-                        assert_eq!(discr_index, field);\n-                        PathElem::Tag\n-                    }\n+                    layout::Variants::Multiple { .. } => bug!(\"we handled variants above\"),\n                 }\n             }\n \n@@ -441,11 +455,12 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n     fn visit_scalar(\n         &mut self,\n         op: OpTy<'tcx, M::PointerTag>,\n-        layout: &layout::Scalar,\n+        scalar_layout: &layout::Scalar,\n     ) -> InterpResult<'tcx> {\n         let value = self.ecx.read_scalar(op)?;\n+        let valid_range = &scalar_layout.valid_range;\n+        let (lo, hi) = valid_range.clone().into_inner();\n         // Determine the allowed range\n-        let (lo, hi) = layout.valid_range.clone().into_inner();\n         // `max_hi` is as big as the size fits\n         let max_hi = u128::max_value() >> (128 - op.layout.size.bits());\n         assert!(hi <= max_hi);\n@@ -459,7 +474,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n             value.not_undef(),\n             value,\n             self.path,\n-            format_args!(\"something {}\", wrapping_range_format(&layout.valid_range, max_hi),)\n+            format_args!(\"something {}\", wrapping_range_format(valid_range, max_hi),)\n         );\n         let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n             Err(ptr) => {\n@@ -471,7 +486,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                             self.path,\n                             format_args!(\n                                 \"something that cannot possibly fail to be {}\",\n-                                wrapping_range_format(&layout.valid_range, max_hi)\n+                                wrapping_range_format(valid_range, max_hi)\n                             )\n                         )\n                     }\n@@ -484,21 +499,21 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                         self.path,\n                         format_args!(\n                             \"something that cannot possibly fail to be {}\",\n-                            wrapping_range_format(&layout.valid_range, max_hi)\n+                            wrapping_range_format(valid_range, max_hi)\n                         )\n                     )\n                 }\n             }\n             Ok(data) => data,\n         };\n         // Now compare. This is slightly subtle because this is a special \"wrap-around\" range.\n-        if wrapping_range_contains(&layout.valid_range, bits) {\n+        if wrapping_range_contains(&valid_range, bits) {\n             Ok(())\n         } else {\n             throw_validation_failure!(\n                 bits,\n                 self.path,\n-                format_args!(\"something {}\", wrapping_range_format(&layout.valid_range, max_hi))\n+                format_args!(\"something {}\", wrapping_range_format(valid_range, max_hi))\n             )\n         }\n     }\n@@ -594,7 +609,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n \n         // *After* all of this, check the ABI.  We need to check the ABI to handle\n         // types like `NonNull` where the `Scalar` info is more restrictive than what\n-        // the fields say. But in most cases, this will just propagate what the fields say,\n+        // the fields say (`rustc_layout_scalar_valid_range_start`).\n+        // But in most cases, this will just propagate what the fields say,\n         // and then we want the error to point at the field -- so, first recurse,\n         // then check ABI.\n         //\n@@ -603,11 +619,18 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // MyNewtype and then the scalar in there).\n         match op.layout.abi {\n             layout::Abi::Uninhabited => unreachable!(), // checked above\n-            layout::Abi::Scalar(ref layout) => {\n-                self.visit_scalar(op, layout)?;\n+            layout::Abi::Scalar(ref scalar_layout) => {\n+                self.visit_scalar(op, scalar_layout)?;\n+            }\n+            layout::Abi::ScalarPair { .. } | layout::Abi::Vector { .. } => {\n+                // These have fields that we already visited above, so we already checked\n+                // all their scalar-level restrictions.\n+                // There is also no equivalent to `rustc_layout_scalar_valid_range_start`\n+                // that would make skipping them here an issue.\n+            }\n+            layout::Abi::Aggregate { .. } => {\n+                // Nothing to do.\n             }\n-            // FIXME: Should we do something for ScalarPair? Vector?\n-            _ => {}\n         }\n \n         Ok(())"}, {"sha": "8c47d68e9686b757a7b6a7ec6970d54e0d494681", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c", "patch": "@@ -66,7 +66,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-enum.rs:71:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<downcast-variant(Some)>.0.1, but expected a valid unicode codepoint\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<enum-variant(Some)>.0.1, but expected a valid unicode codepoint\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}, {"sha": "972c9eb38c81e1626197bd22856ad1ea17906c75", "filename": "src/test/ui/consts/const-eval/ub-upvars.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-upvars.stderr?ref=12054dce9ac82ec63aedb91082e3ea9cdc8c2e5c", "patch": "@@ -6,7 +6,7 @@ LL | |     let bad_ref: &'static u16 = unsafe { mem::transmute(0usize) };\n LL | |     let another_var = 13;\n LL | |     move || { let _ = bad_ref; let _ = another_var; }\n LL | | };\n-   | |__^ type validation failed: encountered a NULL reference at .<deref>.<dyn-downcast>.<closure-var(bad_ref)>\n+   | |__^ type validation failed: encountered a NULL reference at .<deref>.<dyn-downcast>.<captured-var(bad_ref)>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n "}]}