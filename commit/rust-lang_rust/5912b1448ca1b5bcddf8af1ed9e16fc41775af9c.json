{"sha": "5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MTJiMTQ0OGNhMWI1YmNkZGY4YWYxZWQ5ZTE2ZmM0MTc3NWFmOWM=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2013-02-15T08:51:28Z"}, "committer": {"name": "Luqman Aden", "email": "laden@mozilla.com", "date": "2013-02-15T10:49:54Z"}, "message": "libcore: Get rid of `move`.", "tree": {"sha": "a4f7a4cc64b3afd75688bc530bb161210eacf1e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4f7a4cc64b3afd75688bc530bb161210eacf1e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "html_url": "https://github.com/rust-lang/rust/commit/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78f3e0da700ef88ce9b46078292295e51355a756", "url": "https://api.github.com/repos/rust-lang/rust/commits/78f3e0da700ef88ce9b46078292295e51355a756", "html_url": "https://github.com/rust-lang/rust/commit/78f3e0da700ef88ce9b46078292295e51355a756"}], "stats": {"total": 720, "additions": 358, "deletions": 362}, "files": [{"sha": "71af60314da8252b4b60aacd30bc343f69b53389", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -229,12 +229,12 @@ pub mod raw {\n         (**repr).unboxed.fill += sys::size_of::<T>();\n         let p = addr_of(&((**repr).unboxed.data));\n         let p = ptr::offset(p, fill) as *mut T;\n-        rusti::move_val_init(&mut(*p), move initval);\n+        rusti::move_val_init(&mut(*p), initval);\n     }\n \n     pub unsafe fn push_slow<T>(v: &mut @[const T], initval: T) {\n         reserve_at_least(&mut *v, v.len() + 1u);\n-        push_fast(v, move initval);\n+        push_fast(v, initval);\n     }\n \n     /**"}, {"sha": "22ed4f76943109e9ea992354e8c8adb753d718f1", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -29,15 +29,15 @@ pub unsafe fn reinterpret_cast<T, U>(src: &T) -> U {\n  * reinterpret_cast on pointer types.\n  */\n #[inline(always)]\n-pub unsafe fn forget<T>(thing: T) { rusti::forget(move thing); }\n+pub unsafe fn forget<T>(thing: T) { rusti::forget(thing); }\n \n /**\n  * Force-increment the reference count on a shared box. If used\n  * carelessly, this can leak the box. Use this in conjunction with transmute\n  * and/or reinterpret_cast when such calls would otherwise scramble a box's\n  * reference count\n  */\n-pub unsafe fn bump_box_refcount<T>(t: @T) { forget(move t); }\n+pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n \n /**\n  * Transform a value of one type into a value of another type.\n@@ -50,23 +50,23 @@ pub unsafe fn bump_box_refcount<T>(t: @T) { forget(move t); }\n #[inline(always)]\n pub unsafe fn transmute<L, G>(thing: L) -> G {\n     let newthing: G = reinterpret_cast(&thing);\n-    forget(move thing);\n-    move newthing\n+    forget(thing);\n+    newthing\n }\n \n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n-pub unsafe fn transmute_mut<T>(ptr: &a/T) -> &a/mut T { transmute(move ptr) }\n+pub unsafe fn transmute_mut<T>(ptr: &a/T) -> &a/mut T { transmute(ptr) }\n \n /// Coerce a mutable reference to be immutable.\n #[inline(always)]\n pub unsafe fn transmute_immut<T>(ptr: &a/mut T) -> &a/T {\n-    transmute(move ptr)\n+    transmute(ptr)\n }\n \n /// Coerce a borrowed pointer to have an arbitrary associated region.\n #[inline(always)]\n-pub unsafe fn transmute_region<T>(ptr: &a/T) -> &b/T { transmute(move ptr) }\n+pub unsafe fn transmute_region<T>(ptr: &a/T) -> &b/T { transmute(ptr) }\n \n /// Coerce an immutable reference to be mutable.\n #[inline(always)]\n@@ -83,7 +83,7 @@ pub unsafe fn transmute_immut_unsafe<T>(ptr: *const T) -> *T {\n /// Coerce a borrowed mutable pointer to have an arbitrary associated region.\n #[inline(always)]\n pub unsafe fn transmute_mut_region<T>(ptr: &a/mut T) -> &b/mut T {\n-    transmute(move ptr)\n+    transmute(ptr)\n }\n \n /// Transforms lifetime of the second pointer to match the first.\n@@ -132,9 +132,9 @@ pub mod tests {\n         use managed::raw::BoxRepr;\n         unsafe {\n             let x = @100u8;\n-            let x: *BoxRepr = transmute(move x);\n+            let x: *BoxRepr = transmute(x);\n             assert (*x).data == 100;\n-            let _x: @int = transmute(move x);\n+            let _x: @int = transmute(x);\n         }\n     }\n "}, {"sha": "09de94f1aaf7ddf1a76b5b5abd1b32124b0a0b36", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -493,7 +493,7 @@ impl<T: Copy> DList<T> {\n                 v[index] = *data;\n             }\n         }\n-        move v\n+        v\n     }\n }\n "}, {"sha": "03a921d7ea504f8d2c20673fc15b13663bccc544", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -67,18 +67,18 @@ pub pure fn DVec<A>() -> DVec<A> {\n \n /// Creates a new dvec with a single element\n pub pure fn from_elem<A>(e: A) -> DVec<A> {\n-    DVec {mut data: ~[move e]}\n+    DVec {mut data: ~[e]}\n }\n \n /// Creates a new dvec with the contents of a vector\n pub pure fn from_vec<A>(v: ~[A]) -> DVec<A> {\n-    DVec {mut data: move v}\n+    DVec {mut data: v}\n }\n \n /// Consumes the vector and returns its contents\n pub pure fn unwrap<A>(d: DVec<A>) -> ~[A] {\n-    let DVec {data: v} = move d;\n-    move v\n+    let DVec {data: v} = d;\n+    v\n }\n \n priv impl<A> DVec<A> {\n@@ -99,14 +99,14 @@ priv impl<A> DVec<A> {\n             data <-> self.data;\n             let data_ptr: *() = cast::reinterpret_cast(&data);\n             if data_ptr.is_null() { fail!(~\"Recursive use of dvec\"); }\n-            return f(move data);\n+            return f(data);\n         }\n     }\n \n     #[inline(always)]\n     fn give_back(data: ~[A]) {\n         unsafe {\n-            self.data = move data;\n+            self.data = data;\n         }\n     }\n \n@@ -130,7 +130,7 @@ impl<A> DVec<A> {\n      */\n     #[inline(always)]\n     fn swap(f: &fn(v: ~[A]) -> ~[A]) {\n-        self.check_out(|v| self.give_back(f(move v)))\n+        self.check_out(|v| self.give_back(f(v)))\n     }\n \n     /**\n@@ -141,7 +141,7 @@ impl<A> DVec<A> {\n     #[inline(always)]\n     fn swap_mut(f: &fn(v: ~[mut A]) -> ~[mut A]) {\n         do self.swap |v| {\n-            vec::cast_from_mut(f(vec::cast_to_mut(move v)))\n+            vec::cast_from_mut(f(vec::cast_to_mut(v)))\n         }\n     }\n \n@@ -156,16 +156,16 @@ impl<A> DVec<A> {\n     #[inline(always)]\n     fn set(w: ~[A]) {\n         self.check_not_borrowed();\n-        self.data = move w;\n+        self.data = w;\n     }\n \n     /// Remove and return the last element\n     fn pop() -> A {\n         do self.check_out |v| {\n-            let mut v = move v;\n+            let mut v = v;\n             let result = v.pop();\n-            self.give_back(move v);\n-            move result\n+            self.give_back(v);\n+            result\n         }\n     }\n \n@@ -176,53 +176,53 @@ impl<A> DVec<A> {\n             data <-> self.data;\n             let data_ptr: *() = cast::reinterpret_cast(&data);\n             if data_ptr.is_null() { fail!(~\"Recursive use of dvec\"); }\n-            self.data = move ~[move t];\n-            self.data.push_all_move(move data);\n+            self.data = ~[t];\n+            self.data.push_all_move(data);\n         }\n     }\n \n     /// Append a single item to the end of the list\n     #[inline(always)]\n     fn push(t: A) {\n         self.check_not_borrowed();\n-        self.data.push(move t);\n+        self.data.push(t);\n     }\n \n     /// Remove and return the first element\n     fn shift() -> A {\n         do self.check_out |v| {\n-            let mut v = move v;\n+            let mut v = v;\n             let result = v.shift();\n-            self.give_back(move v);\n-            move result\n+            self.give_back(v);\n+            result\n         }\n     }\n \n     /// Reverse the elements in the list, in place\n     fn reverse() {\n         do self.check_out |v| {\n-            let mut v = move v;\n+            let mut v = v;\n             vec::reverse(v);\n-            self.give_back(move v);\n+            self.give_back(v);\n         }\n     }\n \n     /// Gives access to the vector as a slice with immutable contents\n     fn borrow<R>(op: fn(x: &[A]) -> R) -> R {\n         do self.check_out |v| {\n             let result = op(v);\n-            self.give_back(move v);\n-            move result\n+            self.give_back(v);\n+            result\n         }\n     }\n \n     /// Gives access to the vector as a slice with mutable contents\n     fn borrow_mut<R>(op: fn(x: &[mut A]) -> R) -> R {\n         do self.check_out |v| {\n-            let mut v = move v;\n+            let mut v = v;\n             let result = op(v);\n-            self.give_back(move v);\n-            move result\n+            self.give_back(v);\n+            result\n         }\n     }\n }\n@@ -240,15 +240,15 @@ impl<A: Copy> DVec<A> {\n     /// Appends elements from `from_idx` to `to_idx` (exclusive)\n     fn push_slice(ts: &[const A], from_idx: uint, to_idx: uint) {\n         do self.swap |v| {\n-            let mut v = move v;\n+            let mut v = v;\n             let new_len = vec::len(v) + to_idx - from_idx;\n             vec::reserve(&mut v, new_len);\n             let mut i = from_idx;\n             while i < to_idx {\n                 v.push(ts[i]);\n                 i += 1u;\n             }\n-            move v\n+            v\n         }\n     }\n \n@@ -265,7 +265,7 @@ impl<A: Copy> DVec<A> {\n              none { v }\n              Some(h) {\n                let len = v.len() + h;\n-               let mut v = move v;\n+               let mut v = v;\n                vec::reserve(v, len);\n                v\n             }\n@@ -286,8 +286,8 @@ impl<A: Copy> DVec<A> {\n         unsafe {\n             do self.check_out |v| {\n                 let w = copy v;\n-                self.give_back(move v);\n-                move w\n+                self.give_back(v);\n+                w\n             }\n         }\n     }\n@@ -312,9 +312,9 @@ impl<A: Copy> DVec<A> {\n      */\n     fn grow_set_elt(idx: uint, initval: &A, val: A) {\n         do self.swap |v| {\n-            let mut v = move v;\n+            let mut v = v;\n             v.grow_set(idx, initval, val);\n-            move v\n+            v\n         }\n     }\n \n@@ -340,7 +340,7 @@ impl<A: Copy> DVec<A> {\n             for vec::rev_each(v) |e| {\n                 if !f(e) { break; }\n             }\n-            move v\n+            v\n         }\n     }\n \n@@ -353,7 +353,7 @@ impl<A: Copy> DVec<A> {\n             for vec::rev_eachi(v) |i, e| {\n                 if !f(i, e) { break; }\n             }\n-            move v\n+            v\n         }\n     }\n }"}, {"sha": "72aecdd82954fe18e42ab2a25849d80d119c5e89", "filename": "src/libcore/either.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -84,7 +84,7 @@ pub fn partition<T, U>(eithers: ~[Either<T, U>])\n           Right(r) => rights.push(r)\n         }\n     }\n-    return (move lefts, move rights);\n+    return (lefts, rights);\n }\n \n #[inline(always)]\n@@ -131,8 +131,8 @@ pub pure fn is_right<T, U>(eith: &Either<T, U>) -> bool {\n pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n     //! Retrieves the value in the left branch. Fails if the either is Right.\n \n-    match move eith {\n-        Left(move x) => move x,\n+    match eith {\n+        Left(x) => x,\n         Right(_) => fail!(~\"either::unwrap_left Right\")\n     }\n }\n@@ -141,8 +141,8 @@ pub pure fn unwrap_left<T,U>(eith: Either<T,U>) -> T {\n pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     //! Retrieves the value in the right branch. Fails if the either is Left.\n \n-    match move eith {\n-        Right(move x) => move x,\n+    match eith {\n+        Right(x) => x,\n         Left(_) => fail!(~\"either::unwrap_right Left\")\n     }\n }"}, {"sha": "36ea67ea6954e8ace732c3a65022a9bb9807b093", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -510,7 +510,7 @@ pub mod rt {\n                 unsafe { str::unshift_char(&mut s, ' ') };\n             }\n         }\n-        return unsafe { pad(cv, move s, PadSigned) };\n+        return unsafe { pad(cv, s, PadSigned) };\n     }\n     pub pure fn conv_uint(cv: Conv, u: uint) -> ~str {\n         let prec = get_int_precision(cv);\n@@ -522,7 +522,7 @@ pub mod rt {\n               TyBits => uint_to_str_prec(u, 2, prec),\n               TyOctal => uint_to_str_prec(u, 8, prec)\n             };\n-        return unsafe { pad(cv, move rs, PadUnsigned) };\n+        return unsafe { pad(cv, rs, PadUnsigned) };\n     }\n     pub pure fn conv_bool(cv: Conv, b: bool) -> ~str {\n         let s = if b { ~\"true\" } else { ~\"false\" };\n@@ -532,7 +532,7 @@ pub mod rt {\n     }\n     pub pure fn conv_char(cv: Conv, c: char) -> ~str {\n         let mut s = str::from_char(c);\n-        return unsafe { pad(cv, move s, PadNozero) };\n+        return unsafe { pad(cv, s, PadNozero) };\n     }\n     pub pure fn conv_str(cv: Conv, s: &str) -> ~str {\n         // For strings, precision is the maximum characters\n@@ -545,7 +545,7 @@ pub mod rt {\n             s.to_owned()\n           }\n         };\n-        return unsafe { pad(cv, move unpadded, PadNozero) };\n+        return unsafe { pad(cv, unpadded, PadNozero) };\n     }\n     pub pure fn conv_float(cv: Conv, f: float) -> ~str {\n         let (to_str, digits) = match cv.precision {\n@@ -560,7 +560,7 @@ pub mod rt {\n                 s = ~\" \" + s;\n             }\n         }\n-        return unsafe { pad(cv, move s, PadFloat) };\n+        return unsafe { pad(cv, s, PadFloat) };\n     }\n     pub pure fn conv_poly<T>(cv: Conv, v: &T) -> ~str {\n         let s = sys::log_str(v);\n@@ -589,7 +589,7 @@ pub mod rt {\n                     let diff = prec - len;\n                     let pad = str::from_chars(vec::from_elem(diff, '0'));\n                     pad + s\n-                } else { move s }\n+                } else { s }\n             };\n     }\n     pub pure fn get_int_precision(cv: Conv) -> uint {\n@@ -603,13 +603,13 @@ pub mod rt {\n     pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n     pub fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n-        let mut s = move s; // sadtimes\n+        let mut s = s; // sadtimes\n         let uwidth : uint = match cv.width {\n-          CountImplied => return (move s),\n+          CountImplied => return (s),\n           CountIs(width) => { width as uint }\n         };\n         let strlen = str::char_len(s);\n-        if uwidth <= strlen { return (move s); }\n+        if uwidth <= strlen { return (s); }\n         let mut padchar = ' ';\n         let diff = uwidth - strlen;\n         if have_flag(cv.flags, flag_left_justify) {"}, {"sha": "c47e27e75d950709fcb6c33e22c4ecf683c6dfd2", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -50,7 +50,7 @@ pub fn deflate_bytes(bytes: &[const u8]) -> ~[u8] {\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n-            move out\n+            out\n         }\n     }\n }\n@@ -68,7 +68,7 @@ pub fn inflate_bytes(bytes: &[const u8]) -> ~[u8] {\n             let out = vec::raw::from_buf_raw(res as *u8,\n                                             outsz as uint);\n             libc::free(res);\n-            move out\n+            out\n         }\n     }\n }"}, {"sha": "40a9de0cea349405e36a290d3850450e43d4488c", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -183,7 +183,7 @@ fn SipState(key0: u64, key1: u64) -> SipState {\n         mut ntail : 0u,\n     };\n     (&state).reset();\n-    move state\n+    state\n }\n \n \n@@ -352,7 +352,7 @@ impl Streaming for &SipState {\n         for vec::each(r) |b| {\n             s += uint::to_str_radix(*b as uint, 16u);\n         }\n-        move s\n+        s\n     }\n \n     #[inline(always)]\n@@ -447,7 +447,7 @@ pub fn test_siphash() {\n         for vec::each(*r) |b| {\n             s += uint::to_str_radix(*b as uint, 16u);\n         }\n-        move s\n+        s\n     }\n \n     while t < 64 {"}, {"sha": "34a9f6a8588d30916636cd8f171fed9eb0581180", "filename": "src/libcore/io.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -178,7 +178,7 @@ impl<T: Reader> ReaderUtil for T {\n         let count = self.read(bytes, len);\n \n         unsafe { vec::raw::set_len(&mut bytes, count); }\n-        move bytes\n+        bytes\n     }\n \n     fn read_line(&self) -> ~str {\n@@ -249,7 +249,7 @@ impl<T: Reader> ReaderUtil for T {\n                 bytes = vec::slice(bytes, offset, bytes.len());\n             }\n         }\n-        move chars\n+        chars\n     }\n \n     fn read_char(&self) -> char {\n@@ -273,7 +273,7 @@ impl<T: Reader> ReaderUtil for T {\n     fn read_whole_stream(&self) -> ~[u8] {\n         let mut bytes: ~[u8] = ~[];\n         while !self.eof() { bytes.push_all(self.read_bytes(2048u)); }\n-        move bytes\n+        bytes\n     }\n \n     fn each_byte(&self, it: fn(int) -> bool) {\n@@ -999,7 +999,7 @@ pub struct BytesWriter {\n impl Writer for BytesWriter {\n     fn write(&self, v: &[const u8]) {\n         do self.bytes.swap |bytes| {\n-            let mut bytes = move bytes;\n+            let mut bytes = bytes;\n             let v_len = v.len();\n             let bytes_len = bytes.len();\n \n@@ -1014,7 +1014,7 @@ impl Writer for BytesWriter {\n \n             self.pos += v_len;\n \n-            move bytes\n+            bytes\n         }\n     }\n     fn seek(&self, offset: int, whence: SeekStyle) {\n@@ -1035,7 +1035,7 @@ pub pure fn with_bytes_writer(f: fn(Writer)) -> ~[u8] {\n     let wr = @BytesWriter();\n     f(wr as Writer);\n     // FIXME (#3758): This should not be needed.\n-    unsafe { wr.bytes.check_out(|bytes| move bytes) }\n+    unsafe { wr.bytes.check_out(|bytes| bytes) }\n }\n \n pub pure fn with_str_writer(f: fn(Writer)) -> ~str {\n@@ -1048,7 +1048,7 @@ pub pure fn with_str_writer(f: fn(Writer)) -> ~str {\n     }\n     assert str::is_utf8(v);\n \n-    unsafe { move ::cast::transmute(move v) }\n+    unsafe { ::cast::transmute(v) }\n }\n \n // Utility functions\n@@ -1126,7 +1126,7 @@ pub mod fsync {\n \n     pub fn Res<t: Copy>(arg: Arg<t>) -> Res<t>{\n         Res {\n-            arg: move arg\n+            arg: arg\n         }\n     }\n "}, {"sha": "9a8f01baed1ebd8ea7eb9b5b615d28addd49e09d", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -42,7 +42,7 @@ impl<A> iter::ExtendedIter<A> for IMPL_T<A> {\n     }\n     #[inline(always)]\n     pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n-        iter::foldl(self, move b0, blk)\n+        iter::foldl(self, b0, blk)\n     }\n     #[inline(always)]\n     pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {"}, {"sha": "986aa18ad4ab18274de18e2c9a3fc26f926df44c", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -25,7 +25,7 @@ mod inst {\n         unsafe {\n             do self.swap |v| {\n                 v.each(f);\n-                move v\n+                v\n             }\n         }\n     }"}, {"sha": "25cdb11456a06a3ab043879fabb197b828034ca0", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -154,11 +154,11 @@ pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n pub pure fn foldl<A,B,IA:BaseIter<A>>(self: &IA, b0: B,\n                                       blk: fn(&B, &A) -> B)\n     -> B {\n-    let mut b = move b0;\n+    let mut b = b0;\n     for self.each |a| {\n         b = blk(&b, a);\n     }\n-    move b\n+    b\n }\n \n #[inline(always)]\n@@ -215,12 +215,12 @@ pub pure fn min<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ < *b => {\n-             *(move a)\n+             *(a)\n           }\n           _ => Some(*b)\n         }\n     } {\n-        Some(move val) => val,\n+        Some(val) => val,\n         None => fail!(~\"min called on empty iterator\")\n     }\n }\n@@ -230,12 +230,12 @@ pub pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n     match do foldl::<A,Option<A>,IA>(self, None) |a, b| {\n         match a {\n           &Some(ref a_) if *a_ > *b => {\n-              *(move a)\n+              *(a)\n           }\n           _ => Some(*b)\n         }\n     } {\n-        Some(move val) => val,\n+        Some(val) => val,\n         None => fail!(~\"max called on empty iterator\")\n     }\n }"}, {"sha": "1fb855520ba49d92d15b740c813fc3c4d25e8fb8", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -32,15 +32,15 @@ struct Data<T> {\n pub type Mut<T> = Data<T>;\n \n pub fn Mut<T>(t: T) -> Mut<T> {\n-    Data {value: move t, mode: ReadOnly}\n+    Data {value: t, mode: ReadOnly}\n }\n \n pub fn unwrap<T>(m: Mut<T>) -> T {\n     // Borrowck should prevent us from calling unwrap while the value\n     // is in use, as that would be a move from a borrowed value.\n     assert (m.mode as uint) == (ReadOnly as uint);\n-    let Data {value: move value, mode: _} = move m;\n-    move value\n+    let Data {value: value, mode: _} = m;\n+    value\n }\n \n impl<T> Data<T> {"}, {"sha": "a90364c7d8cedb537cee6c70eab40be5c4398317", "filename": "src/libcore/option.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -33,8 +33,8 @@ match msg {\n }\n \n // Remove the contained string, destroying the Option\n-let unwrapped_msg = match move msg {\n-    Some(move m) => m,\n+let unwrapped_msg = match msg {\n+    Some(m) => m,\n     None => ~\"default message\"\n };\n ~~~\n@@ -126,8 +126,8 @@ pub pure fn chain<T, U>(opt: Option<T>,\n      * function that returns an option.\n      */\n \n-    match move opt {\n-        Some(move t) => f(move t),\n+    match opt {\n+        Some(t) => f(t),\n         None => None\n     }\n }\n@@ -148,19 +148,19 @@ pub pure fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n     /*!\n      * Returns the leftmost Some() value, or None if both are None.\n      */\n-    match move opta {\n-        Some(move opta) => Some(move opta),\n-        _ => move optb\n+    match opta {\n+        Some(opta) => Some(opta),\n+        _ => optb\n     }\n }\n \n #[inline(always)]\n pub pure fn while_some<T>(x: Option<T>, blk: fn(v: T) -> Option<T>) {\n     //! Applies a function zero or more times until the result is none.\n \n-    let mut opt = move x;\n+    let mut opt = x;\n     while opt.is_some() {\n-        opt = blk(unwrap(move opt));\n+        opt = blk(unwrap(opt));\n     }\n }\n \n@@ -197,7 +197,7 @@ pub pure fn map_default<T, U>(opt: &r/Option<T>, def: U,\n                               f: fn(&r/T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n-    match *opt { None => move def, Some(ref t) => f(t) }\n+    match *opt { None => def, Some(ref t) => f(t) }\n }\n \n #[inline(always)]\n@@ -224,8 +224,8 @@ pub pure fn unwrap<T>(opt: Option<T>) -> T {\n     Instead, prefer to use pattern matching and handle the `None`\n     case explicitly.\n      */\n-    match move opt {\n-        Some(move x) => move x,\n+    match opt {\n+        Some(x) => x,\n         None => fail!(~\"option::unwrap none\")\n     }\n }\n@@ -247,8 +247,8 @@ pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n #[inline(always)]\n pub pure fn expect<T>(opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n-    match move opt {\n-        Some(move val) => val,\n+    match opt {\n+        Some(val) => val,\n         None => fail!(reason.to_owned()),\n     }\n }\n@@ -285,7 +285,7 @@ impl<T> Option<T> {\n     /// Applies a function to the contained value or returns a default\n     #[inline(always)]\n     pure fn map_default<U>(&self, def: U, f: fn(&self/T) -> U) -> U {\n-        map_default(self, move def, f)\n+        map_default(self, def, f)\n     }\n \n     /// As `map_default`, but consumes the option and gives `f`\n@@ -402,8 +402,8 @@ impl<T: Copy Zero> Option<T> {\n fn test_unwrap_ptr() {\n     let x = ~0;\n     let addr_x = ptr::addr_of(&(*x));\n-    let opt = Some(move x);\n-    let y = unwrap(move opt);\n+    let opt = Some(x);\n+    let y = unwrap(opt);\n     let addr_y = ptr::addr_of(&(*y));\n     assert addr_x == addr_y;\n }\n@@ -412,8 +412,8 @@ fn test_unwrap_ptr() {\n fn test_unwrap_str() {\n     let x = ~\"test\";\n     let addr_x = str::as_buf(x, |buf, _len| buf);\n-    let opt = Some(move x);\n-    let y = unwrap(move opt);\n+    let opt = Some(x);\n+    let y = unwrap(opt);\n     let addr_y = str::as_buf(y, |buf, _len| buf);\n     assert addr_x == addr_y;\n }\n@@ -434,8 +434,8 @@ fn test_unwrap_resource() {\n     let i = @mut 0;\n     {\n         let x = R(i);\n-        let opt = Some(move x);\n-        let _y = unwrap(move opt);\n+        let opt = Some(x);\n+        let _y = unwrap(opt);\n     }\n     assert *i == 1;\n }"}, {"sha": "f2401589cd81dfbc70606fad5b37d6ed55b509d6", "filename": "src/libcore/os.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -171,7 +171,7 @@ pub fn env() -> ~[(~str,~str)] {\n                 assert vec::len(vs) == 2u;\n                 pairs.push((copy vs[0], copy vs[1]));\n             }\n-            move pairs\n+            pairs\n         }\n     }\n }\n@@ -482,7 +482,7 @@ pub fn tmpdir() -> Path {\n \n     fn getenv_nonempty(v: &str) -> Option<Path> {\n         match getenv(v) {\n-            Some(move x) =>\n+            Some(x) =>\n                 if str::is_empty(x) {\n                     None\n                 } else {\n@@ -915,7 +915,7 @@ unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n     for uint::range(0, argc as uint) |i| {\n         vec::push(&mut args, str::raw::from_c_str(*argv.offset(i)));\n     }\n-    move args\n+    args\n }\n \n /**\n@@ -1137,7 +1137,7 @@ mod tests {\n         let rng: rand::Rng = rand::Rng();\n         let n = ~\"TEST\" + rng.gen_str(10u);\n         assert getenv(n).is_none();\n-        move n\n+        n\n     }\n \n     #[test]\n@@ -1171,7 +1171,7 @@ mod tests {\n         let n = make_rand_name();\n         setenv(n, s);\n         log(debug, copy s);\n-        assert getenv(n) == option::Some(move s);\n+        assert getenv(n) == option::Some(s);\n     }\n \n     #[test]\n@@ -1197,7 +1197,7 @@ mod tests {\n             // MingW seems to set some funky environment variables like\n             // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n             // from env() but not visible from getenv().\n-            assert v2.is_none() || v2 == option::Some(move v);\n+            assert v2.is_none() || v2 == option::Some(v);\n         }\n     }\n \n@@ -1210,7 +1210,7 @@ mod tests {\n         assert !vec::contains(e, &(copy n, ~\"VALUE\"));\n \n         e = env();\n-        assert vec::contains(e, &(move n, ~\"VALUE\"));\n+        assert vec::contains(e, &(n, ~\"VALUE\"));\n     }\n \n     #[test]"}, {"sha": "531ce95d067be11232276b66d8c225975c3e0c9d", "filename": "src/libcore/path.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -245,7 +245,7 @@ impl Path {\n                 let mut st = stat::arch::default_stat();\n                 let r = libc::stat(buf, &mut st);\n \n-                if r == 0 { Some(move st) } else { None }\n+                if r == 0 { Some(st) } else { None }\n             }\n         }\n     }\n@@ -257,7 +257,7 @@ impl Path {\n                 let mut st = stat::arch::default_stat();\n                 let r = libc::lstat(buf, &mut st);\n \n-                if r == 0 { Some(move st) } else { None }\n+                if r == 0 { Some(st) } else { None }\n             }\n         }\n     }\n@@ -381,7 +381,7 @@ impl GenericPath for PosixPath {\n         let mut components = str::split_nonempty(s, |c| c == '/');\n         let is_absolute = (s.len() != 0 && s[0] == '/' as u8);\n         return PosixPath { is_absolute: is_absolute,\n-                           components: move components }\n+                           components: components }\n     }\n \n     pure fn dirname() -> ~str {\n@@ -390,7 +390,7 @@ impl GenericPath for PosixPath {\n             if s.len() == 0 {\n                 ~\".\"\n             } else {\n-                move s\n+                s\n             }\n         }\n     }\n@@ -430,7 +430,7 @@ impl GenericPath for PosixPath {\n         let dpath = PosixPath(d);\n         match self.filename() {\n           Some(ref f) => dpath.push(*f),\n-          None => move dpath\n+          None => dpath\n         }\n     }\n \n@@ -477,7 +477,7 @@ impl GenericPath for PosixPath {\n           Some(ref f) => ~[copy *f]\n         };\n         return PosixPath { is_absolute: false,\n-                           components: move cs }\n+                           components: cs }\n     }\n \n     pure fn push_rel(other: &PosixPath) -> PosixPath {\n@@ -491,17 +491,17 @@ impl GenericPath for PosixPath {\n             let mut ss = str::split_nonempty(\n                 *e,\n                 |c| windows::is_sep(c as u8));\n-            unsafe { v.push_all_move(move ss); }\n+            unsafe { v.push_all_move(ss); }\n         }\n         PosixPath { is_absolute: self.is_absolute,\n-                    components: move v }\n+                    components: v }\n     }\n \n     pure fn push(s: &str) -> PosixPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n-        unsafe { v.push_all_move(move ss); }\n-        PosixPath { components: move v, ..copy self }\n+        unsafe { v.push_all_move(ss); }\n+        PosixPath { components: v, ..copy self }\n     }\n \n     pure fn pop() -> PosixPath {\n@@ -511,7 +511,7 @@ impl GenericPath for PosixPath {\n         }\n         return PosixPath {\n             is_absolute: self.is_absolute,\n-            components: move cs\n+            components: cs\n         }\n                           //..self }\n     }\n@@ -577,10 +577,10 @@ impl GenericPath for WindowsPath {\n         let mut components =\n             str::split_nonempty(rest, |c| windows::is_sep(c as u8));\n         let is_absolute = (rest.len() != 0 && windows::is_sep(rest[0]));\n-        return WindowsPath { host: move host,\n-                             device: move device,\n+        return WindowsPath { host: host,\n+                             device: device,\n                              is_absolute: is_absolute,\n-                             components: move components }\n+                             components: components }\n     }\n \n     pure fn dirname() -> ~str {\n@@ -589,7 +589,7 @@ impl GenericPath for WindowsPath {\n             if s.len() == 0 {\n                 ~\".\"\n             } else {\n-                move s\n+                s\n             }\n         }\n     }\n@@ -629,7 +629,7 @@ impl GenericPath for WindowsPath {\n         let dpath = WindowsPath(d);\n         match self.filename() {\n           Some(ref f) => dpath.push(*f),\n-          None => move dpath\n+          None => dpath\n         }\n     }\n \n@@ -677,7 +677,7 @@ impl GenericPath for WindowsPath {\n         return WindowsPath { host: None,\n                              device: None,\n                              is_absolute: false,\n-                             components: move cs }\n+                             components: cs }\n     }\n \n     pure fn push_rel(other: &WindowsPath) -> WindowsPath {\n@@ -691,22 +691,22 @@ impl GenericPath for WindowsPath {\n             let mut ss = str::split_nonempty(\n                 *e,\n                 |c| windows::is_sep(c as u8));\n-            unsafe { v.push_all_move(move ss); }\n+            unsafe { v.push_all_move(ss); }\n         }\n         // tedious, but as-is, we can't use ..self\n         return WindowsPath {\n             host: copy self.host,\n             device: copy self.device,\n             is_absolute: self.is_absolute,\n-            components: move v\n+            components: v\n         }\n     }\n \n     pure fn push(s: &str) -> WindowsPath {\n         let mut v = copy self.components;\n         let mut ss = str::split_nonempty(s, |c| windows::is_sep(c as u8));\n-        unsafe { v.push_all_move(move ss); }\n-        return WindowsPath { components: move v, ..copy self }\n+        unsafe { v.push_all_move(ss); }\n+        return WindowsPath { components: v, ..copy self }\n     }\n \n     pure fn pop() -> WindowsPath {\n@@ -718,7 +718,7 @@ impl GenericPath for WindowsPath {\n             host: copy self.host,\n             device: copy self.device,\n             is_absolute: self.is_absolute,\n-            components: move cs\n+            components: cs\n         }\n     }\n \n@@ -748,7 +748,7 @@ pub pure fn normalize(components: &[~str]) -> ~[~str] {\n             }\n         }\n     }\n-    move cs\n+    cs\n }\n \n // Various windows helpers, and tests for the impl.\n@@ -771,7 +771,7 @@ pub mod windows {\n                 if s[i] == '\\\\' as u8 {\n                     let pre = s.slice(2, i);\n                     let rest = s.slice(i, s.len());\n-                    return Some((move pre, move rest));\n+                    return Some((pre, rest));\n                 }\n                 i += 1;\n             }\n@@ -789,7 +789,7 @@ pub mod windows {\n                 } else {\n                     s.slice(2, s.len())\n                 };\n-                return Some((s.slice(0,1), move rest));\n+                return Some((s.slice(0,1), rest));\n             }\n             None\n         }"}, {"sha": "b9e07135f2c9b7579c798844a15d7c3cfdac3d48", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -101,7 +101,7 @@ use vec;\n const SPIN_COUNT: uint = 0;\n \n macro_rules! move_it (\n-    { $x:expr } => ( unsafe { let y = move *ptr::addr_of(&($x)); move y } )\n+    { $x:expr } => ( unsafe { let y = *ptr::addr_of(&($x)); y } )\n )\n \n #[doc(hidden)]\n@@ -233,15 +233,15 @@ fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n     unsafe {\n         b.data.header.buffer = reinterpret_cast(&b);\n     }\n-    move b\n+    b\n }\n \n #[doc(hidden)]\n pub fn packet<T>() -> *Packet<T> {\n     let b = unibuffer();\n     let p = ptr::addr_of(&(b.data));\n     // We'll take over memory management from here.\n-    unsafe { forget(move b) }\n+    unsafe { forget(b) }\n     p\n }\n \n@@ -252,7 +252,7 @@ pub fn entangle_buffer<T: Owned, Tstart: Owned>(\n     -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n {\n     let p = init(unsafe { reinterpret_cast(&buffer) }, &buffer.data);\n-    unsafe { forget(move buffer) }\n+    unsafe { forget(buffer) }\n     (SendPacketBuffered(p), RecvPacketBuffered(p))\n }\n \n@@ -295,7 +295,7 @@ pub fn swap_task(dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n     // It might be worth making both acquire and release versions of\n     // this.\n     unsafe {\n-        transmute(rusti::atomic_xchg(transmute(move dst), src as int))\n+        transmute(rusti::atomic_xchg(transmute(dst), src as int))\n     }\n }\n \n@@ -335,14 +335,14 @@ fn wait_event(this: *rust_task) -> *libc::c_void {\n #[doc(hidden)]\n fn swap_state_acq(dst: &mut State, src: State) -> State {\n     unsafe {\n-        transmute(rusti::atomic_xchg_acq(transmute(move dst), src as int))\n+        transmute(rusti::atomic_xchg_acq(transmute(dst), src as int))\n     }\n }\n \n #[doc(hidden)]\n fn swap_state_rel(dst: &mut State, src: State) -> State {\n     unsafe {\n-        transmute(rusti::atomic_xchg_rel(transmute(move dst), src as int))\n+        transmute(rusti::atomic_xchg_rel(transmute(dst), src as int))\n     }\n }\n \n@@ -368,7 +368,7 @@ struct BufferResource<T> {\n                 // go go gadget drop glue\n             }\n             else {\n-                forget(move b)\n+                forget(b)\n             }\n         }\n     }\n@@ -381,7 +381,7 @@ fn BufferResource<T>(b: ~Buffer<T>) -> BufferResource<T> {\n \n     BufferResource {\n         // tjc: ????\n-        buffer: move b\n+        buffer: b\n     }\n }\n \n@@ -392,7 +392,7 @@ pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n     let p = unsafe { &*p_ };\n     assert ptr::addr_of(&(p.header)) == header;\n     assert p.payload.is_none();\n-    p.payload = move Some(move payload);\n+    p.payload = Some(payload);\n     let old_state = swap_state_rel(&mut p.header.state, Full);\n     match old_state {\n         Empty => {\n@@ -434,7 +434,7 @@ Fails if the sender closes the connection.\n */\n pub fn recv<T: Owned, Tbuffer: Owned>(\n     p: RecvPacketBuffered<T, Tbuffer>) -> T {\n-    try_recv(move p).expect(\"connection closed\")\n+    try_recv(p).expect(\"connection closed\")\n }\n \n /** Attempts to receive a message from a pipe.\n@@ -474,7 +474,7 @@ pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n         let mut payload = None;\n         payload <-> p.payload;\n         p.header.state = Empty;\n-        return Some(option::unwrap(move payload))\n+        return Some(option::unwrap(payload))\n       },\n       Terminated => return None,\n       _ => {}\n@@ -532,7 +532,7 @@ pub fn try_recv<T: Owned, Tbuffer: Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n                 }\n             }\n             p.header.state = Empty;\n-            return Some(option::unwrap(move payload))\n+            return Some(option::unwrap(payload))\n           }\n           Terminated => {\n             // This assert detects when we've accidentally unsafely\n@@ -723,8 +723,8 @@ pub fn select2<A: Owned, Ab: Owned, B: Owned, Bb: Owned>(\n     let i = wait_many([a.header(), b.header()]);\n \n     match i {\n-      0 => Left((try_recv(move a), move b)),\n-      1 => Right((move a, try_recv(move b))),\n+      0 => Left((try_recv(a), b)),\n+      1 => Right((a, try_recv(b))),\n       _ => fail!(~\"select2 return an invalid packet\")\n     }\n }\n@@ -761,10 +761,10 @@ pub fn select<T: Owned, Tb: Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n     -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n-    let mut remaining = move endpoints;\n+    let mut remaining = endpoints;\n     let port = remaining.swap_remove(ready);\n-    let result = try_recv(move port);\n-    (ready, move result, move remaining)\n+    let result = try_recv(port);\n+    (ready, result, remaining)\n }\n \n /** The sending end of a pipe. It can be used to send exactly one\n@@ -791,7 +791,7 @@ impl<T:Owned,Tbuffer:Owned> ::ops::Drop for SendPacketBuffered<T,Tbuffer> {\n         if self.p != None {\n             let mut p = None;\n             p <-> self.p;\n-            sender_terminate(option::unwrap(move p))\n+            sender_terminate(option::unwrap(p))\n         }\n         //unsafe { error!(\"send_drop: %?\",\n         //                if self.buffer == none {\n@@ -816,7 +816,7 @@ impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n     fn unwrap() -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n-        option::unwrap(move p)\n+        option::unwrap(p)\n     }\n \n     pure fn header() -> *PacketHeader {\n@@ -835,7 +835,7 @@ impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n         //error!(\"send reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n-        option::unwrap(move tmp)\n+        option::unwrap(tmp)\n     }\n }\n \n@@ -860,7 +860,7 @@ impl<T:Owned, Tbuffer:Owned> ::ops::Drop for RecvPacketBuffered<T,Tbuffer> {\n         if self.p != None {\n             let mut p = None;\n             p <-> self.p;\n-            receiver_terminate(option::unwrap(move p))\n+            receiver_terminate(option::unwrap(p))\n         }\n         //unsafe { error!(\"recv_drop: %?\",\n         //                if self.buffer == none {\n@@ -873,14 +873,14 @@ impl<T: Owned, Tbuffer: Owned> RecvPacketBuffered<T, Tbuffer> {\n     fn unwrap() -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n-        option::unwrap(move p)\n+        option::unwrap(p)\n     }\n \n     fn reuse_buffer() -> BufferResource<Tbuffer> {\n         //error!(\"recv reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n-        option::unwrap(move tmp)\n+        option::unwrap(tmp)\n     }\n }\n \n@@ -933,14 +933,14 @@ pub fn spawn_service<T: Owned, Tb: Owned>(\n \n     // This is some nasty gymnastics required to safely move the pipe\n     // into a new task.\n-    let server = ~mut Some(move server);\n-    do task::spawn |move service, move server| {\n+    let server = ~mut Some(server);\n+    do task::spawn || {\n         let mut server_ = None;\n         server_ <-> *server;\n-        service(option::unwrap(move server_))\n+        service(option::unwrap(server_))\n     }\n \n-    move client\n+    client\n }\n \n /** Like `spawn_service_recv`, but for protocols that start in the\n@@ -957,14 +957,14 @@ pub fn spawn_service_recv<T: Owned, Tb: Owned>(\n \n     // This is some nasty gymnastics required to safely move the pipe\n     // into a new task.\n-    let server = ~mut Some(move server);\n-    do task::spawn |move service, move server| {\n+    let server = ~mut Some(server);\n+    do task::spawn || {\n         let mut server_ = None;\n         server_ <-> *server;\n-        service(option::unwrap(move server_))\n+        service(option::unwrap(server_))\n     }\n \n-    move client\n+    client\n }\n \n // Streams - Make pipes a little easier in general.\n@@ -1041,7 +1041,7 @@ impl<T: Owned> GenericChan<T> for Chan<T> {\n         let mut endp = None;\n         endp <-> self.endp;\n         self.endp = Some(\n-            streamp::client::data(unwrap(move endp), move x))\n+            streamp::client::data(unwrap(endp), x))\n     }\n }\n \n@@ -1050,9 +1050,9 @@ impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n     fn try_send(x: T) -> bool {\n         let mut endp = None;\n         endp <-> self.endp;\n-        match move streamp::client::try_data(unwrap(move endp), move x) {\n-            Some(move next) => {\n-                self.endp = Some(move next);\n+        match streamp::client::try_data(unwrap(endp), x) {\n+            Some(next) => {\n+                self.endp = Some(next);\n                 true\n             }\n             None => false\n@@ -1064,18 +1064,18 @@ impl<T: Owned> GenericPort<T> for Port<T> {\n     fn recv() -> T {\n         let mut endp = None;\n         endp <-> self.endp;\n-        let streamp::data(x, endp) = pipes::recv(unwrap(move endp));\n-        self.endp = Some(move endp);\n-        move x\n+        let streamp::data(x, endp) = pipes::recv(unwrap(endp));\n+        self.endp = Some(endp);\n+        x\n     }\n \n     fn try_recv() -> Option<T> {\n         let mut endp = None;\n         endp <-> self.endp;\n-        match move pipes::try_recv(unwrap(move endp)) {\n-          Some(streamp::data(move x, move endp)) => {\n-            self.endp = Some(move endp);\n-            Some(move x)\n+        match pipes::try_recv(unwrap(endp)) {\n+          Some(streamp::data(x, endp)) => {\n+            self.endp = Some(endp);\n+            Some(x)\n           }\n           None => None\n         }\n@@ -1122,13 +1122,13 @@ pub fn PortSet<T: Owned>() -> PortSet<T>{\n impl<T: Owned> PortSet<T> {\n \n     fn add(port: pipes::Port<T>) {\n-        self.ports.push(move port)\n+        self.ports.push(port)\n     }\n \n     fn chan() -> Chan<T> {\n         let (po, ch) = stream();\n-        self.add(move po);\n-        move ch\n+        self.add(po);\n+        ch\n     }\n }\n \n@@ -1142,9 +1142,9 @@ impl<T: Owned> GenericPort<T> for PortSet<T> {\n         ports <-> self.ports;\n         while result.is_none() && ports.len() > 0 {\n             let i = wait_many(ports);\n-            match move ports[i].try_recv() {\n-                Some(move m) => {\n-                  result = Some(move m);\n+            match ports[i].try_recv() {\n+                Some(m) => {\n+                  result = Some(m);\n                 }\n                 None => {\n                     // Remove this port.\n@@ -1153,7 +1153,7 @@ impl<T: Owned> GenericPort<T> for PortSet<T> {\n             }\n         }\n         ports <-> self.ports;\n-        move result\n+        result\n     }\n \n     fn recv() -> T {\n@@ -1178,29 +1178,29 @@ pub type SharedChan<T> = private::Exclusive<Chan<T>>;\n \n impl<T: Owned> GenericChan<T> for SharedChan<T> {\n     fn send(x: T) {\n-        let mut xx = Some(move x);\n+        let mut xx = Some(x);\n         do self.with_imm |chan| {\n             let mut x = None;\n             x <-> xx;\n-            chan.send(option::unwrap(move x))\n+            chan.send(option::unwrap(x))\n         }\n     }\n }\n \n impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n     fn try_send(x: T) -> bool {\n-        let mut xx = Some(move x);\n+        let mut xx = Some(x);\n         do self.with_imm |chan| {\n             let mut x = None;\n             x <-> xx;\n-            chan.try_send(option::unwrap(move x))\n+            chan.try_send(option::unwrap(x))\n         }\n     }\n }\n \n /// Converts a `chan` into a `shared_chan`.\n pub fn SharedChan<T:Owned>(c: Chan<T>) -> SharedChan<T> {\n-    private::exclusive(move c)\n+    private::exclusive(c)\n }\n \n /// Receive a message from one of two endpoints.\n@@ -1267,24 +1267,24 @@ impl<T: Owned> ChanOne<T> {\n  * closed.\n  */\n pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n-    let oneshot::send(message) = recv(move port);\n-    move message\n+    let oneshot::send(message) = recv(port);\n+    message\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n-    let message = try_recv(move port);\n+    let message = try_recv(port);\n \n     if message.is_none() { None }\n     else {\n-        let oneshot::send(message) = option::unwrap(move message);\n-        Some(move message)\n+        let oneshot::send(message) = option::unwrap(message);\n+        Some(message)\n     }\n }\n \n /// Send a message on a oneshot pipe, failing if the connection was closed.\n pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n-    oneshot::client::send(move chan, move data);\n+    oneshot::client::send(chan, data);\n }\n \n /**\n@@ -1293,15 +1293,15 @@ pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n  */\n pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T)\n         -> bool {\n-    oneshot::client::try_send(move chan, move data).is_some()\n+    oneshot::client::try_send(chan, data).is_some()\n }\n \n pub mod rt {\n     use option::{None, Option, Some};\n \n     // These are used to hide the option constructors from the\n     // compiler because their names are changing\n-    pub fn make_some<T>(val: T) -> Option<T> { Some(move val) }\n+    pub fn make_some<T>(val: T) -> Option<T> { Some(val) }\n     pub fn make_none<T>() -> Option<T> { None }\n }\n \n@@ -1318,7 +1318,7 @@ pub mod test {\n \n         c1.send(~\"abc\");\n \n-        match (move p1, move p2).select() {\n+        match (p1, p2).select() {\n           Right(_) => fail!(),\n           _ => ()\n         }\n@@ -1330,9 +1330,9 @@ pub mod test {\n     pub fn test_oneshot() {\n         let (c, p) = oneshot::init();\n \n-        oneshot::client::send(move c, ());\n+        oneshot::client::send(c, ());\n \n-        recv_one(move p)\n+        recv_one(p)\n     }\n \n     #[test]\n@@ -1341,7 +1341,7 @@ pub mod test {\n \n         {\n             // Destroy the channel\n-            let _chan = move chan;\n+            let _chan = chan;\n         }\n \n         assert !port.peek();"}, {"sha": "5b69c348c1591174544e3731734c7162519641a5", "filename": "src/libcore/private.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -145,19 +145,19 @@ struct ArcDestruct<T> {\n                             cast::reinterpret_cast(&data.unwrapper);\n                         let (message, response) = option::swap_unwrap(p);\n                         // Send 'ready' and wait for a response.\n-                        pipes::send_one(move message, ());\n+                        pipes::send_one(message, ());\n                         // Unkillable wait. Message guaranteed to come.\n-                        if pipes::recv_one(move response) {\n+                        if pipes::recv_one(response) {\n                             // Other task got the data.\n-                            cast::forget(move data);\n+                            cast::forget(data);\n                         } else {\n                             // Other task was killed. drop glue takes over.\n                         }\n                     } else {\n                         // drop glue takes over.\n                     }\n                 } else {\n-                    cast::forget(move data);\n+                    cast::forget(data);\n                 }\n             }\n         }\n@@ -182,13 +182,13 @@ pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n                 // tried to wake us whether they should hand-off the data to\n                 // us.\n                 if task::failing() {\n-                    pipes::send_one(move response, false);\n+                    pipes::send_one(response, false);\n                     // Either this swap_unwrap or the one below (at \"Got\n                     // here\") ought to run.\n                     cast::forget(option::swap_unwrap(&mut self.ptr));\n                 } else {\n                     assert self.ptr.is_none();\n-                    pipes::send_one(move response, true);\n+                    pipes::send_one(response, true);\n                 }\n             }\n         }\n@@ -198,8 +198,8 @@ pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&rc.data);\n         let (p1,c1) = pipes::oneshot(); // ()\n         let (p2,c2) = pipes::oneshot(); // bool\n-        let server: UnwrapProto = ~mut Some((move c1,move p2));\n-        let serverp: int = cast::transmute(move server);\n+        let server: UnwrapProto = ~mut Some((c1,p2));\n+        let serverp: int = cast::transmute(server);\n         // Try to put our server end in the unwrapper slot.\n         if compare_and_swap(&mut ptr.unwrapper, 0, serverp) {\n             // Got in. Step 0: Tell destructor not to run. We are now it.\n@@ -210,15 +210,15 @@ pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n             if new_count == 0 {\n                 // We were the last owner. Can unwrap immediately.\n                 // Also we have to free the server endpoints.\n-                let _server: UnwrapProto = cast::transmute(move serverp);\n+                let _server: UnwrapProto = cast::transmute(serverp);\n                 option::swap_unwrap(&mut ptr.data)\n                 // drop glue takes over.\n             } else {\n                 // The *next* person who sees the refcount hit 0 will wake us.\n                 let end_result =\n-                    DeathThroes { ptr: Some(move ptr),\n-                                  response: Some(move c2) };\n-                let mut p1 = Some(move p1); // argh\n+                    DeathThroes { ptr: Some(ptr),\n+                                  response: Some(c2) };\n+                let mut p1 = Some(p1); // argh\n                 do task::rekillable {\n                     pipes::recv_one(option::swap_unwrap(&mut p1));\n                 }\n@@ -230,9 +230,9 @@ pub unsafe fn unwrap_shared_mutable_state<T: Owned>(rc: SharedMutableState<T>)\n             }\n         } else {\n             // Somebody else was trying to unwrap. Avoid guaranteed deadlock.\n-            cast::forget(move ptr);\n+            cast::forget(ptr);\n             // Also we have to free the (rejected) server endpoints.\n-            let _server: UnwrapProto = cast::transmute(move serverp);\n+            let _server: UnwrapProto = cast::transmute(serverp);\n             fail!(~\"Another task is already unwrapping this ARC!\");\n         }\n     }\n@@ -248,9 +248,9 @@ pub type SharedMutableState<T> = ArcDestruct<T>;\n \n pub unsafe fn shared_mutable_state<T: Owned>(data: T) ->\n         SharedMutableState<T> {\n-    let data = ~ArcData { count: 1, unwrapper: 0, data: Some(move data) };\n+    let data = ~ArcData { count: 1, unwrapper: 0, data: Some(data) };\n     unsafe {\n-        let ptr = cast::transmute(move data);\n+        let ptr = cast::transmute(data);\n         ArcDestruct(ptr)\n     }\n }\n@@ -263,7 +263,7 @@ pub unsafe fn get_shared_mutable_state<T: Owned>(\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         assert ptr.count > 0;\n         let r = cast::transmute(option::get_ref(&ptr.data));\n-        cast::forget(move ptr);\n+        cast::forget(ptr);\n         return r;\n     }\n }\n@@ -275,7 +275,7 @@ pub unsafe fn get_shared_immutable_state<T: Owned>(\n         assert ptr.count > 0;\n         // Cast us back into the correct region\n         let r = cast::transmute_region(option::get_ref(&ptr.data));\n-        cast::forget(move ptr);\n+        cast::forget(ptr);\n         return r;\n     }\n }\n@@ -286,7 +286,7 @@ pub unsafe fn clone_shared_mutable_state<T: Owned>(rc: &SharedMutableState<T>)\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         let new_count = rusti::atomic_xadd(&mut ptr.count, 1) + 1;\n         assert new_count >= 2;\n-        cast::forget(move ptr);\n+        cast::forget(ptr);\n     }\n     ArcDestruct((*rc).data)\n }\n@@ -355,9 +355,9 @@ pub struct Exclusive<T> { x: SharedMutableState<ExData<T>> }\n \n pub fn exclusive<T:Owned >(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n-        lock: LittleLock(), mut failed: false, mut data: move user_data\n+        lock: LittleLock(), mut failed: false, mut data: user_data\n     };\n-    Exclusive { x: unsafe { shared_mutable_state(move data) } }\n+    Exclusive { x: unsafe { shared_mutable_state(data) } }\n }\n \n impl<T: Owned> Clone for Exclusive<T> {\n@@ -386,7 +386,7 @@ impl<T: Owned> Exclusive<T> {\n                 (*rec).failed = true;\n                 let result = f(&mut (*rec).data);\n                 (*rec).failed = false;\n-                move result\n+                result\n             }\n         }\n     }\n@@ -401,10 +401,10 @@ impl<T: Owned> Exclusive<T> {\n \n // FIXME(#3724) make this a by-move method on the exclusive\n pub fn unwrap_exclusive<T: Owned>(arc: Exclusive<T>) -> T {\n-    let Exclusive { x: x } = move arc;\n-    let inner = unsafe { unwrap_shared_mutable_state(move x) };\n-    let ExData { data: data, _ } = move inner;\n-    move data\n+    let Exclusive { x: x } = arc;\n+    let inner = unsafe { unwrap_shared_mutable_state(x) };\n+    let ExData { data: data, _ } = inner;\n+    data\n }\n \n #[cfg(test)]\n@@ -430,9 +430,9 @@ pub mod tests {\n         for uint::range(0, num_tasks) |_i| {\n             let total = total.clone();\n             let (port, chan) = pipes::stream();\n-            futures.push(move port);\n+            futures.push(port);\n \n-            do task::spawn |move total, move chan| {\n+            do task::spawn || {\n                 for uint::range(0, count) |_i| {\n                     do total.with |count| {\n                         **count += 1;\n@@ -455,7 +455,7 @@ pub mod tests {\n         // accesses will also fail.\n         let x = exclusive(1);\n         let x2 = x.clone();\n-        do task::try |move x2| {\n+        do task::try || {\n             do x2.with |one| {\n                 assert *one == 2;\n             }\n@@ -468,31 +468,31 @@ pub mod tests {\n     #[test]\n     pub fn exclusive_unwrap_basic() {\n         let x = exclusive(~~\"hello\");\n-        assert unwrap_exclusive(move x) == ~~\"hello\";\n+        assert unwrap_exclusive(x) == ~~\"hello\";\n     }\n \n     #[test]\n     pub fn exclusive_unwrap_contended() {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n-        do task::spawn |move x2| {\n+        do task::spawn || {\n             let x2 = option::swap_unwrap(x2);\n             do x2.with |_hello| { }\n             task::yield();\n         }\n-        assert unwrap_exclusive(move x) == ~~\"hello\";\n+        assert unwrap_exclusive(x) == ~~\"hello\";\n \n         // Now try the same thing, but with the child task blocking.\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n         let mut res = None;\n-        do task::task().future_result(|+r| res = Some(move r)).spawn\n-              |move x2| {\n+        do task::task().future_result(|+r| res = Some(r)).spawn\n+              || {\n             let x2 = option::swap_unwrap(x2);\n-            assert unwrap_exclusive(move x2) == ~~\"hello\";\n+            assert unwrap_exclusive(x2) == ~~\"hello\";\n         }\n         // Have to get rid of our reference before blocking.\n-        { let _x = move x; } // FIXME(#3161) util::ignore doesn't work here\n+        { let _x = x; } // FIXME(#3161) util::ignore doesn't work here\n         let res = option::swap_unwrap(&mut res);\n         res.recv();\n     }\n@@ -502,12 +502,12 @@ pub mod tests {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n         let mut res = None;\n-        do task::task().future_result(|+r| res = Some(move r)).spawn\n-           |move x2| {\n+        do task::task().future_result(|+r| res = Some(r)).spawn\n+           || {\n             let x2 = option::swap_unwrap(x2);\n-            assert unwrap_exclusive(move x2) == ~~\"hello\";\n+            assert unwrap_exclusive(x2) == ~~\"hello\";\n         }\n-        assert unwrap_exclusive(move x) == ~~\"hello\";\n+        assert unwrap_exclusive(x) == ~~\"hello\";\n         let res = option::swap_unwrap(&mut res);\n         res.recv();\n     }\n@@ -526,7 +526,7 @@ pub mod tests {\n                 for 10.times { task::yield(); } // try to let the unwrapper go\n                 fail!(); // punt it awake from its deadlock\n             }\n-            let _z = unwrap_exclusive(move x);\n+            let _z = unwrap_exclusive(x);\n             do x2.with |_hello| { }\n         };\n         assert result.is_err();"}, {"sha": "cc747521030c93802f8107ff8d81b1a0335a4ffd", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -273,7 +273,7 @@ impl Rng {\n             s = s + str::from_char(self.gen_char_from(charset));\n             i += 1u;\n         }\n-        move s\n+        s\n     }\n \n     /// Return a random byte string of the specified length\n@@ -339,14 +339,14 @@ impl Rng {\n                 r.push(item.item);\n             }\n         }\n-        move r\n+        r\n     }\n \n     /// Shuffle a vec\n     fn shuffle<T:Copy>(values: &[T]) -> ~[T] {\n         let mut m = vec::from_slice(values);\n         self.shuffle_mut(m);\n-        move m\n+        m\n     }\n \n     /// Shuffle a mutable vec in place"}, {"sha": "8983c63f42a1ff2e779d2a80a556ac53b96011a4", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -42,7 +42,7 @@ pub struct MovePtrAdaptor<V> {\n     inner: V\n }\n pub fn MovePtrAdaptor<V: TyVisitor MovePtr>(v: V) -> MovePtrAdaptor<V> {\n-    MovePtrAdaptor { inner: move v }\n+    MovePtrAdaptor { inner: v }\n }\n \n impl<V: TyVisitor MovePtr> MovePtrAdaptor<V> {"}, {"sha": "7f1687b08608a20d37f5f548137310ec7bc83cfc", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -200,8 +200,8 @@ impl ReprVisitor {\n     fn visit_ptr_inner(ptr: *c_void, inner: *TyDesc) -> bool {\n         unsafe {\n             let mut u = ReprVisitor(ptr, self.writer);\n-            let v = reflect::MovePtrAdaptor(move u);\n-            visit_tydesc(inner, (move v) as @TyVisitor);\n+            let v = reflect::MovePtrAdaptor(u);\n+            visit_tydesc(inner, (v) as @TyVisitor);\n             true\n         }\n     }\n@@ -569,8 +569,8 @@ pub fn write_repr<T>(writer: @Writer, object: &T) {\n         let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n         let tydesc = intrinsic::get_tydesc::<T>();\n         let mut u = ReprVisitor(ptr, writer);\n-        let v = reflect::MovePtrAdaptor(move u);\n-        visit_tydesc(tydesc, (move v) as @TyVisitor)\n+        let v = reflect::MovePtrAdaptor(u);\n+        visit_tydesc(tydesc, (v) as @TyVisitor)\n     }\n }\n "}, {"sha": "64c62c925849fa87f98993c5414086ec3e04d1ac", "filename": "src/libcore/result.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -125,9 +125,9 @@ pub pure fn to_either<T: Copy, U: Copy>(res: &Result<U, T>)\n #[inline(always)]\n pub pure fn chain<T, U, V>(res: Result<T, V>, op: fn(T)\n     -> Result<U, V>) -> Result<U, V> {\n-    match move res {\n-        Ok(move t) => op(move t),\n-        Err(move e) => Err(move e)\n+    match res {\n+        Ok(t) => op(t),\n+        Err(e) => Err(e)\n     }\n }\n \n@@ -144,9 +144,9 @@ pub pure fn chain_err<T, U, V>(\n     res: Result<T, V>,\n     op: fn(t: V) -> Result<T, U>)\n     -> Result<T, U> {\n-    match move res {\n-      Ok(move t) => Ok(move t),\n-      Err(move v) => op(move v)\n+    match res {\n+      Ok(t) => Ok(t),\n+      Err(v) => op(v)\n     }\n }\n \n@@ -309,7 +309,7 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n           Err(copy u) => return Err(u)\n         }\n     }\n-    return Ok(move vs);\n+    return Ok(vs);\n }\n \n #[inline(always)]\n@@ -349,7 +349,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n         }\n         i += 1u;\n     }\n-    return Ok(move vs);\n+    return Ok(vs);\n }\n \n /**\n@@ -377,17 +377,17 @@ pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n /// Unwraps a result, assuming it is an `ok(T)`\n #[inline(always)]\n pub pure fn unwrap<T, U>(res: Result<T, U>) -> T {\n-    match move res {\n-      Ok(move t) => move t,\n+    match res {\n+      Ok(t) => t,\n       Err(_) => fail!(~\"unwrap called on an err result\")\n     }\n }\n \n /// Unwraps a result, assuming it is an `err(U)`\n #[inline(always)]\n pub pure fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n-    match move res {\n-      Err(move u) => move u,\n+    match res {\n+      Err(u) => u,\n       Ok(_) => fail!(~\"unwrap called on an ok result\")\n     }\n }"}, {"sha": "5103025d1205193b1b58a50030163c53a1900ba3", "filename": "src/libcore/run.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -258,7 +258,7 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n \n     fn ProgRes(r: ProgRepr) -> ProgRes {\n         ProgRes {\n-            r: move r\n+            r: r\n         }\n     }\n \n@@ -344,11 +344,11 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n         let ch_clone = ch.clone();\n         do task::spawn_sched(task::SingleThreaded) {\n             let errput = readclose(pipe_err.in);\n-            ch.send((2, move errput));\n+            ch.send((2, errput));\n         };\n         do task::spawn_sched(task::SingleThreaded) {\n             let output = readclose(pipe_out.in);\n-            ch_clone.send((1, move output));\n+            ch_clone.send((1, output));\n         };\n         let status = run::waitpid(pid);\n         let mut errs = ~\"\";\n@@ -358,10 +358,10 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n             let stream = p.recv();\n             match stream {\n                 (1, copy s) => {\n-                    outs = move s;\n+                    outs = s;\n                 }\n                 (2, copy s) => {\n-                    errs = move s;\n+                    errs = s;\n                 }\n                 (n, _) => {\n                     fail!(fmt!(\"program_output received an unexpected file \\\n@@ -371,8 +371,8 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n             count -= 1;\n         };\n         return ProgramOutput {status: status,\n-                              out: move outs,\n-                              err: move errs};\n+                              out: outs,\n+                              err: errs};\n     }\n }\n "}, {"sha": "afc9d7f1417e44110adfefbc3e0fff5457b045e2", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -216,7 +216,7 @@ pub mod tests {\n \n             assert f(20) == 30;\n \n-            let original_closure: Closure = cast::transmute(move f);\n+            let original_closure: Closure = cast::transmute(f);\n \n             let actual_function_pointer = original_closure.code;\n             let environment = original_closure.env;\n@@ -226,7 +226,7 @@ pub mod tests {\n                 env: environment\n             };\n \n-            let new_f: fn(int) -> int = cast::transmute(move new_closure);\n+            let new_f: fn(int) -> int = cast::transmute(new_closure);\n             assert new_f(20) == 30;\n         }\n     }"}, {"sha": "949c36545dd0341027b17fdc8c02cc0adf452fbd", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -73,7 +73,7 @@ unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n         cast::bump_box_refcount(map);\n         map\n     } else {\n-        let map = cast::transmute(move map_ptr);\n+        let map = cast::transmute(map_ptr);\n         cast::bump_box_refcount(map);\n         map\n     }\n@@ -119,7 +119,7 @@ unsafe fn local_get_helper<T: Durable>(\n         // overwriting the local_data_box we need to give an extra reference.\n         // We must also give an extra reference when not removing.\n         let (index, data_ptr) = *result;\n-        let data: @T = cast::transmute(move data_ptr);\n+        let data: @T = cast::transmute(data_ptr);\n         cast::bump_box_refcount(data);\n         if do_pop {\n             (*map).set_elt(index, None);\n@@ -182,6 +182,6 @@ pub unsafe fn local_modify<T: Durable>(\n     // Could be more efficient by doing the lookup work, but this is easy.\n     let newdata = modify_fn(local_pop(task, key));\n     if newdata.is_some() {\n-        local_set(task, key, option::unwrap(move newdata));\n+        local_set(task, key, option::unwrap(newdata));\n     }\n }"}, {"sha": "4b15d1f76c98a70e096734b01fef5dd3b05d2302", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 37, "deletions": 41, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -203,7 +203,7 @@ pub struct TaskBuilder {\n pub fn task() -> TaskBuilder {\n     TaskBuilder {\n         opts: default_task_opts(),\n-        gen_body: |body| move body, // Identity function\n+        gen_body: |body| body, // Identity function\n         can_not_copy: None,\n         mut consumed: false,\n     }\n@@ -315,7 +315,7 @@ impl TaskBuilder {\n         // Construct the future and give it to the caller.\n         let (notify_pipe_po, notify_pipe_ch) = stream::<TaskResult>();\n \n-        blk(move notify_pipe_po);\n+        blk(notify_pipe_po);\n \n         // Reconfigure self to use a notify channel.\n         TaskBuilder {\n@@ -336,7 +336,7 @@ impl TaskBuilder {\n             opts: TaskOpts {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n-                notify_chan: move notify_chan,\n+                notify_chan: notify_chan,\n                 sched: SchedOpts { mode: mode, foreign_stack_size: None}\n             },\n             can_not_copy: None,\n@@ -366,11 +366,7 @@ impl TaskBuilder {\n                 notify_chan: notify_chan,\n                 sched: self.opts.sched\n             },\n-            // tjc: I think this is the line that gets miscompiled\n-            // w/ last-use off, if we leave out the move prev_gen_body?\n-            // that makes no sense, though...\n-            gen_body: |move prev_gen_body,\n-                       body| { wrapper(prev_gen_body(move body)) },\n+            gen_body: |body| { wrapper(prev_gen_body(body)) },\n             can_not_copy: None,\n             .. self.consume()\n         }\n@@ -397,12 +393,12 @@ impl TaskBuilder {\n             notify_chan: notify_chan,\n             sched: x.opts.sched\n         };\n-        spawn::spawn_raw(move opts, (x.gen_body)(move f));\n+        spawn::spawn_raw(opts, (x.gen_body)(f));\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n     fn spawn_with<A: Owned>(arg: A, f: fn~(v: A)) {\n-        let arg = ~mut Some(move arg);\n-        do self.spawn |move arg, move f| {\n+        let arg = ~mut Some(arg);\n+        do self.spawn || {\n             f(option::swap_unwrap(arg))\n         }\n     }\n@@ -425,12 +421,12 @@ impl TaskBuilder {\n         let mut result = None;\n \n         let fr_task_builder = self.future_result(|+r| {\n-            result = Some(move r);\n+            result = Some(r);\n         });\n-        do fr_task_builder.spawn |move f, move ch| {\n+        do fr_task_builder.spawn || {\n             ch.send(f());\n         }\n-        match option::unwrap(move result).recv() {\n+        match option::unwrap(result).recv() {\n             Success => result::Ok(po.recv()),\n             Failure => result::Err(())\n         }\n@@ -471,7 +467,7 @@ pub fn spawn(f: fn~()) {\n      * This function is equivalent to `task().spawn(f)`.\n      */\n \n-    task().spawn(move f)\n+    task().spawn(f)\n }\n \n pub fn spawn_unlinked(f: fn~()) {\n@@ -480,7 +476,7 @@ pub fn spawn_unlinked(f: fn~()) {\n      * task or the child task fails, the other will not be killed.\n      */\n \n-    task().unlinked().spawn(move f)\n+    task().unlinked().spawn(f)\n }\n \n pub fn spawn_supervised(f: fn~()) {\n@@ -489,7 +485,7 @@ pub fn spawn_supervised(f: fn~()) {\n      * task or the child task fails, the other will not be killed.\n      */\n \n-    task().supervised().spawn(move f)\n+    task().supervised().spawn(f)\n }\n \n pub fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n@@ -503,7 +499,7 @@ pub fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n      * This function is equivalent to `task().spawn_with(arg, f)`.\n      */\n \n-    task().spawn_with(move arg, move f)\n+    task().spawn_with(arg, f)\n }\n \n pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n@@ -519,7 +515,7 @@ pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n      * greater than zero.\n      */\n \n-    task().sched_mode(mode).spawn(move f)\n+    task().sched_mode(mode).spawn(f)\n }\n \n pub fn try<T:Owned>(f: fn~() -> T) -> Result<T,()> {\n@@ -530,7 +526,7 @@ pub fn try<T:Owned>(f: fn~() -> T) -> Result<T,()> {\n      * This is equivalent to task().supervised().try.\n      */\n \n-    task().supervised().try(move f)\n+    task().supervised().try(f)\n }\n \n \n@@ -719,12 +715,12 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n         let mut opts = default_task_opts();\n         opts.linked = true;\n         opts.supervised = true;\n-        move opts\n+        opts\n     };\n \n     let b0 = task();\n     let b1 = TaskBuilder {\n-        opts: move opts,\n+        opts: opts,\n         can_not_copy: None,\n         .. b0\n     };\n@@ -739,12 +735,12 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n         let mut opts = default_task_opts();\n         opts.linked = true;\n         opts.supervised = true;\n-        move opts\n+        opts\n     };\n \n     let b0 = task();\n     let b1 = TaskBuilder {\n-        opts: move opts,\n+        opts: opts,\n         can_not_copy: None,\n         .. b0\n     };\n@@ -843,7 +839,7 @@ fn test_add_wrapper() {\n     let ch = Wrapper { f: Some(ch) };\n     let b1 = do b0.add_wrapper |body| {\n         let ch = Wrapper { f: Some(ch.f.swap_unwrap()) };\n-        fn~(move body) {\n+        fn~() {\n             let ch = ch.f.swap_unwrap();\n             body();\n             ch.send(());\n@@ -857,15 +853,15 @@ fn test_add_wrapper() {\n #[ignore(cfg(windows))]\n fn test_future_result() {\n     let mut result = None;\n-    do task().future_result(|+r| { result = Some(move r); }).spawn { }\n-    assert option::unwrap(move result).recv() == Success;\n+    do task().future_result(|+r| { result = Some(r); }).spawn { }\n+    assert option::unwrap(result).recv() == Success;\n \n     result = None;\n     do task().future_result(|+r|\n-        { result = Some(move r); }).unlinked().spawn {\n+        { result = Some(r); }).unlinked().spawn {\n         fail!();\n     }\n-    assert option::unwrap(move result).recv() == Failure;\n+    assert option::unwrap(result).recv() == Failure;\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n@@ -1024,7 +1020,7 @@ fn avoid_copying_the_body(spawnfn: fn(v: fn~())) {\n     let x = ~1;\n     let x_in_parent = ptr::addr_of(&(*x)) as uint;\n \n-    do spawnfn |move x| {\n+    do spawnfn || {\n         let x_in_child = ptr::addr_of(&(*x)) as uint;\n         ch.send(x_in_child);\n     }\n@@ -1041,7 +1037,7 @@ fn test_avoid_copying_the_body_spawn() {\n #[test]\n fn test_avoid_copying_the_body_task_spawn() {\n     do avoid_copying_the_body |f| {\n-        do task().spawn |move f| {\n+        do task().spawn || {\n             f();\n         }\n     }\n@@ -1050,7 +1046,7 @@ fn test_avoid_copying_the_body_task_spawn() {\n #[test]\n fn test_avoid_copying_the_body_try() {\n     do avoid_copying_the_body |f| {\n-        do try |move f| {\n+        do try || {\n             f()\n         };\n     }\n@@ -1059,7 +1055,7 @@ fn test_avoid_copying_the_body_try() {\n #[test]\n fn test_avoid_copying_the_body_unlinked() {\n     do avoid_copying_the_body |f| {\n-        do spawn_unlinked |move f| {\n+        do spawn_unlinked || {\n             f();\n         }\n     }\n@@ -1096,12 +1092,12 @@ fn test_unkillable() {\n     unsafe {\n         do unkillable {\n             let p = ~0;\n-            let pp: *uint = cast::transmute(move p);\n+            let pp: *uint = cast::transmute(p);\n \n             // If we are killed here then the box will leak\n             po.recv();\n \n-            let _p: ~int = cast::transmute(move pp);\n+            let _p: ~int = cast::transmute(pp);\n         }\n     }\n \n@@ -1116,7 +1112,7 @@ fn test_unkillable_nested() {\n     let (po, ch) = pipes::stream();\n \n     // We want to do this after failing\n-    do spawn_unlinked |move ch| {\n+    do spawn_unlinked || {\n         for iter::repeat(10) { yield() }\n         ch.send(());\n     }\n@@ -1132,12 +1128,12 @@ fn test_unkillable_nested() {\n         do unkillable {\n             do unkillable {} // Here's the difference from the previous test.\n             let p = ~0;\n-            let pp: *uint = cast::transmute(move p);\n+            let pp: *uint = cast::transmute(p);\n \n             // If we are killed here then the box will leak\n             po.recv();\n \n-            let _p: ~int = cast::transmute(move pp);\n+            let _p: ~int = cast::transmute(pp);\n         }\n     }\n \n@@ -1181,7 +1177,7 @@ fn test_child_doesnt_ref_parent() {\n fn test_sched_thread_per_core() {\n     let (port, chan) = pipes::stream();\n \n-    do spawn_sched(ThreadPerCore) |move chan| {\n+    do spawn_sched(ThreadPerCore) || {\n         unsafe {\n             let cores = rt::rust_num_threads();\n             let reported_threads = rt::rust_sched_threads();\n@@ -1197,7 +1193,7 @@ fn test_sched_thread_per_core() {\n fn test_spawn_thread_on_demand() {\n     let (port, chan) = pipes::stream();\n \n-    do spawn_sched(ManualThreads(2)) |move chan| {\n+    do spawn_sched(ManualThreads(2)) || {\n         unsafe {\n             let max_threads = rt::rust_sched_threads();\n             assert(max_threads as int == 2);\n@@ -1206,7 +1202,7 @@ fn test_spawn_thread_on_demand() {\n \n             let (port2, chan2) = pipes::stream();\n \n-            do spawn_sched(CurrentScheduler) |move chan2| {\n+            do spawn_sched(CurrentScheduler) || {\n                 chan2.send(());\n             }\n "}, {"sha": "d72cacc2c4be7b71c4190c9ff788c3c565484c3f", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -93,7 +93,7 @@ use uint;\n use util;\n \n macro_rules! move_it (\n-    { $x:expr } => ( unsafe { let y = move *ptr::addr_of(&($x)); move y } )\n+    { $x:expr } => ( unsafe { let y = *ptr::addr_of(&($x)); y } )\n )\n \n type TaskSet = LinearSet<*rust_task>;\n@@ -195,10 +195,10 @@ fn each_ancestor(list:        &mut AncestorList,\n         if coalesce_this.is_some() {\n             // Needed coalesce. Our next ancestor becomes our old\n             // ancestor's next ancestor. (\"next = old_next->next;\")\n-            *list = move option::unwrap(move coalesce_this);\n+            *list = option::unwrap(coalesce_this);\n         } else {\n             // No coalesce; restore from tmp. (\"next = old_next;\")\n-            *list = move tmp_list;\n+            *list = tmp_list;\n         }\n         return early_break;\n     }\n@@ -279,7 +279,7 @@ fn each_ancestor(list:        &mut AncestorList,\n                     // Swap the list out here; the caller replaces us with it.\n                     let rest = util::replace(&mut nobe.ancestors,\n                                              AncestorList(None));\n-                    (Some(move rest), need_unwind)\n+                    (Some(rest), need_unwind)\n                 } else {\n                     (None, need_unwind)\n                 }\n@@ -292,8 +292,8 @@ fn each_ancestor(list:        &mut AncestorList,\n             // If this trips, more likely the problem is 'blk' failed inside.\n             let tmp_arc = option::swap_unwrap(&mut *parent_group);\n             let result = do access_group(&tmp_arc) |tg_opt| { blk(tg_opt) };\n-            *parent_group = move Some(move tmp_arc);\n-            move result\n+            *parent_group = Some(tmp_arc);\n+            result\n         }\n     }\n }\n@@ -337,15 +337,15 @@ struct TCB {\n fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n        is_main: bool, notifier: Option<AutoNotify>) -> TCB {\n \n-    let notifier = move notifier;\n+    let notifier = notifier;\n     notifier.iter(|x| { x.failed = false; });\n \n     TCB {\n         me: me,\n-        tasks: move tasks,\n-        ancestors: move ancestors,\n+        tasks: tasks,\n+        ancestors: ancestors,\n         is_main: is_main,\n-        notifier: move notifier\n+        notifier: notifier\n     }\n }\n \n@@ -360,7 +360,7 @@ struct AutoNotify {\n \n fn AutoNotify(chan: Chan<TaskResult>) -> AutoNotify {\n     AutoNotify {\n-        notify_chan: move chan,\n+        notify_chan: chan,\n         failed: true // Un-set above when taskgroup successfully made.\n     }\n }\n@@ -370,10 +370,10 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n     let newstate = util::replace(&mut *state, None);\n     // If 'None', the group was failing. Can't enlist.\n     if newstate.is_some() {\n-        let group = option::unwrap(move newstate);\n+        let group = option::unwrap(newstate);\n         taskset_insert(if is_member { &mut group.members }\n                        else         { &mut group.descendants }, me);\n-        *state = Some(move group);\n+        *state = Some(group);\n         true\n     } else {\n         false\n@@ -386,10 +386,10 @@ fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n     let newstate = util::replace(&mut *state, None);\n     // If 'None', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n-        let group = option::unwrap(move newstate);\n+        let group = option::unwrap(newstate);\n         taskset_remove(if is_member { &mut group.members }\n                        else         { &mut group.descendants }, me);\n-        *state = Some(move group);\n+        *state = Some(group);\n     }\n }\n \n@@ -410,7 +410,7 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n         // That's ok; only one task needs to do the dirty work. (Might also\n         // see 'None' if Somebody already failed and we got a kill signal.)\n         if newstate.is_some() {\n-            let group = option::unwrap(move newstate);\n+            let group = option::unwrap(newstate);\n             for taskset_each(&group.members) |sibling| {\n                 // Skip self - killing ourself won't do much good.\n                 if sibling != me {\n@@ -457,7 +457,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 }));\n                 // Main task/group has no ancestors, no notifier, etc.\n                 let group =\n-                    @TCB(spawner, move tasks, AncestorList(None), true, None);\n+                    @TCB(spawner, tasks, AncestorList(None), true, None);\n                 local_set(spawner, taskgroup_key!(), group);\n                 group\n             }\n@@ -472,7 +472,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             // Child's ancestors are spawner's ancestors.\n             let a = share_ancestors(&mut spawner_group.ancestors);\n             // Propagate main-ness.\n-            (move g, move a, spawner_group.is_main)\n+            (g, a, spawner_group.is_main)\n         } else {\n             // Child is in a separate group from spawner.\n             let g = private::exclusive(Some(TaskGroupData {\n@@ -504,7 +504,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 // Child has no ancestors.\n                 AncestorList(None)\n             };\n-            (move g, move a, false)\n+            (g, a, false)\n         };\n     }\n \n@@ -515,10 +515,10 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         //    None               { ancestor_list(None) }\n         let tmp = util::replace(&mut **ancestors, None);\n         if tmp.is_some() {\n-            let ancestor_arc = option::unwrap(move tmp);\n+            let ancestor_arc = option::unwrap(tmp);\n             let result = ancestor_arc.clone();\n-            **ancestors = move Some(move ancestor_arc);\n-            AncestorList(Some(move result))\n+            **ancestors = Some(ancestor_arc);\n+            AncestorList(Some(result))\n         } else {\n             AncestorList(None)\n         }\n@@ -530,7 +530,7 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n     unsafe {\n-        let child_data = ~mut Some((move child_tg, move ancestors, move f));\n+        let child_data = ~mut Some((child_tg, ancestors, f));\n         // Being killed with the unsafe task/closure pointers would leak them.\n         do unkillable {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n@@ -548,16 +548,16 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n                 Some(option::swap_unwrap(&mut opts.notify_chan))\n             };\n \n-            let child_wrapper = make_child_wrapper(new_task, move child_tg,\n-                  move ancestors, is_main, move notify_chan, move f);\n+            let child_wrapper = make_child_wrapper(new_task, child_tg,\n+                  ancestors, is_main, notify_chan, f);\n \n             let closure = cast::transmute(&child_wrapper);\n \n             // Getting killed between these two calls would free the child's\n             // closure. (Reordering them wouldn't help - then getting killed\n             // between them would leak.)\n             rt::start_task(new_task, closure);\n-            cast::forget(move child_wrapper);\n+            cast::forget(child_wrapper);\n         }\n     }\n \n@@ -571,8 +571,8 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n                           ancestors: AncestorList, is_main: bool,\n                           notify_chan: Option<Chan<TaskResult>>,\n                           f: fn~()) -> fn~() {\n-        let child_data = ~mut Some((move child_arc, move ancestors));\n-        return fn~(move notify_chan, move child_data, move f) {\n+        let child_data = ~mut Some((child_arc, ancestors));\n+        return fn~() {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let mut (child_arc, ancestors) = option::swap_unwrap(child_data);\n             // Child task runs this code.\n@@ -584,14 +584,14 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n             let notifier = match notify_chan {\n                 Some(ref notify_chan_value) => {\n                     let moved_ncv = move_it!(*notify_chan_value);\n-                    Some(AutoNotify(move moved_ncv))\n+                    Some(AutoNotify(moved_ncv))\n                 }\n                 _ => None\n             };\n \n             if enlist_many(child, &child_arc, &mut ancestors) {\n-                let group = @TCB(child, move child_arc, move ancestors,\n-                                 is_main, move notifier);\n+                let group = @TCB(child, child_arc, ancestors,\n+                                 is_main, notifier);\n                 unsafe {\n                     local_set(child, taskgroup_key!(), group);\n                 }\n@@ -694,7 +694,7 @@ fn test_spawn_raw_unsupervise() {\n         notify_chan: None,\n         .. default_task_opts()\n     };\n-    do spawn_raw(move opts) {\n+    do spawn_raw(opts) {\n         fail!();\n     }\n }\n@@ -708,7 +708,7 @@ fn test_spawn_raw_notify_success() {\n         notify_chan: Some(notify_ch),\n         .. default_task_opts()\n     };\n-    do spawn_raw(move opts) {\n+    do spawn_raw(opts) {\n     }\n     assert notify_po.recv() == Success;\n }\n@@ -724,7 +724,7 @@ fn test_spawn_raw_notify_failure() {\n         notify_chan: Some(notify_ch),\n         .. default_task_opts()\n     };\n-    do spawn_raw(move opts) {\n+    do spawn_raw(opts) {\n         fail!();\n     }\n     assert notify_po.recv() == Failure;"}, {"sha": "e545f6567ec32880f328870e4f8f4f811beae21a", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -87,7 +87,7 @@ impl<A: ToStr> ToStr for ~[A] {\n                 }\n             }\n             str::push_char(&mut acc, ']');\n-            move acc\n+            acc\n         }\n     }\n }"}, {"sha": "eea172a43ced1e1ca440897b36fdf006f3365b48", "filename": "src/libcore/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -19,7 +19,7 @@ use prelude::*;\n \n /// The identity function.\n #[inline(always)]\n-pub pure fn id<T>(x: T) -> T { move x }\n+pub pure fn id<T>(x: T) -> T { x }\n \n /// Ignores a value.\n #[inline(always)]\n@@ -37,10 +37,10 @@ pub fn with<T: Copy, R>(\n     // we wouldn't need to copy...\n \n     let old_value = *ptr;\n-    *ptr = move new_value;\n+    *ptr = new_value;\n     let result = op();\n-    *ptr = move old_value;\n-    return move result;\n+    *ptr = old_value;\n+    return result;\n }\n \n /**\n@@ -58,9 +58,9 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n  */\n #[inline(always)]\n pub fn replace<T>(dest: &mut T, src: T) -> T {\n-    let mut tmp = move src;\n+    let mut tmp = src;\n     swap(dest, &mut tmp);\n-    move tmp\n+    tmp\n }\n \n /// A non-copyable dummy type.\n@@ -109,7 +109,7 @@ mod tests {\n         let x = ~[(5, false)];\n         //FIXME #3387 assert x.eq(id(copy x));\n         let y = copy x;\n-        assert x.eq(&id(move y));\n+        assert x.eq(&id(y));\n     }\n     #[test]\n     pub fn test_swap() {"}, {"sha": "97519e88f26c810aa2b6f71e111292069e479170", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5912b1448ca1b5bcddf8af1ed9e16fc41775af9c/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=5912b1448ca1b5bcddf8af1ed9e16fc41775af9c", "patch": "@@ -614,7 +614,7 @@ unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n     (**repr).unboxed.fill += sys::nonzero_size_of::<T>();\n     let p = addr_of(&((**repr).unboxed.data));\n     let p = ptr::offset(p, fill) as *mut T;\n-    rusti::move_val_init(&mut(*p), move initval);\n+    rusti::move_val_init(&mut(*p), initval);\n }\n \n #[inline(never)]"}]}