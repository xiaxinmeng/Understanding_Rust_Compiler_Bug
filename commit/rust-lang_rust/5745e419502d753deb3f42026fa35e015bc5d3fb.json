{"sha": "5745e419502d753deb3f42026fa35e015bc5d3fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NDVlNDE5NTAyZDc1M2RlYjNmNDIwMjZmYTM1ZTAxNWJjNWQzZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-12T22:57:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-12T22:57:16Z"}, "message": "auto merge of #18858 : alexcrichton/rust/remove-time, r=jakub\n\nThis commit deprecates the entire libtime library in favor of the\r\nexternally-provided libtime in the rust-lang organization. Users of the\r\n`libtime` crate as-is today should add this to their Cargo manifests:\r\n\r\n    [dependencies.time]\r\n    git = \"https://github.com/rust-lang/time\"\r\n\r\nTo implement this transition, a new function `Duration::span` was added to the\r\n`std::time::Duration` time. This function takes a closure and then returns the\r\nduration of time it took that closure to execute. This interface will likely\r\nimprove with `FnOnce` unboxed closures as moving in and out will be a little\r\neasier.\r\n\r\nDue to the deprecation of the in-tree crate, this is a:\r\n\r\n[breaking-change]\r\n\r\ncc #18855, some of the conversions in the `src/test/bench` area may have been a\r\nlittle nicer with that implemented", "tree": {"sha": "087cc690130ffb3c4603f755c64cb3b5ed76e095", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/087cc690130ffb3c4603f755c64cb3b5ed76e095"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5745e419502d753deb3f42026fa35e015bc5d3fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5745e419502d753deb3f42026fa35e015bc5d3fb", "html_url": "https://github.com/rust-lang/rust/commit/5745e419502d753deb3f42026fa35e015bc5d3fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5745e419502d753deb3f42026fa35e015bc5d3fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a86aa83eea27529b1b8855cd4e2c8ce7bf787ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a86aa83eea27529b1b8855cd4e2c8ce7bf787ef", "html_url": "https://github.com/rust-lang/rust/commit/7a86aa83eea27529b1b8855cd4e2c8ce7bf787ef"}, {"sha": "fcd05ed99ff0aa6157e427a698ac53dbc450135f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcd05ed99ff0aa6157e427a698ac53dbc450135f", "html_url": "https://github.com/rust-lang/rust/commit/fcd05ed99ff0aa6157e427a698ac53dbc450135f"}], "stats": {"total": 609, "additions": 336, "deletions": 273}, "files": [{"sha": "7a34c5977d67c56c751dc1bc5dea94ce750d0e4b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -41,7 +41,6 @@ extern crate rustc_llvm;\n extern crate rustc_back;\n extern crate serialize;\n extern crate rbml;\n-extern crate time;\n #[phase(plugin, link)] extern crate log;\n #[phase(plugin, link)] extern crate syntax;\n "}, {"sha": "19cc04a20ef9617edda7bdb8129892a677892578", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -228,16 +228,16 @@ use util::fs;\n \n use std::c_str::ToCStr;\n use std::cmp;\n+use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::{HashMap, HashSet};\n use std::io::fs::PathExtensions;\n use std::io;\n use std::ptr;\n use std::slice;\n use std::string;\n+use std::time::Duration;\n \n-use std::collections::{HashMap, HashSet};\n-use std::collections::hash_map::{Occupied, Vacant};\n use flate;\n-use time;\n \n pub struct CrateMismatch {\n     path: Path,\n@@ -691,11 +691,13 @@ impl ArchiveMetadata {\n \n // Just a small wrapper to time how long reading metadata takes.\n fn get_metadata_section(is_osx: bool, filename: &Path) -> Result<MetadataBlob, String> {\n-    let start = time::precise_time_ns();\n-    let ret = get_metadata_section_imp(is_osx, filename);\n+    let mut ret = None;\n+    let dur = Duration::span(|| {\n+        ret = Some(get_metadata_section_imp(is_osx, filename));\n+    });\n     info!(\"reading {} => {}ms\", filename.filename_display(),\n-           (time::precise_time_ns() - start) / 1000000);\n-    return ret;\n+          dur.num_milliseconds());\n+    return ret.unwrap();;\n }\n \n fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlob, String> {"}, {"sha": "294b5f96f1c724a9f7812b4fcd7491a6e2b407b9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -97,8 +97,6 @@ use syntax::visit::Visitor;\n use syntax::visit;\n use syntax::{ast, ast_util, ast_map};\n \n-use time;\n-\n local_data_key!(task_local_insn_key: RefCell<Vec<&'static str>>)\n \n pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n@@ -138,23 +136,16 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n pub struct StatRecorder<'a, 'tcx: 'a> {\n     ccx: &'a CrateContext<'a, 'tcx>,\n     name: Option<String>,\n-    start: u64,\n     istart: uint,\n }\n \n impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n     pub fn new(ccx: &'a CrateContext<'a, 'tcx>, name: String)\n                -> StatRecorder<'a, 'tcx> {\n-        let start = if ccx.sess().trans_stats() {\n-            time::precise_time_ns()\n-        } else {\n-            0\n-        };\n         let istart = ccx.stats().n_llvm_insns.get();\n         StatRecorder {\n             ccx: ccx,\n             name: Some(name),\n-            start: start,\n             istart: istart,\n         }\n     }\n@@ -164,11 +155,8 @@ impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     fn drop(&mut self) {\n         if self.ccx.sess().trans_stats() {\n-            let end = time::precise_time_ns();\n-            let elapsed = ((end - self.start) / 1_000_000) as uint;\n             let iend = self.ccx.stats().n_llvm_insns.get();\n             self.ccx.stats().fn_stats.borrow_mut().push((self.name.take().unwrap(),\n-                                                       elapsed,\n                                                        iend - self.istart));\n             self.ccx.stats().n_fns.set(self.ccx.stats().n_fns.get() + 1);\n             // Reset LLVM insn count to avoid compound costs.\n@@ -3097,13 +3085,13 @@ pub fn trans_crate<'tcx>(analysis: CrateAnalysis<'tcx>)\n         println!(\"n_inlines: {}\", stats.n_inlines.get());\n         println!(\"n_closures: {}\", stats.n_closures.get());\n         println!(\"fn stats:\");\n-        stats.fn_stats.borrow_mut().sort_by(|&(_, _, insns_a), &(_, _, insns_b)| {\n+        stats.fn_stats.borrow_mut().sort_by(|&(_, insns_a), &(_, insns_b)| {\n             insns_b.cmp(&insns_a)\n         });\n         for tuple in stats.fn_stats.borrow().iter() {\n             match *tuple {\n-                (ref name, ms, insns) => {\n-                    println!(\"{} insns, {} ms, {}\", insns, ms, *name);\n+                (ref name, insns) => {\n+                    println!(\"{} insns, {}\", insns, *name);\n                 }\n             }\n         }"}, {"sha": "2ba01aa922a743d0cc712b46f95664a0c24ae06b", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -47,8 +47,8 @@ pub struct Stats {\n     pub n_closures: Cell<uint>,\n     pub n_llvm_insns: Cell<uint>,\n     pub llvm_insns: RefCell<FnvHashMap<String, uint>>,\n-    // (ident, time-in-ms, llvm-instructions)\n-    pub fn_stats: RefCell<Vec<(String, uint, uint)> >,\n+    // (ident, llvm-instructions)\n+    pub fn_stats: RefCell<Vec<(String, uint)> >,\n }\n \n /// The shared portion of a `CrateContext`.  There is one `SharedCrateContext`"}, {"sha": "b845e507fd333ae974d5dda155d56ffea2cb5136", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -12,26 +12,30 @@\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n-use std::hash::{Hash, Hasher};\n use std::fmt::Show;\n+use std::hash::{Hash, Hasher};\n+use std::time::Duration;\n+\n use syntax::ast;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-use time;\n-\n pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n     local_data_key!(depth: uint);\n     if !do_it { return f(u); }\n \n     let old = depth.get().map(|d| *d).unwrap_or(0);\n     depth.replace(Some(old + 1));\n \n-    let start = time::precise_time_s();\n-    let rv = f(u);\n-    let end = time::precise_time_s();\n+    let mut u = Some(u);\n+    let mut rv = None;\n+    let dur = Duration::span(|| {\n+        rv = Some(f(u.take().unwrap()))\n+    });\n+    let rv = rv.unwrap();\n \n-    println!(\"{}time: {:3.3f} s\\t{}\", \"  \".repeat(old), end - start, what);\n+    println!(\"{}time: {}.{:03} \\t{}\", \"  \".repeat(old),\n+             dur.num_seconds(), dur.num_milliseconds(), what);\n     depth.replace(Some(old));\n \n     rv"}, {"sha": "7343d674972350bce7e4f1b2c5e27c5785445056", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -25,7 +25,6 @@ extern crate rustc;\n extern crate serialize;\n extern crate syntax;\n extern crate \"test\" as testing;\n-extern crate time;\n #[phase(plugin, link)] extern crate log;\n \n use std::io;\n@@ -238,7 +237,6 @@ pub fn main_args(args: &[String]) -> int {\n     };\n \n     info!(\"going to format\");\n-    let started = time::precise_time_ns();\n     match matches.opt_str(\"w\").as_ref().map(|s| s.as_slice()) {\n         Some(\"html\") | None => {\n             match html::render::run(krate, &external_html, output.unwrap_or(Path::new(\"doc\"))) {\n@@ -257,8 +255,6 @@ pub fn main_args(args: &[String]) -> int {\n             return 1;\n         }\n     }\n-    let ended = time::precise_time_ns();\n-    info!(\"Took {:.03f}s\", (ended as f64 - started as f64) / 1e9f64);\n \n     return 0;\n }"}, {"sha": "c2d4afeb9add3faa46a2e088e0baf594128549a7", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -135,6 +135,14 @@ impl Duration {\n         Duration { secs: secs, nanos: nanos as i32 }\n     }\n \n+    /// Runs a closure, returning the duration of time it took to run the\n+    /// closure.\n+    pub fn span(f: ||) -> Duration {\n+        let before = super::precise_time_ns();\n+        f();\n+        Duration::nanoseconds((before - super::precise_time_ns()) as i64)\n+    }\n+\n     /// Returns the total number of whole weeks in the duration.\n     #[inline]\n     pub fn num_weeks(&self) -> i64 {"}, {"sha": "7bc15798a4f2e6c4b0c7363dddc23e38e639e1e1", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -10,6 +10,79 @@\n \n //! Temporal quantification.\n \n+use libc;\n+\n pub use self::duration::Duration;\n \n pub mod duration;\n+\n+/// Returns the current value of a high-resolution performance counter\n+/// in nanoseconds since an unspecified epoch.\n+// NB: this is intentionally not public, this is not ready to stabilize its api.\n+fn precise_time_ns() -> u64 {\n+    return os_precise_time_ns();\n+\n+    #[cfg(windows)]\n+    fn os_precise_time_ns() -> u64 {\n+        let mut ticks_per_s = 0;\n+        assert_eq!(unsafe {\n+            libc::QueryPerformanceFrequency(&mut ticks_per_s)\n+        }, 1);\n+        let ticks_per_s = if ticks_per_s == 0 {1} else {ticks_per_s};\n+        let mut ticks = 0;\n+        assert_eq!(unsafe {\n+            libc::QueryPerformanceCounter(&mut ticks)\n+        }, 1);\n+\n+        return (ticks as u64 * 1000000000) / (ticks_per_s as u64);\n+    }\n+\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+    fn os_precise_time_ns() -> u64 {\n+        use sync;\n+\n+        static mut TIMEBASE: libc::mach_timebase_info = libc::mach_timebase_info { numer: 0,\n+                                                                                   denom: 0 };\n+        static ONCE: sync::Once = sync::ONCE_INIT;\n+        unsafe {\n+            ONCE.doit(|| {\n+                imp::mach_timebase_info(&mut TIMEBASE);\n+            });\n+            let time = imp::mach_absolute_time();\n+            time * TIMEBASE.numer as u64 / TIMEBASE.denom as u64\n+        }\n+    }\n+\n+    #[cfg(not(any(windows, target_os = \"macos\", target_os = \"ios\")))]\n+    fn os_precise_time_ns() -> u64 {\n+        let mut ts = libc::timespec { tv_sec: 0, tv_nsec: 0 };\n+        unsafe {\n+            imp::clock_gettime(libc::CLOCK_MONOTONIC, &mut ts);\n+        }\n+        return (ts.tv_sec as u64) * 1000000000 + (ts.tv_nsec as u64)\n+    }\n+}\n+\n+#[cfg(all(unix, not(target_os = \"macos\"), not(target_os = \"ios\")))]\n+mod imp {\n+    use libc::{c_int, timespec};\n+\n+    // Apparently android provides this in some other library?\n+    #[cfg(not(target_os = \"android\"))]\n+    #[link(name = \"rt\")]\n+    extern {}\n+\n+    extern {\n+        pub fn clock_gettime(clk_id: c_int, tp: *mut timespec) -> c_int;\n+    }\n+\n+}\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+mod imp {\n+    use libc::{c_int, mach_timebase_info};\n+\n+    extern {\n+        pub fn mach_absolute_time() -> u64;\n+        pub fn mach_timebase_info(info: *mut mach_timebase_info) -> c_int;\n+    }\n+}"}, {"sha": "a57e84b543f7cdd1fccfd241c802fb266be51f78", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -39,11 +39,9 @@ extern crate getopts;\n extern crate regex;\n extern crate serialize;\n extern crate term;\n-extern crate time;\n \n use std::collections::TreeMap;\n use stats::Stats;\n-use time::precise_time_ns;\n use getopts::{OptGroup, optflag, optopt};\n use regex::Regex;\n use serialize::{json, Decodable};\n@@ -53,8 +51,8 @@ use term::color::{Color, RED, YELLOW, GREEN, CYAN};\n \n use std::cmp;\n use std::f64;\n-use std::fmt;\n use std::fmt::Show;\n+use std::fmt;\n use std::from_str::FromStr;\n use std::io::fs::PathExtensions;\n use std::io::stdio::StdWriter;\n@@ -63,6 +61,7 @@ use std::io;\n use std::os;\n use std::string::String;\n use std::task::TaskBuilder;\n+use std::time::Duration;\n \n // to be used by rustc to compile tests in libtest\n pub mod test {\n@@ -175,8 +174,7 @@ impl fmt::Show for TestFn {\n /// call to `iter`.\n pub struct Bencher {\n     iterations: u64,\n-    ns_start: u64,\n-    ns_end: u64,\n+    dur: Duration,\n     pub bytes: u64,\n }\n \n@@ -1272,20 +1270,16 @@ pub fn black_box<T>(dummy: T) {\n impl Bencher {\n     /// Callback for benchmark functions to run in their body.\n     pub fn iter<T>(&mut self, inner: || -> T) {\n-        self.ns_start = precise_time_ns();\n-        let k = self.iterations;\n-        for _ in range(0u64, k) {\n-            black_box(inner());\n-        }\n-        self.ns_end = precise_time_ns();\n+        self.dur = Duration::span(|| {\n+            let k = self.iterations;\n+            for _ in range(0u64, k) {\n+                black_box(inner());\n+            }\n+        });\n     }\n \n     pub fn ns_elapsed(&mut self) -> u64 {\n-        if self.ns_start == 0 || self.ns_end == 0 {\n-            0\n-        } else {\n-            self.ns_end - self.ns_start\n-        }\n+        self.dur.num_nanoseconds().unwrap() as u64\n     }\n \n     pub fn ns_per_iter(&mut self) -> u64 {\n@@ -1322,41 +1316,44 @@ impl Bencher {\n         // (i.e. larger error bars).\n         if n == 0 { n = 1; }\n \n-        let mut total_run = 0;\n+        let mut total_run = Duration::nanoseconds(0);\n         let samples : &mut [f64] = [0.0_f64, ..50];\n         loop {\n-            let loop_start = precise_time_ns();\n+            let mut summ = None;\n+            let mut summ5 = None;\n \n-            for p in samples.iter_mut() {\n-                self.bench_n(n, |x| f(x));\n-                *p = self.ns_per_iter() as f64;\n-            };\n+            let loop_run = Duration::span(|| {\n \n-            stats::winsorize(samples, 5.0);\n-            let summ = stats::Summary::new(samples);\n+                for p in samples.iter_mut() {\n+                    self.bench_n(n, |x| f(x));\n+                    *p = self.ns_per_iter() as f64;\n+                };\n \n-            for p in samples.iter_mut() {\n-                self.bench_n(5 * n, |x| f(x));\n-                *p = self.ns_per_iter() as f64;\n-            };\n+                stats::winsorize(samples, 5.0);\n+                summ = Some(stats::Summary::new(samples));\n \n-            stats::winsorize(samples, 5.0);\n-            let summ5 = stats::Summary::new(samples);\n+                for p in samples.iter_mut() {\n+                    self.bench_n(5 * n, |x| f(x));\n+                    *p = self.ns_per_iter() as f64;\n+                };\n \n-            let now = precise_time_ns();\n-            let loop_run = now - loop_start;\n+                stats::winsorize(samples, 5.0);\n+                summ5 = Some(stats::Summary::new(samples));\n+            });\n+            let summ = summ.unwrap();\n+            let summ5 = summ5.unwrap();\n \n             // If we've run for 100ms and seem to have converged to a\n             // stable median.\n-            if loop_run > 100_000_000 &&\n+            if loop_run.num_milliseconds() > 100 &&\n                 summ.median_abs_dev_pct < 1.0 &&\n                 summ.median - summ5.median < summ5.median_abs_dev {\n                 return summ5;\n             }\n \n-            total_run += loop_run;\n+            total_run = total_run + loop_run;\n             // Longest we ever run for is 3s.\n-            if total_run > 3_000_000_000 {\n+            if total_run.num_seconds() > 3 {\n                 return summ5;\n             }\n \n@@ -1367,13 +1364,13 @@ impl Bencher {\n \n pub mod bench {\n     use std::cmp;\n+    use std::time::Duration;\n     use super::{Bencher, BenchSamples};\n \n     pub fn benchmark(f: |&mut Bencher|) -> BenchSamples {\n         let mut bs = Bencher {\n             iterations: 0,\n-            ns_start: 0,\n-            ns_end: 0,\n+            dur: Duration::nanoseconds(0),\n             bytes: 0\n         };\n "}, {"sha": "3211d03a7c07b874a73b4f9dd1bc407f4ee6cf86", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -11,7 +11,8 @@\n //! Simple time handling.\n \n #![crate_name = \"time\"]\n-#![experimental]\n+#![deprecated = \"use the http://github.com/rust-lang/time crate instead\"]\n+#![allow(deprecated)]\n \n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]"}, {"sha": "2661b1f4eb49b7a93d03ca34e2563991eb2e37c3", "filename": "src/test/auxiliary/lint-unused-extern-crate.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fauxiliary%2Flint-unused-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fauxiliary%2Flint-unused-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint-unused-extern-crate.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn foo() {}"}, {"sha": "bbbd878e8b8ad8abce3baee001f9ef898ac7dc5e", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -8,18 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate time;\n-\n use std::collections::{TrieMap, TreeMap, HashMap, HashSet};\n use std::os;\n use std::rand::{Rng, IsaacRng, SeedableRng};\n+use std::time::Duration;\n use std::uint;\n \n fn timed(label: &str, f: ||) {\n-    let start = time::precise_time_s();\n-    f();\n-    let end = time::precise_time_s();\n-    println!(\"  {}: {}\", label, end - start);\n+    println!(\"  {}: {}\", label, Duration::span(f));\n }\n \n trait MutableMap {"}, {"sha": "15d89bebf759af4fc16c10a0b01cf41bdc3a8619", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -12,30 +12,27 @@\n \n extern crate collections;\n extern crate rand;\n-extern crate time;\n \n use std::collections::BitvSet;\n+use std::collections::HashSet;\n use std::collections::TreeSet;\n use std::hash::Hash;\n-use std::collections::HashSet;\n use std::os;\n+use std::time::Duration;\n use std::uint;\n \n struct Results {\n-    sequential_ints: f64,\n-    random_ints: f64,\n-    delete_ints: f64,\n+    sequential_ints: Duration,\n+    random_ints: Duration,\n+    delete_ints: Duration,\n \n-    sequential_strings: f64,\n-    random_strings: f64,\n-    delete_strings: f64\n+    sequential_strings: Duration,\n+    random_strings: Duration,\n+    delete_strings: Duration,\n }\n \n-fn timed(result: &mut f64, op: ||) {\n-    let start = time::precise_time_s();\n-    op();\n-    let end = time::precise_time_s();\n-    *result = (end - start);\n+fn timed(result: &mut Duration, op: ||) {\n+    *result = Duration::span(op);\n }\n \n trait MutableSet<T> {\n@@ -150,7 +147,7 @@ fn write_header(header: &str) {\n     println!(\"{}\", header);\n }\n \n-fn write_row(label: &str, value: f64) {\n+fn write_row(label: &str, value: Duration) {\n     println!(\"{:30s} {} s\\n\", label, value);\n }\n \n@@ -166,13 +163,13 @@ fn write_results(label: &str, results: &Results) {\n \n fn empty_results() -> Results {\n     Results {\n-        sequential_ints: 0.0,\n-        random_ints: 0.0,\n-        delete_ints: 0.0,\n+        sequential_ints: Duration::seconds(0),\n+        random_ints: Duration::seconds(0),\n+        delete_ints: Duration::seconds(0),\n \n-        sequential_strings: 0.0,\n-        random_strings: 0.0,\n-        delete_strings: 0.0,\n+        sequential_strings: Duration::seconds(0),\n+        random_strings: Duration::seconds(0),\n+        delete_strings: Duration::seconds(0),\n     }\n }\n "}, {"sha": "24bd26b028813d65c446a147c2420f761bbd7d82", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -13,16 +13,14 @@\n \n #![feature(macro_rules)]\n \n-extern crate time;\n-\n-use time::precise_time_s;\n-use std::rand;\n-use std::rand::Rng;\n+use std::io::File;\n use std::mem::swap;\n use std::os;\n+use std::rand::Rng;\n+use std::rand;\n use std::str;\n+use std::time::Duration;\n use std::vec;\n-use std::io::File;\n \n fn main() {\n     let argv = os::args();\n@@ -56,11 +54,9 @@ fn maybe_run_test(argv: &[String], name: String, test: ||) {\n         return\n     }\n \n-    let start = precise_time_s();\n-    test();\n-    let stop = precise_time_s();\n+    let dur = Duration::span(test);\n \n-    println!(\"{}:\\t\\t{} ms\", name, (stop - start) * 1000.0);\n+    println!(\"{}:\\t\\t{} ms\", name, dur.num_milliseconds());\n }\n \n fn shift_push() {"}, {"sha": "c2383add929d72cc5ed00a139efd02c09b0fdcfb", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -18,11 +18,10 @@\n // different scalability characteristics compared to the select\n // version.\n \n-extern crate time;\n-\n use std::comm;\n use std::os;\n use std::task;\n+use std::time::Duration;\n use std::uint;\n \n fn move_out<T>(_x: T) {}\n@@ -58,36 +57,39 @@ fn run(args: &[String]) {\n     let size = from_str::<uint>(args[1].as_slice()).unwrap();\n     let workers = from_str::<uint>(args[2].as_slice()).unwrap();\n     let num_bytes = 100;\n-    let start = time::precise_time_s();\n-    let mut worker_results = Vec::new();\n-    for _ in range(0u, workers) {\n-        let to_child = to_child.clone();\n-        worker_results.push(task::try_future(proc() {\n-            for _ in range(0u, size / workers) {\n-                //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n-                to_child.send(bytes(num_bytes));\n-            }\n-            //println!(\"worker {} exiting\", i);\n-        }));\n-    }\n-    task::spawn(proc() {\n-        server(&from_parent, &to_parent);\n-    });\n+    let mut result = None;\n+    let mut p = Some((to_child, to_parent, from_parent));\n+    let dur = Duration::span(|| {\n+        let (to_child, to_parent, from_parent) = p.take().unwrap();\n+        let mut worker_results = Vec::new();\n+        for _ in range(0u, workers) {\n+            let to_child = to_child.clone();\n+            worker_results.push(task::try_future(proc() {\n+                for _ in range(0u, size / workers) {\n+                    //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n+                    to_child.send(bytes(num_bytes));\n+                }\n+                //println!(\"worker {} exiting\", i);\n+            }));\n+        }\n+        task::spawn(proc() {\n+            server(&from_parent, &to_parent);\n+        });\n \n-    for r in worker_results.into_iter() {\n-        r.unwrap();\n-    }\n+        for r in worker_results.into_iter() {\n+            r.unwrap();\n+        }\n \n-    //println!(\"sending stop message\");\n-    to_child.send(stop);\n-    move_out(to_child);\n-    let result = from_child.recv();\n-    let end = time::precise_time_s();\n-    let elapsed = end - start;\n+        //println!(\"sending stop message\");\n+        to_child.send(stop);\n+        move_out(to_child);\n+        result = Some(from_child.recv());\n+    });\n+    let result = result.unwrap();\n     print!(\"Count is {}\\n\", result);\n-    print!(\"Test took {} seconds\\n\", elapsed);\n-    let thruput = ((size / workers * workers) as f64) / (elapsed as f64);\n-    print!(\"Throughput={} per sec\\n\", thruput);\n+    print!(\"Test took {} ms\\n\", dur.num_milliseconds());\n+    let thruput = ((size / workers * workers) as f64) / (dur.num_milliseconds() as f64);\n+    print!(\"Throughput={} per sec\\n\", thruput / 1000.0);\n     assert_eq!(result, num_bytes * size);\n }\n "}, {"sha": "8d05dfdb7cd02ccbd8f4093346fb5911f1d8a253", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -14,10 +14,9 @@\n //\n // I *think* it's the same, more or less.\n \n-extern crate time;\n-\n use std::os;\n use std::task;\n+use std::time::Duration;\n use std::uint;\n \n fn move_out<T>(_x: T) {}\n@@ -52,50 +51,53 @@ fn run(args: &[String]) {\n     let size = from_str::<uint>(args[1].as_slice()).unwrap();\n     let workers = from_str::<uint>(args[2].as_slice()).unwrap();\n     let num_bytes = 100;\n-    let start = time::precise_time_s();\n-    let mut worker_results = Vec::new();\n-    let from_parent = if workers == 1 {\n-        let (to_child, from_parent) = channel();\n-        worker_results.push(task::try_future(proc() {\n-            for _ in range(0u, size / workers) {\n-                //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n-                to_child.send(bytes(num_bytes));\n-            }\n-            //println!(\"worker {} exiting\", i);\n-        }));\n-        from_parent\n-    } else {\n-        let (to_child, from_parent) = channel();\n-        for _ in range(0u, workers) {\n-            let to_child = to_child.clone();\n+    let mut result = None;\n+    let mut to_parent = Some(to_parent);\n+    let dur = Duration::span(|| {\n+        let to_parent = to_parent.take().unwrap();\n+        let mut worker_results = Vec::new();\n+        let from_parent = if workers == 1 {\n+            let (to_child, from_parent) = channel();\n             worker_results.push(task::try_future(proc() {\n                 for _ in range(0u, size / workers) {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(bytes(num_bytes));\n                 }\n                 //println!(\"worker {} exiting\", i);\n             }));\n-        }\n-        from_parent\n-    };\n-    task::spawn(proc() {\n-        server(&from_parent, &to_parent);\n-    });\n+            from_parent\n+        } else {\n+            let (to_child, from_parent) = channel();\n+            for _ in range(0u, workers) {\n+                let to_child = to_child.clone();\n+                worker_results.push(task::try_future(proc() {\n+                    for _ in range(0u, size / workers) {\n+                        //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n+                        to_child.send(bytes(num_bytes));\n+                    }\n+                    //println!(\"worker {} exiting\", i);\n+                }));\n+            }\n+            from_parent\n+        };\n+        task::spawn(proc() {\n+            server(&from_parent, &to_parent);\n+        });\n \n-    for r in worker_results.into_iter() {\n-        r.unwrap();\n-    }\n+        for r in worker_results.into_iter() {\n+            r.unwrap();\n+        }\n \n-    //println!(\"sending stop message\");\n-    //to_child.send(stop);\n-    //move_out(to_child);\n-    let result = from_child.recv();\n-    let end = time::precise_time_s();\n-    let elapsed = end - start;\n+        //println!(\"sending stop message\");\n+        //to_child.send(stop);\n+        //move_out(to_child);\n+        result = Some(from_child.recv());\n+    });\n+    let result = result.unwrap();\n     print!(\"Count is {}\\n\", result);\n-    print!(\"Test took {} seconds\\n\", elapsed);\n-    let thruput = ((size / workers * workers) as f64) / (elapsed as f64);\n-    print!(\"Throughput={} per sec\\n\", thruput);\n+    print!(\"Test took {} ms\\n\", dur.num_milliseconds());\n+    let thruput = ((size / workers * workers) as f64) / (dur.num_milliseconds() as f64);\n+    print!(\"Throughput={} per sec\\n\", thruput / 1000.0);\n     assert_eq!(result, num_bytes * size);\n }\n "}, {"sha": "d06e6c8cd191fbf08bf0728a9a84b0889e6bd52c", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -18,10 +18,9 @@\n // no-pretty-expanded FIXME #15189\n // ignore-lexer-test FIXME #15679\n \n-extern crate time;\n-\n-use std::sync::{Arc, Future, Mutex};\n use std::os;\n+use std::sync::{Arc, Future, Mutex};\n+use std::time::Duration;\n use std::uint;\n \n // A poor man's pipe.\n@@ -77,38 +76,38 @@ fn main() {\n \n     let (mut num_chan, num_port) = init();\n \n-    let start = time::precise_time_s();\n-\n-    // create the ring\n-    let mut futures = Vec::new();\n-\n-    for i in range(1u, num_tasks) {\n-        //println!(\"spawning %?\", i);\n-        let (new_chan, num_port) = init();\n-        let num_chan_2 = num_chan.clone();\n-        let new_future = Future::spawn(proc() {\n-            thread_ring(i, msg_per_task, num_chan_2, num_port)\n-        });\n-        futures.push(new_future);\n-        num_chan = new_chan;\n-    };\n-\n-    // do our iteration\n-    thread_ring(0, msg_per_task, num_chan, num_port);\n-\n-    // synchronize\n-    for f in futures.iter_mut() {\n-        f.get()\n-    }\n-\n-    let stop = time::precise_time_s();\n+    let mut p = Some((num_chan, num_port));\n+    let dur = Duration::span(|| {\n+        let (mut num_chan, num_port) = p.take().unwrap();\n+\n+        // create the ring\n+        let mut futures = Vec::new();\n+\n+        for i in range(1u, num_tasks) {\n+            //println!(\"spawning %?\", i);\n+            let (new_chan, num_port) = init();\n+            let num_chan_2 = num_chan.clone();\n+            let new_future = Future::spawn(proc() {\n+                thread_ring(i, msg_per_task, num_chan_2, num_port)\n+            });\n+            futures.push(new_future);\n+            num_chan = new_chan;\n+        };\n+\n+        // do our iteration\n+        thread_ring(0, msg_per_task, num_chan, num_port);\n+\n+        // synchronize\n+        for f in futures.iter_mut() {\n+            f.get()\n+        }\n+    });\n \n     // all done, report stats.\n     let num_msgs = num_tasks * msg_per_task;\n-    let elapsed = (stop - start);\n-    let rate = (num_msgs as f64) / elapsed;\n+    let rate = (num_msgs as f64) / (dur.num_milliseconds() as f64);\n \n-    println!(\"Sent {} messages in {} seconds\", num_msgs, elapsed);\n-    println!(\"  {} messages / second\", rate);\n-    println!(\"  {} \u03bcs / message\", 1000000. / rate);\n+    println!(\"Sent {} messages in {} ms\", num_msgs, dur.num_milliseconds());\n+    println!(\"  {} messages / second\", rate / 1000.0);\n+    println!(\"  {} \u03bcs / message\", 1000000. / rate / 1000.0);\n }"}, {"sha": "03066d40512f3cec8b91fb6af081ec0f870cd039", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -18,10 +18,9 @@\n // no-pretty-expanded FIXME #15189\n // ignore-lexer-test FIXME #15679\n \n-extern crate time;\n-\n-use std::sync::{RWLock, Arc, Future};\n use std::os;\n+use std::sync::{RWLock, Arc, Future};\n+use std::time::Duration;\n use std::uint;\n \n // A poor man's pipe.\n@@ -77,38 +76,38 @@ fn main() {\n \n     let (mut num_chan, num_port) = init();\n \n-    let start = time::precise_time_s();\n-\n-    // create the ring\n-    let mut futures = Vec::new();\n-\n-    for i in range(1u, num_tasks) {\n-        //println!(\"spawning %?\", i);\n-        let (new_chan, num_port) = init();\n-        let num_chan_2 = num_chan.clone();\n-        let new_future = Future::spawn(proc() {\n-            thread_ring(i, msg_per_task, num_chan_2, num_port)\n-        });\n-        futures.push(new_future);\n-        num_chan = new_chan;\n-    };\n-\n-    // do our iteration\n-    thread_ring(0, msg_per_task, num_chan, num_port);\n-\n-    // synchronize\n-    for f in futures.iter_mut() {\n-        let _ = f.get();\n-    }\n-\n-    let stop = time::precise_time_s();\n+    let mut p = Some((num_chan, num_port));\n+    let dur = Duration::span(|| {\n+        let (mut num_chan, num_port) = p.take().unwrap();\n+\n+        // create the ring\n+        let mut futures = Vec::new();\n+\n+        for i in range(1u, num_tasks) {\n+            //println!(\"spawning %?\", i);\n+            let (new_chan, num_port) = init();\n+            let num_chan_2 = num_chan.clone();\n+            let new_future = Future::spawn(proc() {\n+                thread_ring(i, msg_per_task, num_chan_2, num_port)\n+            });\n+            futures.push(new_future);\n+            num_chan = new_chan;\n+        };\n+\n+        // do our iteration\n+        thread_ring(0, msg_per_task, num_chan, num_port);\n+\n+        // synchronize\n+        for f in futures.iter_mut() {\n+            let _ = f.get();\n+        }\n+    });\n \n     // all done, report stats.\n     let num_msgs = num_tasks * msg_per_task;\n-    let elapsed = (stop - start);\n-    let rate = (num_msgs as f64) / elapsed;\n+    let rate = (num_msgs as f64) / (dur.num_milliseconds() as f64);\n \n-    println!(\"Sent {} messages in {} seconds\", num_msgs, elapsed);\n-    println!(\"  {} messages / second\", rate);\n-    println!(\"  {} \u03bcs / message\", 1000000. / rate);\n+    println!(\"Sent {} messages in {} ms\", num_msgs, dur.num_milliseconds());\n+    println!(\"  {} messages / second\", rate / 1000.0);\n+    println!(\"  {} \u03bcs / message\", 1000000. / rate / 1000.0);\n }"}, {"sha": "9cc86e91fbed719c80268fb506883fb0e1489ee5", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -19,11 +19,11 @@\n */\n \n extern crate getopts;\n-extern crate time;\n \n use std::os;\n use std::result::{Ok, Err};\n use std::task;\n+use std::time::Duration;\n \n fn fib(n: int) -> int {\n     fn pfib(tx: &Sender<int>, n: int) {\n@@ -107,13 +107,11 @@ fn main() {\n \n         for n in range(1, max + 1) {\n             for _ in range(0u, num_trials) {\n-                let start = time::precise_time_ns();\n-                let fibn = fib(n);\n-                let stop = time::precise_time_ns();\n+                let mut fibn = None;\n+                let dur = Duration::span(|| fibn = Some(fib(n)));\n+                let fibn = fibn.unwrap();\n \n-                let elapsed = stop - start;\n-\n-                println!(\"{}\\t{}\\t{}\", n, fibn, elapsed.to_string());\n+                println!(\"{}\\t{}\\t{}\", n, fibn, dur);\n             }\n         }\n     }"}, {"sha": "576d96ba2a3559e52b44889da5250e3f447ad59a", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -10,11 +10,9 @@\n \n // Microbenchmark for the smallintmap library\n \n-extern crate collections;\n-extern crate time;\n-\n use std::collections::VecMap;\n use std::os;\n+use std::time::Duration;\n use std::uint;\n \n fn append_sequential(min: uint, max: uint, map: &mut VecMap<uint>) {\n@@ -41,25 +39,22 @@ fn main() {\n     let max = from_str::<uint>(args[1].as_slice()).unwrap();\n     let rep = from_str::<uint>(args[2].as_slice()).unwrap();\n \n-    let mut checkf = 0.0;\n-    let mut appendf = 0.0;\n+    let mut checkf = Duration::seconds(0);\n+    let mut appendf = Duration::seconds(0);\n \n     for _ in range(0u, rep) {\n         let mut map = VecMap::new();\n-        let start = time::precise_time_s();\n-        append_sequential(0u, max, &mut map);\n-        let mid = time::precise_time_s();\n-        check_sequential(0u, max, &map);\n-        let end = time::precise_time_s();\n+        let d1 = Duration::span(|| append_sequential(0u, max, &mut map));\n+        let d2 = Duration::span(|| check_sequential(0u, max, &map));\n \n-        checkf += (end - mid) as f64;\n-        appendf += (mid - start) as f64;\n+        checkf = checkf + d2;\n+        appendf = appendf + d1;\n     }\n \n     let maxf = max as f64;\n \n     println!(\"insert(): {} seconds\\n\", checkf);\n-    println!(\"        : {} op/sec\\n\", maxf/checkf);\n+    println!(\"        : {} op/ms\\n\", maxf / checkf.num_milliseconds() as f64);\n     println!(\"get()   : {} seconds\\n\", appendf);\n-    println!(\"        : {} op/sec\\n\", maxf/appendf);\n+    println!(\"        : {} op/ms\\n\", maxf / appendf.num_milliseconds() as f64);\n }"}, {"sha": "19c3045f0e7a181d931cf1b734605a7c5ce14d8b", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -10,11 +10,9 @@\n \n #![feature(unsafe_destructor)]\n \n-extern crate time;\n-\n-use time::precise_time_s;\n use std::os;\n use std::task;\n+use std::time::Duration;\n \n #[deriving(Clone)]\n enum List<T> {\n@@ -37,11 +35,12 @@ fn main() {\n \n fn run(repeat: int, depth: int) {\n     for _ in range(0, repeat) {\n-        println!(\"starting {:.4f}\", precise_time_s());\n-        task::try(proc() {\n-            recurse_or_panic(depth, None)\n+        let dur = Duration::span(|| {\n+            task::try(proc() {\n+                recurse_or_panic(depth, None)\n+            });\n         });\n-        println!(\"stopping {:.4f}\", precise_time_s());\n+        println!(\"iter: {}\", dur);\n     }\n }\n \n@@ -72,7 +71,6 @@ fn r(l: Box<nillist>) -> r {\n \n fn recurse_or_panic(depth: int, st: Option<State>) {\n     if depth == 0 {\n-        println!(\"unwinding {:.4f}\", precise_time_s());\n         panic!();\n     } else {\n         let depth = depth - 1;"}, {"sha": "93190a0ffe5cd0d7b3670c4167cc8974109ee844", "filename": "src/test/compile-fail/lint-unused-extern-crate.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5745e419502d753deb3f42026fa35e015bc5d3fb/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs?ref=5745e419502d753deb3f42026fa35e015bc5d3fb", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// aux-build:lint-unused-extern-crate.rs\n+\n #![feature(globs)]\n #![deny(unused_extern_crates)]\n #![allow(unused_variables)]\n@@ -19,14 +21,14 @@ extern crate \"collections\" as collecs; // no error, it is used\n extern crate rand; // no error, the use marks it as used\n                    // even if imported objects aren't used\n \n-extern crate time; // no error, the use * marks it as used\n+extern crate \"lint-unused-extern-crate\" as other; // no error, the use * marks it as used\n \n #[allow(unused_imports)]\n use rand::isaac::IsaacRng;\n \n-use time::*;\n+use other::*;\n \n fn main() {\n     let x: collecs::vec::Vec<uint> = Vec::new();\n-    let y = now();\n+    let y = foo();\n }"}]}