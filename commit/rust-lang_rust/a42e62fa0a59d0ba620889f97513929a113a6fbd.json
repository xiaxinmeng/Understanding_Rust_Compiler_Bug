{"sha": "a42e62fa0a59d0ba620889f97513929a113a6fbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MmU2MmZhMGE1OWQwYmE2MjA4ODlmOTc1MTM5MjlhMTEzYTZmYmQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-03-24T00:52:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-24T00:52:29Z"}, "message": "Rollup merge of #83353 - m-ou-se:io-error-avoid-alloc, r=nagisa\n\nAdd internal io::Error::new_const to avoid allocations.\n\nThis makes it possible to have a io::Error containing a message with zero allocations, and uses that everywhere to avoid the *three* allocations involved in `io::Error::new(kind, \"message\")`.\n\nThe function signature isn't perfect, because it needs a reference to the `&str`. So for now, this is just a `pub(crate)` function. Later, we'll be able to use `fn new_const<MSG: &'static str>(kind: ErrorKind)` to make that a bit better. (Then we'll also be able to use some ZST trickery if that would result in more efficient code.)\n\nSee https://github.com/rust-lang/rust/issues/83352", "tree": {"sha": "c8dabc69676343818b44914550e763ddd18d214d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8dabc69676343818b44914550e763ddd18d214d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a42e62fa0a59d0ba620889f97513929a113a6fbd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgWo1NCRBK7hj4Ov3rIwAAdHIIAAgFT1PyyzpI5BOxM6QlBCY5\nhgXafSvdWnq1hYEqOI+vnGSFNa7Rj+z6sCZeCpp9tkth2fDZ97V7OxnlphEp2fkl\nyINsp9NWdnNWPNjXK8W1yw5LBGiP/owt0Qxp5BG6XBXbOsuW/BGhhtuuW/TmcP51\nYQai4xuAiTrIpnMjjm7zYDRZmWKbGseYxBI79PiwvTm22jiFGdrF/EnBjCx3dCtm\nHfOwuppTGSSJ384q0oAIS+5BNSH8PlUr7zCTpDORaAwFl+pNFZll4BK7FrWcZULz\nONtLCpl4LgHeCsbOh1DkFDWIMYHyjtniXlu2vqql2EUp0qcCjGpqKILrFbe5XZ0=\n=skj4\n-----END PGP SIGNATURE-----\n", "payload": "tree c8dabc69676343818b44914550e763ddd18d214d\nparent 2f611da1d66ae98b53358bcb7739884524b7e18d\nparent 6bbcc5bfbbfd9ba5a6d584a753fa32d80e3a7a17\nauthor Dylan DPC <dylan.dpc@gmail.com> 1616547149 +0100\ncommitter GitHub <noreply@github.com> 1616547149 +0100\n\nRollup merge of #83353 - m-ou-se:io-error-avoid-alloc, r=nagisa\n\nAdd internal io::Error::new_const to avoid allocations.\n\nThis makes it possible to have a io::Error containing a message with zero allocations, and uses that everywhere to avoid the *three* allocations involved in `io::Error::new(kind, \"message\")`.\n\nThe function signature isn't perfect, because it needs a reference to the `&str`. So for now, this is just a `pub(crate)` function. Later, we'll be able to use `fn new_const<MSG: &'static str>(kind: ErrorKind)` to make that a bit better. (Then we'll also be able to use some ZST trickery if that would result in more efficient code.)\n\nSee https://github.com/rust-lang/rust/issues/83352\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a42e62fa0a59d0ba620889f97513929a113a6fbd", "html_url": "https://github.com/rust-lang/rust/commit/a42e62fa0a59d0ba620889f97513929a113a6fbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a42e62fa0a59d0ba620889f97513929a113a6fbd/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f611da1d66ae98b53358bcb7739884524b7e18d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f611da1d66ae98b53358bcb7739884524b7e18d", "html_url": "https://github.com/rust-lang/rust/commit/2f611da1d66ae98b53358bcb7739884524b7e18d"}, {"sha": "6bbcc5bfbbfd9ba5a6d584a753fa32d80e3a7a17", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bbcc5bfbbfd9ba5a6d584a753fa32d80e3a7a17", "html_url": "https://github.com/rust-lang/rust/commit/6bbcc5bfbbfd9ba5a6d584a753fa32d80e3a7a17"}], "stats": {"total": 461, "additions": 272, "deletions": 189}, "files": [{"sha": "687ed61b95961061c494be03824b57e923c5ce90", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -1036,7 +1036,7 @@ impl fmt::Display for NulError {\n impl From<NulError> for io::Error {\n     /// Converts a [`NulError`] into a [`io::Error`].\n     fn from(_: NulError) -> io::Error {\n-        io::Error::new(io::ErrorKind::InvalidInput, \"data provided contains a nul byte\")\n+        io::Error::new_const(io::ErrorKind::InvalidInput, &\"data provided contains a nul byte\")\n     }\n }\n "}, {"sha": "ccbc69a975c32e248ab58f47683131e1d2bedb52", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -2188,7 +2188,10 @@ impl DirBuilder {\n         match path.parent() {\n             Some(p) => self.create_dir_all(p)?,\n             None => {\n-                return Err(io::Error::new(io::ErrorKind::Other, \"failed to create whole tree\"));\n+                return Err(io::Error::new_const(\n+                    io::ErrorKind::Other,\n+                    &\"failed to create whole tree\",\n+                ));\n             }\n         }\n         match self.inner.mkdir(path) {"}, {"sha": "80f98bbbad3665c00fbd2828e545a8d92f2d7ddd", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -164,9 +164,9 @@ impl<W: Write> BufWriter<W> {\n \n             match r {\n                 Ok(0) => {\n-                    return Err(Error::new(\n+                    return Err(Error::new_const(\n                         ErrorKind::WriteZero,\n-                        \"failed to write the buffered data\",\n+                        &\"failed to write the buffered data\",\n                     ));\n                 }\n                 Ok(n) => guard.consume(n),"}, {"sha": "9021b4700653845ceae4b3cf1c0a8cd027911b20", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -229,9 +229,9 @@ where\n                 self.pos = n;\n                 Ok(self.pos)\n             }\n-            None => Err(Error::new(\n+            None => Err(Error::new_const(\n                 ErrorKind::InvalidInput,\n-                \"invalid seek to a negative or overflowing position\",\n+                &\"invalid seek to a negative or overflowing position\",\n             )),\n         }\n     }\n@@ -328,9 +328,9 @@ fn slice_write_vectored(\n // Resizing write implementation\n fn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usize> {\n     let pos: usize = (*pos_mut).try_into().map_err(|_| {\n-        Error::new(\n+        Error::new_const(\n             ErrorKind::InvalidInput,\n-            \"cursor position exceeds maximum possible vector length\",\n+            &\"cursor position exceeds maximum possible vector length\",\n         )\n     })?;\n     // Make sure the internal buffer is as least as big as where we"}, {"sha": "2122aa755e15787ebd69e6292e864e1c580a5d96", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -69,6 +69,8 @@ impl fmt::Debug for Error {\n enum Repr {\n     Os(i32),\n     Simple(ErrorKind),\n+    // &str is a fat pointer, but &&str is a thin pointer.\n+    SimpleMessage(ErrorKind, &'static &'static str),\n     Custom(Box<Custom>),\n }\n \n@@ -259,6 +261,18 @@ impl Error {\n         Error { repr: Repr::Custom(Box::new(Custom { kind, error })) }\n     }\n \n+    /// Creates a new I/O error from a known kind of error as well as a\n+    /// constant message.\n+    ///\n+    /// This function does not allocate.\n+    ///\n+    /// This function should maybe change to\n+    /// `new_const<const MSG: &'static str>(kind: ErrorKind)`\n+    /// in the future, when const generics allow that.\n+    pub(crate) const fn new_const(kind: ErrorKind, message: &'static &'static str) -> Error {\n+        Self { repr: Repr::SimpleMessage(kind, message) }\n+    }\n+\n     /// Returns an error representing the last OS error which occurred.\n     ///\n     /// This function reads the value of `errno` for the target platform (e.g.\n@@ -342,6 +356,7 @@ impl Error {\n             Repr::Os(i) => Some(i),\n             Repr::Custom(..) => None,\n             Repr::Simple(..) => None,\n+            Repr::SimpleMessage(..) => None,\n         }\n     }\n \n@@ -377,6 +392,7 @@ impl Error {\n         match self.repr {\n             Repr::Os(..) => None,\n             Repr::Simple(..) => None,\n+            Repr::SimpleMessage(..) => None,\n             Repr::Custom(ref c) => Some(&*c.error),\n         }\n     }\n@@ -448,6 +464,7 @@ impl Error {\n         match self.repr {\n             Repr::Os(..) => None,\n             Repr::Simple(..) => None,\n+            Repr::SimpleMessage(..) => None,\n             Repr::Custom(ref mut c) => Some(&mut *c.error),\n         }\n     }\n@@ -484,6 +501,7 @@ impl Error {\n         match self.repr {\n             Repr::Os(..) => None,\n             Repr::Simple(..) => None,\n+            Repr::SimpleMessage(..) => None,\n             Repr::Custom(c) => Some(c.error),\n         }\n     }\n@@ -512,6 +530,7 @@ impl Error {\n             Repr::Os(code) => sys::decode_error_kind(code),\n             Repr::Custom(ref c) => c.kind,\n             Repr::Simple(kind) => kind,\n+            Repr::SimpleMessage(kind, _) => kind,\n         }\n     }\n }\n@@ -527,6 +546,9 @@ impl fmt::Debug for Repr {\n                 .finish(),\n             Repr::Custom(ref c) => fmt::Debug::fmt(&c, fmt),\n             Repr::Simple(kind) => fmt.debug_tuple(\"Kind\").field(&kind).finish(),\n+            Repr::SimpleMessage(kind, &message) => {\n+                fmt.debug_struct(\"Error\").field(\"kind\", &kind).field(\"message\", &message).finish()\n+            }\n         }\n     }\n }\n@@ -541,6 +563,7 @@ impl fmt::Display for Error {\n             }\n             Repr::Custom(ref c) => c.error.fmt(fmt),\n             Repr::Simple(kind) => write!(fmt, \"{}\", kind.as_str()),\n+            Repr::SimpleMessage(_, &msg) => msg.fmt(fmt),\n         }\n     }\n }\n@@ -551,6 +574,7 @@ impl error::Error for Error {\n     fn description(&self) -> &str {\n         match self.repr {\n             Repr::Os(..) | Repr::Simple(..) => self.kind().as_str(),\n+            Repr::SimpleMessage(_, &msg) => msg,\n             Repr::Custom(ref c) => c.error.description(),\n         }\n     }\n@@ -560,6 +584,7 @@ impl error::Error for Error {\n         match self.repr {\n             Repr::Os(..) => None,\n             Repr::Simple(..) => None,\n+            Repr::SimpleMessage(..) => None,\n             Repr::Custom(ref c) => c.error.cause(),\n         }\n     }\n@@ -568,6 +593,7 @@ impl error::Error for Error {\n         match self.repr {\n             Repr::Os(..) => None,\n             Repr::Simple(..) => None,\n+            Repr::SimpleMessage(..) => None,\n             Repr::Custom(ref c) => c.error.source(),\n         }\n     }"}, {"sha": "5098a46313de39c22385f5b08cde895f5fe6ecae", "filename": "library/std/src/io/error/tests.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -1,9 +1,15 @@\n use super::{Custom, Error, ErrorKind, Repr};\n use crate::error;\n use crate::fmt;\n+use crate::mem::size_of;\n use crate::sys::decode_error_kind;\n use crate::sys::os::error_string;\n \n+#[test]\n+fn test_size() {\n+    assert!(size_of::<Error>() <= size_of::<[usize; 2]>());\n+}\n+\n #[test]\n fn test_debug_error() {\n     let code = 6;\n@@ -51,3 +57,13 @@ fn test_downcasting() {\n     let extracted = err.into_inner().unwrap();\n     extracted.downcast::<TestError>().unwrap();\n }\n+\n+#[test]\n+fn test_const() {\n+    const E: Error = Error::new_const(ErrorKind::NotFound, &\"hello\");\n+\n+    assert_eq!(E.kind(), ErrorKind::NotFound);\n+    assert_eq!(E.to_string(), \"hello\");\n+    assert!(format!(\"{:?}\", E).contains(\"\\\"hello\\\"\"));\n+    assert!(format!(\"{:?}\", E).contains(\"NotFound\"));\n+}"}, {"sha": "6891bd8a664379fed03cf1e0c4878490ef04fbf9", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -263,7 +263,7 @@ impl Read for &[u8] {\n     #[inline]\n     fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n         if buf.len() > self.len() {\n-            return Err(Error::new(ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"));\n+            return Err(Error::new_const(ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"));\n         }\n         let (a, b) = self.split_at(buf.len());\n \n@@ -345,7 +345,7 @@ impl Write for &mut [u8] {\n         if self.write(data)? == data.len() {\n             Ok(())\n         } else {\n-            Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\"))\n+            Err(Error::new_const(ErrorKind::WriteZero, &\"failed to write whole buffer\"))\n         }\n     }\n "}, {"sha": "5316305a30370a67486f30c97b444c7fd55d241e", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -333,7 +333,7 @@ where\n         let ret = f(g.buf);\n         if str::from_utf8(&g.buf[g.len..]).is_err() {\n             ret.and_then(|_| {\n-                Err(Error::new(ErrorKind::InvalidData, \"stream did not contain valid UTF-8\"))\n+                Err(Error::new_const(ErrorKind::InvalidData, &\"stream did not contain valid UTF-8\"))\n             })\n         } else {\n             g.len = g.buf.len();\n@@ -429,7 +429,7 @@ pub(crate) fn default_read_exact<R: Read + ?Sized>(this: &mut R, mut buf: &mut [\n         }\n     }\n     if !buf.is_empty() {\n-        Err(Error::new(ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n+        Err(Error::new_const(ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"))\n     } else {\n         Ok(())\n     }\n@@ -1437,7 +1437,10 @@ pub trait Write {\n         while !buf.is_empty() {\n             match self.write(buf) {\n                 Ok(0) => {\n-                    return Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\"));\n+                    return Err(Error::new_const(\n+                        ErrorKind::WriteZero,\n+                        &\"failed to write whole buffer\",\n+                    ));\n                 }\n                 Ok(n) => buf = &buf[n..],\n                 Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n@@ -1502,7 +1505,10 @@ pub trait Write {\n         while !bufs.is_empty() {\n             match self.write_vectored(bufs) {\n                 Ok(0) => {\n-                    return Err(Error::new(ErrorKind::WriteZero, \"failed to write whole buffer\"));\n+                    return Err(Error::new_const(\n+                        ErrorKind::WriteZero,\n+                        &\"failed to write whole buffer\",\n+                    ));\n                 }\n                 Ok(n) => bufs = IoSlice::advance(bufs, n),\n                 Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n@@ -1576,7 +1582,7 @@ pub trait Write {\n                 if output.error.is_err() {\n                     output.error\n                 } else {\n-                    Err(Error::new(ErrorKind::Other, \"formatter error\"))\n+                    Err(Error::new_const(ErrorKind::Other, &\"formatter error\"))\n                 }\n             }\n         }"}, {"sha": "2b14e16150317f3be9c5c0a2c6576e83b6fddf87", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -152,12 +152,12 @@ fn take_eof() {\n \n     impl Read for R {\n         fn read(&mut self, _: &mut [u8]) -> io::Result<usize> {\n-            Err(io::Error::new(io::ErrorKind::Other, \"\"))\n+            Err(io::Error::new_const(io::ErrorKind::Other, &\"\"))\n         }\n     }\n     impl BufRead for R {\n         fn fill_buf(&mut self) -> io::Result<&[u8]> {\n-            Err(io::Error::new(io::ErrorKind::Other, \"\"))\n+            Err(io::Error::new_const(io::ErrorKind::Other, &\"\"))\n         }\n         fn consume(&mut self, _amt: usize) {}\n     }"}, {"sha": "d814e9b25ba9a0be62e0a6432289883da51d565d", "filename": "library/std/src/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fmod.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -88,6 +88,6 @@ where\n         }\n     }\n     Err(last_err.unwrap_or_else(|| {\n-        Error::new(ErrorKind::InvalidInput, \"could not resolve to any addresses\")\n+        Error::new_const(ErrorKind::InvalidInput, &\"could not resolve to any addresses\")\n     }))\n }"}, {"sha": "b9af5992dffdfa17d6171bb830f19c15858f8a7c", "filename": "library/std/src/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fudp.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -173,7 +173,7 @@ impl UdpSocket {\n     pub fn send_to<A: ToSocketAddrs>(&self, buf: &[u8], addr: A) -> io::Result<usize> {\n         match addr.to_socket_addrs()?.next() {\n             Some(addr) => self.0.send_to(buf, &addr),\n-            None => Err(Error::new(ErrorKind::InvalidInput, \"no addresses to send data to\")),\n+            None => Err(Error::new_const(ErrorKind::InvalidInput, &\"no addresses to send data to\")),\n         }\n     }\n "}, {"sha": "1c0515a150398910ffc6f1450cbf2512acc61570", "filename": "library/std/src/sys/hermit/fd.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffd.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -46,19 +46,19 @@ impl FileDesc {\n         self.duplicate_path(&[])\n     }\n     pub fn duplicate_path(&self, _path: &[u8]) -> io::Result<FileDesc> {\n-        Err(io::Error::new(ErrorKind::Other, \"duplicate isn't supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"duplicate isn't supported\"))\n     }\n \n     pub fn nonblocking(&self) -> io::Result<bool> {\n         Ok(false)\n     }\n \n     pub fn set_cloexec(&self) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"cloexec isn't supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"cloexec isn't supported\"))\n     }\n \n     pub fn set_nonblocking(&self, _nonblocking: bool) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"nonblocking isn't supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"nonblocking isn't supported\"))\n     }\n }\n "}, {"sha": "0f33282fa8370514fa18bf76b6f32a5457be49f1", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -226,7 +226,7 @@ impl OpenOptions {\n             (false, _, true) => Ok(O_WRONLY | O_APPEND),\n             (true, _, true) => Ok(O_RDWR | O_APPEND),\n             (false, false, false) => {\n-                Err(io::Error::new(ErrorKind::InvalidInput, \"invalid access mode\"))\n+                Err(io::Error::new_const(ErrorKind::InvalidInput, &\"invalid access mode\"))\n             }\n         }\n     }\n@@ -236,12 +236,18 @@ impl OpenOptions {\n             (true, false) => {}\n             (false, false) => {\n                 if self.truncate || self.create || self.create_new {\n-                    return Err(io::Error::new(ErrorKind::InvalidInput, \"invalid creation mode\"));\n+                    return Err(io::Error::new_const(\n+                        ErrorKind::InvalidInput,\n+                        &\"invalid creation mode\",\n+                    ));\n                 }\n             }\n             (_, true) => {\n                 if self.truncate && !self.create_new {\n-                    return Err(io::Error::new(ErrorKind::InvalidInput, \"invalid creation mode\"));\n+                    return Err(io::Error::new_const(\n+                        ErrorKind::InvalidInput,\n+                        &\"invalid creation mode\",\n+                    ));\n                 }\n             }\n         }"}, {"sha": "1ecda25c03de5ca05ddc8eed8e2041bb4294fffa", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -55,7 +55,10 @@ pub fn unsupported<T>() -> crate::io::Result<T> {\n }\n \n pub fn unsupported_err() -> crate::io::Error {\n-    crate::io::Error::new(crate::io::ErrorKind::Other, \"operation not supported on HermitCore yet\")\n+    crate::io::Error::new_const(\n+        crate::io::ErrorKind::Other,\n+        &\"operation not supported on HermitCore yet\",\n+    )\n }\n \n // This enum is used as the storage for a bunch of types which can't actually"}, {"sha": "7053487ccfbe02671eab2c1bdbb3bbfb647ed7a1", "filename": "library/std/src/sys/hermit/net.rs", "status": "modified", "additions": 74, "deletions": 66, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fnet.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -14,7 +14,10 @@ use crate::time::Duration;\n /// if not, starts it.\n pub fn init() -> io::Result<()> {\n     if abi::network_init() < 0 {\n-        return Err(io::Error::new(ErrorKind::Other, \"Unable to initialize network interface\"));\n+        return Err(io::Error::new_const(\n+            ErrorKind::Other,\n+            &\"Unable to initialize network interface\",\n+        ));\n     }\n \n     Ok(())\n@@ -47,9 +50,10 @@ impl TcpStream {\n \n         match abi::tcpstream::connect(addr.ip().to_string().as_bytes(), addr.port(), None) {\n             Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n-            _ => {\n-                Err(io::Error::new(ErrorKind::Other, \"Unable to initiate a connection on a socket\"))\n-            }\n+            _ => Err(io::Error::new_const(\n+                ErrorKind::Other,\n+                &\"Unable to initiate a connection on a socket\",\n+            )),\n         }\n     }\n \n@@ -60,42 +64,45 @@ impl TcpStream {\n             Some(duration.as_millis() as u64),\n         ) {\n             Ok(handle) => Ok(TcpStream(Arc::new(Socket(handle)))),\n-            _ => {\n-                Err(io::Error::new(ErrorKind::Other, \"Unable to initiate a connection on a socket\"))\n-            }\n+            _ => Err(io::Error::new_const(\n+                ErrorKind::Other,\n+                &\"Unable to initiate a connection on a socket\",\n+            )),\n         }\n     }\n \n     pub fn set_read_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n         abi::tcpstream::set_read_timeout(*self.0.as_inner(), duration.map(|d| d.as_millis() as u64))\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to set timeout value\"))\n+            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"Unable to set timeout value\"))\n     }\n \n     pub fn set_write_timeout(&self, duration: Option<Duration>) -> io::Result<()> {\n         abi::tcpstream::set_write_timeout(\n             *self.0.as_inner(),\n             duration.map(|d| d.as_millis() as u64),\n         )\n-        .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to set timeout value\"))\n+        .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"Unable to set timeout value\"))\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        let duration = abi::tcpstream::get_read_timeout(*self.0.as_inner())\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to determine timeout value\"))?;\n+        let duration = abi::tcpstream::get_read_timeout(*self.0.as_inner()).map_err(|_| {\n+            io::Error::new_const(ErrorKind::Other, &\"Unable to determine timeout value\")\n+        })?;\n \n         Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        let duration = abi::tcpstream::get_write_timeout(*self.0.as_inner())\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to determine timeout value\"))?;\n+        let duration = abi::tcpstream::get_write_timeout(*self.0.as_inner()).map_err(|_| {\n+            io::Error::new_const(ErrorKind::Other, &\"Unable to determine timeout value\")\n+        })?;\n \n         Ok(duration.map(|d| Duration::from_millis(d)))\n     }\n \n     pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n         abi::tcpstream::peek(*self.0.as_inner(), buf)\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"set_nodelay failed\"))\n+            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"set_nodelay failed\"))\n     }\n \n     pub fn read(&self, buffer: &mut [u8]) -> io::Result<usize> {\n@@ -107,7 +114,7 @@ impl TcpStream {\n \n         for i in ioslice.iter_mut() {\n             let ret = abi::tcpstream::read(*self.0.as_inner(), &mut i[0..])\n-                .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to read on socket\"))?;\n+                .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"Unable to read on socket\"))?;\n \n             if ret != 0 {\n                 size += ret;\n@@ -130,8 +137,9 @@ impl TcpStream {\n         let mut size: usize = 0;\n \n         for i in ioslice.iter() {\n-            size += abi::tcpstream::write(*self.0.as_inner(), i)\n-                .map_err(|_| io::Error::new(ErrorKind::Other, \"Unable to write on socket\"))?;\n+            size += abi::tcpstream::write(*self.0.as_inner(), i).map_err(|_| {\n+                io::Error::new_const(ErrorKind::Other, &\"Unable to write on socket\")\n+            })?;\n         }\n \n         Ok(size)\n@@ -144,26 +152,26 @@ impl TcpStream {\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         let (ipaddr, port) = abi::tcpstream::peer_addr(*self.0.as_inner())\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"peer_addr failed\"))?;\n+            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"peer_addr failed\"))?;\n \n         let saddr = match ipaddr {\n             Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n             Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n             _ => {\n-                return Err(io::Error::new(ErrorKind::Other, \"peer_addr failed\"));\n+                return Err(io::Error::new_const(ErrorKind::Other, &\"peer_addr failed\"));\n             }\n         };\n \n         Ok(saddr)\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        Err(io::Error::new(ErrorKind::Other, \"socket_addr isn't supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"socket_addr isn't supported\"))\n     }\n \n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         abi::tcpstream::shutdown(*self.0.as_inner(), how as i32)\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to shutdown socket\"))\n+            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"unable to shutdown socket\"))\n     }\n \n     pub fn duplicate(&self) -> io::Result<TcpStream> {\n@@ -172,31 +180,31 @@ impl TcpStream {\n \n     pub fn set_nodelay(&self, mode: bool) -> io::Result<()> {\n         abi::tcpstream::set_nodelay(*self.0.as_inner(), mode)\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"set_nodelay failed\"))\n+            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"set_nodelay failed\"))\n     }\n \n     pub fn nodelay(&self) -> io::Result<bool> {\n         abi::tcpstream::nodelay(*self.0.as_inner())\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"nodelay failed\"))\n+            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"nodelay failed\"))\n     }\n \n     pub fn set_ttl(&self, tll: u32) -> io::Result<()> {\n         abi::tcpstream::set_tll(*self.0.as_inner(), tll)\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to set TTL\"))\n+            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"unable to set TTL\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n         abi::tcpstream::get_tll(*self.0.as_inner())\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to get TTL\"))\n+            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"unable to get TTL\"))\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        Err(io::Error::new(ErrorKind::Other, \"take_error isn't supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"take_error isn't supported\"))\n     }\n \n     pub fn set_nonblocking(&self, mode: bool) -> io::Result<()> {\n         abi::tcpstream::set_nonblocking(*self.0.as_inner(), mode)\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"unable to set blocking mode\"))\n+            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"unable to set blocking mode\"))\n     }\n }\n \n@@ -222,12 +230,12 @@ impl TcpListener {\n \n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n         let (handle, ipaddr, port) = abi::tcplistener::accept(self.0.port())\n-            .map_err(|_| io::Error::new(ErrorKind::Other, \"accept failed\"))?;\n+            .map_err(|_| io::Error::new_const(ErrorKind::Other, &\"accept failed\"))?;\n         let saddr = match ipaddr {\n             Ipv4(ref addr) => SocketAddr::new(IpAddr::V4(Ipv4Addr::from(addr.0)), port),\n             Ipv6(ref addr) => SocketAddr::new(IpAddr::V6(Ipv6Addr::from(addr.0)), port),\n             _ => {\n-                return Err(io::Error::new(ErrorKind::Other, \"accept failed\"));\n+                return Err(io::Error::new_const(ErrorKind::Other, &\"accept failed\"));\n             }\n         };\n \n@@ -239,27 +247,27 @@ impl TcpListener {\n     }\n \n     pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn only_v6(&self) -> io::Result<bool> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n }\n \n@@ -273,127 +281,127 @@ pub struct UdpSocket(abi::Handle);\n \n impl UdpSocket {\n     pub fn bind(_: io::Result<&SocketAddr>) -> io::Result<UdpSocket> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn duplicate(&self) -> io::Result<UdpSocket> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn broadcast(&self) -> io::Result<bool> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn ttl(&self) -> io::Result<u32> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n \n     pub fn connect(&self, _: io::Result<&SocketAddr>) -> io::Result<()> {\n-        Err(io::Error::new(ErrorKind::Other, \"not supported\"))\n+        Err(io::Error::new_const(ErrorKind::Other, &\"not supported\"))\n     }\n }\n "}, {"sha": "6bff13ca92ccac65a5056d7799624ca2f674ade2", "filename": "library/std/src/sys/hermit/stdio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fstdio.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -40,7 +40,7 @@ impl io::Write for Stdout {\n         unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n-            Err(io::Error::new(io::ErrorKind::Other, \"Stdout is not able to print\"))\n+            Err(io::Error::new_const(io::ErrorKind::Other, &\"Stdout is not able to print\"))\n         } else {\n             Ok(len as usize)\n         }\n@@ -52,7 +52,7 @@ impl io::Write for Stdout {\n         unsafe { len = abi::write(1, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n-            Err(io::Error::new(io::ErrorKind::Other, \"Stdout is not able to print\"))\n+            Err(io::Error::new_const(io::ErrorKind::Other, &\"Stdout is not able to print\"))\n         } else {\n             Ok(len as usize)\n         }\n@@ -81,7 +81,7 @@ impl io::Write for Stderr {\n         unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n-            Err(io::Error::new(io::ErrorKind::Other, \"Stderr is not able to print\"))\n+            Err(io::Error::new_const(io::ErrorKind::Other, &\"Stderr is not able to print\"))\n         } else {\n             Ok(len as usize)\n         }\n@@ -93,7 +93,7 @@ impl io::Write for Stderr {\n         unsafe { len = abi::write(2, data.as_ptr() as *const u8, data.len()) }\n \n         if len < 0 {\n-            Err(io::Error::new(io::ErrorKind::Other, \"Stderr is not able to print\"))\n+            Err(io::Error::new_const(io::ErrorKind::Other, &\"Stderr is not able to print\"))\n         } else {\n             Ok(len as usize)\n         }"}, {"sha": "f35a3a8a80fc5757e44dcc7a058966f8d95e9d0c", "filename": "library/std/src/sys/hermit/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -37,7 +37,7 @@ impl Thread {\n             // The thread failed to start and as a result p was not consumed. Therefore, it is\n             // safe to reconstruct the box so that it gets deallocated.\n             drop(Box::from_raw(p));\n-            Err(io::Error::new(io::ErrorKind::Other, \"Unable to create thread!\"))\n+            Err(io::Error::new_const(io::ErrorKind::Other, &\"Unable to create thread!\"))\n         } else {\n             Ok(Thread { tid: tid })\n         };"}, {"sha": "3cd245f40d967f9388f293bf37e536b293039360", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -50,7 +50,7 @@ pub fn unsupported<T>() -> crate::io::Result<T> {\n }\n \n pub fn unsupported_err() -> crate::io::Error {\n-    crate::io::Error::new(ErrorKind::Other, \"operation not supported on SGX yet\")\n+    crate::io::Error::new_const(ErrorKind::Other, &\"operation not supported on SGX yet\")\n }\n \n /// This function is used to implement various functions that doesn't exist,\n@@ -61,9 +61,9 @@ pub fn unsupported_err() -> crate::io::Error {\n pub fn sgx_ineffective<T>(v: T) -> crate::io::Result<T> {\n     static SGX_INEFFECTIVE_ERROR: AtomicBool = AtomicBool::new(false);\n     if SGX_INEFFECTIVE_ERROR.load(Ordering::Relaxed) {\n-        Err(crate::io::Error::new(\n+        Err(crate::io::Error::new_const(\n             ErrorKind::Other,\n-            \"operation can't be trusted to have any effect on SGX\",\n+            &\"operation can't be trusted to have any effect on SGX\",\n         ))\n     } else {\n         Ok(v)"}, {"sha": "c0c5d55548c5f52a60fe079901a6cf96af72bed3", "filename": "library/std/src/sys/sgx/net.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fnet.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -97,9 +97,9 @@ impl TcpStream {\n \n     pub fn connect_timeout(addr: &SocketAddr, dur: Duration) -> io::Result<TcpStream> {\n         if dur == Duration::default() {\n-            return Err(io::Error::new(\n+            return Err(io::Error::new_const(\n                 io::ErrorKind::InvalidInput,\n-                \"cannot set a 0 duration timeout\",\n+                &\"cannot set a 0 duration timeout\",\n             ));\n         }\n         Self::connect(Ok(addr)) // FIXME: ignoring timeout\n@@ -108,9 +108,9 @@ impl TcpStream {\n     pub fn set_read_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         match dur {\n             Some(dur) if dur == Duration::default() => {\n-                return Err(io::Error::new(\n+                return Err(io::Error::new_const(\n                     io::ErrorKind::InvalidInput,\n-                    \"cannot set a 0 duration timeout\",\n+                    &\"cannot set a 0 duration timeout\",\n                 ));\n             }\n             _ => sgx_ineffective(()),\n@@ -120,9 +120,9 @@ impl TcpStream {\n     pub fn set_write_timeout(&self, dur: Option<Duration>) -> io::Result<()> {\n         match dur {\n             Some(dur) if dur == Duration::default() => {\n-                return Err(io::Error::new(\n+                return Err(io::Error::new_const(\n                     io::ErrorKind::InvalidInput,\n-                    \"cannot set a 0 duration timeout\",\n+                    &\"cannot set a 0 duration timeout\",\n                 ));\n             }\n             _ => sgx_ineffective(()),"}, {"sha": "cf6aa31b7cfe331486a78d80942ec31ed5b88f4c", "filename": "library/std/src/sys/unix/android.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fandroid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fandroid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fandroid.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -96,7 +96,7 @@ pub fn ftruncate64(fd: c_int, size: u64) -> io::Result<()> {\n             Some(f) => cvt_r(|| f(fd, size as i64)).map(drop),\n             None => {\n                 if size > i32::MAX as u64 {\n-                    Err(io::Error::new(io::ErrorKind::InvalidInput, \"cannot truncate >2GB\"))\n+                    Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"cannot truncate >2GB\"))\n                 } else {\n                     cvt_r(|| ftruncate(fd, size as i32)).map(drop)\n                 }\n@@ -123,7 +123,7 @@ pub unsafe fn cvt_pread64(\n         if let Ok(o) = offset.try_into() {\n             cvt(pread(fd, buf, count, o))\n         } else {\n-            Err(io::Error::new(io::ErrorKind::InvalidInput, \"cannot pread >2GB\"))\n+            Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"cannot pread >2GB\"))\n         }\n     })\n }\n@@ -141,7 +141,7 @@ pub unsafe fn cvt_pwrite64(\n         if let Ok(o) = offset.try_into() {\n             cvt(pwrite(fd, buf, count, o))\n         } else {\n-            Err(io::Error::new(io::ErrorKind::InvalidInput, \"cannot pwrite >2GB\"))\n+            Err(io::Error::new_const(io::ErrorKind::InvalidInput, &\"cannot pwrite >2GB\"))\n         }\n     })\n }"}, {"sha": "9a982a4acd9e292d93f6cd3e6759d6952054b412", "filename": "library/std/src/sys/unix/ext/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -109,7 +109,7 @@ pub trait FileExt {\n             }\n         }\n         if !buf.is_empty() {\n-            Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n+            Err(io::Error::new_const(io::ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"))\n         } else {\n             Ok(())\n         }\n@@ -191,9 +191,9 @@ pub trait FileExt {\n         while !buf.is_empty() {\n             match self.write_at(buf, offset) {\n                 Ok(0) => {\n-                    return Err(io::Error::new(\n+                    return Err(io::Error::new_const(\n                         io::ErrorKind::WriteZero,\n-                        \"failed to write whole buffer\",\n+                        &\"failed to write whole buffer\",\n                     ));\n                 }\n                 Ok(n) => {"}, {"sha": "6e7d1f1678a9e8ca63b053dc58c59f0a2652eaa2", "filename": "library/std/src/sys/unix/ext/net/addr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Faddr.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -29,16 +29,16 @@ pub(super) unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un,\n     let bytes = path.as_os_str().as_bytes();\n \n     if bytes.contains(&0) {\n-        return Err(io::Error::new(\n+        return Err(io::Error::new_const(\n             io::ErrorKind::InvalidInput,\n-            \"paths may not contain interior null bytes\",\n+            &\"paths may not contain interior null bytes\",\n         ));\n     }\n \n     if bytes.len() >= addr.sun_path.len() {\n-        return Err(io::Error::new(\n+        return Err(io::Error::new_const(\n             io::ErrorKind::InvalidInput,\n-            \"path must be shorter than SUN_LEN\",\n+            &\"path must be shorter than SUN_LEN\",\n         ));\n     }\n     for (dst, src) in addr.sun_path.iter_mut().zip(bytes.iter()) {\n@@ -118,9 +118,9 @@ impl SocketAddr {\n             // linux returns zero bytes of address\n             len = sun_path_offset(&addr) as libc::socklen_t; // i.e., zero-length address\n         } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n-            return Err(io::Error::new(\n+            return Err(io::Error::new_const(\n                 io::ErrorKind::InvalidInput,\n-                \"file descriptor did not correspond to a Unix socket\",\n+                &\"file descriptor did not correspond to a Unix socket\",\n             ));\n         }\n "}, {"sha": "f25a6280cd0769aa20cd24dca25efc7a86711b00", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -357,17 +357,17 @@ impl FileAttr {\n                         tv_nsec: ext.stx_btime.tv_nsec as _,\n                     }))\n                 } else {\n-                    Err(io::Error::new(\n+                    Err(io::Error::new_const(\n                         io::ErrorKind::Other,\n-                        \"creation time is not available for the filesystem\",\n+                        &\"creation time is not available for the filesystem\",\n                     ))\n                 };\n             }\n         }\n \n-        Err(io::Error::new(\n+        Err(io::Error::new_const(\n             io::ErrorKind::Other,\n-            \"creation time is not available on this platform \\\n+            &\"creation time is not available on this platform \\\n                             currently\",\n         ))\n     }\n@@ -1156,9 +1156,9 @@ fn open_from(from: &Path) -> io::Result<(crate::fs::File, crate::fs::Metadata)>\n     let reader = File::open(from)?;\n     let metadata = reader.metadata()?;\n     if !metadata.is_file() {\n-        return Err(Error::new(\n+        return Err(Error::new_const(\n             ErrorKind::InvalidInput,\n-            \"the source path is not an existing regular file\",\n+            &\"the source path is not an existing regular file\",\n         ));\n     }\n     Ok((reader, metadata))"}, {"sha": "d60a4b5591fae39f7b9c90f050bf3db2a3fe05f6", "filename": "library/std/src/sys/unix/l4re.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fl4re.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -1,6 +1,6 @@\n macro_rules! unimpl {\n     () => {\n-        return Err(io::Error::new(io::ErrorKind::Other, \"No networking available on L4Re.\"));\n+        return Err(io::Error::new_const(io::ErrorKind::Other, &\"No networking available on L4Re.\"));\n     };\n }\n "}, {"sha": "e6b61062d15ff964dac8e491b3275915ce5a760a", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -139,9 +139,9 @@ impl Socket {\n         let mut pollfd = libc::pollfd { fd: self.0.raw(), events: libc::POLLOUT, revents: 0 };\n \n         if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new(\n+            return Err(io::Error::new_const(\n                 io::ErrorKind::InvalidInput,\n-                \"cannot set a 0 duration timeout\",\n+                &\"cannot set a 0 duration timeout\",\n             ));\n         }\n \n@@ -150,7 +150,7 @@ impl Socket {\n         loop {\n             let elapsed = start.elapsed();\n             if elapsed >= timeout {\n-                return Err(io::Error::new(io::ErrorKind::TimedOut, \"connection timed out\"));\n+                return Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\"));\n             }\n \n             let timeout = timeout - elapsed;\n@@ -177,7 +177,10 @@ impl Socket {\n                     // for POLLHUP rather than read readiness\n                     if pollfd.revents & libc::POLLHUP != 0 {\n                         let e = self.take_error()?.unwrap_or_else(|| {\n-                            io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n+                            io::Error::new_const(\n+                                io::ErrorKind::Other,\n+                                &\"no error set after POLLHUP\",\n+                            )\n                         });\n                         return Err(e);\n                     }\n@@ -318,9 +321,9 @@ impl Socket {\n         let timeout = match dur {\n             Some(dur) => {\n                 if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n-                    return Err(io::Error::new(\n+                    return Err(io::Error::new_const(\n                         io::ErrorKind::InvalidInput,\n-                        \"cannot set a 0 duration timeout\",\n+                        &\"cannot set a 0 duration timeout\",\n                     ));\n                 }\n "}, {"sha": "4a077e2151ed98ce55c48e1c09dd63bc26964ca1", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -287,9 +287,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n                 0,\n             ))?;\n             if path_len <= 1 {\n-                return Err(io::Error::new(\n+                return Err(io::Error::new_const(\n                     io::ErrorKind::Other,\n-                    \"KERN_PROC_PATHNAME sysctl returned zero-length string\",\n+                    &\"KERN_PROC_PATHNAME sysctl returned zero-length string\",\n                 ));\n             }\n             let mut path: Vec<u8> = Vec::with_capacity(path_len);\n@@ -310,9 +310,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         if curproc_exe.is_file() {\n             return crate::fs::read_link(curproc_exe);\n         }\n-        Err(io::Error::new(\n+        Err(io::Error::new_const(\n             io::ErrorKind::Other,\n-            \"/proc/curproc/exe doesn't point to regular file.\",\n+            &\"/proc/curproc/exe doesn't point to regular file.\",\n         ))\n     }\n     sysctl().or_else(|_| procfs())\n@@ -329,7 +329,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         cvt(libc::sysctl(mib, 4, argv.as_mut_ptr() as *mut _, &mut argv_len, ptr::null_mut(), 0))?;\n         argv.set_len(argv_len as usize);\n         if argv[0].is_null() {\n-            return Err(io::Error::new(io::ErrorKind::Other, \"no current exe available\"));\n+            return Err(io::Error::new_const(io::ErrorKind::Other, &\"no current exe available\"));\n         }\n         let argv0 = CStr::from_ptr(argv[0]).to_bytes();\n         if argv0[0] == b'.' || argv0.iter().any(|b| *b == b'/') {\n@@ -343,9 +343,9 @@ pub fn current_exe() -> io::Result<PathBuf> {\n #[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"emscripten\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     match crate::fs::read_link(\"/proc/self/exe\") {\n-        Err(ref e) if e.kind() == io::ErrorKind::NotFound => Err(io::Error::new(\n+        Err(ref e) if e.kind() == io::ErrorKind::NotFound => Err(io::Error::new_const(\n             io::ErrorKind::Other,\n-            \"no /proc/self/exe available. Is /proc mounted?\",\n+            &\"no /proc/self/exe available. Is /proc mounted?\",\n         )),\n         other => other,\n     }\n@@ -431,7 +431,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n             _get_next_image_info(0, &mut cookie, &mut info, mem::size_of::<image_info>() as i32);\n         if result != 0 {\n             use crate::io::ErrorKind;\n-            Err(io::Error::new(ErrorKind::Other, \"Error getting executable path\"))\n+            Err(io::Error::new_const(ErrorKind::Other, &\"Error getting executable path\"))\n         } else {\n             let name = CStr::from_ptr(info.name.as_ptr()).to_bytes();\n             Ok(PathBuf::from(OsStr::from_bytes(name)))\n@@ -447,7 +447,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n #[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     use crate::io::ErrorKind;\n-    Err(io::Error::new(ErrorKind::Other, \"Not yet implemented!\"))\n+    Err(io::Error::new_const(ErrorKind::Other, &\"Not yet implemented!\"))\n }\n \n #[cfg(target_os = \"vxworks\")]"}, {"sha": "b19ad4ccdc777e15feee924de05a28a8bf817d8b", "filename": "library/std/src/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -22,9 +22,9 @@ impl Command {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return Err(io::Error::new(\n+            return Err(io::Error::new_const(\n                 io::ErrorKind::InvalidInput,\n-                \"nul byte found in provided data\",\n+                &\"nul byte found in provided data\",\n             ));\n         }\n \n@@ -37,7 +37,10 @@ impl Command {\n \n     pub fn exec(&mut self, default: Stdio) -> io::Error {\n         if self.saw_nul() {\n-            return io::Error::new(io::ErrorKind::InvalidInput, \"nul byte found in provided data\");\n+            return io::Error::new_const(\n+                io::ErrorKind::InvalidInput,\n+                &\"nul byte found in provided data\",\n+            );\n         }\n \n         match self.setup_io(default, true) {\n@@ -182,9 +185,9 @@ impl Process {\n             ))?;\n         }\n         if actual != 1 {\n-            return Err(io::Error::new(\n+            return Err(io::Error::new_const(\n                 io::ErrorKind::InvalidData,\n-                \"Failed to get exit status of process\",\n+                &\"Failed to get exit status of process\",\n             ));\n         }\n         Ok(ExitStatus(proc_info.return_code))\n@@ -220,9 +223,9 @@ impl Process {\n             ))?;\n         }\n         if actual != 1 {\n-            return Err(io::Error::new(\n+            return Err(io::Error::new_const(\n                 io::ErrorKind::InvalidData,\n-                \"Failed to get exit status of process\",\n+                &\"Failed to get exit status of process\",\n             ));\n         }\n         Ok(Some(ExitStatus(proc_info.return_code)))"}, {"sha": "01f1318fe8078d61c471c570f962d249344c2535", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -28,7 +28,10 @@ impl Command {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return Err(io::Error::new(ErrorKind::InvalidInput, \"nul byte found in provided data\"));\n+            return Err(io::Error::new_const(\n+                ErrorKind::InvalidInput,\n+                &\"nul byte found in provided data\",\n+            ));\n         }\n \n         let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n@@ -118,7 +121,10 @@ impl Command {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return io::Error::new(ErrorKind::InvalidInput, \"nul byte found in provided data\");\n+            return io::Error::new_const(\n+                ErrorKind::InvalidInput,\n+                &\"nul byte found in provided data\",\n+            );\n         }\n \n         match self.setup_io(default, true) {\n@@ -442,9 +448,9 @@ impl Process {\n         // and used for another process, and we probably shouldn't be killing\n         // random processes, so just return an error.\n         if self.status.is_some() {\n-            Err(Error::new(\n+            Err(Error::new_const(\n                 ErrorKind::InvalidInput,\n-                \"invalid argument: can't kill an exited process\",\n+                &\"invalid argument: can't kill an exited process\",\n             ))\n         } else {\n             cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(drop)"}, {"sha": "01e4fd3c994d42db470020386ba4a429150d8301", "filename": "library/std/src/sys/unsupported/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -18,7 +18,7 @@ pub fn unsupported<T>() -> std_io::Result<T> {\n }\n \n pub fn unsupported_err() -> std_io::Error {\n-    std_io::Error::new(std_io::ErrorKind::Other, \"operation not supported on this platform\")\n+    std_io::Error::new_const(std_io::ErrorKind::Other, &\"operation not supported on this platform\")\n }\n \n pub fn decode_error_kind(_code: i32) -> crate::io::ErrorKind {"}, {"sha": "897927e7b79a7f4fec3dbe41446547012d1ab26b", "filename": "library/std/src/sys/unsupported/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fos.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -80,11 +80,11 @@ pub fn getenv(_: &OsStr) -> io::Result<Option<OsString>> {\n }\n \n pub fn setenv(_: &OsStr, _: &OsStr) -> io::Result<()> {\n-    Err(io::Error::new(io::ErrorKind::Other, \"cannot set env vars on this platform\"))\n+    Err(io::Error::new_const(io::ErrorKind::Other, &\"cannot set env vars on this platform\"))\n }\n \n pub fn unsetenv(_: &OsStr) -> io::Result<()> {\n-    Err(io::Error::new(io::ErrorKind::Other, \"cannot unset env vars on this platform\"))\n+    Err(io::Error::new_const(io::ErrorKind::Other, &\"cannot unset env vars on this platform\"))\n }\n \n pub fn temp_dir() -> PathBuf {"}, {"sha": "295452327eb7053abec2d4b751ad48c32220f03d", "filename": "library/std/src/sys/vxworks/process/process_vxworks.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -22,7 +22,10 @@ impl Command {\n         let envp = self.capture_env();\n \n         if self.saw_nul() {\n-            return Err(io::Error::new(ErrorKind::InvalidInput, \"nul byte found in provided data\"));\n+            return Err(io::Error::new_const(\n+                ErrorKind::InvalidInput,\n+                &\"nul byte found in provided data\",\n+            ));\n         }\n         let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n         let mut p = Process { pid: 0, status: None };\n@@ -134,9 +137,9 @@ impl Process {\n         // and used for another process, and we probably shouldn't be killing\n         // random processes, so just return an error.\n         if self.status.is_some() {\n-            Err(Error::new(\n+            Err(Error::new_const(\n                 ErrorKind::InvalidInput,\n-                \"invalid argument: can't kill an exited process\",\n+                &\"invalid argument: can't kill an exited process\",\n             ))\n         } else {\n             cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(drop)"}, {"sha": "ba4057bd34ca2c13881a888d2ebebe16deaefa35", "filename": "library/std/src/sys/wasi/ext/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fext%2Ffs.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -85,7 +85,7 @@ pub trait FileExt {\n             }\n         }\n         if !buf.is_empty() {\n-            Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n+            Err(io::Error::new_const(io::ErrorKind::UnexpectedEof, &\"failed to fill whole buffer\"))\n         } else {\n             Ok(())\n         }\n@@ -151,9 +151,9 @@ pub trait FileExt {\n         while !buf.is_empty() {\n             match self.write_at(buf, offset) {\n                 Ok(0) => {\n-                    return Err(io::Error::new(\n+                    return Err(io::Error::new_const(\n                         io::ErrorKind::WriteZero,\n-                        \"failed to write whole buffer\",\n+                        &\"failed to write whole buffer\",\n                     ));\n                 }\n                 Ok(n) => {\n@@ -532,5 +532,5 @@ pub fn symlink_path<P: AsRef<Path>, U: AsRef<Path>>(old_path: P, new_path: U) ->\n }\n \n fn osstr2str(f: &OsStr) -> io::Result<&str> {\n-    f.to_str().ok_or_else(|| io::Error::new(io::ErrorKind::Other, \"input must be utf-8\"))\n+    f.to_str().ok_or_else(|| io::Error::new_const(io::ErrorKind::Other, &\"input must be utf-8\"))\n }"}, {"sha": "1ec3ff6a10f9a6d5fff5bcc6fda93f21557f7e03", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -670,7 +670,7 @@ fn open_parent(p: &Path) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n }\n \n pub fn osstr2str(f: &OsStr) -> io::Result<&str> {\n-    f.to_str().ok_or_else(|| io::Error::new(io::ErrorKind::Other, \"input must be utf-8\"))\n+    f.to_str().ok_or_else(|| io::Error::new_const(io::ErrorKind::Other, &\"input must be utf-8\"))\n }\n \n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {"}, {"sha": "c6509db80c05be2a5cdb94cf89b15801db209cf1", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -513,9 +513,9 @@ impl File {\n                     )\n                 }\n                 _ => {\n-                    return Err(io::Error::new(\n+                    return Err(io::Error::new_const(\n                         io::ErrorKind::Other,\n-                        \"Unsupported reparse point type\",\n+                        &\"Unsupported reparse point type\",\n                     ));\n                 }\n             };\n@@ -802,7 +802,7 @@ pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n \n #[cfg(target_vendor = \"uwp\")]\n pub fn link(_original: &Path, _link: &Path) -> io::Result<()> {\n-    return Err(io::Error::new(io::ErrorKind::Other, \"hard link are not supported on UWP\"));\n+    return Err(io::Error::new_const(io::ErrorKind::Other, &\"hard link are not supported on UWP\"));\n }\n \n pub fn stat(path: &Path) -> io::Result<FileAttr> {"}, {"sha": "0353c9811f15f79d38c76d2e077cfb1ea0586377", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -130,9 +130,9 @@ pub fn to_u16s<S: AsRef<OsStr>>(s: S) -> crate::io::Result<Vec<u16>> {\n     fn inner(s: &OsStr) -> crate::io::Result<Vec<u16>> {\n         let mut maybe_result: Vec<u16> = s.encode_wide().collect();\n         if unrolled_find_u16s(0, &maybe_result).is_some() {\n-            return Err(crate::io::Error::new(\n+            return Err(crate::io::Error::new_const(\n                 ErrorKind::InvalidInput,\n-                \"strings passed to WinAPI cannot contain NULs\",\n+                &\"strings passed to WinAPI cannot contain NULs\",\n             ));\n         }\n         maybe_result.push(0);"}, {"sha": "e50adcb28a4b7a30124f9bdde83b767ac27570e2", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -136,9 +136,9 @@ impl Socket {\n         }\n \n         if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new(\n+            return Err(io::Error::new_const(\n                 io::ErrorKind::InvalidInput,\n-                \"cannot set a 0 duration timeout\",\n+                &\"cannot set a 0 duration timeout\",\n             ));\n         }\n \n@@ -164,7 +164,7 @@ impl Socket {\n             unsafe { cvt(c::select(1, ptr::null_mut(), &mut writefds, &mut errorfds, &timeout))? };\n \n         match n {\n-            0 => Err(io::Error::new(io::ErrorKind::TimedOut, \"connection timed out\")),\n+            0 => Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\")),\n             _ => {\n                 if writefds.fd_count != 1 {\n                     if let Some(e) = self.take_error()? {\n@@ -339,9 +339,9 @@ impl Socket {\n             Some(dur) => {\n                 let timeout = sys::dur2timeout(dur);\n                 if timeout == 0 {\n-                    return Err(io::Error::new(\n+                    return Err(io::Error::new_const(\n                         io::ErrorKind::InvalidInput,\n-                        \"cannot set a 0 duration timeout\",\n+                        &\"cannot set a 0 duration timeout\",\n                     ));\n                 }\n                 timeout\n@@ -370,7 +370,7 @@ impl Socket {\n \n     #[cfg(target_vendor = \"uwp\")]\n     fn set_no_inherit(&self) -> io::Result<()> {\n-        Err(io::Error::new(io::ErrorKind::Other, \"Unavailable on UWP\"))\n+        Err(io::Error::new_const(io::ErrorKind::Other, &\"Unavailable on UWP\"))\n     }\n \n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {"}, {"sha": "30bbfdd0dd1e2412d231f8fa4aaa92630a91a79d", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -62,7 +62,7 @@ impl AsRef<OsStr> for EnvKey {\n \n fn ensure_no_nuls<T: AsRef<OsStr>>(str: T) -> io::Result<T> {\n     if str.as_ref().encode_wide().any(|b| b == 0) {\n-        Err(io::Error::new(ErrorKind::InvalidInput, \"nul byte found in provided data\"))\n+        Err(io::Error::new_const(ErrorKind::InvalidInput, &\"nul byte found in provided data\"))\n     } else {\n         Ok(str)\n     }"}, {"sha": "be3141e46a1cc375b10076648abe3b0b8fda7d6a", "filename": "library/std/src/sys/windows/stdio.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstdio.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -68,9 +68,9 @@ fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n     let utf8 = match str::from_utf8(&data[..len]) {\n         Ok(s) => s,\n         Err(ref e) if e.valid_up_to() == 0 => {\n-            return Err(io::Error::new(\n+            return Err(io::Error::new_const(\n                 io::ErrorKind::InvalidData,\n-                \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n+                &\"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\",\n             ));\n         }\n         Err(e) => str::from_utf8(&data[..e.valid_up_to()]).unwrap(),\n@@ -149,9 +149,9 @@ impl io::Read for Stdin {\n         if buf.len() == 0 {\n             return Ok(0);\n         } else if buf.len() < 4 {\n-            return Err(io::Error::new(\n+            return Err(io::Error::new_const(\n                 io::ErrorKind::InvalidInput,\n-                \"Windows stdin in console mode does not support a buffer too small to \\\n+                &\"Windows stdin in console mode does not support a buffer too small to \\\n                  guarantee holding one arbitrary UTF-8 character (4 bytes)\",\n             ));\n         }\n@@ -243,9 +243,9 @@ fn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n             }\n             Err(_) => {\n                 // We can't really do any better than forget all data and return an error.\n-                return Err(io::Error::new(\n+                return Err(io::Error::new_const(\n                     io::ErrorKind::InvalidData,\n-                    \"Windows stdin in console mode does not support non-UTF-16 input; \\\n+                    &\"Windows stdin in console mode does not support non-UTF-16 input; \\\n                      encountered unpaired surrogate\",\n                 ));\n             }"}, {"sha": "92d0cc60850c6978233f400dce6c98bb9a6eaad4", "filename": "library/std/src/sys_common/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys_common%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys_common%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Ffs.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -9,9 +9,9 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     let metadata = reader.metadata()?;\n \n     if !metadata.is_file() {\n-        return Err(Error::new(\n+        return Err(Error::new_const(\n             ErrorKind::InvalidInput,\n-            \"the source path is not an existing regular file\",\n+            &\"the source path is not an existing regular file\",\n         ));\n     }\n "}, {"sha": "d5f29c4a439702d907fc5765a27bb832cf8aa6d0", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -108,7 +108,7 @@ pub fn sockaddr_to_addr(storage: &c::sockaddr_storage, len: usize) -> io::Result\n                 *(storage as *const _ as *const c::sockaddr_in6)\n             })))\n         }\n-        _ => Err(Error::new(ErrorKind::InvalidInput, \"invalid argument\")),\n+        _ => Err(Error::new_const(ErrorKind::InvalidInput, &\"invalid argument\")),\n     }\n }\n \n@@ -171,7 +171,7 @@ impl TryFrom<&str> for LookupHost {\n             ($e:expr, $msg:expr) => {\n                 match $e {\n                     Some(r) => r,\n-                    None => return Err(io::Error::new(io::ErrorKind::InvalidInput, $msg)),\n+                    None => return Err(io::Error::new_const(io::ErrorKind::InvalidInput, &$msg)),\n                 }\n             };\n         }"}, {"sha": "e8cdde880145935c8028a193abd738300ef8bab7", "filename": "library/std/src/thread/available_concurrency.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fthread%2Favailable_concurrency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a42e62fa0a59d0ba620889f97513929a113a6fbd/library%2Fstd%2Fsrc%2Fthread%2Favailable_concurrency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Favailable_concurrency.rs?ref=a42e62fa0a59d0ba620889f97513929a113a6fbd", "patch": "@@ -64,7 +64,7 @@ cfg_if::cfg_if! {\n                 sysinfo.dwNumberOfProcessors as usize\n             };\n             match res {\n-                0 => Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\")),\n+                0 => Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\")),\n                 cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus) }),\n             }\n         }\n@@ -81,7 +81,7 @@ cfg_if::cfg_if! {\n         fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n             match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n                 -1 => Err(io::Error::last_os_error()),\n-                0 => Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\")),\n+                0 => Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\")),\n                 cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) }),\n             }\n         }\n@@ -114,7 +114,7 @@ cfg_if::cfg_if! {\n                 if res == -1 {\n                     return Err(io::Error::last_os_error());\n                 } else if cpus == 0 {\n-                    return Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"));\n+                    return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n                 }\n             }\n             Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n@@ -142,15 +142,15 @@ cfg_if::cfg_if! {\n             if res == -1 {\n                 return Err(io::Error::last_os_error());\n             } else if cpus == 0 {\n-                return Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"));\n+                return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n             }\n \n             Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n         }\n     } else {\n         // FIXME: implement on vxWorks, Redox, HermitCore, Haiku, l4re\n         fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n-            Err(io::Error::new(io::ErrorKind::NotFound, \"The number of hardware threads is not known for the target platform\"))\n+            Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"))\n         }\n     }\n }"}]}