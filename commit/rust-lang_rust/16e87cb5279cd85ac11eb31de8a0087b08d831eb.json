{"sha": "16e87cb5279cd85ac11eb31de8a0087b08d831eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZTg3Y2I1Mjc5Y2Q4NWFjMTFlYjMxZGU4YTAwODdiMDhkODMxZWI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-29T22:50:53Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-09-24T01:23:18Z"}, "message": "librustc: Make the fall-through case in match not use garbage collected functions", "tree": {"sha": "438935c0c7be203d6051be6af5fef8671a92beeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/438935c0c7be203d6051be6af5fef8671a92beeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16e87cb5279cd85ac11eb31de8a0087b08d831eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16e87cb5279cd85ac11eb31de8a0087b08d831eb", "html_url": "https://github.com/rust-lang/rust/commit/16e87cb5279cd85ac11eb31de8a0087b08d831eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16e87cb5279cd85ac11eb31de8a0087b08d831eb/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15ce791ff5b5756b1455c65708782bc8028de56f", "url": "https://api.github.com/repos/rust-lang/rust/commits/15ce791ff5b5756b1455c65708782bc8028de56f", "html_url": "https://github.com/rust-lang/rust/commit/15ce791ff5b5756b1455c65708782bc8028de56f"}], "stats": {"total": 102, "additions": 76, "deletions": 26}, "files": [{"sha": "464bcfee48e0c6ca1b51fe5350031435579390d0", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 76, "deletions": 26, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/16e87cb5279cd85ac11eb31de8a0087b08d831eb/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e87cb5279cd85ac11eb31de8a0087b08d831eb/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=16e87cb5279cd85ac11eb31de8a0087b08d831eb", "patch": "@@ -533,7 +533,7 @@ fn enter_default<'r>(bcx: @mut Block,\n                      m: &[Match<'r>],\n                      col: uint,\n                      val: ValueRef,\n-                     chk: Option<mk_fail>)\n+                     chk: FailureHandler)\n                       -> ~[Match<'r>] {\n     debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n@@ -567,7 +567,7 @@ fn enter_default<'r>(bcx: @mut Block,\n     // we don't need any default cases. If the check *isn't* nonexhaustive\n     // (because chk is Some), then we need the defaults anyways.\n     let is_exhaustive = match matches.last_opt() {\n-        Some(m) if m.data.arm.guard.is_some() && chk.is_none() => true,\n+        Some(m) if m.data.arm.guard.is_some() && chk.is_infallible() => true,\n         _ => false\n     };\n \n@@ -1185,7 +1185,62 @@ fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n     }\n }\n \n-type mk_fail = @fn() -> BasicBlockRef;\n+trait CustomFailureHandler {\n+    fn handle_fail(&self) -> BasicBlockRef;\n+}\n+\n+struct DynamicFailureHandler {\n+    bcx: @mut Block,\n+    sp: span,\n+    msg: @str,\n+    finished: @mut Option<BasicBlockRef>,\n+}\n+\n+impl CustomFailureHandler for DynamicFailureHandler {\n+    fn handle_fail(&self) -> BasicBlockRef {\n+        match *self.finished {\n+            Some(bb) => return bb,\n+            _ => (),\n+        }\n+\n+        let fail_cx = sub_block(self.bcx, \"case_fallthrough\");\n+        controlflow::trans_fail(fail_cx, Some(self.sp), self.msg);\n+        *self.finished = Some(fail_cx.llbb);\n+        fail_cx.llbb\n+    }\n+}\n+\n+/// What to do when the pattern match fails.\n+enum FailureHandler {\n+    Infallible,\n+    JumpToBasicBlock(BasicBlockRef),\n+    CustomFailureHandlerClass(@CustomFailureHandler),\n+}\n+\n+impl FailureHandler {\n+    fn is_infallible(&self) -> bool {\n+        match *self {\n+            Infallible => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn is_fallible(&self) -> bool {\n+        !self.is_infallible()\n+    }\n+\n+    fn handle_fail(&self) -> BasicBlockRef {\n+        match *self {\n+            Infallible => {\n+                fail!(\"attempted to fail in infallible failure handler!\")\n+            }\n+            JumpToBasicBlock(basic_block) => basic_block,\n+            CustomFailureHandlerClass(custom_failure_handler) => {\n+                custom_failure_handler.handle_fail()\n+            }\n+        }\n+    }\n+}\n \n fn pick_col(m: &[Match]) -> uint {\n     fn score(p: &ast::Pat) -> uint {\n@@ -1347,7 +1402,7 @@ fn compile_guard(bcx: @mut Block,\n                      data: &ArmData,\n                      m: &[Match],\n                      vals: &[ValueRef],\n-                     chk: Option<mk_fail>)\n+                     chk: FailureHandler)\n                   -> @mut Block {\n     debug!(\"compile_guard(bcx=%s, guard_expr=%s, m=%s, vals=%s)\",\n            bcx.to_str(),\n@@ -1400,9 +1455,9 @@ fn compile_guard(bcx: @mut Block,\n }\n \n fn compile_submatch(bcx: @mut Block,\n-                        m: &[Match],\n-                        vals: &[ValueRef],\n-                        chk: Option<mk_fail>) {\n+                    m: &[Match],\n+                    vals: &[ValueRef],\n+                    chk: FailureHandler) {\n     debug!(\"compile_submatch(bcx=%s, m=%s, vals=%s)\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -1412,11 +1467,11 @@ fn compile_submatch(bcx: @mut Block,\n     /*\n       For an empty match, a fall-through case must exist\n      */\n-    assert!((m.len() > 0u || chk.is_some()));\n+    assert!((m.len() > 0u || chk.is_fallible()));\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n     if m.len() == 0u {\n-        Br(bcx, chk.unwrap()());\n+        Br(bcx, chk.handle_fail());\n         return;\n     }\n     if m[0].pats.len() == 0u {\n@@ -1454,7 +1509,7 @@ fn compile_submatch(bcx: @mut Block,\n fn compile_submatch_continue(mut bcx: @mut Block,\n                              m: &[Match],\n                              vals: &[ValueRef],\n-                             chk: Option<mk_fail>,\n+                             chk: FailureHandler,\n                              col: uint,\n                              val: ValueRef) {\n     let tcx = bcx.tcx();\n@@ -1617,7 +1672,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n     };\n \n     let defaults = enter_default(else_cx, dm, m, col, val, chk);\n-    let exhaustive = chk.is_none() && defaults.len() == 0u;\n+    let exhaustive = chk.is_infallible() && defaults.len() == 0u;\n     let len = opts.len();\n \n     // Compile subtrees for each option\n@@ -1721,7 +1776,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n \n                   // If none of these subcases match, move on to the\n                   // next condition.\n-                  branch_chk = Some::<mk_fail>(|| bcx.llbb);\n+                  branch_chk = JumpToBasicBlock(bcx.llbb);\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               _ => ()\n@@ -1860,11 +1915,15 @@ fn trans_match_inner(scope_cx: @mut Block,\n         if ty::type_is_empty(tcx, t) {\n             // Special case for empty types\n             let fail_cx = @mut None;\n-            let f: mk_fail = || mk_fail(scope_cx, discr_expr.span,\n-                            @\"scrutinizing value that can't exist\", fail_cx);\n-            Some(f)\n+            let fail_handler = @DynamicFailureHandler {\n+                bcx: scope_cx,\n+                sp: discr_expr.span,\n+                msg: @\"scrutinizing value that can't exist\",\n+                finished: fail_cx,\n+            } as @CustomFailureHandler;\n+            CustomFailureHandlerClass(fail_handler)\n         } else {\n-            None\n+            Infallible\n         }\n     };\n     let lldiscr = discr_datum.to_zeroable_ref_llval(bcx);\n@@ -1892,15 +1951,6 @@ fn trans_match_inner(scope_cx: @mut Block,\n \n     bcx = controlflow::join_blocks(scope_cx, arm_cxs);\n     return bcx;\n-\n-    fn mk_fail(bcx: @mut Block, sp: Span, msg: @str,\n-               finished: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n-        match *finished { Some(bb) => return bb, _ => () }\n-        let fail_cx = sub_block(bcx, \"case_fallthrough\");\n-        controlflow::trans_fail(fail_cx, Some(sp), msg);\n-        *finished = Some(fail_cx.llbb);\n-        return fail_cx.llbb;\n-    }\n }\n \n enum IrrefutablePatternBindingMode {\n@@ -1913,7 +1963,7 @@ enum IrrefutablePatternBindingMode {\n pub fn store_local(bcx: @mut Block,\n                    pat: @ast::Pat,\n                    opt_init_expr: Option<@ast::Expr>)\n-                               -> @mut Block {\n+                   -> @mut Block {\n     /*!\n      * Generates code for a local variable declaration like\n      * `let <pat>;` or `let <pat> = <opt_init_expr>`."}]}