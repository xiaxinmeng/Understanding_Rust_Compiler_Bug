{"sha": "5dd8f8e26f2a62f5e7e4da50dcdfde344f6d31b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZDhmOGUyNmYyYTYyZjVlN2U0ZGE1MGRjZGZkZTM0NGY2ZDMxYjk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-27T21:58:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-27T21:58:35Z"}, "message": "Merge #2810\n\n2810: Improves reference search by StructLiteral r=mikhail-m1 a=mikhail-m1\n\nHey, I've made some changes to improve search for struct literals, now it works for `struct Foo<|> {`, `struct Foo <|>{`, `struct Foo<|>(`. Unfortunately tuple creation is represented as a call expression, so for tuples it works only is search is started in a tuple declaration.  It leads to incorrect classification of function calls during search phase, but from user perspective it's not visible and works as expected. May be it worth to add a comment or rename it to remove this misleading classification. Issue #2549.\n\nCo-authored-by: Mikhail Modin <mikhailm1@gmail.com>", "tree": {"sha": "48fcdfed65f6d24ee3616710d7eec181b5780b63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48fcdfed65f6d24ee3616710d7eec181b5780b63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dd8f8e26f2a62f5e7e4da50dcdfde344f6d31b9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeL10LCRBK7hj4Ov3rIwAAdHIIAGDS5M2lRJT8FlAlCuW19Q3w\nmQS2KYsUkixNtFIYPO8ed9pPAH6p4Cq5IIpudkM0B9Xc3lkH7VD4a3wyruanCg1q\nyyNCk0jz7lYbmOeC2oWdr9RBv2InXV6FVVCXNu1cHiy05awtJSfv5AhVb3DVHYo4\nRVd2k5NGr24gMJQoT/dioRo2wuuh5wT9C8wBP/uPrNKQgzq8TVShLUAY6JVFXJ8T\n9j55y1Wzl9OaoOedrq5U+F1gAeQRuY66Kx8igOUIg32AmWT9OgQWZWH/GGgwiI3W\nSRDv7VSnlS5WQClvuufAvnmtNmWvlrxR91cLXCbnfjvTm/zE3kbN0ANp0+2JKD0=\n=6ESG\n-----END PGP SIGNATURE-----\n", "payload": "tree 48fcdfed65f6d24ee3616710d7eec181b5780b63\nparent 5cfaf87627fcd9d22b74da7efd485223da225893\nparent fbc3ffcee6eec3d89e27417b3d3543327d810299\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1580162315 +0000\ncommitter GitHub <noreply@github.com> 1580162315 +0000\n\nMerge #2810\n\n2810: Improves reference search by StructLiteral r=mikhail-m1 a=mikhail-m1\n\nHey, I've made some changes to improve search for struct literals, now it works for `struct Foo<|> {`, `struct Foo <|>{`, `struct Foo<|>(`. Unfortunately tuple creation is represented as a call expression, so for tuples it works only is search is started in a tuple declaration.  It leads to incorrect classification of function calls during search phase, but from user perspective it's not visible and works as expected. May be it worth to add a comment or rename it to remove this misleading classification. Issue #2549.\n\nCo-authored-by: Mikhail Modin <mikhailm1@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd8f8e26f2a62f5e7e4da50dcdfde344f6d31b9", "html_url": "https://github.com/rust-lang/rust/commit/5dd8f8e26f2a62f5e7e4da50dcdfde344f6d31b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dd8f8e26f2a62f5e7e4da50dcdfde344f6d31b9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cfaf87627fcd9d22b74da7efd485223da225893", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cfaf87627fcd9d22b74da7efd485223da225893", "html_url": "https://github.com/rust-lang/rust/commit/5cfaf87627fcd9d22b74da7efd485223da225893"}, {"sha": "fbc3ffcee6eec3d89e27417b3d3543327d810299", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc3ffcee6eec3d89e27417b3d3543327d810299", "html_url": "https://github.com/rust-lang/rust/commit/fbc3ffcee6eec3d89e27417b3d3543327d810299"}], "stats": {"total": 138, "additions": 111, "deletions": 27}, "files": [{"sha": "ebded715d616c69f4d639c0ab15d0edadd7e1f7e", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 111, "deletions": 27, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/5dd8f8e26f2a62f5e7e4da50dcdfde344f6d31b9/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd8f8e26f2a62f5e7e4da50dcdfde344f6d31b9/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=5dd8f8e26f2a62f5e7e4da50dcdfde344f6d31b9", "patch": "@@ -112,25 +112,20 @@ impl IntoIterator for ReferenceSearchResult {\n \n pub(crate) fn find_all_refs(\n     db: &RootDatabase,\n-    mut position: FilePosition,\n+    position: FilePosition,\n     search_scope: Option<SearchScope>,\n ) -> Option<RangeInfo<ReferenceSearchResult>> {\n     let parse = db.parse(position.file_id);\n     let syntax = parse.tree().syntax().clone();\n \n-    let token = syntax.token_at_offset(position.offset);\n-    let mut search_kind = ReferenceKind::Other;\n+    let (opt_name, search_kind) =\n+        if let Some(name) = get_struct_def_name_for_struc_litetal_search(&syntax, position) {\n+            (Some(name), ReferenceKind::StructLiteral)\n+        } else {\n+            (find_node_at_offset::<ast::Name>(&syntax, position.offset), ReferenceKind::Other)\n+        };\n \n-    if let TokenAtOffset::Between(ref left, ref right) = token {\n-        if (right.kind() == SyntaxKind::L_CURLY || right.kind() == SyntaxKind::L_PAREN)\n-            && left.kind() != SyntaxKind::IDENT\n-        {\n-            position = FilePosition { offset: left.text_range().start(), ..position };\n-            search_kind = ReferenceKind::StructLiteral;\n-        }\n-    }\n-\n-    let RangeInfo { range, info: (name, def) } = find_name(db, &syntax, position)?;\n+    let RangeInfo { range, info: (name, def) } = find_name(db, &syntax, position, opt_name)?;\n \n     let declaration = match def.kind {\n         NameKind::Macro(mac) => mac.to_nav(db),\n@@ -170,9 +165,10 @@ fn find_name(\n     db: &RootDatabase,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n+    opt_name: Option<ast::Name>,\n ) -> Option<RangeInfo<(String, NameDefinition)>> {\n     let mut sb = SourceBinder::new(db);\n-    if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n+    if let Some(name) = opt_name {\n         let def = classify_name(&mut sb, InFile::new(position.file_id.into(), &name))?;\n         let range = name.syntax().text_range();\n         return Some(RangeInfo::new(range, (name.text().to_string(), def)));\n@@ -218,15 +214,8 @@ fn process_definition(\n                 if let Some(d) = classify_name_ref(&mut sb, InFile::new(file_id.into(), &name_ref))\n                 {\n                     if d == def {\n-                        let kind = if name_ref\n-                            .syntax()\n-                            .ancestors()\n-                            .find_map(ast::RecordLit::cast)\n-                            .and_then(|l| l.path())\n-                            .and_then(|p| p.segment())\n-                            .and_then(|p| p.name_ref())\n-                            .map(|n| n == name_ref)\n-                            .unwrap_or(false)\n+                        let kind = if is_record_lit_name_ref(&name_ref)\n+                            || is_call_expr_name_ref(&name_ref)\n                         {\n                             ReferenceKind::StructLiteral\n                         } else {\n@@ -301,6 +290,49 @@ fn reference_access(kind: &NameKind, name_ref: &ast::NameRef) -> Option<Referenc\n     mode.or(Some(ReferenceAccess::Read))\n }\n \n+fn is_record_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::RecordLit::cast)\n+        .and_then(|l| l.path())\n+        .and_then(|p| p.segment())\n+        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n+        .unwrap_or(false)\n+}\n+\n+fn get_struct_def_name_for_struc_litetal_search(\n+    syntax: &SyntaxNode,\n+    position: FilePosition,\n+) -> Option<ast::Name> {\n+    if let TokenAtOffset::Between(ref left, ref right) = syntax.token_at_offset(position.offset) {\n+        if right.kind() != SyntaxKind::L_CURLY && right.kind() != SyntaxKind::L_PAREN {\n+            return None;\n+        }\n+        if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, left.text_range().start()) {\n+            return name.syntax().ancestors().find_map(ast::StructDef::cast).and_then(|l| l.name());\n+        }\n+        if find_node_at_offset::<ast::TypeParamList>(&syntax, left.text_range().start()).is_some() {\n+            return left.ancestors().find_map(ast::StructDef::cast).and_then(|l| l.name());\n+        }\n+    }\n+    None\n+}\n+\n+fn is_call_expr_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::CallExpr::cast)\n+        .and_then(|c| match c.expr()? {\n+            ast::Expr::PathExpr(p) => {\n+                Some(p.path()?.segment()?.name_ref().as_ref() == Some(name_ref))\n+            }\n+            _ => None,\n+        })\n+        .unwrap_or(false)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::{\n@@ -309,7 +341,7 @@ mod tests {\n     };\n \n     #[test]\n-    fn test_struct_literal() {\n+    fn test_struct_literal_after_space() {\n         let code = r#\"\n     struct Foo <|>{\n         a: i32,\n@@ -330,6 +362,58 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_struct_literal_befor_space() {\n+        let code = r#\"\n+    struct Foo<|> {}\n+        fn main() {\n+        let f: Foo;\n+        f = Foo {};\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        check_result(\n+            refs,\n+            \"Foo STRUCT_DEF FileId(1) [5; 18) [12; 15) Other\",\n+            &[\"FileId(1) [54; 57) Other\", \"FileId(1) [71; 74) StructLiteral\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_literal_with_generic_type() {\n+        let code = r#\"\n+    struct Foo<T> <|>{}\n+        fn main() {\n+        let f: Foo::<i32>;\n+        f = Foo {};\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        check_result(\n+            refs,\n+            \"Foo STRUCT_DEF FileId(1) [5; 21) [12; 15) Other\",\n+            &[\"FileId(1) [81; 84) StructLiteral\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_literal_for_tuple() {\n+        let code = r#\"\n+    struct Foo<|>(i32);\n+\n+    fn main() {\n+        let f: Foo;\n+        f = Foo(1);\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        check_result(\n+            refs,\n+            \"Foo STRUCT_DEF FileId(1) [5; 21) [12; 15) Other\",\n+            &[\"FileId(1) [71; 74) StructLiteral\"],\n+        );\n+    }\n+\n     #[test]\n     fn test_find_all_refs_for_local() {\n         let code = r#\"\n@@ -564,15 +648,15 @@ mod tests {\n         check_result(\n             refs,\n             \"quux FN_DEF FileId(1) [18; 34) [25; 29) Other\",\n-            &[\"FileId(2) [16; 20) Other\", \"FileId(3) [16; 20) Other\"],\n+            &[\"FileId(2) [16; 20) StructLiteral\", \"FileId(3) [16; 20) StructLiteral\"],\n         );\n \n         let refs =\n             analysis.find_all_refs(pos, Some(SearchScope::single_file(bar))).unwrap().unwrap();\n         check_result(\n             refs,\n             \"quux FN_DEF FileId(1) [18; 34) [25; 29) Other\",\n-            &[\"FileId(3) [16; 20) Other\"],\n+            &[\"FileId(3) [16; 20) StructLiteral\"],\n         );\n     }\n \n@@ -591,7 +675,7 @@ mod tests {\n         check_result(\n             refs,\n             \"m1 MACRO_CALL FileId(1) [9; 63) [46; 48) Other\",\n-            &[\"FileId(1) [96; 98) Other\", \"FileId(1) [114; 116) Other\"],\n+            &[\"FileId(1) [96; 98) StructLiteral\", \"FileId(1) [114; 116) StructLiteral\"],\n         );\n     }\n "}]}