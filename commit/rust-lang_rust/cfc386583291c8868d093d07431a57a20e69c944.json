{"sha": "cfc386583291c8868d093d07431a57a20e69c944", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYzM4NjU4MzI5MWM4ODY4ZDA5M2QwNzQzMWE1N2EyMGU2OWM5NDQ=", "commit": {"author": {"name": "Brian Campbell", "email": "lambda@continuation.org", "date": "2016-02-06T22:16:56Z"}, "committer": {"name": "Brian Campbell", "email": "lambda@continuation.org", "date": "2016-05-23T04:22:41Z"}, "message": "Use libc::abort, not intrinsics::abort, in rtabort!\n\nintrinsics::abort compiles down to an illegal instruction, which on\nUnix-like platforms causes the process to be killed with SIGILL.  A more\nappropriate way to kill the process would be SIGABRT; this indicates\nbetter that the runtime has explicitly aborted, rather than some kind of\ncompiler bug or architecture mismatch that SIGILL might indicate.\n\nFor rtassert!, replace this with libc::abort.  libc::abort raises\nSIGABRT, but is defined to do so in such a way that it will terminate\nthe process even if SIGABRT is currently masked or caught by a signal\nhandler that returns.\n\nOn non-Unix platforms, retain the existing behavior.  On Windows we\nprefer to avoid depending on the C runtime, and we need a fallback for\nany other platforms that may be defined.  An alternative on Windows\nwould be to call TerminateProcess, but this seems less essential than\nswitching to using SIGABRT on Unix-like platforms, where it is common\nfor the process-killing signal to be printed out or logged.\n\nThis is a [breaking-change] for any code that depends on the exact\nsignal raised to abort a process via rtabort!\n\ncc #31273\ncc #31333", "tree": {"sha": "1a39f5eb5c9619a2d9f09e209c1d4966827db759", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a39f5eb5c9619a2d9f09e209c1d4966827db759"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfc386583291c8868d093d07431a57a20e69c944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfc386583291c8868d093d07431a57a20e69c944", "html_url": "https://github.com/rust-lang/rust/commit/cfc386583291c8868d093d07431a57a20e69c944", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfc386583291c8868d093d07431a57a20e69c944/comments", "author": {"login": "lambda", "id": 37398, "node_id": "MDQ6VXNlcjM3Mzk4", "avatar_url": "https://avatars.githubusercontent.com/u/37398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lambda", "html_url": "https://github.com/lambda", "followers_url": "https://api.github.com/users/lambda/followers", "following_url": "https://api.github.com/users/lambda/following{/other_user}", "gists_url": "https://api.github.com/users/lambda/gists{/gist_id}", "starred_url": "https://api.github.com/users/lambda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lambda/subscriptions", "organizations_url": "https://api.github.com/users/lambda/orgs", "repos_url": "https://api.github.com/users/lambda/repos", "events_url": "https://api.github.com/users/lambda/events{/privacy}", "received_events_url": "https://api.github.com/users/lambda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lambda", "id": 37398, "node_id": "MDQ6VXNlcjM3Mzk4", "avatar_url": "https://avatars.githubusercontent.com/u/37398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lambda", "html_url": "https://github.com/lambda", "followers_url": "https://api.github.com/users/lambda/followers", "following_url": "https://api.github.com/users/lambda/following{/other_user}", "gists_url": "https://api.github.com/users/lambda/gists{/gist_id}", "starred_url": "https://api.github.com/users/lambda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lambda/subscriptions", "organizations_url": "https://api.github.com/users/lambda/orgs", "repos_url": "https://api.github.com/users/lambda/repos", "events_url": "https://api.github.com/users/lambda/events{/privacy}", "received_events_url": "https://api.github.com/users/lambda/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "html_url": "https://github.com/rust-lang/rust/commit/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5"}], "stats": {"total": 29, "additions": 25, "deletions": 4}, "files": [{"sha": "1df511a8818c414849262f14df1926e7e1818741", "filename": "src/libstd/sys/common/util.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cfc386583291c8868d093d07431a57a20e69c944/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc386583291c8868d093d07431a57a20e69c944/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs?ref=cfc386583291c8868d093d07431a57a20e69c944", "patch": "@@ -10,7 +10,6 @@\n \n use env;\n use fmt;\n-use intrinsics;\n use io::prelude::*;\n use sync::atomic::{self, Ordering};\n use sys::stdio::Stderr;\n@@ -34,9 +33,32 @@ pub fn dumb_print(args: fmt::Arguments) {\n     let _ = Stderr::new().map(|mut stderr| stderr.write_fmt(args));\n }\n \n+// On Unix-like platforms, libc::abort will unregister signal handlers\n+// including the SIGABRT handler, preventing the abort from being blocked, and\n+// fclose streams, with the side effect of flushing them so libc bufferred\n+// output will be printed.  Additionally the shell will generally print a more\n+// understandable error message like \"Abort trap\" rather than \"Illegal\n+// instruction\" that intrinsics::abort would cause, as intrinsics::abort is\n+// implemented as an illegal instruction.\n+#[cfg(unix)]\n+unsafe fn abort_internal() -> ! {\n+    use libc;\n+    libc::abort()\n+}\n+\n+// On Windows, we want to avoid using libc, and there isn't a direct\n+// equivalent of libc::abort.  The __failfast intrinsic may be a reasonable\n+// substitute, but desireability of using it over the abort instrinsic is\n+// debateable; see https://github.com/rust-lang/rust/pull/31519 for details.\n+#[cfg(not(unix))]\n+unsafe fn abort_internal() -> ! {\n+    use intrinsics;\n+    intrinsics::abort()\n+}\n+\n pub fn abort(args: fmt::Arguments) -> ! {\n     dumb_print(format_args!(\"fatal runtime error: {}\\n\", args));\n-    unsafe { intrinsics::abort(); }\n+    unsafe { abort_internal(); }\n }\n \n #[allow(dead_code)] // stack overflow detection not enabled on all platforms"}, {"sha": "58119f965cf82b83e54649938494a6857def747a", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cfc386583291c8868d093d07431a57a20e69c944/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc386583291c8868d093d07431a57a20e69c944/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=cfc386583291c8868d093d07431a57a20e69c944", "patch": "@@ -46,8 +46,7 @@ fn check_status(status: std::process::ExitStatus)\n     use std::os::unix::process::ExitStatusExt;\n \n     assert!(!status.success());\n-    assert!(status.signal() != Some(libc::SIGSEGV)\n-            && status.signal() != Some(libc::SIGBUS));\n+    assert_eq!(status.signal(), Some(libc::SIGABRT));\n }\n \n #[cfg(not(unix))]"}]}