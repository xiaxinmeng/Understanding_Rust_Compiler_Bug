{"sha": "5aae6546c0839189bd03d49ef3d92833a9f1b060", "node_id": "C_kwDOAAsO6NoAKDVhYWU2NTQ2YzA4MzkxODliZDAzZDQ5ZWYzZDkyODMzYTlmMWIwNjA", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-02-12T23:43:32Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-02-12T23:44:09Z"}, "message": "Cleanup header parsing by extracting common logic", "tree": {"sha": "a3338d5383bdc01be31150879de11496bb1f8f97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3338d5383bdc01be31150879de11496bb1f8f97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5aae6546c0839189bd03d49ef3d92833a9f1b060", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5aae6546c0839189bd03d49ef3d92833a9f1b060", "html_url": "https://github.com/rust-lang/rust/commit/5aae6546c0839189bd03d49ef3d92833a9f1b060", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5aae6546c0839189bd03d49ef3d92833a9f1b060/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e660d52e3ddcea7c45070526064a45f5a1964366", "url": "https://api.github.com/repos/rust-lang/rust/commits/e660d52e3ddcea7c45070526064a45f5a1964366", "html_url": "https://github.com/rust-lang/rust/commit/e660d52e3ddcea7c45070526064a45f5a1964366"}], "stats": {"total": 397, "additions": 168, "deletions": 229}, "files": [{"sha": "5b8ee9fbdc97ec7b119c3d0f43d63c4ce4ca7766", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 168, "deletions": 229, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/5aae6546c0839189bd03d49ef3d92833a9f1b060/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5aae6546c0839189bd03d49ef3d92833a9f1b060/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=5aae6546c0839189bd03d49ef3d92833a9f1b060", "patch": "@@ -41,12 +41,15 @@ impl EarlyProps {\n     pub fn from_reader<R: Read>(config: &Config, testfile: &Path, rdr: R) -> Self {\n         let mut props = EarlyProps::default();\n         iter_header(testfile, rdr, &mut |_, ln| {\n-            if let Some(s) = config.parse_aux_build(ln) {\n-                props.aux.push(s);\n-            }\n-            if let Some(ac) = config.parse_aux_crate(ln) {\n-                props.aux_crate.push(ac);\n-            }\n+            config.push_name_value_directive(ln, directives::AUX_BUILD, &mut props.aux, |r| {\n+                r.trim().to_string()\n+            });\n+            config.push_name_value_directive(\n+                ln,\n+                directives::AUX_CRATE,\n+                &mut props.aux_crate,\n+                Config::parse_aux_crate,\n+            );\n             config.parse_and_update_revisions(ln, &mut props.revisions);\n         });\n         return props;\n@@ -156,6 +159,38 @@ pub struct TestProps {\n     pub stderr_per_bitwidth: bool,\n }\n \n+mod directives {\n+    pub const ERROR_PATTERN: &'static str = \"error-pattern\";\n+    pub const COMPILE_FLAGS: &'static str = \"compile-flags\";\n+    pub const RUN_FLAGS: &'static str = \"run-flags\";\n+    pub const SHOULD_ICE: &'static str = \"should-ice\";\n+    pub const BUILD_AUX_DOCS: &'static str = \"build-aux-docs\";\n+    pub const FORCE_HOST: &'static str = \"force-host\";\n+    pub const CHECK_STDOUT: &'static str = \"check-stdout\";\n+    pub const CHECK_RUN_RESULTS: &'static str = \"check-run-results\";\n+    pub const DONT_CHECK_COMPILER_STDOUT: &'static str = \"dont-check-compiler-stdout\";\n+    pub const DONT_CHECK_COMPILER_STDERR: &'static str = \"dont-check-compiler-stderr\";\n+    pub const NO_PREFER_DYNAMIC: &'static str = \"no-prefer-dynamic\";\n+    pub const PRETTY_EXPANDED: &'static str = \"pretty-expanded\";\n+    pub const PRETTY_MODE: &'static str = \"pretty-mode\";\n+    pub const PRETTY_COMPARE_ONLY: &'static str = \"pretty-compare-only\";\n+    pub const AUX_BUILD: &'static str = \"aux-build\";\n+    pub const AUX_CRATE: &'static str = \"aux-crate\";\n+    pub const EXEC_ENV: &'static str = \"exec-env\";\n+    pub const RUSTC_ENV: &'static str = \"rustc-env\";\n+    pub const UNSET_RUSTC_ENV: &'static str = \"unset-rustc-env\";\n+    pub const FORBID_OUTPUT: &'static str = \"forbid-output\";\n+    pub const CHECK_TEST_LINE_NUMBERS_MATCH: &'static str = \"check-test-line-numbers-match\";\n+    pub const IGNORE_PASS: &'static str = \"ignore-pass\";\n+    pub const FAILURE_STATUS: &'static str = \"failure-status\";\n+    pub const RUN_RUSTFIX: &'static str = \"run-rustfix\";\n+    pub const RUSTFIX_ONLY_MACHINE_APPLICABLE: &'static str = \"rustfix-only-machine-applicable\";\n+    pub const ASSEMBLY_OUTPUT: &'static str = \"assembly-output\";\n+    pub const STDERR_PER_BITWIDTH: &'static str = \"stderr-per-bitwidth\";\n+    pub const INCREMENTAL: &'static str = \"incremental\";\n+    pub const KNOWN_BUG: &'static str = \"known-bug\";\n+}\n+\n impl TestProps {\n     pub fn new() -> Self {\n         TestProps {\n@@ -235,11 +270,16 @@ impl TestProps {\n                     return;\n                 }\n \n-                if let Some(ep) = config.parse_error_pattern(ln) {\n-                    self.error_patterns.push(ep);\n-                }\n+                use directives::*;\n+\n+                config.push_name_value_directive(\n+                    ln,\n+                    ERROR_PATTERN,\n+                    &mut self.error_patterns,\n+                    |r| r,\n+                );\n \n-                if let Some(flags) = config.parse_compile_flags(ln) {\n+                if let Some(flags) = config.parse_name_value_directive(ln, COMPILE_FLAGS) {\n                     self.compile_flags.extend(flags.split_whitespace().map(|s| s.to_owned()));\n                 }\n \n@@ -250,93 +290,73 @@ impl TestProps {\n \n                 config.parse_and_update_revisions(ln, &mut self.revisions);\n \n-                if self.run_flags.is_none() {\n-                    self.run_flags = config.parse_run_flags(ln);\n-                }\n+                config.set_name_value_directive(ln, RUN_FLAGS, &mut self.run_flags, |r| r);\n \n                 if self.pp_exact.is_none() {\n                     self.pp_exact = config.parse_pp_exact(ln, testfile);\n                 }\n \n-                if !self.should_ice {\n-                    self.should_ice = config.parse_should_ice(ln);\n-                }\n-\n-                if !self.build_aux_docs {\n-                    self.build_aux_docs = config.parse_build_aux_docs(ln);\n-                }\n-\n-                if !self.force_host {\n-                    self.force_host = config.parse_force_host(ln);\n-                }\n-\n-                if !self.check_stdout {\n-                    self.check_stdout = config.parse_check_stdout(ln);\n-                }\n-\n-                if !self.check_run_results {\n-                    self.check_run_results = config.parse_check_run_results(ln);\n-                }\n-\n-                if !self.dont_check_compiler_stdout {\n-                    self.dont_check_compiler_stdout = config.parse_dont_check_compiler_stdout(ln);\n-                }\n-\n-                if !self.dont_check_compiler_stderr {\n-                    self.dont_check_compiler_stderr = config.parse_dont_check_compiler_stderr(ln);\n-                }\n-\n-                if !self.no_prefer_dynamic {\n-                    self.no_prefer_dynamic = config.parse_no_prefer_dynamic(ln);\n-                }\n-\n-                if !self.pretty_expanded {\n-                    self.pretty_expanded = config.parse_pretty_expanded(ln);\n-                }\n-\n-                if let Some(m) = config.parse_pretty_mode(ln) {\n+                config.set_name_directive(ln, SHOULD_ICE, &mut self.should_ice);\n+                config.set_name_directive(ln, BUILD_AUX_DOCS, &mut self.build_aux_docs);\n+                config.set_name_directive(ln, FORCE_HOST, &mut self.force_host);\n+                config.set_name_directive(ln, CHECK_STDOUT, &mut self.check_stdout);\n+                config.set_name_directive(ln, CHECK_RUN_RESULTS, &mut self.check_run_results);\n+                config.set_name_directive(\n+                    ln,\n+                    DONT_CHECK_COMPILER_STDOUT,\n+                    &mut self.dont_check_compiler_stdout,\n+                );\n+                config.set_name_directive(\n+                    ln,\n+                    DONT_CHECK_COMPILER_STDERR,\n+                    &mut self.dont_check_compiler_stderr,\n+                );\n+                config.set_name_directive(ln, NO_PREFER_DYNAMIC, &mut self.no_prefer_dynamic);\n+                config.set_name_directive(ln, PRETTY_EXPANDED, &mut self.pretty_expanded);\n+\n+                if let Some(m) = config.parse_name_value_directive(ln, PRETTY_MODE) {\n                     self.pretty_mode = m;\n                 }\n \n-                if !self.pretty_compare_only {\n-                    self.pretty_compare_only = config.parse_pretty_compare_only(ln);\n-                }\n-\n-                if let Some(ab) = config.parse_aux_build(ln) {\n-                    self.aux_builds.push(ab);\n-                }\n-\n-                if let Some(ac) = config.parse_aux_crate(ln) {\n-                    self.aux_crates.push(ac);\n-                }\n-\n-                if let Some(ee) = config.parse_env(ln, \"exec-env\") {\n-                    self.exec_env.push(ee);\n-                }\n-\n-                if let Some(ee) = config.parse_env(ln, \"rustc-env\") {\n-                    self.rustc_env.push(ee);\n-                }\n-\n-                if let Some(ev) = config.parse_name_value_directive(ln, \"unset-rustc-env\") {\n-                    self.unset_rustc_env.push(ev);\n-                }\n-\n-                if let Some(of) = config.parse_forbid_output(ln) {\n-                    self.forbid_output.push(of);\n-                }\n-\n-                if !self.check_test_line_numbers_match {\n-                    self.check_test_line_numbers_match =\n-                        config.parse_check_test_line_numbers_match(ln);\n-                }\n+                config.set_name_directive(ln, PRETTY_COMPARE_ONLY, &mut self.pretty_compare_only);\n+                config.push_name_value_directive(ln, AUX_BUILD, &mut self.aux_builds, |r| {\n+                    r.trim().to_string()\n+                });\n+                config.push_name_value_directive(\n+                    ln,\n+                    AUX_CRATE,\n+                    &mut self.aux_crates,\n+                    Config::parse_aux_crate,\n+                );\n+                config.push_name_value_directive(\n+                    ln,\n+                    EXEC_ENV,\n+                    &mut self.exec_env,\n+                    Config::parse_env,\n+                );\n+                config.push_name_value_directive(\n+                    ln,\n+                    RUSTC_ENV,\n+                    &mut self.rustc_env,\n+                    Config::parse_env,\n+                );\n+                config.push_name_value_directive(\n+                    ln,\n+                    UNSET_RUSTC_ENV,\n+                    &mut self.unset_rustc_env,\n+                    |r| r,\n+                );\n+                config.push_name_value_directive(ln, FORBID_OUTPUT, &mut self.forbid_output, |r| r);\n+                config.set_name_directive(\n+                    ln,\n+                    CHECK_TEST_LINE_NUMBERS_MATCH,\n+                    &mut self.check_test_line_numbers_match,\n+                );\n \n                 self.update_pass_mode(ln, cfg, config);\n                 self.update_fail_mode(ln, config);\n \n-                if !self.ignore_pass {\n-                    self.ignore_pass = config.parse_ignore_pass(ln);\n-                }\n+                config.set_name_directive(ln, IGNORE_PASS, &mut self.ignore_pass);\n \n                 if let Some(rule) = config.parse_custom_normalization(ln, \"normalize-stdout\") {\n                     self.normalize_stdout.push(rule);\n@@ -345,34 +365,28 @@ impl TestProps {\n                     self.normalize_stderr.push(rule);\n                 }\n \n-                if let Some(code) = config.parse_failure_status(ln) {\n+                if let Some(code) = config\n+                    .parse_name_value_directive(ln, FAILURE_STATUS)\n+                    .and_then(|code| code.trim().parse::<i32>().ok())\n+                {\n                     self.failure_status = code;\n                 }\n \n-                if !self.run_rustfix {\n-                    self.run_rustfix = config.parse_run_rustfix(ln);\n-                }\n-\n-                if !self.rustfix_only_machine_applicable {\n-                    self.rustfix_only_machine_applicable =\n-                        config.parse_rustfix_only_machine_applicable(ln);\n-                }\n-\n-                if self.assembly_output.is_none() {\n-                    self.assembly_output = config.parse_assembly_output(ln);\n-                }\n-\n-                if !self.stderr_per_bitwidth {\n-                    self.stderr_per_bitwidth = config.parse_stderr_per_bitwidth(ln);\n-                }\n-\n-                if !self.incremental {\n-                    self.incremental = config.parse_incremental(ln);\n-                }\n-\n-                if !self.known_bug {\n-                    self.known_bug = config.parse_known_bug(ln);\n-                }\n+                config.set_name_directive(ln, RUN_RUSTFIX, &mut self.run_rustfix);\n+                config.set_name_directive(\n+                    ln,\n+                    RUSTFIX_ONLY_MACHINE_APPLICABLE,\n+                    &mut self.rustfix_only_machine_applicable,\n+                );\n+                config.set_name_value_directive(\n+                    ln,\n+                    ASSEMBLY_OUTPUT,\n+                    &mut self.assembly_output,\n+                    |r| r.trim().to_string(),\n+                );\n+                config.set_name_directive(ln, STDERR_PER_BITWIDTH, &mut self.stderr_per_bitwidth);\n+                config.set_name_directive(ln, INCREMENTAL, &mut self.incremental);\n+                config.set_name_directive(ln, KNOWN_BUG, &mut self.known_bug);\n             });\n         }\n \n@@ -514,33 +528,12 @@ fn iter_header<R: Read>(testfile: &Path, rdr: R, it: &mut dyn FnMut(Option<&str>\n }\n \n impl Config {\n-    fn parse_should_ice(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"should-ice\")\n-    }\n-    fn parse_error_pattern(&self, line: &str) -> Option<String> {\n-        self.parse_name_value_directive(line, \"error-pattern\")\n-    }\n-\n-    fn parse_forbid_output(&self, line: &str) -> Option<String> {\n-        self.parse_name_value_directive(line, \"forbid-output\")\n-    }\n-\n-    fn parse_aux_build(&self, line: &str) -> Option<String> {\n-        self.parse_name_value_directive(line, \"aux-build\").map(|r| r.trim().to_string())\n-    }\n-\n-    fn parse_aux_crate(&self, line: &str) -> Option<(String, String)> {\n-        self.parse_name_value_directive(line, \"aux-crate\").map(|r| {\n-            let mut parts = r.trim().splitn(2, '=');\n-            (\n-                parts.next().expect(\"missing aux-crate name (e.g. log=log.rs)\").to_string(),\n-                parts.next().expect(\"missing aux-crate value (e.g. log=log.rs)\").to_string(),\n-            )\n-        })\n-    }\n-\n-    fn parse_compile_flags(&self, line: &str) -> Option<String> {\n-        self.parse_name_value_directive(line, \"compile-flags\")\n+    fn parse_aux_crate(r: String) -> (String, String) {\n+        let mut parts = r.trim().splitn(2, '=');\n+        (\n+            parts.next().expect(\"missing aux-crate name (e.g. log=log.rs)\").to_string(),\n+            parts.next().expect(\"missing aux-crate value (e.g. log=log.rs)\").to_string(),\n+        )\n     }\n \n     fn parse_and_update_revisions(&self, line: &str, existing: &mut Vec<String>) {\n@@ -555,87 +548,18 @@ impl Config {\n         }\n     }\n \n-    fn parse_run_flags(&self, line: &str) -> Option<String> {\n-        self.parse_name_value_directive(line, \"run-flags\")\n-    }\n-\n-    fn parse_force_host(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"force-host\")\n-    }\n-\n-    fn parse_build_aux_docs(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"build-aux-docs\")\n-    }\n+    fn parse_env(nv: String) -> (String, String) {\n+        // nv is either FOO or FOO=BAR\n+        let mut strs: Vec<String> = nv.splitn(2, '=').map(str::to_owned).collect();\n \n-    fn parse_check_stdout(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"check-stdout\")\n-    }\n-\n-    fn parse_check_run_results(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"check-run-results\")\n-    }\n-\n-    fn parse_dont_check_compiler_stdout(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"dont-check-compiler-stdout\")\n-    }\n-\n-    fn parse_dont_check_compiler_stderr(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"dont-check-compiler-stderr\")\n-    }\n-\n-    fn parse_no_prefer_dynamic(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"no-prefer-dynamic\")\n-    }\n-\n-    fn parse_pretty_expanded(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"pretty-expanded\")\n-    }\n-\n-    fn parse_pretty_mode(&self, line: &str) -> Option<String> {\n-        self.parse_name_value_directive(line, \"pretty-mode\")\n-    }\n-\n-    fn parse_pretty_compare_only(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"pretty-compare-only\")\n-    }\n-\n-    fn parse_failure_status(&self, line: &str) -> Option<i32> {\n-        match self.parse_name_value_directive(line, \"failure-status\") {\n-            Some(code) => code.trim().parse::<i32>().ok(),\n-            _ => None,\n-        }\n-    }\n-\n-    fn parse_check_test_line_numbers_match(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"check-test-line-numbers-match\")\n-    }\n-\n-    fn parse_ignore_pass(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"ignore-pass\")\n-    }\n-\n-    fn parse_stderr_per_bitwidth(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"stderr-per-bitwidth\")\n-    }\n-\n-    fn parse_assembly_output(&self, line: &str) -> Option<String> {\n-        self.parse_name_value_directive(line, \"assembly-output\").map(|r| r.trim().to_string())\n-    }\n-\n-    fn parse_env(&self, line: &str, name: &str) -> Option<(String, String)> {\n-        self.parse_name_value_directive(line, name).map(|nv| {\n-            // nv is either FOO or FOO=BAR\n-            let mut strs: Vec<String> = nv.splitn(2, '=').map(str::to_owned).collect();\n-\n-            match strs.len() {\n-                1 => (strs.pop().unwrap(), String::new()),\n-                2 => {\n-                    let end = strs.pop().unwrap();\n-                    (strs.pop().unwrap(), end)\n-                }\n-                n => panic!(\"Expected 1 or 2 strings, not {}\", n),\n+        match strs.len() {\n+            1 => (strs.pop().unwrap(), String::new()),\n+            2 => {\n+                let end = strs.pop().unwrap();\n+                (strs.pop().unwrap(), end)\n             }\n-        })\n+            n => panic!(\"Expected 1 or 2 strings, not {}\", n),\n+        }\n     }\n \n     fn parse_pp_exact(&self, line: &str, testfile: &Path) -> Option<PathBuf> {\n@@ -747,24 +671,38 @@ impl Config {\n         None\n     }\n \n-    fn parse_run_rustfix(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"run-rustfix\")\n-    }\n-\n-    fn parse_rustfix_only_machine_applicable(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"rustfix-only-machine-applicable\")\n-    }\n-\n     fn parse_edition(&self, line: &str) -> Option<String> {\n         self.parse_name_value_directive(line, \"edition\")\n     }\n \n-    fn parse_incremental(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"incremental\")\n+    fn set_name_directive(&self, line: &str, directive: &str, value: &mut bool) {\n+        if !*value {\n+            *value = self.parse_name_directive(line, directive)\n+        }\n+    }\n+\n+    fn set_name_value_directive<T>(\n+        &self,\n+        line: &str,\n+        directive: &str,\n+        value: &mut Option<T>,\n+        parse: impl FnOnce(String) -> T,\n+    ) {\n+        if value.is_none() {\n+            *value = self.parse_name_value_directive(line, directive).map(parse);\n+        }\n     }\n \n-    fn parse_known_bug(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"known-bug\")\n+    fn push_name_value_directive<T>(\n+        &self,\n+        line: &str,\n+        directive: &str,\n+        values: &mut Vec<T>,\n+        parse: impl FnOnce(String) -> T,\n+    ) {\n+        if let Some(value) = self.parse_name_value_directive(line, directive).map(parse) {\n+            values.push(value);\n+        }\n     }\n }\n \n@@ -916,7 +854,8 @@ pub fn make_test_description<R: Read>(\n         ignore |= !has_hwasan && config.parse_name_directive(ln, \"needs-sanitizer-hwaddress\");\n         ignore |= config.target_panic == PanicStrategy::Abort\n             && config.parse_name_directive(ln, \"needs-unwind\");\n-        ignore |= config.target == \"wasm32-unknown-unknown\" && config.parse_check_run_results(ln);\n+        ignore |= config.target == \"wasm32-unknown-unknown\"\n+            && config.parse_name_directive(ln, directives::CHECK_RUN_RESULTS);\n         ignore |= config.debugger == Some(Debugger::Cdb) && ignore_cdb(config, ln);\n         ignore |= config.debugger == Some(Debugger::Gdb) && ignore_gdb(config, ln);\n         ignore |= config.debugger == Some(Debugger::Lldb) && ignore_lldb(config, ln);"}]}