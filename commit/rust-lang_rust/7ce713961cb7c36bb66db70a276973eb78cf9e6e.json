{"sha": "7ce713961cb7c36bb66db70a276973eb78cf9e6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZTcxMzk2MWNiN2MzNmJiNjZkYjcwYTI3Njk3M2ViNzhjZjllNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-11T00:59:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-11T00:59:48Z"}, "message": "Auto merge of #30301 - michaelwoerister:mir-to-metadata2, r=nikomatsakis\n\nThis PR makes `Mir` `RustcEncodable` and `RustcDecodable` and stores it in crate metadata for inlinable items.\n\nSome other things in here:\n- `mir::visit::Visitor` is extended to also visit `Literals`, `Spans` and `DefIds`.\n- It also adds `mir::visit::MutVisitor` which allows to mutate the visited `Mir` structure in place.\n- Some numbers on how big MIR is in metadata (total metadata size in bytes):\n\n|                | w/ MIR     | w/o MIR     | Rel. Size |\n|----------------|-----------:|------------:|:---------:|\n| libcore        | 17,695,473 |  14,263,377 |  124%     |\n| liblibc        | 411,440   |  404,382    | 102%      |\n| libcollections |  4,537,975 |   3,526,933 |   129%    |\n| libserialize   |  2,574,769 |   2,060,798 |   125%    |\n| libsyntax      | 15,262,894 |  12,075,574 |  126%     |\n| librustc       | 16,984,537 |  13,692,168 |  124%     |\n\nSo, adding MIR to metadata makes it about 25% bigger. It could be worse, considering that it still uses the inefficient RBML encoding. Still, the question is whether we should put MIR emission behind a `-Z` flag.", "tree": {"sha": "b7379aa50ccc114e34709bc1f6d041d4905f7be5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7379aa50ccc114e34709bc1f6d041d4905f7be5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ce713961cb7c36bb66db70a276973eb78cf9e6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ce713961cb7c36bb66db70a276973eb78cf9e6e", "html_url": "https://github.com/rust-lang/rust/commit/7ce713961cb7c36bb66db70a276973eb78cf9e6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ce713961cb7c36bb66db70a276973eb78cf9e6e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d3684063bab26117a8a5c26684470396446fe88", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d3684063bab26117a8a5c26684470396446fe88", "html_url": "https://github.com/rust-lang/rust/commit/0d3684063bab26117a8a5c26684470396446fe88"}, {"sha": "5addc31adb558da1613c8f9748ee05688f6eaf91", "url": "https://api.github.com/repos/rust-lang/rust/commits/5addc31adb558da1613c8f9748ee05688f6eaf91", "html_url": "https://github.com/rust-lang/rust/commit/5addc31adb558da1613c8f9748ee05688f6eaf91"}], "stats": {"total": 630, "additions": 567, "deletions": 63}, "files": [{"sha": "9f75f9ebb9adf51ec1adff29a0486a0b78a245f3", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -242,7 +242,7 @@ pub fn lookup_const_fn_by_id<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: DefId)\n     }\n }\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum ConstVal {\n     Float(f64),\n     Int(i64),"}, {"sha": "22a4ddd2f687b54db5ba18fcaef85f42e0429cd9", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -28,6 +28,7 @@ use middle::def;\n use middle::lang_items;\n use middle::ty::{self, Ty};\n use middle::def_id::{DefId, DefIndex};\n+use mir::repr::Mir;\n use session::Session;\n use session::search_paths::PathKind;\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n@@ -100,6 +101,7 @@ pub enum InlinedItem {\n }\n \n /// A borrowed version of `hir::InlinedItem`.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InlinedItemRef<'a> {\n     Item(&'a hir::Item),\n     TraitItem(DefId, &'a hir::TraitItem),\n@@ -216,6 +218,8 @@ pub trait CrateStore<'tcx> : Any {\n     // misc. metadata\n     fn maybe_get_item_ast(&'tcx self, tcx: &ty::ctxt<'tcx>, def: DefId)\n                           -> FoundAst<'tcx>;\n+    fn maybe_get_item_mir(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> Option<Mir<'tcx>>;\n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<ast::CrateNum>;\n@@ -235,6 +239,7 @@ pub trait CrateStore<'tcx> : Any {\n                        item_symbols: &RefCell<NodeMap<String>>,\n                        link_meta: &LinkMeta,\n                        reachable: &NodeSet,\n+                       mir_map: &NodeMap<Mir<'tcx>>,\n                        krate: &hir::Crate) -> Vec<u8>;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n@@ -383,6 +388,9 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // misc. metadata\n     fn maybe_get_item_ast(&'tcx self, tcx: &ty::ctxt<'tcx>, def: DefId)\n                           -> FoundAst<'tcx> { unimplemented!() }\n+    fn maybe_get_item_mir(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> Option<Mir<'tcx>> { unimplemented!() }\n+\n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<ast::CrateNum> { vec![] }\n@@ -404,6 +412,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                        item_symbols: &RefCell<NodeMap<String>>,\n                        link_meta: &LinkMeta,\n                        reachable: &NodeSet,\n+                       mir_map: &NodeMap<Mir<'tcx>>,\n                        krate: &hir::Crate) -> Vec<u8> { vec![] }\n     fn metadata_encoding_version(&self) -> &[u8] { unimplemented!() }\n }"}, {"sha": "66b2a9d3ad0bfeb8dfab458cb7dc137adf5668e3", "filename": "src/librustc/middle/ty/sty.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fsty.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -10,6 +10,7 @@\n \n //! This module contains TypeVariants and its major components\n \n+use middle::cstore;\n use middle::def_id::DefId;\n use middle::region;\n use middle::subst::{self, Substs};\n@@ -26,6 +27,8 @@ use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::parse::token::special_idents;\n \n+use serialize::{Decodable, Decoder};\n+\n use rustc_front::hir;\n \n use self::FnOutput::*;\n@@ -233,7 +236,7 @@ pub enum TypeVariants<'tcx> {\n /// closure C wind up influencing the decisions we ought to make for\n /// closure C (which would then require fixed point iteration to\n /// handle). Plus it fixes an ICE. :P\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function.\n     /// These are separated out because trans wants to pass them around\n@@ -246,6 +249,23 @@ pub struct ClosureSubsts<'tcx> {\n     pub upvar_tys: Vec<Ty<'tcx>>\n }\n \n+impl<'tcx> Decodable for &'tcx ClosureSubsts<'tcx> {\n+    fn decode<S: Decoder>(s: &mut S) -> Result<&'tcx ClosureSubsts<'tcx>, S::Error> {\n+        let closure_substs = try! { Decodable::decode(s) };\n+        let dummy_def_id: DefId = unsafe { mem::zeroed() };\n+\n+        cstore::tls::with_decoding_context(s, |dcx, _| {\n+            // Intern the value\n+            let ty = dcx.tcx().mk_closure_from_closure_substs(dummy_def_id,\n+                                                              Box::new(closure_substs));\n+            match ty.sty {\n+                TyClosure(_, ref closure_substs) => Ok(&**closure_substs),\n+                _ => unreachable!()\n+            }\n+        })\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct TraitTy<'tcx> {\n     pub principal: ty::PolyTraitRef<'tcx>,\n@@ -434,7 +454,7 @@ pub struct ClosureTy<'tcx> {\n     pub sig: PolyFnSig<'tcx>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum FnOutput<'tcx> {\n     FnConverging(Ty<'tcx>),\n     FnDiverging\n@@ -632,7 +652,7 @@ pub struct DebruijnIndex {\n ///\n /// [1] http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n /// [2] http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n-#[derive(Clone, PartialEq, Eq, Hash, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, Copy, RustcEncodable, RustcDecodable)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n@@ -701,7 +721,7 @@ pub struct RegionVid {\n     pub index: u32\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct SkolemizedRegionVid {\n     pub index: u32\n }"}, {"sha": "049063f73a5bf7c4ac86d2b27cb58eb920f21409", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -13,13 +13,15 @@ use middle::def_id::DefId;\n use middle::subst::Substs;\n use middle::ty::{AdtDef, ClosureSubsts, FnOutput, Region, Ty};\n use rustc_back::slice;\n+use rustc_data_structures::tuple_slice::TupleSlice;\n use rustc_front::hir::InlineAsm;\n use syntax::ast::Name;\n use syntax::codemap::Span;\n use std::fmt::{Debug, Formatter, Error};\n use std::u32;\n \n /// Lowered representation of a single function.\n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct Mir<'tcx> {\n     /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n@@ -70,13 +72,13 @@ impl<'tcx> Mir<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Mutability and borrow kinds\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum Mutability {\n     Mut,\n     Not,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     Shared,\n@@ -127,6 +129,7 @@ pub enum BorrowKind {\n \n // A \"variable\" is a binding declared by the user as part of the fn\n // decl, a let, etc.\n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct VarDecl<'tcx> {\n     pub mutability: Mutability,\n     pub name: Name,\n@@ -135,6 +138,7 @@ pub struct VarDecl<'tcx> {\n \n // A \"temp\" is a temporary that we place on the stack. They are\n // anonymous, always mutable, and have only a type.\n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct TempDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n@@ -150,6 +154,7 @@ pub struct TempDecl<'tcx> {\n //\n // there is only one argument, of type `(i32, u32)`, but two bindings\n // (`x` and `y`).\n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct ArgDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n@@ -161,7 +166,7 @@ pub struct ArgDecl<'tcx> {\n /// list of the `Mir`.\n ///\n /// (We use a `u32` internally just to save memory.)\n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub struct BasicBlock(u32);\n \n impl BasicBlock {\n@@ -185,12 +190,13 @@ impl Debug for BasicBlock {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlock and Terminator\n \n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct BasicBlockData<'tcx> {\n     pub statements: Vec<Statement<'tcx>>,\n     pub terminator: Terminator<'tcx>,\n }\n \n+#[derive(RustcEncodable, RustcDecodable)]\n pub enum Terminator<'tcx> {\n     /// block should have one successor in the graph; we jump there\n     Goto {\n@@ -206,7 +212,7 @@ pub enum Terminator<'tcx> {\n     /// jump to branch 0 if this lvalue evaluates to true\n     If {\n         cond: Operand<'tcx>,\n-        targets: [BasicBlock; 2],\n+        targets: (BasicBlock, BasicBlock),\n     },\n \n     /// lvalue evaluates to some enum; jump depending on the branch\n@@ -254,7 +260,7 @@ pub enum Terminator<'tcx> {\n     /// unwinding.\n     Call {\n         data: CallData<'tcx>,\n-        targets: [BasicBlock; 2],\n+        targets: (BasicBlock, BasicBlock),\n     },\n }\n \n@@ -264,12 +270,12 @@ impl<'tcx> Terminator<'tcx> {\n         match *self {\n             Goto { target: ref b } => slice::ref_slice(b),\n             Panic { target: ref b } => slice::ref_slice(b),\n-            If { cond: _, targets: ref b } => b,\n+            If { cond: _, targets: ref b } => b.as_slice(),\n             Switch { targets: ref b, .. } => b,\n             SwitchInt { targets: ref b, .. } => b,\n             Diverge => &[],\n             Return => &[],\n-            Call { data: _, targets: ref b } => b,\n+            Call { data: _, targets: ref b } => b.as_slice(),\n         }\n     }\n \n@@ -278,17 +284,17 @@ impl<'tcx> Terminator<'tcx> {\n         match *self {\n             Goto { target: ref mut b } => slice::mut_ref_slice(b),\n             Panic { target: ref mut b } => slice::mut_ref_slice(b),\n-            If { cond: _, targets: ref mut b } => b,\n+            If { cond: _, targets: ref mut b } => b.as_mut_slice(),\n             Switch { targets: ref mut b, .. } => b,\n             SwitchInt { targets: ref mut b, .. } => b,\n             Diverge => &mut [],\n             Return => &mut [],\n-            Call { data: _, targets: ref mut b } => b,\n+            Call { data: _, targets: ref mut b } => b.as_mut_slice(),\n         }\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct CallData<'tcx> {\n     /// where the return value is written to\n     pub destination: Lvalue<'tcx>,\n@@ -345,18 +351,19 @@ impl<'tcx> Debug for Terminator<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Statements\n \n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct Statement<'tcx> {\n     pub span: Span,\n     pub kind: StatementKind<'tcx>,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n pub enum StatementKind<'tcx> {\n     Assign(Lvalue<'tcx>, Rvalue<'tcx>),\n     Drop(DropKind, Lvalue<'tcx>),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum DropKind {\n     Free, // free a partially constructed box, should go away eventually\n     Deep\n@@ -377,7 +384,7 @@ impl<'tcx> Debug for Statement<'tcx> {\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Lvalue<'tcx> {\n     /// local variable declared by the user\n     Var(u32),\n@@ -403,13 +410,13 @@ pub enum Lvalue<'tcx> {\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Lvalue`. See the aliases\n /// `LvalueProjection` etc below.\n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct Projection<'tcx, B, V> {\n     pub base: B,\n     pub elem: ProjectionElem<'tcx, V>,\n }\n \n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum ProjectionElem<'tcx, V> {\n     Deref,\n     Field(Field),\n@@ -447,7 +454,7 @@ pub type LvalueElem<'tcx> =\n     ProjectionElem<'tcx,Operand<'tcx>>;\n \n /// Index into the list of fields found in a `VariantDef`\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct Field(u32);\n \n impl Field {\n@@ -523,7 +530,7 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n // lvalue). They are intentionally limited to prevent rvalues from\n // being nested in one another.\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Operand<'tcx> {\n     Consume(Lvalue<'tcx>),\n     Constant(Constant<'tcx>),\n@@ -542,7 +549,7 @@ impl<'tcx> Debug for Operand<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Rvalues\n \n-#[derive(Clone)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum Rvalue<'tcx> {\n     // x (either a move or copy, depending on type of x)\n     Use(Operand<'tcx>),\n@@ -583,10 +590,10 @@ pub enum Rvalue<'tcx> {\n         from_end: usize,\n     },\n \n-    InlineAsm(&'tcx InlineAsm),\n+    InlineAsm(InlineAsm),\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum CastKind {\n     Misc,\n \n@@ -604,15 +611,15 @@ pub enum CastKind {\n     Unsize,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum AggregateKind<'tcx> {\n     Vec,\n     Tuple,\n     Adt(AdtDef<'tcx>, usize, &'tcx Substs<'tcx>),\n     Closure(DefId, &'tcx ClosureSubsts<'tcx>),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum BinOp {\n     /// The `+` operator (addition)\n     Add,\n@@ -648,7 +655,7 @@ pub enum BinOp {\n     Gt,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum UnOp {\n     /// The `!` operator for logical inversion\n     Not,\n@@ -684,14 +691,14 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n // this does not necessarily mean that they are \"==\" in Rust -- in\n // particular one must be wary of `NaN`!\n \n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n     pub literal: Literal<'tcx>,\n }\n \n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Literal<'tcx> {\n     Item {\n         def_id: DefId,"}, {"sha": "00d21d3c16e1faeb84a6b60d65721fa4847f3d75", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 313, "deletions": 3, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -8,8 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::def_id::DefId;\n use middle::ty::Region;\n use mir::repr::*;\n+use rustc_data_structures::tuple_slice::TupleSlice;\n+use syntax::codemap::Span;\n \n pub trait Visitor<'tcx> {\n     // Override these, and call `self.super_xxx` to revert back to the\n@@ -55,6 +58,18 @@ pub trait Visitor<'tcx> {\n         self.super_constant(constant);\n     }\n \n+    fn visit_literal(&mut self, literal: &Literal<'tcx>) {\n+        self.super_literal(literal);\n+    }\n+\n+    fn visit_def_id(&mut self, def_id: DefId) {\n+        self.super_def_id(def_id);\n+    }\n+\n+    fn visit_span(&mut self, span: Span) {\n+        self.super_span(span);\n+    }\n+\n     // The `super_xxx` methods comprise the default behavior and are\n     // not meant to be overidden.\n \n@@ -73,6 +88,8 @@ pub trait Visitor<'tcx> {\n     }\n \n     fn super_statement(&mut self, block: BasicBlock, statement: &Statement<'tcx>) {\n+        self.visit_span(statement.span);\n+\n         match statement.kind {\n             StatementKind::Assign(ref lvalue, ref rvalue) => {\n                 self.visit_assign(block, lvalue, rvalue);\n@@ -97,7 +114,7 @@ pub trait Visitor<'tcx> {\n \n             Terminator::If { ref cond, ref targets } => {\n                 self.visit_operand(cond);\n-                for &target in &targets[..] {\n+                for &target in targets.as_slice() {\n                     self.visit_branch(block, target);\n                 }\n             }\n@@ -126,7 +143,7 @@ pub trait Visitor<'tcx> {\n                 for arg in &data.args {\n                     self.visit_operand(arg);\n                 }\n-                for &target in &targets[..] {\n+                for &target in targets.as_slice() {\n                     self.visit_branch(block, target);\n                 }\n             }\n@@ -217,7 +234,26 @@ pub trait Visitor<'tcx> {\n     fn super_branch(&mut self, _source: BasicBlock, _target: BasicBlock) {\n     }\n \n-    fn super_constant(&mut self, _constant: &Constant<'tcx>) {\n+    fn super_constant(&mut self, constant: &Constant<'tcx>) {\n+        self.visit_span(constant.span);\n+        self.visit_literal(&constant.literal);\n+    }\n+\n+    fn super_literal(&mut self, literal: &Literal<'tcx>) {\n+        match *literal {\n+            Literal::Item { def_id, .. } => {\n+                self.visit_def_id(def_id);\n+            },\n+            Literal::Value { .. } => {\n+                // Nothing to do\n+            }\n+        }\n+    }\n+\n+    fn super_def_id(&mut self, _def_id: DefId) {\n+    }\n+\n+    fn super_span(&mut self, _span: Span) {\n     }\n }\n \n@@ -244,3 +280,277 @@ pub enum LvalueContext {\n     // Consumed as part of an operand\n     Consume,\n }\n+\n+pub trait MutVisitor<'tcx> {\n+    // Override these, and call `self.super_xxx` to revert back to the\n+    // default behavior.\n+\n+    fn visit_mir(&mut self, mir: &mut Mir<'tcx>) {\n+        self.super_mir(mir);\n+    }\n+\n+    fn visit_basic_block_data(&mut self,\n+                              block: BasicBlock,\n+                              data: &mut BasicBlockData<'tcx>) {\n+        self.super_basic_block_data(block, data);\n+    }\n+\n+    fn visit_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &mut Statement<'tcx>) {\n+        self.super_statement(block, statement);\n+    }\n+\n+    fn visit_assign(&mut self,\n+                    block: BasicBlock,\n+                    lvalue: &mut Lvalue<'tcx>,\n+                    rvalue: &mut Rvalue<'tcx>) {\n+        self.super_assign(block, lvalue, rvalue);\n+    }\n+\n+    fn visit_terminator(&mut self,\n+                        block: BasicBlock,\n+                        terminator: &mut Terminator<'tcx>) {\n+        self.super_terminator(block, terminator);\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>) {\n+        self.super_rvalue(rvalue);\n+    }\n+\n+    fn visit_operand(&mut self, operand: &mut Operand<'tcx>) {\n+        self.super_operand(operand);\n+    }\n+\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &mut Lvalue<'tcx>,\n+                    context: LvalueContext) {\n+        self.super_lvalue(lvalue, context);\n+    }\n+\n+    fn visit_branch(&mut self, source: BasicBlock, target: BasicBlock) {\n+        self.super_branch(source, target);\n+    }\n+\n+    fn visit_constant(&mut self, constant: &mut Constant<'tcx>) {\n+        self.super_constant(constant);\n+    }\n+\n+    fn visit_literal(&mut self, literal: &mut Literal<'tcx>) {\n+        self.super_literal(literal);\n+    }\n+\n+    fn visit_def_id(&mut self, def_id: &mut DefId) {\n+        self.super_def_id(def_id);\n+    }\n+\n+    fn visit_span(&mut self, span: &mut Span) {\n+        self.super_span(span);\n+    }\n+\n+    // The `super_xxx` methods comprise the default behavior and are\n+    // not meant to be overidden.\n+\n+    fn super_mir(&mut self, mir: &mut Mir<'tcx>) {\n+        for block in mir.all_basic_blocks() {\n+            let data = mir.basic_block_data_mut(block);\n+            self.visit_basic_block_data(block, data);\n+        }\n+    }\n+\n+    fn super_basic_block_data(&mut self,\n+                              block: BasicBlock,\n+                              data: &mut BasicBlockData<'tcx>) {\n+        for statement in &mut data.statements {\n+            self.visit_statement(block, statement);\n+        }\n+        self.visit_terminator(block, &mut data.terminator);\n+    }\n+\n+    fn super_statement(&mut self,\n+                       block: BasicBlock,\n+                       statement: &mut Statement<'tcx>) {\n+        self.visit_span(&mut statement.span);\n+\n+        match statement.kind {\n+            StatementKind::Assign(ref mut lvalue, ref mut rvalue) => {\n+                self.visit_assign(block, lvalue, rvalue);\n+            }\n+            StatementKind::Drop(_, ref mut lvalue) => {\n+                self.visit_lvalue(lvalue, LvalueContext::Drop);\n+            }\n+        }\n+    }\n+\n+    fn super_assign(&mut self,\n+                    _block: BasicBlock,\n+                    lvalue: &mut Lvalue<'tcx>,\n+                    rvalue: &mut Rvalue<'tcx>) {\n+        self.visit_lvalue(lvalue, LvalueContext::Store);\n+        self.visit_rvalue(rvalue);\n+    }\n+\n+    fn super_terminator(&mut self,\n+                        block: BasicBlock,\n+                        terminator: &mut Terminator<'tcx>) {\n+        match *terminator {\n+            Terminator::Goto { target } |\n+            Terminator::Panic { target } => {\n+                self.visit_branch(block, target);\n+            }\n+\n+            Terminator::If { ref mut cond, ref mut targets } => {\n+                self.visit_operand(cond);\n+                for &target in targets.as_slice() {\n+                    self.visit_branch(block, target);\n+                }\n+            }\n+\n+            Terminator::Switch { ref mut discr, adt_def: _, ref targets } => {\n+                self.visit_lvalue(discr, LvalueContext::Inspect);\n+                for &target in targets {\n+                    self.visit_branch(block, target);\n+                }\n+            }\n+\n+            Terminator::SwitchInt { ref mut discr, switch_ty: _, values: _, ref targets } => {\n+                self.visit_lvalue(discr, LvalueContext::Inspect);\n+                for &target in targets {\n+                    self.visit_branch(block, target);\n+                }\n+            }\n+\n+            Terminator::Diverge |\n+            Terminator::Return => {\n+            }\n+\n+            Terminator::Call { ref mut data, ref mut targets } => {\n+                self.visit_lvalue(&mut data.destination, LvalueContext::Store);\n+                self.visit_operand(&mut data.func);\n+                for arg in &mut data.args {\n+                    self.visit_operand(arg);\n+                }\n+                for &target in targets.as_slice() {\n+                    self.visit_branch(block, target);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn super_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>) {\n+        match *rvalue {\n+            Rvalue::Use(ref mut operand) => {\n+                self.visit_operand(operand);\n+            }\n+\n+            Rvalue::Repeat(ref mut value, ref mut len) => {\n+                self.visit_operand(value);\n+                self.visit_constant(len);\n+            }\n+\n+            Rvalue::Ref(r, bk, ref mut path) => {\n+                self.visit_lvalue(path, LvalueContext::Borrow {\n+                    region: r,\n+                    kind: bk\n+                });\n+            }\n+\n+            Rvalue::Len(ref mut path) => {\n+                self.visit_lvalue(path, LvalueContext::Inspect);\n+            }\n+\n+            Rvalue::Cast(_, ref mut operand, _) => {\n+                self.visit_operand(operand);\n+            }\n+\n+            Rvalue::BinaryOp(_, ref mut lhs, ref mut rhs) => {\n+                self.visit_operand(lhs);\n+                self.visit_operand(rhs);\n+            }\n+\n+            Rvalue::UnaryOp(_, ref mut op) => {\n+                self.visit_operand(op);\n+            }\n+\n+            Rvalue::Box(_) => {\n+            }\n+\n+            Rvalue::Aggregate(ref mut kind, ref mut operands) => {\n+                match *kind {\n+                    AggregateKind::Closure(ref mut def_id, _) => {\n+                        self.visit_def_id(def_id);\n+                    }\n+                    _ => { /* nothing to do */ }\n+                }\n+\n+                for operand in &mut operands[..] {\n+                    self.visit_operand(operand);\n+                }\n+            }\n+\n+            Rvalue::Slice { ref mut input, from_start, from_end } => {\n+                self.visit_lvalue(input, LvalueContext::Slice {\n+                    from_start: from_start,\n+                    from_end: from_end,\n+                });\n+            }\n+\n+            Rvalue::InlineAsm(_) => {\n+            }\n+        }\n+    }\n+\n+    fn super_operand(&mut self, operand: &mut Operand<'tcx>) {\n+        match *operand {\n+            Operand::Consume(ref mut lvalue) => {\n+                self.visit_lvalue(lvalue, LvalueContext::Consume);\n+            }\n+            Operand::Constant(ref mut constant) => {\n+                self.visit_constant(constant);\n+            }\n+        }\n+    }\n+\n+    fn super_lvalue(&mut self,\n+                    lvalue: &mut Lvalue<'tcx>,\n+                    _context: LvalueContext) {\n+        match *lvalue {\n+            Lvalue::Var(_) |\n+            Lvalue::Temp(_) |\n+            Lvalue::Arg(_) |\n+            Lvalue::ReturnPointer => {\n+            }\n+            Lvalue::Static(ref mut def_id) => {\n+                self.visit_def_id(def_id);\n+            }\n+            Lvalue::Projection(ref mut proj) => {\n+                self.visit_lvalue(&mut proj.base, LvalueContext::Projection);\n+            }\n+        }\n+    }\n+\n+    fn super_branch(&mut self, _source: BasicBlock, _target: BasicBlock) {\n+    }\n+\n+    fn super_constant(&mut self, constant: &mut Constant<'tcx>) {\n+        self.visit_span(&mut constant.span);\n+        self.visit_literal(&mut constant.literal);\n+    }\n+\n+    fn super_literal(&mut self, literal: &mut Literal<'tcx>) {\n+        match *literal {\n+            Literal::Item { ref mut def_id, .. } => {\n+                self.visit_def_id(def_id);\n+            },\n+            Literal::Value { .. } => {\n+                // Nothing to do\n+            }\n+        }\n+    }\n+\n+    fn super_def_id(&mut self, _def_id: &mut DefId) {\n+    }\n+\n+    fn super_span(&mut self, _span: &mut Span) {\n+    }\n+}"}, {"sha": "0ea7cfa3902fa86df7b2c79fe2f354329c1e63b9", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -42,6 +42,7 @@ pub mod snapshot_vec;\n pub mod transitive_relation;\n pub mod unify;\n pub mod fnv;\n+pub mod tuple_slice;\n \n // See comments in src/librustc/lib.rs\n #[doc(hidden)]"}, {"sha": "f157d82eda12b9d7d9d05dace89223d0f13a05f5", "filename": "src/librustc_data_structures/tuple_slice.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_data_structures%2Ftuple_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_data_structures%2Ftuple_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftuple_slice.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::slice;\n+\n+/// Allows to view uniform tuples as slices\n+pub trait TupleSlice<T> {\n+    fn as_slice(&self) -> &[T];\n+    fn as_mut_slice(&mut self) -> &mut [T];\n+}\n+\n+macro_rules! impl_tuple_slice {\n+    ($tuple_type:ty, $size:expr) => {\n+        impl<T> TupleSlice<T> for $tuple_type {\n+            fn as_slice(&self) -> &[T] {\n+                unsafe {\n+                    let ptr = &self.0 as *const T;\n+                    slice::from_raw_parts(ptr, $size)\n+                }\n+            }\n+\n+            fn as_mut_slice(&mut self) -> &mut [T] {\n+                unsafe {\n+                    let ptr = &mut self.0 as *mut T;\n+                    slice::from_raw_parts_mut(ptr, $size)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl_tuple_slice!((T,T), 2);\n+impl_tuple_slice!((T,T,T), 3);\n+impl_tuple_slice!((T,T,T,T), 4);\n+impl_tuple_slice!((T,T,T,T,T), 5);\n+impl_tuple_slice!((T,T,T,T,T,T), 6);\n+impl_tuple_slice!((T,T,T,T,T,T,T), 7);\n+impl_tuple_slice!((T,T,T,T,T,T,T,T), 8);\n+\n+#[test]\n+fn test_sliced_tuples() {\n+    let t2 = (100i32, 101i32);\n+    assert_eq!(t2.as_slice(), &[100i32, 101i32]);\n+\n+    let t3 = (102i32, 103i32, 104i32);\n+    assert_eq!(t3.as_slice(), &[102i32, 103i32, 104i32]);\n+\n+    let t4 = (105i32, 106i32, 107i32, 108i32);\n+    assert_eq!(t4.as_slice(), &[105i32, 106i32, 107i32, 108i32]);\n+\n+    let t5 = (109i32, 110i32, 111i32, 112i32, 113i32);\n+    assert_eq!(t5.as_slice(), &[109i32, 110i32, 111i32, 112i32, 113i32]);\n+}"}, {"sha": "5186c9691334143dc10cdb44e2881c55fc27f5e1", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -120,7 +120,8 @@ enum_from_u32! {\n \n         tag_tree = 0x51,\n \n-        // GAP 0x52\n+        tag_mir = 0x52,\n+\n         tag_table = 0x53,\n         // GAP 0x54, 0x55\n         tag_table_def = 0x56,"}, {"sha": "ad00ef29e5f60e53c41d97d67dce5a13fbde6c48", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -22,6 +22,7 @@ use middle::ty::{self, Ty};\n use middle::def_id::{DefId, DefIndex};\n \n use rustc::front::map as hir_map;\n+use rustc::mir::repr::Mir;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use std::cell::RefCell;\n@@ -421,6 +422,12 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::maybe_get_item_ast(&*cdata, tcx, def.index, decode_inlined_item)\n     }\n \n+    fn maybe_get_item_mir(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n+                          -> Option<Mir<'tcx>> {\n+        let cdata = self.get_crate_data(def.krate);\n+        decoder::maybe_get_item_mir(&*cdata, tcx, def.index)\n+    }\n+\n     fn crates(&self) -> Vec<ast::CrateNum>\n     {\n         let mut result = vec![];\n@@ -473,6 +480,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                        item_symbols: &RefCell<NodeMap<String>>,\n                        link_meta: &LinkMeta,\n                        reachable: &NodeSet,\n+                       mir_map: &NodeMap<Mir<'tcx>>,\n                        krate: &hir::Crate) -> Vec<u8>\n     {\n         let encode_inlined_item: encoder::EncodeInlinedItem =\n@@ -486,7 +494,8 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n             link_meta: link_meta,\n             cstore: self,\n             encode_inlined_item: encode_inlined_item,\n-            reachable: reachable\n+            reachable: reachable,\n+            mir_map: mir_map,\n         };\n         encoder::encode_metadata(encode_params, krate)\n "}, {"sha": "d1917b29b9f1201178393cc4c0dc8be68f7356a7", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -18,6 +18,7 @@ use cstore::{self, crate_metadata};\n use common::*;\n use encoder::def_to_u64;\n use index;\n+use tls_context;\n use tydecode::TyDecoder;\n \n use rustc::back::svh::Svh;\n@@ -26,14 +27,17 @@ use rustc::util::nodemap::FnvHashMap;\n use rustc_front::hir;\n \n use middle::cstore::{LOCAL_CRATE, FoundAst, InlinedItem, LinkagePreference};\n-use middle::cstore::{DefLike, DlDef, DlField, DlImpl};\n+use middle::cstore::{DefLike, DlDef, DlField, DlImpl, tls};\n use middle::def;\n use middle::def_id::{DefId, DefIndex};\n use middle::lang_items;\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty::{self, RegionEscape, Ty};\n \n+use rustc::mir;\n+use rustc::mir::visit::MutVisitor;\n+\n use std::cell::{Cell, RefCell};\n use std::io::prelude::*;\n use std::io;\n@@ -48,7 +52,7 @@ use syntax::parse::token::{IdentInterner, special_idents};\n use syntax::parse::token;\n use syntax::ast;\n use syntax::abi;\n-use syntax::codemap;\n+use syntax::codemap::{self, Span};\n use syntax::print::pprust;\n use syntax::ptr::P;\n \n@@ -783,6 +787,56 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: DefIndex,\n     }\n }\n \n+pub fn maybe_get_item_mir<'tcx>(cdata: Cmd,\n+                                tcx: &ty::ctxt<'tcx>,\n+                                id: DefIndex)\n+                                -> Option<mir::repr::Mir<'tcx>> {\n+    let item_doc = cdata.lookup_item(id);\n+\n+    return reader::maybe_get_doc(item_doc, tag_mir as usize).map(|mir_doc| {\n+        let dcx = tls_context::DecodingContext {\n+            crate_metadata: cdata,\n+            tcx: tcx,\n+        };\n+        let mut decoder = reader::Decoder::new(mir_doc);\n+\n+        let mut mir = tls::enter_decoding_context(&dcx, &mut decoder, |_, decoder| {\n+            Decodable::decode(decoder).unwrap()\n+        });\n+\n+        let mut def_id_and_span_translator = MirDefIdAndSpanTranslator {\n+            crate_metadata: cdata,\n+            codemap: tcx.sess.codemap(),\n+            last_filemap_index_hint: Cell::new(0),\n+        };\n+\n+        def_id_and_span_translator.visit_mir(&mut mir);\n+\n+        mir\n+    });\n+\n+    struct MirDefIdAndSpanTranslator<'cdata, 'codemap> {\n+        crate_metadata: Cmd<'cdata>,\n+        codemap: &'codemap codemap::CodeMap,\n+        last_filemap_index_hint: Cell<usize>\n+    }\n+\n+    impl<'v, 'cdata, 'codemap> mir::visit::MutVisitor<'v>\n+        for MirDefIdAndSpanTranslator<'cdata, 'codemap>\n+    {\n+        fn visit_def_id(&mut self, def_id: &mut DefId) {\n+            *def_id = translate_def_id(self.crate_metadata, *def_id);\n+        }\n+\n+        fn visit_span(&mut self, span: &mut Span) {\n+            *span = translate_span(self.crate_metadata,\n+                                   self.codemap,\n+                                   &self.last_filemap_index_hint,\n+                                   *span);\n+        }\n+    }\n+}\n+\n fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n     fn get_mutability(ch: u8) -> hir::Mutability {\n         match ch as char {"}, {"sha": "a627eeb68807508c35b7845e4d8dab26e4e931c8", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -30,6 +30,7 @@ use middle::ty::{self, Ty};\n use rustc::back::svh::Svh;\n use rustc::front::map::{LinkedPath, PathElem, PathElems};\n use rustc::front::map as ast_map;\n+use rustc::mir::repr::Mir;\n use rustc::session::config;\n use rustc::util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n@@ -64,6 +65,7 @@ pub struct EncodeParams<'a, 'tcx: 'a> {\n     pub cstore: &'a cstore::CStore,\n     pub encode_inlined_item: EncodeInlinedItem<'a>,\n     pub reachable: &'a NodeSet,\n+    pub mir_map: &'a NodeMap<Mir<'tcx>>,\n }\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n@@ -76,6 +78,7 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub encode_inlined_item: RefCell<EncodeInlinedItem<'a>>,\n     pub type_abbrevs: tyencode::abbrev_map<'tcx>,\n     pub reachable: &'a NodeSet,\n+    pub mir_map: &'a NodeMap<Mir<'tcx>>,\n }\n \n impl<'a, 'tcx> EncodeContext<'a,'tcx> {\n@@ -840,7 +843,24 @@ fn encode_inlined_item(ecx: &EncodeContext,\n                        ii: InlinedItemRef) {\n     let mut eii = ecx.encode_inlined_item.borrow_mut();\n     let eii: &mut EncodeInlinedItem = &mut *eii;\n-    eii(ecx, rbml_w, ii)\n+    eii(ecx, rbml_w, ii);\n+\n+    encode_mir(ecx, rbml_w, ii);\n+}\n+\n+fn encode_mir(ecx: &EncodeContext, rbml_w: &mut Encoder, ii: InlinedItemRef) {\n+    let id = match ii {\n+        InlinedItemRef::Item(item) => item.id,\n+        InlinedItemRef::TraitItem(_, trait_item) => trait_item.id,\n+        InlinedItemRef::ImplItem(_, impl_item) => impl_item.id,\n+        InlinedItemRef::Foreign(foreign_item) => foreign_item.id\n+    };\n+\n+    if let Some(mir) = ecx.mir_map.get(&id) {\n+        rbml_w.start_tag(tag_mir as usize);\n+        Encodable::encode(mir, rbml_w).unwrap();\n+        rbml_w.end_tag();\n+    }\n }\n \n const FN_FAMILY: char = 'f';\n@@ -1884,6 +1904,7 @@ pub fn encode_metadata(parms: EncodeParams, krate: &hir::Crate) -> Vec<u8> {\n         encode_inlined_item,\n         link_meta,\n         reachable,\n+        mir_map,\n         ..\n     } = parms;\n     let ecx = EncodeContext {\n@@ -1896,6 +1917,7 @@ pub fn encode_metadata(parms: EncodeParams, krate: &hir::Crate) -> Vec<u8> {\n         encode_inlined_item: RefCell::new(encode_inlined_item),\n         type_abbrevs: RefCell::new(FnvHashMap()),\n         reachable: reachable,\n+        mir_map: mir_map,\n     };\n \n     let mut wr = Cursor::new(Vec::new());"}, {"sha": "1c96addcea0d9e618644462836c8cf3244be6aac", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -69,7 +69,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 this.cfg.terminate(block,\n                                    Terminator::If {\n                                        cond: Operand::Consume(lt),\n-                                       targets: [success, failure],\n+                                       targets: (success, failure),\n                                    });\n                 this.panic(failure);\n                 success.and(slice.index(idx))"}, {"sha": "2f57dd22454cb50c3841216fe1512b27e86fd6df", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -40,7 +40,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 this.in_scope(extent, block, |this| this.as_rvalue(block, value))\n             }\n             ExprKind::InlineAsm { asm } => {\n-                block.and(Rvalue::InlineAsm(asm))\n+                block.and(Rvalue::InlineAsm(asm.clone()))\n             }\n             ExprKind::Repeat { value, count } => {\n                 let value_operand = unpack!(block = this.as_operand(block, value));"}, {"sha": "802c55ce7647a0f53bdd731ba5f8eaab99ee3d9c", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -53,7 +53,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let mut else_block = this.cfg.start_new_block();\n                 this.cfg.terminate(block, Terminator::If {\n                     cond: operand,\n-                    targets: [then_block, else_block]\n+                    targets: (then_block, else_block)\n                 });\n \n                 unpack!(then_block = this.into(destination, then_block, then_expr));\n@@ -84,15 +84,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n                 let lhs = unpack!(block = this.as_operand(block, lhs));\n                 let blocks = match op {\n-                    LogicalOp::And => [else_block, false_block],\n-                    LogicalOp::Or => [true_block, else_block],\n+                    LogicalOp::And => (else_block, false_block),\n+                    LogicalOp::Or => (true_block, else_block),\n                 };\n                 this.cfg.terminate(block, Terminator::If { cond: lhs, targets: blocks });\n \n                 let rhs = unpack!(else_block = this.as_operand(else_block, rhs));\n                 this.cfg.terminate(else_block, Terminator::If {\n                     cond: rhs,\n-                    targets: [true_block, false_block]\n+                    targets: (true_block, false_block)\n                 });\n \n                 this.cfg.push_assign_constant(\n@@ -149,7 +149,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         this.cfg.terminate(loop_block_end,\n                                            Terminator::If {\n                                                cond: cond,\n-                                               targets: [body_block, exit_block]\n+                                               targets: (body_block, exit_block)\n                                            });\n                     } else {\n                         body_block = loop_block;\n@@ -225,7 +225,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                            func: fun,\n                                            args: args,\n                                        },\n-                                       targets: [success, panic],\n+                                       targets: (success, panic),\n                                    });\n                 success.unit()\n             }"}, {"sha": "f8385d5817018b063217a11bb9353827fb6dea0a", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -555,7 +555,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             let cond = unpack!(block = self.as_operand(block, guard));\n             let otherwise = self.cfg.start_new_block();\n             self.cfg.terminate(block, Terminator::If { cond: cond,\n-                                                       targets: [arm_block, otherwise]});\n+                                                       targets: (arm_block, otherwise)});\n             Some(otherwise)\n         } else {\n             self.cfg.terminate(block, Terminator::Goto { target: arm_block });"}, {"sha": "7b329fc4d52c38da3d25af934e56d29ba1d26ddd", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -232,7 +232,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                                  self.cfg.start_new_block()];\n                 self.cfg.terminate(block, Terminator::If {\n                     cond: Operand::Consume(result),\n-                    targets: [target_blocks[0], target_blocks[1]]\n+                    targets: (target_blocks[0], target_blocks[1])\n                 });\n \n                 target_blocks\n@@ -252,7 +252,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let bool_ty = self.hir.bool_ty();\n         let eq_result = self.temp(bool_ty);\n         let func = self.item_ref_operand(span, item_ref);\n-        let call_blocks = [self.cfg.start_new_block(), self.diverge_cleanup()];\n+        let call_blocks = (self.cfg.start_new_block(), self.diverge_cleanup());\n         self.cfg.terminate(block,\n                            Terminator::Call {\n                                data: CallData {\n@@ -264,10 +264,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                            });\n \n         // check the result\n-        self.cfg.terminate(call_blocks[0],\n+        self.cfg.terminate(call_blocks.0,\n                            Terminator::If {\n                                cond: Operand::Consume(eq_result),\n-                               targets: [target_blocks[0], target_blocks[1]],\n+                               targets: (target_blocks[0], target_blocks[1]),\n                            });\n \n         target_blocks"}, {"sha": "d0c0afc80a657dce2b7c166c4536cbdc1896a3cd", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -96,18 +96,21 @@ impl SimplifyCfg {\n             mem::swap(&mut terminator, &mut mir.basic_block_data_mut(bb).terminator);\n \n             mir.basic_block_data_mut(bb).terminator = match terminator {\n-                Terminator::If { ref targets, .. } if targets[0] == targets[1] => {\n+                Terminator::If { ref targets, .. } if targets.0 == targets.1 => {\n                     changed = true;\n-                    Terminator::Goto { target: targets[0] }\n+                    Terminator::Goto { target: targets.0 }\n                 }\n                 Terminator::If { ref targets, cond: Operand::Constant(Constant {\n                     literal: Literal::Value {\n                         value: ConstVal::Bool(cond)\n                     }, ..\n                 }) } => {\n                     changed = true;\n-                    let target_idx = if cond { 0 } else { 1 };\n-                    Terminator::Goto { target: targets[target_idx] }\n+                    if cond {\n+                        Terminator::Goto { target: targets.0 }\n+                    } else {\n+                        Terminator::Goto { target: targets.1 }\n+                    }\n                 }\n                 Terminator::SwitchInt { ref targets, .. }  if targets.len() == 1 => {\n                     Terminator::Goto { target: targets[0] }"}, {"sha": "838a5435d4feee8b4a9c0e42b15e737a7cefc405", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -2760,7 +2760,11 @@ fn register_method(ccx: &CrateContext,\n     }\n }\n \n-pub fn write_metadata(cx: &SharedCrateContext, krate: &hir::Crate, reachable: &NodeSet) -> Vec<u8> {\n+pub fn write_metadata<'a, 'tcx>(cx: &SharedCrateContext<'a, 'tcx>,\n+                                krate: &hir::Crate,\n+                                reachable: &NodeSet,\n+                                mir_map: &MirMap<'tcx>)\n+                                -> Vec<u8> {\n     use flate;\n \n     let any_library = cx.sess()\n@@ -2773,9 +2777,13 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &hir::Crate, reachable: &N\n     }\n \n     let cstore = &cx.tcx().sess.cstore;\n-    let metadata = cstore.encode_metadata(\n-        cx.tcx(), cx.export_map(), cx.item_symbols(), cx.link_meta(), reachable,\n-        krate);\n+    let metadata = cstore.encode_metadata(cx.tcx(),\n+                                          cx.export_map(),\n+                                          cx.item_symbols(),\n+                                          cx.link_meta(),\n+                                          reachable,\n+                                          mir_map,\n+                                          krate);\n     let mut compressed = cstore.metadata_encoding_version().to_vec();\n     compressed.extend_from_slice(&flate::deflate_bytes(&metadata));\n \n@@ -3045,7 +3053,7 @@ pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let reachable_symbol_ids = filter_reachable_ids(&shared_ccx);\n \n     // Translate the metadata.\n-    let metadata = write_metadata(&shared_ccx, krate, &reachable_symbol_ids);\n+    let metadata = write_metadata(&shared_ccx, krate, &reachable_symbol_ids, mir_map);\n \n     if shared_ccx.sess().trans_stats() {\n         let stats = shared_ccx.stats();"}, {"sha": "b58b51f5a2b235d6df5d92ede9c371a722f937b5", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -39,7 +39,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 unimplemented!()\n             }\n \n-            mir::Terminator::If { ref cond, targets: [true_bb, false_bb] } => {\n+            mir::Terminator::If { ref cond, targets: (true_bb, false_bb) } => {\n                 let cond = self.trans_operand(bcx, cond);\n                 let lltrue = self.llblock(true_bb);\n                 let llfalse = self.llblock(false_bb);"}, {"sha": "529e65dace04cea804e843f8f1b5bf93a92f76a5", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce713961cb7c36bb66db70a276973eb78cf9e6e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=7ce713961cb7c36bb66db70a276973eb78cf9e6e", "patch": "@@ -120,7 +120,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 bcx\n             }\n \n-            mir::Rvalue::InlineAsm(inline_asm) => {\n+            mir::Rvalue::InlineAsm(ref inline_asm) => {\n                 asm::trans_inline_asm(bcx, inline_asm)\n             }\n "}]}