{"sha": "64474a40b0273557dbea58ca29af9245cbb4ad87", "node_id": "C_kwDOAAsO6NoAKDY0NDc0YTQwYjAyNzM1NTdkYmVhNThjYTI5YWY5MjQ1Y2JiNGFkODc", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-10-31T11:01:54Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2023-04-16T03:50:57Z"}, "message": "Move the WorkerLocal type from the rustc-rayon fork into rustc_data_structures", "tree": {"sha": "2be6396311b795b12a8a603ab84b80349c3f91c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2be6396311b795b12a8a603ab84b80349c3f91c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64474a40b0273557dbea58ca29af9245cbb4ad87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64474a40b0273557dbea58ca29af9245cbb4ad87", "html_url": "https://github.com/rust-lang/rust/commit/64474a40b0273557dbea58ca29af9245cbb4ad87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64474a40b0273557dbea58ca29af9245cbb4ad87/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6fb7b9815aea87fb5ced1c683212871699c907c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6fb7b9815aea87fb5ced1c683212871699c907c", "html_url": "https://github.com/rust-lang/rust/commit/c6fb7b9815aea87fb5ced1c683212871699c907c"}], "stats": {"total": 247, "additions": 213, "deletions": 34}, "files": [{"sha": "7ed70ba1e0fc7737a78af1e2a08842919f316922", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64474a40b0273557dbea58ca29af9245cbb4ad87/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64474a40b0273557dbea58ca29af9245cbb4ad87/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=64474a40b0273557dbea58ca29af9245cbb4ad87", "patch": "@@ -1,14 +1,10 @@\n use crate::fx::{FxHashMap, FxHasher};\n-use crate::sync::{Lock, LockGuard};\n+use crate::sync::{CacheAligned, Lock, LockGuard};\n use std::borrow::Borrow;\n use std::collections::hash_map::RawEntryMut;\n use std::hash::{Hash, Hasher};\n use std::mem;\n \n-#[derive(Default)]\n-#[cfg_attr(parallel_compiler, repr(align(64)))]\n-struct CacheAligned<T>(T);\n-\n #[cfg(parallel_compiler)]\n // 32 shards is sufficient to reduce contention on an 8-core Ryzen 7 1700,\n // but this should be tested on higher core count CPUs. How the `Sharded` type gets used"}, {"sha": "e73ca56efa0377d0357ce308a2a89f35e4a764d9", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/64474a40b0273557dbea58ca29af9245cbb4ad87/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64474a40b0273557dbea58ca29af9245cbb4ad87/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=64474a40b0273557dbea58ca29af9245cbb4ad87", "patch": "@@ -45,6 +45,9 @@ use std::hash::{BuildHasher, Hash};\n use std::ops::{Deref, DerefMut};\n use std::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\n \n+mod worker_local;\n+pub use worker_local::{Registry, WorkerLocal};\n+\n pub use std::sync::atomic::Ordering;\n pub use std::sync::atomic::Ordering::SeqCst;\n \n@@ -205,33 +208,6 @@ cfg_if! {\n \n         use std::cell::Cell;\n \n-        #[derive(Debug)]\n-        pub struct WorkerLocal<T>(OneThread<T>);\n-\n-        impl<T> WorkerLocal<T> {\n-            /// Creates a new worker local where the `initial` closure computes the\n-            /// value this worker local should take for each thread in the thread pool.\n-            #[inline]\n-            pub fn new<F: FnMut(usize) -> T>(mut f: F) -> WorkerLocal<T> {\n-                WorkerLocal(OneThread::new(f(0)))\n-            }\n-\n-            /// Returns the worker-local value for each thread\n-            #[inline]\n-            pub fn into_inner(self) -> Vec<T> {\n-                vec![OneThread::into_inner(self.0)]\n-            }\n-        }\n-\n-        impl<T> Deref for WorkerLocal<T> {\n-            type Target = T;\n-\n-            #[inline(always)]\n-            fn deref(&self) -> &T {\n-                &self.0\n-            }\n-        }\n-\n         pub type MTLockRef<'a, T> = &'a mut MTLock<T>;\n \n         #[derive(Debug, Default)]\n@@ -351,8 +327,6 @@ cfg_if! {\n             };\n         }\n \n-        pub use rayon_core::WorkerLocal;\n-\n         pub use rayon::iter::ParallelIterator;\n         use rayon::iter::IntoParallelIterator;\n \n@@ -383,6 +357,10 @@ pub fn assert_send<T: ?Sized + Send>() {}\n pub fn assert_send_val<T: ?Sized + Send>(_t: &T) {}\n pub fn assert_send_sync_val<T: ?Sized + Sync + Send>(_t: &T) {}\n \n+#[derive(Default)]\n+#[cfg_attr(parallel_compiler, repr(align(64)))]\n+pub struct CacheAligned<T>(pub T);\n+\n pub trait HashMapExt<K, V> {\n     /// Same as HashMap::insert, but it may panic if there's already an\n     /// entry for `key` with a value not equal to `value`"}, {"sha": "bfb04ba8a73f4cff7d5978614dcf0841048ce753", "filename": "compiler/rustc_data_structures/src/sync/worker_local.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/64474a40b0273557dbea58ca29af9245cbb4ad87/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fworker_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64474a40b0273557dbea58ca29af9245cbb4ad87/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fworker_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fworker_local.rs?ref=64474a40b0273557dbea58ca29af9245cbb4ad87", "patch": "@@ -0,0 +1,180 @@\n+use crate::sync::Lock;\n+use std::cell::Cell;\n+use std::cell::OnceCell;\n+use std::ops::Deref;\n+use std::ptr;\n+use std::sync::Arc;\n+\n+#[cfg(parallel_compiler)]\n+use {crate::cold_path, crate::sync::CacheAligned};\n+\n+/// A pointer to the `RegistryData` which uniquely identifies a registry.\n+/// This identifier can be reused if the registry gets freed.\n+#[derive(Clone, Copy, PartialEq)]\n+struct RegistryId(*const RegistryData);\n+\n+impl RegistryId {\n+    #[inline(always)]\n+    /// Verifies that the current thread is associated with the registry and returns its unique\n+    /// index within the registry. This panics if the current thread is not associated with this\n+    /// registry.\n+    ///\n+    /// Note that there's a race possible where the identifer in `THREAD_DATA` could be reused\n+    /// so this can succeed from a different registry.\n+    #[cfg(parallel_compiler)]\n+    fn verify(self) -> usize {\n+        let (id, index) = THREAD_DATA.with(|data| (data.registry_id.get(), data.index.get()));\n+\n+        if id == self {\n+            index\n+        } else {\n+            cold_path(|| panic!(\"Unable to verify registry association\"))\n+        }\n+    }\n+}\n+\n+struct RegistryData {\n+    thread_limit: usize,\n+    threads: Lock<usize>,\n+}\n+\n+/// Represents a list of threads which can access worker locals.\n+#[derive(Clone)]\n+pub struct Registry(Arc<RegistryData>);\n+\n+thread_local! {\n+    /// The registry associated with the thread.\n+    /// This allows the `WorkerLocal` type to clone the registry in its constructor.\n+    static REGISTRY: OnceCell<Registry> = OnceCell::new();\n+}\n+\n+struct ThreadData {\n+    registry_id: Cell<RegistryId>,\n+    index: Cell<usize>,\n+}\n+\n+thread_local! {\n+    /// A thread local which contains the identifer of `REGISTRY` but allows for faster access.\n+    /// It also holds the index of the current thread.\n+    static THREAD_DATA: ThreadData = const { ThreadData {\n+        registry_id: Cell::new(RegistryId(ptr::null())),\n+        index: Cell::new(0),\n+    }};\n+}\n+\n+impl Registry {\n+    /// Creates a registry which can hold up to `thread_limit` threads.\n+    pub fn new(thread_limit: usize) -> Self {\n+        Registry(Arc::new(RegistryData { thread_limit, threads: Lock::new(0) }))\n+    }\n+\n+    /// Gets the registry associated with the current thread. Panics if there's no such registry.\n+    pub fn current() -> Self {\n+        REGISTRY.with(|registry| registry.get().cloned().expect(\"No assocated registry\"))\n+    }\n+\n+    /// Registers the current thread with the registry so worker locals can be used on it.\n+    /// Panics if the thread limit is hit or if the thread already has an associated registry.\n+    pub fn register(&self) {\n+        let mut threads = self.0.threads.lock();\n+        if *threads < self.0.thread_limit {\n+            REGISTRY.with(|registry| {\n+                if registry.get().is_some() {\n+                    drop(threads);\n+                    panic!(\"Thread already has a registry\");\n+                }\n+                registry.set(self.clone()).ok();\n+                THREAD_DATA.with(|data| {\n+                    data.registry_id.set(self.id());\n+                    data.index.set(*threads);\n+                });\n+                *threads += 1;\n+            });\n+        } else {\n+            drop(threads);\n+            panic!(\"Thread limit reached\");\n+        }\n+    }\n+\n+    /// Gets the identifer of this registry.\n+    fn id(&self) -> RegistryId {\n+        RegistryId(&*self.0)\n+    }\n+}\n+\n+/// Holds worker local values for each possible thread in a registry. You can only access the\n+/// worker local value through the `Deref` impl on the registry associated with the thread it was\n+/// created on. It will panic otherwise.\n+pub struct WorkerLocal<T> {\n+    #[cfg(not(parallel_compiler))]\n+    local: T,\n+    #[cfg(parallel_compiler)]\n+    locals: Box<[CacheAligned<T>]>,\n+    #[cfg(parallel_compiler)]\n+    registry: Registry,\n+}\n+\n+// This is safe because the `deref` call will return a reference to a `T` unique to each thread\n+// or it will panic for threads without an associated local. So there isn't a need for `T` to do\n+// it's own synchronization. The `verify` method on `RegistryId` has an issue where the the id\n+// can be reused, but `WorkerLocal` has a reference to `Registry` which will prevent any reuse.\n+#[cfg(parallel_compiler)]\n+unsafe impl<T: Send> Sync for WorkerLocal<T> {}\n+\n+impl<T> WorkerLocal<T> {\n+    /// Creates a new worker local where the `initial` closure computes the\n+    /// value this worker local should take for each thread in the registry.\n+    #[inline]\n+    pub fn new<F: FnMut(usize) -> T>(mut initial: F) -> WorkerLocal<T> {\n+        #[cfg(parallel_compiler)]\n+        {\n+            let registry = Registry::current();\n+            WorkerLocal {\n+                locals: (0..registry.0.thread_limit).map(|i| CacheAligned(initial(i))).collect(),\n+                registry,\n+            }\n+        }\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            WorkerLocal { local: initial(0) }\n+        }\n+    }\n+\n+    /// Returns the worker-local values for each thread\n+    #[inline]\n+    pub fn into_inner(self) -> impl Iterator<Item = T> {\n+        #[cfg(parallel_compiler)]\n+        {\n+            self.locals.into_vec().into_iter().map(|local| local.0)\n+        }\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            std::iter::once(self.local)\n+        }\n+    }\n+}\n+\n+impl<T> WorkerLocal<Vec<T>> {\n+    /// Joins the elements of all the worker locals into one Vec\n+    pub fn join(self) -> Vec<T> {\n+        self.into_inner().into_iter().flat_map(|v| v).collect()\n+    }\n+}\n+\n+impl<T> Deref for WorkerLocal<T> {\n+    type Target = T;\n+\n+    #[inline(always)]\n+    #[cfg(not(parallel_compiler))]\n+    fn deref(&self) -> &T {\n+        &self.local\n+    }\n+\n+    #[inline(always)]\n+    #[cfg(parallel_compiler)]\n+    fn deref(&self) -> &T {\n+        // This is safe because `verify` will only return values less than\n+        // `self.registry.thread_limit` which is the size of the `self.locals` array.\n+        unsafe { &self.locals.get_unchecked(self.registry.id().verify()).0 }\n+    }\n+}"}, {"sha": "577a1034307cf72771c8f1a46237e252fb00173e", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/64474a40b0273557dbea58ca29af9245cbb4ad87/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64474a40b0273557dbea58ca29af9245cbb4ad87/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=64474a40b0273557dbea58ca29af9245cbb4ad87", "patch": "@@ -19,6 +19,7 @@ use rustc_session::Session;\n use rustc_session::{early_error, CompilerIO};\n use rustc_span::source_map::{FileLoader, FileName};\n use rustc_span::symbol::sym;\n+use std::cell::OnceCell;\n use std::path::PathBuf;\n use std::result;\n \n@@ -58,9 +59,25 @@ impl Compiler {\n     }\n }\n \n+fn registry_setup() {\n+    thread_local! {\n+        static ONCE: OnceCell<()> = OnceCell::new();\n+    }\n+\n+    // Create a dummy registry to allow `WorkerLocal` construction.\n+    // We use `OnceCell` so we only register one dummy registry per thread.\n+    ONCE.with(|once| {\n+        once.get_or_init(|| {\n+            rustc_data_structures::sync::Registry::new(1).register();\n+        });\n+    });\n+}\n+\n /// Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`.\n pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n     rustc_span::create_default_session_if_not_set_then(move |_| {\n+        registry_setup();\n+\n         let cfg = cfgspecs\n             .into_iter()\n             .map(|s| {\n@@ -120,6 +137,8 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n /// Converts strings provided as `--check-cfg [specs]` into a `CheckCfg`.\n pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n     rustc_span::create_default_session_if_not_set_then(move |_| {\n+        registry_setup();\n+\n         let mut cfg = CheckCfg::default();\n \n         'specs: for s in specs {"}, {"sha": "a27a1e2978a368e2f4c2d9b9ac463b861d9c5c33", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/64474a40b0273557dbea58ca29af9245cbb4ad87/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64474a40b0273557dbea58ca29af9245cbb4ad87/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=64474a40b0273557dbea58ca29af9245cbb4ad87", "patch": "@@ -4,6 +4,8 @@ use libloading::Library;\n use rustc_ast as ast;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+#[cfg(parallel_compiler)]\n+use rustc_data_structures::sync;\n use rustc_errors::registry::Registry;\n use rustc_parse::validate_attr;\n use rustc_session as session;\n@@ -170,6 +172,7 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     use rustc_middle::ty::tls;\n     use rustc_query_impl::{deadlock, QueryContext, QueryCtxt};\n \n+    let registry = sync::Registry::new(threads);\n     let mut builder = rayon::ThreadPoolBuilder::new()\n         .thread_name(|_| \"rustc\".to_string())\n         .acquire_thread_handler(jobserver::acquire_thread)\n@@ -200,6 +203,9 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n                 .build_scoped(\n                     // Initialize each new worker thread when created.\n                     move |thread: rayon::ThreadBuilder| {\n+                        // Register the thread for use with the `WorkerLocal` type.\n+                        registry.register();\n+\n                         rustc_span::set_session_globals_then(session_globals, || thread.run())\n                     },\n                     // Run `f` on the first thread in the thread pool."}]}