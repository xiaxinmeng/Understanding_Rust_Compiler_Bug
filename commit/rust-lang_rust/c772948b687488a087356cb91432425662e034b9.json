{"sha": "c772948b687488a087356cb91432425662e034b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NzI5NDhiNjg3NDg4YTA4NzM1NmNiOTE0MzI0MjU2NjJlMDM0Yjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-20T15:01:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-20T15:01:01Z"}, "message": "Auto merge of #36388 - pcwalton:copy-propagation, r=nikomatsakis\n\nlibrustc_mir: Implement def-use chains and trivial copy propagation on MIR.\n\nThis only supports trivial cases in which there is exactly one def and\none use.\n\nCurrently, some random unrelated MIR tests are failing, probably just because they haven't been updated.\n\nr? @eddyb", "tree": {"sha": "bff1c7822b91450f04d0cabaf98ee85b0df9b2ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bff1c7822b91450f04d0cabaf98ee85b0df9b2ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c772948b687488a087356cb91432425662e034b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c772948b687488a087356cb91432425662e034b9", "html_url": "https://github.com/rust-lang/rust/commit/c772948b687488a087356cb91432425662e034b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c772948b687488a087356cb91432425662e034b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c2552b712386dd01a9d620aff960b98cddb4098", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c2552b712386dd01a9d620aff960b98cddb4098", "html_url": "https://github.com/rust-lang/rust/commit/2c2552b712386dd01a9d620aff960b98cddb4098"}, {"sha": "480287ec3b0260e26c8796506039c379bd7e0ead", "url": "https://api.github.com/repos/rust-lang/rust/commits/480287ec3b0260e26c8796506039c379bd7e0ead", "html_url": "https://github.com/rust-lang/rust/commit/480287ec3b0260e26c8796506039c379bd7e0ead"}], "stats": {"total": 630, "additions": 593, "deletions": 37}, "files": [{"sha": "be761c95b6119a40054396a5170b2957308e9669", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -187,6 +187,32 @@ impl<'tcx> Mir<'tcx> {\n         self.var_decls.len() +\n         self.temp_decls.len() + 1\n     }\n+\n+    pub fn format_local(&self, local: Local) -> String {\n+        let mut index = local.index();\n+        index = match index.checked_sub(self.arg_decls.len()) {\n+            None => return format!(\"{:?}\", Arg::new(index)),\n+            Some(index) => index,\n+        };\n+        index = match index.checked_sub(self.var_decls.len()) {\n+            None => return format!(\"{:?}\", Var::new(index)),\n+            Some(index) => index,\n+        };\n+        index = match index.checked_sub(self.temp_decls.len()) {\n+            None => return format!(\"{:?}\", Temp::new(index)),\n+            Some(index) => index,\n+        };\n+        debug_assert!(index == 0);\n+        return \"ReturnPointer\".to_string()\n+    }\n+\n+    /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n+    /// invalidating statement indices in `Location`s.\n+    pub fn make_statement_nop(&mut self, location: Location) {\n+        let block = &mut self[location.block];\n+        debug_assert!(location.statement_index < block.statements.len());\n+        block.statements[location.statement_index].make_nop()\n+    }\n }\n \n impl<'tcx> Index<BasicBlock> for Mir<'tcx> {\n@@ -686,6 +712,14 @@ pub struct Statement<'tcx> {\n     pub kind: StatementKind<'tcx>,\n }\n \n+impl<'tcx> Statement<'tcx> {\n+    /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n+    /// invalidating statement indices in `Location`s.\n+    pub fn make_nop(&mut self) {\n+        self.kind = StatementKind::Nop\n+    }\n+}\n+\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Lvalue.\n@@ -699,6 +733,9 @@ pub enum StatementKind<'tcx> {\n \n     /// End the current live range for the storage of the local.\n     StorageDead(Lvalue<'tcx>),\n+\n+    /// No-op. Useful for deleting instructions without affecting statement indices.\n+    Nop,\n }\n \n impl<'tcx> Debug for Statement<'tcx> {\n@@ -711,6 +748,7 @@ impl<'tcx> Debug for Statement<'tcx> {\n             SetDiscriminant{lvalue: ref lv, variant_index: index} => {\n                 write!(fmt, \"discriminant({:?}) = {:?}\", lv, index)\n             }\n+            Nop => write!(fmt, \"nop\"),\n         }\n     }\n }\n@@ -824,6 +862,24 @@ impl<'tcx> Lvalue<'tcx> {\n             elem: elem,\n         }))\n     }\n+\n+    pub fn from_local(mir: &Mir<'tcx>, local: Local) -> Lvalue<'tcx> {\n+        let mut index = local.index();\n+        index = match index.checked_sub(mir.arg_decls.len()) {\n+            None => return Lvalue::Arg(Arg(index as u32)),\n+            Some(index) => index,\n+        };\n+        index = match index.checked_sub(mir.var_decls.len()) {\n+            None => return Lvalue::Var(Var(index as u32)),\n+            Some(index) => index,\n+        };\n+        index = match index.checked_sub(mir.temp_decls.len()) {\n+            None => return Lvalue::Temp(Temp(index as u32)),\n+            Some(index) => index,\n+        };\n+        debug_assert!(index == 0);\n+        Lvalue::ReturnPointer\n+    }\n }\n \n impl<'tcx> Debug for Lvalue<'tcx> {\n@@ -1258,3 +1314,13 @@ impl fmt::Debug for Location {\n         write!(fmt, \"{:?}[{}]\", self.block, self.statement_index)\n     }\n }\n+\n+impl Location {\n+    pub fn dominates(&self, other: &Location, dominators: &Dominators<BasicBlock>) -> bool {\n+        if self.block == other.block {\n+            self.statement_index <= other.statement_index\n+        } else {\n+            dominators.is_dominated_by(other.block, self.block)\n+        }\n+    }\n+}"}, {"sha": "2c58d35973e73a2c6b7880875cf0824e10016ff4", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 104, "deletions": 5, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -150,7 +150,7 @@ macro_rules! make_mir_visitor {\n \n             fn visit_lvalue(&mut self,\n                             lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            context: LvalueContext,\n+                            context: LvalueContext<'tcx>,\n                             location: Location) {\n                 self.super_lvalue(lvalue, context, location);\n             }\n@@ -346,6 +346,7 @@ macro_rules! make_mir_visitor {\n                     StatementKind::StorageDead(ref $($mutability)* lvalue) => {\n                         self.visit_lvalue(lvalue, LvalueContext::StorageDead, location);\n                     }\n+                    StatementKind::Nop => {}\n                 }\n             }\n \n@@ -580,7 +581,7 @@ macro_rules! make_mir_visitor {\n \n             fn super_lvalue(&mut self,\n                             lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            context: LvalueContext,\n+                            context: LvalueContext<'tcx>,\n                             location: Location) {\n                 match *lvalue {\n                     Lvalue::Var(_) |\n@@ -605,7 +606,12 @@ macro_rules! make_mir_visitor {\n                     ref $($mutability)* base,\n                     ref $($mutability)* elem,\n                 } = *proj;\n-                self.visit_lvalue(base, LvalueContext::Projection, location);\n+                let context = if context.is_mutating_use() {\n+                    LvalueContext::Projection(Mutability::Mut)\n+                } else {\n+                    LvalueContext::Projection(Mutability::Not)\n+                };\n+                self.visit_lvalue(base, context, location);\n                 self.visit_projection_elem(elem, context, location);\n             }\n \n@@ -750,6 +756,21 @@ macro_rules! make_mir_visitor {\n \n             fn super_const_usize(&mut self, _substs: & $($mutability)* ConstUsize) {\n             }\n+\n+            // Convenience methods\n+\n+            fn visit_location(&mut self, mir: & $($mutability)* Mir<'tcx>, location: Location) {\n+                let basic_block = & $($mutability)* mir[location.block];\n+                if basic_block.statements.len() == location.statement_index {\n+                    if let Some(ref $($mutability)* terminator) = basic_block.terminator {\n+                        self.visit_terminator(location.block, terminator, location)\n+                    }\n+                } else {\n+                    let statement = & $($mutability)*\n+                        basic_block.statements[location.statement_index];\n+                    self.visit_statement(location.block, statement, location)\n+                }\n+            }\n         }\n     }\n }\n@@ -774,8 +795,20 @@ pub enum LvalueContext<'tcx> {\n     // Being borrowed\n     Borrow { region: &'tcx Region, kind: BorrowKind },\n \n-    // Used as base for another lvalue, e.g. `x` in `x.y`\n-    Projection,\n+    // Used as base for another lvalue, e.g. `x` in `x.y`.\n+    //\n+    // The `Mutability` argument specifies whether the projection is being performed in order to\n+    // (potentially) mutate the lvalue. For example, the projection `x.y` is marked as a mutation\n+    // in these cases:\n+    //\n+    //     x.y = ...;\n+    //     f(&mut x.y);\n+    //\n+    // But not in these cases:\n+    //\n+    //     z = x.y;\n+    //     f(&x.y);\n+    Projection(Mutability),\n \n     // Consumed as part of an operand\n     Consume,\n@@ -784,3 +817,69 @@ pub enum LvalueContext<'tcx> {\n     StorageLive,\n     StorageDead,\n }\n+\n+impl<'tcx> LvalueContext<'tcx> {\n+    /// Returns true if this lvalue context represents a drop.\n+    pub fn is_drop(&self) -> bool {\n+        match *self {\n+            LvalueContext::Drop => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a storage live or storage dead marker.\n+    pub fn is_storage_marker(&self) -> bool {\n+        match *self {\n+            LvalueContext::StorageLive | LvalueContext::StorageDead => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a storage live marker.\n+    pub fn is_storage_live_marker(&self) -> bool {\n+        match *self {\n+            LvalueContext::StorageLive => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a storage dead marker.\n+    pub fn is_storage_dead_marker(&self) -> bool {\n+        match *self {\n+            LvalueContext::StorageDead => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a use that potentially changes the value.\n+    pub fn is_mutating_use(&self) -> bool {\n+        match *self {\n+            LvalueContext::Store | LvalueContext::Call |\n+            LvalueContext::Borrow { kind: BorrowKind::Mut, .. } |\n+            LvalueContext::Projection(Mutability::Mut) |\n+            LvalueContext::Drop => true,\n+            LvalueContext::Inspect |\n+            LvalueContext::Borrow { kind: BorrowKind::Shared, .. } |\n+            LvalueContext::Borrow { kind: BorrowKind::Unique, .. } |\n+            LvalueContext::Projection(Mutability::Not) | LvalueContext::Consume |\n+            LvalueContext::StorageLive | LvalueContext::StorageDead => false,\n+        }\n+    }\n+\n+    /// Returns true if this lvalue context represents a use that does not change the value.\n+    pub fn is_nonmutating_use(&self) -> bool {\n+        match *self {\n+            LvalueContext::Inspect | LvalueContext::Borrow { kind: BorrowKind::Shared, .. } |\n+            LvalueContext::Borrow { kind: BorrowKind::Unique, .. } |\n+            LvalueContext::Projection(Mutability::Not) | LvalueContext::Consume => true,\n+            LvalueContext::Borrow { kind: BorrowKind::Mut, .. } | LvalueContext::Store |\n+            LvalueContext::Call | LvalueContext::Projection(Mutability::Mut) |\n+            LvalueContext::Drop | LvalueContext::StorageLive | LvalueContext::StorageDead => false,\n+        }\n+    }\n+\n+    pub fn is_use(&self) -> bool {\n+        self.is_mutating_use() || self.is_nonmutating_use()\n+    }\n+}\n+"}, {"sha": "55dda8eda3a4a552e52c9dd33da78d36cdbaadf8", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -455,7 +455,8 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n                                      });\n             }\n             repr::StatementKind::StorageLive(_) |\n-            repr::StatementKind::StorageDead(_) => {}\n+            repr::StatementKind::StorageDead(_) |\n+            repr::StatementKind::Nop => {}\n         }\n     }\n "}, {"sha": "aeb91f06a9aa455947d200861ac94c294adbbee4", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -105,7 +105,8 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 (lvalue, rvalue)\n             }\n             repr::StatementKind::StorageLive(_) |\n-            repr::StatementKind::StorageDead(_) => continue,\n+            repr::StatementKind::StorageDead(_) |\n+            repr::StatementKind::Nop => continue,\n             repr::StatementKind::SetDiscriminant{ .. } =>\n                 span_bug!(stmt.source_info.span,\n                           \"sanity_check should run before Deaggregator inserts SetDiscriminant\"),"}, {"sha": "6346c1e58897e12e62d32e05abc82e3c38c80fc3", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -438,6 +438,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                 span_bug!(stmt.source_info.span,\n                           \"SetDiscriminant should not exist during borrowck\");\n             }\n+            StatementKind::Nop => {}\n         }\n     }\n "}, {"sha": "f26afdc2b857280ae51891af7712098027323db4", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -389,7 +389,8 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n                                        |moi| callback(moi, DropFlagState::Present))\n             }\n             repr::StatementKind::StorageLive(_) |\n-            repr::StatementKind::StorageDead(_) => {}\n+            repr::StatementKind::StorageDead(_) |\n+            repr::StatementKind::Nop => {}\n         },\n         None => {\n             debug!(\"drop_flag_effects: replace {:?}\", block.terminator());"}, {"sha": "55892801247b5459a5420c43fadd2155c7b4510b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -1028,6 +1028,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // No lifetime analysis based on borrowing can be done from here on out.\n         passes.push_pass(box mir::transform::instcombine::InstCombine::new());\n         passes.push_pass(box mir::transform::deaggregator::Deaggregator);\n+        passes.push_pass(box mir::transform::copy_prop::CopyPropagation);\n \n         passes.push_pass(box mir::transform::add_call_guards::AddCallGuards);\n         passes.push_pass(box mir::transform::dump_mir::Marker(\"PreTrans\"));"}, {"sha": "7329a20c497082d431b688aa306f0b3ec50c685f", "filename": "src/librustc_mir/def_use.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdef_use.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -0,0 +1,197 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Def-use analysis.\n+\n+use rustc::mir::repr::{Local, Location, Lvalue, Mir};\n+use rustc::mir::visit::{LvalueContext, MutVisitor, Visitor};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use std::marker::PhantomData;\n+use std::mem;\n+\n+pub struct DefUseAnalysis<'tcx> {\n+    info: IndexVec<Local, Info<'tcx>>,\n+    mir_summary: MirSummary,\n+}\n+\n+#[derive(Clone)]\n+pub struct Info<'tcx> {\n+    pub defs_and_uses: Vec<Use<'tcx>>,\n+}\n+\n+#[derive(Clone)]\n+pub struct Use<'tcx> {\n+    pub context: LvalueContext<'tcx>,\n+    pub location: Location,\n+}\n+\n+impl<'tcx> DefUseAnalysis<'tcx> {\n+    pub fn new(mir: &Mir<'tcx>) -> DefUseAnalysis<'tcx> {\n+        DefUseAnalysis {\n+            info: IndexVec::from_elem_n(Info::new(), mir.count_locals()),\n+            mir_summary: MirSummary::new(mir),\n+        }\n+    }\n+\n+    pub fn analyze(&mut self, mir: &Mir<'tcx>) {\n+        let mut finder = DefUseFinder {\n+            info: mem::replace(&mut self.info, IndexVec::new()),\n+            mir_summary: self.mir_summary,\n+        };\n+        finder.visit_mir(mir);\n+        self.info = finder.info\n+    }\n+\n+    pub fn local_info(&self, local: Local) -> &Info<'tcx> {\n+        &self.info[local]\n+    }\n+\n+    pub fn local_info_mut(&mut self, local: Local) -> &mut Info<'tcx> {\n+        &mut self.info[local]\n+    }\n+\n+    fn mutate_defs_and_uses<F>(&self, local: Local, mir: &mut Mir<'tcx>, mut callback: F)\n+                               where F: for<'a> FnMut(&'a mut Lvalue<'tcx>,\n+                                                      LvalueContext<'tcx>,\n+                                                      Location) {\n+        for lvalue_use in &self.info[local].defs_and_uses {\n+            MutateUseVisitor::new(local,\n+                                  &mut callback,\n+                                  self.mir_summary,\n+                                  mir).visit_location(mir, lvalue_use.location)\n+        }\n+    }\n+\n+    /// FIXME(pcwalton): This should update the def-use chains.\n+    pub fn replace_all_defs_and_uses_with(&self,\n+                                          local: Local,\n+                                          mir: &mut Mir<'tcx>,\n+                                          new_lvalue: Lvalue<'tcx>) {\n+        self.mutate_defs_and_uses(local, mir, |lvalue, _, _| *lvalue = new_lvalue.clone())\n+    }\n+}\n+\n+struct DefUseFinder<'tcx> {\n+    info: IndexVec<Local, Info<'tcx>>,\n+    mir_summary: MirSummary,\n+}\n+\n+impl<'tcx> DefUseFinder<'tcx> {\n+    fn lvalue_mut_info(&mut self, lvalue: &Lvalue<'tcx>) -> Option<&mut Info<'tcx>> {\n+        let info = &mut self.info;\n+        self.mir_summary.local_index(lvalue).map(move |local| &mut info[local])\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for DefUseFinder<'tcx> {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        if let Some(ref mut info) = self.lvalue_mut_info(lvalue) {\n+            info.defs_and_uses.push(Use {\n+                context: context,\n+                location: location,\n+            })\n+        }\n+        self.super_lvalue(lvalue, context, location)\n+    }\n+}\n+\n+impl<'tcx> Info<'tcx> {\n+    fn new() -> Info<'tcx> {\n+        Info {\n+            defs_and_uses: vec![],\n+        }\n+    }\n+\n+    pub fn def_count(&self) -> usize {\n+        self.defs_and_uses.iter().filter(|lvalue_use| lvalue_use.context.is_mutating_use()).count()\n+    }\n+\n+    pub fn def_count_not_including_drop(&self) -> usize {\n+        self.defs_and_uses.iter().filter(|lvalue_use| {\n+            lvalue_use.context.is_mutating_use() && !lvalue_use.context.is_drop()\n+        }).count()\n+    }\n+\n+    pub fn use_count(&self) -> usize {\n+        self.defs_and_uses.iter().filter(|lvalue_use| {\n+            lvalue_use.context.is_nonmutating_use()\n+        }).count()\n+    }\n+}\n+\n+struct MutateUseVisitor<'tcx, F> {\n+    query: Local,\n+    callback: F,\n+    mir_summary: MirSummary,\n+    phantom: PhantomData<&'tcx ()>,\n+}\n+\n+impl<'tcx, F> MutateUseVisitor<'tcx, F> {\n+    fn new(query: Local, callback: F, mir_summary: MirSummary, _: &Mir<'tcx>)\n+           -> MutateUseVisitor<'tcx, F>\n+           where F: for<'a> FnMut(&'a mut Lvalue<'tcx>, LvalueContext<'tcx>, Location) {\n+        MutateUseVisitor {\n+            query: query,\n+            callback: callback,\n+            mir_summary: mir_summary,\n+            phantom: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<'tcx, F> MutVisitor<'tcx> for MutateUseVisitor<'tcx, F>\n+              where F: for<'a> FnMut(&'a mut Lvalue<'tcx>, LvalueContext<'tcx>, Location) {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &mut Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n+        if self.mir_summary.local_index(lvalue) == Some(self.query) {\n+            (self.callback)(lvalue, context, location)\n+        }\n+        self.super_lvalue(lvalue, context, location)\n+    }\n+}\n+\n+/// A small structure that enables various metadata of the MIR to be queried\n+/// without a reference to the MIR itself.\n+#[derive(Clone, Copy)]\n+struct MirSummary {\n+    arg_count: usize,\n+    var_count: usize,\n+    temp_count: usize,\n+}\n+\n+impl MirSummary {\n+    fn new(mir: &Mir) -> MirSummary {\n+        MirSummary {\n+            arg_count: mir.arg_decls.len(),\n+            var_count: mir.var_decls.len(),\n+            temp_count: mir.temp_decls.len(),\n+        }\n+    }\n+\n+    fn local_index<'tcx>(&self, lvalue: &Lvalue<'tcx>) -> Option<Local> {\n+        match *lvalue {\n+            Lvalue::Arg(arg) => Some(Local::new(arg.index())),\n+            Lvalue::Var(var) => Some(Local::new(var.index() + self.arg_count)),\n+            Lvalue::Temp(temp) => {\n+                Some(Local::new(temp.index() + self.arg_count + self.var_count))\n+            }\n+            Lvalue::ReturnPointer => {\n+                Some(Local::new(self.arg_count + self.var_count + self.temp_count))\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+"}, {"sha": "12f1eb8535a3eb7bd27a48a060988b326d3ed06d", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -46,8 +46,10 @@ extern crate rustc_const_eval;\n pub mod diagnostics;\n \n pub mod build;\n+pub mod def_use;\n pub mod graphviz;\n mod hair;\n pub mod mir_map;\n pub mod pretty;\n pub mod transform;\n+"}, {"sha": "33f3d6d8842eae5ccb623f5699a5c063857ea323", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -0,0 +1,180 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Trivial copy propagation pass.\n+//!\n+//! This uses def-use analysis to remove values that have exactly one def and one use, which must\n+//! be an assignment.\n+//!\n+//! To give an example, we look for patterns that look like:\n+//!\n+//!     DEST = SRC\n+//!     ...\n+//!     USE(DEST)\n+//!\n+//! where `DEST` and `SRC` are both locals of some form. We replace that with:\n+//!\n+//!     NOP\n+//!     ...\n+//!     USE(SRC)\n+//!\n+//! The assignment `DEST = SRC` must be (a) the only mutation of `DEST` and (b) the only\n+//! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n+//! future.\n+\n+use def_use::DefUseAnalysis;\n+use rustc::mir::repr::{Local, Lvalue, Mir, Operand, Rvalue, StatementKind};\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n+use rustc::ty::TyCtxt;\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+pub struct CopyPropagation;\n+\n+impl Pass for CopyPropagation {}\n+\n+impl<'tcx> MirPass<'tcx> for CopyPropagation {\n+    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+        loop {\n+            let mut def_use_analysis = DefUseAnalysis::new(mir);\n+            def_use_analysis.analyze(mir);\n+\n+            let mut changed = false;\n+            for dest_local_index in 0..mir.count_locals() {\n+                let dest_local = Local::new(dest_local_index);\n+                debug!(\"Considering destination local: {}\", mir.format_local(dest_local));\n+\n+                let src_local;\n+                let location;\n+                {\n+                    // The destination must have exactly one def.\n+                    let dest_use_info = def_use_analysis.local_info(dest_local);\n+                    let dest_def_count = dest_use_info.def_count_not_including_drop();\n+                    if dest_def_count == 0 {\n+                        debug!(\"  Can't copy-propagate local: dest {} undefined\",\n+                               mir.format_local(dest_local));\n+                        continue\n+                    }\n+                    if dest_def_count > 1 {\n+                        debug!(\"  Can't copy-propagate local: dest {} defined {} times\",\n+                               mir.format_local(dest_local),\n+                               dest_use_info.def_count());\n+                        continue\n+                    }\n+                    if dest_use_info.use_count() == 0 {\n+                        debug!(\"  Can't copy-propagate local: dest {} unused\",\n+                               mir.format_local(dest_local));\n+                        continue\n+                    }\n+                    let dest_lvalue_def = dest_use_info.defs_and_uses.iter().filter(|lvalue_def| {\n+                        lvalue_def.context.is_mutating_use() && !lvalue_def.context.is_drop()\n+                    }).next().unwrap();\n+                    location = dest_lvalue_def.location;\n+\n+                    let basic_block = &mir[location.block];\n+                    let statement_index = location.statement_index;\n+                    let statement = match basic_block.statements.get(statement_index) {\n+                        Some(statement) => statement,\n+                        None => {\n+                            debug!(\"  Can't copy-propagate local: used in terminator\");\n+                            continue\n+                        }\n+                    };\n+\n+                    // That use of the source must be an assignment.\n+                    let src_lvalue = match statement.kind {\n+                        StatementKind::Assign(\n+                                ref dest_lvalue,\n+                                Rvalue::Use(Operand::Consume(ref src_lvalue)))\n+                                if Some(dest_local) == mir.local_index(dest_lvalue) => {\n+                            src_lvalue\n+                        }\n+                        _ => {\n+                            debug!(\"  Can't copy-propagate local: source use is not an \\\n+                                    assignment\");\n+                            continue\n+                        }\n+                    };\n+                    src_local = match mir.local_index(src_lvalue) {\n+                        Some(src_local) => src_local,\n+                        None => {\n+                            debug!(\"  Can't copy-propagate local: source is not a local\");\n+                            continue\n+                        }\n+                    };\n+\n+                    // There must be exactly one use of the source used in a statement (not in a\n+                    // terminator).\n+                    let src_use_info = def_use_analysis.local_info(src_local);\n+                    let src_use_count = src_use_info.use_count();\n+                    if src_use_count == 0 {\n+                        debug!(\"  Can't copy-propagate local: no uses\");\n+                        continue\n+                    }\n+                    if src_use_count != 1 {\n+                        debug!(\"  Can't copy-propagate local: {} uses\", src_use_info.use_count());\n+                        continue\n+                    }\n+\n+                    // Verify that the source doesn't change in between. This is done\n+                    // conservatively for now, by ensuring that the source has exactly one\n+                    // mutation. The goal is to prevent things like:\n+                    //\n+                    //     DEST = SRC;\n+                    //     SRC = X;\n+                    //     USE(DEST);\n+                    //\n+                    // From being misoptimized into:\n+                    //\n+                    //     SRC = X;\n+                    //     USE(SRC);\n+                    let src_def_count = src_use_info.def_count_not_including_drop();\n+                    if src_def_count != 1 {\n+                        debug!(\"  Can't copy-propagate local: {} defs of src\",\n+                               src_use_info.def_count_not_including_drop());\n+                        continue\n+                    }\n+                }\n+\n+                // If all checks passed, then we can eliminate the destination and the assignment.\n+                //\n+                // First, remove all markers.\n+                //\n+                // FIXME(pcwalton): Don't do this. Merge live ranges instead.\n+                debug!(\"  Replacing all uses of {}\", mir.format_local(dest_local));\n+                for lvalue_use in &def_use_analysis.local_info(dest_local).defs_and_uses {\n+                    if lvalue_use.context.is_storage_marker() {\n+                        mir.make_statement_nop(lvalue_use.location)\n+                    }\n+                }\n+                for lvalue_use in &def_use_analysis.local_info(src_local).defs_and_uses {\n+                    if lvalue_use.context.is_storage_marker() {\n+                        mir.make_statement_nop(lvalue_use.location)\n+                    }\n+                }\n+\n+                // Now replace all uses of the destination local with the source local.\n+                let src_lvalue = Lvalue::from_local(mir, src_local);\n+                def_use_analysis.replace_all_defs_and_uses_with(dest_local, mir, src_lvalue);\n+\n+                // Finally, zap the now-useless assignment instruction.\n+                mir.make_statement_nop(location);\n+\n+                changed = true;\n+                // FIXME(pcwalton): Update the use-def chains to delete the instructions instead of\n+                // regenerating the chains.\n+                break\n+            }\n+            if !changed {\n+                break\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "7bcb89b5895e78698dc13eac93643c74ce64fc1b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -19,4 +19,4 @@ pub mod qualify_consts;\n pub mod dump_mir;\n pub mod deaggregator;\n pub mod instcombine;\n-\n+pub mod copy_prop;"}, {"sha": "57de68fce1d1a4543e435b08bf4cc0b847fa00ba", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -328,7 +328,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n     fn visit_lvalue(&mut self,\n                     lvalue: &mut Lvalue<'tcx>,\n-                    context: LvalueContext,\n+                    context: LvalueContext<'tcx>,\n                     location: Location) {\n         if let Lvalue::Temp(ref mut temp) = *lvalue {\n             *temp = self.promote_temp(*temp);"}, {"sha": "c3a22853f84373b7aa484b86a465201ce4159b38", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -475,7 +475,10 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n /// For functions (constant or not), it also records\n /// candidates for promotion in promotion_candidates.\n impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n-    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext, location: Location) {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &Lvalue<'tcx>,\n+                    context: LvalueContext<'tcx>,\n+                    location: Location) {\n         match *lvalue {\n             Lvalue::Arg(_) => {\n                 self.add(Qualif::FN_ARGUMENT);\n@@ -910,7 +913,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n                 StatementKind::SetDiscriminant { .. } |\n                 StatementKind::StorageLive(_) |\n-                StatementKind::StorageDead(_) => {}\n+                StatementKind::StorageDead(_) |\n+                StatementKind::Nop => {}\n             }\n         });\n     }"}, {"sha": "412759cd5b2d3522f01c0ba28f11cb2a962f27a4", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -385,6 +385,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n+            StatementKind::Nop => {}\n         }\n     }\n "}, {"sha": "6648944540e3b3e855038868cddad4cb6500a25e", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -523,7 +523,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n     fn visit_lvalue(&mut self,\n                     lvalue: &mir::Lvalue<'tcx>,\n-                    context: mir_visit::LvalueContext,\n+                    context: mir_visit::LvalueContext<'tcx>,\n                     location: Location) {\n         debug!(\"visiting lvalue {:?}\", *lvalue);\n "}, {"sha": "5de59b9f6bded47cb54591fbbfb25195b4a5b1a5", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -147,7 +147,7 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n \n     fn visit_lvalue(&mut self,\n                     lvalue: &mir::Lvalue<'tcx>,\n-                    context: LvalueContext,\n+                    context: LvalueContext<'tcx>,\n                     location: Location) {\n         debug!(\"visit_lvalue(lvalue={:?}, context={:?})\", lvalue, context);\n \n@@ -180,7 +180,7 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n                 LvalueContext::Store |\n                 LvalueContext::Inspect |\n                 LvalueContext::Borrow { .. } |\n-                LvalueContext::Projection => {\n+                LvalueContext::Projection(..) => {\n                     self.mark_as_lvalue(index);\n                 }\n "}, {"sha": "70d0a61840475e5b90391d1cb89e12a611bbe591", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -292,7 +292,8 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::StatementKind::StorageLive(_) |\n-                    mir::StatementKind::StorageDead(_) => {}\n+                    mir::StatementKind::StorageDead(_) |\n+                    mir::StatementKind::Nop => {}\n                     mir::StatementKind::SetDiscriminant{ .. } => {\n                         span_bug!(span, \"SetDiscriminant should not appear in constants?\");\n                     }"}, {"sha": "325bd655266c122793e0db01de990ffe56243a00", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -78,6 +78,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             mir::StatementKind::StorageDead(ref lvalue) => {\n                 self.trans_storage_liveness(bcx, lvalue, base::Lifetime::End)\n             }\n+            mir::StatementKind::Nop => bcx,\n         }\n     }\n "}, {"sha": "891ca03cc4dd52f4696a2e52660453e71137e1db", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -23,9 +23,9 @@ fn helper(_: usize) {\n pub fn ref_dst(s: &[u8]) {\n     // We used to generate an extra alloca and memcpy to ref the dst, so check that we copy\n     // directly to the alloca for \"x\"\n-// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 0\n+// CHECK: [[X0:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %s, i32 0, i32 0\n // CHECK: store i8* %0, i8** [[X0]]\n-// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %x, i32 0, i32 1\n+// CHECK: [[X1:%[0-9]+]] = getelementptr {{.*}} { i8*, [[USIZE]] }* %s, i32 0, i32 1\n // CHECK: store [[USIZE]] %1, [[USIZE]]* [[X1]]\n \n     let x = &*s;"}, {"sha": "8782dcf8898b7405fd5cb2b7a799ffad4a7e4efb", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c772948b687488a087356cb91432425662e034b9/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c772948b687488a087356cb91432425662e034b9/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=c772948b687488a087356cb91432425662e034b9", "patch": "@@ -21,27 +21,27 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node4.PreTrans.after.mir\n //     bb0: {\n-//         StorageLive(var0);               // scope 0 at storage_ranges.rs:12:9: 12:10\n-//         var0 = const 0i32;               // scope 0 at storage_ranges.rs:12:13: 12:14\n-//         StorageLive(var1);               // scope 1 at storage_ranges.rs:14:13: 14:14\n-//         StorageLive(tmp1);               // scope 1 at storage_ranges.rs:14:18: 14:25\n-//         StorageLive(tmp2);               // scope 1 at storage_ranges.rs:14:23: 14:24\n-//         tmp2 = var0;                     // scope 1 at storage_ranges.rs:14:23: 14:24\n-//         tmp1 = std::option::Option<i32>::Some(tmp2,); // scope 1 at storage_ranges.rs:14:18: 14:25\n-//         var1 = &tmp1;                    // scope 1 at storage_ranges.rs:14:17: 14:25\n-//         StorageDead(tmp2);               // scope 1 at storage_ranges.rs:14:23: 14:24\n-//         tmp0 = ();                       // scope 2 at storage_ranges.rs:13:5: 15:6\n-//         StorageDead(tmp1);               // scope 1 at storage_ranges.rs:14:18: 14:25\n-//         StorageDead(var1);               // scope 1 at storage_ranges.rs:14:13: 14:14\n-//         StorageLive(var2);               // scope 1 at storage_ranges.rs:16:9: 16:10\n-//         var2 = const 1i32;               // scope 1 at storage_ranges.rs:16:13: 16:14\n-//         return = ();                     // scope 3 at storage_ranges.rs:11:11: 17:2\n-//         StorageDead(var2);               // scope 1 at storage_ranges.rs:16:9: 16:10\n-//         StorageDead(var0);               // scope 0 at storage_ranges.rs:12:9: 12:10\n-//         goto -> bb1;                     // scope 0 at storage_ranges.rs:11:1: 17:2\n+//         nop;                             // scope 0 at storage_ranges.rs:14:9: 14:10\n+//         var0 = const 0i32;               // scope 0 at storage_ranges.rs:14:13: 14:14\n+//         StorageLive(var1);               // scope 1 at storage_ranges.rs:16:13: 16:14\n+//         StorageLive(tmp1);               // scope 1 at storage_ranges.rs:16:18: 16:25\n+//         nop;                             // scope 1 at storage_ranges.rs:16:23: 16:24\n+//         nop;                             // scope 1 at storage_ranges.rs:16:23: 16:24\n+//         tmp1 = std::option::Option<i32>::Some(var0,); // scope 1 at storage_ranges.rs:16:18: 16:25\n+//         var1 = &tmp1;                    // scope 1 at storage_ranges.rs:16:17: 16:25\n+//         nop;                             // scope 1 at storage_ranges.rs:16:23: 16:24\n+//         tmp0 = ();                       // scope 2 at storage_ranges.rs:15:5: 17:6\n+//         StorageDead(tmp1);               // scope 1 at storage_ranges.rs:16:18: 16:25\n+//         StorageDead(var1);               // scope 1 at storage_ranges.rs:16:13: 16:14\n+//         StorageLive(var2);               // scope 1 at storage_ranges.rs:18:9: 18:10\n+//         var2 = const 1i32;               // scope 1 at storage_ranges.rs:18:13: 18:14\n+//         return = ();                     // scope 3 at storage_ranges.rs:13:11: 19:2\n+//         StorageDead(var2);               // scope 1 at storage_ranges.rs:18:9: 18:10\n+//         nop;                             // scope 0 at storage_ranges.rs:14:9: 14:10\n+//         goto -> bb1;                     // scope 0 at storage_ranges.rs:13:1: 19:2\n //     }\n //\n //     bb1: {\n-//         return;                          // scope 0 at storage_ranges.rs:11:1: 17:2\n+//         return;                          // scope 0 at storage_ranges.rs:13:1: 19:2\n //     }\n // END rustc.node4.PreTrans.after.mir"}]}