{"sha": "1a385032112dd1a3445dd4d2c848159f2a8315b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMzg1MDMyMTEyZGQxYTM0NDVkZDRkMmM4NDgxNTlmMmE4MzE1Yjg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-08-01T15:14:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-01T15:14:04Z"}, "message": "Merge pull request #1129 from oli-obk/needless_ref\n\nlint on needless ref in patterns", "tree": {"sha": "390ff64a66aa45d385bd85f5db6bdf82300fa94b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/390ff64a66aa45d385bd85f5db6bdf82300fa94b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a385032112dd1a3445dd4d2c848159f2a8315b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a385032112dd1a3445dd4d2c848159f2a8315b8", "html_url": "https://github.com/rust-lang/rust/commit/1a385032112dd1a3445dd4d2c848159f2a8315b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a385032112dd1a3445dd4d2c848159f2a8315b8/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34645322948219d0d05fd26d2a8388b35b128f9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/34645322948219d0d05fd26d2a8388b35b128f9f", "html_url": "https://github.com/rust-lang/rust/commit/34645322948219d0d05fd26d2a8388b35b128f9f"}, {"sha": "81c5757f44a1f9815afb4fb4de49c42c405f8888", "url": "https://api.github.com/repos/rust-lang/rust/commits/81c5757f44a1f9815afb4fb4de49c42c405f8888", "html_url": "https://github.com/rust-lang/rust/commit/81c5757f44a1f9815afb4fb4de49c42c405f8888"}], "stats": {"total": 120, "additions": 69, "deletions": 51}, "files": [{"sha": "f900b6003af68f66b54528ca5c9a4ceb3a815dc7", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -58,7 +58,7 @@ impl LateLintPass for AttrPass {\n             if items.is_empty() || name != &\"deprecated\" {\n                 return;\n             }\n-            for ref item in items {\n+            for item in items {\n                 if let MetaItemKind::NameValue(ref name, ref lit) = item.node {\n                     if name == &\"since\" {\n                         check_semver(cx, item.span, lit);"}, {"sha": "227d38a97fd97e7e767ace033a19e5c703f98282", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -114,7 +114,7 @@ impl LateLintPass for BlockInIfCondition {\n             } else {\n                 let mut visitor = ExVisitor { found_block: None };\n                 walk_expr(&mut visitor, check);\n-                if let Some(ref block) = visitor.found_block {\n+                if let Some(block) = visitor.found_block {\n                     span_help_and_lint(cx, BLOCK_IN_IF_CONDITION_STMT, block.span, COMPLEX_BLOCK_MESSAGE, \"\");\n                 }\n             }"}, {"sha": "fa3e6a15606080c937413bba5881e7d8d6201d61", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -320,7 +320,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     /// A block can only yield a constant if it only has one constant expression\n     fn block(&mut self, block: &Block) -> Option<Constant> {\n         if block.stmts.is_empty() {\n-            block.expr.as_ref().and_then(|ref b| self.expr(b))\n+            block.expr.as_ref().and_then(|b| self.expr(b))\n         } else {\n             None\n         }"}, {"sha": "77771bd0d784c6c0294f1cc16219be5f2beb0847", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -149,7 +149,7 @@ fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref\n                             TypeVariants::TyFnPtr(..) => {\n                                 return;\n                             }\n-                            TypeVariants::TyTuple(ref tys) if tys.len() > 12 => {\n+                            TypeVariants::TyTuple(tys) if tys.len() > 12 => {\n                                 return;\n                             }\n                             _ => (),"}, {"sha": "bc348f220aaabb3ccdf6163e2481aea4401ecf63", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -39,7 +39,7 @@ declare_lint! {\n \n fn is_non_trait_box(ty: ty::Ty) -> bool {\n     match ty.sty {\n-        ty::TyBox(ref inner) => !inner.is_trait(),\n+        ty::TyBox(inner) => !inner.is_trait(),\n         _ => false,\n     }\n }\n@@ -190,7 +190,7 @@ impl<'a, 'tcx: 'a+'gcx, 'gcx: 'a> EscapeDelegate<'a, 'tcx, 'gcx> {\n         // Large types need to be boxed to avoid stack\n         // overflows.\n         match ty.sty {\n-            ty::TyBox(ref inner) => {\n+            ty::TyBox(inner) => {\n                 if let Ok(layout) = inner.layout(self.infcx) {\n                     let size = layout.size(&self.target);\n                     size.bytes() > self.too_large_for_stack"}, {"sha": "d687cb7c1f47760d3483fd1d977729d6c9a4280a", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -73,7 +73,7 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                     }\n                     _ => (),\n                 }\n-                for (ref a1, ref a2) in decl.inputs.iter().zip(args) {\n+                for (a1, a2) in decl.inputs.iter().zip(args) {\n                     if let PatKind::Binding(_, ident, _) = a1.pat.node {\n                         // XXXManishearth Should I be checking the binding mode here?\n                         if let ExprPath(None, ref p) = a2.node {"}, {"sha": "0e32a4059946bc0b44cb34d7012be7c858ae3b4f", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -71,7 +71,7 @@ impl LateLintPass for Functions {\n     fn check_fn(&mut self, cx: &LateContext, kind: intravisit::FnKind, decl: &hir::FnDecl, block: &hir::Block, span: Span, nodeid: ast::NodeId) {\n         use rustc::hir::map::Node::*;\n \n-        let is_impl = if let Some(NodeItem(ref item)) = cx.tcx.map.find(cx.tcx.map.get_parent_node(nodeid)) {\n+        let is_impl = if let Some(NodeItem(item)) = cx.tcx.map.find(cx.tcx.map.get_parent_node(nodeid)) {\n             matches!(item.node, hir::ItemImpl(_, _, _, Some(_), _, _) | hir::ItemDefaultImpl(..))\n         } else {\n             false"}, {"sha": "c8f792b6d5f52dc3a5ead66359949e8bc560ce0e", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -203,8 +203,8 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n               .map_or(false, |ids| ids.iter().any(|i| is_is_empty(cx, i)))\n         }\n         ty::TyProjection(_) => ty.ty_to_def_id().map_or(false, |id| has_is_empty_impl(cx, &id)),\n-        ty::TyEnum(ref id, _) |\n-        ty::TyStruct(ref id, _) => has_is_empty_impl(cx, &id.did),\n+        ty::TyEnum(id, _) |\n+        ty::TyStruct(id, _) => has_is_empty_impl(cx, &id.did),\n         ty::TyArray(..) | ty::TyStr => true,\n         _ => false,\n     }"}, {"sha": "f5b1982dd1ce1d1ccd0c351616a688c4ce9c2490", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -60,7 +60,7 @@ impl LintPass for LetIfSeq {\n impl LateLintPass for LetIfSeq {\n     fn check_block(&mut self, cx: &LateContext, block: &hir::Block) {\n         let mut it = block.stmts.iter().peekable();\n-        while let Some(ref stmt) = it.next() {\n+        while let Some(stmt) = it.next() {\n             if_let_chain! {[\n                 let Some(expr) = it.peek(),\n                 let hir::StmtDecl(ref decl, _) = stmt.node,"}, {"sha": "7308a656590399934e119baeb73d91c3f68bd462", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -138,7 +138,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         Ok(file_name) => {\n             // if the user specified a file, it must exist, otherwise default to `clippy.toml` but\n             // do not require the file to exist\n-            let (ref file_name, must_exist) = if let Some(ref file_name) = file_name {\n+            let (file_name, must_exist) = if let Some(ref file_name) = file_name {\n                 (&**file_name, true)\n             } else {\n                 (\"clippy.toml\", false)"}, {"sha": "822f48b77f5536d72ccf5b1d20465ecfe959bf63", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -391,7 +391,7 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n /// Check for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n-    if let Some(higher::Range { start: Some(ref start), ref end, limits }) = higher::range(arg) {\n+    if let Some(higher::Range { start: Some(start), ref end, limits }) = higher::range(arg) {\n         // the var must be a single name\n         if let PatKind::Binding(_, ref ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n@@ -425,7 +425,7 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                     format!(\".skip({})\", snippet(cx, start.span, \"..\"))\n                 };\n \n-                let take = if let Some(ref end) = *end {\n+                let take = if let Some(end) = *end {\n                     if is_len_call(end, &indexed) {\n                         \"\".to_owned()\n                     } else {\n@@ -494,7 +494,7 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n \n fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     // if this for loop is iterating over a two-sided range...\n-    if let Some(higher::Range { start: Some(ref start), end: Some(ref end), limits }) = higher::range(arg) {\n+    if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(arg) {\n         // ...and both sides are compile-time constant integers...\n         if let Ok(start_idx) = eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None) {\n             if let Ok(end_idx) = eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None) {\n@@ -873,7 +873,7 @@ fn is_break_expr(expr: &Expr) -> bool {\n         ExprBreak(None) => true,\n         ExprBlock(ref b) => {\n             match extract_first_expr(b) {\n-                Some(ref subexpr) => is_break_expr(subexpr),\n+                Some(subexpr) => is_break_expr(subexpr),\n                 None => false,\n             }\n         }"}, {"sha": "820223a435026b2d642a619b50d8bd3ce062d97c", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -262,7 +262,7 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n                     None\n                 };\n \n-                if let Some((ref true_expr, ref false_expr)) = exprs {\n+                if let Some((true_expr, false_expr)) = exprs {\n                     let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n                         (false, false) => {\n                             Some(format!(\"if {} {} else {}\","}, {"sha": "1724d2999fb6b0a3af575c25f8609998e166e4d3", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -674,7 +674,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr) {\n \n /// Checks for the `CLONE_DOUBLE_REF` lint.\n fn lint_clone_double_ref(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, ty: ty::Ty) {\n-    if let ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) = ty.sty {\n+    if let ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) = ty.sty {\n         if let ty::TyRef(..) = inner.sty {\n             span_lint_and_then(cx,\n                                CLONE_DOUBLE_REF,\n@@ -694,7 +694,7 @@ fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &MethodArgs) {\n         return;\n     }\n     let arg_ty = cx.tcx.expr_ty(&args[1]);\n-    if let Some(slice) = derefs_to_slice(cx, &args[1], &arg_ty) {\n+    if let Some(slice) = derefs_to_slice(cx, &args[1], arg_ty) {\n         span_lint_and_then(cx, EXTEND_FROM_SLICE, expr.span, \"use of `extend` to extend a Vec by a slice\", |db| {\n             db.span_suggestion(expr.span,\n                                \"try this\",\n@@ -725,7 +725,7 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n // Type of MethodArgs is potentially a Vec\n fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &MethodArgs, is_mut: bool){\n     let mut_str = if is_mut { \"_mut\" } else {\"\"};\n-    let caller_type = if let Some(_) = derefs_to_slice(cx, &iter_args[0], &cx.tcx.expr_ty(&iter_args[0])) {\n+    let caller_type = if let Some(_) = derefs_to_slice(cx, &iter_args[0], cx.tcx.expr_ty(&iter_args[0])) {\n         \"slice\"\n     }\n     else if match_type(cx, cx.tcx.expr_ty(&iter_args[0]), &paths::VEC) {\n@@ -747,20 +747,20 @@ fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &MethodArgs, is_\n     );\n }\n \n-fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: &ty::Ty) -> Option<sugg::Sugg<'static>> {\n-    fn may_slice(cx: &LateContext, ty: &ty::Ty) -> bool {\n+fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sugg::Sugg<'static>> {\n+    fn may_slice(cx: &LateContext, ty: ty::Ty) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n             ty::TyStruct(..) => match_type(cx, ty, &paths::VEC),\n             ty::TyArray(_, size) => size < 32,\n-            ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) |\n-            ty::TyBox(ref inner) => may_slice(cx, inner),\n+            ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) |\n+            ty::TyBox(inner) => may_slice(cx, inner),\n             _ => false,\n         }\n     }\n \n     if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n-        if &name.node.as_str() == &\"iter\" && may_slice(cx, &cx.tcx.expr_ty(&args[0])) {\n+        if &name.node.as_str() == &\"iter\" && may_slice(cx, cx.tcx.expr_ty(&args[0])) {\n             sugg::Sugg::hir_opt(cx, &*args[0]).map(|sugg| {\n                 sugg.addr()\n             })\n@@ -770,8 +770,8 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: &ty::Ty) -> Option<su\n     } else {\n         match ty.sty {\n             ty::TySlice(_) => sugg::Sugg::hir_opt(cx, expr),\n-            ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) |\n-            ty::TyBox(ref inner) => {\n+            ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) |\n+            ty::TyBox(inner) => {\n                 if may_slice(cx, inner) {\n                     sugg::Sugg::hir_opt(cx, expr)\n                 } else {"}, {"sha": "45ce71426dd774393588e2aa06272c533b523fa1", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -55,7 +55,7 @@ impl LateLintPass for TopLevelRefPass {\n             // Does not apply to closures\n             return;\n         }\n-        for ref arg in &decl.inputs {\n+        for arg in &decl.inputs {\n             if let PatKind::Binding(BindByRef(_), _, _) = arg.pat.node {\n                 span_lint(cx,\n                           TOPLEVEL_REF_ARG,\n@@ -464,7 +464,7 @@ impl LateLintPass for UsedUnderscoreBinding {\n /// Heuristic to see if an expression is used. Should be compatible with `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n-    if let Some(ref parent) = get_parent_expr(cx, expr) {\n+    if let Some(parent) = get_parent_expr(cx, expr) {\n         match parent.node {\n             ExprAssign(_, ref rhs) |\n             ExprAssignOp(_, _, ref rhs) => **rhs == *expr,"}, {"sha": "a8127ef88afeafe0e348ce6a010602fda97273c0", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -130,7 +130,7 @@ impl EarlyLintPass for MiscEarly {\n     fn check_fn(&mut self, cx: &EarlyContext, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n         let mut registered_names: HashMap<String, Span> = HashMap::new();\n \n-        for ref arg in &decl.inputs {\n+        for arg in &decl.inputs {\n             if let PatKind::Ident(_, sp_ident, None) = arg.pat.node {\n                 let arg_name = sp_ident.node.to_string();\n "}, {"sha": "5683a269cfe8a97ed3abb7775504a6b4d42a05b7", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -59,8 +59,8 @@ impl LateLintPass for UnnecessaryMutPassed {\n \n fn check_arguments(cx: &LateContext, arguments: &[P<Expr>], type_definition: &TyS, name: &str) {\n     match type_definition.sty {\n-        TypeVariants::TyFnDef(_, _, ref fn_type) |\n-        TypeVariants::TyFnPtr(ref fn_type) => {\n+        TypeVariants::TyFnDef(_, _, fn_type) |\n+        TypeVariants::TyFnPtr(fn_type) => {\n             let parameters = &fn_type.sig.skip_binder().inputs;\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {"}, {"sha": "ab87201d230fc9e42fc783ae46d69723f04cd78e", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -3,7 +3,7 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n-use rustc::hir::{ExprAddrOf, Expr, MutImmutable};\n+use rustc::hir::{ExprAddrOf, Expr, MutImmutable, Pat, PatKind, BindingMode};\n use rustc::ty::TyRef;\n use utils::{span_lint, in_macro};\n use rustc::ty::adjustment::AutoAdjustment::AdjustDerefRef;\n@@ -53,4 +53,21 @@ impl LateLintPass for NeedlessBorrow {\n             }\n         }\n     }\n+    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n+        if in_macro(cx, pat.span) {\n+            return;\n+        }\n+        if let PatKind::Binding(BindingMode::BindByRef(MutImmutable), _, _) = pat.node {\n+            if let TyRef(_, ref tam) = cx.tcx.pat_ty(pat).sty {\n+                if tam.mutbl == MutImmutable {\n+                    if let TyRef(..) = tam.ty.sty {\n+                        span_lint(cx,\n+                                  NEEDLESS_BORROW,\n+                                  pat.span,\n+                                  \"this pattern creates a reference to a reference\")\n+                    }\n+                }\n+            }\n+        }\n+    }\n }"}, {"sha": "88e25c819bc8419856e16d65db722ad6d872590d", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -95,7 +95,7 @@ impl LateLintPass for NewWithoutDefault {\n             return;\n         }\n \n-        if let FnKind::Method(name, ref sig, _, _) = kind {\n+        if let FnKind::Method(name, sig, _, _) = kind {\n             if sig.constness == hir::Constness::Const {\n                 // can't be implemented by default\n                 return;\n@@ -147,7 +147,7 @@ impl LateLintPass for NewWithoutDefault {\n \n fn can_derive_default<'t, 'c>(ty: ty::Ty<'t>, cx: &LateContext<'c, 't>, default_trait_id: DefId) -> bool {\n     match ty.sty {\n-        ty::TyStruct(ref adt_def, ref substs) => {\n+        ty::TyStruct(adt_def, substs) => {\n             for field in adt_def.all_fields() {\n                 let f_ty = field.ty(cx.tcx, substs);\n                 if !implements_trait(cx, f_ty, default_trait_id, Vec::new()) {"}, {"sha": "6ea4557564a0a16fc74d4cdfe06e7a272c185a4a", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -161,12 +161,12 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n             }\n         }\n         PatKind::Struct(_, ref pfields, _) => {\n-            if let Some(ref init_struct) = *init {\n+            if let Some(init_struct) = *init {\n                 if let ExprStruct(_, ref efields, _) = init_struct.node {\n                     for field in pfields {\n                         let name = field.node.name;\n                         let efield = efields.iter()\n-                                            .find(|ref f| f.name.node == name)\n+                                            .find(|f| f.name.node == name)\n                                             .map(|f| &*f.expr);\n                         check_pat(cx, &field.node.pat, &efield, span, bindings);\n                     }\n@@ -182,7 +182,7 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n             }\n         }\n         PatKind::Tuple(ref inner, _) => {\n-            if let Some(ref init_tup) = *init {\n+            if let Some(init_tup) = *init {\n                 if let ExprTup(ref tup) = init_tup.node {\n                     for (i, p) in inner.iter().enumerate() {\n                         check_pat(cx, p, &Some(&tup[i]), p.span, bindings);\n@@ -199,7 +199,7 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n             }\n         }\n         PatKind::Box(ref inner) => {\n-            if let Some(ref initp) = *init {\n+            if let Some(initp) = *init {\n                 if let ExprBox(ref inner_init) = initp.node {\n                     check_pat(cx, inner, &Some(&**inner_init), span, bindings);\n                 } else {\n@@ -276,7 +276,7 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n         // ExprCall\n         // ExprMethodCall\n         ExprVec(ref v) | ExprTup(ref v) => {\n-            for ref e in v {\n+            for e in v {\n                 check_expr(cx, e, bindings)\n             }\n         }\n@@ -294,8 +294,8 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n         ExprMatch(ref init, ref arms, _) => {\n             check_expr(cx, init, bindings);\n             let len = bindings.len();\n-            for ref arm in arms {\n-                for ref pat in &arm.pats {\n+            for arm in arms {\n+                for pat in &arm.pats {\n                     check_pat(cx, pat, &Some(&**init), pat.span, bindings);\n                     // This is ugly, but needed to get the right type\n                     if let Some(ref guard) = arm.guard {\n@@ -321,7 +321,7 @@ fn check_ty(cx: &LateContext, ty: &Ty, bindings: &mut Vec<(Name, Span)>) {\n         TyPtr(MutTy { ty: ref mty, .. }) |\n         TyRptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n         TyTup(ref tup) => {\n-            for ref t in tup {\n+            for t in tup {\n                 check_ty(cx, t, bindings)\n             }\n         }\n@@ -335,7 +335,7 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n         ExprBox(ref inner) |\n         ExprAddrOf(_, ref inner) => is_self_shadow(name, inner),\n         ExprBlock(ref block) => {\n-            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |ref e| is_self_shadow(name, e))\n+            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |e| is_self_shadow(name, e))\n         }\n         ExprUnary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n         ExprPath(_, ref path) => path_eq_name(name, path),"}, {"sha": "2403d20ef7de826a6d4d3c44fc11309923acb175", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -82,7 +82,7 @@ impl LateLintPass for StringAdd {\n                     // the string_add_assign is allow, so no duplicates\n                 } else {\n                     let parent = get_parent_expr(cx, e);\n-                    if let Some(ref p) = parent {\n+                    if let Some(p) = parent {\n                         if let ExprAssign(ref target, _) = p.node {\n                             // avoid duplicate matches\n                             if SpanlessEq::new(cx).eq_expr(target, left) {"}, {"sha": "2bea1d3840c2ef1098c34e1a3043a53a0c577ac2", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -55,7 +55,7 @@ impl fmt::Display for Error {\n \n                 Ok(())\n             }\n-            Error::Type(ref key, ref expected, ref got) => {\n+            Error::Type(key, expected, got) => {\n                 write!(f, \"`{}` is expected to be a `{}` but is a `{}`\", key, expected, got)\n             }\n             Error::UnknownKey(ref key) => write!(f, \"unknown key `{}`\", key),"}, {"sha": "744fc9289dc3b12baa93d817b519b52c9a9f82d7", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -154,8 +154,8 @@ pub fn match_def_path(cx: &LateContext, def_id: DefId, path: &[&str]) -> bool {\n /// Check if type is struct or enum type with given def path.\n pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n     match ty.sty {\n-        ty::TyEnum(ref adt, _) |\n-        ty::TyStruct(ref adt, _) => match_def_path(cx, adt.did, path),\n+        ty::TyEnum(adt, _) |\n+        ty::TyStruct(adt, _) => match_def_path(cx, adt.did, path),\n         _ => false,\n     }\n }\n@@ -427,7 +427,7 @@ pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c\n                             .and_then(|enclosing_id| map.find(enclosing_id));\n     if let Some(node) = enclosing_node {\n         match node {\n-            Node::NodeBlock(ref block) => Some(block),\n+            Node::NodeBlock(block) => Some(block),\n             Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, ref block), .. }) => Some(block),\n             _ => None,\n         }\n@@ -719,8 +719,8 @@ pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: ty::Ty<'tcx>, b: ty::Ty\n /// Return whether the given type is an `unsafe` function.\n pub fn type_is_unsafe_function(ty: ty::Ty) -> bool {\n     match ty.sty {\n-        ty::TyFnDef(_, _, ref f) |\n-        ty::TyFnPtr(ref f) => f.unsafety == Unsafety::Unsafe,\n+        ty::TyFnDef(_, _, f) |\n+        ty::TyFnPtr(f) => f.unsafety == Unsafety::Unsafe,\n         _ => false,\n     }\n }"}, {"sha": "0b615838a9ecba4a2ebbd4ac0fe2a1bcacf09679", "filename": "tests/compile-fail/needless_borrow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a385032112dd1a3445dd4d2c848159f2a8315b8/tests%2Fcompile-fail%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a385032112dd1a3445dd4d2c848159f2a8315b8/tests%2Fcompile-fail%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fneedless_borrow.rs?ref=1a385032112dd1a3445dd4d2c848159f2a8315b8", "patch": "@@ -17,6 +17,7 @@ fn main() {\n     let vec = Vec::new();\n     let vec_val = g(&vec); // should not error, because `&Vec<T>` derefs to `&[T]`\n     h(&\"foo\"); // should not error, because the `&&str` is required, due to `&Trait`\n+    if let Some(ref cake) = Some(&5) {} //~ ERROR: this pattern creates a reference to a reference\n }\n \n fn f<T:Copy>(y: &T) -> T {"}]}