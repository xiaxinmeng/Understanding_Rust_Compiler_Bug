{"sha": "a3bc0e752fad96f537b73f4e9bc805a73d404f7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYmMwZTc1MmZhZDk2ZjUzN2I3M2Y0ZTliYzgwNWE3M2Q0MDRmN2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-20T04:15:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-20T04:15:43Z"}, "message": "Auto merge of #75346 - davidtwco:issue-69925-polymorphic-instancedef-fnptrshim, r=nikomatsakis\n\nshim: monomorphic `FnPtrShim`s during construction\n\nFixes #69925.\n\nThis PR adjusts MIR shim construction so that substitutions are applied to function pointer shims during construction, rather than during codegen (as determined by `substs_for_mir_body`).\n\nr? `@eddyb`", "tree": {"sha": "0c1e237df2c2e814a31fcc81c8c81cdbcdafc69a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c1e237df2c2e814a31fcc81c8c81cdbcdafc69a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3bc0e752fad96f537b73f4e9bc805a73d404f7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3bc0e752fad96f537b73f4e9bc805a73d404f7b", "html_url": "https://github.com/rust-lang/rust/commit/a3bc0e752fad96f537b73f4e9bc805a73d404f7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3bc0e752fad96f537b73f4e9bc805a73d404f7b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "255a4c58f5863ed41c2e68792799125c6c676575", "url": "https://api.github.com/repos/rust-lang/rust/commits/255a4c58f5863ed41c2e68792799125c6c676575", "html_url": "https://github.com/rust-lang/rust/commit/255a4c58f5863ed41c2e68792799125c6c676575"}, {"sha": "f8376b59d1391a5191a561c44067355f1a99c7c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8376b59d1391a5191a561c44067355f1a99c7c0", "html_url": "https://github.com/rust-lang/rust/commit/f8376b59d1391a5191a561c44067355f1a99c7c0"}], "stats": {"total": 117, "additions": 58, "deletions": 59}, "files": [{"sha": "a6b62097d5b18d8d3baf764192ef081b968c9da2", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a3bc0e752fad96f537b73f4e9bc805a73d404f7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3bc0e752fad96f537b73f4e9bc805a73d404f7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=a3bc0e752fad96f537b73f4e9bc805a73d404f7b", "patch": "@@ -62,10 +62,6 @@ pub enum InstanceDef<'tcx> {\n     /// `<fn() as FnTrait>::call_*` (generated `FnTrait` implementation for `fn()` pointers).\n     ///\n     /// `DefId` is `FnTrait::call_*`.\n-    ///\n-    /// NB: the (`fn` pointer) type must currently be monomorphic to avoid double substitution\n-    /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n-    // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     FnPtrShim(DefId, Ty<'tcx>),\n \n     /// Dynamic dispatch to `<dyn Trait as Trait>::fn`.\n@@ -87,10 +83,6 @@ pub enum InstanceDef<'tcx> {\n     /// The `DefId` is for `core::ptr::drop_in_place`.\n     /// The `Option<Ty<'tcx>>` is either `Some(T)`, or `None` for empty drop\n     /// glue.\n-    ///\n-    /// NB: the type must currently be monomorphic to avoid double substitution\n-    /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n-    // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     DropGlue(DefId, Option<Ty<'tcx>>),\n \n     /// Compiler-generated `<T as Clone>::clone` implementation.\n@@ -99,10 +91,6 @@ pub enum InstanceDef<'tcx> {\n     /// Additionally, arrays, tuples, and closures get a `Clone` shim even if they aren't `Copy`.\n     ///\n     /// The `DefId` is for `Clone::clone`, the `Ty` is the type `T` with the builtin `Clone` impl.\n-    ///\n-    /// NB: the type must currently be monomorphic to avoid double substitution\n-    /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n-    // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     CloneShim(DefId, Ty<'tcx>),\n }\n \n@@ -243,6 +231,27 @@ impl<'tcx> InstanceDef<'tcx> {\n             _ => false,\n         }\n     }\n+\n+    /// Returns `true` when the MIR body associated with this instance should be monomorphized\n+    /// by its users (e.g. codegen or miri) by substituting the `substs` from `Instance` (see\n+    /// `Instance::substs_for_mir_body`).\n+    ///\n+    /// Otherwise, returns `false` only for some kinds of shims where the construction of the MIR\n+    /// body should perform necessary substitutions.\n+    pub fn has_polymorphic_mir_body(&self) -> bool {\n+        match *self {\n+            InstanceDef::CloneShim(..)\n+            | InstanceDef::FnPtrShim(..)\n+            | InstanceDef::DropGlue(_, Some(_)) => false,\n+            InstanceDef::ClosureOnceShim { .. }\n+            | InstanceDef::DropGlue(..)\n+            | InstanceDef::Item(_)\n+            | InstanceDef::Intrinsic(..)\n+            | InstanceDef::ReifyShim(..)\n+            | InstanceDef::Virtual(..)\n+            | InstanceDef::VtableShim(..) => true,\n+        }\n+    }\n }\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n@@ -440,30 +449,18 @@ impl<'tcx> Instance<'tcx> {\n         Instance { def, substs }\n     }\n \n-    /// FIXME(#69925) Depending on the kind of `InstanceDef`, the MIR body associated with an\n+    /// Depending on the kind of `InstanceDef`, the MIR body associated with an\n     /// instance is expressed in terms of the generic parameters of `self.def_id()`, and in other\n     /// cases the MIR body is expressed in terms of the types found in the substitution array.\n     /// In the former case, we want to substitute those generic types and replace them with the\n     /// values from the substs when monomorphizing the function body. But in the latter case, we\n     /// don't want to do that substitution, since it has already been done effectively.\n     ///\n-    /// This function returns `Some(substs)` in the former case and None otherwise -- i.e., if\n+    /// This function returns `Some(substs)` in the former case and `None` otherwise -- i.e., if\n     /// this function returns `None`, then the MIR body does not require substitution during\n-    /// monomorphization.\n+    /// codegen.\n     pub fn substs_for_mir_body(&self) -> Option<SubstsRef<'tcx>> {\n-        match self.def {\n-            InstanceDef::CloneShim(..)\n-            | InstanceDef::DropGlue(_, Some(_)) => None,\n-            InstanceDef::ClosureOnceShim { .. }\n-            | InstanceDef::DropGlue(..)\n-            // FIXME(#69925): `FnPtrShim` should be in the other branch.\n-            | InstanceDef::FnPtrShim(..)\n-            | InstanceDef::Item(_)\n-            | InstanceDef::Intrinsic(..)\n-            | InstanceDef::ReifyShim(..)\n-            | InstanceDef::Virtual(..)\n-            | InstanceDef::VtableShim(..) => Some(self.substs),\n-        }\n+        if self.def.has_polymorphic_mir_body() { Some(self.substs) } else { None }\n     }\n \n     /// Returns a new `Instance` where generic parameters in `instance.substs` are replaced by"}, {"sha": "7e4d189f0b73785bfe34fb18dabdd9ec7e5169f3", "filename": "compiler/rustc_mir/src/shim.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a3bc0e752fad96f537b73f4e9bc805a73d404f7b/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3bc0e752fad96f537b73f4e9bc805a73d404f7b/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fshim.rs?ref=a3bc0e752fad96f537b73f4e9bc805a73d404f7b", "patch": "@@ -33,7 +33,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n     let mut result = match instance {\n         ty::InstanceDef::Item(..) => bug!(\"item {:?} passed to make_shim\", instance),\n         ty::InstanceDef::VtableShim(def_id) => {\n-            build_call_shim(tcx, instance, Some(Adjustment::Deref), CallKind::Direct(def_id), None)\n+            build_call_shim(tcx, instance, Some(Adjustment::Deref), CallKind::Direct(def_id))\n         }\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n@@ -42,24 +42,16 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n                 Some(ty::ClosureKind::FnMut | ty::ClosureKind::Fn) => Adjustment::Deref,\n                 None => bug!(\"fn pointer {:?} is not an fn\", ty),\n             };\n-            // HACK: we need the \"real\" argument types for the MIR,\n-            // but because our substs are (Self, Args), where Args\n-            // is a tuple, we must include the *concrete* argument\n-            // types in the MIR. They will be substituted again with\n-            // the param-substs, but because they are concrete, this\n-            // will not do any harm.\n-            let sig = tcx.erase_late_bound_regions(&ty.fn_sig(tcx));\n-            let arg_tys = sig.inputs();\n-\n-            build_call_shim(tcx, instance, Some(adjustment), CallKind::Indirect(ty), Some(arg_tys))\n+\n+            build_call_shim(tcx, instance, Some(adjustment), CallKind::Indirect(ty))\n         }\n         // We are generating a call back to our def-id, which the\n         // codegen backend knows to turn to an actual call, be it\n         // a virtual call, or a direct call to a function for which\n         // indirect calls must be codegen'd differently than direct ones\n         // (such as `#[track_caller]`).\n         ty::InstanceDef::ReifyShim(def_id) => {\n-            build_call_shim(tcx, instance, None, CallKind::Direct(def_id), None)\n+            build_call_shim(tcx, instance, None, CallKind::Direct(def_id))\n         }\n         ty::InstanceDef::ClosureOnceShim { call_once: _ } => {\n             let fn_mut = tcx.require_lang_item(LangItem::FnMut, None);\n@@ -70,13 +62,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n                 .unwrap()\n                 .def_id;\n \n-            build_call_shim(\n-                tcx,\n-                instance,\n-                Some(Adjustment::RefMut),\n-                CallKind::Direct(call_mut),\n-                None,\n-            )\n+            build_call_shim(tcx, instance, Some(Adjustment::RefMut), CallKind::Direct(call_mut))\n         }\n         ty::InstanceDef::DropGlue(def_id, ty) => build_drop_shim(tcx, def_id, ty),\n         ty::InstanceDef::CloneShim(def_id, ty) => build_clone_shim(tcx, def_id, ty),\n@@ -641,29 +627,45 @@ impl CloneShimBuilder<'tcx> {\n     }\n }\n \n-/// Builds a \"call\" shim for `instance`. The shim calls the\n-/// function specified by `call_kind`, first adjusting its first\n-/// argument according to `rcvr_adjustment`.\n-///\n-/// If `untuple_args` is a vec of types, the second argument of the\n-/// function will be untupled as these types.\n+/// Builds a \"call\" shim for `instance`. The shim calls the function specified by `call_kind`,\n+/// first adjusting its first argument according to `rcvr_adjustment`.\n fn build_call_shim<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: ty::InstanceDef<'tcx>,\n     rcvr_adjustment: Option<Adjustment>,\n     call_kind: CallKind<'tcx>,\n-    untuple_args: Option<&[Ty<'tcx>]>,\n ) -> Body<'tcx> {\n     debug!(\n-        \"build_call_shim(instance={:?}, rcvr_adjustment={:?}, \\\n-            call_kind={:?}, untuple_args={:?})\",\n-        instance, rcvr_adjustment, call_kind, untuple_args\n+        \"build_call_shim(instance={:?}, rcvr_adjustment={:?}, call_kind={:?})\",\n+        instance, rcvr_adjustment, call_kind\n     );\n \n+    // `FnPtrShim` contains the fn pointer type that a call shim is being built for - this is used\n+    // to substitute into the signature of the shim. It is not necessary for users of this\n+    // MIR body to perform further substitutions (see `InstanceDef::has_polymorphic_mir_body`).\n+    let (sig_substs, untuple_args) = if let ty::InstanceDef::FnPtrShim(_, ty) = instance {\n+        let sig = tcx.erase_late_bound_regions(&ty.fn_sig(tcx));\n+\n+        let untuple_args = sig.inputs();\n+\n+        // Create substitutions for the `Self` and `Args` generic parameters of the shim body.\n+        let arg_tup = tcx.mk_tup(untuple_args.iter());\n+        let sig_substs = tcx.mk_substs_trait(ty, &[ty::subst::GenericArg::from(arg_tup)]);\n+\n+        (Some(sig_substs), Some(untuple_args))\n+    } else {\n+        (None, None)\n+    };\n+\n     let def_id = instance.def_id();\n     let sig = tcx.fn_sig(def_id);\n     let mut sig = tcx.erase_late_bound_regions(&sig);\n \n+    assert_eq!(sig_substs.is_some(), !instance.has_polymorphic_mir_body());\n+    if let Some(sig_substs) = sig_substs {\n+        sig = sig.subst(tcx, sig_substs);\n+    }\n+\n     if let CallKind::Indirect(fnty) = call_kind {\n         // `sig` determines our local decls, and thus the callee type in the `Call` terminator. This\n         // can only be an `FnDef` or `FnPtr`, but currently will be `Self` since the types come from"}, {"sha": "bcc6042f2fb622b8caddad6ae18151a7aa6aa825", "filename": "src/test/mir-opt/fn_ptr_shim.core.ops-function-Fn-call.AddMovesForPackedDrops.before.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3bc0e752fad96f537b73f4e9bc805a73d404f7b/src%2Ftest%2Fmir-opt%2Ffn_ptr_shim.core.ops-function-Fn-call.AddMovesForPackedDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/a3bc0e752fad96f537b73f4e9bc805a73d404f7b/src%2Ftest%2Fmir-opt%2Ffn_ptr_shim.core.ops-function-Fn-call.AddMovesForPackedDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Ffn_ptr_shim.core.ops-function-Fn-call.AddMovesForPackedDrops.before.mir?ref=a3bc0e752fad96f537b73f4e9bc805a73d404f7b", "patch": "@@ -1,7 +1,7 @@\n // MIR for `std::ops::Fn::call` before AddMovesForPackedDrops\n \n-fn std::ops::Fn::call(_1: *const fn(), _2: Args) -> <Self as FnOnce<Args>>::Output {\n-    let mut _0: <Self as std::ops::FnOnce<Args>>::Output; // return place in scope 0 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n+fn std::ops::Fn::call(_1: *const fn(), _2: ()) -> <fn() as FnOnce<()>>::Output {\n+    let mut _0: <fn() as std::ops::FnOnce<()>>::Output; // return place in scope 0 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n \n     bb0: {\n         _0 = move (*_1)() -> bb1;        // scope 0 at $SRC_DIR/core/src/ops/function.rs:LL:COL"}]}