{"sha": "c1f7e922e6e082d3f58db4a69fdf821e93ffa665", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZjdlOTIyZTZlMDgyZDNmNThkYjRhNjlmZGY4MjFlOTNmZmE2NjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-10-10T03:18:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-10-10T06:35:45Z"}, "message": "std: Synchronize global allocator on wasm32\n\nWe originally didn't have threads, and now we're starting to add them!\nMake sure we properly synchronize access to dlmalloc when the `atomics`\nfeature is enabled for `wasm32-unknown-unknown`.", "tree": {"sha": "ea9d965a6caf7b5afb25118ebf16b901695b2715", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea9d965a6caf7b5afb25118ebf16b901695b2715"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1f7e922e6e082d3f58db4a69fdf821e93ffa665", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1f7e922e6e082d3f58db4a69fdf821e93ffa665", "html_url": "https://github.com/rust-lang/rust/commit/c1f7e922e6e082d3f58db4a69fdf821e93ffa665", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1f7e922e6e082d3f58db4a69fdf821e93ffa665/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eae47a40484a085f699c3175d51e74901c607e65", "url": "https://api.github.com/repos/rust-lang/rust/commits/eae47a40484a085f699c3175d51e74901c607e65", "html_url": "https://github.com/rust-lang/rust/commit/eae47a40484a085f699c3175d51e74901c607e65"}], "stats": {"total": 53, "additions": 52, "deletions": 1}, "files": [{"sha": "15283036bb49522d35aec181804831dba3fb4dce", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c1f7e922e6e082d3f58db4a69fdf821e93ffa665/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1f7e922e6e082d3f58db4a69fdf821e93ffa665/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=c1f7e922e6e082d3f58db4a69fdf821e93ffa665", "patch": "@@ -20,6 +20,10 @@\n #![feature(nll)]\n #![feature(staged_api)]\n #![feature(rustc_attrs)]\n+#![cfg_attr(\n+    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+    feature(integer_atomics, stdsimd)\n+)]\n #![cfg_attr(any(unix, target_os = \"cloudabi\", target_os = \"redox\"), feature(libc))]\n #![rustc_alloc_kind = \"lib\"]\n \n@@ -331,29 +335,76 @@ mod platform {\n     use core::alloc::{GlobalAlloc, Layout};\n     use System;\n \n-    // No need for synchronization here as wasm is currently single-threaded\n     static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n \n     #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n         unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            let _lock = lock::lock();\n             DLMALLOC.malloc(layout.size(), layout.align())\n         }\n \n         #[inline]\n         unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            let _lock = lock::lock();\n             DLMALLOC.calloc(layout.size(), layout.align())\n         }\n \n         #[inline]\n         unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+            let _lock = lock::lock();\n             DLMALLOC.free(ptr, layout.size(), layout.align())\n         }\n \n         #[inline]\n         unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            let _lock = lock::lock();\n             DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n         }\n     }\n+\n+    #[cfg(target_feature = \"atomics\")]\n+    mod lock {\n+        use core::arch::wasm32;\n+        use core::sync::atomic::{AtomicI32, Ordering::SeqCst};\n+\n+        static LOCKED: AtomicI32 = AtomicI32::new(0);\n+\n+        pub struct DropLock;\n+\n+        pub fn lock() -> DropLock {\n+            loop {\n+                if LOCKED.swap(1, SeqCst) == 0 {\n+                    return DropLock\n+                }\n+                unsafe {\n+                    let r = wasm32::atomic::wait_i32(\n+                        &LOCKED as *const AtomicI32 as *mut i32,\n+                        1,  // expected value\n+                        -1, // timeout\n+                    );\n+                    debug_assert!(r == 0 || r == 1);\n+                }\n+            }\n+        }\n+\n+        impl Drop for DropLock {\n+            fn drop(&mut self) {\n+                let r = LOCKED.swap(0, SeqCst);\n+                debug_assert_eq!(r, 1);\n+                unsafe {\n+                    wasm32::atomic::wake(\n+                        &LOCKED as *const AtomicI32 as *mut i32,\n+                        1, // only one thread\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    #[cfg(not(target_feature = \"atomics\"))]\n+    mod lock {\n+        pub fn lock() {} // no atomics, no threads, that's easy!\n+    }\n }"}]}