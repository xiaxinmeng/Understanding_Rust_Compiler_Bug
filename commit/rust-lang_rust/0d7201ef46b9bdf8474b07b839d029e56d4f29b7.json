{"sha": "0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNzIwMWVmNDZiOWJkZjg0NzRiMDdiODM5ZDAyOWU1NmQ0ZjI5Yjc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-10-20T03:33:20Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-02T02:00:02Z"}, "message": "rustc: record the target type of every adjustment.", "tree": {"sha": "a4e96933e9757746b5a2bcee669b25b8827ab233", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4e96933e9757746b5a2bcee669b25b8827ab233"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "html_url": "https://github.com/rust-lang/rust/commit/0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a8d131e5df60ba48c2382f9a3027b2c75c14e18", "html_url": "https://github.com/rust-lang/rust/commit/6a8d131e5df60ba48c2382f9a3027b2c75c14e18"}], "stats": {"total": 1004, "additions": 422, "deletions": 582}, "files": [{"sha": "a2fc6e044e74c53753b3a2819a49cfad66a8c1ab", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -374,7 +374,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         let method_call = ty::MethodCall::expr(call_expr.id);\n         let fn_ty = match self.tcx.tables().method_map.get(&method_call) {\n             Some(method) => method.ty,\n-            None => self.tcx.expr_ty_adjusted(func_or_rcvr)\n+            None => self.tcx.tables().expr_ty_adjusted(func_or_rcvr)\n         };\n \n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);"}, {"sha": "689f45cd709d5f06b06bb976ee66dccf2526048c", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -1256,26 +1256,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.region_vars.new_bound(debruijn)\n     }\n \n-    /// Apply `adjustment` to the type of `expr`\n-    pub fn adjust_expr_ty(&self,\n-                          expr: &hir::Expr,\n-                          adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n-                          -> Ty<'tcx>\n-    {\n-        let raw_ty = self.expr_ty(expr);\n-        let raw_ty = self.shallow_resolve(raw_ty);\n-        let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n-        raw_ty.adjust(self.tcx,\n-                      expr.span,\n-                      expr.id,\n-                      adjustment,\n-                      |method_call| self.tables\n-                                        .borrow()\n-                                        .method_map\n-                                        .get(&method_call)\n-                                        .map(|method| resolve_ty(method.ty)))\n-    }\n-\n     /// True if errors have been reported since this infcx was\n     /// created.  This is sometimes used as a heuristic to skip\n     /// reporting errors that often occur as a result of earlier\n@@ -1612,7 +1592,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        let ty = self.adjust_expr_ty(expr, self.tables.borrow().adjustments.get(&expr.id));\n+        let ty = self.tables.borrow().expr_ty_adjusted(expr);\n         self.resolve_type_vars_or_error(&ty)\n     }\n \n@@ -1656,9 +1636,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .map(|method| method.def_id)\n     }\n \n-    pub fn adjustments(&self) -> Ref<NodeMap<adjustment::AutoAdjustment<'tcx>>> {\n+    pub fn adjustments(&self) -> Ref<NodeMap<adjustment::Adjustment<'tcx>>> {\n         fn project_adjustments<'a, 'tcx>(tables: &'a ty::Tables<'tcx>)\n-                                        -> &'a NodeMap<adjustment::AutoAdjustment<'tcx>> {\n+                                        -> &'a NodeMap<adjustment::Adjustment<'tcx>> {\n             &tables.adjustments\n         }\n "}, {"sha": "4212b1fb05ee3a6eeffc5ff277ac84a964f0cf36", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n-        match self.tcx.expr_ty_adjusted(lhs).sty {\n+        match self.tcx.tables().expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().field_named(name).did);\n             }\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n-        match self.tcx.expr_ty_adjusted(lhs).sty {\n+        match self.tcx.tables().expr_ty_adjusted(lhs).sty {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.struct_variant().fields[idx].did);\n             }"}, {"sha": "8ca3c75eaa4b1fbe3ad90774651e43d940cf113f", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -168,15 +168,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprCall(ref base, _) => {\n-                let base_type = self.tcx.expr_ty_adjusted(base);\n+                let base_type = self.tcx.tables().expr_ty_adjusted(base);\n                 debug!(\"effect: call case, base type is {:?}\",\n                         base_type);\n                 if type_is_unsafe_function(base_type) {\n                     self.require_unsafe(expr.span, \"call to unsafe function\")\n                 }\n             }\n             hir::ExprUnary(hir::UnDeref, ref base) => {\n-                let base_type = self.tcx.expr_ty_adjusted(base);\n+                let base_type = self.tcx.tables().expr_ty_adjusted(base);\n                 debug!(\"effect: unary case, base type is {:?}\",\n                         base_type);\n                 if let ty::TyRawPtr(_) = base_type.sty {\n@@ -200,7 +200,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ExprField(ref base_expr, field) => {\n-                if let ty::TyAdt(adt, ..) = self.tcx.expr_ty_adjusted(base_expr).sty {\n+                if let ty::TyAdt(adt, ..) = self.tcx.tables().expr_ty_adjusted(base_expr).sty {\n                     if adt.is_union() {\n                         self.require_unsafe(field.span, \"access to union field\");\n                     }"}, {"sha": "0543d1303a5f10fe9f1137d11c61cbec6e0769fb", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -720,20 +720,33 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n         let adj = infcx.adjustments().get(&expr.id).map(|x| x.clone());\n         if let Some(adjustment) = adj {\n-            match adjustment {\n-                adjustment::AdjustNeverToAny(..) |\n-                adjustment::AdjustReifyFnPointer |\n-                adjustment::AdjustUnsafeFnPointer |\n-                adjustment::AdjustMutToConstPointer => {\n+            match adjustment.kind {\n+                adjustment::Adjust::NeverToAny |\n+                adjustment::Adjust::ReifyFnPointer |\n+                adjustment::Adjust::UnsafeFnPointer |\n+                adjustment::Adjust::MutToConstPointer => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n                     debug!(\"walk_adjustment: trivial adjustment\");\n                     let cmt_unadjusted =\n                         return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                     self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 }\n-                adjustment::AdjustDerefRef(ref adj) => {\n-                    self.walk_autoderefref(expr, adj);\n+                adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n+                    debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n+\n+                    self.walk_autoderefs(expr, autoderefs);\n+\n+                    let cmt_derefd =\n+                        return_if_err!(self.mc.cat_expr_autoderefd(expr, autoderefs));\n+\n+                    let cmt_refd =\n+                        self.walk_autoref(expr, cmt_derefd, autoref);\n+\n+                    if unsize {\n+                        // Unsizing consumes the thin pointer and produces a fat one.\n+                        self.delegate_consume(expr.id, expr.span, cmt_refd);\n+                    }\n                 }\n             }\n         }\n@@ -770,28 +783,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn walk_autoderefref(&mut self,\n-                         expr: &hir::Expr,\n-                         adj: &adjustment::AutoDerefRef<'tcx>) {\n-        debug!(\"walk_autoderefref expr={:?} adj={:?}\",\n-               expr,\n-               adj);\n-\n-        self.walk_autoderefs(expr, adj.autoderefs);\n-\n-        let cmt_derefd =\n-            return_if_err!(self.mc.cat_expr_autoderefd(expr, adj.autoderefs));\n-\n-        let cmt_refd =\n-            self.walk_autoref(expr, cmt_derefd, adj.autoref);\n-\n-        if adj.unsize.is_some() {\n-            // Unsizing consumes the thin pointer and produces a fat one.\n-            self.delegate_consume(expr.id, expr.span, cmt_refd);\n-        }\n-    }\n-\n-\n     /// Walks the autoref `opt_autoref` applied to the autoderef'd\n     /// `expr`. `cmt_derefd` is the mem-categorized form of `expr`\n     /// after all relevant autoderefs have occurred. Because AutoRefs\n@@ -803,7 +794,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_autoref(&mut self,\n                     expr: &hir::Expr,\n                     cmt_base: mc::cmt<'tcx>,\n-                    opt_autoref: Option<adjustment::AutoRef<'tcx>>)\n+                    opt_autoref: Option<adjustment::AutoBorrow<'tcx>>)\n                     -> mc::cmt<'tcx>\n     {\n         debug!(\"walk_autoref(expr.id={} cmt_derefd={:?} opt_autoref={:?})\",\n@@ -822,7 +813,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         };\n \n         match *autoref {\n-            adjustment::AutoPtr(r, m) => {\n+            adjustment::AutoBorrow::Ref(r, m) => {\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n                                      cmt_base,\n@@ -831,7 +822,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                      AutoRef);\n             }\n \n-            adjustment::AutoUnsafe(m) => {\n+            adjustment::AutoBorrow::RawPtr(m) => {\n                 debug!(\"walk_autoref: expr.id={} cmt_base={:?}\",\n                        expr.id,\n                        cmt_base);"}, {"sha": "46bea00cca3cbf8399319f2c5723ca75c3357d20", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -1114,7 +1114,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprCall(ref f, ref args) => {\n             // FIXME(canndrew): This is_never should really be an is_uninhabited\n             let diverges = !self.ir.tcx.tables().is_method_call(expr.id) &&\n-                self.ir.tcx.expr_ty_adjusted(&f).fn_ret().0.is_never();\n+                self.ir.tcx.tables().expr_ty_adjusted(&f).fn_ret().0.is_never();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {"}, {"sha": "e3ed13e1e40173501cab2d79040731b8d07b67e0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -354,11 +354,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        let unadjusted_ty = self.expr_ty(expr)?;\n-        Ok(unadjusted_ty.adjust(\n-            self.tcx(), expr.span, expr.id,\n-            self.infcx.adjustments().get(&expr.id),\n-            |method_call| self.infcx.node_method_ty(method_call)))\n+        self.infcx.expr_ty_adjusted(expr)\n     }\n \n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n@@ -396,19 +392,21 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n \n             Some(adjustment) => {\n-                match *adjustment {\n-                    adjustment::AdjustDerefRef(\n-                        adjustment::AutoDerefRef {\n-                            autoref: None, unsize: None, autoderefs, ..}) => {\n+                match adjustment.kind {\n+                    adjustment::Adjust::DerefRef {\n+                        autoderefs,\n+                        autoref: None,\n+                        unsize: false\n+                    } => {\n                         // Equivalent to *expr or something similar.\n                         self.cat_expr_autoderefd(expr, autoderefs)\n                     }\n \n-                    adjustment::AdjustNeverToAny(..) |\n-                    adjustment::AdjustReifyFnPointer |\n-                    adjustment::AdjustUnsafeFnPointer |\n-                    adjustment::AdjustMutToConstPointer |\n-                    adjustment::AdjustDerefRef(_) => {\n+                    adjustment::Adjust::NeverToAny |\n+                    adjustment::Adjust::ReifyFnPointer |\n+                    adjustment::Adjust::UnsafeFnPointer |\n+                    adjustment::Adjust::MutToConstPointer |\n+                    adjustment::Adjust::DerefRef {..} => {\n                         debug!(\"cat_expr({:?}): {:?}\",\n                                adjustment,\n                                expr);"}, {"sha": "fd17e378787a59008fd9415c5c93cf783f26e269", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -559,7 +559,7 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n         }\n         hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n-            match tcx.expr_ty_adjusted(base_e).sty {\n+            match tcx.tables().expr_ty_adjusted(base_e).sty {\n                 ty::TyAdt(def, _) => {\n                     def.struct_variant().field_named(field.node).did\n                 }\n@@ -569,7 +569,7 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n         }\n         hir::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n-            match tcx.expr_ty_adjusted(base_e).sty {\n+            match tcx.tables().expr_ty_adjusted(base_e).sty {\n                 ty::TyAdt(def, _) => {\n                     def.struct_variant().fields[field.node].did\n                 }"}, {"sha": "333a5c74cb45cb309c73e62317493ffed343530c", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 107, "deletions": 182, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::AutoAdjustment::*;\n-pub use self::AutoRef::*;\n-\n-use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeAndMut};\n use ty::LvaluePreference::{NoPreference};\n \n use syntax::ast;\n@@ -20,116 +17,122 @@ use syntax_pos::Span;\n use hir;\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub enum AutoAdjustment<'tcx> {\n-    AdjustNeverToAny(Ty<'tcx>), // go from ! to any type\n-    AdjustReifyFnPointer,       // go from a fn-item type to a fn-pointer type\n-    AdjustUnsafeFnPointer,      // go from a safe fn pointer to an unsafe fn pointer\n-    AdjustMutToConstPointer,    // go from a mut raw pointer to a const raw pointer\n-    AdjustDerefRef(AutoDerefRef<'tcx>),\n+pub struct Adjustment<'tcx> {\n+    pub kind: Adjust<'tcx>,\n+    pub target: Ty<'tcx>\n }\n \n-/// Represents coercing a pointer to a different kind of pointer - where 'kind'\n-/// here means either or both of raw vs borrowed vs unique and fat vs thin.\n-///\n-/// We transform pointers by following the following steps in order:\n-/// 1. Deref the pointer `self.autoderefs` times (may be 0).\n-/// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n-///    `&` or `*` pointer.\n-/// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n-///    which will do things like convert thin pointers to fat\n-///    pointers, or convert structs containing thin pointers to\n-///    structs containing fat pointers, or convert between fat\n-///    pointers.  We don't store the details of how the transform is\n-///    done (in fact, we don't know that, because it might depend on\n-///    the precise type parameters). We just store the target\n-///    type. Trans figures out what has to be done at monomorphization\n-///    time based on the precise source/target type at hand.\n-///\n-/// To make that more concrete, here are some common scenarios:\n-///\n-/// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n-/// Here the pointer will be dereferenced N times (where a dereference can\n-/// happen to raw or borrowed pointers or any smart pointer which implements\n-/// Deref, including Box<_>). The number of dereferences is given by\n-/// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n-/// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n-/// None.\n-///\n-/// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n-/// with a thin pointer, deref a number of times, unsize the underlying data,\n-/// then autoref. The 'unsize' phase may change a fixed length array to a\n-/// dynamically sized one, a concrete object to a trait object, or statically\n-/// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n-/// represented by:\n-///\n-/// ```\n-/// AutoDerefRef {\n-///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n-///     autoref: Some(AutoPtr), // [i32] -> &[i32]\n-///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n-/// }\n-/// ```\n-///\n-/// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n-/// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n-/// The autoderef and -ref are the same as in the above example, but the type\n-/// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n-/// the underlying conversions from `[i32; 4]` to `[i32]`.\n-///\n-/// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n-/// that case, we have the pointer we need coming in, so there are no\n-/// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n-/// At some point, of course, `Box` should move out of the compiler, in which\n-/// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n-/// Box<[i32]> is represented by:\n-///\n-/// ```\n-/// AutoDerefRef {\n-///     autoderefs: 0,\n-///     autoref: None,\n-///     unsize: Some(Box<[i32]>),\n-/// }\n-/// ```\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-pub struct AutoDerefRef<'tcx> {\n-    /// Step 1. Apply a number of dereferences, producing an lvalue.\n-    pub autoderefs: usize,\n-\n-    /// Step 2. Optionally produce a pointer/reference from the value.\n-    pub autoref: Option<AutoRef<'tcx>>,\n-\n-    /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n-    /// `&[T]`. The stored type is the target pointer type. Note that\n-    /// the source could be a thin or fat pointer.\n-    pub unsize: Option<Ty<'tcx>>,\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum Adjust<'tcx> {\n+    /// Go from ! to any type.\n+    NeverToAny,\n+\n+    /// Go from a fn-item type to a fn-pointer type.\n+    ReifyFnPointer,\n+\n+    /// Go from a safe fn pointer to an unsafe fn pointer.\n+    UnsafeFnPointer,\n+\n+    /// Go from a mut raw pointer to a const raw pointer.\n+    MutToConstPointer,\n+\n+    /// Represents coercing a pointer to a different kind of pointer - where 'kind'\n+    /// here means either or both of raw vs borrowed vs unique and fat vs thin.\n+    ///\n+    /// We transform pointers by following the following steps in order:\n+    /// 1. Deref the pointer `self.autoderefs` times (may be 0).\n+    /// 2. If `autoref` is `Some(_)`, then take the address and produce either a\n+    ///    `&` or `*` pointer.\n+    /// 3. If `unsize` is `Some(_)`, then apply the unsize transformation,\n+    ///    which will do things like convert thin pointers to fat\n+    ///    pointers, or convert structs containing thin pointers to\n+    ///    structs containing fat pointers, or convert between fat\n+    ///    pointers.  We don't store the details of how the transform is\n+    ///    done (in fact, we don't know that, because it might depend on\n+    ///    the precise type parameters). We just store the target\n+    ///    type. Trans figures out what has to be done at monomorphization\n+    ///    time based on the precise source/target type at hand.\n+    ///\n+    /// To make that more concrete, here are some common scenarios:\n+    ///\n+    /// 1. The simplest cases are where the pointer is not adjusted fat vs thin.\n+    /// Here the pointer will be dereferenced N times (where a dereference can\n+    /// happen to raw or borrowed pointers or any smart pointer which implements\n+    /// Deref, including Box<_>). The number of dereferences is given by\n+    /// `autoderefs`.  It can then be auto-referenced zero or one times, indicated\n+    /// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n+    /// None.\n+    ///\n+    /// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n+    /// with a thin pointer, deref a number of times, unsize the underlying data,\n+    /// then autoref. The 'unsize' phase may change a fixed length array to a\n+    /// dynamically sized one, a concrete object to a trait object, or statically\n+    /// sized struct to a dyncamically sized one. E.g., &[i32; 4] -> &[i32] is\n+    /// represented by:\n+    ///\n+    /// ```\n+    /// Adjust::DerefRef {\n+    ///     autoderefs: 1,          // &[i32; 4] -> [i32; 4]\n+    ///     autoref: Some(AutoBorrow::Ref), // [i32] -> &[i32]\n+    ///     unsize: Some([i32]),    // [i32; 4] -> [i32]\n+    /// }\n+    /// ```\n+    ///\n+    /// Note that for a struct, the 'deep' unsizing of the struct is not recorded.\n+    /// E.g., `struct Foo<T> { x: T }` we can coerce &Foo<[i32; 4]> to &Foo<[i32]>\n+    /// The autoderef and -ref are the same as in the above example, but the type\n+    /// stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n+    /// the underlying conversions from `[i32; 4]` to `[i32]`.\n+    ///\n+    /// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n+    /// that case, we have the pointer we need coming in, so there are no\n+    /// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n+    /// At some point, of course, `Box` should move out of the compiler, in which\n+    /// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n+    /// Box<[i32]> is represented by:\n+    ///\n+    /// ```\n+    /// Adjust::DerefRef {\n+    ///     autoderefs: 0,\n+    ///     autoref: None,\n+    ///     unsize: Some(Box<[i32]>),\n+    /// }\n+    /// ```\n+    DerefRef {\n+        /// Step 1. Apply a number of dereferences, producing an lvalue.\n+        autoderefs: usize,\n+\n+        /// Step 2. Optionally produce a pointer/reference from the value.\n+        autoref: Option<AutoBorrow<'tcx>>,\n+\n+        /// Step 3. Unsize a pointer/reference value, e.g. `&[T; n]` to\n+        /// `&[T]`. Note that the source could be a thin or fat pointer.\n+        unsize: bool,\n+    }\n }\n \n-impl<'tcx> AutoAdjustment<'tcx> {\n+impl<'tcx> Adjustment<'tcx> {\n     pub fn is_identity(&self) -> bool {\n-        match *self {\n-            AdjustNeverToAny(ty) => ty.is_never(),\n-            AdjustReifyFnPointer |\n-            AdjustUnsafeFnPointer |\n-            AdjustMutToConstPointer => false,\n-            AdjustDerefRef(ref r) => r.is_identity(),\n+        match self.kind {\n+            Adjust::NeverToAny => self.target.is_never(),\n+\n+            Adjust::DerefRef { autoderefs: 0, autoref: None, unsize: false } => true,\n+\n+            Adjust::ReifyFnPointer |\n+            Adjust::UnsafeFnPointer |\n+            Adjust::MutToConstPointer |\n+            Adjust::DerefRef {..} => false,\n         }\n     }\n }\n-impl<'tcx> AutoDerefRef<'tcx> {\n-    pub fn is_identity(&self) -> bool {\n-        self.autoderefs == 0 && self.unsize.is_none() && self.autoref.is_none()\n-    }\n-}\n-\n \n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n-pub enum AutoRef<'tcx> {\n+pub enum AutoBorrow<'tcx> {\n     /// Convert from T to &T.\n-    AutoPtr(&'tcx ty::Region, hir::Mutability),\n+    Ref(&'tcx ty::Region, hir::Mutability),\n \n     /// Convert from T to *T.\n-    /// Value to thin pointer.\n-    AutoUnsafe(hir::Mutability),\n+    RawPtr(hir::Mutability),\n }\n \n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n@@ -139,84 +142,6 @@ pub enum CustomCoerceUnsized {\n }\n \n impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n-    /// See `expr_ty_adjusted`\n-    pub fn adjust<F>(&'tcx self,\n-                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     span: Span,\n-                     expr_id: ast::NodeId,\n-                     adjustment: Option<&AutoAdjustment<'tcx>>,\n-                     mut method_type: F)\n-                     -> Ty<'tcx> where\n-        F: FnMut(ty::MethodCall) -> Option<Ty<'tcx>>,\n-    {\n-        if let ty::TyError = self.sty {\n-            return self;\n-        }\n-\n-        return match adjustment {\n-            Some(adjustment) => {\n-                match *adjustment {\n-                    AdjustNeverToAny(ref ty) => ty,\n-\n-                    AdjustReifyFnPointer => {\n-                        match self.sty {\n-                            ty::TyFnDef(.., f) => tcx.mk_fn_ptr(f),\n-                            _ => {\n-                                bug!(\"AdjustReifyFnPointer adjustment on non-fn-item: {:?}\",\n-                                     self);\n-                            }\n-                        }\n-                    }\n-\n-                    AdjustUnsafeFnPointer => {\n-                        match self.sty {\n-                            ty::TyFnPtr(b) => tcx.safe_to_unsafe_fn_ty(b),\n-                            ref b => {\n-                                bug!(\"AdjustUnsafeFnPointer adjustment on non-fn-ptr: {:?}\",\n-                                     b);\n-                            }\n-                        }\n-                    }\n-\n-                    AdjustMutToConstPointer => {\n-                        match self.sty {\n-                            ty::TyRawPtr(mt) => tcx.mk_ptr(ty::TypeAndMut {\n-                                ty: mt.ty,\n-                                mutbl: hir::MutImmutable\n-                            }),\n-                            ref b => {\n-                                bug!(\"AdjustMutToConstPointer on non-raw-ptr: {:?}\",\n-                                     b);\n-                            }\n-                        }\n-                    }\n-\n-                    AdjustDerefRef(ref adj) => {\n-                        let mut adjusted_ty = self;\n-\n-                        if !adjusted_ty.references_error() {\n-                            for i in 0..adj.autoderefs {\n-                                adjusted_ty =\n-                                    adjusted_ty.adjust_for_autoderef(tcx,\n-                                                                     expr_id,\n-                                                                     span,\n-                                                                     i as u32,\n-                                                                     &mut method_type);\n-                            }\n-                        }\n-\n-                        if let Some(target) = adj.unsize {\n-                            target\n-                        } else {\n-                            adjusted_ty.adjust_for_autoref(tcx, adj.autoref)\n-                        }\n-                    }\n-                }\n-            }\n-            None => self\n-        };\n-    }\n-\n     pub fn adjust_for_autoderef<F>(&'tcx self,\n                                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                    expr_id: ast::NodeId,\n@@ -247,14 +172,14 @@ impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                              autoref: Option<AutoRef<'tcx>>)\n+                              autoref: Option<AutoBorrow<'tcx>>)\n                               -> Ty<'tcx> {\n         match autoref {\n             None => self,\n-            Some(AutoPtr(r, m)) => {\n+            Some(AutoBorrow::Ref(r, m)) => {\n                 tcx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n             }\n-            Some(AutoUnsafe(m)) => {\n+            Some(AutoBorrow::RawPtr(m)) => {\n                 tcx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n             }\n         }"}, {"sha": "7e5e10435d51683d520fc299a801a67b082eeb58", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -212,7 +212,7 @@ pub struct Tables<'tcx> {\n     /// other items.\n     pub item_substs: NodeMap<ty::ItemSubsts<'tcx>>,\n \n-    pub adjustments: NodeMap<ty::adjustment::AutoAdjustment<'tcx>>,\n+    pub adjustments: NodeMap<ty::adjustment::Adjustment<'tcx>>,\n \n     pub method_map: ty::MethodMap<'tcx>,\n \n@@ -287,7 +287,7 @@ impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n     // Returns the type of an expression as a monotype.\n     //\n     // NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n-    // some cases, we insert `AutoAdjustment` annotations such as auto-deref or\n+    // some cases, we insert `Adjustment` annotations such as auto-deref or\n     // auto-ref.  The type returned by this function does not consider such\n     // adjustments.  See `expr_ty_adjusted()` instead.\n     //\n@@ -302,6 +302,17 @@ impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n         self.node_id_to_type_opt(expr.id)\n     }\n \n+    /// Returns the type of `expr`, considering any `Adjustment`\n+    /// entry recorded for that expression.\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+        self.adjustments.get(&expr.id)\n+            .map_or_else(|| self.expr_ty(expr), |adj| adj.target)\n+    }\n+\n+    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+        self.adjustments.get(&expr.id)\n+            .map(|adj| adj.target).or_else(|| self.expr_ty_opt(expr))\n+    }\n \n     pub fn is_method_call(&self, expr_id: NodeId) -> bool {\n         self.method_map.contains_key(&ty::MethodCall::expr(expr_id))"}, {"sha": "b79ebdb14f552ba0977135013ba10f6782a9b0b3", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -176,8 +176,8 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         r.super_fold_with(self)\n     }\n \n-    fn fold_autoref(&mut self, ar: &adjustment::AutoRef<'tcx>)\n-                    -> adjustment::AutoRef<'tcx> {\n+    fn fold_autoref(&mut self, ar: &adjustment::AutoBorrow<'tcx>)\n+                    -> adjustment::AutoBorrow<'tcx> {\n         ar.super_fold_with(self)\n     }\n }"}, {"sha": "2c15f08e89822667ad9fd9cdab7cce33fb9ca20d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -2124,34 +2124,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.tables.borrow()\n     }\n \n-    /// Returns the type of `expr`, considering any `AutoAdjustment`\n-    /// entry recorded for that expression.\n-    ///\n-    /// It would almost certainly be better to store the adjusted ty in with\n-    /// the `AutoAdjustment`, but I opted not to do this because it would\n-    /// require serializing and deserializing the type and, although that's not\n-    /// hard to do, I just hate that code so much I didn't want to touch it\n-    /// unless it was to fix it properly, which seemed a distraction from the\n-    /// thread at hand! -nmatsakis\n-    pub fn expr_ty_adjusted(self, expr: &hir::Expr) -> Ty<'gcx> {\n-        self.tables().expr_ty(expr)\n-            .adjust(self.global_tcx(), expr.span, expr.id,\n-                    self.tables().adjustments.get(&expr.id),\n-                    |method_call| {\n-            self.tables().method_map.get(&method_call).map(|method| method.ty)\n-        })\n-    }\n-\n-    pub fn expr_ty_adjusted_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n-        self.tables().expr_ty_opt(expr).map(|t| t.adjust(self.global_tcx(),\n-                                                expr.span,\n-                                                expr.id,\n-                                                self.tables().adjustments.get(&expr.id),\n-                                                |method_call| {\n-            self.tables().method_map.get(&method_call).map(|method| method.ty)\n-        }))\n-    }\n-\n     pub fn expr_span(self, id: NodeId) -> Span {\n         match self.map.find(id) {\n             Some(ast_map::NodeExpr(e)) => {"}, {"sha": "9ca911837b517855e3dcbce3e0aa5c69b22a4bfd", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -218,15 +218,15 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ItemSubsts<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoRef<'a> {\n-    type Lifted = ty::adjustment::AutoRef<'tcx>;\n+impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n+    type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            ty::adjustment::AutoPtr(r, m) => {\n-                tcx.lift(&r).map(|r| ty::adjustment::AutoPtr(r, m))\n+            ty::adjustment::AutoBorrow::Ref(r, m) => {\n+                tcx.lift(&r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n             }\n-            ty::adjustment::AutoUnsafe(m) => {\n-                Some(ty::adjustment::AutoUnsafe(m))\n+            ty::adjustment::AutoBorrow::RawPtr(m) => {\n+                Some(ty::adjustment::AutoBorrow::RawPtr(m))\n             }\n         }\n     }\n@@ -676,13 +676,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ty::adjustment::AutoPtr(ref r, m) => {\n-                ty::adjustment::AutoPtr(r.fold_with(folder), m)\n+            ty::adjustment::AutoBorrow::Ref(ref r, m) => {\n+                ty::adjustment::AutoBorrow::Ref(r.fold_with(folder), m)\n             }\n-            ty::adjustment::AutoUnsafe(m) => ty::adjustment::AutoUnsafe(m)\n+            ty::adjustment::AutoBorrow::RawPtr(m) => ty::adjustment::AutoBorrow::RawPtr(m)\n         }\n     }\n \n@@ -692,8 +692,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            ty::adjustment::AutoPtr(r, _m) => r.visit_with(visitor),\n-            ty::adjustment::AutoUnsafe(_m) => false,\n+            ty::adjustment::AutoBorrow::Ref(r, _m) => r.visit_with(visitor),\n+            ty::adjustment::AutoBorrow::RawPtr(_m) => false,\n         }\n     }\n }"}, {"sha": "2ad2a23489de40558eb40263de198950aa7e7ee4", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -436,32 +436,9 @@ impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::adjustment::AutoAdjustment<'tcx> {\n+impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::adjustment::AdjustNeverToAny(ref target) => {\n-                write!(f, \"AdjustNeverToAny({:?})\", target)\n-            }\n-            ty::adjustment::AdjustReifyFnPointer => {\n-                write!(f, \"AdjustReifyFnPointer\")\n-            }\n-            ty::adjustment::AdjustUnsafeFnPointer => {\n-                write!(f, \"AdjustUnsafeFnPointer\")\n-            }\n-            ty::adjustment::AdjustMutToConstPointer => {\n-                write!(f, \"AdjustMutToConstPointer\")\n-            }\n-            ty::adjustment::AdjustDerefRef(ref data) => {\n-                write!(f, \"{:?}\", data)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::adjustment::AutoDerefRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"AutoDerefRef({}, unsize={:?}, {:?})\",\n-               self.autoderefs, self.unsize, self.autoref)\n+        write!(f, \"{:?} -> {}\", self.kind, self.target)\n     }\n }\n "}, {"sha": "b3c0e9ef2b727d616f6dec3edf75327dd98217a3", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -34,7 +34,6 @@ use middle::stability;\n use rustc::cfg;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::adjustment;\n use rustc::traits::{self, Reveal};\n use rustc::hir::map as hir_map;\n use util::nodemap::NodeSet;\n@@ -941,6 +940,8 @@ impl LateLintPass for UnconditionalRecursion {\n                                                 method: &ty::Method,\n                                                 id: ast::NodeId)\n                                                 -> bool {\n+            use rustc::ty::adjustment::*;\n+\n             // Check for method calls and overloaded operators.\n             let opt_m = tcx.tables().method_map.get(&ty::MethodCall::expr(id)).cloned();\n             if let Some(m) = opt_m {\n@@ -951,8 +952,8 @@ impl LateLintPass for UnconditionalRecursion {\n \n             // Check for overloaded autoderef method calls.\n             let opt_adj = tcx.tables().adjustments.get(&id).cloned();\n-            if let Some(adjustment::AdjustDerefRef(adj)) = opt_adj {\n-                for i in 0..adj.autoderefs {\n+            if let Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) = opt_adj {\n+                for i in 0..autoderefs {\n                     let method_call = ty::MethodCall::autoderef(id, i as u32);\n                     if let Some(m) = tcx.tables().method_map.get(&method_call)\n                                                             .cloned() {"}, {"sha": "15430a5c9f99d96ca583ae3c2767bb8d51dfd374", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -442,15 +442,14 @@ impl LateLintPass for UnusedAllocation {\n         }\n \n         if let Some(adjustment) = cx.tcx.tables().adjustments.get(&e.id) {\n-            if let adjustment::AdjustDerefRef(adjustment::AutoDerefRef { ref autoref, .. }) =\n-                *adjustment {\n+            if let adjustment::Adjust::DerefRef { autoref, .. } = adjustment.kind {\n                 match autoref {\n-                    &Some(adjustment::AutoPtr(_, hir::MutImmutable)) => {\n+                    Some(adjustment::AutoBorrow::Ref(_, hir::MutImmutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION,\n                                      e.span,\n                                      \"unnecessary allocation, use & instead\");\n                     }\n-                    &Some(adjustment::AutoPtr(_, hir::MutMutable)) => {\n+                    Some(adjustment::AutoBorrow::Ref(_, hir::MutMutable)) => {\n                         cx.span_lint(UNUSED_ALLOCATION,\n                                      e.span,\n                                      \"unnecessary allocation, use &mut instead\");"}, {"sha": "e009955b92ee4a67cc7f13f05bf4f3e93189ddcf", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -38,7 +38,7 @@ enum TableEntry<'tcx> {\n     Def(Def),\n     NodeType(Ty<'tcx>),\n     ItemSubsts(ty::ItemSubsts<'tcx>),\n-    Adjustment(ty::adjustment::AutoAdjustment<'tcx>),\n+    Adjustment(ty::adjustment::Adjustment<'tcx>),\n     ConstQualif(ConstQualif),\n }\n "}, {"sha": "b37dd8dd0a90716d11c584cde4bff6e33c7f4db2", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -233,7 +233,7 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                                        ast_expr: &'tcx hir::Expr)\n                                        -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n     let tcx = hir.tcx();\n-    let ty = tcx.expr_ty_adjusted(ast_expr);\n+    let ty = tcx.tables().expr_ty_adjusted(ast_expr);\n     let span = tcx.map.span(item_id);\n     let mut builder = Builder::new(hir, span, 0, ty);\n "}, {"sha": "ba0d3b49a6c1ae28315fd51bd8085db29f982470", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -35,50 +35,49 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let mut expr = make_mirror_unadjusted(cx, self);\n+        let adj = cx.tcx.tables().adjustments.get(&self.id).cloned();\n \n         debug!(\"make_mirror: unadjusted-expr={:?} applying adjustments={:?}\",\n-               expr, cx.tcx.tables().adjustments.get(&self.id));\n+               expr, adj);\n \n         // Now apply adjustments, if any.\n-        match cx.tcx.tables().adjustments.get(&self.id) {\n+        match adj.map(|adj| (adj.kind, adj.target)) {\n             None => {}\n-            Some(&ty::adjustment::AdjustReifyFnPointer) => {\n-                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+            Some((ty::adjustment::Adjust::ReifyFnPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::ReifyFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustUnsafeFnPointer) => {\n-                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+            Some((ty::adjustment::Adjust::UnsafeFnPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::UnsafeFnPointer { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustNeverToAny(adjusted_ty)) => {\n+            Some((ty::adjustment::Adjust::NeverToAny, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::NeverToAny { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustMutToConstPointer) => {\n-                let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n+            Some((ty::adjustment::Adjust::MutToConstPointer, adjusted_ty)) => {\n                 expr = Expr {\n                     temp_lifetime: temp_lifetime,\n                     ty: adjusted_ty,\n                     span: self.span,\n                     kind: ExprKind::Cast { source: expr.to_ref() },\n                 };\n             }\n-            Some(&ty::adjustment::AdjustDerefRef(ref adj)) => {\n-                for i in 0..adj.autoderefs {\n+            Some((ty::adjustment::Adjust::DerefRef { autoderefs, autoref, unsize },\n+                  adjusted_ty)) => {\n+                for i in 0..autoderefs {\n                     let i = i as u32;\n                     let adjusted_ty =\n                         expr.ty.adjust_for_autoderef(\n@@ -128,10 +127,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     };\n                 }\n \n-                if let Some(autoref) = adj.autoref {\n+                if let Some(autoref) = autoref {\n                     let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n                     match autoref {\n-                        ty::adjustment::AutoPtr(r, m) => {\n+                        ty::adjustment::AutoBorrow::Ref(r, m) => {\n                             expr = Expr {\n                                 temp_lifetime: temp_lifetime,\n                                 ty: adjusted_ty,\n@@ -143,7 +142,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 },\n                             };\n                         }\n-                        ty::adjustment::AutoUnsafe(m) => {\n+                        ty::adjustment::AutoBorrow::RawPtr(m) => {\n                             // Convert this to a suitable `&foo` and\n                             // then an unsafe coercion. Limit the region to be just this\n                             // expression.\n@@ -169,10 +168,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     }\n                 }\n \n-                if let Some(target) = adj.unsize {\n+                if unsize {\n                     expr = Expr {\n                         temp_lifetime: temp_lifetime,\n-                        ty: target,\n+                        ty: adjusted_ty,\n                         span: self.span,\n                         kind: ExprKind::Unsize { source: expr.to_ref() },\n                     };\n@@ -578,7 +577,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::Loop { condition: None,\n                              body: block::to_expr_ref(cx, body) },\n         hir::ExprField(ref source, name) => {\n-            let index = match cx.tcx.expr_ty_adjusted(source).sty {\n+            let index = match cx.tcx.tables().expr_ty_adjusted(source).sty {\n                 ty::TyAdt(adt_def, _) =>\n                     adt_def.variants[0].index_of_field_named(name.node),\n                 ref ty =>\n@@ -893,7 +892,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             argrefs.extend(\n                 args.iter()\n                     .map(|arg| {\n-                        let arg_ty = cx.tcx.expr_ty_adjusted(arg);\n+                        let arg_ty = cx.tcx.tables().expr_ty_adjusted(arg);\n                         let adjusted_ty =\n                             cx.tcx.mk_ref(region,\n                                        ty::TypeAndMut { ty: arg_ty,"}, {"sha": "f23539e88f78d175f3b9dfc36e4dd70a019dbdae", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -625,14 +625,16 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n \n /// Check the adjustments of an expression\n fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr) {\n-    match v.tcx.tables().adjustments.get(&e.id) {\n+    use rustc::ty::adjustment::*;\n+\n+    match v.tcx.tables().adjustments.get(&e.id).map(|adj| adj.kind) {\n         None |\n-        Some(&ty::adjustment::AdjustNeverToAny(..)) |\n-        Some(&ty::adjustment::AdjustReifyFnPointer) |\n-        Some(&ty::adjustment::AdjustUnsafeFnPointer) |\n-        Some(&ty::adjustment::AdjustMutToConstPointer) => {}\n+        Some(Adjust::NeverToAny) |\n+        Some(Adjust::ReifyFnPointer) |\n+        Some(Adjust::UnsafeFnPointer) |\n+        Some(Adjust::MutToConstPointer) => {}\n \n-        Some(&ty::adjustment::AdjustDerefRef(ty::adjustment::AutoDerefRef { autoderefs, .. })) => {\n+        Some(Adjust::DerefRef { autoderefs, .. }) => {\n             if (0..autoderefs as u32)\n                 .any(|autoderef| v.tcx.tables().is_overloaded_autoderef(e.id, autoderef)) {\n                 v.add_qualif(ConstQualif::NOT_CONST);"}, {"sha": "db4788c3ceadb70964703f37c071161b23f13e17", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -1380,7 +1380,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                         return;\n                     }\n                 };\n-                let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n+                let ty = &self.tcx.tables().expr_ty_adjusted(&hir_node).sty;\n                 match *ty {\n                     ty::TyAdt(def, _) => {\n                         let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);"}, {"sha": "7e008f741624b117187e54a756b1ed73dbcc8133", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -418,7 +418,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Option<Data> {\n         let hir_node = self.tcx.map.expect_expr(expr.id);\n-        let ty = self.tcx.expr_ty_adjusted_opt(&hir_node);\n+        let ty = self.tcx.tables().expr_ty_adjusted_opt(&hir_node);\n         if ty.is_none() || ty.unwrap().sty == ty::TyError {\n             return None;\n         }\n@@ -432,7 +432,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         return None;\n                     }\n                 };\n-                match self.tcx.expr_ty_adjusted(&hir_node).sty {\n+                match self.tcx.tables().expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let f = def.struct_variant().field_named(ident.node.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n@@ -451,7 +451,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::Struct(ref path, ..) => {\n-                match self.tcx.expr_ty_adjusted(&hir_node).sty {\n+                match self.tcx.tables().expr_ty_adjusted(&hir_node).sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);"}, {"sha": "3cf64fa439d7d0afe868f3ab2554079661dac4c1", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match self.structurally_resolved_type(callee_expr.span, adjusted_ty).sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                self.write_autoderef_adjustment(callee_expr.id, autoderefs);\n+                self.write_autoderef_adjustment(callee_expr.id, autoderefs, adjusted_ty);\n                 return Some(CallStep::Builtin);\n             }\n "}, {"sha": "16493412d690b41e042afbb1e2c9b99b2fc8fe06", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -65,10 +65,7 @@ use check::FnCtxt;\n use rustc::hir;\n use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n use rustc::traits::{self, ObligationCause};\n-use rustc::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n-use rustc::ty::adjustment::{AutoPtr, AutoUnsafe, AdjustReifyFnPointer};\n-use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n-use rustc::ty::adjustment::AdjustNeverToAny;\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::{self, LvaluePreference, TypeAndMut, Ty};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n@@ -93,7 +90,7 @@ impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n     }\n }\n \n-type CoerceResult<'tcx> = RelateResult<'tcx, (Ty<'tcx>, AutoAdjustment<'tcx>)>;\n+type CoerceResult<'tcx> = RelateResult<'tcx, (Ty<'tcx>, Adjust<'tcx>)>;\n \n fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n                        to_mutbl: hir::Mutability)\n@@ -144,12 +141,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n     /// Synthesize an identity adjustment.\n     fn identity(&self, ty: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        Ok((ty,\n-            AdjustDerefRef(AutoDerefRef {\n-                autoderefs: 0,\n-                autoref: None,\n-                unsize: None,\n-            })))\n+        Ok((ty, Adjust::DerefRef {\n+            autoderefs: 0,\n+            autoref: None,\n+            unsize: false,\n+        }))\n     }\n \n     fn coerce<'a, E, I>(&self, exprs: &E, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx>\n@@ -166,7 +162,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         }\n \n         if a.is_never() {\n-            return Ok((b, AdjustNeverToAny(b)));\n+            return Ok((b, Adjust::NeverToAny));\n         }\n \n         // Consider coercing the subtype to a DST\n@@ -396,17 +392,16 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyRef(r_borrow, _) => r_borrow,\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n-        let autoref = Some(AutoPtr(r_borrow, mt_b.mutbl));\n+        let autoref = Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl));\n         debug!(\"coerce_borrowed_pointer: succeeded ty={:?} autoderefs={:?} autoref={:?}\",\n                ty,\n                autoderefs,\n                autoref);\n-        Ok((ty,\n-            AdjustDerefRef(AutoDerefRef {\n-                autoderefs: autoderefs,\n-                autoref: autoref,\n-                unsize: None,\n-            })))\n+        Ok((ty, Adjust::DerefRef {\n+            autoderefs: autoderefs,\n+            autoref: autoref,\n+            unsize: false,\n+        }))\n     }\n \n \n@@ -437,11 +432,11 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n                 let coercion = Coercion(self.origin.span());\n                 let r_borrow = self.next_region_var(coercion);\n-                (mt_a.ty, Some(AutoPtr(r_borrow, mt_b.mutbl)))\n+                (mt_a.ty, Some(AutoBorrow::Ref(r_borrow, mt_b.mutbl)))\n             }\n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n-                (mt_a.ty, Some(AutoUnsafe(mt_b.mutbl)))\n+                (mt_a.ty, Some(AutoBorrow::RawPtr(mt_b.mutbl)))\n             }\n             _ => (source, None),\n         };\n@@ -497,13 +492,13 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         *self.unsizing_obligations.borrow_mut() = leftover_predicates;\n \n-        let adjustment = AutoDerefRef {\n+        let adjustment = Adjust::DerefRef {\n             autoderefs: if reborrow.is_some() { 1 } else { 0 },\n             autoref: reborrow,\n-            unsize: Some(target),\n+            unsize: true,\n         };\n         debug!(\"Success, coerced with {:?}\", adjustment);\n-        Ok((target, AdjustDerefRef(adjustment)))\n+        Ok((target, adjustment))\n     }\n \n     fn coerce_from_safe_fn(&self,\n@@ -516,7 +511,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n                     let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n                     return self.unify_and_identity(unsafe_a, b)\n-                        .map(|(ty, _)| (ty, AdjustUnsafeFnPointer));\n+                        .map(|(ty, _)| (ty, Adjust::UnsafeFnPointer));\n                 }\n                 _ => {}\n             }\n@@ -555,7 +550,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             ty::TyFnPtr(_) => {\n                 let a_fn_pointer = self.tcx.mk_fn_ptr(fn_ty_a);\n                 self.coerce_from_safe_fn(a_fn_pointer, fn_ty_a, b)\n-                    .map(|(ty, _)| (ty, AdjustReifyFnPointer))\n+                    .map(|(ty, _)| (ty, Adjust::ReifyFnPointer))\n             }\n             _ => self.unify_and_identity(a, b),\n         }\n@@ -585,17 +580,17 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n \n         // Although references and unsafe ptrs have the same\n-        // representation, we still register an AutoDerefRef so that\n+        // representation, we still register an Adjust::DerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n         Ok((ty,\n             if is_ref {\n-                AdjustDerefRef(AutoDerefRef {\n+                Adjust::DerefRef {\n                     autoderefs: 1,\n-                    autoref: Some(AutoUnsafe(mutbl_b)),\n-                    unsize: None,\n-                })\n+                    autoref: Some(AutoBorrow::RawPtr(mutbl_b)),\n+                    unsize: false,\n+                }\n             } else if mt_a.mutbl != mutbl_b {\n-                AdjustMutToConstPointer\n+                Adjust::MutToConstPointer\n             } else {\n                 noop\n             }))\n@@ -606,24 +601,25 @@ fn apply<'a, 'b, 'gcx, 'tcx, E, I>(coerce: &mut Coerce<'a, 'gcx, 'tcx>,\n                                    exprs: &E,\n                                    a: Ty<'tcx>,\n                                    b: Ty<'tcx>)\n-                                   -> CoerceResult<'tcx>\n+                                   -> RelateResult<'tcx, Adjustment<'tcx>>\n     where E: Fn() -> I,\n           I: IntoIterator<Item = &'b hir::Expr>\n {\n \n-    let (ty, adjustment) = indent(|| coerce.coerce(exprs, a, b))?;\n+    let (ty, adjust) = indent(|| coerce.coerce(exprs, a, b))?;\n \n     let fcx = coerce.fcx;\n-    if let AdjustDerefRef(auto) = adjustment {\n-        if auto.unsize.is_some() {\n-            let mut obligations = coerce.unsizing_obligations.borrow_mut();\n-            for obligation in obligations.drain(..) {\n-                fcx.register_predicate(obligation);\n-            }\n+    if let Adjust::DerefRef { unsize: true, .. } = adjust {\n+        let mut obligations = coerce.unsizing_obligations.borrow_mut();\n+        for obligation in obligations.drain(..) {\n+            fcx.register_predicate(obligation);\n         }\n     }\n \n-    Ok((ty, adjustment))\n+    Ok(Adjustment {\n+        kind: adjust,\n+        target: ty\n+    })\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -641,17 +637,17 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut coerce = Coerce::new(self, TypeOrigin::ExprAssignable(expr.span));\n         self.commit_if_ok(|_| {\n-            let (ty, adjustment) = apply(&mut coerce, &|| Some(expr), source, target)?;\n+            let adjustment = apply(&mut coerce, &|| Some(expr), source, target)?;\n             if !adjustment.is_identity() {\n                 debug!(\"Success, coerced with {:?}\", adjustment);\n                 match self.tables.borrow().adjustments.get(&expr.id) {\n                     None |\n-                    Some(&AdjustNeverToAny(..)) => (),\n+                    Some(&Adjustment { kind: Adjust::NeverToAny, .. }) => (),\n                     _ => bug!(\"expr already has an adjustment on it!\"),\n                 };\n                 self.write_adjustment(expr.id, adjustment);\n             }\n-            Ok(ty)\n+            Ok(adjustment.target)\n         })\n     }\n \n@@ -705,12 +701,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 // Reify both sides and return the reified fn pointer type.\n+                let fn_ptr = self.tcx.mk_fn_ptr(fty);\n                 for expr in exprs().into_iter().chain(Some(new)) {\n                     // No adjustments can produce a fn item, so this should never trip.\n                     assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n-                    self.write_adjustment(expr.id, AdjustReifyFnPointer);\n+                    self.write_adjustment(expr.id, Adjustment {\n+                        kind: Adjust::ReifyFnPointer,\n+                        target: fn_ptr\n+                    });\n                 }\n-                return Ok(self.tcx.mk_fn_ptr(fty));\n+                return Ok(fn_ptr);\n             }\n             _ => {}\n         }\n@@ -724,11 +724,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if !self.tables.borrow().adjustments.contains_key(&new.id) {\n             let result = self.commit_if_ok(|_| apply(&mut coerce, &|| Some(new), new_ty, prev_ty));\n             match result {\n-                Ok((ty, adjustment)) => {\n+                Ok(adjustment) => {\n                     if !adjustment.is_identity() {\n                         self.write_adjustment(new.id, adjustment);\n                     }\n-                    return Ok(ty);\n+                    return Ok(adjustment.target);\n                 }\n                 Err(e) => first_error = Some(e),\n             }\n@@ -738,10 +738,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // This requires ensuring there are no coercions applied to *any* of the\n         // previous expressions, other than noop reborrows (ignoring lifetimes).\n         for expr in exprs() {\n-            let noop = match self.tables.borrow().adjustments.get(&expr.id) {\n-                Some(&AdjustDerefRef(AutoDerefRef { autoderefs: 1,\n-                                                    autoref: Some(AutoPtr(_, mutbl_adj)),\n-                                                    unsize: None })) => {\n+            let noop = match self.tables.borrow().adjustments.get(&expr.id).map(|adj| adj.kind) {\n+                Some(Adjust::DerefRef {\n+                    autoderefs: 1,\n+                    autoref: Some(AutoBorrow::Ref(_, mutbl_adj)),\n+                    unsize: false\n+                }) => {\n                     match self.node_ty(expr.id).sty {\n                         ty::TyRef(_, mt_orig) => {\n                             // Reborrow that we can safely ignore.\n@@ -750,7 +752,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         _ => false,\n                     }\n                 }\n-                Some(&AdjustNeverToAny(_)) => true,\n+                Some(Adjust::NeverToAny) => true,\n                 Some(_) => false,\n                 None => true,\n             };\n@@ -783,18 +785,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     })\n                 }\n             }\n-            Ok((ty, adjustment)) => {\n+            Ok(adjustment) => {\n                 if !adjustment.is_identity() {\n+                    let mut tables = self.tables.borrow_mut();\n                     for expr in exprs() {\n-                        let previous = self.tables.borrow().adjustments.get(&expr.id).cloned();\n-                        if let Some(AdjustNeverToAny(_)) = previous {\n-                            self.write_adjustment(expr.id, AdjustNeverToAny(ty));\n-                        } else {\n-                            self.write_adjustment(expr.id, adjustment);\n+                        if let Some(&mut Adjustment {\n+                            kind: Adjust::NeverToAny,\n+                            ref mut target\n+                        }) = tables.adjustments.get_mut(&expr.id) {\n+                            *target = adjustment.target;\n+                            continue;\n                         }\n+                        tables.adjustments.insert(expr.id, adjustment);\n                     }\n                 }\n-                Ok(ty)\n+                Ok(adjustment.target)\n             }\n         }\n     }"}, {"sha": "f88bb355d1270a63ddeaa536a2ec5ca64e2c962d", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 70, "deletions": 66, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -15,7 +15,7 @@ use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n-use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use syntax_pos::Span;\n@@ -140,20 +140,19 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                       unadjusted_self_ty: Ty<'tcx>,\n                       pick: &probe::Pick<'tcx>)\n                       -> Ty<'tcx> {\n-        let (autoref, unsize) = if let Some(mutbl) = pick.autoref {\n+        let autoref = if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n-            let autoref = AutoPtr(region, mutbl);\n-            (Some(autoref),\n-             pick.unsize.map(|target| target.adjust_for_autoref(self.tcx, Some(autoref))))\n+            Some(AutoBorrow::Ref(region, mutbl))\n         } else {\n             // No unsizing should be performed without autoref (at\n             // least during method dispach). This is because we\n             // currently only unsize `[T;N]` to `[T]`, and naturally\n             // that must occur being a reference.\n             assert!(pick.unsize.is_none());\n-            (None, None)\n+            None\n         };\n \n+\n         // Commit the autoderefs by calling `autoderef` again, but this\n         // time writing the results into the various tables.\n         let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n@@ -163,19 +162,20 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         autoderef.unambiguous_final_ty();\n         autoderef.finalize(LvaluePreference::NoPreference, Some(self.self_expr));\n \n+        let target = pick.unsize.unwrap_or(autoderefd_ty);\n+        let target = target.adjust_for_autoref(self.tcx, autoref);\n+\n         // Write out the final adjustment.\n-        self.write_adjustment(self.self_expr.id,\n-                              AdjustDerefRef(AutoDerefRef {\n-                                  autoderefs: pick.autoderefs,\n-                                  autoref: autoref,\n-                                  unsize: unsize,\n-                              }));\n-\n-        if let Some(target) = unsize {\n-            target\n-        } else {\n-            autoderefd_ty.adjust_for_autoref(self.tcx, autoref)\n-        }\n+        self.write_adjustment(self.self_expr.id, Adjustment {\n+            kind: Adjust::DerefRef {\n+                autoderefs: pick.autoderefs,\n+                autoref: autoref,\n+                unsize: pick.unsize.is_some(),\n+            },\n+            target: target\n+        });\n+\n+        target\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -463,29 +463,23 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Fix up autoderefs and derefs.\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n+            debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?}\", i, expr);\n+\n             // Count autoderefs.\n-            let autoderef_count = match self.tables\n-                .borrow()\n-                .adjustments\n-                .get(&expr.id) {\n-                Some(&AdjustDerefRef(ref adj)) => adj.autoderefs,\n-                Some(_) | None => 0,\n-            };\n-\n-            debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?} \\\n-                                                      autoderef_count={}\",\n-                   i,\n-                   expr,\n-                   autoderef_count);\n-\n-            if autoderef_count > 0 {\n-                let mut autoderef = self.autoderef(expr.span, self.node_ty(expr.id));\n-                autoderef.nth(autoderef_count).unwrap_or_else(|| {\n-                    span_bug!(expr.span,\n-                              \"expr was deref-able {} times but now isn't?\",\n-                              autoderef_count);\n-                });\n-                autoderef.finalize(PreferMutLvalue, Some(expr));\n+            let adjustment = self.tables.borrow().adjustments.get(&expr.id).cloned();\n+            match adjustment {\n+                Some(Adjustment { kind: Adjust::DerefRef { autoderefs, .. }, .. }) => {\n+                    if autoderefs > 0 {\n+                        let mut autoderef = self.autoderef(expr.span, self.node_ty(expr.id));\n+                        autoderef.nth(autoderefs).unwrap_or_else(|| {\n+                            span_bug!(expr.span,\n+                                      \"expr was deref-able {} times but now isn't?\",\n+                                      autoderefs);\n+                        });\n+                        autoderef.finalize(PreferMutLvalue, Some(expr));\n+                    }\n+                }\n+                Some(_) | None => {}\n             }\n \n             // Don't retry the first one or we might infinite loop!\n@@ -503,45 +497,55 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     // ought to recode this routine so it doesn't\n                     // (ab)use the normal type checking paths.\n                     let adj = self.tables.borrow().adjustments.get(&base_expr.id).cloned();\n-                    let (autoderefs, unsize) = match adj {\n-                        Some(AdjustDerefRef(adr)) => {\n-                            match adr.autoref {\n+                    let (autoderefs, unsize, adjusted_base_ty) = match adj {\n+                        Some(Adjustment {\n+                            kind: Adjust::DerefRef { autoderefs, autoref, unsize },\n+                            target\n+                        }) => {\n+                            match autoref {\n                                 None => {\n-                                    assert!(adr.unsize.is_none());\n-                                    (adr.autoderefs, None)\n-                                }\n-                                Some(AutoPtr(..)) => {\n-                                    (adr.autoderefs,\n-                                     adr.unsize.map(|target| {\n-                                         target.builtin_deref(false, NoPreference)\n-                                             .expect(\"fixup: AutoPtr is not &T\")\n-                                             .ty\n-                                     }))\n+                                    assert!(!unsize);\n                                 }\n+                                Some(AutoBorrow::Ref(..)) => {}\n                                 Some(_) => {\n                                     span_bug!(base_expr.span,\n                                               \"unexpected adjustment autoref {:?}\",\n-                                              adr);\n+                                              adj);\n                                 }\n                             }\n+\n+                            (autoderefs, unsize, if unsize {\n+                                target.builtin_deref(false, NoPreference)\n+                                      .expect(\"fixup: AutoBorrow::Ref is not &T\")\n+                                      .ty\n+                            } else {\n+                                let ty = self.node_ty(base_expr.id);\n+                                let mut ty = self.shallow_resolve(ty);\n+                                let mut method_type = |method_call: ty::MethodCall| {\n+                                    self.tables.borrow().method_map.get(&method_call).map(|m| {\n+                                        self.resolve_type_vars_if_possible(&m.ty)\n+                                    })\n+                                };\n+\n+                                if !ty.references_error() {\n+                                    for i in 0..autoderefs {\n+                                        ty = ty.adjust_for_autoderef(self.tcx,\n+                                                                     base_expr.id,\n+                                                                     base_expr.span,\n+                                                                     i as u32,\n+                                                                     &mut method_type);\n+                                    }\n+                                }\n+\n+                                ty\n+                            })\n                         }\n-                        None => (0, None),\n+                        None => (0, false, self.node_ty(base_expr.id)),\n                         Some(_) => {\n                             span_bug!(base_expr.span, \"unexpected adjustment type\");\n                         }\n                     };\n \n-                    let (adjusted_base_ty, unsize) = if let Some(target) = unsize {\n-                        (target, true)\n-                    } else {\n-                        (self.adjust_expr_ty(base_expr,\n-                                             Some(&AdjustDerefRef(AutoDerefRef {\n-                                                 autoderefs: autoderefs,\n-                                                 autoref: None,\n-                                                 unsize: None,\n-                                             }))),\n-                         false)\n-                    };\n                     let index_expr_ty = self.node_ty(index_expr.id);\n \n                     let result = self.try_index_step(ty::MethodCall::expr(expr.id),"}, {"sha": "2df562f9ade46032613c5c6ea92799d74e2e79e9", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -16,7 +16,7 @@ use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::infer;\n \n use syntax::ast;\n@@ -294,28 +294,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        unsize,\n                        method_ty.explicit_self);\n \n-                match method_ty.explicit_self {\n+                let autoref = match method_ty.explicit_self {\n                     ty::ExplicitSelfCategory::ByValue => {\n                         // Trait method is fn(self), no transformation needed.\n                         assert!(!unsize);\n-                        self.write_autoderef_adjustment(self_expr.id, autoderefs);\n+                        None\n                     }\n \n                     ty::ExplicitSelfCategory::ByReference(..) => {\n                         // Trait method is fn(&self) or fn(&mut self), need an\n                         // autoref. Pull the region etc out of the type of first argument.\n                         match transformed_self_ty.sty {\n                             ty::TyRef(region, ty::TypeAndMut { mutbl, ty: _ }) => {\n-                                self.write_adjustment(self_expr.id,\n-                                                      AdjustDerefRef(AutoDerefRef {\n-                                                          autoderefs: autoderefs,\n-                                                          autoref: Some(AutoPtr(region, mutbl)),\n-                                                          unsize: if unsize {\n-                                                              Some(transformed_self_ty)\n-                                                          } else {\n-                                                              None\n-                                                          },\n-                                                      }));\n+                                Some(AutoBorrow::Ref(region, mutbl))\n                             }\n \n                             _ => {\n@@ -331,7 +322,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   \"unexpected explicit self type in operator method: {:?}\",\n                                   method_ty.explicit_self);\n                     }\n-                }\n+                };\n+\n+                self.write_adjustment(self_expr.id, Adjustment {\n+                    kind: Adjust::DerefRef {\n+                        autoderefs: autoderefs,\n+                        autoref: autoref,\n+                        unsize: unsize\n+                    },\n+                    target: transformed_self_ty\n+                });\n             }\n         }\n "}, {"sha": "1c9c80bb7fc614c94869fd716d431191ee7f1b2f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -1564,20 +1564,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn write_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n-                                      derefs: usize) {\n-        self.write_adjustment(\n-            node_id,\n-            adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n+                                      derefs: usize,\n+                                      adjusted_ty: Ty<'tcx>) {\n+        self.write_adjustment(node_id, adjustment::Adjustment {\n+            kind: adjustment::Adjust::DerefRef {\n                 autoderefs: derefs,\n                 autoref: None,\n-                unsize: None\n-            })\n-        );\n+                unsize: false\n+            },\n+            target: adjusted_ty\n+        });\n     }\n \n     pub fn write_adjustment(&self,\n                             node_id: ast::NodeId,\n-                            adj: adjustment::AutoAdjustment<'tcx>) {\n+                            adj: adjustment::Adjustment<'tcx>) {\n         debug!(\"write_adjustment(node_id={}, adj={:?})\", node_id, adj);\n \n         if adj.is_identity() {\n@@ -1743,21 +1744,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    /// Apply `adjustment` to the type of `expr`\n-    pub fn adjust_expr_ty(&self,\n-                          expr: &hir::Expr,\n-                          adjustment: Option<&adjustment::AutoAdjustment<'tcx>>)\n-                          -> Ty<'tcx>\n-    {\n-        let raw_ty = self.node_ty(expr.id);\n-        let raw_ty = self.shallow_resolve(raw_ty);\n-        let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n-        raw_ty.adjust(self.tcx, expr.span, expr.id, adjustment, |method_call| {\n-            self.tables.borrow().method_map.get(&method_call)\n-                                        .map(|method| resolve_ty(method.ty))\n-        })\n-    }\n-\n     pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n         match self.tables.borrow().node_types.get(&id) {\n             Some(&t) => t,\n@@ -2294,7 +2280,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 debug!(\"try_index_step: success, using built-in indexing\");\n                 // If we had `[T; N]`, we should've caught it before unsizing to `[T]`.\n                 assert!(!unsize);\n-                self.write_autoderef_adjustment(base_expr.id, autoderefs);\n+                self.write_autoderef_adjustment(base_expr.id, autoderefs, adjusted_ty);\n                 return Some((tcx.types.usize, ty));\n             }\n             _ => {}\n@@ -2850,9 +2836,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // In case we did perform an adjustment, we have to update\n                 // the type of the block, because old trans still uses it.\n-                let adj = self.tables.borrow().adjustments.get(&then.id).cloned();\n-                if res.is_ok() && adj.is_some() {\n-                    self.write_ty(then_blk.id, self.adjust_expr_ty(then, adj.as_ref()));\n+                if res.is_ok() {\n+                    let adj = self.tables.borrow().adjustments.get(&then.id).cloned();\n+                    if let Some(adj) = adj {\n+                        self.write_ty(then_blk.id, adj.target);\n+                    }\n                 }\n \n                 res\n@@ -2913,7 +2901,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n                             autoderef.finalize(lvalue_pref, Some(base));\n-                            self.write_autoderef_adjustment(base.id, autoderefs);\n+                            self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n                             return field_ty;\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n@@ -3031,7 +3019,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if let Some(field_ty) = field {\n                 autoderef.finalize(lvalue_pref, Some(base));\n-                self.write_autoderef_adjustment(base.id, autoderefs);\n+                self.write_autoderef_adjustment(base.id, autoderefs, base_t);\n                 return field_ty;\n             }\n         }\n@@ -3341,8 +3329,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if ty.is_never() {\n             if let Some(hir::map::NodeExpr(_)) = self.tcx.map.find(expr.id) {\n                 let adj_ty = self.next_diverging_ty_var();\n-                let adj = adjustment::AdjustNeverToAny(adj_ty);\n-                self.write_adjustment(expr.id, adj);\n+                self.write_adjustment(expr.id, adjustment::Adjustment {\n+                    kind: adjustment::Adjust::NeverToAny,\n+                    target: adj_ty\n+                });\n                 return adj_ty;\n             }\n         }"}, {"sha": "63f7a59f24fde2148d4a33b6fa4b82ab19cf6d4a", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 28, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -259,23 +259,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.resolve_type(t)\n     }\n \n-    fn resolve_method_type(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n-        let method_ty = self.tables.borrow().method_map\n-                            .get(&method_call).map(|method| method.ty);\n-        method_ty.map(|method_ty| self.resolve_type(method_ty))\n-    }\n-\n     /// Try to resolve the type for the given node.\n     pub fn resolve_expr_type_adjusted(&mut self, expr: &hir::Expr) -> Ty<'tcx> {\n-        let ty_unadjusted = self.resolve_node_type(expr.id);\n-        if ty_unadjusted.references_error() {\n-            ty_unadjusted\n-        } else {\n-            ty_unadjusted.adjust(\n-                self.tcx, expr.span, expr.id,\n-                self.tables.borrow().adjustments.get(&expr.id),\n-                |method_call| self.resolve_method_type(method_call))\n-        }\n+        let ty = self.tables.borrow().expr_ty_adjusted(expr);\n+        self.resolve_type(ty)\n     }\n \n     fn visit_fn_body(&mut self,\n@@ -558,10 +545,8 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n         let adjustment = self.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n         if let Some(adjustment) = adjustment {\n             debug!(\"adjustment={:?}\", adjustment);\n-            match adjustment {\n-                adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n-                    autoderefs, ref autoref, ..\n-                }) => {\n+            match adjustment.kind {\n+                adjustment::Adjust::DerefRef { autoderefs, ref autoref, .. } => {\n                     let expr_ty = self.resolve_node_type(expr.id);\n                     self.constrain_autoderefs(expr, autoderefs, expr_ty);\n                     if let Some(ref autoref) = *autoref {\n@@ -951,7 +936,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     let origin = infer::ParameterOrigin::OverloadedDeref;\n                     self.substs_wf_in_scope(origin, method.substs, deref_expr.span, r_deref_expr);\n \n-                    // Treat overloaded autoderefs as if an AutoRef adjustment\n+                    // Treat overloaded autoderefs as if an AutoBorrow adjustment\n                     // was applied on the base type, as that is always the case.\n                     let fn_sig = method.ty.fn_sig();\n                     let fn_sig = // late-bound regions should have been instantiated\n@@ -1065,15 +1050,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         id: ast::NodeId,\n         minimum_lifetime: &'tcx ty::Region)\n     {\n-        let tcx = self.tcx;\n-\n         // Try to resolve the type.  If we encounter an error, then typeck\n         // is going to fail anyway, so just stop here and let typeck\n         // report errors later on in the writeback phase.\n         let ty0 = self.resolve_node_type(id);\n-        let ty = ty0.adjust(tcx, origin.span(), id,\n-                            self.tables.borrow().adjustments.get(&id),\n-                            |method_call| self.resolve_method_type(method_call));\n+        let ty = self.tables.borrow().adjustments.get(&id).map_or(ty0, |adj| adj.target);\n+        let ty = self.resolve_type(ty);\n         debug!(\"constrain_regions_in_type_of_node(\\\n                 ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n                 ty,  ty0,\n@@ -1170,20 +1152,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn link_autoref(&self,\n                     expr: &hir::Expr,\n                     autoderefs: usize,\n-                    autoref: &adjustment::AutoRef<'tcx>)\n+                    autoref: &adjustment::AutoBorrow<'tcx>)\n     {\n         debug!(\"link_autoref(autoref={:?})\", autoref);\n         let mc = mc::MemCategorizationContext::new(self);\n         let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n         debug!(\"expr_cmt={:?}\", expr_cmt);\n \n         match *autoref {\n-            adjustment::AutoPtr(r, m) => {\n+            adjustment::AutoBorrow::Ref(r, m) => {\n                 self.link_region(expr.span, r,\n                                  ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n \n-            adjustment::AutoUnsafe(m) => {\n+            adjustment::AutoBorrow::RawPtr(m) => {\n                 let r = self.tcx.node_scope_region(expr.id);\n                 self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }"}, {"sha": "5ef3e8699602b5437d93a813b7a04ce2addc8586", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d7201ef46b9bdf8474b07b839d029e56d4f29b7/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0d7201ef46b9bdf8474b07b839d029e56d4f29b7", "patch": "@@ -381,36 +381,40 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             }\n \n             Some(adjustment) => {\n-                let resolved_adjustment = match adjustment {\n-                    adjustment::AdjustNeverToAny(ty) => {\n-                        adjustment::AdjustNeverToAny(self.resolve(&ty, reason))\n+                let resolved_adjustment = match adjustment.kind {\n+                    adjustment::Adjust::NeverToAny => {\n+                        adjustment::Adjust::NeverToAny\n                     }\n \n-                    adjustment::AdjustReifyFnPointer => {\n-                        adjustment::AdjustReifyFnPointer\n+                    adjustment::Adjust::ReifyFnPointer => {\n+                        adjustment::Adjust::ReifyFnPointer\n                     }\n \n-                    adjustment::AdjustMutToConstPointer => {\n-                        adjustment::AdjustMutToConstPointer\n+                    adjustment::Adjust::MutToConstPointer => {\n+                        adjustment::Adjust::MutToConstPointer\n                     }\n \n-                    adjustment::AdjustUnsafeFnPointer => {\n-                        adjustment::AdjustUnsafeFnPointer\n+                    adjustment::Adjust::UnsafeFnPointer => {\n+                        adjustment::Adjust::UnsafeFnPointer\n                     }\n \n-                    adjustment::AdjustDerefRef(adj) => {\n-                        for autoderef in 0..adj.autoderefs {\n+                    adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n+                        for autoderef in 0..autoderefs {\n                             let method_call = MethodCall::autoderef(id, autoderef as u32);\n                             self.visit_method_map_entry(reason, method_call);\n                         }\n \n-                        adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n-                            autoderefs: adj.autoderefs,\n-                            autoref: self.resolve(&adj.autoref, reason),\n-                            unsize: self.resolve(&adj.unsize, reason),\n-                        })\n+                        adjustment::Adjust::DerefRef {\n+                            autoderefs: autoderefs,\n+                            autoref: self.resolve(&autoref, reason),\n+                            unsize: unsize,\n+                        }\n                     }\n                 };\n+                let resolved_adjustment = adjustment::Adjustment {\n+                    kind: resolved_adjustment,\n+                    target: self.resolve(&adjustment.target, reason)\n+                };\n                 debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n                 self.tcx().tables.borrow_mut().adjustments.insert(\n                     id, resolved_adjustment);"}]}