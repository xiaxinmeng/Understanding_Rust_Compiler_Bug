{"sha": "8597077b7ace2a16b3c6c7c9e37eeb47f758194f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1OTcwNzdiN2FjZTJhMTZiM2M2YzdjOWUzN2VlYjQ3Zjc1ODE5NGY=", "commit": {"author": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2011-12-14T20:14:06Z"}, "committer": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2011-12-19T04:46:39Z"}, "message": "Clean up some names and factor out some common code.", "tree": {"sha": "cdc8d2a26b54ffb1c2c89f5da5c3361c9c470e1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdc8d2a26b54ffb1c2c89f5da5c3361c9c470e1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8597077b7ace2a16b3c6c7c9e37eeb47f758194f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8597077b7ace2a16b3c6c7c9e37eeb47f758194f", "html_url": "https://github.com/rust-lang/rust/commit/8597077b7ace2a16b3c6c7c9e37eeb47f758194f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8597077b7ace2a16b3c6c7c9e37eeb47f758194f/comments", "author": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61e8b44f2051e31e41c2ea45841c77c5ec7eec59", "url": "https://api.github.com/repos/rust-lang/rust/commits/61e8b44f2051e31e41c2ea45841c77c5ec7eec59", "html_url": "https://github.com/rust-lang/rust/commit/61e8b44f2051e31e41c2ea45841c77c5ec7eec59"}], "stats": {"total": 378, "additions": 164, "deletions": 214}, "files": [{"sha": "2c249a64d4aa10b309b259905365bfd13979b534", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 161, "deletions": 210, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/8597077b7ace2a16b3c6c7c9e37eeb47f758194f/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8597077b7ace2a16b3c6c7c9e37eeb47f758194f/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=8597077b7ace2a16b3c6c7c9e37eeb47f758194f", "patch": "@@ -8,6 +8,15 @@ import syntax::{ast, codemap};\n import ast::ty;\n import util::ppaux::ty_to_str;\n \n+export create_local_var;\n+export create_function;\n+export create_arg;\n+export add_line_info;\n+export update_source_pos;\n+export invalidate_source_pos;\n+export revalidate_source_pos;\n+export debug_ctxt;\n+\n const LLVMDebugVersion: int = (9 << 16);\n \n const DW_LANG_RUST: int = 0x9000;\n@@ -35,13 +44,11 @@ const DW_ATE_signed_char: int = 0x06;\n const DW_ATE_unsigned: int = 0x07;\n const DW_ATE_unsigned_char: int = 0x08;\n \n-fn as_buf(s: str) -> str::sbuf {\n-    str::as_buf(s, {|sbuf| sbuf})\n-}\n fn llstr(s: str) -> ValueRef {\n-    llvm::LLVMMDString(as_buf(s), str::byte_len(s))\n+    str::as_buf(s, {|sbuf|\n+        llvm::LLVMMDString(sbuf, str::byte_len(s))\n+    })\n }\n-\n fn lltag(lltag: int) -> ValueRef {\n     lli32(LLVMDebugVersion | lltag)\n }\n@@ -65,25 +72,27 @@ fn llnull() -> ValueRef unsafe {\n     unsafe::reinterpret_cast(std::ptr::null::<ValueRef>())\n }\n \n-fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n-    let existing = if cache.contains_key(mdtag) {\n-        cache.get(mdtag)\n-    } else {\n-        []\n-    };\n-    cache.insert(mdtag, existing + [val]);\n+fn add_named_metadata(cx: @crate_ctxt, name: str, val: ValueRef) {\n+    str::as_buf(name, {|sbuf|\n+        llvm::LLVMAddNamedMetadataOperand(cx.llmod, sbuf, str::byte_len(name), val)\n+    })\n }\n \n ////////////////\n \n type debug_ctxt = {\n     llmetadata: metadata_cache,\n-    //llmod: ValueRef,\n-    //opt: bool,\n     names: trans_common::namegen\n };\n \n-////////////////\n+fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n+    let existing = if cache.contains_key(mdtag) {\n+        cache.get(mdtag)\n+    } else {\n+        []\n+    };\n+    cache.insert(mdtag, existing + [val]);\n+}\n \n type metadata<T> = {node: ValueRef, data: T};\n \n@@ -143,17 +152,19 @@ fn cached_metadata<copy T>(cache: metadata_cache, mdtag: int,\n     ret option::none;\n }\n \n-fn get_compile_unit_metadata(cx: @crate_ctxt, full_path: str)\n+fn create_compile_unit(cx: @crate_ctxt, full_path: str)\n     -> @metadata<compile_unit_md> {\n     let cache = get_cache(cx);\n-    alt cached_metadata::<@metadata<compile_unit_md>>(cache, CompileUnitTag,\n+    let tg = CompileUnitTag;\n+    alt cached_metadata::<@metadata<compile_unit_md>>(cache, tg,\n                         {|md| md.data.path == full_path}) {\n       option::some(md) { ret md; }\n       option::none. {}\n     }\n+\n     let fname = fs::basename(full_path);\n     let path = fs::dirname(full_path);\n-    let unit_metadata = [lltag(CompileUnitTag),\n+    let unit_metadata = [lltag(tg),\n                          llunused(),\n                          lli32(DW_LANG_RUST),\n                          llstr(fname),\n@@ -169,29 +180,28 @@ fn get_compile_unit_metadata(cx: @crate_ctxt, full_path: str)\n                          // list of global variables\n                         ];\n     let unit_node = llmdnode(unit_metadata);\n-    llvm::LLVMAddNamedMetadataOperand(cx.llmod, as_buf(\"llvm.dbg.cu\"),\n-                                  str::byte_len(\"llvm.dbg.cu\"),\n-                                  unit_node);\n+    add_named_metadata(cx, \"llvm.dbg.cu\", unit_node);\n     let mdval = @{node: unit_node, data: {path: full_path}};\n-    update_cache(cache, CompileUnitTag, compile_unit_metadata(mdval));\n+    update_cache(cache, tg, compile_unit_metadata(mdval));\n     ret mdval;\n }\n \n fn get_cache(cx: @crate_ctxt) -> metadata_cache {\n     option::get(cx.dbg_cx).llmetadata\n }\n \n-fn get_file_metadata(cx: @crate_ctxt, full_path: str) -> @metadata<file_md> {\n+fn create_file(cx: @crate_ctxt, full_path: str) -> @metadata<file_md> {\n     let cache = get_cache(cx);;\n     let tg = FileDescriptorTag;\n     alt cached_metadata::<@metadata<file_md>>(\n         cache, tg, {|md| md.data.path == full_path}) {\n         option::some(md) { ret md; }\n         option::none. {}\n     }\n+\n     let fname = fs::basename(full_path);\n     let path = fs::dirname(full_path);\n-    let unit_node = get_compile_unit_metadata(cx, full_path).node;\n+    let unit_node = create_compile_unit(cx, full_path).node;\n     let file_md = [lltag(tg),\n                    llstr(fname),\n                    llstr(path),\n@@ -206,7 +216,7 @@ fn line_from_span(cm: codemap::codemap, sp: codemap::span) -> uint {\n     codemap::lookup_char_pos(cm, sp.lo).line\n }\n \n-fn get_block_metadata(cx: @block_ctxt) -> @metadata<block_md> {\n+fn create_block(cx: @block_ctxt) -> @metadata<block_md> {\n     let cache = get_cache(bcx_ccx(cx));\n     let start = codemap::lookup_char_pos(bcx_ccx(cx).sess.get_codemap(),\n                                          cx.sp.lo);\n@@ -220,11 +230,12 @@ fn get_block_metadata(cx: @block_ctxt) -> @metadata<block_md> {\n       option::some(md) { ret md; }\n       option::none. {}\n     }\n+\n     let parent = alt cx.parent {\n       trans_common::parent_none. { function_metadata_from_block(cx).node }\n-      trans_common::parent_some(bcx) { get_block_metadata(cx).node }\n+      trans_common::parent_some(bcx) { create_block(cx).node }\n     };\n-    let file_node = get_file_metadata(bcx_ccx(cx), fname);\n+    let file_node = create_file(bcx_ccx(cx), fname);\n     let unique_id = alt cache.find(LexicalBlockTag) {\n       option::some(v) { vec::len(v) as int }\n       option::none. { 0 }\n@@ -246,7 +257,7 @@ fn size_and_align_of<T>() -> (int, int) {\n     (sys::size_of::<T>() as int, sys::align_of::<T>() as int)\n }\n \n-fn get_basic_type_metadata(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n+fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n     -> @metadata<tydesc_md> {\n     let cache = get_cache(cx);\n     let tg = BasicTypeDescriptorTag;\n@@ -256,6 +267,7 @@ fn get_basic_type_metadata(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n       option::some(md) { ret md; }\n       option::none. {}\n     }\n+\n     let (name, (size, align), encoding) = alt ty.node {\n       ast::ty_bool. {(\"bool\", size_and_align_of::<bool>(), DW_ATE_boolean)}\n       ast::ty_int(m) { alt m {\n@@ -279,9 +291,10 @@ fn get_basic_type_metadata(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n         ast::ty_f64. {(\"f64\", size_and_align_of::<f64>(), DW_ATE_float)}\n       }}\n     };\n+\n     let fname = filename_from_span(cx, ty.span);\n-    let file_node = get_file_metadata(cx, fname);\n-    let cu_node = get_compile_unit_metadata(cx, fname);\n+    let file_node = create_file(cx, fname);\n+    let cu_node = create_compile_unit(cx, fname);\n     let lldata = [lltag(tg),\n                   cu_node.node,\n                   llstr(name),\n@@ -295,14 +308,12 @@ fn get_basic_type_metadata(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n     let llnode = llmdnode(lldata);\n     let mdval = @{node: llnode, data: {hash: ty::hash_ty(t)}};\n     update_cache(cache, tg, tydesc_metadata(mdval));\n-    llvm::LLVMAddNamedMetadataOperand(cx.llmod, as_buf(\"llvm.dbg.ty\"),\n-                                      str::byte_len(\"llvm.dbg.ty\"),\n-                                      llnode);\n+    add_named_metadata(cx, \"llvm.dbg.ty\", llnode);\n     ret mdval;\n }\n \n-fn get_pointer_type_metadata(cx: @crate_ctxt, t: ty::t, span: codemap::span,\n-                             pointee: @metadata<tydesc_md>)\n+fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: codemap::span,\n+                       pointee: @metadata<tydesc_md>)\n     -> @metadata<tydesc_md> {\n     let tg = PointerTypeTag;\n     /*let cache = cx.llmetadata;\n@@ -313,24 +324,13 @@ fn get_pointer_type_metadata(cx: @crate_ctxt, t: ty::t, span: codemap::span,\n     }*/\n     let (size, align) = size_and_align_of::<ctypes::intptr_t>();\n     let fname = filename_from_span(cx, span);\n-    let file_node = get_file_metadata(cx, fname);\n-    //let cu_node = get_compile_unit_metadata(cx, fname);\n-    let lldata = [lltag(tg),\n-                  file_node.node,\n-                  llstr(\"\"),\n-                  file_node.node,\n-                  lli32(0), //XXX source line\n-                  lli64(size * 8),  // size in bits\n-                  lli64(align * 8), // alignment in bits\n-                  lli64(0), //XXX offset?\n-                  lli32(0),\n-                  pointee.node];\n-    let llnode = llmdnode(lldata);\n+    let file_node = create_file(cx, fname);\n+    //let cu_node = create_compile_unit(cx, fname);\n+    let llnode = create_derived_type(tg, file_node.node, \"\", 0, size * 8,\n+                                     align * 8, 0, pointee.node);\n     let mdval = @{node: llnode, data: {hash: ty::hash_ty(t)}};\n     //update_cache(cache, tg, tydesc_metadata(mdval));\n-    llvm::LLVMAddNamedMetadataOperand(cx.llmod, as_buf(\"llvm.dbg.ty\"),\n-                                      str::byte_len(\"llvm.dbg.ty\"),\n-                                      llnode);\n+    add_named_metadata(cx, \"llvm.dbg.ty\", llnode);\n     ret mdval;\n }\n \n@@ -361,33 +361,40 @@ fn create_structure(file: @metadata<file_md>, name: str, line: int)\n     ret cx;\n }\n \n-fn add_member(cx: @struct_ctxt, name: str, line: int, size: int, align: int,\n-              ty: ValueRef) {\n-    let lldata = [lltag(MemberTag),\n-                  cx.file,\n+fn create_derived_type(type_tag: int, file: ValueRef, name: str, line: int,\n+                       size: int, align: int, offset: int, ty: ValueRef)\n+    -> ValueRef {\n+    let lldata = [lltag(type_tag),\n+                  file,\n                   llstr(name),\n-                  cx.file,\n+                  file,\n                   lli32(line),\n-                  lli64(size * 8),\n-                  lli64(align * 8),\n-                  lli64(cx.total_size),\n+                  lli64(size),\n+                  lli64(align),\n+                  lli64(offset),\n                   lli32(0),\n                   ty];\n+    ret llmdnode(lldata);\n+}\n+\n+fn add_member(cx: @struct_ctxt, name: str, line: int, size: int, align: int,\n+              ty: ValueRef) {\n+    cx.members += [create_derived_type(MemberTag, cx.file, name, line, size * 8,\n+                                       align * 8, cx.total_size, ty)];\n     cx.total_size += size * 8;\n-    cx.members += [llmdnode(lldata)];\n }\n \n-fn get_record_metadata(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n-                       span: codemap::span) -> @metadata<tydesc_md> {\n+fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n+                 span: codemap::span) -> @metadata<tydesc_md> {\n     let fname = filename_from_span(cx, span);\n-    let file_node = get_file_metadata(cx, fname);\n+    let file_node = create_file(cx, fname);\n     let scx = create_structure(file_node,\n                                option::get(cx.dbg_cx).names.next(\"rec\"),\n                                line_from_span(cx.sess.get_codemap(),\n                                               span) as int);\n     for field in fields {\n         let field_t = ty::get_field(ccx_tcx(cx), t, field.node.ident).mt.ty;\n-        let ty_md = get_ty_metadata(cx, field_t, field.node.mt.ty);\n+        let ty_md = create_ty(cx, field_t, field.node.mt.ty);\n         let (size, align) = member_size_and_align(field.node.mt.ty);\n         add_member(scx, field.node.ident,\n                    line_from_span(cx.sess.get_codemap(), field.span) as int,\n@@ -397,23 +404,23 @@ fn get_record_metadata(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n     ret mdval;\n }\n \n-fn get_boxed_type_metadata(cx: @crate_ctxt, outer: ty::t, inner: ty::t,\n-                           span: codemap::span, boxed: @metadata<tydesc_md>)\n+fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n+                     span: codemap::span, boxed: @metadata<tydesc_md>)\n     -> @metadata<tydesc_md> {\n-    let tg = StructureTypeTag;\n+    //let tg = StructureTypeTag;\n     /*let cache = cx.llmetadata;\n     alt cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, {|md| ty::hash_ty(outer) == ty::hash_ty(md.data.hash)}) {\n       option::some(md) { ret md; }\n       option::none. {}\n     }*/\n     let fname = filename_from_span(cx, span);\n-    let file_node = get_file_metadata(cx, fname);\n-    //let cu_node = get_compile_unit_metadata(cx, fname);\n+    let file_node = create_file(cx, fname);\n+    //let cu_node = create_compile_unit_metadata(cx, fname);\n     let tcx = ccx_tcx(cx);\n     let uint_t = ty::mk_uint(tcx);\n     let uint_ty = @{node: ast::ty_uint(ast::ty_u), span: span};\n-    let refcount_type = get_basic_type_metadata(cx, uint_t, uint_ty);\n+    let refcount_type = create_basic_type(cx, uint_t, uint_ty);\n     let scx = create_structure(file_node, ty_to_str(ccx_tcx(cx), outer), 0);\n     add_member(scx, \"refcnt\", 0, sys::size_of::<uint>() as int, \n                sys::align_of::<uint>() as int, refcount_type.node);\n@@ -423,9 +430,7 @@ fn get_boxed_type_metadata(cx: @crate_ctxt, outer: ty::t, inner: ty::t,\n     let llnode = finish_structure(scx);\n     let mdval = @{node: llnode, data: {hash: outer}};\n     //update_cache(cache, tg, tydesc_metadata(mdval));\n-    llvm::LLVMAddNamedMetadataOperand(cx.llmod, as_buf(\"llvm.dbg.ty\"),\n-                                      str::byte_len(\"llvm.dbg.ty\"),\n-                                      llnode);\n+    add_named_metadata(cx, \"llvm.dbg.ty\", llnode);\n     ret mdval;\n }\n \n@@ -453,16 +458,16 @@ fn create_composite_type(type_tag: int, name: str, file: ValueRef, line: int,\n     ret llmdnode(lldata);\n }\n \n-fn get_vec_metadata(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t, vec_ty: @ast::ty)\n+fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t, vec_ty: @ast::ty)\n     -> @metadata<tydesc_md> {\n     let fname = filename_from_span(cx, vec_ty.span);\n-    let file_node = get_file_metadata(cx, fname);\n+    let file_node = create_file(cx, fname);\n     let elem_ty = alt vec_ty.node { ast::ty_vec(mt) { mt.ty } };\n-    let elem_ty_md = get_ty_metadata(cx, elem_t, elem_ty);\n+    let elem_ty_md = create_ty(cx, elem_t, elem_ty);\n     let tcx = ccx_tcx(cx);\n     let scx = create_structure(file_node, ty_to_str(tcx, vec_t), 0);\n     let uint_ty = @{node: ast::ty_uint(ast::ty_u), span: vec_ty.span};\n-    let size_t_type = get_basic_type_metadata(cx, ty::mk_uint(tcx), uint_ty);\n+    let size_t_type = create_basic_type(cx, ty::mk_uint(tcx), uint_ty);\n     add_member(scx, \"fill\", 0, sys::size_of::<ctypes::size_t>() as int,\n                sys::align_of::<ctypes::size_t>() as int, size_t_type.node);\n     add_member(scx, \"alloc\", 0, sys::size_of::<ctypes::size_t>() as int,\n@@ -517,7 +522,7 @@ fn member_size_and_align(ty: @ast::ty) -> (int, int) {\n     }\n }\n \n-fn get_ty_metadata(cx: @crate_ctxt, t: ty::t, ty: @ast::ty) -> @metadata<tydesc_md> {\n+fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty) -> @metadata<tydesc_md> {\n     /*let cache = get_cache(cx);\n     alt cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, {|md| t == md.data.hash}) {\n@@ -558,30 +563,35 @@ fn get_ty_metadata(cx: @crate_ctxt, t: ty::t, ty: @ast::ty) -> @metadata<tydesc_\n         let inner_t = alt ty::struct(ccx_tcx(cx), t) {\n           ty::ty_box(boxed) { boxed.ty }\n         };\n-        let md = get_ty_metadata(cx, inner_t, mt.ty);\n-        let box = get_boxed_type_metadata(cx, t, inner_t, ty.span, md);\n-        ret get_pointer_type_metadata(cx, t, ty.span, box);\n+        let md = create_ty(cx, inner_t, mt.ty);\n+        let box = create_boxed_type(cx, t, inner_t, ty.span, md);\n+        ret create_pointer_type(cx, t, ty.span, box);\n       }\n+\n       ast::ty_uniq(mt) {\n         let inner_t = alt ty::struct(ccx_tcx(cx), t) {\n           ty::ty_uniq(boxed) { boxed.ty }\n         };\n-        let md = get_ty_metadata(cx, inner_t, mt.ty);\n-        ret get_pointer_type_metadata(cx, t, ty.span, md);\n+        let md = create_ty(cx, inner_t, mt.ty);\n+        ret create_pointer_type(cx, t, ty.span, md);\n       }\n+\n       ast::ty_infer. {\n         let inferred = t_to_ty(cx, t, ty.span);\n-        ret get_ty_metadata(cx, t, inferred);\n+        ret create_ty(cx, t, inferred);\n       }\n+\n       ast::ty_rec(fields) {\n-        ret get_record_metadata(cx, t, fields, ty.span);\n+        ret create_record(cx, t, fields, ty.span);\n       }\n+\n       ast::ty_vec(mt) {\n         let inner_t = ty::sequence_element_type(ccx_tcx(cx), t);\n-        let v = get_vec_metadata(cx, t, inner_t, ty);\n-        ret get_pointer_type_metadata(cx, t, ty.span, v);\n+        let v = create_vec(cx, t, inner_t, ty);\n+        ret create_pointer_type(cx, t, ty.span, v);\n       }\n-      _ { ret get_basic_type_metadata(cx, t, ty); }\n+\n+      _ { ret create_basic_type(cx, t, ty); }\n     };\n }\n \n@@ -590,45 +600,54 @@ fn function_metadata_from_block(bcx: @block_ctxt) -> @metadata<subprogram_md> {\n     let fcx = bcx_fcx(bcx);\n     let fn_node = cx.ast_map.get(fcx.id);\n     let fn_item = alt fn_node { ast_map::node_item(item) { item } };\n-    get_function_metadata(fcx, fn_item, fcx.llfn)\n+    ret create_function(fcx, fn_item, fcx.llfn);\n }\n \n fn filename_from_span(cx: @crate_ctxt, sp: codemap::span) -> str {\n     codemap::lookup_char_pos(cx.sess.get_codemap(), sp.lo).filename\n }\n \n-fn get_local_var_metadata(bcx: @block_ctxt, local: @ast::local)\n+fn create_var(type_tag: int, context: ValueRef, name: str, file: ValueRef,\n+              line: int, ret_ty: ValueRef) -> ValueRef {\n+    let lldata = [lltag(type_tag),\n+                  context,\n+                  llstr(name),\n+                  file,\n+                  lli32(line),\n+                  ret_ty,\n+                  lli32(0)\n+                 ];\n+    ret llmdnode(lldata);\n+}\n+\n+fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n     -> @metadata<local_var_md> unsafe {\n     let cx = bcx_ccx(bcx);\n     let cache = get_cache(cx);\n+    let tg = AutoVariableTag;\n     alt cached_metadata::<@metadata<local_var_md>>(\n-        cache, AutoVariableTag, {|md| md.data.id == local.node.id}) {\n+        cache, tg, {|md| md.data.id == local.node.id}) {\n       option::some(md) { ret md; }\n       option::none. {}\n     }\n+\n     let name = alt local.node.pat.node {\n       ast::pat_bind(ident) { ident }\n     };\n     let loc = codemap::lookup_char_pos(cx.sess.get_codemap(),\n                                        local.span.lo);\n     let ty = trans::node_id_type(cx, local.node.id);\n-    let tymd = get_ty_metadata(cx, ty, local.node.ty);\n-    let filemd = get_file_metadata(cx, loc.filename);\n+    let tymd = create_ty(cx, ty, local.node.ty);\n+    let filemd = create_file(cx, loc.filename);\n     let context = alt bcx.parent {\n       trans_common::parent_none. { function_metadata_from_block(bcx).node }\n-      trans_common::parent_some(_) { get_block_metadata(bcx).node }\n+      trans_common::parent_some(_) { create_block(bcx).node }\n     };\n-    let lldata = [lltag(AutoVariableTag),\n-                  context, // context\n-                  llstr(name), // name\n-                  filemd.node,\n-                  lli32(loc.line as int), // line\n-                  tymd.node,\n-                  lli32(0) //XXX flags\n-                 ];\n-    let mdnode = llmdnode(lldata);\n+    let mdnode = create_var(tg, context, name, filemd.node,\n+                            loc.line as int, tymd.node);\n     let mdval = @{node: mdnode, data: {id: local.node.id}};\n     update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n+\n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       option::some(local_mem(v)) { v }\n       option::none. {\n@@ -643,89 +662,35 @@ fn get_local_var_metadata(bcx: @block_ctxt, local: @ast::local)\n     ret mdval;\n }\n \n-//FIXME: consolidate with get_local_var_metadata\n-/*fn get_retval_metadata(bcx: @block_ctxt)\n-    -> @metadata<retval_md> unsafe {\n-    let fcx = bcx_fcx(bcx);\n-    let cx = fcx_ccx(fcx);\n-    let cache = cx.llmetadata;\n-    alt cached_metadata::<@metadata<retval_md>>(\n-        cache, ReturnVariableTag, {|md| md.data.id == fcx.id}) {\n-      option::some(md) { ret md; }\n-      option::none. {}\n-    }\n-    let item = alt option::get(cx.ast_map.find(fcx.id)) {\n-      ast_map::node_item(item) { item }\n-    };\n-    let loc = codemap::lookup_char_pos(cx.sess.get_codemap(),\n-                                       fcx.sp.lo);\n-    let ret_ty = alt item.node {\n-      ast::item_fn(f, _) { f.decl.output }\n-    };\n-    let ty_node = alt ret_ty.node {\n-      ast::ty_nil. { llnull() }\n-      _ { get_ty_metadata(cx, ty::node_id_to_type(ccx_tcx(cx), item.id),\n-                          ret_ty).node }\n-    };\n-    /*let ty_node = get_ty_metadata(cx, ty::node_id_to_type(ccx_tcx(cx), fcx.id),\n-                                  ty).node;*/\n-    //let ty = trans::node_id_type(cx, arg.id);\n-    //let tymd = get_ty_metadata(cx, ty, arg.ty);\n-    let filemd = get_file_metadata(cx, loc.filename);\n-    let fn_node = cx.ast_map.get(fcx.id);\n-    let fn_item = alt fn_node { ast_map::node_item(item) { item } };\n-    let context = get_function_metadata(fcx, fn_item, fcx.llfn);\n-    let lldata = [lltag(ReturnVariableTag),\n-                  context.node, // context\n-                  llstr(\"%0\"), // name\n-                  filemd.node,\n-                  lli32(loc.line as int), // line\n-                  ty_node,\n-                  lli32(0) //XXX flags\n-                 ];\n-    let mdnode = llmdnode(lldata);\n-    let mdval = @{node: mdnode, data: {id: fcx.id}};\n-    update_cache(cache, ReturnVariableTag, retval_metadata(mdval));\n-    let llptr = fcx.llretptr;\n-    let declargs = [llmdnode([llptr]), mdnode];\n-    trans_build::Call(bcx, cx.intrinsics.get(\"llvm.dbg.declare\"),\n-                      declargs);\n-    ret mdval;\n-}*/\n-\n-//FIXME: consolidate with get_local_var_metadata\n-fn get_arg_metadata(bcx: @block_ctxt, arg: ast::arg)\n+//FIXME: consolidate with create_local_var\n+fn create_arg(bcx: @block_ctxt, arg: ast::arg)\n     -> @metadata<argument_md> unsafe {\n     let fcx = bcx_fcx(bcx);\n     let cx = fcx_ccx(fcx);\n     let cache = get_cache(cx);\n+    let tg = ArgVariableTag;\n     alt cached_metadata::<@metadata<argument_md>>(\n         cache, ArgVariableTag, {|md| md.data.id == arg.id}) {\n       option::some(md) { ret md; }\n       option::none. {}\n     }\n-    let arg_n = alt cx.ast_map.get(arg.id) {\n+\n+    /*let arg_n = alt cx.ast_map.get(arg.id) {\n       ast_map::node_arg(_, n) { n - 2u }\n-    };\n+    };*/\n     let loc = codemap::lookup_char_pos(cx.sess.get_codemap(),\n                                        fcx.sp.lo);\n     let ty = trans::node_id_type(cx, arg.id);\n-    let tymd = get_ty_metadata(cx, ty, arg.ty);\n-    let filemd = get_file_metadata(cx, loc.filename);\n+    let tymd = create_ty(cx, ty, arg.ty);\n+    let filemd = create_file(cx, loc.filename);\n     let fn_node = cx.ast_map.get(fcx.id);\n     let fn_item = alt fn_node { ast_map::node_item(item) { item } };\n-    let context = get_function_metadata(fcx, fn_item, fcx.llfn);\n-    let lldata = [lltag(ArgVariableTag),\n-                  context.node, // context\n-                  llstr(arg.ident), // name\n-                  filemd.node,\n-                  lli32(loc.line as int), // line\n-                  tymd.node,\n-                  lli32(0) //XXX flags\n-                 ];\n-    let mdnode = llmdnode(lldata);\n+    let context = create_function(fcx, fn_item, fcx.llfn);\n+    let mdnode = create_var(tg, context.node, arg.ident, filemd.node,\n+                            loc.line as int, tymd.node);\n     let mdval = @{node: mdnode, data: {id: arg.id}};\n-    update_cache(cache, ArgVariableTag, argument_metadata(mdval));\n+    update_cache(cache, tg, argument_metadata(mdval));\n+\n     let llptr = alt fcx.llargs.get(arg.id) {\n       local_mem(v) | local_imm(v) { v }\n     };\n@@ -785,54 +750,46 @@ fn add_line_info(cx: @block_ctxt, llinstr: ValueRef) {\n         ret;\n     }\n     let loc = option::get(vec::last(cx.source_pos.pos));\n-    let blockmd = get_block_metadata(cx);\n-    let kind_id = llvm::LLVMGetMDKindID(as_buf(\"dbg\"),\n-                                        str::byte_len(\"dbg\"));\n-    let scopedata = [lli32(loc.line as int),\n-                     lli32(loc.col as int),\n-                     blockmd.node,\n-                     llnull()];\n-    let dbgscope = llmdnode(scopedata);\n-    llvm::LLVMSetMetadata(llinstr, kind_id, dbgscope);\n-}\n-\n-fn get_function_metadata(fcx: @fn_ctxt, item: @ast::item,\n-                         llfndecl: ValueRef) -> @metadata<subprogram_md> {\n+    let blockmd = create_block(cx);\n+    let kind = \"dbg\";\n+    str::as_buf(kind, {|sbuf| \n+        let kind_id = llvm::LLVMGetMDKindID(sbuf,\n+                                            str::byte_len(kind));\n+        let scopedata = [lli32(loc.line as int),\n+                         lli32(loc.col as int),\n+                         blockmd.node,\n+                         llnull()];\n+        let dbgscope = llmdnode(scopedata);\n+        llvm::LLVMSetMetadata(llinstr, kind_id, dbgscope)\n+    });\n+}\n+\n+fn create_function(fcx: @fn_ctxt, item: @ast::item, llfndecl: ValueRef)\n+    -> @metadata<subprogram_md> {\n     let cx = fcx_ccx(fcx);\n     let cache = get_cache(cx);\n     alt cached_metadata::<@metadata<subprogram_md>>(\n         cache, SubprogramTag, {|md| md.data.name == item.ident &&\n-                                    /*sub.path == ??*/ true}) {\n+                                    /*md.data.path == ??*/ true}) {\n       option::some(md) { ret md; }\n       option::none. {}\n     }\n+\n     let loc = codemap::lookup_char_pos(cx.sess.get_codemap(),\n-                                           item.span.lo);\n-    let file_node = get_file_metadata(cx, loc.filename).node;\n+                                       item.span.lo);\n+    let file_node = create_file(cx, loc.filename).node;\n     let mangled = cx.item_symbols.get(item.id);\n     let ret_ty = alt item.node {\n       ast::item_fn(f, _) { f.decl.output }\n     };\n     let ty_node = alt ret_ty.node {\n       ast::ty_nil. { llnull() }\n-      _ { get_ty_metadata(cx, ty::node_id_to_type(ccx_tcx(cx), item.id),\n-                          ret_ty).node }\n+      _ { create_ty(cx, ty::node_id_to_type(ccx_tcx(cx), item.id), ret_ty).node }\n     };\n-    let sub_type = llmdnode([ty_node]);\n-    let sub_metadata = [lltag(SubroutineTag),\n-                        file_node,\n-                        llstr(\"\"),\n-                        file_node,\n-                        lli32(0),\n-                        lli64(0),\n-                        lli64(0),\n-                        lli64(0),\n-                        lli32(0),\n-                        llnull(),\n-                        sub_type,\n-                        lli32(0),\n-                        llnull()];\n-    let sub_node = llmdnode(sub_metadata);\n+    let sub_node = create_composite_type(SubroutineTag, \"\", file_node, 0, 0,\n+                                         0, 0, option::none,\n+                                         option::some([ty_node]));\n+\n     let fn_metadata = [lltag(SubprogramTag),\n                        llunused(),\n                        file_node,\n@@ -855,15 +812,9 @@ fn get_function_metadata(fcx: @fn_ctxt, item: @ast::item,\n                        //list of func vars\n                       ];\n     let val = llmdnode(fn_metadata);\n-    llvm::LLVMAddNamedMetadataOperand(cx.llmod, as_buf(\"llvm.dbg.sp\"),\n-                                      str::byte_len(\"llvm.dbg.sp\"),\n-                                      val);\n+    add_named_metadata(cx, \"llvm.dbg.sp\", val);\n     let mdval = @{node: val, data: {name: item.ident,\n                                     file: loc.filename}};\n     update_cache(cache, SubprogramTag, subprogram_metadata(mdval));\n-    /*alt ret_ty.node {\n-      ast::ty_nil. {}\n-      _ { let _ = get_retval_metadata(fcx, ret_ty); }\n-    }*/\n     ret mdval;\n }"}, {"sha": "563f4d64cd2a943d6f4b6347daa280e2c25dbce2", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8597077b7ace2a16b3c6c7c9e37eeb47f758194f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8597077b7ace2a16b3c6c7c9e37eeb47f758194f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8597077b7ace2a16b3c6c7c9e37eeb47f758194f", "patch": "@@ -4028,7 +4028,7 @@ fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n                     bcx = init_ref_local(bcx, local);\n                 }\n                 if bcx_ccx(cx).sess.get_opts().debuginfo {\n-                    debuginfo::get_local_var_metadata(bcx, local);\n+                    debuginfo::create_local_var(bcx, local);\n                 }\n             }\n           }\n@@ -4426,7 +4426,6 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n         llvm::LLVMAddAttribute(llvm::LLVMGetFirstParam(fcx.llfn),\n                                lib::llvm::LLVMStructRetAttribute as\n                                    lib::llvm::llvm::Attribute);\n-        //let _ = debuginfo::get_retval_metadata(bcx);\n     }\n     let arg_n: uint = 0u, bcx = bcx;\n     for arg in arg_tys {\n@@ -4448,7 +4447,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n           ast::by_ref. {}\n         }\n         if fcx_ccx(fcx).sess.get_opts().debuginfo {\n-            let _ = debuginfo::get_arg_metadata(bcx, args[arg_n]);\n+            debuginfo::create_arg(bcx, args[arg_n]);\n         }\n         arg_n += 1u;\n     }\n@@ -4589,7 +4588,7 @@ fn trans_fn(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n         let item = alt option::get(cx.ccx.ast_map.find(id)) {\n             ast_map::node_item(item) { item }\n         };\n-        debuginfo::get_function_metadata(option::get(fcx), item, llfndecl);\n+        debuginfo::create_function(option::get(fcx), item, llfndecl);\n     }\n     if do_time {\n         let end = time::get_time();"}]}