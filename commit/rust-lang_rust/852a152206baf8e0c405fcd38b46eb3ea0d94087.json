{"sha": "852a152206baf8e0c405fcd38b46eb3ea0d94087", "node_id": "C_kwDOAAsO6NoAKDg1MmExNTIyMDZiYWY4ZTBjNDA1ZmNkMzhiNDZlYjNlYTBkOTQwODc", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-09-29T02:42:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-29T02:42:03Z"}, "message": "Rollup merge of #102085 - chenyukang:code-refactor, r=cjgillot\n\nCode refactoring smart_resolve_report_errors\n\n`smart_resolve_report_errors` https://github.com/rust-lang/rust/blob/4ecfdfac51b159f68fce608792affb34a70e6f73/compiler/rustc_resolve/src/late/diagnostics.rs#L143\nis almost 600 lines of code, we should do some code refactoring.", "tree": {"sha": "679570722f90b83429de996d29b99b07a55c6b7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/679570722f90b83429de996d29b99b07a55c6b7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/852a152206baf8e0c405fcd38b46eb3ea0d94087", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjNQX7CRBK7hj4Ov3rIwAAf3oIAHXbtf48OybTHqRwQW9SPfUn\n1YjSYC1Pibr9iyEx08UxAz4AsftCUIC/FkA1sfysCT1IzGghHuMD56qL24sApZjz\nYImlMbur9yv4gYtWAJ6oKw8HkuHzJ3Xa49PhxQKcAelVH8Ez/uFmzdMBax3Bva1g\nndqvKLs0hJdmwnK9qI4pgLQHcAn8Edww1YwcTyn1f6/afWQHrp5W1ZV8KSGn0NzI\n4Rpsz0vLiQFgKUA34Pnfjj8JNqj4+pu9I0Z9wMW0vLgG/yIcNb6ltGcjr9p+FJSB\nDHSdDASu8cr+LbwLX3TxXWd3AKmVU+EXvoIFx1wixcuZn7dRk4HFpsKwSBkekLU=\n=nKyC\n-----END PGP SIGNATURE-----\n", "payload": "tree 679570722f90b83429de996d29b99b07a55c6b7a\nparent 7cd4780c91139334b0a3a1f118b477506dd567dd\nparent db0877f653c61f79457f02ea0bb643017cbb2490\nauthor Yuki Okushi <jtitor@2k36.org> 1664419323 +0900\ncommitter GitHub <noreply@github.com> 1664419323 +0900\n\nRollup merge of #102085 - chenyukang:code-refactor, r=cjgillot\n\nCode refactoring smart_resolve_report_errors\n\n`smart_resolve_report_errors` https://github.com/rust-lang/rust/blob/4ecfdfac51b159f68fce608792affb34a70e6f73/compiler/rustc_resolve/src/late/diagnostics.rs#L143\nis almost 600 lines of code, we should do some code refactoring.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/852a152206baf8e0c405fcd38b46eb3ea0d94087", "html_url": "https://github.com/rust-lang/rust/commit/852a152206baf8e0c405fcd38b46eb3ea0d94087", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/852a152206baf8e0c405fcd38b46eb3ea0d94087/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7cd4780c91139334b0a3a1f118b477506dd567dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cd4780c91139334b0a3a1f118b477506dd567dd", "html_url": "https://github.com/rust-lang/rust/commit/7cd4780c91139334b0a3a1f118b477506dd567dd"}, {"sha": "db0877f653c61f79457f02ea0bb643017cbb2490", "url": "https://api.github.com/repos/rust-lang/rust/commits/db0877f653c61f79457f02ea0bb643017cbb2490", "html_url": "https://github.com/rust-lang/rust/commit/db0877f653c61f79457f02ea0bb643017cbb2490"}], "stats": {"total": 613, "additions": 366, "deletions": 247}, "files": [{"sha": "824cebd7e0a5bfb55f8ff52d59bf9710b89164b6", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 366, "deletions": 247, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/852a152206baf8e0c405fcd38b46eb3ea0d94087/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/852a152206baf8e0c405fcd38b46eb3ea0d94087/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=852a152206baf8e0c405fcd38b46eb3ea0d94087", "patch": "@@ -130,6 +130,16 @@ pub(super) enum LifetimeElisionCandidate {\n     Missing(MissingLifetime),\n }\n \n+/// Only used for diagnostics.\n+struct BaseError {\n+    msg: String,\n+    fallback_label: String,\n+    span: Span,\n+    span_label: Option<(Span, &'static str)>,\n+    could_be_expr: bool,\n+    suggestion: Option<(Span, &'static str, String)>,\n+}\n+\n impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     fn def_span(&self, def_id: DefId) -> Option<Span> {\n         match def_id.krate {\n@@ -138,35 +148,18 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n \n-    /// Handles error reporting for `smart_resolve_path_fragment` function.\n-    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n-    pub(crate) fn smart_resolve_report_errors(\n+    fn make_base_error(\n         &mut self,\n         path: &[Segment],\n         span: Span,\n         source: PathSource<'_>,\n         res: Option<Res>,\n-    ) -> (DiagnosticBuilder<'a, ErrorGuaranteed>, Vec<ImportSuggestion>) {\n-        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n-        let ns = source.namespace();\n-        let is_expected = &|res| source.is_expected(res);\n-        let is_enum_variant = &|res| matches!(res, Res::Def(DefKind::Variant, _));\n-\n-        debug!(?res, ?source);\n-\n+    ) -> BaseError {\n         // Make the base error.\n-        struct BaseError<'a> {\n-            msg: String,\n-            fallback_label: String,\n-            span: Span,\n-            span_label: Option<(Span, &'a str)>,\n-            could_be_expr: bool,\n-            suggestion: Option<(Span, &'a str, String)>,\n-        }\n         let mut expected = source.descr_expected();\n         let path_str = Segment::names_to_string(path);\n         let item_str = path.last().unwrap().ident;\n-        let base_error = if let Some(res) = res {\n+        if let Some(res) = res {\n             BaseError {\n                 msg: format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n                 fallback_label: format!(\"not a {expected}\"),\n@@ -277,8 +270,20 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 could_be_expr: false,\n                 suggestion,\n             }\n-        };\n+        }\n+    }\n \n+    /// Handles error reporting for `smart_resolve_path_fragment` function.\n+    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n+    pub(crate) fn smart_resolve_report_errors(\n+        &mut self,\n+        path: &[Segment],\n+        span: Span,\n+        source: PathSource<'_>,\n+        res: Option<Res>,\n+    ) -> (DiagnosticBuilder<'a, ErrorGuaranteed>, Vec<ImportSuggestion>) {\n+        debug!(?res, ?source);\n+        let base_error = self.make_base_error(path, span, source, res);\n         let code = source.error_code(res.is_some());\n         let mut err =\n             self.r.session.struct_span_err_with_code(base_error.span, &base_error.msg, code);\n@@ -289,41 +294,79 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             err.span_label(span, label);\n         }\n \n-        if let Some(sugg) = base_error.suggestion {\n-            err.span_suggestion_verbose(sugg.0, sugg.1, sugg.2, Applicability::MaybeIncorrect);\n+        if let Some(ref sugg) = base_error.suggestion {\n+            err.span_suggestion_verbose(sugg.0, sugg.1, &sugg.2, Applicability::MaybeIncorrect);\n         }\n \n-        if let Some(span) = self.diagnostic_metadata.current_block_could_be_bare_struct_literal {\n-            err.multipart_suggestion(\n-                \"you might have meant to write a `struct` literal\",\n-                vec![\n-                    (span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n-                    (span.shrink_to_hi(), \"}\".to_string()),\n-                ],\n-                Applicability::HasPlaceholders,\n-            );\n+        self.suggest_bare_struct_literal(&mut err);\n+        self.suggest_pattern_match_with_let(&mut err, source, span);\n+\n+        self.suggest_self_or_self_ref(&mut err, path, span);\n+        self.detect_assoct_type_constraint_meant_as_path(&mut err, &base_error);\n+        if self.suggest_self_ty(&mut err, source, path, span)\n+            || self.suggest_self_value(&mut err, source, path, span)\n+        {\n+            return (err, Vec::new());\n         }\n-        match (source, self.diagnostic_metadata.in_if_condition) {\n-            (\n-                PathSource::Expr(_),\n-                Some(Expr { span: expr_span, kind: ExprKind::Assign(lhs, _, _), .. }),\n-            ) => {\n-                // Icky heuristic so we don't suggest:\n-                // `if (i + 2) = 2` => `if let (i + 2) = 2` (approximately pattern)\n-                // `if 2 = i` => `if let 2 = i` (lhs needs to contain error span)\n-                if lhs.is_approximately_pattern() && lhs.span.contains(span) {\n-                    err.span_suggestion_verbose(\n-                        expr_span.shrink_to_lo(),\n-                        \"you might have meant to use pattern matching\",\n-                        \"let \",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+\n+        let (found, candidates) =\n+            self.try_lookup_name_relaxed(&mut err, source, path, span, res, &base_error);\n+        if found {\n+            return (err, candidates);\n+        }\n+\n+        if !self.type_ascription_suggestion(&mut err, base_error.span) {\n+            let mut fallback =\n+                self.suggest_trait_and_bounds(&mut err, source, res, span, &base_error);\n+            fallback |= self.suggest_typo(&mut err, source, path, span, &base_error);\n+            if fallback {\n+                // Fallback label.\n+                err.span_label(base_error.span, &base_error.fallback_label);\n+            }\n+        }\n+        self.err_code_special_cases(&mut err, source, path, span);\n+\n+        (err, candidates)\n+    }\n+\n+    fn detect_assoct_type_constraint_meant_as_path(\n+        &self,\n+        err: &mut Diagnostic,\n+        base_error: &BaseError,\n+    ) {\n+        let Some(ty) = self.diagnostic_metadata.current_type_path else { return; };\n+        let TyKind::Path(_, path) = &ty.kind else { return; };\n+        for segment in &path.segments {\n+            let Some(params) = &segment.args else { continue; };\n+            let ast::GenericArgs::AngleBracketed(ref params) = params.deref() else { continue; };\n+            for param in &params.args {\n+                let ast::AngleBracketedArg::Constraint(constraint) = param else { continue; };\n+                let ast::AssocConstraintKind::Bound { bounds } = &constraint.kind else {\n+                    continue;\n+                };\n+                for bound in bounds {\n+                    let ast::GenericBound::Trait(trait_ref, ast::TraitBoundModifier::None)\n+                        = bound else\n+                    {\n+                        continue;\n+                    };\n+                    if base_error.span == trait_ref.span {\n+                        err.span_suggestion_verbose(\n+                            constraint.ident.span.between(trait_ref.span),\n+                            \"you might have meant to write a path instead of an associated type bound\",\n+                            \"::\",\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n                 }\n             }\n-            _ => {}\n         }\n+    }\n \n+    fn suggest_self_or_self_ref(&mut self, err: &mut Diagnostic, path: &[Segment], span: Span) {\n         let is_assoc_fn = self.self_type_is_available();\n+        let Some(path_last_segment) = path.last() else { return };\n+        let item_str = path_last_segment.ident;\n         // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n         if [\"this\", \"my\"].contains(&item_str.as_str()) && is_assoc_fn {\n             err.span_suggestion_short(\n@@ -358,96 +401,25 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 }\n             }\n         }\n+    }\n \n-        self.detect_assoct_type_constraint_meant_as_path(base_error.span, &mut err);\n-\n-        // Emit special messages for unresolved `Self` and `self`.\n-        if is_self_type(path, ns) {\n-            err.code(rustc_errors::error_code!(E0411));\n-            err.span_label(\n-                span,\n-                \"`Self` is only available in impls, traits, and type definitions\".to_string(),\n-            );\n-            if let Some(item_kind) = self.diagnostic_metadata.current_item {\n-                err.span_label(\n-                    item_kind.ident.span,\n-                    format!(\n-                        \"`Self` not allowed in {} {}\",\n-                        item_kind.kind.article(),\n-                        item_kind.kind.descr()\n-                    ),\n-                );\n-            }\n-            return (err, Vec::new());\n-        }\n-        if is_self_value(path, ns) {\n-            debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n-\n-            err.code(rustc_errors::error_code!(E0424));\n-            err.span_label(span, match source {\n-                PathSource::Pat => \"`self` value is a keyword and may not be bound to variables or shadowed\",\n-                _ => \"`self` value is a keyword only available in methods with a `self` parameter\",\n-            });\n-            if let Some((fn_kind, span)) = &self.diagnostic_metadata.current_function {\n-                // The current function has a `self' parameter, but we were unable to resolve\n-                // a reference to `self`. This can only happen if the `self` identifier we\n-                // are resolving came from a different hygiene context.\n-                if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {\n-                    err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n-                } else {\n-                    let doesnt = if is_assoc_fn {\n-                        let (span, sugg) = fn_kind\n-                            .decl()\n-                            .inputs\n-                            .get(0)\n-                            .map(|p| (p.span.shrink_to_lo(), \"&self, \"))\n-                            .unwrap_or_else(|| {\n-                                // Try to look for the \"(\" after the function name, if possible.\n-                                // This avoids placing the suggestion into the visibility specifier.\n-                                let span = fn_kind\n-                                    .ident()\n-                                    .map_or(*span, |ident| span.with_lo(ident.span.hi()));\n-                                (\n-                                    self.r\n-                                        .session\n-                                        .source_map()\n-                                        .span_through_char(span, '(')\n-                                        .shrink_to_hi(),\n-                                    \"&self\",\n-                                )\n-                            });\n-                        err.span_suggestion_verbose(\n-                            span,\n-                            \"add a `self` receiver parameter to make the associated `fn` a method\",\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        \"doesn't\"\n-                    } else {\n-                        \"can't\"\n-                    };\n-                    if let Some(ident) = fn_kind.ident() {\n-                        err.span_label(\n-                            ident.span,\n-                            &format!(\"this function {} have a `self` parameter\", doesnt),\n-                        );\n-                    }\n-                }\n-            } else if let Some(item_kind) = self.diagnostic_metadata.current_item {\n-                err.span_label(\n-                    item_kind.ident.span,\n-                    format!(\n-                        \"`self` not allowed in {} {}\",\n-                        item_kind.kind.article(),\n-                        item_kind.kind.descr()\n-                    ),\n-                );\n-            }\n-            return (err, Vec::new());\n-        }\n-\n+    fn try_lookup_name_relaxed(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+        res: Option<Res>,\n+        base_error: &BaseError,\n+    ) -> (bool, Vec<ImportSuggestion>) {\n         // Try to lookup name in more relaxed fashion for better error reporting.\n         let ident = path.last().unwrap().ident;\n+        let is_expected = &|res| source.is_expected(res);\n+        let ns = source.namespace();\n+        let is_enum_variant = &|res| matches!(res, Res::Def(DefKind::Variant, _));\n+        let path_str = Segment::names_to_string(path);\n+        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n+\n         let mut candidates = self\n             .r\n             .lookup_import_candidates(ident, ns, &self.parent_scope, is_expected)\n@@ -494,7 +466,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     {\n                         // Already reported this issue on the lhs of the type ascription.\n                         err.delay_as_bug();\n-                        return (err, candidates);\n+                        return (true, candidates);\n                     }\n                 }\n \n@@ -522,8 +494,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 );\n             }\n         }\n+\n         // Try Levenshtein algorithm.\n-        let typo_sugg = self.lookup_typo_candidate(path, ns, is_expected);\n+        let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n         if path.len() == 1 && self.self_type_is_available() {\n             if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n                 let self_is_available = self.self_value_is_available(path[0].ident.span);\n@@ -560,8 +533,8 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         );\n                     }\n                 }\n-                self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span);\n-                return (err, candidates);\n+                self.r.add_typo_suggestion(err, typo_sugg, ident_span);\n+                return (true, candidates);\n             }\n \n             // If the first argument in call is `self` suggest calling a method.\n@@ -579,121 +552,150 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     format!(\"self.{path_str}({args_snippet})\"),\n                     Applicability::MachineApplicable,\n                 );\n-                return (err, candidates);\n+                return (true, candidates);\n             }\n         }\n \n         // Try context-dependent help if relaxed lookup didn't work.\n         if let Some(res) = res {\n             if self.smart_resolve_context_dependent_help(\n-                &mut err,\n+                err,\n                 span,\n                 source,\n                 res,\n                 &path_str,\n                 &base_error.fallback_label,\n             ) {\n                 // We do this to avoid losing a secondary span when we override the main error span.\n-                self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span);\n-                return (err, candidates);\n+                self.r.add_typo_suggestion(err, typo_sugg, ident_span);\n+                return (true, candidates);\n             }\n         }\n+        return (false, candidates);\n+    }\n \n+    fn suggest_trait_and_bounds(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        source: PathSource<'_>,\n+        res: Option<Res>,\n+        span: Span,\n+        base_error: &BaseError,\n+    ) -> bool {\n         let is_macro =\n             base_error.span.from_expansion() && base_error.span.desugaring_kind().is_none();\n-        if !self.type_ascription_suggestion(&mut err, base_error.span) {\n-            let mut fallback = false;\n-            if let (\n-                PathSource::Trait(AliasPossibility::Maybe),\n-                Some(Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, _)),\n-                false,\n-            ) = (source, res, is_macro)\n-            {\n-                if let Some(bounds @ [_, .., _]) = self.diagnostic_metadata.current_trait_object {\n-                    fallback = true;\n-                    let spans: Vec<Span> = bounds\n-                        .iter()\n-                        .map(|bound| bound.span())\n-                        .filter(|&sp| sp != base_error.span)\n-                        .collect();\n+        let mut fallback = false;\n \n-                    let start_span = bounds[0].span();\n-                    // `end_span` is the end of the poly trait ref (Foo + 'baz + Bar><)\n-                    let end_span = bounds.last().unwrap().span();\n-                    // `last_bound_span` is the last bound of the poly trait ref (Foo + >'baz< + Bar)\n-                    let last_bound_span = spans.last().cloned().unwrap();\n-                    let mut multi_span: MultiSpan = spans.clone().into();\n-                    for sp in spans {\n-                        let msg = if sp == last_bound_span {\n-                            format!(\n-                                \"...because of {these} bound{s}\",\n-                                these = pluralize!(\"this\", bounds.len() - 1),\n-                                s = pluralize!(bounds.len() - 1),\n-                            )\n-                        } else {\n-                            String::new()\n-                        };\n-                        multi_span.push_span_label(sp, msg);\n-                    }\n-                    multi_span\n-                        .push_span_label(base_error.span, \"expected this type to be a trait...\");\n-                    err.span_help(\n-                        multi_span,\n-                        \"`+` is used to constrain a \\\"trait object\\\" type with lifetimes or \\\n-                         auto-traits; structs and enums can't be bound in that way\",\n-                    );\n-                    if bounds.iter().all(|bound| match bound {\n-                        ast::GenericBound::Outlives(_) => true,\n-                        ast::GenericBound::Trait(tr, _) => tr.span == base_error.span,\n-                    }) {\n-                        let mut sugg = vec![];\n-                        if base_error.span != start_span {\n-                            sugg.push((start_span.until(base_error.span), String::new()));\n-                        }\n-                        if base_error.span != end_span {\n-                            sugg.push((base_error.span.shrink_to_hi().to(end_span), String::new()));\n-                        }\n+        if let (\n+            PathSource::Trait(AliasPossibility::Maybe),\n+            Some(Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, _)),\n+            false,\n+        ) = (source, res, is_macro)\n+        {\n+            if let Some(bounds @ [_, .., _]) = self.diagnostic_metadata.current_trait_object {\n+                fallback = true;\n+                let spans: Vec<Span> = bounds\n+                    .iter()\n+                    .map(|bound| bound.span())\n+                    .filter(|&sp| sp != base_error.span)\n+                    .collect();\n \n-                        err.multipart_suggestion(\n-                            \"if you meant to use a type and not a trait here, remove the bounds\",\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                let start_span = bounds[0].span();\n+                // `end_span` is the end of the poly trait ref (Foo + 'baz + Bar><)\n+                let end_span = bounds.last().unwrap().span();\n+                // `last_bound_span` is the last bound of the poly trait ref (Foo + >'baz< + Bar)\n+                let last_bound_span = spans.last().cloned().unwrap();\n+                let mut multi_span: MultiSpan = spans.clone().into();\n+                for sp in spans {\n+                    let msg = if sp == last_bound_span {\n+                        format!(\n+                            \"...because of {these} bound{s}\",\n+                            these = pluralize!(\"this\", bounds.len() - 1),\n+                            s = pluralize!(bounds.len() - 1),\n+                        )\n+                    } else {\n+                        String::new()\n+                    };\n+                    multi_span.push_span_label(sp, msg);\n+                }\n+                multi_span.push_span_label(base_error.span, \"expected this type to be a trait...\");\n+                err.span_help(\n+                    multi_span,\n+                    \"`+` is used to constrain a \\\"trait object\\\" type with lifetimes or \\\n+                        auto-traits; structs and enums can't be bound in that way\",\n+                );\n+                if bounds.iter().all(|bound| match bound {\n+                    ast::GenericBound::Outlives(_) => true,\n+                    ast::GenericBound::Trait(tr, _) => tr.span == base_error.span,\n+                }) {\n+                    let mut sugg = vec![];\n+                    if base_error.span != start_span {\n+                        sugg.push((start_span.until(base_error.span), String::new()));\n                     }\n+                    if base_error.span != end_span {\n+                        sugg.push((base_error.span.shrink_to_hi().to(end_span), String::new()));\n+                    }\n+\n+                    err.multipart_suggestion(\n+                        \"if you meant to use a type and not a trait here, remove the bounds\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n+        }\n \n-            fallback |= self.restrict_assoc_type_in_where_clause(span, &mut err);\n+        fallback |= self.restrict_assoc_type_in_where_clause(span, err);\n+        fallback\n+    }\n \n-            if !self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span) {\n-                fallback = true;\n-                match self.diagnostic_metadata.current_let_binding {\n-                    Some((pat_sp, Some(ty_sp), None))\n-                        if ty_sp.contains(base_error.span) && base_error.could_be_expr =>\n-                    {\n-                        err.span_suggestion_short(\n-                            pat_sp.between(ty_sp),\n-                            \"use `=` if you meant to assign\",\n-                            \" = \",\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    _ => {}\n+    fn suggest_typo(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+        base_error: &BaseError,\n+    ) -> bool {\n+        let is_expected = &|res| source.is_expected(res);\n+        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n+        let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n+        let mut fallback = false;\n+        if !self.r.add_typo_suggestion(err, typo_sugg, ident_span) {\n+            fallback = true;\n+            match self.diagnostic_metadata.current_let_binding {\n+                Some((pat_sp, Some(ty_sp), None))\n+                    if ty_sp.contains(base_error.span) && base_error.could_be_expr =>\n+                {\n+                    err.span_suggestion_short(\n+                        pat_sp.between(ty_sp),\n+                        \"use `=` if you meant to assign\",\n+                        \" = \",\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n-\n-                // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n-                let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n-                self.r.add_typo_suggestion(&mut err, suggestion, ident_span);\n-            }\n-            if fallback {\n-                // Fallback label.\n-                err.span_label(base_error.span, base_error.fallback_label);\n+                _ => {}\n             }\n+\n+            // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n+            let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n+            self.r.add_typo_suggestion(err, suggestion, ident_span);\n         }\n+        fallback\n+    }\n+\n+    fn err_code_special_cases(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+    ) {\n         if let Some(err_code) = &err.code {\n             if err_code == &rustc_errors::error_code!(E0425) {\n                 for label_rib in &self.label_ribs {\n                     for (label_ident, node_id) in &label_rib.bindings {\n+                        let ident = path.last().unwrap().ident;\n                         if format!(\"'{}\", ident) == label_ident.to_string() {\n                             err.span_label(label_ident.span, \"a label with a similar name exists\");\n                             if let PathSource::Expr(Some(Expr {\n@@ -724,38 +726,116 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 }\n             }\n         }\n+    }\n \n-        (err, candidates)\n+    /// Emit special messages for unresolved `Self` and `self`.\n+    fn suggest_self_ty(\n+        &mut self,\n+        err: &mut Diagnostic,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+    ) -> bool {\n+        if !is_self_type(path, source.namespace()) {\n+            return false;\n+        }\n+        err.code(rustc_errors::error_code!(E0411));\n+        err.span_label(\n+            span,\n+            \"`Self` is only available in impls, traits, and type definitions\".to_string(),\n+        );\n+        if let Some(item_kind) = self.diagnostic_metadata.current_item {\n+            err.span_label(\n+                item_kind.ident.span,\n+                format!(\n+                    \"`Self` not allowed in {} {}\",\n+                    item_kind.kind.article(),\n+                    item_kind.kind.descr()\n+                ),\n+            );\n+        }\n+        true\n     }\n \n-    fn detect_assoct_type_constraint_meant_as_path(&self, base_span: Span, err: &mut Diagnostic) {\n-        let Some(ty) = self.diagnostic_metadata.current_type_path else { return; };\n-        let TyKind::Path(_, path) = &ty.kind else { return; };\n-        for segment in &path.segments {\n-            let Some(params) = &segment.args else { continue; };\n-            let ast::GenericArgs::AngleBracketed(ref params) = params.deref() else { continue; };\n-            for param in &params.args {\n-                let ast::AngleBracketedArg::Constraint(constraint) = param else { continue; };\n-                let ast::AssocConstraintKind::Bound { bounds } = &constraint.kind else {\n-                    continue;\n+    fn suggest_self_value(\n+        &mut self,\n+        err: &mut Diagnostic,\n+        source: PathSource<'_>,\n+        path: &[Segment],\n+        span: Span,\n+    ) -> bool {\n+        if !is_self_value(path, source.namespace()) {\n+            return false;\n+        }\n+\n+        debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n+        err.code(rustc_errors::error_code!(E0424));\n+        err.span_label(\n+            span,\n+            match source {\n+                PathSource::Pat => {\n+                    \"`self` value is a keyword and may not be bound to variables or shadowed\"\n+                }\n+                _ => \"`self` value is a keyword only available in methods with a `self` parameter\",\n+            },\n+        );\n+        let is_assoc_fn = self.self_type_is_available();\n+        if let Some((fn_kind, span)) = &self.diagnostic_metadata.current_function {\n+            // The current function has a `self' parameter, but we were unable to resolve\n+            // a reference to `self`. This can only happen if the `self` identifier we\n+            // are resolving came from a different hygiene context.\n+            if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {\n+                err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n+            } else {\n+                let doesnt = if is_assoc_fn {\n+                    let (span, sugg) = fn_kind\n+                        .decl()\n+                        .inputs\n+                        .get(0)\n+                        .map(|p| (p.span.shrink_to_lo(), \"&self, \"))\n+                        .unwrap_or_else(|| {\n+                            // Try to look for the \"(\" after the function name, if possible.\n+                            // This avoids placing the suggestion into the visibility specifier.\n+                            let span = fn_kind\n+                                .ident()\n+                                .map_or(*span, |ident| span.with_lo(ident.span.hi()));\n+                            (\n+                                self.r\n+                                    .session\n+                                    .source_map()\n+                                    .span_through_char(span, '(')\n+                                    .shrink_to_hi(),\n+                                \"&self\",\n+                            )\n+                        });\n+                    err.span_suggestion_verbose(\n+                        span,\n+                        \"add a `self` receiver parameter to make the associated `fn` a method\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    \"doesn't\"\n+                } else {\n+                    \"can't\"\n                 };\n-                for bound in bounds {\n-                    let ast::GenericBound::Trait(trait_ref, ast::TraitBoundModifier::None)\n-                        = bound else\n-                    {\n-                        continue;\n-                    };\n-                    if base_span == trait_ref.span {\n-                        err.span_suggestion_verbose(\n-                            constraint.ident.span.between(trait_ref.span),\n-                            \"you might have meant to write a path instead of an associated type bound\",\n-                            \"::\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n+                if let Some(ident) = fn_kind.ident() {\n+                    err.span_label(\n+                        ident.span,\n+                        &format!(\"this function {} have a `self` parameter\", doesnt),\n+                    );\n                 }\n             }\n+        } else if let Some(item_kind) = self.diagnostic_metadata.current_item {\n+            err.span_label(\n+                item_kind.ident.span,\n+                format!(\n+                    \"`self` not allowed in {} {}\",\n+                    item_kind.kind.article(),\n+                    item_kind.kind.descr()\n+                ),\n+            );\n         }\n+        true\n     }\n \n     fn suggest_swapping_misplaced_self_ty_and_trait(\n@@ -787,6 +867,45 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n \n+    fn suggest_bare_struct_literal(&mut self, err: &mut Diagnostic) {\n+        if let Some(span) = self.diagnostic_metadata.current_block_could_be_bare_struct_literal {\n+            err.multipart_suggestion(\n+                \"you might have meant to write a `struct` literal\",\n+                vec![\n+                    (span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n+                    (span.shrink_to_hi(), \"}\".to_string()),\n+                ],\n+                Applicability::HasPlaceholders,\n+            );\n+        }\n+    }\n+\n+    fn suggest_pattern_match_with_let(\n+        &mut self,\n+        err: &mut Diagnostic,\n+        source: PathSource<'_>,\n+        span: Span,\n+    ) {\n+        if let PathSource::Expr(_) = source &&\n+        let Some(Expr {\n+                    span: expr_span,\n+                    kind: ExprKind::Assign(lhs, _, _),\n+                    ..\n+                })  = self.diagnostic_metadata.in_if_condition {\n+            // Icky heuristic so we don't suggest:\n+            // `if (i + 2) = 2` => `if let (i + 2) = 2` (approximately pattern)\n+            // `if 2 = i` => `if let 2 = i` (lhs needs to contain error span)\n+            if lhs.is_approximately_pattern() && lhs.span.contains(span) {\n+                err.span_suggestion_verbose(\n+                    expr_span.shrink_to_lo(),\n+                    \"you might have meant to use pattern matching\",\n+                    \"let \",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+\n     fn get_single_associated_item(\n         &mut self,\n         path: &[Segment],"}]}