{"sha": "679102109fd72c2560de0988324c14af3ae27c7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3OTEwMjEwOWZkNzJjMjU2MGRlMDk4ODMyNGMxNGFmM2FlMjdjN2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-17T22:22:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-17T22:22:04Z"}, "message": "auto merge of #8554 : michaelwoerister/rust/generics, r=brson\n\nThis pull request includes support for generic functions and self arguments in methods, and combinations thereof. This also encompasses any kind of trait methods, regular and static, with and without default implementation. The implementation is backed up by a felt ton of test cases `:)`\r\n\r\nThis is a very important step towards being able to compile larger programs with debug info, since practically any generic function caused an ICE before.\r\n\r\nOne point worth discussing is that activating debug info now automatically (and silently) sets the `no_monomorphic_collapse` flag. Otherwise debug info would show wrong type names in all but one instance of the monomorphized function.\r\n\r\nAnother thing to note is that the handling of generic types does not strictly follow the DWARF specification. That is, variables with type `T` (where `T=int`) are described as having type `int` and not as having type `T`. In other words, we are losing information whether a variable has been declared with a type parameter as its type. In practice this should not make much of difference though since the concrete type is mostly what one is interested in. I'll post an issue later so this won't be forgotten.\r\n\r\nAlso included are a number of bug fixes:\r\n* Closes #1758\r\n* Closes #8513\r\n* Closes #8443\r\n* Fixes handling of field names in tuple structs\r\n* Fixes and re-enables test case for option-like enums that relied on undefined behavior before\r\n* Closes #1339 (should have been closed a while ago)\r\n\r\nCheers,\r\nMichael", "tree": {"sha": "ac90aa5ba2c85b7dd296fac2bc04f3caddeda36f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac90aa5ba2c85b7dd296fac2bc04f3caddeda36f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/679102109fd72c2560de0988324c14af3ae27c7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/679102109fd72c2560de0988324c14af3ae27c7a", "html_url": "https://github.com/rust-lang/rust/commit/679102109fd72c2560de0988324c14af3ae27c7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/679102109fd72c2560de0988324c14af3ae27c7a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb8a231eb8b730128c5b7e89c8eac9eab36642c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb8a231eb8b730128c5b7e89c8eac9eab36642c4", "html_url": "https://github.com/rust-lang/rust/commit/cb8a231eb8b730128c5b7e89c8eac9eab36642c4"}, {"sha": "80fb2f20561afb254c820c8112e4f439d75cf16b", "url": "https://api.github.com/repos/rust-lang/rust/commits/80fb2f20561afb254c820c8112e4f439d75cf16b", "html_url": "https://github.com/rust-lang/rust/commit/80fb2f20561afb254c820c8112e4f439d75cf16b"}], "stats": {"total": 2326, "additions": 2226, "deletions": 100}, "files": [{"sha": "5227d68774b5ffad235e4aad1df0b233bd8a69ff", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -691,6 +691,14 @@ pub fn build_session_options(binary: @str,\n     let extra_debuginfo = debugging_opts & session::extra_debug_info != 0;\n     let debuginfo = debugging_opts & session::debug_info != 0 ||\n         extra_debuginfo;\n+\n+    // If debugging info is generated, do not collapse monomorphized function instances.\n+    // Functions with equivalent llvm code still need separate debugging descriptions because names\n+    // might differ.\n+    if debuginfo {\n+        debugging_opts |= session::no_monomorphic_collapse;\n+    }\n+\n     let statik = debugging_opts & session::statik != 0;\n \n     let addl_lib_search_paths = getopts::opt_strs(matches, \"L\").map(|s| Path(*s));"}, {"sha": "4c204b908bc6bc2a0188eff9ceae5a4e28e39cbb", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -2086,6 +2086,16 @@ pub mod llvm {\n \n         #[fast_ffi]\n         pub fn LLVMSetUnnamedAddr(GlobalVar: ValueRef, UnnamedAddr: Bool);\n+\n+        #[fast_ffi]\n+        pub fn LLVMDIBuilderCreateTemplateTypeParameter(Builder: DIBuilderRef,\n+                                                        Scope: ValueRef,\n+                                                        Name: *c_char,\n+                                                        Ty: ValueRef,\n+                                                        File: ValueRef,\n+                                                        LineNo: c_uint,\n+                                                        ColumnNo: c_uint)\n+                                                        -> ValueRef;\n     }\n }\n "}, {"sha": "6640ed0f38d92d11f4940ed735df5d37e327fee7", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -133,7 +133,7 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n \n fn fcx_has_nonzero_span(fcx: &FunctionContext) -> bool {\n     match fcx.span {\n-        None => true,\n+        None => false,\n         Some(span) => *span.lo != 0 || *span.hi != 0\n     }\n }\n@@ -1739,6 +1739,10 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n \n             fcx.llself = Some(ValSelfData {v: self_val, ..slf});\n             add_clean(bcx, self_val, slf.t);\n+\n+            if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n+                debuginfo::create_self_argument_metadata(bcx, slf.t, self_val);\n+            }\n         }\n         _ => {}\n     }\n@@ -1859,6 +1863,10 @@ pub fn trans_closure(ccx: @mut CrateContext,\n         set_fixed_stack_segment(fcx.llfn);\n     }\n \n+    if ccx.sess.opts.debuginfo && fcx_has_nonzero_span(fcx) {\n+        debuginfo::create_function_metadata(fcx);\n+    }\n+\n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n     let bcx_top = fcx.entry_bcx.unwrap();\n@@ -1929,12 +1937,7 @@ pub fn trans_fn(ccx: @mut CrateContext,\n                   id,\n                   attrs,\n                   output_type,\n-                  |fcx| {\n-                      if ccx.sess.opts.debuginfo\n-                          && fcx_has_nonzero_span(fcx) {\n-                          debuginfo::create_function_metadata(fcx);\n-                      }\n-                  });\n+                  |_fcx| { });\n }\n \n fn insert_synthetic_type_entries(bcx: @mut Block,"}, {"sha": "f5073cc71e5d031559a410f17a27f85cd0d094ab", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 299, "deletions": 82, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -51,7 +51,7 @@ This file consists of three conceptual sections:\n \n use driver::session;\n use lib::llvm::llvm;\n-use lib::llvm::{ModuleRef, ContextRef};\n+use lib::llvm::{ModuleRef, ContextRef, ValueRef};\n use lib::llvm::debuginfo::*;\n use middle::trans::common::*;\n use middle::trans::machine;\n@@ -69,7 +69,8 @@ use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n use std::vec;\n use syntax::codemap::span;\n-use syntax::{ast, codemap, ast_util, ast_map};\n+use syntax::{ast, codemap, ast_util, ast_map, opt_vec};\n+use syntax::parse::token::special_idents;\n \n static DW_LANG_RUST: int = 0x9000;\n \n@@ -97,7 +98,7 @@ pub struct DebugContext {\n     priv builder: DIBuilderRef,\n     priv curr_loc: (uint, uint),\n     priv created_files: HashMap<~str, DIFile>,\n-    priv created_functions: HashMap<ast::NodeId, DISubprogram>,\n+    priv created_functions: HashMap<FunctionCacheKey, DISubprogram>,\n     priv created_blocks: HashMap<ast::NodeId, DILexicalBlock>,\n     priv created_types: HashMap<uint, DIType>\n }\n@@ -121,21 +122,25 @@ impl DebugContext {\n     }\n }\n \n+#[deriving(Eq,IterBytes)]\n+struct FunctionCacheKey {\n+    // Use the address of the llvm function (FunctionContext::llfn) as key for the cache. This\n+    // nicely takes care of monomorphization, where two specializations will have the same\n+    // ast::NodeId but different llvm functions (each needing its own debug description).\n+    priv llfn: ValueRef\n+}\n+\n+impl FunctionCacheKey {\n+    fn for_function_context(fcx: &FunctionContext) -> FunctionCacheKey {\n+        FunctionCacheKey { llfn: fcx.llfn }\n+    }\n+}\n \n pub struct FunctionDebugContext {\n     priv scope_map: HashMap<ast::NodeId, DIScope>,\n     priv argument_counter: uint,\n }\n \n-impl FunctionDebugContext {\n-    fn new() -> FunctionDebugContext {\n-        return FunctionDebugContext {\n-            scope_map: HashMap::new(),\n-            argument_counter: 1,\n-        };\n-    }\n-}\n-\n /// Create any deferred debug metadata nodes\n pub fn finalize(cx: @mut CrateContext) {\n     debug!(\"finalize\");\n@@ -162,6 +167,9 @@ pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n     }\n }\n \n+/// Creates debug information for a local variable introduced in the head of a match-statement arm.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_match_binding_metadata(bcx: @mut Block,\n                                      variable_ident: ast::ident,\n                                      node_id: ast::NodeId,\n@@ -170,6 +178,52 @@ pub fn create_match_binding_metadata(bcx: @mut Block,\n     declare_local(bcx, variable_ident, node_id, variable_type, span);\n }\n \n+/// Creates debug information for the self argument of a method.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR.\n+pub fn create_self_argument_metadata(bcx: @mut Block,\n+                                     variable_type: ty::t,\n+                                     llptr: ValueRef) {\n+    assert_fcx_has_span(bcx.fcx);\n+    let span = bcx.fcx.span.unwrap();\n+\n+    let cx = bcx.ccx();\n+\n+    let filename = span_start(cx, span).file.name;\n+    let file_metadata = file_metadata(cx, filename);\n+\n+    let loc = span_start(cx, span);\n+    let type_metadata = type_metadata(cx, variable_type, span);\n+    let scope = create_function_metadata(bcx.fcx);\n+\n+    let var_metadata = do cx.sess.str_of(special_idents::self_).to_c_str().with_ref |name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateLocalVariable(\n+                DIB(cx),\n+                DW_TAG_arg_variable,\n+                scope,\n+                name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                type_metadata,\n+                false,\n+                0,\n+                1)\n+        }\n+    };\n+\n+    set_debug_location(cx, scope, loc.line, loc.col.to_uint());\n+    unsafe {\n+        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+            DIB(cx),\n+            llptr,\n+            var_metadata,\n+            bcx.llbb);\n+\n+        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n+    }\n+}\n+\n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n@@ -243,9 +297,10 @@ pub fn create_argument_metadata(bcx: @mut Block,\n     }\n }\n \n-/// Sets the current debug location at the beginning of the span\n+/// Sets the current debug location at the beginning of the span.\n ///\n-/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...)\n+/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id parameter is used to\n+/// reliably find the correct visibility scope for the code position.\n pub fn update_source_pos(fcx: &FunctionContext,\n                          node_id: ast::NodeId,\n                          span: span) {\n@@ -269,13 +324,24 @@ pub fn update_source_pos(fcx: &FunctionContext,\n /// The return value should be ignored if called from outside of the debuginfo module.\n pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n     let cx = fcx.ccx;\n+    let cache_key = FunctionCacheKey::for_function_context(fcx);\n+\n+    match dbg_cx(cx).created_functions.find_copy(&cache_key) {\n+        Some(fn_metadata) => {\n+            assert!(fcx.debug_context.is_some());\n+            return fn_metadata;\n+        }\n+        None => { /* fallthrough */}\n+    }\n+\n+    let empty_generics = ast::Generics { lifetimes: opt_vec::Empty, ty_params: opt_vec::Empty };\n \n     let fnitem = cx.tcx.items.get_copy(&fcx.id);\n-    let (ident, fn_decl, id) = match fnitem {\n+    let (ident, fn_decl, generics, span) = match fnitem {\n         ast_map::node_item(ref item, _) => {\n             match item.node {\n-                ast::item_fn(ref fn_decl, _, _, _, _) => {\n-                    (item.ident, fn_decl, item.id)\n+                ast::item_fn(ref fn_decl, _, _, ref generics, _) => {\n+                    (item.ident, fn_decl, generics, item.span)\n                 }\n                 _ => fcx.ccx.sess.span_bug(item.span,\n                                            \"create_function_metadata: item bound to non-function\")\n@@ -284,19 +350,24 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n         ast_map::node_method(\n             @ast::method {\n                 decl: ref fn_decl,\n-                id: id,\n                 ident: ident,\n+                generics: ref generics,\n+                span: span,\n                 _\n             },\n             _,\n             _) => {\n-            (ident, fn_decl, id)\n+            (ident, fn_decl, generics, span)\n         }\n         ast_map::node_expr(ref expr) => {\n             match expr.node {\n                 ast::expr_fn_block(ref fn_decl, _) => {\n                     let name = gensym_name(\"fn\");\n-                    (name, fn_decl, expr.id)\n+                    (name, fn_decl,\n+                        // This is not quite right. It should actually inherit the generics of the\n+                        // enclosing function.\n+                        &empty_generics,\n+                        expr.span)\n                 }\n                 _ => fcx.ccx.sess.span_bug(expr.span,\n                         \"create_function_metadata: expected an expr_fn_block here\")\n@@ -306,96 +377,229 @@ pub fn create_function_metadata(fcx: &mut FunctionContext) -> DISubprogram {\n             @ast::provided(\n                 @ast::method {\n                     decl: ref fn_decl,\n-                    id: id,\n                     ident: ident,\n+                    generics: ref generics,\n+                    span: span,\n                     _\n                 }),\n             _,\n             _) => {\n-            (ident, fn_decl, id)\n+            (ident, fn_decl, generics, span)\n         }\n         _ => fcx.ccx.sess.bug(fmt!(\"create_function_metadata: unexpected sort of node: %?\", fnitem))\n     };\n \n-    match dbg_cx(cx).created_functions.find_copy(&id) {\n-        Some(fn_metadata) => return fn_metadata,\n-        None => ()\n-    }\n-\n-    let span = match fcx.span {\n-        Some(value) => value,\n-        None => codemap::dummy_sp()\n-    };\n-\n     debug!(\"create_function_metadata: %s, %s\",\n            cx.sess.str_of(ident),\n            cx.sess.codemap.span_to_str(span));\n \n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let return_type_metadata = if cx.sess.opts.extra_debuginfo {\n-        match fn_decl.output.node {\n-          ast::ty_nil => ptr::null(),\n-          _ => type_metadata(cx, ty::node_id_to_type(cx.tcx, id), fn_decl.output.span)\n-        }\n-    } else {\n-        ptr::null()\n+    let function_type_metadata = unsafe {\n+        let fn_signature = get_function_signature(fcx, fn_decl);\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n-    let fn_ty = unsafe {\n-        llvm::LLVMDIBuilderCreateSubroutineType(\n-            DIB(cx),\n-            file_metadata,\n-            create_DIArray(DIB(cx), [return_type_metadata]))\n+    // get_template_parameters() will append a `<...>` clause to the function name if necessary.\n+    let mut function_name = cx.sess.str_of(ident).to_owned();\n+    let template_parameters = get_template_parameters(fcx,\n+                                                      generics,\n+                                                      file_metadata,\n+                                                      &mut function_name);\n+\n+    let fn_metadata = do function_name.to_c_str().with_ref |function_name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateFunction(\n+                DIB(cx),\n+                file_metadata,\n+                function_name,\n+                function_name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                function_type_metadata,\n+                false,\n+                true,\n+                loc.line as c_uint,\n+                FlagPrototyped as c_uint,\n+                cx.sess.opts.optimize != session::No,\n+                fcx.llfn,\n+                template_parameters,\n+                ptr::null())\n+        }\n     };\n \n-    let fn_metadata =\n-        do cx.sess.str_of(ident).with_c_str |name| {\n-        do cx.sess.str_of(ident).with_c_str |linkage| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateFunction(\n-                    DIB(cx),\n-                    file_metadata,\n-                    name,\n-                    linkage,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    fn_ty,\n-                    false,\n-                    true,\n-                    loc.line as c_uint,\n-                    FlagPrototyped as c_uint,\n-                    cx.sess.opts.optimize != session::No,\n-                    fcx.llfn,\n-                    ptr::null(),\n-                    ptr::null())\n+    dbg_cx(cx).created_functions.insert(cache_key, fn_metadata);\n+\n+    // Initialize fn debug context (including scope map)\n+    {\n+        assert!(fcx.debug_context.is_none());\n+\n+        let mut fn_debug_context = ~FunctionDebugContext {\n+            scope_map: HashMap::new(),\n+            argument_counter: if fcx.llself.is_some() { 2 } else { 1 }\n+        };\n+\n+        let entry_block_id = fcx.entry_bcx.get_ref().node_info.get_ref().id;\n+        let entry_block = cx.tcx.items.get(&entry_block_id);\n+\n+        match *entry_block {\n+            ast_map::node_block(ref block) => {\n+                let scope_map = &mut fn_debug_context.scope_map;\n+                let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n+\n+                populate_scope_map(cx, arg_pats, block, fn_metadata, scope_map);\n             }\n-        }};\n+            _ => cx.sess.span_bug(span,\n+                    fmt!(\"debuginfo::create_function_metadata() - \\\n+                         FunctionContext::entry_bcx::node_info points to wrong type of ast_map \\\n+                         entry. Expected: ast_map::node_block, actual: %?\", *entry_block))\n+        }\n+\n+        fcx.debug_context = Some(fn_debug_context);\n+    }\n+\n+    return fn_metadata;\n \n-    assert!(fcx.debug_context.is_none());\n+    fn get_function_signature(fcx: &FunctionContext, fn_decl: &ast::fn_decl) -> DIArray {\n+        let cx = fcx.ccx;\n \n-    let mut fn_debug_context = ~FunctionDebugContext::new();\n-    let entry_block_id = fcx.entry_bcx.get_ref().node_info.get_ref().id;\n-    let entry_block = cx.tcx.items.get(&entry_block_id);\n+        if !cx.sess.opts.extra_debuginfo {\n+            return create_DIArray(DIB(cx), []);\n+        }\n+\n+        let mut signature = vec::with_capacity(fn_decl.inputs.len() + 1);\n \n-    match *entry_block {\n-        ast_map::node_block(ref block) => {\n-            let scope_map = &mut fn_debug_context.scope_map;\n-            let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n+        // Return type -- llvm::DIBuilder wants this at index 0\n+        match fn_decl.output.node {\n+            ast::ty_nil => {\n+                signature.push(ptr::null());\n+            }\n+            _ => {\n+                let return_type = ty::node_id_to_type(cx.tcx, fcx.id);\n+                let return_type = match fcx.param_substs {\n+                    None => return_type,\n+                    Some(substs) => {\n+                        ty::subst_tps(cx.tcx, substs.tys, substs.self_ty, return_type)\n+                    }\n+                };\n \n-            populate_scope_map(cx, arg_pats, block, fn_metadata, scope_map);\n+                signature.push(type_metadata(cx, return_type, codemap::dummy_sp()));\n+            }\n         }\n-        _ => cx.sess.span_bug(span,\n-                fmt!(\"debuginfo::create_function_metadata() - \\\n-                     FunctionContext::entry_bcx::node_info points to wrong type of ast_map entry. \\\n-                     Expected: ast_map::node_block, actual: %?\", *entry_block))\n+\n+        // arguments types\n+        for arg in fn_decl.inputs.iter() {\n+            let arg_type = ty::node_id_to_type(cx.tcx, arg.pat.id);\n+            let arg_type = match fcx.param_substs {\n+                None => arg_type,\n+                Some(substs) => {\n+                    ty::subst_tps(cx.tcx, substs.tys, substs.self_ty, arg_type)\n+                }\n+            };\n+\n+            signature.push(type_metadata(cx, arg_type, codemap::dummy_sp()));\n+        }\n+\n+        return create_DIArray(DIB(cx), signature);\n     }\n \n-    fcx.debug_context = Some(fn_debug_context);\n+    fn get_template_parameters(fcx: &FunctionContext,\n+                               generics: &ast::Generics,\n+                               file_metadata: DIFile,\n+                               name_to_append_suffix_to: &mut ~str)\n+                            -> DIArray {\n+        let cx = fcx.ccx;\n \n-    dbg_cx(cx).created_functions.insert(id, fn_metadata);\n-    return fn_metadata;\n+        let self_type = match fcx.param_substs {\n+            Some(@param_substs{ self_ty: self_type, _ }) => self_type,\n+            _ => None\n+        };\n+\n+        // Only true for static default methods:\n+        let has_self_type = self_type.is_some();\n+\n+        if !generics.is_type_parameterized() && !has_self_type {\n+            return ptr::null();\n+        }\n+\n+        name_to_append_suffix_to.push_char('<');\n+\n+        // The list to be filled with template parameters:\n+        let mut template_params: ~[DIDescriptor] = vec::with_capacity(generics.ty_params.len() + 1);\n+\n+        // Handle self type\n+        if has_self_type {\n+            let actual_self_type = self_type.unwrap();\n+            let actual_self_type_metadata = type_metadata(cx,\n+                                                          actual_self_type,\n+                                                          codemap::dummy_sp());\n+\n+            // Add self type name to <...> clause of function name\n+            let actual_self_type_name = ty_to_str(cx.tcx, actual_self_type);\n+            name_to_append_suffix_to.push_str(actual_self_type_name);\n+            if generics.is_type_parameterized() {\n+                name_to_append_suffix_to.push_str(\",\");\n+            }\n+\n+            let ident = special_idents::type_self;\n+\n+            let param_metadata = do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name,\n+                        actual_self_type_metadata,\n+                        ptr::null(),\n+                        0,\n+                        0)\n+                }\n+            };\n+\n+            template_params.push(param_metadata);\n+        }\n+\n+        // Handle other generic parameters\n+        let actual_types = match fcx.param_substs {\n+            Some(@param_substs { tys: ref types, _ }) => types,\n+            None => {\n+                return create_DIArray(DIB(cx), template_params);\n+            }\n+        };\n+\n+        for (index, &ast::TyParam{ ident: ident, _ }) in generics.ty_params.iter().enumerate() {\n+            let actual_type = actual_types[index];\n+            let actual_type_metadata = type_metadata(cx, actual_type, codemap::dummy_sp());\n+\n+            // Add actual type name to <...> clause of function name\n+            let actual_type_name = ty_to_str(cx.tcx, actual_type);\n+            name_to_append_suffix_to.push_str(actual_type_name);\n+\n+            if index != generics.ty_params.len() - 1 {\n+                name_to_append_suffix_to.push_str(\",\");\n+            }\n+\n+            let param_metadata = do cx.sess.str_of(ident).to_c_str().with_ref |name| {\n+                unsafe {\n+                    llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n+                        DIB(cx),\n+                        file_metadata,\n+                        name,\n+                        actual_type_metadata,\n+                        ptr::null(),\n+                        0,\n+                        0)\n+                }\n+            };\n+\n+            template_params.push(param_metadata);\n+        }\n+\n+        name_to_append_suffix_to.push_char('>');\n+\n+        return create_DIArray(DIB(cx), template_params);\n+    }\n }\n \n \n@@ -611,7 +815,13 @@ fn struct_metadata(cx: &mut CrateContext,\n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n \n     let field_llvm_types = do fields.map |field| { type_of::type_of(cx, field.mt.ty) };\n-    let field_names = do fields.map |field| { cx.sess.str_of(field.ident).to_owned() };\n+    let field_names = do fields.map |field| {\n+        if field.ident == special_idents::unnamed_field {\n+            ~\"\"\n+        } else {\n+            cx.sess.str_of(field.ident).to_owned()\n+        }\n+    };\n     let field_types_metadata = do fields.map |field| {\n         type_metadata(cx, field.mt.ty, span)\n     };\n@@ -1271,6 +1481,13 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n     cx.dbg_cx.get_ref().builder\n }\n \n+fn assert_fcx_has_span(fcx: &FunctionContext) {\n+    if fcx.span.is_none() {\n+        fcx.ccx.sess.bug(fmt!(\"debuginfo: Encountered function %s with invalid source span. \\\n+            This function should have been ignored by debuginfo generation.\",\n+            ast_map::path_to_str(fcx.path, fcx.ccx.sess.intr())));\n+    }\n+}\n \n // This procedure builds the *scope map* for a given function, which maps any given ast::NodeId in\n // the function's AST to the correct DIScope metadata instance."}, {"sha": "61ea0d549b3f02b0800e176aff9cef2c3b47f045", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -838,3 +838,21 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateUnionType(\n extern \"C\" void LLVMSetUnnamedAddr(LLVMValueRef Value, LLVMBool Unnamed) {\n     unwrap<GlobalValue>(Value)->setUnnamedAddr(Unnamed);\n }\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateTemplateTypeParameter(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope,\n+    const char* Name,\n+    LLVMValueRef Ty,\n+    LLVMValueRef File = 0,\n+    unsigned LineNo = 0,\n+    unsigned ColumnNo = 0)\n+{\n+    return wrap(Builder->createTemplateTypeParameter(\n+      unwrapDI<DIDescriptor>(Scope),\n+      Name,\n+      unwrapDI<DIType>(Ty),\n+      unwrapDI<MDNode*>(File),\n+      LineNo,\n+      ColumnNo));\n+}"}, {"sha": "0b777abfb87159c968b299c4e722d755a4ca6241", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -613,4 +613,5 @@ LLVMDIBuilderInsertDeclareBefore\n LLVMDIBuilderCreateEnumerator\n LLVMDIBuilderCreateEnumerationType\n LLVMDIBuilderCreateUnionType\n+LLVMDIBuilderCreateTemplateTypeParameter\n LLVMSetUnnamedAddr"}, {"sha": "052b3c6994a9c82d800de60697da31d2f2fb9d20", "filename": "src/test/debug-info/by-value-struct-argument.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fby-value-struct-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fby-value-struct-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fby-value-struct-argument.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Does not work yet, see issue #8512\n+// xfail-test\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print s\n+// check:$1 = {a = 1, b = 2.5}\n+// debugger:continue\n+\n+#[deriving(Clone)]\n+struct Struct {\n+    a: int,\n+    b: float\n+}\n+\n+fn fun(s: Struct) {\n+    zzz();\n+}\n+\n+fn main() {\n+    fun(Struct { a: 1, b: 2.5 });\n+}\n+\n+fn zzz() {()}"}, {"sha": "b6cf6afff1ed2bf91344546d8646fdc9532eab55", "filename": "src/test/debug-info/closure-in-generic-function.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fclosure-in-generic-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fclosure-in-generic-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fclosure-in-generic-function.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = 0.5\n+// debugger:print y\n+// check:$2 = 10\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print *x\n+// check:$3 = 29\n+// debugger:print *y\n+// check:$4 = 110\n+// debugger:continue\n+\n+fn some_generic_fun<T1, T2>(a: T1, b: T2) -> (T2, T1) {\n+\n+    let closure = |x, y| {\n+        zzz();\n+        (y, x)\n+    };\n+\n+    closure(a, b)\n+}\n+\n+fn main() {\n+    some_generic_fun(0.5, 10);\n+    some_generic_fun(&29, ~110);\n+}\n+\n+fn zzz() {()}"}, {"sha": "c3b48f27b7381382883a0d51533c3759c4054194", "filename": "src/test/debug-info/generic-function.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-function.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print *t0\n+// check:$1 = 1\n+// debugger:print *t1\n+// check:$2 = 2.5\n+// debugger:print ret\n+// check:$3 = {{1, 2.5}, {2.5, 1}}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print *t0\n+// check:$4 = 3.5\n+// debugger:print *t1\n+// check:$5 = 4\n+// debugger:print ret\n+// check:$6 = {{3.5, 4}, {4, 3.5}}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print *t0\n+// check:$7 = 5\n+// debugger:print *t1\n+// check:$8 = {a = 6, b = 7.5}\n+// debugger:print ret\n+// check:$9 = {{5, {a = 6, b = 7.5}}, {{a = 6, b = 7.5}, 5}}\n+// debugger:continue\n+\n+#[deriving(Clone)]\n+struct Struct {\n+    a: int,\n+    b: float\n+}\n+\n+fn dup_tup<T0: Clone, T1: Clone>(t0: &T0, t1: &T1) -> ((T0, T1), (T1, T0)) {\n+    let ret = ((t0.clone(), t1.clone()), (t1.clone(), t0.clone()));\n+    zzz();\n+    ret\n+}\n+\n+fn main() {\n+\n+    let _ = dup_tup(&1, &2.5);\n+    let _ = dup_tup(&3.5, &4_u16);\n+    let _ = dup_tup(&5, &Struct { a: 6, b: 7.5 });\n+}\n+\n+fn zzz() {()}"}, {"sha": "1d883b5ab4df19abe47009efcc141a089dacbdd3", "filename": "src/test/debug-info/generic-functions-nested.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-functions-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-functions-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-functions-nested.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$1 = -1\n+// debugger:print y\n+// check:$2 = 1\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$3 = -1\n+// debugger:print y\n+// check:$4 = 2.5\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$5 = -2.5\n+// debugger:print y\n+// check:$6 = 1\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print x\n+// check:$7 = -2.5\n+// debugger:print y\n+// check:$8 = 2.5\n+// debugger:continue\n+\n+fn outer<TA: Clone>(a: TA) {\n+    inner(a.clone(), 1);\n+    inner(a.clone(), 2.5);\n+\n+    fn inner<TX, TY>(x: TX, y: TY) {\n+        zzz();\n+    }\n+}\n+\n+fn main() {\n+    outer(-1);\n+    outer(-2.5);\n+}\n+\n+fn zzz() {()}"}, {"sha": "20569691fd4b530e8b189a35030c06c6f1acde59", "filename": "src/test/debug-info/generic-method-on-generic-struct.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-method-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-method-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-method-on-generic-struct.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,140 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// STACK BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$1 = {x = {8888, -8888}}\n+// debugger:print arg1\n+// check:$2 = -1\n+// debugger:print/d arg2\n+// check:$3 = -2\n+// debugger:continue\n+\n+// STACK BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = {8888, -8888}}\n+// debugger:print arg1\n+// check:$4 = -3\n+// debugger:print arg2\n+// check:$5 = -4\n+// debugger:continue\n+\n+// OWNED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$6 = {x = 1234.5}\n+// debugger:print arg1\n+// check:$7 = -5\n+// debugger:print arg2\n+// check:$8 = -6\n+// debugger:continue\n+\n+// OWNED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 1234.5}\n+// debugger:print arg1\n+// check:$9 = -7\n+// debugger:print arg2\n+// check:$10 = -8\n+// debugger:continue\n+\n+// OWNED MOVED\n+// debugger:finish\n+// debugger:print *self\n+// check:$11 = {x = 1234.5}\n+// debugger:print arg1\n+// check:$12 = -9\n+// debugger:print arg2\n+// check:$13 = -10.5\n+// debugger:continue\n+\n+// MANAGED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$14 = {x = -1}\n+// debugger:print arg1\n+// check:$15 = -11\n+// debugger:print arg2\n+// check:$16 = -12.5\n+// debugger:continue\n+\n+// MANAGED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = -1}\n+// debugger:print arg1\n+// check:$17 = -13\n+// debugger:print *arg2\n+// check:$18 = {-14, 14}\n+// debugger:continue\n+\n+// MANAGED SELF\n+// debugger:finish\n+// debugger:print self->val\n+// check:$19 = {x = -1}\n+// debugger:print arg1\n+// check:$20 = -15\n+// debugger:print *arg2\n+// check:$21 = {-16, 16.5}\n+// debugger:continue\n+\n+struct Struct<T> {\n+    x: T\n+}\n+\n+impl<T1> Struct<T1> {\n+\n+    fn self_by_ref<T2>(&self, arg1: int, arg2: T2) -> int {\n+        zzz();\n+        arg1\n+    }\n+\n+    fn self_by_val<T2>(self, arg1: int, arg2: T2) -> int {\n+        zzz();\n+        arg1\n+    }\n+\n+    fn self_owned<T2>(~self, arg1: int, arg2: T2) -> int {\n+        zzz();\n+        arg1\n+    }\n+\n+    fn self_managed<T2>(@self, arg1: int, arg2: T2) -> int {\n+        zzz();\n+        arg1\n+    }\n+}\n+\n+fn main() {\n+    let stack = Struct { x: (8888_u32, -8888_i32) };\n+    let _ = stack.self_by_ref(-1, -2_i8);\n+    let _ = stack.self_by_val(-3, -4_i16);\n+\n+    let owned = ~Struct { x: 1234.5 };\n+    let _ = owned.self_by_ref(-5, -6_i32);\n+    let _ = owned.self_by_val(-7, -8_i64);\n+    let _ = owned.self_owned(-9, -10.5_f32);\n+\n+    let managed = @Struct { x: -1_i16 };\n+    let _ = managed.self_by_ref(-11, -12.5_f64);\n+    let _ = managed.self_by_val(-13, &(-14, 14));\n+    let _ = managed.self_managed(-15, &(-16, 16.5));\n+}\n+\n+fn zzz() {()}"}, {"sha": "3a5380b8ab28aaf5df1dac466e0ff21f14fc38e7", "filename": "src/test/debug-info/generic-static-method-on-struct-and-enum.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-static-method-on-struct-and-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-static-method-on-struct-and-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-static-method-on-struct-and-enum.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// STRUCT\n+// debugger:finish\n+// debugger:print arg1\n+// check:$1 = 1\n+// debugger:print arg2\n+// check:$2 = 2\n+// debugger:continue\n+\n+// ENUM\n+// debugger:finish\n+// debugger:print arg1\n+// check:$3 = -3\n+// debugger:print arg2\n+// check:$4 = 4.5\n+// debugger:print arg3\n+// check:$5 = 5\n+// debugger:continue\n+\n+\n+struct Struct {\n+    x: int\n+}\n+\n+impl Struct {\n+\n+    fn static_method<T1, T2>(arg1: T1, arg2: T2) -> int {\n+        zzz();\n+        return 0;\n+    }\n+}\n+\n+enum Enum {\n+    Variant1 { x: int },\n+    Variant2,\n+    Variant3(float, int, char),\n+}\n+\n+impl Enum {\n+\n+    fn static_method<T1, T2, T3>(arg1: T1, arg2: T2, arg3: T3) -> int {\n+        zzz();\n+        return 1;\n+    }\n+}\n+\n+fn main() {\n+    Struct::static_method(1, 2);\n+    Enum::static_method(-3, 4.5, 5);\n+}\n+\n+fn zzz() {()}"}, {"sha": "77ac7895366d78bb51f3db2857c923e30721aaa7", "filename": "src/test/debug-info/generic-struct-style-enum.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-struct-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-struct-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-struct-style-enum.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print union on\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print case1\n+// check:$1 = {{Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {Case1, a = 0, b = 2088533116, c = 2088533116}, {Case1, a = 0, b = 8970181431921507452}}\n+\n+// debugger:print case2\n+// check:$2 = {{Case2, a = 0, b = 4369, c = 4369, d = 4369, e = 4369}, {Case2, a = 0, b = 286331153, c = 286331153}, {Case2, a = 0, b = 1229782938247303441}}\n+\n+// debugger:print case3\n+// check:$3 = {{Case3, a = 0, b = 22873, c = 22873, d = 22873, e = 22873}, {Case3, a = 0, b = 1499027801, c = 1499027801}, {Case3, a = 0, b = 6438275382588823897}}\n+\n+// debugger:print univariant\n+// check:$4 = {a = -1}\n+\n+// NOTE: This is a copy of the non-generic test case. The `Txx` type parameters have to be\n+// substituted with something of size `xx` bits and the same alignment as an integer type of the\n+// same size.\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular<T16, T32, T64> {\n+    Case1 { a: T64, b: T16, c: T16, d: T16, e: T16},\n+    Case2 { a: T64, b: T32, c: T32},\n+    Case3 { a: T64, b: T64 }\n+}\n+\n+enum Univariant<T> {\n+    TheOnlyCase { a: T }\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianess trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1: Regular<u16, u32, i64> = Case1 { a: 0, b: 31868, c: 31868, d: 31868, e: 31868 };\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2: Regular<i16, u32, i64>  = Case2 { a: 0, b: 286331153, c: 286331153 };\n+\n+    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n+    // 0b01011001010110010101100101011001 = 1499027801\n+    // 0b0101100101011001 = 22873\n+    // 0b01011001 = 89\n+    let case3: Regular<u16, i32, u64>  = Case3 { a: 0, b: 6438275382588823897 };\n+\n+    let univariant = TheOnlyCase { a: -1 };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}"}, {"sha": "0044def2707d465ae10ab65c9fe994878ce1e274", "filename": "src/test/debug-info/generic-struct.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-struct.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print int_int\n+// check:$1 = {key = 0, value = 1}\n+// debugger:print int_float\n+// check:$2 = {key = 2, value = 3.5}\n+// debugger:print float_int\n+// check:$3 = {key = 4.5, value = 5}\n+// debugger:print float_int_float\n+// check:$4 = {key = 6.5, value = {key = 7, value = 8.5}}\n+\n+struct AGenericStruct<TKey, TValue> {\n+    key: TKey,\n+    value: TValue\n+}\n+\n+fn main() {\n+\n+    let int_int = AGenericStruct { key: 0, value: 1 };\n+    let int_float = AGenericStruct { key: 2, value: 3.5 };\n+    let float_int = AGenericStruct { key: 4.5, value: 5 };\n+    let float_int_float = AGenericStruct { key: 6.5, value: AGenericStruct { key: 7, value: 8.5 } };\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}"}, {"sha": "ef75c93a56bea36941b3fa7c256f44fd92e1a5b2", "filename": "src/test/debug-info/generic-trait-generic-static-default-method.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-trait-generic-static-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-trait-generic-static-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-trait-generic-static-default-method.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print arg1\n+// check:$1 = 1000\n+// debugger:print *arg2\n+// check:$2 = {1, 2.5}\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print arg1\n+// check:$3 = 2000\n+// debugger:print *arg2\n+// check:$4 = {3.5, {4, 5, 6}}\n+// debugger:continue\n+\n+\n+struct Struct {\n+    x: int\n+}\n+\n+trait Trait<T1> {\n+    fn generic_static_default_method<T2>(arg1: int, arg2: &(T1, T2)) -> int {\n+        zzz();\n+        arg1\n+    }\n+}\n+\n+impl<T> Trait<T> for Struct;\n+\n+fn main() {\n+\n+    // Is this really how to use these?\n+    Trait::generic_static_default_method::<int, Struct, float>(1000, &(1, 2.5));\n+    Trait::generic_static_default_method::<float, Struct, (int, int, int)>(2000, &(3.5, (4, 5, 6)));\n+\n+}\n+\n+fn zzz() {()}"}, {"sha": "d6350e033f0ce3a05dd7e7c064b651826f774b79", "filename": "src/test/debug-info/generic-tuple-style-enum.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-tuple-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fgeneric-tuple-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fgeneric-tuple-style-enum.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print union on\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print case1\n+// check:$1 = {{Case1, 0, 31868, 31868, 31868, 31868}, {Case1, 0, 2088533116, 2088533116}, {Case1, 0, 8970181431921507452}}\n+\n+// debugger:print case2\n+// check:$2 = {{Case2, 0, 4369, 4369, 4369, 4369}, {Case2, 0, 286331153, 286331153}, {Case2, 0, 1229782938247303441}}\n+\n+// debugger:print case3\n+// check:$3 = {{Case3, 0, 22873, 22873, 22873, 22873}, {Case3, 0, 1499027801, 1499027801}, {Case3, 0, 6438275382588823897}}\n+\n+// debugger:print univariant\n+// check:$4 = {-1}\n+\n+\n+// NOTE: This is a copy of the non-generic test case. The `Txx` type parameters have to be\n+// substituted with something of size `xx` bits and the same alignment as an integer type of the\n+// same size.\n+\n+// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n+// the size of the discriminant value is machine dependent, this has be taken into account when\n+// datatype layout should be predictable as in this case.\n+enum Regular<T16, T32, T64> {\n+    Case1(T64, T16, T16, T16, T16),\n+    Case2(T64, T32, T32),\n+    Case3(T64, T64)\n+}\n+\n+enum Univariant<T64> {\n+    TheOnlyCase(T64)\n+}\n+\n+fn main() {\n+\n+    // In order to avoid endianess trouble all of the following test values consist of a single\n+    // repeated byte. This way each interpretation of the union should look the same, no matter if\n+    // this is a big or little endian machine.\n+\n+    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n+    // 0b01111100011111000111110001111100 = 2088533116\n+    // 0b0111110001111100 = 31868\n+    // 0b01111100 = 124\n+    let case1: Regular<u16, u32, u64> = Case1(0_u64, 31868_u16, 31868_u16, 31868_u16, 31868_u16);\n+\n+    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n+    // 0b00010001000100010001000100010001 = 286331153\n+    // 0b0001000100010001 = 4369\n+    // 0b00010001 = 17\n+    let case2: Regular<i16, i32, i64> = Case2(0_i64, 286331153_i32, 286331153_i32);\n+\n+    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n+    // 0b01011001010110010101100101011001 = 1499027801\n+    // 0b0101100101011001 = 22873\n+    // 0b01011001 = 89\n+    let case3: Regular<i16, i32, i64> = Case3(0_i64, 6438275382588823897_i64);\n+\n+    let univariant = TheOnlyCase(-1_i64);\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}"}, {"sha": "11b142b3d2301510475ff23337c6ddbd6b86a8b3", "filename": "src/test/debug-info/lexical-scope-in-parameterless-closure.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Flexical-scope-in-parameterless-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Flexical-scope-in-parameterless-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-parameterless-closure.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z debug-info\n+// debugger:run\n+\n+// Nothing to do here really, just make sure it compiles. See issue #8513.\n+fn main() {\n+    let _ = ||();\n+    let _ = range(1u,3).map(|_| 5);\n+}\n+"}, {"sha": "07481011df3f99597588e3263113ac2602dade47", "filename": "src/test/debug-info/method-on-enum.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fmethod-on-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fmethod-on-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-enum.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,141 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// STACK BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$1 = {{Variant2, x = 1799, y = 1799}, {Variant2, 117901063}}\n+// debugger:print arg1\n+// check:$2 = -1\n+// debugger:print arg2\n+// check:$3 = -2\n+// debugger:continue\n+\n+// STACK BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {{Variant2, x = 1799, y = 1799}, {Variant2, 117901063}}\n+// debugger:print arg1\n+// check:$4 = -3\n+// debugger:print arg2\n+// check:$5 = -4\n+// debugger:continue\n+\n+// OWNED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$6 = {{Variant1, x = 1799, y = 1799}, {Variant1, 117901063}}\n+// debugger:print arg1\n+// check:$7 = -5\n+// debugger:print arg2\n+// check:$8 = -6\n+// debugger:continue\n+\n+// OWNED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {{Variant1, x = 1799, y = 1799}, {Variant1, 117901063}}\n+// debugger:print arg1\n+// check:$9 = -7\n+// debugger:print arg2\n+// check:$10 = -8\n+// debugger:continue\n+\n+// OWNED MOVED\n+// debugger:finish\n+// debugger:print *self\n+// check:$11 = {{Variant1, x = 1799, y = 1799}, {Variant1, 117901063}}\n+// debugger:print arg1\n+// check:$12 = -9\n+// debugger:print arg2\n+// check:$13 = -10\n+// debugger:continue\n+\n+// MANAGED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$14 = {{Variant2, x = 1799, y = 1799}, {Variant2, 117901063}}\n+// debugger:print arg1\n+// check:$15 = -11\n+// debugger:print arg2\n+// check:$16 = -12\n+// debugger:continue\n+\n+// MANAGED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {{Variant2, x = 1799, y = 1799}, {Variant2, 117901063}}\n+// debugger:print arg1\n+// check:$17 = -13\n+// debugger:print arg2\n+// check:$18 = -14\n+// debugger:continue\n+\n+// MANAGED SELF\n+// debugger:finish\n+// debugger:print self->val\n+// check:$19 = {{Variant2, x = 1799, y = 1799}, {Variant2, 117901063}}\n+// debugger:print arg1\n+// check:$20 = -15\n+// debugger:print arg2\n+// check:$21 = -16\n+// debugger:continue\n+\n+enum Enum {\n+    Variant1 { x: u16, y: u16 },\n+    Variant2 (u32)\n+}\n+\n+impl Enum {\n+\n+    fn self_by_ref(&self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_by_val(self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_managed(@self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+}\n+\n+fn main() {\n+    let stack = Variant2(117901063);\n+    let _ = stack.self_by_ref(-1, -2);\n+    let _ = stack.self_by_val(-3, -4);\n+\n+    let owned = ~Variant1{ x: 1799, y: 1799 };\n+    let _ = owned.self_by_ref(-5, -6);\n+    let _ = owned.self_by_val(-7, -8);\n+    let _ = owned.self_owned(-9, -10);\n+\n+    let managed = @Variant2(117901063);\n+    let _ = managed.self_by_ref(-11, -12);\n+    let _ = managed.self_by_val(-13, -14);\n+    let _ = managed.self_managed(-15, -16);\n+}\n+\n+fn zzz() {()}"}, {"sha": "f482846027ee4679bf3577b020eabfebebe216b8", "filename": "src/test/debug-info/method-on-generic-struct.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fmethod-on-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fmethod-on-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-generic-struct.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,140 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// STACK BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$1 = {x = {8888, -8888}}\n+// debugger:print arg1\n+// check:$2 = -1\n+// debugger:print arg2\n+// check:$3 = -2\n+// debugger:continue\n+\n+// STACK BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = {8888, -8888}}\n+// debugger:print arg1\n+// check:$4 = -3\n+// debugger:print arg2\n+// check:$5 = -4\n+// debugger:continue\n+\n+// OWNED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$6 = {x = 1234.5}\n+// debugger:print arg1\n+// check:$7 = -5\n+// debugger:print arg2\n+// check:$8 = -6\n+// debugger:continue\n+\n+// OWNED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 1234.5}\n+// debugger:print arg1\n+// check:$9 = -7\n+// debugger:print arg2\n+// check:$10 = -8\n+// debugger:continue\n+\n+// OWNED MOVED\n+// debugger:finish\n+// debugger:print *self\n+// check:$11 = {x = 1234.5}\n+// debugger:print arg1\n+// check:$12 = -9\n+// debugger:print arg2\n+// check:$13 = -10\n+// debugger:continue\n+\n+// MANAGED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$14 = {x = -1}\n+// debugger:print arg1\n+// check:$15 = -11\n+// debugger:print arg2\n+// check:$16 = -12\n+// debugger:continue\n+\n+// MANAGED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = -1}\n+// debugger:print arg1\n+// check:$17 = -13\n+// debugger:print arg2\n+// check:$18 = -14\n+// debugger:continue\n+\n+// MANAGED SELF\n+// debugger:finish\n+// debugger:print self->val\n+// check:$19 = {x = -1}\n+// debugger:print arg1\n+// check:$20 = -15\n+// debugger:print arg2\n+// check:$21 = -16\n+// debugger:continue\n+\n+struct Struct<T> {\n+    x: T\n+}\n+\n+impl<T> Struct<T> {\n+\n+    fn self_by_ref(&self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_by_val(self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_managed(@self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+}\n+\n+fn main() {\n+    let stack = Struct { x: (8888_u32, -8888_i32) };\n+    let _ = stack.self_by_ref(-1, -2);\n+    let _ = stack.self_by_val(-3, -4);\n+\n+    let owned = ~Struct { x: 1234.5 };\n+    let _ = owned.self_by_ref(-5, -6);\n+    let _ = owned.self_by_val(-7, -8);\n+    let _ = owned.self_owned(-9, -10);\n+\n+    let managed = @Struct { x: -1_i16 };\n+    let _ = managed.self_by_ref(-11, -12);\n+    let _ = managed.self_by_val(-13, -14);\n+    let _ = managed.self_managed(-15, -16);\n+}\n+\n+fn zzz() {()}"}, {"sha": "211f83e6107de40da7af7aa5dfca40cd2af7f765", "filename": "src/test/debug-info/method-on-struct.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fmethod-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fmethod-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-struct.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,140 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// STACK BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$1 = {x = 100}\n+// debugger:print arg1\n+// check:$2 = -1\n+// debugger:print arg2\n+// check:$3 = -2\n+// debugger:continue\n+\n+// STACK BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 100}\n+// debugger:print arg1\n+// check:$4 = -3\n+// debugger:print arg2\n+// check:$5 = -4\n+// debugger:continue\n+\n+// OWNED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$6 = {x = 200}\n+// debugger:print arg1\n+// check:$7 = -5\n+// debugger:print arg2\n+// check:$8 = -6\n+// debugger:continue\n+\n+// OWNED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 200}\n+// debugger:print arg1\n+// check:$9 = -7\n+// debugger:print arg2\n+// check:$10 = -8\n+// debugger:continue\n+\n+// OWNED MOVED\n+// debugger:finish\n+// debugger:print *self\n+// check:$11 = {x = 200}\n+// debugger:print arg1\n+// check:$12 = -9\n+// debugger:print arg2\n+// check:$13 = -10\n+// debugger:continue\n+\n+// MANAGED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$14 = {x = 300}\n+// debugger:print arg1\n+// check:$15 = -11\n+// debugger:print arg2\n+// check:$16 = -12\n+// debugger:continue\n+\n+// MANAGED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 300}\n+// debugger:print arg1\n+// check:$17 = -13\n+// debugger:print arg2\n+// check:$18 = -14\n+// debugger:continue\n+\n+// MANAGED SELF\n+// debugger:finish\n+// debugger:print self->val\n+// check:$19 = {x = 300}\n+// debugger:print arg1\n+// check:$20 = -15\n+// debugger:print arg2\n+// check:$21 = -16\n+// debugger:continue\n+\n+struct Struct {\n+    x: int\n+}\n+\n+impl Struct {\n+\n+    fn self_by_ref(&self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        self.x + arg1 + arg2\n+    }\n+\n+    fn self_by_val(self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        self.x + arg1 + arg2\n+    }\n+\n+    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        self.x + arg1 + arg2\n+    }\n+\n+    fn self_managed(@self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        self.x + arg1 + arg2\n+    }\n+}\n+\n+fn main() {\n+    let stack = Struct { x: 100 };\n+    let _ = stack.self_by_ref(-1, -2);\n+    let _ = stack.self_by_val(-3, -4);\n+\n+    let owned = ~Struct { x: 200 };\n+    let _ = owned.self_by_ref(-5, -6);\n+    let _ = owned.self_by_val(-7, -8);\n+    let _ = owned.self_owned(-9, -10);\n+\n+    let managed = @Struct { x: 300 };\n+    let _ = managed.self_by_ref(-11, -12);\n+    let _ = managed.self_by_val(-13, -14);\n+    let _ = managed.self_managed(-15, -16);\n+}\n+\n+fn zzz() {()}"}, {"sha": "ad6c9a1cada4fdf68c3d0f2d8f9fa31e6946de72", "filename": "src/test/debug-info/method-on-trait.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fmethod-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fmethod-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-trait.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,147 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// STACK BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$1 = {x = 100}\n+// debugger:print arg1\n+// check:$2 = -1\n+// debugger:print arg2\n+// check:$3 = -2\n+// debugger:continue\n+\n+// STACK BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 100}\n+// debugger:print arg1\n+// check:$4 = -3\n+// debugger:print arg2\n+// check:$5 = -4\n+// debugger:continue\n+\n+// OWNED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$6 = {x = 200}\n+// debugger:print arg1\n+// check:$7 = -5\n+// debugger:print arg2\n+// check:$8 = -6\n+// debugger:continue\n+\n+// OWNED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 200}\n+// debugger:print arg1\n+// check:$9 = -7\n+// debugger:print arg2\n+// check:$10 = -8\n+// debugger:continue\n+\n+// OWNED MOVED\n+// debugger:finish\n+// debugger:print *self\n+// check:$11 = {x = 200}\n+// debugger:print arg1\n+// check:$12 = -9\n+// debugger:print arg2\n+// check:$13 = -10\n+// debugger:continue\n+\n+// MANAGED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$14 = {x = 300}\n+// debugger:print arg1\n+// check:$15 = -11\n+// debugger:print arg2\n+// check:$16 = -12\n+// debugger:continue\n+\n+// MANAGED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 300}\n+// debugger:print arg1\n+// check:$17 = -13\n+// debugger:print arg2\n+// check:$18 = -14\n+// debugger:continue\n+\n+// MANAGED SELF\n+// debugger:finish\n+// debugger:print self->val\n+// check:$19 = {x = 300}\n+// debugger:print arg1\n+// check:$20 = -15\n+// debugger:print arg2\n+// check:$21 = -16\n+// debugger:continue\n+\n+struct Struct {\n+    x: int\n+}\n+\n+trait Trait {\n+    fn self_by_ref(&self, arg1: int, arg2: int) -> int;\n+    fn self_by_val(self, arg1: int, arg2: int) -> int;\n+    fn self_owned(~self, arg1: int, arg2: int) -> int;\n+    fn self_managed(@self, arg1: int, arg2: int) -> int;\n+}\n+\n+impl Trait for Struct {\n+\n+    fn self_by_ref(&self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        self.x + arg1 + arg2\n+    }\n+\n+    fn self_by_val(self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        self.x + arg1 + arg2\n+    }\n+\n+    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        self.x + arg1 + arg2\n+    }\n+\n+    fn self_managed(@self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        self.x + arg1 + arg2\n+    }\n+}\n+\n+fn main() {\n+    let stack = Struct { x: 100 };\n+    let _ = stack.self_by_ref(-1, -2);\n+    let _ = stack.self_by_val(-3, -4);\n+\n+    let owned = ~Struct { x: 200 };\n+    let _ = owned.self_by_ref(-5, -6);\n+    let _ = owned.self_by_val(-7, -8);\n+    let _ = owned.self_owned(-9, -10);\n+\n+    let managed = @Struct { x: 300 };\n+    let _ = managed.self_by_ref(-11, -12);\n+    let _ = managed.self_by_val(-13, -14);\n+    let _ = managed.self_managed(-15, -16);\n+}\n+\n+fn zzz() {()}"}, {"sha": "03d7c44059fa19ec1cdb72a0460cbf8a1a5e3dee", "filename": "src/test/debug-info/method-on-tuple-struct.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fmethod-on-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fmethod-on-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fmethod-on-tuple-struct.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,138 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// STACK BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$1 = {100, -100.5}\n+// debugger:print arg1\n+// check:$2 = -1\n+// debugger:print arg2\n+// check:$3 = -2\n+// debugger:continue\n+\n+// STACK BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {100, -100.5}\n+// debugger:print arg1\n+// check:$4 = -3\n+// debugger:print arg2\n+// check:$5 = -4\n+// debugger:continue\n+\n+// OWNED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$6 = {200, -200.5}\n+// debugger:print arg1\n+// check:$7 = -5\n+// debugger:print arg2\n+// check:$8 = -6\n+// debugger:continue\n+\n+// OWNED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {200, -200.5}\n+// debugger:print arg1\n+// check:$9 = -7\n+// debugger:print arg2\n+// check:$10 = -8\n+// debugger:continue\n+\n+// OWNED MOVED\n+// debugger:finish\n+// debugger:print *self\n+// check:$11 = {200, -200.5}\n+// debugger:print arg1\n+// check:$12 = -9\n+// debugger:print arg2\n+// check:$13 = -10\n+// debugger:continue\n+\n+// MANAGED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$14 = {300, -300.5}\n+// debugger:print arg1\n+// check:$15 = -11\n+// debugger:print arg2\n+// check:$16 = -12\n+// debugger:continue\n+\n+// MANAGED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {300, -300.5}\n+// debugger:print arg1\n+// check:$17 = -13\n+// debugger:print arg2\n+// check:$18 = -14\n+// debugger:continue\n+\n+// MANAGED SELF\n+// debugger:finish\n+// debugger:print self->val\n+// check:$19 = {300, -300.5}\n+// debugger:print arg1\n+// check:$20 = -15\n+// debugger:print arg2\n+// check:$21 = -16\n+// debugger:continue\n+\n+struct TupleStruct(int, float);\n+\n+impl TupleStruct {\n+\n+    fn self_by_ref(&self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_by_val(self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_managed(@self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+}\n+\n+fn main() {\n+    let stack = TupleStruct(100, -100.5);\n+    let _ = stack.self_by_ref(-1, -2);\n+    let _ = stack.self_by_val(-3, -4);\n+\n+    let owned = ~TupleStruct(200, -200.5);\n+    let _ = owned.self_by_ref(-5, -6);\n+    let _ = owned.self_by_val(-7, -8);\n+    let _ = owned.self_owned(-9, -10);\n+\n+    let managed = @TupleStruct(300, -300.5);\n+    let _ = managed.self_by_ref(-11, -12);\n+    let _ = managed.self_by_val(-13, -14);\n+    let _ = managed.self_managed(-15, -16);\n+}\n+\n+fn zzz() {()}"}, {"sha": "02fd294a0bd5e555c12c9b31a177ef4fc7826aba", "filename": "src/test/debug-info/option-like-enum.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n-// xfail-test broken in newrt?\n \n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n@@ -25,31 +24,47 @@\n // debugger:print full\n // check:$3 = {454545, 0x87654321, 9988}\n \n-// debugger:print empty\n-// check:$4 = {0, 0x0, 0}\n+// debugger:print empty->discr\n+// check:$4 = (int *) 0x0\n \n // debugger:print droid\n // check:$5 = {id = 675675, range = 10000001, internals = 0x43218765}\n \n-// debugger:print void_droid\n-// check:$6 = {id = 0, range = 0, internals = 0x0}\n+// debugger:print void_droid->internals\n+// check:$6 = (int *) 0x0\n \n+// debugger:continue\n \n // If a struct has exactly two variants, one of them is empty, and the other one\n // contains a non-nullable pointer, then this value is used as the discriminator.\n // The test cases in this file make sure that something readable is generated for\n // this kind of types.\n+// Unfortunately (for these test cases) the content of the non-discriminant fields\n+// in the null-case is not defined. So we just read the discriminator field in\n+// this case (by casting the value to a memory-equivalent struct).\n \n enum MoreFields<'self> {\n     Full(u32, &'self int, i16),\n     Empty\n }\n \n+struct MoreFieldsRepr<'self> {\n+    a: u32,\n+    discr: &'self int,\n+    b: i16\n+}\n+\n enum NamedFields<'self> {\n     Droid { id: i32, range: i64, internals: &'self int },\n     Void\n }\n \n+struct NamedFieldsRepr<'self> {\n+    id: i32,\n+    range: i64,\n+    internals: &'self int\n+}\n+\n fn main() {\n \n     let some: Option<&u32> = Some(unsafe { std::cast::transmute(0x12345678) });\n@@ -58,15 +73,17 @@ fn main() {\n     let full = Full(454545, unsafe { std::cast::transmute(0x87654321) }, 9988);\n \n     let int_val = 0;\n-    let mut empty = Full(0, &int_val, 0);\n-    empty = Empty;\n+    let empty: &MoreFieldsRepr = unsafe { std::cast::transmute(&Empty) };\n \n-    let droid = Droid { id: 675675, range: 10000001, internals: unsafe { std::cast::transmute(0x43218765) } };\n+    let droid = Droid {\n+        id: 675675,\n+        range: 10000001,\n+        internals: unsafe { std::cast::transmute(0x43218765) }\n+    };\n \n-    let mut void_droid = Droid { id: 0, range: 0, internals: &int_val };\n-    void_droid = Void;\n+    let void_droid: &NamedFieldsRepr = unsafe { std::cast::transmute(&Void) };\n \n     zzz();\n }\n \n-fn zzz() {()}\n\\ No newline at end of file\n+fn zzz() {()}"}, {"sha": "cc7cab395934064fee3e29af8078ca79e62dc9d8", "filename": "src/test/debug-info/self-in-default-method.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fself-in-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fself-in-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fself-in-default-method.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,141 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// STACK BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$1 = {x = 100}\n+// debugger:print arg1\n+// check:$2 = -1\n+// debugger:print arg2\n+// check:$3 = -2\n+// debugger:continue\n+\n+// STACK BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 100}\n+// debugger:print arg1\n+// check:$4 = -3\n+// debugger:print arg2\n+// check:$5 = -4\n+// debugger:continue\n+\n+// OWNED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$6 = {x = 200}\n+// debugger:print arg1\n+// check:$7 = -5\n+// debugger:print arg2\n+// check:$8 = -6\n+// debugger:continue\n+\n+// OWNED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 200}\n+// debugger:print arg1\n+// check:$9 = -7\n+// debugger:print arg2\n+// check:$10 = -8\n+// debugger:continue\n+\n+// OWNED MOVED\n+// debugger:finish\n+// debugger:print *self\n+// check:$11 = {x = 200}\n+// debugger:print arg1\n+// check:$12 = -9\n+// debugger:print arg2\n+// check:$13 = -10\n+// debugger:continue\n+\n+// MANAGED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$14 = {x = 300}\n+// debugger:print arg1\n+// check:$15 = -11\n+// debugger:print arg2\n+// check:$16 = -12\n+// debugger:continue\n+\n+// MANAGED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 300}\n+// debugger:print arg1\n+// check:$17 = -13\n+// debugger:print arg2\n+// check:$18 = -14\n+// debugger:continue\n+\n+// MANAGED SELF\n+// debugger:finish\n+// debugger:print self->val\n+// check:$19 = {x = 300}\n+// debugger:print arg1\n+// check:$20 = -15\n+// debugger:print arg2\n+// check:$21 = -16\n+// debugger:continue\n+\n+struct Struct {\n+    x: int\n+}\n+\n+trait Trait {\n+    fn self_by_ref(&self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_by_val(self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_owned(~self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+\n+    fn self_managed(@self, arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+}\n+\n+impl Trait for Struct;\n+\n+fn main() {\n+    let stack = Struct { x: 100 };\n+    let _ = stack.self_by_ref(-1, -2);\n+    let _ = stack.self_by_val(-3, -4);\n+\n+    let owned = ~Struct { x: 200 };\n+    let _ = owned.self_by_ref(-5, -6);\n+    let _ = owned.self_by_val(-7, -8);\n+    let _ = owned.self_owned(-9, -10);\n+\n+    let managed = @Struct { x: 300 };\n+    let _ = managed.self_by_ref(-11, -12);\n+    let _ = managed.self_by_val(-13, -14);\n+    let _ = managed.self_managed(-15, -16);\n+}\n+\n+fn zzz() {()}"}, {"sha": "57068df7c0bf33869a3457fdcd1dbca149619c1a", "filename": "src/test/debug-info/self-in-generic-default-method.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fself-in-generic-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fself-in-generic-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fself-in-generic-default-method.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,142 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// STACK BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$1 = {x = 987}\n+// debugger:print arg1\n+// check:$2 = -1\n+// debugger:print/d arg2\n+// check:$3 = -2\n+// debugger:continue\n+\n+// STACK BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 987}\n+// debugger:print arg1\n+// check:$4 = -3\n+// debugger:print arg2\n+// check:$5 = -4\n+// debugger:continue\n+\n+// OWNED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$6 = {x = 879}\n+// debugger:print arg1\n+// check:$7 = -5\n+// debugger:print arg2\n+// check:$8 = -6\n+// debugger:continue\n+\n+// OWNED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 879}\n+// debugger:print arg1\n+// check:$9 = -7\n+// debugger:print arg2\n+// check:$10 = -8\n+// debugger:continue\n+\n+// OWNED MOVED\n+// debugger:finish\n+// debugger:print *self\n+// check:$11 = {x = 879}\n+// debugger:print arg1\n+// check:$12 = -9\n+// debugger:print arg2\n+// check:$13 = -10.5\n+// debugger:continue\n+\n+// MANAGED BY REF\n+// debugger:finish\n+// debugger:print *self\n+// check:$14 = {x = 897}\n+// debugger:print arg1\n+// check:$15 = -11\n+// debugger:print arg2\n+// check:$16 = -12.5\n+// debugger:continue\n+\n+// MANAGED BY VAL\n+// debugger:finish\n+// d ebugger:print self -- ignored for now because of issue #8512\n+// c heck:$X = {x = 897}\n+// debugger:print arg1\n+// check:$17 = -13\n+// debugger:print *arg2\n+// check:$18 = {-14, 14}\n+// debugger:continue\n+\n+// MANAGED SELF\n+// debugger:finish\n+// debugger:print self->val\n+// check:$19 = {x = 897}\n+// debugger:print arg1\n+// check:$20 = -15\n+// debugger:print *arg2\n+// check:$21 = {-16, 16.5}\n+// debugger:continue\n+\n+struct Struct {\n+    x: int\n+}\n+\n+trait Trait {\n+\n+    fn self_by_ref<T>(&self, arg1: int, arg2: T) -> int {\n+        zzz();\n+        arg1\n+    }\n+\n+    fn self_by_val<T>(self, arg1: int, arg2: T) -> int {\n+        zzz();\n+        arg1\n+    }\n+\n+    fn self_owned<T>(~self, arg1: int, arg2: T) -> int {\n+        zzz();\n+        arg1\n+    }\n+\n+    fn self_managed<T>(@self, arg1: int, arg2: T) -> int {\n+        zzz();\n+        arg1\n+    }\n+}\n+\n+impl Trait for Struct;\n+\n+fn main() {\n+    let stack = Struct { x: 987 };\n+    let _ = stack.self_by_ref(-1, -2_i8);\n+    let _ = stack.self_by_val(-3, -4_i16);\n+\n+    let owned = ~Struct { x: 879 };\n+    let _ = owned.self_by_ref(-5, -6_i32);\n+    let _ = owned.self_by_val(-7, -8_i64);\n+    let _ = owned.self_owned(-9, -10.5_f32);\n+\n+    let managed = @Struct { x: 897 };\n+    let _ = managed.self_by_ref(-11, -12.5_f64);\n+    let _ = managed.self_by_val(-13, &(-14, 14));\n+    let _ = managed.self_managed(-15, &(-16, 16.5));\n+}\n+\n+fn zzz() {()}"}, {"sha": "ecc74e442d040626f0f6f22e1851eb1d53b101d5", "filename": "src/test/debug-info/static-method-on-struct-and-enum.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fstatic-method-on-struct-and-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Fstatic-method-on-struct-and-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstatic-method-on-struct-and-enum.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// STRUCT\n+// debugger:finish\n+// debugger:print arg1\n+// check:$1 = 1\n+// debugger:print arg2\n+// check:$2 = 2\n+// debugger:continue\n+\n+// ENUM\n+// debugger:finish\n+// debugger:print arg1\n+// check:$3 = -3\n+// debugger:print arg2\n+// check:$4 = 4.5\n+// debugger:print arg3\n+// check:$5 = 5\n+// debugger:continue\n+\n+\n+struct Struct {\n+    x: int\n+}\n+\n+impl Struct {\n+\n+    fn static_method(arg1: int, arg2: int) -> int {\n+        zzz();\n+        arg1 + arg2\n+    }\n+}\n+\n+enum Enum {\n+    Variant1 { x: int },\n+    Variant2,\n+    Variant3(float, int, char),\n+}\n+\n+impl Enum {\n+\n+    fn static_method(arg1: int, arg2: float, arg3: uint) -> int {\n+        zzz();\n+        arg1\n+    }\n+}\n+\n+fn main() {\n+    Struct::static_method(1, 2);\n+    Enum::static_method(-3, 4.5, 5);\n+}\n+\n+fn zzz() {()}"}, {"sha": "33468c974eba71a2c1278f9ff8a1237b6443cfff", "filename": "src/test/debug-info/trait-generic-static-default-method.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Ftrait-generic-static-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Ftrait-generic-static-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftrait-generic-static-default-method.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+\n+// debugger:finish\n+// debugger:print arg1\n+// check:$1 = 1000\n+// debugger:print arg2\n+// check:$2 = 0.5\n+// debugger:continue\n+\n+// debugger:finish\n+// debugger:print arg1\n+// check:$3 = 2000\n+// debugger:print *arg2\n+// check:$4 = {1, 2, 3}\n+// debugger:continue\n+\n+\n+struct Struct {\n+    x: int\n+}\n+\n+trait Trait {\n+    fn generic_static_default_method<T>(arg1: int, arg2: T) -> int {\n+        zzz();\n+        arg1\n+    }\n+}\n+\n+impl Trait for Struct;\n+\n+fn main() {\n+\n+    // Is this really how to use these?\n+    Trait::generic_static_default_method::<Struct, float>(1000, 0.5);\n+    Trait::generic_static_default_method::<Struct, &(int, int, int)>(2000, &(1, 2, 3));\n+\n+}\n+\n+fn zzz() {()}"}, {"sha": "ada3802e15d5a899edb651c11110bd0980d2d26b", "filename": "src/test/debug-info/tuple-struct.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Ftuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/679102109fd72c2560de0988324c14af3ae27c7a/src%2Ftest%2Fdebug-info%2Ftuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftuple-struct.rs?ref=679102109fd72c2560de0988324c14af3ae27c7a", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print no_padding16\n+// check:$1 = {10000, -10001}\n+\n+// debugger:print no_padding32\n+// check:$2 = {-10002, -10003.5, 10004}\n+\n+// debugger:print no_padding64\n+// check:$3 = {-10005.5, 10006, 10007}\n+\n+// debugger:print no_padding163264\n+// check:$4 = {-10008, 10009, 10010, 10011}\n+\n+// debugger:print internal_padding\n+// check:$5 = {10012, -10013}\n+\n+// debugger:print padding_at_end\n+// check:$6 = {-10014, 10015}\n+\n+\n+// This test case mainly makes sure that no field names are generated for tuple structs (as opposed\n+// to all fields having the name \"__field__\"). Otherwise they are handled the same a normal structs.\n+\n+struct NoPadding16(u16, i16);\n+struct NoPadding32(i32, f32, u32);\n+struct NoPadding64(f64, i64, u64);\n+struct NoPadding163264(i16, u16, i32, u64);\n+struct InternalPadding(u16, i64);\n+struct PaddingAtEnd(i64, u16);\n+\n+fn main() {\n+    let no_padding16 = NoPadding16(10000, -10001);\n+    let no_padding32 = NoPadding32(-10002, -10003.5, 10004);\n+    let no_padding64 = NoPadding64(-10005.5, 10006, 10007);\n+    let no_padding163264 = NoPadding163264(-10008, 10009, 10010, 10011);\n+\n+    let internal_padding = InternalPadding(10012, -10013);\n+    let padding_at_end = PaddingAtEnd(-10014, 10015);\n+\n+    zzz();\n+}\n+\n+fn zzz() {()}"}]}