{"sha": "036e5b2806256601408d91b5bbb4907bfb110760", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNmU1YjI4MDYyNTY2MDE0MDhkOTFiNWJiYjQ5MDdiZmIxMTA3NjA=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-20T17:56:04Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-20T17:56:04Z"}, "message": "Refactor name resolution to resolve derive helpers", "tree": {"sha": "8742d859eed0fdd5a5ae8bb334718c514780350f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8742d859eed0fdd5a5ae8bb334718c514780350f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/036e5b2806256601408d91b5bbb4907bfb110760", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/036e5b2806256601408d91b5bbb4907bfb110760", "html_url": "https://github.com/rust-lang/rust/commit/036e5b2806256601408d91b5bbb4907bfb110760", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/036e5b2806256601408d91b5bbb4907bfb110760/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f088606d8946d992c61153dc7f208efdaf9fb12d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f088606d8946d992c61153dc7f208efdaf9fb12d", "html_url": "https://github.com/rust-lang/rust/commit/f088606d8946d992c61153dc7f208efdaf9fb12d"}], "stats": {"total": 220, "additions": 135, "deletions": 85}, "files": [{"sha": "2d1cba632d4ff1cff19c604f113073cf784b6c6c", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 113, "deletions": 85, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/036e5b2806256601408d91b5bbb4907bfb110760/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036e5b2806256601408d91b5bbb4907bfb110760/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=036e5b2806256601408d91b5bbb4907bfb110760", "patch": "@@ -20,7 +20,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast;\n \n use crate::{\n-    attr::{AttrId, Attrs},\n+    attr::{Attr, AttrId, Attrs},\n     builtin_attr,\n     db::DefDatabase,\n     derive_macro_as_call_id,\n@@ -100,8 +100,8 @@ pub(super) fn collect_defs(\n         proc_macros,\n         exports_proc_macros: false,\n         from_glob_import: Default::default(),\n-        ignore_attrs_on: FxHashSet::default(),\n-        derive_helpers_in_scope: FxHashMap::default(),\n+        ignore_attrs_on: Default::default(),\n+        derive_helpers_in_scope: Default::default(),\n     };\n     match block {\n         Some(block) => {\n@@ -247,7 +247,13 @@ struct DefCollector<'a> {\n     proc_macros: Vec<(Name, ProcMacroExpander)>,\n     exports_proc_macros: bool,\n     from_glob_import: PerNsGlobImports,\n-    ignore_attrs_on: FxHashSet<InFile<ModItem>>,\n+    /// If we fail to resolve an attribute on a `ModItem`, we fall back to ignoring the attribute.\n+    /// This map is used to skip all attributes up to and including the one that failed to resolve,\n+    /// in order to not expand them twice.\n+    ///\n+    /// This also stores the attributes to skip when we resolve derive helpers and non-macro\n+    /// non-builtin attributes in general.\n+    ignore_attrs_on: FxHashMap<InFile<ModItem>, AttrId>,\n     /// Tracks which custom derives are in scope for an item, to allow resolution of derive helper\n     /// attributes.\n     derive_helpers_in_scope: FxHashMap<AstId<ast::Item>, Vec<Name>>,\n@@ -319,7 +325,7 @@ impl DefCollector<'_> {\n                 }\n             }\n \n-            if self.reseed_with_unresolved_attributes() == ReachedFixedPoint::Yes {\n+            if self.reseed_with_unresolved_attribute() == ReachedFixedPoint::Yes {\n                 break;\n             }\n         }\n@@ -362,25 +368,21 @@ impl DefCollector<'_> {\n     }\n \n     /// When the fixed-point loop reaches a stable state, we might still have some unresolved\n-    /// attributes (or unexpanded attribute proc macros) left over. This takes them, and feeds the\n-    /// item they're applied to back into name resolution.\n+    /// attributes (or unexpanded attribute proc macros) left over. This takes one of them, and\n+    /// feeds the item it's applied to back into name resolution.\n     ///\n     /// This effectively ignores the fact that the macro is there and just treats the items as\n     /// normal code.\n     ///\n     /// This improves UX when proc macros are turned off or don't work, and replicates the behavior\n     /// before we supported proc. attribute macros.\n-    fn reseed_with_unresolved_attributes(&mut self) -> ReachedFixedPoint {\n+    fn reseed_with_unresolved_attribute(&mut self) -> ReachedFixedPoint {\n         cov_mark::hit!(unresolved_attribute_fallback);\n \n-        let mut added_items = false;\n-        let unresolved_macros = std::mem::replace(&mut self.unresolved_macros, Vec::new());\n-        for directive in &unresolved_macros {\n-            if let MacroDirectiveKind::Attr { ast_id, mod_item, .. } = &directive.kind {\n-                // Make sure to only add such items once.\n-                if !self.ignore_attrs_on.insert(ast_id.ast_id.with_value(*mod_item)) {\n-                    continue;\n-                }\n+        let mut unresolved_macros = std::mem::replace(&mut self.unresolved_macros, Vec::new());\n+        let pos = unresolved_macros.iter().position(|directive| {\n+            if let MacroDirectiveKind::Attr { ast_id, mod_item, attr } = &directive.kind {\n+                self.ignore_attrs_on.insert(ast_id.ast_id.with_value(*mod_item), *attr);\n \n                 let file_id = self.def_map[directive.module_id].definition_source(self.db).file_id;\n                 let item_tree = self.db.file_item_tree(file_id);\n@@ -394,14 +396,20 @@ impl DefCollector<'_> {\n                     mod_dir,\n                 }\n                 .collect(&[*mod_item]);\n-                added_items = true;\n+                true\n+            } else {\n+                false\n             }\n+        });\n+\n+        if let Some(pos) = pos {\n+            unresolved_macros.remove(pos);\n         }\n \n         // The collection above might add new unresolved macros (eg. derives), so merge the lists.\n         self.unresolved_macros.extend(unresolved_macros);\n \n-        if added_items {\n+        if pos.is_some() {\n             // Continue name resolution with the new data.\n             ReachedFixedPoint::No\n         } else {\n@@ -922,14 +930,45 @@ impl DefCollector<'_> {\n                         Err(UnresolvedMacro { .. }) => (),\n                     }\n                 }\n-                MacroDirectiveKind::Attr { .. } => {\n-                    // not yet :)\n+                MacroDirectiveKind::Attr { ast_id, mod_item, attr } => {\n+                    if let Some(ident) = ast_id.path.as_ident() {\n+                        if let Some(helpers) = self.derive_helpers_in_scope.get(&ast_id.ast_id) {\n+                            if helpers.contains(ident) {\n+                                cov_mark::hit!(resolved_derive_helper);\n+\n+                                // Resolved to derive helper. Collect the item's attributes again,\n+                                // starting after the derive helper.\n+                                let file_id = self.def_map[directive.module_id]\n+                                    .definition_source(self.db)\n+                                    .file_id;\n+                                let item_tree = self.db.file_item_tree(file_id);\n+                                let mod_dir = self.mod_dirs[&directive.module_id].clone();\n+                                self.ignore_attrs_on.insert(InFile::new(file_id, *mod_item), *attr);\n+                                ModCollector {\n+                                    def_collector: &mut *self,\n+                                    macro_depth: directive.depth,\n+                                    module_id: directive.module_id,\n+                                    file_id,\n+                                    item_tree: &item_tree,\n+                                    mod_dir,\n+                                }\n+                                .collect(&[*mod_item]);\n+\n+                                // Remove the original directive since we resolved it.\n+                                return false;\n+                            }\n+                        }\n+                    }\n+\n+                    // Not resolved to a derive helper, so try to resolve as a macro.\n+                    // FIXME: not yet :)\n                 }\n             }\n \n             true\n         });\n-        self.unresolved_macros = macros;\n+        // Attribute resolution can add unresolved macro invocations, so concatenate the lists.\n+        self.unresolved_macros.extend(macros);\n \n         for (module_id, macro_call_id, depth) in resolved {\n             self.collect_macro_expansion(module_id, macro_call_id, depth);\n@@ -1102,7 +1141,7 @@ impl ModCollector<'_, '_> {\n \n         // Prelude module is always considered to be `#[macro_use]`.\n         if let Some(prelude_module) = self.def_collector.def_map.prelude {\n-            if prelude_module.krate != self.def_collector.def_map.krate {\n+            if prelude_module.krate != krate {\n                 cov_mark::hit!(prelude_is_macro_use);\n                 self.def_collector.import_all_macros_exported(self.module_id, prelude_module.krate);\n             }\n@@ -1137,7 +1176,7 @@ impl ModCollector<'_, '_> {\n                 }\n             }\n \n-            if let Err(()) = self.resolve_attributes(&attrs, None, item) {\n+            if let Err(()) = self.resolve_attributes(&attrs, item) {\n                 // Do not process the item. It has at least one non-builtin attribute, so the\n                 // fixed-point algorithm is required to resolve the rest of them.\n                 continue;\n@@ -1203,11 +1242,6 @@ impl ModCollector<'_, '_> {\n                 ModItem::Struct(id) => {\n                     let it = &self.item_tree[id];\n \n-                    // FIXME: check attrs to see if this is an attribute macro invocation;\n-                    // in which case we don't add the invocation, just a single attribute\n-                    // macro invocation\n-                    self.collect_derives(&attrs, it.ast_id.upcast());\n-\n                     def = Some(DefData {\n                         id: StructLoc { container: module, id: ItemTreeId::new(self.file_id, id) }\n                             .intern(self.def_collector.db)\n@@ -1220,11 +1254,6 @@ impl ModCollector<'_, '_> {\n                 ModItem::Union(id) => {\n                     let it = &self.item_tree[id];\n \n-                    // FIXME: check attrs to see if this is an attribute macro invocation;\n-                    // in which case we don't add the invocation, just a single attribute\n-                    // macro invocation\n-                    self.collect_derives(&attrs, it.ast_id.upcast());\n-\n                     def = Some(DefData {\n                         id: UnionLoc { container: module, id: ItemTreeId::new(self.file_id, id) }\n                             .intern(self.def_collector.db)\n@@ -1237,11 +1266,6 @@ impl ModCollector<'_, '_> {\n                 ModItem::Enum(id) => {\n                     let it = &self.item_tree[id];\n \n-                    // FIXME: check attrs to see if this is an attribute macro invocation;\n-                    // in which case we don't add the invocation, just a single attribute\n-                    // macro invocation\n-                    self.collect_derives(&attrs, it.ast_id.upcast());\n-\n                     def = Some(DefData {\n                         id: EnumLoc { container: module, id: ItemTreeId::new(self.file_id, id) }\n                             .intern(self.def_collector.db)\n@@ -1453,12 +1477,10 @@ impl ModCollector<'_, '_> {\n     ///\n     /// Returns `Err` when some attributes could not be resolved to builtins and have been\n     /// registered as unresolved.\n-    fn resolve_attributes(\n-        &mut self,\n-        attrs: &Attrs,\n-        mut ignore_up_to: Option<AttrId>,\n-        mod_item: ModItem,\n-    ) -> Result<(), ()> {\n+    ///\n+    /// If `ignore_up_to` is `Some`, attributes precending and including that attribute will be\n+    /// assumed to be resolved already.\n+    fn resolve_attributes(&mut self, attrs: &Attrs, mod_item: ModItem) -> Result<(), ()> {\n         fn is_builtin_attr(path: &ModPath) -> bool {\n             if path.kind == PathKind::Plain {\n                 if let Some(tool_module) = path.segments().first() {\n@@ -1483,62 +1505,68 @@ impl ModCollector<'_, '_> {\n             false\n         }\n \n-        // We failed to resolve an attribute on this item earlier, and are falling back to treating\n-        // the item as-is.\n-        if self.def_collector.ignore_attrs_on.contains(&InFile::new(self.file_id, mod_item)) {\n-            return Ok(());\n-        }\n-\n-        match attrs\n-            .iter()\n-            .skip_while(|attr| match ignore_up_to {\n-                Some(id) if attr.id == id => {\n-                    ignore_up_to = None;\n-                    false\n-                }\n-                Some(_) => true,\n-                None => false,\n-            })\n-            .find(|attr| !is_builtin_attr(&attr.path))\n-        {\n-            Some(non_builtin_attr) => {\n-                log::debug!(\"non-builtin attribute {}\", non_builtin_attr.path);\n+        let mut ignore_up_to =\n+            self.def_collector.ignore_attrs_on.get(&InFile::new(self.file_id, mod_item)).copied();\n+        for attr in attrs.iter().skip_while(|attr| match ignore_up_to {\n+            Some(id) if attr.id == id => {\n+                ignore_up_to = None;\n+                true\n+            }\n+            Some(_) => true,\n+            None => false,\n+        }) {\n+            if attr.path.as_ident() == Some(&hir_expand::name![derive]) {\n+                self.collect_derive(attr, mod_item);\n+            } else if is_builtin_attr(&attr.path) {\n+                continue;\n+            } else {\n+                log::debug!(\"non-builtin attribute {}\", attr.path);\n \n                 let ast_id = AstIdWithPath::new(\n                     self.file_id,\n                     mod_item.ast_id(self.item_tree),\n-                    non_builtin_attr.path.as_ref().clone(),\n+                    attr.path.as_ref().clone(),\n                 );\n                 self.def_collector.unresolved_macros.push(MacroDirective {\n                     module_id: self.module_id,\n                     depth: self.macro_depth + 1,\n-                    kind: MacroDirectiveKind::Attr { ast_id, attr: non_builtin_attr.id, mod_item },\n+                    kind: MacroDirectiveKind::Attr { ast_id, attr: attr.id, mod_item },\n                 });\n \n-                Err(())\n+                return Err(());\n             }\n-            None => Ok(()),\n         }\n+\n+        Ok(())\n     }\n \n-    fn collect_derives(&mut self, attrs: &Attrs, ast_id: FileAstId<ast::Item>) {\n-        for derive in attrs.by_key(\"derive\").attrs() {\n-            match derive.parse_derive() {\n-                Some(derive_macros) => {\n-                    for path in derive_macros {\n-                        let ast_id = AstIdWithPath::new(self.file_id, ast_id, path);\n-                        self.def_collector.unresolved_macros.push(MacroDirective {\n-                            module_id: self.module_id,\n-                            depth: self.macro_depth + 1,\n-                            kind: MacroDirectiveKind::Derive { ast_id, derive_attr: derive.id },\n-                        });\n-                    }\n-                }\n-                None => {\n-                    // FIXME: diagnose\n-                    log::debug!(\"malformed derive: {:?}\", derive);\n+    fn collect_derive(&mut self, attr: &Attr, mod_item: ModItem) {\n+        let ast_id: FileAstId<ast::Item> = match mod_item {\n+            ModItem::Struct(it) => self.item_tree[it].ast_id.upcast(),\n+            ModItem::Union(it) => self.item_tree[it].ast_id.upcast(),\n+            ModItem::Enum(it) => self.item_tree[it].ast_id.upcast(),\n+            _ => {\n+                // Cannot use derive on this item.\n+                // FIXME: diagnose\n+                return;\n+            }\n+        };\n+\n+        match attr.parse_derive() {\n+            Some(derive_macros) => {\n+                for path in derive_macros {\n+                    let ast_id = AstIdWithPath::new(self.file_id, ast_id, path);\n+                    self.def_collector.unresolved_macros.push(MacroDirective {\n+                        module_id: self.module_id,\n+                        depth: self.macro_depth + 1,\n+                        kind: MacroDirectiveKind::Derive { ast_id, derive_attr: attr.id },\n+                    });\n                 }\n             }\n+            None => {\n+                // FIXME: diagnose\n+                log::debug!(\"malformed derive: {:?}\", attr);\n+            }\n         }\n     }\n \n@@ -1753,7 +1781,7 @@ mod tests {\n             proc_macros: Default::default(),\n             exports_proc_macros: false,\n             from_glob_import: Default::default(),\n-            ignore_attrs_on: FxHashSet::default(),\n+            ignore_attrs_on: Default::default(),\n             derive_helpers_in_scope: FxHashMap::default(),\n         };\n         collector.seed_with_top_level();"}, {"sha": "04de107f5b71c8a2e55a8c2cced58a12e564e376", "filename": "crates/hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/036e5b2806256601408d91b5bbb4907bfb110760/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036e5b2806256601408d91b5bbb4907bfb110760/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=036e5b2806256601408d91b5bbb4907bfb110760", "patch": "@@ -735,6 +735,28 @@ fn unresolved_attributes_fall_back_track_per_file_moditems() {\n     );\n }\n \n+#[test]\n+fn resolves_derive_helper() {\n+    cov_mark::check!(resolved_derive_helper);\n+    check(\n+        r#\"\n+//- /main.rs crate:main deps:proc\n+#[derive(proc::Derive)]\n+#[helper]\n+#[unresolved]\n+struct S;\n+\n+//- /proc.rs crate:proc\n+#[proc_macro_derive(Derive, attributes(helper))]\n+fn derive() {}\n+        \"#,\n+        expect![[r#\"\n+            crate\n+            S: t v\n+        \"#]],\n+    )\n+}\n+\n #[test]\n fn macro_expansion_overflow() {\n     cov_mark::check!(macro_expansion_overflow);"}]}