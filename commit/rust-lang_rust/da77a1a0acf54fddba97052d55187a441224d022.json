{"sha": "da77a1a0acf54fddba97052d55187a441224d022", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNzdhMWEwYWNmNTRmZGRiYTk3MDUyZDU1MTg3YTQ0MTIyNGQwMjI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-07-19T23:39:34Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-07-27T19:59:34Z"}, "message": "Simplify parsing of paths", "tree": {"sha": "154fb69caee4076e6386c6f6c754a8be420296d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/154fb69caee4076e6386c6f6c754a8be420296d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da77a1a0acf54fddba97052d55187a441224d022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da77a1a0acf54fddba97052d55187a441224d022", "html_url": "https://github.com/rust-lang/rust/commit/da77a1a0acf54fddba97052d55187a441224d022", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da77a1a0acf54fddba97052d55187a441224d022/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5cc1baa2900ab344e8e8386aa8314b59051868ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cc1baa2900ab344e8e8386aa8314b59051868ca", "html_url": "https://github.com/rust-lang/rust/commit/5cc1baa2900ab344e8e8386aa8314b59051868ca"}], "stats": {"total": 407, "additions": 152, "deletions": 255}, "files": [{"sha": "b8e371a4e763da7d9ae794ac0623e430ecf92be9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da77a1a0acf54fddba97052d55187a441224d022/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da77a1a0acf54fddba97052d55187a441224d022/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=da77a1a0acf54fddba97052d55187a441224d022", "patch": "@@ -153,6 +153,19 @@ pub enum PathParameters {\n     Parenthesized(ParenthesizedParameterData),\n }\n \n+impl PathParameters {\n+    pub fn span(&self, fallback: Span) -> Span {\n+        match *self {\n+            AngleBracketed(ref data) => {\n+                data.lifetimes.get(0).map(|x| x.span).or_else(||\n+                data.types.get(0).map(|x| x.span)).or_else(||\n+                data.bindings.get(0).map(|x| x.span)).unwrap_or(fallback)\n+            }\n+            Parenthesized(ref data) => data.span\n+        }\n+    }\n+}\n+\n /// A path like `Foo<'a, T>`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Default)]\n pub struct AngleBracketedParameterData {\n@@ -173,6 +186,12 @@ impl Into<Option<P<PathParameters>>> for AngleBracketedParameterData {\n     }\n }\n \n+impl Into<Option<P<PathParameters>>> for ParenthesizedParameterData {\n+    fn into(self) -> Option<P<PathParameters>> {\n+        Some(P(PathParameters::Parenthesized(self)))\n+    }\n+}\n+\n /// A path like `Foo(A,B) -> C`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ParenthesizedParameterData {"}, {"sha": "833a10efa0bdf026d693391a9f9b84e7de1c3ae6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 124, "deletions": 249, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/da77a1a0acf54fddba97052d55187a441224d022/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da77a1a0acf54fddba97052d55187a441224d022/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=da77a1a0acf54fddba97052d55187a441224d022", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use abi::{self, Abi};\n-use ast::{AngleBracketedParameterData, AttrStyle, BareFnTy};\n+use ast::{AngleBracketedParameterData, ParenthesizedParameterData, AttrStyle, BareFnTy};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Unsafety;\n use ast::{Mod, Arg, Arm, Attribute, BindingMode, TraitItemKind};\n@@ -72,19 +72,27 @@ bitflags! {\n \n type ItemInfo = (Ident, ItemKind, Option<Vec<Attribute> >);\n \n-/// How to parse a path. There are three different kinds of paths, all of which\n-/// are parsed somewhat differently.\n+/// How to parse a path.\n #[derive(Copy, Clone, PartialEq)]\n pub enum PathStyle {\n-    /// A path with no type parameters, e.g. `foo::bar::Baz`, used in imports or visibilities.\n-    Mod,\n-    /// A path with a lifetime and type parameters, with no double colons\n-    /// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`, used in types.\n-    /// Paths using this style can be passed into macros expecting `path` nonterminals.\n-    Type,\n-    /// A path with a lifetime and type parameters with double colons before\n-    /// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`, used in expressions or patterns.\n+    /// In some contexts, notably in expressions, paths with generic arguments are ambiguous\n+    /// with something else. For example, in expressions `segment < ....` can be interpreted\n+    /// as a comparison and `segment ( ....` can be interpreted as a function call.\n+    /// In all such contexts the non-path interpretation is preferred by default for practical\n+    /// reasons, but the path interpretation can be forced by the disambiguator `::`, e.g.\n+    /// `x<y>` - comparisons, `x::<y>` - unambiguously a path.\n     Expr,\n+    /// In other contexts, notably in types, no ambiguity exists and paths can be written\n+    /// without the disambiguator, e.g. `x<y>` - unambiguously a path.\n+    /// Paths with disambiguators are rejected for now, but may be allowed in the future.\n+    Type,\n+    /// A path with generic arguments disallowed, e.g. `foo::bar::Baz`, used in imports,\n+    /// visibilities or attributes.\n+    /// Technically, this variant is unnecessary and e.g. `Expr` can be used instead\n+    /// (paths in \"mod\" contexts have to be checked later for absence of generic arguments\n+    /// anyway, due to macros), but it is used to avoid weird suggestions about expected\n+    /// tokens when something goes wrong.\n+    Mod,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq)]\n@@ -1397,7 +1405,7 @@ impl<'a> Parser<'a> {\n             TyKind::Infer\n         } else if self.eat_lt() {\n             // Qualified path\n-            let (qself, path) = self.parse_qualified_path(PathStyle::Type)?;\n+            let (qself, path) = self.parse_qpath(PathStyle::Type)?;\n             TyKind::Path(Some(qself), path)\n         } else if self.token.is_path_start() {\n             // Simple path\n@@ -1683,108 +1691,58 @@ impl<'a> Parser<'a> {\n      }\n \n     /// Parses qualified path.\n-    ///\n     /// Assumes that the leading `<` has been parsed already.\n     ///\n-    /// Qualifed paths are a part of the universal function call\n-    /// syntax (UFCS).\n-    ///\n     /// `qualified_path = <type [as trait_ref]>::path`\n     ///\n-    /// See `parse_path` for `mode` meaning.\n-    ///\n-    /// # Examples:\n-    ///\n+    /// # Examples\n     /// `<T as U>::a`\n-    /// `<T as U>::F::a::<S>`\n-    pub fn parse_qualified_path(&mut self, mode: PathStyle)\n-                                -> PResult<'a, (QSelf, ast::Path)> {\n-        let span = self.prev_span;\n-        let self_type = self.parse_ty()?;\n+    /// `<T as U>::F::a<S>` (without disambiguator)\n+    /// `<T as U>::F::a::<S>` (with disambiguator)\n+    fn parse_qpath(&mut self, style: PathStyle) -> PResult<'a, (QSelf, ast::Path)> {\n+        let lo = self.prev_span;\n+        let ty = self.parse_ty()?;\n         let mut path = if self.eat_keyword(keywords::As) {\n             self.parse_path(PathStyle::Type)?\n         } else {\n-            ast::Path {\n-                span: span,\n-                segments: vec![]\n-            }\n-        };\n-\n-        let qself = QSelf {\n-            ty: self_type,\n-            position: path.segments.len()\n+            ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP }\n         };\n-\n         self.expect(&token::Gt)?;\n         self.expect(&token::ModSep)?;\n \n-        let segments = match mode {\n-            PathStyle::Type => {\n-                self.parse_path_segments_without_colons(true)?\n-            }\n-            PathStyle::Expr => {\n-                self.parse_path_segments_with_colons()?\n-            }\n-            PathStyle::Mod => {\n-                self.parse_path_segments_without_types()?\n-            }\n-        };\n-        path.segments.extend(segments);\n-\n-        path.span.hi = self.prev_span.hi;\n+        let qself = QSelf { ty, position: path.segments.len() };\n+        self.parse_path_segments(&mut path.segments, style)?;\n \n-        Ok((qself, path))\n+        Ok((qself, ast::Path { segments: path.segments, span: lo.to(self.prev_span) }))\n     }\n \n-    /// Parses a path and optional type parameter bounds, depending on the\n-    /// mode. The `mode` parameter determines whether lifetimes, types, and/or\n-    /// bounds are permitted and whether `::` must precede type parameter\n-    /// groups.\n-    pub fn parse_path(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n-        self.parse_path_common(mode, true)\n-    }\n-\n-    pub fn parse_path_without_generics(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n-        self.parse_path_common(mode, false)\n-    }\n-\n-    fn parse_path_common(&mut self, mode: PathStyle, parse_generics: bool)\n-        -> PResult<'a, ast::Path>\n+    /// Parses simple paths.\n+    ///\n+    /// `path = [::] segment+`\n+    /// `segment = ident | ident[::]<args> | ident[::](args) [-> type]`\n+    ///\n+    /// # Examples\n+    /// `a::b::C<D>` (without disambiguator)\n+    /// `a::b::C::<D>` (with disambiguator)\n+    /// `Fn(Args)` (without disambiguator)\n+    /// `Fn::(Args)` (with disambiguator)\n+    pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, ast::Path>\n     {\n         maybe_whole!(self, NtPath, |x| x);\n \n         let lo = self.meta_var_span.unwrap_or(self.span);\n-        let is_global = self.eat(&token::ModSep);\n-\n-        // Parse any number of segments and bound sets. A segment is an\n-        // identifier followed by an optional lifetime and a set of types.\n-        // A bound set is a set of type parameter bounds.\n-        let mut segments = match mode {\n-            PathStyle::Type => {\n-                self.parse_path_segments_without_colons(parse_generics)?\n-            }\n-            PathStyle::Expr => {\n-                self.parse_path_segments_with_colons()?\n-            }\n-            PathStyle::Mod => {\n-                self.parse_path_segments_without_types()?\n-            }\n-        };\n-\n-        if is_global {\n-            segments.insert(0, PathSegment::crate_root(lo));\n+        let mut segments = Vec::new();\n+        if self.eat(&token::ModSep) {\n+            segments.push(PathSegment::crate_root(lo));\n         }\n+        self.parse_path_segments(&mut segments, style)?;\n \n-        // Assemble the result.\n-        Ok(ast::Path {\n-            span: lo.to(self.prev_span),\n-            segments: segments,\n-        })\n+        Ok(ast::Path { segments, span: lo.to(self.prev_span) })\n     }\n \n     /// Like `parse_path`, but also supports parsing `Word` meta items into paths for back-compat.\n     /// This is used when parsing derive macro paths in `#[derive]` attributes.\n-    pub fn parse_path_allowing_meta(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n+    pub fn parse_path_allowing_meta(&mut self, style: PathStyle) -> PResult<'a, ast::Path> {\n         let meta_ident = match self.token {\n             token::Interpolated(ref nt) => match nt.0 {\n                 token::NtMeta(ref meta) => match meta.node {\n@@ -1799,134 +1757,79 @@ impl<'a> Parser<'a> {\n             self.bump();\n             return Ok(ast::Path::from_ident(self.prev_span, ident));\n         }\n-        self.parse_path(mode)\n+        self.parse_path(style)\n     }\n \n-    /// Examples:\n-    /// - `a::b<T,U>::c<V,W>`\n-    /// - `a::b<T,U>::c(V) -> W`\n-    /// - `a::b<T,U>::c(V)`\n-    pub fn parse_path_segments_without_colons(&mut self, parse_generics: bool)\n-        -> PResult<'a, Vec<PathSegment>>\n-    {\n-        let mut segments = Vec::new();\n+    fn parse_path_segments(&mut self, segments: &mut Vec<PathSegment>, style: PathStyle)\n+                           -> PResult<'a, ()> {\n         loop {\n-            // First, parse an identifier.\n-            let ident_span = self.span;\n-            let identifier = self.parse_path_segment_ident()?;\n+            segments.push(self.parse_path_segment(style)?);\n \n-            if self.check(&token::ModSep) && self.look_ahead(1, |t| *t == token::Lt) {\n-                self.bump();\n-                let prev_span = self.prev_span;\n+            if self.is_import_coupler() || !self.eat(&token::ModSep) {\n+                return Ok(());\n+            }\n+        }\n+    }\n \n-                let mut err = self.diagnostic().struct_span_err(prev_span,\n-                    \"unexpected token: `::`\");\n-                err.help(\n-                    \"use `<...>` instead of `::<...>` if you meant to specify type arguments\");\n-                err.emit();\n+    fn parse_path_segment(&mut self, style: PathStyle) -> PResult<'a, PathSegment> {\n+        let ident_span = self.span;\n+        let ident = self.parse_path_segment_ident()?;\n+\n+        let is_args_start = |token: &token::Token| match *token {\n+            token::Lt | token::BinOp(token::Shl) | token::OpenDelim(token::Paren) => true,\n+            _ => false,\n+        };\n+        let check_args_start = |this: &mut Self| {\n+            this.expected_tokens.extend_from_slice(\n+                &[TokenType::Token(token::Lt), TokenType::Token(token::OpenDelim(token::Paren))]\n+            );\n+            is_args_start(&this.token)\n+        };\n+\n+        Ok(if style == PathStyle::Type && check_args_start(self) ||\n+              style != PathStyle::Mod && self.check(&token::ModSep)\n+                                      && self.look_ahead(1, |t| is_args_start(t)) {\n+            // Generic arguments are found - `<`, `(`, `::<` or `::(`.\n+            let lo = self.span;\n+            if self.eat(&token::ModSep) {\n+                // These errors are not strictly necessary and may be removed in the future.\n+                if style == PathStyle::Type {\n+                    let mut err = self.diagnostic().struct_span_err(self.prev_span,\n+                        \"unnecessary path disambiguator\");\n+                    err.span_label(self.prev_span, \"try removing `::`\");\n+                    err.emit();\n+                } else if self.token == token::OpenDelim(token::Paren) {\n+                    self.diagnostic().span_err(self.prev_span,\n+                        \"`::` is not supported before parenthesized generic arguments\")\n+                }\n             }\n \n-            // Parse types, optionally.\n-            let parameters = if parse_generics && self.eat_lt() {\n+            let parameters = if self.eat_lt() {\n+                // `<'a, T, A = U>`\n                 let (lifetimes, types, bindings) = self.parse_generic_args()?;\n                 self.expect_gt()?;\n+                let _span = lo.to(self.prev_span);\n                 AngleBracketedParameterData { lifetimes, types, bindings }.into()\n-            } else if self.eat(&token::OpenDelim(token::Paren)) {\n-                let lo = self.prev_span;\n-\n-                let inputs = self.parse_seq_to_end(\n-                    &token::CloseDelim(token::Paren),\n-                    SeqSep::trailing_allowed(token::Comma),\n-                    |p| p.parse_ty())?;\n-\n-                let output_ty = if self.eat(&token::RArrow) {\n+            } else {\n+                // `(T, U) -> R`\n+                self.bump(); // `(`\n+                let inputs = self.parse_seq_to_end(&token::CloseDelim(token::Paren),\n+                                                   SeqSep::trailing_allowed(token::Comma),\n+                                                   |p| p.parse_ty())?;\n+                let output = if self.eat(&token::RArrow) {\n                     Some(self.parse_ty_no_plus()?)\n                 } else {\n                     None\n                 };\n-\n-                let hi = self.prev_span;\n-\n-                Some(P(ast::PathParameters::Parenthesized(ast::ParenthesizedParameterData {\n-                    span: lo.to(hi),\n-                    inputs: inputs,\n-                    output: output_ty,\n-                })))\n-            } else {\n-                None\n+                let span = lo.to(self.prev_span);\n+                ParenthesizedParameterData { inputs, output, span }.into()\n             };\n \n-            // Assemble and push the result.\n-            segments.push(PathSegment {\n-                identifier: identifier,\n-                span: ident_span,\n-                parameters: parameters\n-            });\n-\n-            // Continue only if we see a `::`\n-            if !self.eat(&token::ModSep) {\n-                return Ok(segments);\n-            }\n-        }\n-    }\n-\n-    /// Examples:\n-    /// - `a::b::<T,U>::c`\n-    pub fn parse_path_segments_with_colons(&mut self) -> PResult<'a, Vec<PathSegment>> {\n-        let mut segments = Vec::new();\n-        loop {\n-            // First, parse an identifier.\n-            let ident_span = self.span;\n-            let identifier = self.parse_path_segment_ident()?;\n-\n-            // If we do not see a `::`, stop.\n-            if !self.eat(&token::ModSep) {\n-                segments.push(PathSegment::from_ident(identifier, ident_span));\n-                return Ok(segments);\n-            }\n-\n-            // Check for a type segment.\n-            if self.eat_lt() {\n-                // Consumed `a::b::<`, go look for types\n-                let (lifetimes, types, bindings) = self.parse_generic_args()?;\n-                self.expect_gt()?;\n-                segments.push(PathSegment {\n-                    identifier: identifier,\n-                    span: ident_span,\n-                    parameters: AngleBracketedParameterData { lifetimes, types, bindings }.into(),\n-                });\n-\n-                // Consumed `a::b::<T,U>`, check for `::` before proceeding\n-                if !self.eat(&token::ModSep) {\n-                    return Ok(segments);\n-                }\n-            } else {\n-                // Consumed `a::`, go look for `b`\n-                segments.push(PathSegment::from_ident(identifier, ident_span));\n-            }\n-        }\n-    }\n-\n-    /// Examples:\n-    /// - `a::b::c`\n-    pub fn parse_path_segments_without_types(&mut self)\n-                                             -> PResult<'a, Vec<PathSegment>> {\n-        let mut segments = Vec::new();\n-        loop {\n-            // First, parse an identifier.\n-            let ident_span = self.span;\n-            let identifier = self.parse_path_segment_ident()?;\n-\n-            // Assemble and push the result.\n-            segments.push(PathSegment::from_ident(identifier, ident_span));\n-\n-            // If we do not see a `::` or see `::{`/`::*`, stop.\n-            if !self.check(&token::ModSep) || self.is_import_coupler() {\n-                return Ok(segments);\n-            } else {\n-                self.bump();\n-            }\n-        }\n+            PathSegment { identifier: ident, span: ident_span, parameters }\n+        } else {\n+            // Generic arguments are not found.\n+            PathSegment::from_ident(ident, ident_span)\n+        })\n     }\n \n     fn check_lifetime(&mut self) -> bool {\n@@ -2030,10 +1933,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::ExprKind {\n-        ExprKind::Field(expr, ident)\n-    }\n-\n     pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<usize>) -> ast::ExprKind {\n         ExprKind::TupField(expr, idx)\n     }\n@@ -2178,8 +2077,7 @@ impl<'a> Parser<'a> {\n             }\n             _ => {\n                 if self.eat_lt() {\n-                    let (qself, path) =\n-                        self.parse_qualified_path(PathStyle::Expr)?;\n+                    let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n                     hi = path.span;\n                     return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n                 }\n@@ -2439,50 +2337,33 @@ impl<'a> Parser<'a> {\n         )\n     }\n \n-    // Assuming we have just parsed `.foo` (i.e., a dot and an ident), continue\n-    // parsing into an expression.\n-    fn parse_dot_suffix(&mut self, ident: Ident, ident_span: Span, self_value: P<Expr>, lo: Span)\n-                        -> PResult<'a, P<Expr>> {\n-        let (lifetimes, types, bindings) = if self.eat(&token::ModSep) {\n-            self.expect_lt()?;\n-            let args = self.parse_generic_args()?;\n-            self.expect_gt()?;\n-            args\n-        } else {\n-            (Vec::new(), Vec::new(), Vec::new())\n-        };\n-\n+    // Assuming we have just parsed `.`, continue parsing into an expression.\n+    fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n+        let segment = self.parse_path_segment(PathStyle::Expr)?;\n         Ok(match self.token {\n-            // expr.f() method call.\n             token::OpenDelim(token::Paren) => {\n-                let mut es = self.parse_unspanned_seq(\n+                // Method call `expr.f()`\n+                let mut args = self.parse_unspanned_seq(\n                     &token::OpenDelim(token::Paren),\n                     &token::CloseDelim(token::Paren),\n                     SeqSep::trailing_allowed(token::Comma),\n                     |p| Ok(p.parse_expr()?)\n                 )?;\n-                let hi = self.prev_span;\n+                args.insert(0, self_arg);\n \n-                es.insert(0, self_value);\n-                let seg = PathSegment {\n-                    identifier: ident,\n-                    span: ident_span.to(ident_span),\n-                    parameters: AngleBracketedParameterData { lifetimes, types, bindings }.into(),\n-                };\n-                self.mk_expr(lo.to(hi), ExprKind::MethodCall(seg, es), ThinVec::new())\n+                let span = lo.to(self.prev_span);\n+                self.mk_expr(span, ExprKind::MethodCall(segment, args), ThinVec::new())\n             }\n-            // Field access.\n             _ => {\n-                if let Some(generic_arg_span) = lifetimes.get(0).map(|x| x.span).or_else(||\n-                                                types.get(0).map(|x| x.span)).or_else(||\n-                                                bindings.get(0).map(|x| x.span)) {\n-                    self.span_err(generic_arg_span,\n+                // Field access `expr.f`\n+                if let Some(parameters) = segment.parameters {\n+                    self.span_err(parameters.span(segment.span),\n                                   \"field expressions may not have generic arguments\");\n                 }\n \n-                let id = respan(ident_span.to(ident_span), ident);\n-                let field = self.mk_field(self_value, id);\n-                self.mk_expr(lo.to(ident_span), field, ThinVec::new())\n+                let span = lo.to(self.prev_span);\n+                let ident = respan(segment.span, segment.identifier);\n+                self.mk_expr(span, ExprKind::Field(self_arg, ident), ThinVec::new())\n             }\n         })\n     }\n@@ -2500,10 +2381,8 @@ impl<'a> Parser<'a> {\n             // expr.f\n             if self.eat(&token::Dot) {\n                 match self.token {\n-                  token::Ident(i) => {\n-                    let ident_span = self.span;\n-                    self.bump();\n-                    e = self.parse_dot_suffix(i, ident_span, e, lo)?;\n+                  token::Ident(..) => {\n+                    e = self.parse_dot_suffix(e, lo)?;\n                   }\n                   token::Literal(token::Integer(n), suf) => {\n                     let sp = self.span;\n@@ -2561,9 +2440,6 @@ impl<'a> Parser<'a> {\n                     // FIXME Could factor this out into non_fatal_unexpected or something.\n                     let actual = self.this_token_to_string();\n                     self.span_err(self.span, &format!(\"unexpected token: `{}`\", actual));\n-\n-                    let dot_span = self.prev_span;\n-                    e = self.parse_dot_suffix(keywords::Invalid.ident(), dot_span, e, lo)?;\n                   }\n                 }\n                 continue;\n@@ -2928,7 +2804,7 @@ impl<'a> Parser<'a> {\n                 let parser_snapshot_after_type = self.clone();\n                 mem::replace(self, parser_snapshot_before_type);\n \n-                match self.parse_path_without_generics(PathStyle::Type) {\n+                match self.parse_path(PathStyle::Expr) {\n                     Ok(path) => {\n                         // Successfully parsed the type path leaving a `<` yet to parse.\n                         type_err.cancel();\n@@ -3455,8 +3331,7 @@ impl<'a> Parser<'a> {\n             let lo = self.span;\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path\n-                let (qself, path) =\n-                    self.parse_qualified_path(PathStyle::Expr)?;\n+                let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n                 (Some(qself), path)\n             } else {\n                 // Parse an unqualified path\n@@ -3554,7 +3429,7 @@ impl<'a> Parser<'a> {\n                 // Parse pattern starting with a path\n                 let (qself, path) = if self.eat_lt() {\n                     // Parse a qualified path\n-                    let (qself, path) = self.parse_qualified_path(PathStyle::Expr)?;\n+                    let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n                     (Some(qself), path)\n                 } else {\n                     // Parse an unqualified path"}, {"sha": "737955b2ff351a0580326424318a2d758ca5189c", "filename": "src/test/compile-fail/issue-36116.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da77a1a0acf54fddba97052d55187a441224d022/src%2Ftest%2Fcompile-fail%2Fissue-36116.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da77a1a0acf54fddba97052d55187a441224d022/src%2Ftest%2Fcompile-fail%2Fissue-36116.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-36116.rs?ref=da77a1a0acf54fddba97052d55187a441224d022", "patch": "@@ -14,10 +14,10 @@ struct Foo<T> {\n \n fn main() {\n     let f = Some(Foo { _a: 42 }).map(|a| a as Foo::<i32>);\n-    //~^ ERROR unexpected token: `::`\n-    //~| HELP use `<...>` instead of `::<...>` if you meant to specify type arguments\n+    //~^ ERROR unnecessary path disambiguator\n+    //~| NOTE try removing `::`\n \n     let g: Foo::<i32> = Foo { _a: 42 };\n-    //~^ ERROR unexpected token: `::`\n-    //~| HELP use `<...>` instead of `::<...>` if you meant to specify type arguments\n+    //~^ ERROR unnecessary path disambiguator\n+    //~| NOTE try removing `::`\n }"}, {"sha": "bc7c333723d8ef7e10c8261bba497155edcb7273", "filename": "src/test/compile-fail/parse-error-correct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da77a1a0acf54fddba97052d55187a441224d022/src%2Ftest%2Fcompile-fail%2Fparse-error-correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da77a1a0acf54fddba97052d55187a441224d022/src%2Ftest%2Fcompile-fail%2Fparse-error-correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fparse-error-correct.rs?ref=da77a1a0acf54fddba97052d55187a441224d022", "patch": "@@ -17,5 +17,6 @@ fn main() {\n     let y = 42;\n     let x = y.;  //~ ERROR unexpected token\n     let x = y.();  //~ ERROR unexpected token\n+                   //~^ ERROR expected function, found `{integer}`\n     let x = y.foo; //~ ERROR `{integer}` is a primitive type and therefore doesn't have fields [E061\n }"}, {"sha": "95c307c5670990ae72a21635cbd848cd1e77692f", "filename": "src/test/parse-fail/type-parameters-in-field-exprs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da77a1a0acf54fddba97052d55187a441224d022/src%2Ftest%2Fparse-fail%2Ftype-parameters-in-field-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da77a1a0acf54fddba97052d55187a441224d022/src%2Ftest%2Fparse-fail%2Ftype-parameters-in-field-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftype-parameters-in-field-exprs.rs?ref=da77a1a0acf54fddba97052d55187a441224d022", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// compile-flags: -Z parse-only -Z continue-parse-after-error\n \n struct Foo {\n     x: isize,\n@@ -22,4 +22,6 @@ fn main() {\n     };\n     f.x::<isize>;\n     //~^ ERROR field expressions may not have generic arguments\n+    f.x::<>;\n+    //~^ ERROR field expressions may not have generic arguments\n }"}, {"sha": "548a5078a747bd848120a63373c9e55a33b92f59", "filename": "src/test/parse-fail/unboxed-closure-sugar-used-on-struct-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da77a1a0acf54fddba97052d55187a441224d022/src%2Ftest%2Fparse-fail%2Funboxed-closure-sugar-used-on-struct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da77a1a0acf54fddba97052d55187a441224d022/src%2Ftest%2Fparse-fail%2Funboxed-closure-sugar-used-on-struct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Funboxed-closure-sugar-used-on-struct-3.rs?ref=da77a1a0acf54fddba97052d55187a441224d022", "patch": "@@ -24,7 +24,7 @@ fn bar() {\n     let b = Box::Bar::<isize,usize>::new(); // OK\n \n     let b = Box::Bar::()::new();\n-    //~^ ERROR expected identifier, found `(`\n+    //~^ ERROR `::` is not supported before parenthesized generic arguments\n }\n \n fn main() { }"}]}