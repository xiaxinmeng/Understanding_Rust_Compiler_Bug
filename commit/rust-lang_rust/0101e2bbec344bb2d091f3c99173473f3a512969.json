{"sha": "0101e2bbec344bb2d091f3c99173473f3a512969", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMDFlMmJiZWMzNDRiYjJkMDkxZjNjOTkxNzM0NzNmM2E1MTI5Njk=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2019-05-16T02:10:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-16T02:10:33Z"}, "message": "Merge pull request #3553 from bash/minor-refactorings\n\nMinor refactorings", "tree": {"sha": "1280d06d987dc0ef4a1151a9dd9639380de05c32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1280d06d987dc0ef4a1151a9dd9639380de05c32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0101e2bbec344bb2d091f3c99173473f3a512969", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc3MaZCRBK7hj4Ov3rIwAAdHIIAJ53IYSLSIl0ts+5vcYwzd1C\nqIkMCUfbKHKejTG/Idtfl2Xxt3XjJvzP45fsV2xsdnlgO5Avxzfj8tAlB3spV7LO\nLO495pfWqxq6DxBMQI5BIwg3RiQ1LMDl14Ov+XGgQx6IebZJIkXu+4QSInn04+KS\n9zd9uIkQEk77Dn6Zyf7eBtXTOXSciknDtbjWwQqA1sByqOAwNMPCmYnmJMNUV+rT\nvhkUZ4GXfMjSzLeV1VlgMnIE7lQWOp7taJlCyH6ZWCNQEw8L4LexWVkD4++dVVZz\nHLZjHIHAhVjPdgL+hjYXxaTmQvfYzcrAqv2gqVxQ19uAL95Rs7+ns+DK+Zw+/so=\n=sHh6\n-----END PGP SIGNATURE-----\n", "payload": "tree 1280d06d987dc0ef4a1151a9dd9639380de05c32\nparent cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a\nparent 424193041ff64e1f97975e540adcf488e278836e\nauthor Seiichi Uchida <seuchida@gmail.com> 1557972633 +0900\ncommitter GitHub <noreply@github.com> 1557972633 +0900\n\nMerge pull request #3553 from bash/minor-refactorings\n\nMinor refactorings"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0101e2bbec344bb2d091f3c99173473f3a512969", "html_url": "https://github.com/rust-lang/rust/commit/0101e2bbec344bb2d091f3c99173473f3a512969", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0101e2bbec344bb2d091f3c99173473f3a512969/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a", "html_url": "https://github.com/rust-lang/rust/commit/cc97eaf9f9181aec5a1ba6459b204ed4a7fba62a"}, {"sha": "424193041ff64e1f97975e540adcf488e278836e", "url": "https://api.github.com/repos/rust-lang/rust/commits/424193041ff64e1f97975e540adcf488e278836e", "html_url": "https://github.com/rust-lang/rust/commit/424193041ff64e1f97975e540adcf488e278836e"}], "stats": {"total": 115, "additions": 75, "deletions": 40}, "files": [{"sha": "e40b16314fd28b54ded8a479a1144205de03ab93", "filename": "src/attr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0101e2bbec344bb2d091f3c99173473f3a512969/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0101e2bbec344bb2d091f3c99173473f3a512969/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=0101e2bbec344bb2d091f3c99173473f3a512969", "patch": "@@ -53,12 +53,11 @@ fn is_derive(attr: &ast::Attribute) -> bool {\n }\n \n /// Returns the arguments of `#[derive(...)]`.\n-fn get_derive_spans(attr: &ast::Attribute) -> Option<Vec<Span>> {\n+fn get_derive_spans<'a>(attr: &'a ast::Attribute) -> Option<impl Iterator<Item = Span> + 'a> {\n     attr.meta_item_list().map(|meta_item_list| {\n         meta_item_list\n-            .iter()\n+            .into_iter()\n             .map(|nested_meta_item| nested_meta_item.span)\n-            .collect()\n     })\n }\n \n@@ -411,10 +410,11 @@ impl<'a> Rewrite for [ast::Attribute] {\n             // Handle derives if we will merge them.\n             if context.config.merge_derives() && is_derive(&attrs[0]) {\n                 let derives = take_while_with_pred(context, attrs, is_derive);\n-                let mut derive_spans = vec![];\n-                for derive in derives {\n-                    derive_spans.append(&mut get_derive_spans(derive)?);\n-                }\n+                let derive_spans: Vec<_> = derives\n+                    .iter()\n+                    .filter_map(get_derive_spans)\n+                    .flatten()\n+                    .collect();\n                 let derive_str =\n                     format_derive(&derive_spans, attr_prefix(&attrs[0]), shape, context)?;\n                 result.push_str(&derive_str);"}, {"sha": "5c2b46583b43efa2137b4ab1637d2a4ac8888322", "filename": "src/checkstyle.rs", "status": "modified", "additions": 55, "deletions": 21, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0101e2bbec344bb2d091f3c99173473f3a512969/src%2Fcheckstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0101e2bbec344bb2d091f3c99173473f3a512969/src%2Fcheckstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcheckstyle.rs?ref=0101e2bbec344bb2d091f3c99173473f3a512969", "patch": "@@ -1,3 +1,4 @@\n+use std::fmt::{self, Display};\n use std::io::{self, Write};\n use std::path::Path;\n \n@@ -9,9 +10,9 @@ use crate::rustfmt_diff::{DiffLine, Mismatch};\n /// future version of Rustfmt.\n pub(crate) fn header() -> String {\n     let mut xml_heading = String::new();\n-    xml_heading.push_str(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\");\n+    xml_heading.push_str(r#\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\"#);\n     xml_heading.push_str(\"\\n\");\n-    xml_heading.push_str(\"<checkstyle version=\\\"4.3\\\">\");\n+    xml_heading.push_str(r#\"<checkstyle version=\"4.3\">\"#);\n     xml_heading\n }\n \n@@ -31,17 +32,16 @@ pub(crate) fn output_checkstyle_file<T>(\n where\n     T: Write,\n {\n-    write!(writer, \"<file name=\\\"{}\\\">\", filename.display())?;\n+    write!(writer, r#\"<file name=\"{}\">\"#, filename.display())?;\n     for mismatch in diff {\n         for line in mismatch.lines {\n             // Do nothing with `DiffLine::Context` and `DiffLine::Resulting`.\n-            if let DiffLine::Expected(ref str) = line {\n-                let message = xml_escape_str(str);\n+            if let DiffLine::Expected(message) = line {\n                 write!(\n                     writer,\n-                    \"<error line=\\\"{}\\\" severity=\\\"warning\\\" message=\\\"Should be `{}`\\\" \\\n-                     />\",\n-                    mismatch.line_number, message\n+                    r#\"<error line=\"{}\" severity=\"warning\" message=\"Should be `{}`\" />\"#,\n+                    mismatch.line_number,\n+                    XmlEscaped(&message)\n                 )?;\n             }\n         }\n@@ -50,19 +50,53 @@ where\n     Ok(())\n }\n \n-// Convert special characters into XML entities.\n-// This is needed for checkstyle output.\n-fn xml_escape_str(string: &str) -> String {\n-    let mut out = String::new();\n-    for c in string.chars() {\n-        match c {\n-            '<' => out.push_str(\"&lt;\"),\n-            '>' => out.push_str(\"&gt;\"),\n-            '\"' => out.push_str(\"&quot;\"),\n-            '\\'' => out.push_str(\"&apos;\"),\n-            '&' => out.push_str(\"&amp;\"),\n-            _ => out.push(c),\n+/// Convert special characters into XML entities.\n+/// This is needed for checkstyle output.\n+struct XmlEscaped<'a>(&'a str);\n+\n+impl<'a> Display for XmlEscaped<'a> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        for char in self.0.chars() {\n+            match char {\n+                '<' => write!(formatter, \"&lt;\"),\n+                '>' => write!(formatter, \"&gt;\"),\n+                '\"' => write!(formatter, \"&quot;\"),\n+                '\\'' => write!(formatter, \"&apos;\"),\n+                '&' => write!(formatter, \"&amp;\"),\n+                _ => write!(formatter, \"{}\", char),\n+            }?;\n         }\n+\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn special_characters_are_escaped() {\n+        assert_eq!(\n+            \"&lt;&gt;&quot;&apos;&amp;\",\n+            format!(\"{}\", XmlEscaped(r#\"<>\"'&\"#)),\n+        );\n+    }\n+\n+    #[test]\n+    fn special_characters_are_escaped_in_string_with_other_characters() {\n+        assert_eq!(\n+            \"The quick brown &quot;\ud83e\udd8a&quot; jumps &lt;over&gt; the lazy \ud83d\udc36\",\n+            format!(\n+                \"{}\",\n+                XmlEscaped(r#\"The quick brown \"\ud83e\udd8a\" jumps <over> the lazy \ud83d\udc36\"#)\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn other_characters_are_not_escaped() {\n+        let string = \"The quick brown \ud83e\udd8a jumps over the lazy \ud83d\udc36\";\n+        assert_eq!(string, format!(\"{}\", XmlEscaped(string)));\n     }\n-    out\n }"}, {"sha": "47d885ef2e34741d34f8f697eaf24d986dd7ad89", "filename": "src/formatting.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0101e2bbec344bb2d091f3c99173473f3a512969/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0101e2bbec344bb2d091f3c99173473f3a512969/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=0101e2bbec344bb2d091f3c99173473f3a512969", "patch": "@@ -458,8 +458,7 @@ struct FormatLines<'a> {\n     errors: Vec<FormattingError>,\n     issue_seeker: BadIssueSeeker,\n     line_buffer: String,\n-    // `true` if the current line contains a string literal.\n-    is_string: bool,\n+    current_line_contains_string_literal: bool,\n     format_line: bool,\n     allow_issue_seek: bool,\n     config: &'a Config,\n@@ -483,7 +482,7 @@ impl<'a> FormatLines<'a> {\n             allow_issue_seek: !issue_seeker.is_disabled(),\n             issue_seeker,\n             line_buffer: String::with_capacity(config.max_width() * 2),\n-            is_string: false,\n+            current_line_contains_string_literal: false,\n             format_line: config.file_lines().contains_line(name, 1),\n             config,\n         }\n@@ -547,7 +546,7 @@ impl<'a> FormatLines<'a> {\n                 && !self.is_skipped_line()\n                 && self.should_report_error(kind, &error_kind)\n             {\n-                let is_string = self.is_string;\n+                let is_string = self.current_line_contains_string_literal;\n                 self.push_err(error_kind, kind.is_comment(), is_string);\n             }\n         }\n@@ -561,7 +560,7 @@ impl<'a> FormatLines<'a> {\n         self.newline_count += 1;\n         self.last_was_space = false;\n         self.line_buffer.clear();\n-        self.is_string = false;\n+        self.current_line_contains_string_literal = false;\n     }\n \n     fn char(&mut self, c: char, kind: FullCodeCharKind) {\n@@ -574,7 +573,7 @@ impl<'a> FormatLines<'a> {\n         self.last_was_space = c.is_whitespace();\n         self.line_buffer.push(c);\n         if kind.is_string() {\n-            self.is_string = true;\n+            self.current_line_contains_string_literal = true;\n         }\n     }\n \n@@ -589,12 +588,14 @@ impl<'a> FormatLines<'a> {\n     }\n \n     fn should_report_error(&self, char_kind: FullCodeCharKind, error_kind: &ErrorKind) -> bool {\n-        let allow_error_report =\n-            if char_kind.is_comment() || self.is_string || error_kind.is_comment() {\n-                self.config.error_on_unformatted()\n-            } else {\n-                true\n-            };\n+        let allow_error_report = if char_kind.is_comment()\n+            || self.current_line_contains_string_literal\n+            || error_kind.is_comment()\n+        {\n+            self.config.error_on_unformatted()\n+        } else {\n+            true\n+        };\n \n         match error_kind {\n             ErrorKind::LineOverflow(..) => {"}]}