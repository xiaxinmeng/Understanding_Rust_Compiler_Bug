{"sha": "e2efdd156bf6915d6831821ff8a263e43e493e32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZWZkZDE1NmJmNjkxNWQ2ODMxODIxZmY4YTI2M2U0M2U0OTNlMzI=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-26T05:07:41Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-12-10T03:34:15Z"}, "message": "Use precise places when lowering Closures in THIR\n\n- Closures now use closure_min_captures to figure out captured paths\n- Build upvar_mutbls using closure_min_captures\n- Change logic in limit_capture_mutability to differentiate b/w\n  capturing parent's local variable or capturing a variable that is\n  captured by the parent (in case of nested closure) using PlaceBase.\n\nCo-authored-by: Roxane Fruytier <roxane.fruytier@hotmail.com>", "tree": {"sha": "d892ad6c043569b9c2d9111f9093cfa6011c4751", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d892ad6c043569b9c2d9111f9093cfa6011c4751"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2efdd156bf6915d6831821ff8a263e43e493e32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2efdd156bf6915d6831821ff8a263e43e493e32", "html_url": "https://github.com/rust-lang/rust/commit/e2efdd156bf6915d6831821ff8a263e43e493e32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2efdd156bf6915d6831821ff8a263e43e493e32/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a1d0699a484ee875c87394f70cb37f09acadd88", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a1d0699a484ee875c87394f70cb37f09acadd88", "html_url": "https://github.com/rust-lang/rust/commit/6a1d0699a484ee875c87394f70cb37f09acadd88"}], "stats": {"total": 172, "additions": 109, "deletions": 63}, "files": [{"sha": "e1a3dc87c8c8dc696a21971c946295fa7da0b631", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e2efdd156bf6915d6831821ff8a263e43e493e32/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2efdd156bf6915d6831821ff8a263e43e493e32/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=e2efdd156bf6915d6831821ff8a263e43e493e32", "patch": "@@ -18,7 +18,7 @@ use rustc_index::vec::Idx;\n \n /// The \"outermost\" place that holds this value.\n #[derive(Copy, Clone)]\n-pub enum PlaceBase {\n+crate enum PlaceBase {\n     /// Denotes the start of a `Place`.\n     Local(Local),\n \n@@ -67,7 +67,7 @@ pub enum PlaceBase {\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone)]\n-struct PlaceBuilder<'tcx> {\n+crate struct PlaceBuilder<'tcx> {\n     base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n@@ -279,7 +279,7 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n }\n \n impl<'tcx> PlaceBuilder<'tcx> {\n-    fn into_place<'a>(\n+    crate fn into_place<'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         typeck_results: &'a ty::TypeckResults<'tcx>,\n@@ -299,6 +299,10 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         to_upvars_resolved_place_builder(self, tcx, typeck_results).unwrap()\n     }\n \n+    crate fn base(&self) -> PlaceBase {\n+        self.base\n+    }\n+\n     fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n         self.project(PlaceElem::Field(f, ty))\n     }\n@@ -352,7 +356,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n     /// intermediate `Place` values until we know the full set of projections.\n-    fn as_place_builder<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<PlaceBuilder<'tcx>>\n+    crate fn as_place_builder<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<PlaceBuilder<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {"}, {"sha": "bfb3dcb8da355ea46efdd5fbaf30293b1990ceb8", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e2efdd156bf6915d6831821ff8a263e43e493e32/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2efdd156bf6915d6831821ff8a263e43e493e32/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=e2efdd156bf6915d6831821ff8a263e43e493e32", "patch": "@@ -4,6 +4,7 @@ use rustc_index::vec::Idx;\n \n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n+use crate::build::expr::as_place::PlaceBase;\n use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind;\n@@ -393,51 +394,54 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         this.cfg.push(block, Statement { source_info, kind: StatementKind::StorageLive(temp) });\n \n-        let arg_place = unpack!(block = this.as_place(block, arg));\n-\n-        let mutability = match arg_place.as_ref() {\n-            PlaceRef { local, projection: &[] } => this.local_decls[local].mutability,\n-            PlaceRef { local, projection: &[ProjectionElem::Deref] } => {\n-                debug_assert!(\n-                    this.local_decls[local].is_ref_for_guard(),\n-                    \"Unexpected capture place\",\n-                );\n-                this.local_decls[local].mutability\n-            }\n-            PlaceRef {\n-                local,\n-                projection: &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n-            }\n-            | PlaceRef {\n-                local,\n-                projection:\n-                    &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _), ProjectionElem::Deref],\n-            } => {\n-                let place = PlaceRef { local, projection: proj_base };\n-\n-                // Not projected from the implicit `self` in a closure.\n-                debug_assert!(\n-                    match place.local_or_deref_local() {\n-                        Some(local) => local == Local::new(1),\n-                        None => false,\n-                    },\n-                    \"Unexpected capture place\"\n-                );\n-                // Not in a closure\n-                debug_assert!(\n-                    this.upvar_mutbls.len() > upvar_index.index(),\n-                    \"Unexpected capture place\"\n-                );\n-                this.upvar_mutbls[upvar_index.index()]\n+        let arg_place_builder = unpack!(block = this.as_place_builder(block, arg));\n+\n+        let mutability = match arg_place_builder.base() {\n+            // We are capturing a path that starts off a local variable in the parent.\n+            // The mutability of the current capture is same as the mutability\n+            // of the local declaration in the parent.\n+            PlaceBase::Local(local) =>  this.local_decls[local].mutability,\n+            // Parent is a closure and we are capturing a path that is captured\n+            // by the parent itself. The mutability of the current capture\n+            // is same as that of the capture in the parent closure.\n+            PlaceBase::Upvar { .. } => {\n+                let enclosing_upvars_resolved = arg_place_builder.clone().into_place(\n+                    this.hir.tcx(),\n+                    this.hir.typeck_results());\n+\n+                match enclosing_upvars_resolved.as_ref() {\n+                    PlaceRef { local, projection: &[ProjectionElem::Field(upvar_index, _), ..] }\n+                    | PlaceRef {\n+                        local,\n+                        projection: &[ProjectionElem::Deref, ProjectionElem::Field(upvar_index, _), ..] } => {\n+                            // Not in a closure\n+                            debug_assert!(\n+                                local == Local::new(1),\n+                                \"Expected local to be Local(1), found {:?}\",\n+                                local\n+                            );\n+                            // Not in a closure\n+                            debug_assert!(\n+                                this.upvar_mutbls.len() > upvar_index.index(),\n+                                \"Unexpected capture place, upvar_mutbls={:#?}, upvar_index={:?}\",\n+                                this.upvar_mutbls, upvar_index\n+                            );\n+                            this.upvar_mutbls[upvar_index.index()]\n+                        }\n+                    _ => bug!(\"Unexpected capture place\"),\n+                }\n             }\n-            _ => bug!(\"Unexpected capture place\"),\n         };\n \n         let borrow_kind = match mutability {\n             Mutability::Not => BorrowKind::Unique,\n             Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n         };\n \n+        let arg_place = arg_place_builder.into_place(\n+                    this.hir.tcx(),\n+                    this.hir.typeck_results());\n+\n         this.cfg.push_assign(\n             block,\n             source_info,"}, {"sha": "d7fce15d99669f8172b2a754d5b8ff3fee622907", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e2efdd156bf6915d6831821ff8a263e43e493e32/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2efdd156bf6915d6831821ff8a263e43e493e32/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=e2efdd156bf6915d6831821ff8a263e43e493e32", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{GeneratorKind, HirIdMap, Node};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::Subst;\n@@ -823,7 +824,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // with the closure's DefId. Here, we run through that vec of UpvarIds for\n         // the given closure and use the necessary information to create upvar\n         // debuginfo and to fill `self.upvar_mutbls`.\n-        if let Some(upvars) = hir_typeck_results.closure_captures.get(&fn_def_id) {\n+        if hir_typeck_results.closure_min_captures.get(&fn_def_id).is_some() {\n             let closure_env_arg = Local::new(1);\n             let mut closure_env_projs = vec![];\n             let mut closure_ty = self.local_decls[closure_env_arg].ty;\n@@ -836,14 +837,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ty::Generator(_, substs, _) => ty::UpvarSubsts::Generator(substs),\n                 _ => span_bug!(self.fn_span, \"upvars with non-closure env ty {:?}\", closure_ty),\n             };\n-            let upvar_tys = upvar_substs.upvar_tys();\n-            let upvars_with_tys = upvars.iter().zip(upvar_tys);\n-            self.upvar_mutbls = upvars_with_tys\n+            let capture_tys = upvar_substs.upvar_tys();\n+            let captures_with_tys = hir_typeck_results\n+                .closure_min_captures_flattened(fn_def_id)\n+                .zip(capture_tys);\n+\n+            self.upvar_mutbls = captures_with_tys\n                 .enumerate()\n-                .map(|(i, ((&var_id, &upvar_id), ty))| {\n-                    let capture = hir_typeck_results.upvar_capture(upvar_id);\n+                .map(|(i, (captured_place, ty))| {\n+                    let capture = captured_place.info.capture_kind;\n+                    let var_id = match captured_place.place.base {\n+                        HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+                        _ => bug!(\"Expected an upvar\")\n+                    };\n \n                     let mut mutability = Mutability::Not;\n+\n+                    // FIXME(project-rfc-2229#8): Store more precise information\n                     let mut name = kw::Invalid;\n                     if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n                         if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {"}, {"sha": "d6695a5500d1b9fe484ad9cbad73b8179598dd0e", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e2efdd156bf6915d6831821ff8a263e43e493e32/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2efdd156bf6915d6831821ff8a263e43e493e32/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=e2efdd156bf6915d6831821ff8a263e43e493e32", "patch": "@@ -6,6 +6,8 @@ use crate::thir::*;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_index::vec::Idx;\n+use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n+use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::BorrowKind;\n use rustc_middle::ty::adjustment::{\n@@ -386,14 +388,12 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n                     span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n             };\n+\n             let upvars = cx\n                 .typeck_results()\n-                .closure_captures\n-                .get(&def_id)\n-                .iter()\n-                .flat_map(|upvars| upvars.iter())\n+                .closure_min_captures_flattened(def_id)\n                 .zip(substs.upvar_tys())\n-                .map(|((&var_hir_id, _), ty)| capture_upvar(cx, expr, var_hir_id, ty))\n+                .map(|(captured_place, ty)| capture_upvar(cx, expr, captured_place, ty))\n                 .collect();\n             ExprKind::Closure { closure_id: def_id, substs, upvars, movability }\n         }\n@@ -981,27 +981,55 @@ fn overloaded_place<'a, 'tcx>(\n     ExprKind::Deref { arg: ref_expr.to_ref() }\n }\n \n-fn capture_upvar<'tcx>(\n+fn capture_upvar<'a, 'tcx>(\n     cx: &mut Cx<'_, 'tcx>,\n     closure_expr: &'tcx hir::Expr<'tcx>,\n-    var_hir_id: hir::HirId,\n+    captured_place: &'a ty::CapturedPlace<'tcx>,\n     upvar_ty: Ty<'tcx>,\n ) -> ExprRef<'tcx> {\n-    let upvar_id = ty::UpvarId {\n-        var_path: ty::UpvarPath { hir_id: var_hir_id },\n-        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.hir_id),\n-    };\n-    let upvar_capture = cx.typeck_results().upvar_capture(upvar_id);\n+    let upvar_capture = captured_place.info.capture_kind;\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n-    let var_ty = cx.typeck_results().node_type(var_hir_id);\n-    let captured_var = Expr {\n+    let var_ty = captured_place.place.base_ty;\n+\n+    // The result of capture analysis in `rustc_typeck/check/upvar.rs`represents a captured path\n+    // as it's seen for use within the closure and not at the time of closure creation.\n+    //\n+    // That is we see expect to see it start from a captured upvar and not something that is local\n+    // to the closure's parent.\n+    let var_hir_id = match captured_place.place.base {\n+        HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+        base => bug!(\"Expected an upvar, found {:?}\", base),\n+    };\n+\n+    let mut captured_place_expr = Expr {\n         temp_lifetime,\n         ty: var_ty,\n         span: closure_expr.span,\n         kind: convert_var(cx, var_hir_id),\n     };\n+\n+    for proj in captured_place.place.projections.iter() {\n+        let kind = match proj.kind {\n+            HirProjectionKind::Deref => ExprKind::Deref { arg: captured_place_expr.to_ref() },\n+            HirProjectionKind::Field(field, ..) => {\n+                // Variant index will always be 0, because for multi-variant\n+                // enums, we capture the enum entirely.\n+                ExprKind::Field {\n+                    lhs: captured_place_expr.to_ref(),\n+                    name: Field::new(field as usize),\n+                }\n+            }\n+            HirProjectionKind::Index | HirProjectionKind::Subslice => {\n+                // We don't capture these projections, so we can ignore them here\n+                continue;\n+            }\n+        };\n+\n+        captured_place_expr = Expr { temp_lifetime, ty: proj.ty, span: closure_expr.span, kind };\n+    }\n+\n     match upvar_capture {\n-        ty::UpvarCapture::ByValue(_) => captured_var.to_ref(),\n+        ty::UpvarCapture::ByValue(_) => captured_place_expr.to_ref(),\n         ty::UpvarCapture::ByRef(upvar_borrow) => {\n             let borrow_kind = match upvar_borrow.kind {\n                 ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n@@ -1012,7 +1040,7 @@ fn capture_upvar<'tcx>(\n                 temp_lifetime,\n                 ty: upvar_ty,\n                 span: closure_expr.span,\n-                kind: ExprKind::Borrow { borrow_kind, arg: captured_var.to_ref() },\n+                kind: ExprKind::Borrow { borrow_kind, arg: captured_place_expr.to_ref() },\n             }\n             .to_ref()\n         }"}]}