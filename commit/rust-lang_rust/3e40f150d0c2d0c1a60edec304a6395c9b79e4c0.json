{"sha": "3e40f150d0c2d0c1a60edec304a6395c9b79e4c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNDBmMTUwZDBjMmQwYzFhNjBlZGVjMzA0YTYzOTVjOWI3OWU0YzA=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-12-27T09:59:01Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-12-27T09:59:01Z"}, "message": "Add some more clif comments", "tree": {"sha": "fdad364ed8a963256b112a8ee7b7acb31fe01249", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdad364ed8a963256b112a8ee7b7acb31fe01249"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e40f150d0c2d0c1a60edec304a6395c9b79e4c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e40f150d0c2d0c1a60edec304a6395c9b79e4c0", "html_url": "https://github.com/rust-lang/rust/commit/3e40f150d0c2d0c1a60edec304a6395c9b79e4c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e40f150d0c2d0c1a60edec304a6395c9b79e4c0/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6359826c7b6017f12a0074054e2c0725c3ac9a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6359826c7b6017f12a0074054e2c0725c3ac9a9", "html_url": "https://github.com/rust-lang/rust/commit/e6359826c7b6017f12a0074054e2c0725c3ac9a9"}], "stats": {"total": 175, "additions": 133, "deletions": 42}, "files": [{"sha": "5fd7995332ad72fc4d79d5492adff44cc70ffb15", "filename": "src/abi.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3e40f150d0c2d0c1a60edec304a6395c9b79e4c0/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e40f150d0c2d0c1a60edec304a6395c9b79e4c0/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=3e40f150d0c2d0c1a60edec304a6395c9b79e4c0", "patch": "@@ -197,8 +197,10 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n     /// Instance must be monomorphized\n     pub fn get_function_ref(&mut self, inst: Instance<'tcx>) -> FuncRef {\n         let func_id = self.get_function_id(inst);\n-        self.module\n-            .declare_func_in_func(func_id, &mut self.bcx.func)\n+        let func_ref = self.module\n+            .declare_func_in_func(func_id, &mut self.bcx.func);\n+        self.add_entity_comment(func_ref, format!(\"{:?}\", inst));\n+        func_ref\n     }\n \n     fn lib_call(\n@@ -271,13 +273,13 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n     }\n }\n \n-fn add_local_comment<'a, 'tcx: 'a>(\n+fn add_arg_comment<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     msg: &str,\n     local: mir::Local,\n     local_field: Option<usize>,\n     param: Option<Value>,\n-    pass_mode: Option<PassMode>,\n+    pass_mode: PassMode,\n     ssa: crate::analyze::Flags,\n     ty: Ty<'tcx>,\n ) {\n@@ -291,11 +293,7 @@ fn add_local_comment<'a, 'tcx: 'a>(\n     } else {\n         Cow::Borrowed(\"-\")\n     };\n-    let pass_mode = if let Some(pass_mode) = pass_mode {\n-        Cow::Owned(format!(\"{:?}\", pass_mode))\n-    } else {\n-        Cow::Borrowed(\"-\")\n-    };\n+    let pass_mode = format!(\"{:?}\", pass_mode);\n     fx.add_global_comment(format!(\n         \"{msg:5} {local:>3}{local_field:<5} {param:10} {pass_mode:20} {ssa:10} {ty:?}\",\n         msg=msg, local=format!(\"{:?}\", local), local_field=local_field, param=param, pass_mode=pass_mode, ssa=format!(\"{:?}\", ssa), ty=ty,\n@@ -322,15 +320,34 @@ fn local_place<'a, 'tcx: 'a>(\n             offset: None,\n         });\n \n+        let TyLayout { ty, details } = layout;\n+        let ty::layout::LayoutDetails { size, align, abi: _, variants: _, fields: _ } = details;\n+        fx.add_entity_comment(stack_slot, format!(\n+            \"{:?}: {:?} size={} align={},{}\",\n+            local, ty, size.bytes(), align.abi.bytes(), align.pref.bytes(),\n+        ));\n+\n         CPlace::from_stack_slot(fx, stack_slot, layout.ty)\n     };\n \n     debug_assert!(fx.local_map.insert(local, place).is_none());\n     fx.local_map[&local]\n }\n \n-fn param_to_cvalue<'a, 'tcx: 'a>(fx: &FunctionCx<'a, 'tcx, impl Backend>, ebb_param: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n-    match get_pass_mode(fx.tcx, fx.self_sig().abi, layout.ty, false) {\n+fn cvalue_for_param<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    start_ebb: Ebb,\n+    local: mir::Local,\n+    local_field: Option<usize>,\n+    arg_ty: Ty<'tcx>,\n+    ssa_flags: crate::analyze::Flags,\n+) -> CValue<'tcx> {\n+    let layout = fx.layout_of(arg_ty);\n+    let pass_mode = get_pass_mode(fx.tcx, fx.self_sig().abi, arg_ty, false);\n+    let clif_type = pass_mode.get_param_ty(fx);\n+    let ebb_param = fx.bcx.append_ebb_param(start_ebb, clif_type);\n+    add_arg_comment(fx, \"arg\", local, local_field, Some(ebb_param), pass_mode, ssa_flags, arg_ty);\n+    match pass_mode {\n         PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n         PassMode::ByVal(_) => CValue::ByVal(ebb_param, layout),\n         PassMode::ByRef => CValue::ByRef(ebb_param, layout),\n@@ -352,9 +369,12 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n         PassMode::ByRef => Some(fx.bcx.append_ebb_param(start_ebb, fx.pointer_type)),\n     };\n \n-    enum ArgKind {\n-        Normal(Value),\n-        Spread(Vec<Value>),\n+    add_local_header_comment(fx);\n+    add_arg_comment(fx, \"ret\", RETURN_PLACE, None, ret_param, output_pass_mode, ssa_analyzed[&RETURN_PLACE], ret_layout.ty);\n+\n+    enum ArgKind<'tcx> {\n+        Normal(CValue<'tcx>),\n+        Spread(Vec<CValue<'tcx>>),\n     }\n \n     let func_params = fx\n@@ -375,25 +395,18 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n                     _ => bug!(\"spread argument isn't a tuple?! but {:?}\", arg_ty),\n                 };\n \n-                let mut ebb_params = Vec::new();\n+                let mut params = Vec::new();\n                 for (i, arg_ty) in tupled_arg_tys.iter().enumerate() {\n-                    let pass_mode = get_pass_mode(fx.tcx, fx.self_sig().abi, arg_ty, false);;\n-                    let clif_type = pass_mode.get_param_ty(fx);\n-                    let ebb_param = fx.bcx.append_ebb_param(start_ebb, clif_type);\n-                    add_local_comment(fx, \"arg\", local, Some(i), Some(ebb_param), Some(pass_mode), ssa_analyzed[&local], arg_ty);\n-                    ebb_params.push(ebb_param);\n+                    let param = cvalue_for_param(fx, start_ebb, local, Some(i), arg_ty, ssa_analyzed[&local]);\n+                    params.push(param);\n                 }\n \n-                (local, ArgKind::Spread(ebb_params), arg_ty)\n+                (local, ArgKind::Spread(params), arg_ty)\n             } else {\n-                let clif_type =\n-                    get_pass_mode(fx.tcx, fx.self_sig().abi, arg_ty, false).get_param_ty(fx);\n-                let ebb_param = fx.bcx.append_ebb_param(start_ebb, clif_type);\n-                let pass_mode = get_pass_mode(fx.tcx, fx.self_sig().abi, arg_ty, false);\n-                add_local_comment(fx, \"arg\", local, None, Some(ebb_param), Some(pass_mode), ssa_analyzed[&local], arg_ty);\n+                let param = cvalue_for_param(fx, start_ebb, local, None, arg_ty, ssa_analyzed[&local]);\n                 (\n                     local,\n-                    ArgKind::Normal(ebb_param),\n+                    ArgKind::Normal(param),\n                     arg_ty,\n                 )\n             }\n@@ -423,9 +436,6 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n         }\n     }\n \n-    add_local_header_comment(fx);\n-    add_local_comment(fx, \"ret\", RETURN_PLACE, None, ret_param, Some(output_pass_mode), ssa_analyzed[&RETURN_PLACE], ret_layout.ty);\n-\n     for (local, arg_kind, ty) in func_params {\n         let layout = fx.layout_of(ty);\n \n@@ -437,15 +447,12 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n         let place = local_place(fx, local, layout, is_ssa);\n \n         match arg_kind {\n-            ArgKind::Normal(ebb_param) => {\n-                let cvalue = param_to_cvalue(fx, ebb_param, layout);\n-                place.write_cvalue(fx, cvalue);\n+            ArgKind::Normal(param) => {\n+                place.write_cvalue(fx, param);\n             }\n-            ArgKind::Spread(ebb_params) => {\n-                for (i, ebb_param) in ebb_params.into_iter().enumerate() {\n-                    let sub_place = place.place_field(fx, mir::Field::new(i));\n-                    let cvalue = param_to_cvalue(fx, ebb_param, sub_place.layout());\n-                    sub_place.write_cvalue(fx, cvalue);\n+            ArgKind::Spread(params) => {\n+                for (i, param) in params.into_iter().enumerate() {\n+                    place.place_field(fx, mir::Field::new(i)).write_cvalue(fx, param);\n                 }\n             }\n         }\n@@ -455,8 +462,6 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n         let ty = fx.mir.local_decls[local].ty;\n         let layout = fx.layout_of(ty);\n \n-        add_local_comment(fx, \"local\", local, None, None, None, ssa_analyzed[&local], ty);\n-\n         let is_ssa = !ssa_analyzed\n             .get(&local)\n             .unwrap()"}, {"sha": "9687b21217a773b9d2a75bc645c7bc05ac85e844", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 88, "deletions": 2, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/3e40f150d0c2d0c1a60edec304a6395c9b79e4c0/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e40f150d0c2d0c1a60edec304a6395c9b79e4c0/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=3e40f150d0c2d0c1a60edec304a6395c9b79e4c0", "patch": "@@ -3,14 +3,70 @@ use std::collections::HashMap;\n use std::fmt;\n \n use cranelift::codegen::entity::SecondaryMap;\n+use cranelift::codegen::ir::entities::AnyEntity;\n use cranelift::codegen::write::{FuncWriter, PlainWriter};\n \n use crate::prelude::*;\n \n+/// This module provides the [CommentWriter] which makes it possible\n+/// to add comments to the written cranelift ir.\n+///\n+/// # Example\n+///\n+/// ```clif\n+/// test compile\n+/// target x86_64\n+///\n+/// function u0:0(i64, i64, i64) system_v {\n+/// ; symbol _ZN119_$LT$example..IsNotEmpty$u20$as$u20$mini_core..FnOnce$LT$$LP$$RF$$u27$a$u20$$RF$$u27$b$u20$$u5b$u16$u5d$$C$$RP$$GT$$GT$9call_once17he85059d5e6a760a0E\n+/// ; instance Instance { def: Item(DefId(0/0:29 ~ example[8787]::{{impl}}[0]::call_once[0])), substs: [ReErased, ReErased] }\n+/// ; sig ([IsNotEmpty, (&&[u16],)]; variadic: false)->(u8, u8)\n+///\n+/// ; ssa {_2: NOT_SSA, _4: NOT_SSA, _0: NOT_SSA, _3: (empty), _1: NOT_SSA}\n+/// ; msg   loc.idx    param    pass mode            ssa flags  ty\n+/// ; ret    _0      = v0       ByRef                NOT_SSA    (u8, u8)\n+/// ; arg    _1      = v1       ByRef                NOT_SSA    IsNotEmpty\n+/// ; arg    _2.0    = v2       ByVal(types::I64)    NOT_SSA    &&[u16]\n+///\n+///     ss0 = explicit_slot 0 ; _1: IsNotEmpty size=0 align=1,8\n+///     ss1 = explicit_slot 8 ; _2: (&&[u16],) size=8 align=8,8\n+///     ss2 = explicit_slot 8 ; _4: (&&[u16],) size=8 align=8,8\n+///     sig0 = (i64, i64, i64) system_v\n+///     sig1 = (i64, i64, i64) system_v\n+///     fn0 = colocated u0:6 sig1 ; Instance { def: Item(DefId(0/0:31 ~ example[8787]::{{impl}}[1]::call_mut[0])), substs: [ReErased, ReErased] }\n+///\n+/// ebb0(v0: i64, v1: i64, v2: i64):\n+///     v3 = stack_addr.i64 ss0\n+///     v4 = stack_addr.i64 ss1\n+///     store v2, v4\n+///     v5 = stack_addr.i64 ss2\n+///     jump ebb1\n+///\n+/// ebb1:\n+///     nop\n+/// ; _3 = &mut _1\n+/// ; _4 = _2\n+///     v6 = load.i64 v4\n+///     store v6, v5\n+/// ;\n+/// ; _0 = const mini_core::FnMut::call_mut(move _3, move _4)\n+///     v7 = load.i64 v5\n+///     call fn0(v0, v3, v7)\n+///     jump ebb2\n+///\n+/// ebb2:\n+///     nop\n+/// ;\n+/// ; return\n+///     return\n+/// }\n+/// ```\n+\n #[derive(Debug)]\n pub struct CommentWriter {\n     global_comments: Vec<String>,\n-    inst_comments: HashMap<Inst, String>\n+    entity_comments: HashMap<AnyEntity, String>,\n+    inst_comments: HashMap<Inst, String>,\n }\n \n impl CommentWriter {\n@@ -25,6 +81,7 @@ impl CommentWriter {\n                 format!(\"sig {:?}\", crate::abi::ty_fn_sig(tcx, instance.ty(tcx))),\n                 String::new(),\n             ],\n+            entity_comments: HashMap::new(),\n             inst_comments: HashMap::new(),\n         }\n     }\n@@ -48,7 +105,23 @@ impl<'a> FuncWriter for &'a CommentWriter {\n             writeln!(w, \"\")?;\n         }\n \n-        PlainWriter.write_preamble(w, func, reg_info)\n+        self.super_preamble(w, func, reg_info)\n+    }\n+\n+    fn write_entity_definition(\n+        &mut self,\n+        w: &mut dyn fmt::Write,\n+        _func: &Function,\n+        entity: AnyEntity,\n+        value: &fmt::Display,\n+    ) -> fmt::Result {\n+        write!(w, \"    {} = {}\", entity, value)?;\n+\n+        if let Some(comment) = self.entity_comments.get(&entity) {\n+            writeln!(w, \" ; {}\", comment.replace('\\n', \"\\n; \"))\n+        } else {\n+            writeln!(w, \"\")\n+        }\n     }\n \n     fn write_ebb_header(\n@@ -84,6 +157,19 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n         self.clif_comments.global_comments.push(comment.into());\n     }\n \n+    pub fn add_entity_comment<'s, S: Into<Cow<'s, str>>, E: Into<AnyEntity>>(&mut self, entity: E, comment: S) {\n+        use std::collections::hash_map::Entry;\n+        match self.clif_comments.entity_comments.entry(entity.into()) {\n+            Entry::Occupied(mut occ) => {\n+                occ.get_mut().push('\\n');\n+                occ.get_mut().push_str(comment.into().as_ref());\n+            }\n+            Entry::Vacant(vac) => {\n+                vac.insert(comment.into().into_owned());\n+            }\n+        }\n+    }\n+\n     pub fn add_comment<'s, S: Into<Cow<'s, str>>>(&mut self, inst: Inst, comment: S) {\n         use std::collections::hash_map::Entry;\n         match self.clif_comments.inst_comments.entry(inst) {"}]}