{"sha": "f9d61cd2eda81b595862635914bd0224402a4a26", "node_id": "C_kwDOAAsO6NoAKGY5ZDYxY2QyZWRhODFiNTk1ODYyNjM1OTE0YmQwMjI0NDAyYTRhMjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-15T23:10:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-15T23:10:14Z"}, "message": "Auto merge of #90146 - cjgillot:no-id-map, r=nagisa\n\nReduce use of LocalDefId <-> HirId maps\n\nThis is an attempt to reduce the perf effect of https://github.com/rust-lang/rust/pull/89278.\nr? `@ghost`", "tree": {"sha": "1e2d540d7fb5b23e6567d2c766b4b1f5dfbef30e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e2d540d7fb5b23e6567d2c766b4b1f5dfbef30e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9d61cd2eda81b595862635914bd0224402a4a26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9d61cd2eda81b595862635914bd0224402a4a26", "html_url": "https://github.com/rust-lang/rust/commit/f9d61cd2eda81b595862635914bd0224402a4a26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9d61cd2eda81b595862635914bd0224402a4a26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec4bcaac450279b029f3480b8b8f1b82ab36a5eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec4bcaac450279b029f3480b8b8f1b82ab36a5eb", "html_url": "https://github.com/rust-lang/rust/commit/ec4bcaac450279b029f3480b8b8f1b82ab36a5eb"}, {"sha": "8617ff0f0bfc8ab8484f4ad970d63e0a787f954f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8617ff0f0bfc8ab8484f4ad970d63e0a787f954f", "html_url": "https://github.com/rust-lang/rust/commit/8617ff0f0bfc8ab8484f4ad970d63e0a787f954f"}], "stats": {"total": 787, "additions": 374, "deletions": 413}, "files": [{"sha": "ba111d394ec26bc20dd81ddd1ae4aa2a5f5d200a", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -409,8 +409,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let generics = tcx.generics_of(self.mir_def_id());\n                     let param = generics.type_param(&param_ty, tcx);\n                     if let Some(generics) = tcx\n-                        .hir()\n-                        .get_generics(tcx.typeck_root_def_id(self.mir_def_id().to_def_id()))\n+                        .typeck_root_def_id(self.mir_def_id().to_def_id())\n+                        .as_local()\n+                        .and_then(|def_id| tcx.hir().get_generics(def_id))\n                     {\n                         suggest_constraining_type_param(\n                             tcx,"}, {"sha": "8f4e574fbd6188dfb83a607901c378e3cacde23c", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -628,42 +628,39 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n         (\n             true,\n-            td.as_local().and_then(|tld| {\n-                let h = hir_map.local_def_id_to_hir_id(tld);\n-                match hir_map.find(h) {\n-                    Some(Node::Item(hir::Item {\n-                        kind: hir::ItemKind::Trait(_, _, _, _, items),\n-                        ..\n-                    })) => {\n-                        let mut f_in_trait_opt = None;\n-                        for hir::TraitItemRef { id: fi, kind: k, .. } in *items {\n-                            let hi = fi.hir_id();\n-                            if !matches!(k, hir::AssocItemKind::Fn { .. }) {\n-                                continue;\n-                            }\n-                            if hir_map.name(hi) != hir_map.name(my_hir) {\n-                                continue;\n-                            }\n-                            f_in_trait_opt = Some(hi);\n-                            break;\n+            td.as_local().and_then(|tld| match hir_map.find_by_def_id(tld) {\n+                Some(Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, _, _, items),\n+                    ..\n+                })) => {\n+                    let mut f_in_trait_opt = None;\n+                    for hir::TraitItemRef { id: fi, kind: k, .. } in *items {\n+                        let hi = fi.hir_id();\n+                        if !matches!(k, hir::AssocItemKind::Fn { .. }) {\n+                            continue;\n                         }\n-                        f_in_trait_opt.and_then(|f_in_trait| match hir_map.find(f_in_trait) {\n-                            Some(Node::TraitItem(hir::TraitItem {\n-                                kind:\n-                                    hir::TraitItemKind::Fn(\n-                                        hir::FnSig { decl: hir::FnDecl { inputs, .. }, .. },\n-                                        _,\n-                                    ),\n-                                ..\n-                            })) => {\n-                                let hir::Ty { span, .. } = inputs[local.index() - 1];\n-                                Some(span)\n-                            }\n-                            _ => None,\n-                        })\n+                        if hir_map.name(hi) != hir_map.name(my_hir) {\n+                            continue;\n+                        }\n+                        f_in_trait_opt = Some(hi);\n+                        break;\n                     }\n-                    _ => None,\n+                    f_in_trait_opt.and_then(|f_in_trait| match hir_map.find(f_in_trait) {\n+                        Some(Node::TraitItem(hir::TraitItem {\n+                            kind:\n+                                hir::TraitItemKind::Fn(\n+                                    hir::FnSig { decl: hir::FnDecl { inputs, .. }, .. },\n+                                    _,\n+                                ),\n+                            ..\n+                        })) => {\n+                            let hir::Ty { span, .. } = inputs[local.index() - 1];\n+                            Some(span)\n+                        }\n+                        _ => None,\n+                    })\n                 }\n+                _ => None,\n             }),\n         )\n     }\n@@ -896,7 +893,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if look_at_return && hir.get_return_block(closure_id).is_some() {\n             // ...otherwise we are probably in the tail expression of the function, point at the\n             // return type.\n-            match hir.get(hir.get_parent_item(fn_call_id)) {\n+            match hir.get_by_def_id(hir.get_parent_item(fn_call_id)) {\n                 hir::Node::Item(hir::Item { ident, kind: hir::ItemKind::Fn(sig, ..), .. })\n                 | hir::Node::TraitItem(hir::TraitItem {\n                     ident,\n@@ -1075,8 +1072,7 @@ fn get_mut_span_in_struct_field<'tcx>(\n         if let ty::Adt(def, _) = ty.kind() {\n             let field = def.all_fields().nth(field.index())?;\n             // Use the HIR types to construct the diagnostic message.\n-            let hir_id = tcx.hir().local_def_id_to_hir_id(field.did.as_local()?);\n-            let node = tcx.hir().find(hir_id)?;\n+            let node = tcx.hir().find_by_def_id(field.did.as_local()?)?;\n             // Now we're dealing with the actual struct that we're going to suggest a change to,\n             // we can expect a field that is an immutable reference to a type.\n             if let hir::Node::Field(field) = node {"}, {"sha": "9aa58f05a8e65e5e55ce8ed0d643c7a123d5f23c", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -704,7 +704,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         hir::AsyncGeneratorKind::Block => \" of async block\",\n                         hir::AsyncGeneratorKind::Closure => \" of async closure\",\n                         hir::AsyncGeneratorKind::Fn => {\n-                            let parent_item = hir.get(hir.get_parent_item(mir_hir_id));\n+                            let parent_item = hir.get_by_def_id(hir.get_parent_item(mir_hir_id));\n                             let output = &parent_item\n                                 .fn_decl()\n                                 .expect(\"generator lowered from async fn should be in fn\")"}, {"sha": "aeddd926896e8233cb456ead084ac3ce997262c5", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -76,7 +76,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n             //\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n-            match tcx.hir().get(tcx.hir().local_def_id_to_hir_id(def_id)) {\n+            match tcx.hir().get_by_def_id(def_id) {\n                 Node::ForeignItem(..) => {\n                     tcx.is_statically_included_foreign_item(def_id).then_some(def_id)\n                 }"}, {"sha": "05fbbf45d7c24d5e0516ab3bf0c513f0c1c27794", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -1,5 +1,5 @@\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::Symbol;\n@@ -15,7 +15,8 @@ pub fn is_unstable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Symbol> {\n     }\n }\n \n-pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n+pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let parent_id = tcx.hir().get_parent_node(hir_id);\n     matches!(\n         tcx.hir().get(parent_id),\n@@ -29,15 +30,15 @@ pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n /// said intrinsic has a `rustc_const_{un,}stable` attribute.\n fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-\n-    let node = tcx.hir().get(hir_id);\n+    let def_id = def_id.expect_local();\n+    let node = tcx.hir().get_by_def_id(def_id);\n \n     if let hir::Node::ForeignItem(hir::ForeignItem { kind: hir::ForeignItemKind::Fn(..), .. }) =\n         node\n     {\n         // Intrinsics use `rustc_const_{un,}stable` attributes to indicate constness. All other\n         // foreign items cannot be evaluated at compile-time.\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = tcx.hir().get_foreign_abi(hir_id) {\n             tcx.lookup_const_stability(def_id).is_some()\n         } else {\n@@ -50,7 +51,7 @@ fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n \n         // If the function itself is not annotated with `const`, it may still be a `const fn`\n         // if it resides in a const trait impl.\n-        is_parent_const_impl_raw(tcx, hir_id)\n+        is_parent_const_impl_raw(tcx, def_id)\n     } else {\n         matches!(node, hir::Node::Ctor(_))\n     }"}, {"sha": "1daade8f4004b7745424487b84f75d93b8ebb7db", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -221,8 +221,7 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n             // Prevent const trait methods from being annotated as `stable`.\n             // FIXME: Do this as part of stability checking.\n             if self.is_const_stable_const_fn() {\n-                let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                if crate::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n+                if crate::const_eval::is_parent_const_impl_raw(tcx, def_id) {\n                     self.ccx\n                         .tcx\n                         .sess"}, {"sha": "a3664493e18837309ef95147f4095efc78c1e265", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -210,8 +210,7 @@ impl Qualif for CustomEq {\n         // because that component may be part of an enum variant (e.g.,\n         // `Option::<NonStructuralMatchTy>::Some`), in which case some values of this type may be\n         // structural-match (`Option::None`).\n-        let id = cx.tcx.hir().local_def_id_to_hir_id(cx.def_id());\n-        traits::search_for_structural_match_violation(id, cx.body.span, cx.tcx, ty).is_some()\n+        traits::search_for_structural_match_violation(cx.body.span, cx.tcx, ty).is_some()\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "5b486819c35e83e55296f187a264c265c2a0c16a", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -19,11 +19,13 @@ pub struct HirId {\n }\n \n impl HirId {\n+    #[inline]\n     pub fn expect_owner(self) -> LocalDefId {\n         assert_eq!(self.local_id.index(), 0);\n         self.owner\n     }\n \n+    #[inline]\n     pub fn as_owner(self) -> Option<LocalDefId> {\n         if self.local_id.index() == 0 { Some(self.owner) } else { None }\n     }"}, {"sha": "7676ff3c41cc7adcc7c783f9a20e5e07e13747ea", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -223,8 +223,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n     /// Return all DepNode labels that should be asserted for this item.\n     /// index=0 is the \"name\" used for error messages\n     fn auto_labels(&mut self, item_id: LocalDefId, attr: &Attribute) -> (&'static str, Labels) {\n-        let hir_id = self.tcx.hir().local_def_id_to_hir_id(item_id);\n-        let node = self.tcx.hir().get(hir_id);\n+        let node = self.tcx.hir().get_by_def_id(item_id);\n         let (name, labels) = match node {\n             HirNode::Item(item) => {\n                 match item.kind {"}, {"sha": "ece7ca9df18e5217974574b871668414fddf3be0", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -151,11 +151,10 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n ) -> (String, Span) {\n     let sm = tcx.sess.source_map();\n \n-    let scope = region.free_region_binding_scope(tcx);\n-    let node = tcx.hir().local_def_id_to_hir_id(scope.expect_local());\n+    let scope = region.free_region_binding_scope(tcx).expect_local();\n     match *region {\n         ty::ReEarlyBound(ref br) => {\n-            let mut sp = sm.guess_head_span(tcx.hir().span(node));\n+            let mut sp = sm.guess_head_span(tcx.def_span(scope));\n             if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n             {\n@@ -166,7 +165,7 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n         ty::ReFree(ty::FreeRegion {\n             bound_region: ty::BoundRegionKind::BrNamed(_, name), ..\n         }) => {\n-            let mut sp = sm.guess_head_span(tcx.hir().span(node));\n+            let mut sp = sm.guess_head_span(tcx.def_span(scope));\n             if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n             {\n@@ -181,13 +180,13 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n                 } else {\n                     (\n                         format!(\"the anonymous lifetime #{} defined here\", idx + 1),\n-                        tcx.hir().span(node),\n+                        tcx.def_span(scope),\n                     )\n                 }\n             }\n             _ => (\n                 format!(\"the lifetime `{}` as defined here\", region),\n-                sm.guess_head_span(tcx.hir().span(node)),\n+                sm.guess_head_span(tcx.def_span(scope)),\n             ),\n         },\n         _ => bug!(),\n@@ -1759,8 +1758,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         if let Some(ValuePairs::PolyTraitRefs(exp_found)) = values {\n             if let ty::Closure(def_id, _) = exp_found.expected.skip_binder().self_ty().kind() {\n                 if let Some(def_id) = def_id.as_local() {\n-                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                    let span = self.tcx.hir().span(hir_id);\n+                    let span = self.tcx.def_span(def_id);\n                     diag.span_note(span, \"this closure does not fulfill the lifetime requirements\");\n                 }\n             }\n@@ -2212,9 +2210,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     if let Some(Node::Item(Item {\n                         kind: ItemKind::Trait(..) | ItemKind::Impl { .. },\n                         ..\n-                    })) = hir.find(parent_id)\n+                    })) = hir.find_by_def_id(parent_id)\n                     {\n-                        Some(self.tcx.generics_of(hir.local_def_id(parent_id).to_def_id()))\n+                        Some(self.tcx.generics_of(parent_id))\n                     } else {\n                         None\n                     },\n@@ -2245,7 +2243,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         if let Node::GenericParam(param) = hir.get(id) {\n                             has_bounds = !param.bounds.is_empty();\n                         }\n-                        let sp = hir.span(id);\n+                        let sp = self.tcx.def_span(def_id);\n                         // `sp` only covers `T`, change it so that it covers\n                         // `T:` when appropriate\n                         let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n@@ -2291,12 +2289,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .as_ref()\n             .and_then(|(_, g, _)| g.params.first())\n             .and_then(|param| param.def_id.as_local())\n-            .map(|def_id| {\n-                (\n-                    hir.span(hir.local_def_id_to_hir_id(def_id)).shrink_to_lo(),\n-                    format!(\"{}, \", new_lt),\n-                )\n-            });\n+            .map(|def_id| (self.tcx.def_span(def_id).shrink_to_lo(), format!(\"{}, \", new_lt)));\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),"}, {"sha": "eecd0a5a70807c1de193522123cdae715f22f21f", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -187,6 +187,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             | ObligationCauseCode::BlockTailExpression(hir_id) = cause.code()\n             {\n                 let parent_id = tcx.hir().get_parent_item(*hir_id);\n+                let parent_id = tcx.hir().local_def_id_to_hir_id(parent_id);\n                 if let Some(fn_decl) = tcx.hir().fn_decl_by_hir_id(parent_id) {\n                     let mut span: MultiSpan = fn_decl.output.span().into();\n                     let mut add_label = true;\n@@ -425,7 +426,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let tcx = self.tcx();\n         match tcx.hir().get_if_local(def_id) {\n             Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find(tcx.hir().get_parent_item(impl_item.hir_id())) {\n+                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id())) {\n                     Some(Node::Item(Item {\n                         kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n                         ..\n@@ -434,13 +435,13 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 }\n             }\n             Some(Node::TraitItem(trait_item)) => {\n-                let parent_id = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find(parent_id) {\n+                let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n+                match tcx.hir().find_by_def_id(trait_did) {\n                     Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n                         // The method being called is defined in the `trait`, but the `'static`\n                         // obligation comes from the `impl`. Find that `impl` so that we can point\n                         // at it in the suggestion.\n-                        let trait_did = tcx.hir().local_def_id(parent_id).to_def_id();\n+                        let trait_did = trait_did.to_def_id();\n                         match tcx\n                             .hir()\n                             .trait_impls(trait_did)"}, {"sha": "0b1c59d092f2be4695ac3bc10e1b8f4a46c4d242", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -635,7 +635,7 @@ fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: LocalDefId, opaque_hir_id: hi\n     let scope = tcx.hir().get_defining_scope(opaque_hir_id);\n     // We walk up the node tree until we hit the root or the scope of the opaque type.\n     while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n-        hir_id = tcx.hir().get_parent_item(hir_id);\n+        hir_id = tcx.hir().local_def_id_to_hir_id(tcx.hir().get_parent_item(hir_id));\n     }\n     // Syntactically, we are allowed to define the concrete type if:\n     let res = hir_id == scope;"}, {"sha": "b73f403360a00decba6c4c9ce15d9362c4e70ff1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -610,8 +610,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n                 let Some(def_id) = real_trait.as_local() else { return };\n-                let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n-                let Some(Node::Item(item)) = cx.tcx.hir().find(hir_id) else { return };\n+                let Some(Node::Item(item)) = cx.tcx.hir().find_by_def_id(def_id) else { return };\n                 if let hir::VisibilityKind::Inherited = item.vis.node {\n                     for impl_item_ref in items {\n                         self.private_traits.insert(impl_item_ref.id.hir_id());\n@@ -656,7 +655,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n         // If the method is an impl for an item with docs_hidden, don't doc.\n         if method_context(cx, impl_item.hir_id()) == MethodLateContext::PlainImpl {\n-            let parent = cx.tcx.hir().get_parent_did(impl_item.hir_id());\n+            let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n             let impl_ty = cx.tcx.type_of(parent);\n             let outerdef = match impl_ty.kind() {\n                 ty::Adt(def, _) => Some(def.did),\n@@ -1212,7 +1211,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                             check_no_mangle_on_generic_fn(\n                                 no_mangle_attr,\n                                 Some(generics),\n-                                cx.tcx.hir().get_generics(it.id.def_id.to_def_id()).unwrap(),\n+                                cx.tcx.hir().get_generics(it.id.def_id).unwrap(),\n                                 it.span,\n                             );\n                         }"}, {"sha": "fb5bd316319036f1d17750f5eb07f8d6ec57780c", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -1579,12 +1579,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_info_for_closure(&mut self, def_id: LocalDefId) {\n+    fn encode_info_for_closure(&mut self, hir_id: hir::HirId) {\n+        let def_id = self.tcx.hir().local_def_id(hir_id);\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n \n         // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n         // including on the signature, which is inferred in `typeck.\n-        let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let ty = self.tcx.typeck(def_id).node_type(hir_id);\n \n         match ty.kind() {\n@@ -1605,9 +1605,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_info_for_anon_const(&mut self, def_id: LocalDefId) {\n+    fn encode_info_for_anon_const(&mut self, id: hir::HirId) {\n+        let def_id = self.tcx.hir().local_def_id(id);\n         debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n-        let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n         let qualifs = self.tcx.mir_const_qualif(def_id);\n@@ -1928,8 +1928,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n     fn visit_anon_const(&mut self, c: &'tcx AnonConst) {\n         intravisit::walk_anon_const(self, c);\n-        let def_id = self.tcx.hir().local_def_id(c.hir_id);\n-        self.encode_info_for_anon_const(def_id);\n+        self.encode_info_for_anon_const(c.hir_id);\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         intravisit::walk_item(self, item);\n@@ -1983,8 +1982,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr<'_>) {\n         if let hir::ExprKind::Closure(..) = expr.kind {\n-            let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n-            self.encode_info_for_closure(def_id);\n+            self.encode_info_for_closure(expr.hir_id);\n         }\n     }\n "}, {"sha": "aac9595ae6bacfae0d0ce0a752c368db8732e80d", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -117,13 +117,13 @@ pub struct ParentOwnerIterator<'hir> {\n }\n \n impl<'hir> Iterator for ParentOwnerIterator<'hir> {\n-    type Item = (HirId, OwnerNode<'hir>);\n+    type Item = (LocalDefId, OwnerNode<'hir>);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if self.current_id.local_id.index() != 0 {\n             self.current_id.local_id = ItemLocalId::new(0);\n             if let Some(node) = self.map.tcx.hir_owner(self.current_id.owner) {\n-                return Some((self.current_id, node.node));\n+                return Some((self.current_id.owner, node.node));\n             }\n         }\n         if self.current_id == CRATE_HIR_ID {\n@@ -141,7 +141,7 @@ impl<'hir> Iterator for ParentOwnerIterator<'hir> {\n \n             // If this `HirId` doesn't have an entry, skip it and look for its `parent_id`.\n             if let Some(node) = self.map.tcx.hir_owner(self.current_id.owner) {\n-                return Some((self.current_id, node.node));\n+                return Some((self.current_id.owner, node.node));\n             }\n         }\n     }\n@@ -200,8 +200,12 @@ impl<'hir> Map<'hir> {\n \n     #[inline]\n     pub fn opt_local_def_id(&self, hir_id: HirId) -> Option<LocalDefId> {\n-        // FIXME(#85914) is this access safe for incr. comp.?\n-        self.tcx.untracked_resolutions.definitions.opt_hir_id_to_local_def_id(hir_id)\n+        if hir_id.local_id == ItemLocalId::new(0) {\n+            Some(hir_id.owner)\n+        } else {\n+            // FIXME(#85914) is this access safe for incr. comp.?\n+            self.tcx.untracked_resolutions.definitions.opt_hir_id_to_local_def_id(hir_id)\n+        }\n     }\n \n     #[inline]\n@@ -336,17 +340,28 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n+    #[inline]\n+    pub fn find_by_def_id(&self, id: LocalDefId) -> Option<Node<'hir>> {\n+        self.find(self.local_def_id_to_hir_id(id))\n+    }\n+\n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n     pub fn get(&self, id: HirId) -> Node<'hir> {\n         self.find(id).unwrap_or_else(|| bug!(\"couldn't find hir id {} in the HIR map\", id))\n     }\n \n+    /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n+    #[inline]\n+    pub fn get_by_def_id(&self, id: LocalDefId) -> Node<'hir> {\n+        self.find_by_def_id(id).unwrap_or_else(|| bug!(\"couldn't find {:?} in the HIR map\", id))\n+    }\n+\n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n         id.as_local().and_then(|id| self.find(self.local_def_id_to_hir_id(id)))\n     }\n \n-    pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n-        let id = id.as_local()?;\n+    pub fn get_generics(&self, id: LocalDefId) -> Option<&'hir Generics<'hir>> {\n         let node = self.tcx.hir_owner(id)?;\n         match node.node {\n             OwnerNode::ImplItem(impl_item) => Some(&impl_item.generics),\n@@ -530,10 +545,12 @@ impl<'hir> Map<'hir> {\n         });\n     }\n \n-    pub fn ty_param_owner(&self, id: HirId) -> HirId {\n+    pub fn ty_param_owner(&self, id: HirId) -> LocalDefId {\n         match self.get(id) {\n-            Node::Item(&Item { kind: ItemKind::Trait(..) | ItemKind::TraitAlias(..), .. }) => id,\n-            Node::GenericParam(_) => self.get_parent_node(id),\n+            Node::Item(&Item { kind: ItemKind::Trait(..) | ItemKind::TraitAlias(..), .. }) => {\n+                id.expect_owner()\n+            }\n+            Node::GenericParam(_) => self.get_parent_item(id),\n             _ => bug!(\"ty_param_owner: {} not a type parameter\", self.node_to_string(id)),\n         }\n     }\n@@ -776,23 +793,23 @@ impl<'hir> Map<'hir> {\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n-    pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n-        if let Some((hir_id, _node)) = self.parent_owner_iter(hir_id).next() {\n-            hir_id\n+    pub fn get_parent_item(&self, hir_id: HirId) -> LocalDefId {\n+        if let Some((def_id, _node)) = self.parent_owner_iter(hir_id).next() {\n+            def_id\n         } else {\n-            CRATE_HIR_ID\n+            CRATE_DEF_ID\n         }\n     }\n \n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    pub(super) fn get_module_parent_node(&self, hir_id: HirId) -> HirId {\n-        for (hir_id, node) in self.parent_owner_iter(hir_id) {\n+    pub(super) fn get_module_parent_node(&self, hir_id: HirId) -> LocalDefId {\n+        for (def_id, node) in self.parent_owner_iter(hir_id) {\n             if let OwnerNode::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n-                return hir_id;\n+                return def_id;\n             }\n         }\n-        CRATE_HIR_ID\n+        CRATE_DEF_ID\n     }\n \n     /// When on an if expression, a match arm tail expression or a match arm, give back\n@@ -855,19 +872,18 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn get_parent_did(&self, id: HirId) -> LocalDefId {\n-        self.local_def_id(self.get_parent_item(id))\n-    }\n-\n     pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n-        if let Some(node) = self.tcx.hir_owner(self.local_def_id(parent)) {\n+        if let Some(node) = self.tcx.hir_owner(parent) {\n             if let OwnerNode::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }) = node.node\n             {\n                 return *abi;\n             }\n         }\n-        bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n+        bug!(\n+            \"expected foreign mod or inlined parent, found {}\",\n+            self.node_to_string(HirId::make_owner(parent))\n+        )\n     }\n \n     pub fn expect_item(&self, id: LocalDefId) -> &'hir Item<'hir> {\n@@ -925,7 +941,7 @@ impl<'hir> Map<'hir> {\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n             Node::Binding(&Pat { kind: PatKind::Binding(_, _, l, _), .. }) => l.name,\n-            Node::Ctor(..) => self.name(self.get_parent_item(id)),\n+            Node::Ctor(..) => self.name(HirId::make_owner(self.get_parent_item(id))),\n             _ => return None,\n         })\n     }"}, {"sha": "8164eefd6cb2e317bf6e8631f5e33444d5ba1f24", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -58,13 +58,13 @@ impl<'tcx> TyCtxt<'tcx> {\n pub fn provide(providers: &mut Providers) {\n     providers.parent_module_from_def_id = |tcx, id| {\n         let hir = tcx.hir();\n-        hir.local_def_id(hir.get_module_parent_node(hir.local_def_id_to_hir_id(id)))\n+        hir.get_module_parent_node(hir.local_def_id_to_hir_id(id))\n     };\n     providers.hir_crate = |tcx, ()| tcx.untracked_crate;\n     providers.crate_hash = map::crate_hash;\n     providers.hir_module_items = map::hir_module_items;\n     providers.hir_owner = |tcx, id| {\n-        let owner = tcx.hir_crate(()).owners[id].as_ref()?;\n+        let owner = tcx.hir_crate(()).owners.get(id)?.as_ref()?;\n         let node = owner.node();\n         Some(Owner { node, hash_without_bodies: owner.nodes.hash_without_bodies })\n     };"}, {"sha": "6d531d3e7d620fa68a52d06c25d4bd038ca2edf9", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -348,7 +348,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // Deprecated attributes apply in-crate and cross-crate.\n         if let Some(id) = id {\n             if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n-                let parent_def_id = self.hir().local_def_id(self.hir().get_parent_item(id));\n+                let parent_def_id = self.hir().get_parent_item(id);\n                 let skip = self\n                     .lookup_deprecation_entry(parent_def_id.to_def_id())\n                     .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));"}, {"sha": "0890ba63e58567ac900ac10cb5fffd7f4d66927d", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -2449,15 +2449,14 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                     AggregateKind::Closure(def_id, substs) => ty::tls::with(|tcx| {\n                         if let Some(def_id) = def_id.as_local() {\n-                            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n                                 let substs = tcx.lift(substs).unwrap();\n                                 format!(\n                                     \"[closure@{}]\",\n                                     tcx.def_path_str_with_substs(def_id.to_def_id(), substs),\n                                 )\n                             } else {\n-                                let span = tcx.hir().span(hir_id);\n+                                let span = tcx.def_span(def_id);\n                                 format!(\n                                     \"[closure@{}]\",\n                                     tcx.sess.source_map().span_to_diagnostic_string(span)\n@@ -2481,8 +2480,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n                         if let Some(def_id) = def_id.as_local() {\n-                            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                            let name = format!(\"[generator@{:?}]\", tcx.hir().span(hir_id));\n+                            let name = format!(\"[generator@{:?}]\", tcx.def_span(def_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             // FIXME(project-rfc-2229#48): This should be a list of capture names/places"}, {"sha": "892808386deef4c79bc5b3cad93d7fd711d066d1", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -179,15 +179,11 @@ impl<'tcx> MonoItem<'tcx> {\n \n     pub fn local_span(&self, tcx: TyCtxt<'tcx>) -> Option<Span> {\n         match *self {\n-            MonoItem::Fn(Instance { def, .. }) => {\n-                def.def_id().as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n-            }\n-            MonoItem::Static(def_id) => {\n-                def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n-            }\n-            MonoItem::GlobalAsm(item_id) => Some(item_id.hir_id()),\n+            MonoItem::Fn(Instance { def, .. }) => def.def_id().as_local(),\n+            MonoItem::Static(def_id) => def_id.as_local(),\n+            MonoItem::GlobalAsm(item_id) => Some(item_id.def_id),\n         }\n-        .map(|hir_id| tcx.hir().span(hir_id))\n+        .map(|def_id| tcx.def_span(def_id))\n     }\n \n     // Only used by rustc_codegen_cranelift"}, {"sha": "e76cf5d94d32edfdbc358ad311b99c9f19b670af", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -665,9 +665,7 @@ fn trim_span_hi(span: Span, to_pos: BytePos) -> Span {\n }\n \n fn fn_span<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Span {\n-    let hir_id =\n-        tcx.hir().local_def_id_to_hir_id(def_id.as_local().expect(\"expected DefId is local\"));\n-    let fn_decl_span = tcx.hir().span(hir_id);\n+    let fn_decl_span = tcx.def_span(def_id);\n     if let Some(body_span) = hir_body(tcx, def_id).map(|hir_body| hir_body.value.span) {\n         if fn_decl_span.ctxt() == body_span.ctxt() { fn_decl_span.to(body_span) } else { body_span }\n     } else {"}, {"sha": "373823087c5c843ae1dd2cad4b004c01a45b3570", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -42,9 +42,7 @@ impl<'tcx> Const<'tcx> {\n     ) -> &'tcx Self {\n         debug!(\"Const::from_anon_const(def={:?})\", def);\n \n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n-\n-        let body_id = match tcx.hir().get(hir_id) {\n+        let body_id = match tcx.hir().get_by_def_id(def.did) {\n             hir::Node::AnonConst(ac) => ac.body,\n             _ => span_bug!(\n                 tcx.def_span(def.did.to_def_id()),\n@@ -260,8 +258,7 @@ impl<'tcx> Const<'tcx> {\n }\n \n pub fn const_param_default<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Const<'tcx> {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    let default_def_id = match tcx.hir().get(hir_id) {\n+    let default_def_id = match tcx.hir().get_by_def_id(def_id.expect_local()) {\n         hir::Node::GenericParam(hir::GenericParam {\n             kind: hir::GenericParamKind::Const { ty: _, default: Some(ac) },\n             .."}, {"sha": "9f38421294d9e56c39cb819ffdccb28ef862cafc", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -1461,8 +1461,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => return None, // not a free region\n         };\n \n-        let hir_id = self.hir().local_def_id_to_hir_id(suitable_region_binding_scope);\n-        let is_impl_item = match self.hir().find(hir_id) {\n+        let is_impl_item = match self.hir().find_by_def_id(suitable_region_binding_scope) {\n             Some(Node::Item(..) | Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n@@ -1495,8 +1494,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn return_type_impl_trait(self, scope_def_id: LocalDefId) -> Option<(Ty<'tcx>, Span)> {\n         // `type_of()` will fail on these (#55796, #86483), so only allow `fn`s or closures.\n-        let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n-        match self.hir().get(hir_id) {\n+        match self.hir().get_by_def_id(scope_def_id) {\n             Node::Item(&hir::Item { kind: ItemKind::Fn(..), .. }) => {}\n             Node::TraitItem(&hir::TraitItem { kind: TraitItemKind::Fn(..), .. }) => {}\n             Node::ImplItem(&hir::ImplItem { kind: ImplItemKind::Fn(..), .. }) => {}\n@@ -1510,6 +1508,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let sig = ret_ty.fn_sig(self);\n                 let output = self.erase_late_bound_regions(sig.output());\n                 if output.is_impl_trait() {\n+                    let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n                     let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n                     Some((output, fn_decl.output.span()))\n                 } else {"}, {"sha": "5bb687512f3cbe5dbaa4b578e39d7a9ba15dbd09", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -869,7 +869,7 @@ fn foo(&self) -> Self::T { String::new() }\n         // When `body_owner` is an `impl` or `trait` item, look in its associated types for\n         // `expected` and point at it.\n         let parent_id = self.hir().get_parent_item(hir_id);\n-        let item = self.hir().find(parent_id);\n+        let item = self.hir().find_by_def_id(parent_id);\n         debug!(\"expected_projection parent item {:?}\", item);\n         match item {\n             Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Trait(.., items), .. })) => {"}, {"sha": "55807874705f6253e603e4362e9712f01c3d5c9d", "filename": "compiler/rustc_middle/src/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -1,6 +1,6 @@\n use crate::ty::context::TyCtxt;\n use crate::ty::{DefId, DefIdTree};\n-use rustc_hir::CRATE_HIR_ID;\n+use rustc_span::def_id::CRATE_DEF_ID;\n use smallvec::SmallVec;\n use std::mem;\n use std::sync::Arc;\n@@ -43,8 +43,8 @@ impl<'tcx> DefIdForest {\n     /// Creates a forest consisting of a single tree representing the entire\n     /// crate.\n     #[inline]\n-    pub fn full(tcx: TyCtxt<'tcx>) -> DefIdForest {\n-        DefIdForest::from_id(tcx.hir().local_def_id(CRATE_HIR_ID).to_def_id())\n+    pub fn full() -> DefIdForest {\n+        DefIdForest::from_id(CRATE_DEF_ID.to_def_id())\n     }\n \n     /// Creates a forest containing a `DefId` and all its descendants.\n@@ -96,7 +96,7 @@ impl<'tcx> DefIdForest {\n         let mut ret: SmallVec<[_; 1]> = if let Some(first) = iter.next() {\n             SmallVec::from_slice(first.as_slice())\n         } else {\n-            return DefIdForest::full(tcx);\n+            return DefIdForest::full();\n         };\n \n         let mut next_ret: SmallVec<[_; 1]> = SmallVec::new();"}, {"sha": "167a54e42a0156bdd1b9e08c0fb128624325ee14", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -205,7 +205,7 @@ pub(crate) fn type_uninhabited_from<'tcx>(\n     match *ty.kind() {\n         Adt(def, substs) => def.uninhabited_from(tcx, substs, param_env),\n \n-        Never => DefIdForest::full(tcx),\n+        Never => DefIdForest::full(),\n \n         Tuple(ref tys) => DefIdForest::union(\n             tcx,"}, {"sha": "c188502f34f5c83a7807c9959b719c99b4f2e0ed", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -2082,8 +2082,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if let Some(impl_did) = impl_did.as_local() {\n-            let hir_id = self.hir().local_def_id_to_hir_id(impl_did);\n-            Ok(self.hir().span(hir_id))\n+            Ok(self.def_span(impl_did))\n         } else {\n             Err(self.crate_name(impl_did.krate))\n         }\n@@ -2130,7 +2129,7 @@ impl<'tcx> TyCtxt<'tcx> {\n /// Yields the parent function's `LocalDefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<LocalDefId> {\n     let def_id = def_id.as_local()?;\n-    if let Node::Item(item) = tcx.hir().get(tcx.hir().local_def_id_to_hir_id(def_id)) {\n+    if let Node::Item(item) = tcx.hir().get_by_def_id(def_id) {\n         if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.kind {\n             return match opaque_ty.origin {\n                 hir::OpaqueTyOrigin::FnReturn(parent) | hir::OpaqueTyOrigin::AsyncFn(parent) => {"}, {"sha": "32977fd42bd0a1944a681d2db20b12daa055b754", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -671,8 +671,7 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(\"generator\");\n                     // FIXME(eddyb) should use `def_span`.\n                     if let Some(did) = did.as_local() {\n-                        let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n-                        let span = self.tcx().hir().span(hir_id);\n+                        let span = self.tcx().def_span(did);\n                         p!(write(\n                             \"@{}\",\n                             // This may end up in stderr diagnostics but it may also be emitted\n@@ -708,11 +707,10 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(write(\"closure\"));\n                     // FIXME(eddyb) should use `def_span`.\n                     if let Some(did) = did.as_local() {\n-                        let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n                         if self.tcx().sess.opts.debugging_opts.span_free_formats {\n                             p!(\"@\", print_def_path(did.to_def_id(), substs));\n                         } else {\n-                            let span = self.tcx().hir().span(hir_id);\n+                            let span = self.tcx().def_span(did);\n                             p!(write(\n                                 \"@{}\",\n                                 // This may end up in stderr diagnostics but it may also be emitted"}, {"sha": "2433a00232d7fb0b8004b8240e53d1a97a31d6d9", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -217,17 +217,14 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n                 ty::ClosureKind::FnOnce => {}\n             }\n \n-            // We won't be building MIR if the closure wasn't local\n-            let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n-            let closure_span = tcx.hir().span(closure_hir_id);\n-\n             let Some((capture_index, capture)) =\n                 find_capture_matching_projections(\n                     typeck_results,\n                     var_hir_id,\n                     closure_def_id,\n                     &from_builder.projection,\n                 ) else {\n+                let closure_span = tcx.def_span(closure_def_id);\n                 if !enable_precise_capture(tcx, closure_span) {\n                     bug!(\n                         \"No associated capture found for {:?}[{:#?}] even though \\\n@@ -244,6 +241,8 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n                 return Err(from_builder);\n             };\n \n+            // We won't be building MIR if the closure wasn't local\n+            let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n             let closure_ty = typeck_results.node_type(closure_hir_id);\n \n             let substs = match closure_ty.kind() {"}, {"sha": "d348aaa899e65d79d78b950bb8d3bd196cd231c5", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -11,9 +11,8 @@ use std::ops::ControlFlow;\n \n crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n     let def_id = body.source.def_id().expect_local();\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n-    if let Some(fn_kind) = tcx.hir().get(hir_id).fn_kind() {\n+    if let Some(fn_kind) = tcx.hir().get_by_def_id(def_id).fn_kind() {\n         if let FnKind::Closure = fn_kind {\n             // closures can't recur, so they don't matter.\n             return;"}, {"sha": "8ccf6acf7034ca0ab77cfcfa5fd47754aefe010a", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -120,34 +120,32 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     }\n \n     fn search_for_structural_match_violation(&self, ty: Ty<'tcx>) -> Option<String> {\n-        traits::search_for_structural_match_violation(self.id, self.span, self.tcx(), ty).map(\n-            |non_sm_ty| {\n-                with_no_trimmed_paths(|| match non_sm_ty {\n-                    traits::NonStructuralMatchTy::Adt(adt) => self.adt_derive_msg(adt),\n-                    traits::NonStructuralMatchTy::Dynamic => {\n-                        \"trait objects cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTy::Opaque => {\n-                        \"opaque types cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTy::Closure => {\n-                        \"closures cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTy::Generator => {\n-                        \"generators cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTy::Param => {\n-                        bug!(\"use of a constant whose type is a parameter inside a pattern\")\n-                    }\n-                    traits::NonStructuralMatchTy::Projection => {\n-                        bug!(\"use of a constant whose type is a projection inside a pattern\")\n-                    }\n-                    traits::NonStructuralMatchTy::Foreign => {\n-                        bug!(\"use of a value of a foreign type inside a pattern\")\n-                    }\n-                })\n-            },\n-        )\n+        traits::search_for_structural_match_violation(self.span, self.tcx(), ty).map(|non_sm_ty| {\n+            with_no_trimmed_paths(|| match non_sm_ty {\n+                traits::NonStructuralMatchTy::Adt(adt) => self.adt_derive_msg(adt),\n+                traits::NonStructuralMatchTy::Dynamic => {\n+                    \"trait objects cannot be used in patterns\".to_string()\n+                }\n+                traits::NonStructuralMatchTy::Opaque => {\n+                    \"opaque types cannot be used in patterns\".to_string()\n+                }\n+                traits::NonStructuralMatchTy::Closure => {\n+                    \"closures cannot be used in patterns\".to_string()\n+                }\n+                traits::NonStructuralMatchTy::Generator => {\n+                    \"generators cannot be used in patterns\".to_string()\n+                }\n+                traits::NonStructuralMatchTy::Param => {\n+                    bug!(\"use of a constant whose type is a parameter inside a pattern\")\n+                }\n+                traits::NonStructuralMatchTy::Projection => {\n+                    bug!(\"use of a constant whose type is a projection inside a pattern\")\n+                }\n+                traits::NonStructuralMatchTy::Foreign => {\n+                    bug!(\"use of a value of a foreign type inside a pattern\")\n+                }\n+            })\n+        })\n     }\n \n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {"}, {"sha": "b5888592f6295ea44656896fd4884030b4fe419b", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -76,10 +76,8 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         }\n \n         let def_id = body.source.def_id().expect_local();\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-\n-        let is_fn_like = tcx.hir().get(hir_id).fn_kind().is_some();\n-        let is_assoc_const = tcx.def_kind(def_id.to_def_id()) == DefKind::AssocConst;\n+        let is_fn_like = tcx.hir().get_by_def_id(def_id).fn_kind().is_some();\n+        let is_assoc_const = tcx.def_kind(def_id) == DefKind::AssocConst;\n \n         // Only run const prop on functions, methods, closures and associated constants\n         if !is_fn_like && !is_assoc_const {"}, {"sha": "82455654a8860c11501e8caf17bcf5cc5abca8fc", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -66,8 +66,8 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n             return;\n         }\n \n-        let hir_id = tcx.hir().local_def_id_to_hir_id(mir_source.def_id().expect_local());\n-        let is_fn_like = tcx.hir().get(hir_id).fn_kind().is_some();\n+        let is_fn_like =\n+            tcx.hir().get_by_def_id(mir_source.def_id().expect_local()).fn_kind().is_some();\n \n         // Only instrument functions, methods, and closures (not constants since they are evaluated\n         // at compile time by Miri)."}, {"sha": "83e442c7891c6cc84cecf355d5601f21fbc74bb7", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -366,8 +366,7 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n         tcx.ensure().mir_borrowck(def.did);\n     }\n \n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n-    let is_fn_like = tcx.hir().get(hir_id).fn_kind().is_some();\n+    let is_fn_like = tcx.hir().get_by_def_id(def.did).fn_kind().is_some();\n     if is_fn_like {\n         let did = def.did.to_def_id();\n         let def = ty::WithOptConstParam::unknown(did);"}, {"sha": "27540395c07892054465dc5d1a1af0c866369e81", "filename": "compiler/rustc_monomorphize/src/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -49,8 +49,7 @@ crate fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: Instanc\n             .map(|l| format!(\"{:?}\", l.size.bytes()))\n             .unwrap_or_else(|e| format!(\"Failed {:?}\", e));\n \n-        let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n-        let closure_span = tcx.hir().span(closure_hir_id);\n+        let closure_span = tcx.def_span(closure_def_id);\n         let src_file = tcx.sess.source_map().span_to_filename(closure_span);\n         let line_nos = tcx\n             .sess"}, {"sha": "eca7d84e95d8e446e35b94a1ae65abd111314fbb", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{pluralize, struct_span_err, Applicability};\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n-use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{self, FnSig, ForeignItem, HirId, Item, ItemKind, TraitItem, CRATE_HIR_ID};\n use rustc_hir::{MethodKind, Target};\n@@ -32,7 +32,7 @@ pub(crate) fn target_from_impl_item<'tcx>(\n     match impl_item.kind {\n         hir::ImplItemKind::Const(..) => Target::AssocConst,\n         hir::ImplItemKind::Fn(..) => {\n-            let parent_hir_id = tcx.hir().get_parent_item(impl_item.hir_id()).expect_owner();\n+            let parent_hir_id = tcx.hir().get_parent_item(impl_item.hir_id());\n             let containing_item = tcx.hir().expect_item(parent_hir_id);\n             let containing_impl_is_for_trait = match &containing_item.kind {\n                 hir::ItemKind::Impl(impl_) => impl_.of_trait.is_some(),\n@@ -582,7 +582,7 @@ impl CheckAttrVisitor<'_> {\n             Target::Impl => Some(\"implementation block\"),\n             Target::ForeignMod => Some(\"extern block\"),\n             Target::AssocTy => {\n-                let parent_hir_id = self.tcx.hir().get_parent_item(hir_id).expect_owner();\n+                let parent_hir_id = self.tcx.hir().get_parent_item(hir_id);\n                 let containing_item = self.tcx.hir().expect_item(parent_hir_id);\n                 if Target::from_item(containing_item) == Target::Impl {\n                     Some(\"type alias in implementation block\")\n@@ -591,7 +591,7 @@ impl CheckAttrVisitor<'_> {\n                 }\n             }\n             Target::AssocConst => {\n-                let parent_hir_id = self.tcx.hir().get_parent_item(hir_id).expect_owner();\n+                let parent_hir_id = self.tcx.hir().get_parent_item(hir_id);\n                 let containing_item = self.tcx.hir().expect_item(parent_hir_id);\n                 // We can't link to trait impl's consts.\n                 let err = \"associated constant in trait implementation block\";\n@@ -832,7 +832,7 @@ impl CheckAttrVisitor<'_> {\n                     let mut err = lint.build(\n                         \"this attribute can only be applied at the crate level\",\n                     );\n-                    if attr.style == AttrStyle::Outer && self.tcx.hir().get_parent_item(hir_id) == CRATE_HIR_ID {\n+                    if attr.style == AttrStyle::Outer && self.tcx.hir().get_parent_item(hir_id) == CRATE_DEF_ID {\n                         if let Ok(mut src) =\n                             self.tcx.sess.source_map().span_to_snippet(attr.span)\n                         {"}, {"sha": "f17816eff9a7429321176126ace7066adb9622d9", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -23,7 +23,7 @@ use std::mem;\n // may need to be marked as live.\n fn should_explore(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     matches!(\n-        tcx.hir().find(tcx.hir().local_def_id_to_hir_id(def_id)),\n+        tcx.hir().find_by_def_id(def_id),\n         Some(\n             Node::Item(..)\n                 | Node::ImplItem(..)\n@@ -232,7 +232,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n             // tuple struct constructor function\n             let id = self.struct_constructors.get(&id).copied().unwrap_or(id);\n \n-            if let Some(node) = self.tcx.hir().find(self.tcx.hir().local_def_id_to_hir_id(id)) {\n+            if let Some(node) = self.tcx.hir().find_by_def_id(id) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }"}, {"sha": "fdabe41dafaedff61466dea6036b6be20c155163", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -1,8 +1,8 @@\n use rustc_ast::entry::EntryPointType;\n use rustc_errors::struct_span_err;\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::{ForeignItem, HirId, ImplItem, Item, ItemKind, Node, TraitItem, CRATE_HIR_ID};\n+use rustc_hir::{ForeignItem, ImplItem, Item, ItemKind, Node, TraitItem, CRATE_HIR_ID};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n@@ -18,14 +18,14 @@ struct EntryContext<'a, 'tcx> {\n     map: Map<'tcx>,\n \n     /// The function that has attribute named `main`.\n-    attr_main_fn: Option<(HirId, Span)>,\n+    attr_main_fn: Option<(LocalDefId, Span)>,\n \n     /// The function that has the attribute 'start' on it.\n-    start_fn: Option<(HirId, Span)>,\n+    start_fn: Option<(LocalDefId, Span)>,\n \n     /// The functions that one might think are `main` but aren't, e.g.\n     /// main functions not defined at the top level. For diagnostics.\n-    non_main_fns: Vec<(HirId, Span)>,\n+    non_main_fns: Vec<Span>,\n }\n \n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n@@ -112,11 +112,11 @@ fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n         }\n         EntryPointType::MainNamed => (),\n         EntryPointType::OtherMain => {\n-            ctxt.non_main_fns.push((item.hir_id(), item.span));\n+            ctxt.non_main_fns.push(item.span);\n         }\n         EntryPointType::MainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n-                ctxt.attr_main_fn = Some((item.hir_id(), item.span));\n+                ctxt.attr_main_fn = Some((item.def_id, item.span));\n             } else {\n                 struct_span_err!(\n                     ctxt.session,\n@@ -131,7 +131,7 @@ fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n         }\n         EntryPointType::Start => {\n             if ctxt.start_fn.is_none() {\n-                ctxt.start_fn = Some((item.hir_id(), item.span));\n+                ctxt.start_fn = Some((item.def_id, item.span));\n             } else {\n                 struct_span_err!(ctxt.session, item.span, E0138, \"multiple `start` functions\")\n                     .span_label(ctxt.start_fn.unwrap().1, \"previous `#[start]` function here\")\n@@ -143,20 +143,19 @@ fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n }\n \n fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(DefId, EntryFnType)> {\n-    if let Some((hir_id, _)) = visitor.start_fn {\n-        Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Start))\n-    } else if let Some((hir_id, _)) = visitor.attr_main_fn {\n-        Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Main))\n+    if let Some((def_id, _)) = visitor.start_fn {\n+        Some((def_id.to_def_id(), EntryFnType::Start))\n+    } else if let Some((def_id, _)) = visitor.attr_main_fn {\n+        Some((def_id.to_def_id(), EntryFnType::Main))\n     } else {\n         if let Some(main_def) = tcx.resolutions(()).main_def {\n             if let Some(def_id) = main_def.opt_fn_def_id() {\n                 // non-local main imports are handled below\n-                if def_id.is_local() {\n-                    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-                    if matches!(tcx.hir().find(hir_id), Some(Node::ForeignItem(_))) {\n+                if let Some(def_id) = def_id.as_local() {\n+                    if matches!(tcx.hir().find_by_def_id(def_id), Some(Node::ForeignItem(_))) {\n                         tcx.sess\n                             .struct_span_err(\n-                                tcx.hir().span(hir_id),\n+                                tcx.def_span(def_id),\n                                 \"the `main` function cannot be declared in an `extern` block\",\n                             )\n                             .emit();\n@@ -201,7 +200,7 @@ fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) {\n     );\n     let filename = &tcx.sess.local_crate_source_file;\n     let note = if !visitor.non_main_fns.is_empty() {\n-        for &(_, span) in &visitor.non_main_fns {\n+        for &span in &visitor.non_main_fns {\n             err.span_note(span, \"here is a function named `main`\");\n         }\n         err.note(\"you have one or more functions named `main` not defined at the crate level\");"}, {"sha": "d8c984c06764e094402e1c39f4e76f8688fef96b", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -57,22 +57,22 @@ impl<'a, 'hir> OuterVisitor<'a, 'hir> {\n impl<'a, 'hir> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n     fn visit_item(&mut self, i: &'hir hir::Item<'hir>) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.hir_id(), |this| intravisit::walk_item(this, i));\n+        inner_visitor.check(i.def_id, |this| intravisit::walk_item(this, i));\n     }\n \n     fn visit_trait_item(&mut self, i: &'hir hir::TraitItem<'hir>) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.hir_id(), |this| intravisit::walk_trait_item(this, i));\n+        inner_visitor.check(i.def_id, |this| intravisit::walk_trait_item(this, i));\n     }\n \n     fn visit_impl_item(&mut self, i: &'hir hir::ImplItem<'hir>) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.hir_id(), |this| intravisit::walk_impl_item(this, i));\n+        inner_visitor.check(i.def_id, |this| intravisit::walk_impl_item(this, i));\n     }\n \n     fn visit_foreign_item(&mut self, i: &'hir hir::ForeignItem<'hir>) {\n         let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n-        inner_visitor.check(i.hir_id(), |this| intravisit::walk_foreign_item(this, i));\n+        inner_visitor.check(i.def_id, |this| intravisit::walk_foreign_item(this, i));\n     }\n }\n \n@@ -83,9 +83,8 @@ impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n         self.errors.lock().push(f());\n     }\n \n-    fn check<F: FnOnce(&mut HirIdValidator<'a, 'hir>)>(&mut self, hir_id: HirId, walk: F) {\n+    fn check<F: FnOnce(&mut HirIdValidator<'a, 'hir>)>(&mut self, owner: LocalDefId, walk: F) {\n         assert!(self.owner.is_none());\n-        let owner = self.hir_map.local_def_id(hir_id);\n         self.owner = Some(owner);\n         walk(self);\n "}, {"sha": "3596210036a9c65aa13aef0e974b511912cf83ba", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -6,6 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n+#![feature(let_else)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n #![feature(nll)]"}, {"sha": "f4790c4335c12133f6e15d4625eedf42932f20b3", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -52,7 +52,7 @@ fn method_might_be_inlined(\n             return true;\n         }\n     }\n-    match tcx.hir().find(tcx.hir().local_def_id_to_hir_id(impl_src)) {\n+    match tcx.hir().find_by_def_id(impl_src) {\n         Some(Node::Item(item)) => item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n         Some(..) | None => span_bug!(impl_item.span, \"impl did is not an item\"),\n     }\n@@ -140,14 +140,11 @@ impl<'tcx> ReachableContext<'tcx> {\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n-        let hir_id = match def_id.as_local() {\n-            Some(def_id) => self.tcx.hir().local_def_id_to_hir_id(def_id),\n-            None => {\n-                return false;\n-            }\n+        let Some(def_id) = def_id.as_local() else {\n+            return false;\n         };\n \n-        match self.tcx.hir().find(hir_id) {\n+        match self.tcx.hir().find_by_def_id(def_id) {\n             Some(Node::Item(item)) => match item.kind {\n                 hir::ItemKind::Fn(..) => {\n                     item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id))\n@@ -169,7 +166,8 @@ impl<'tcx> ReachableContext<'tcx> {\n                         if generics.requires_monomorphization(self.tcx) || attrs.requests_inline() {\n                             true\n                         } else {\n-                            let impl_did = self.tcx.hir().get_parent_did(hir_id);\n+                            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+                            let impl_did = self.tcx.hir().get_parent_item(hir_id);\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n@@ -198,9 +196,7 @@ impl<'tcx> ReachableContext<'tcx> {\n                 continue;\n             }\n \n-            if let Some(ref item) =\n-                self.tcx.hir().find(self.tcx.hir().local_def_id_to_hir_id(search_item))\n-            {\n+            if let Some(ref item) = self.tcx.hir().find_by_def_id(search_item) {\n                 self.propagate_node(item, search_item);\n             }\n         }"}, {"sha": "270da883b8db45f3ec8f84342d2e50d156582f20", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -629,7 +629,7 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n-        let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent_item(ii.hir_id()));\n+        let impl_def_id = self.tcx.hir().get_parent_item(ii.hir_id());\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n             self.check_missing_stability(ii.def_id, ii.span);\n         }"}, {"sha": "e5d57a889a6fbe57fc2d0178fda4d7225e6acd82", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -2024,7 +2024,7 @@ fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility {\n                 // Visibilities of trait impl items are inherited from their traits\n                 // and are not filled in resolve.\n                 Node::ImplItem(impl_item) => {\n-                    match tcx.hir().get(tcx.hir().get_parent_item(hir_id)) {\n+                    match tcx.hir().get_by_def_id(tcx.hir().get_parent_item(hir_id)) {\n                         Node::Item(hir::Item {\n                             kind: hir::ItemKind::Impl(hir::Impl { of_trait: Some(tr), .. }),\n                             .."}, {"sha": "01fc1b7012e2630518e1f7049a68ec2062465b9f", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 41, "deletions": 49, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -376,12 +376,9 @@ pub fn provide(providers: &mut ty::query::Providers) {\n \n         named_region_map: |tcx, id| resolve_lifetimes_for(tcx, id).defs.get(&id),\n         is_late_bound_map,\n-        object_lifetime_defaults_map: |tcx, id| {\n-            let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n-            match tcx.hir().find(hir_id) {\n-                Some(Node::Item(item)) => compute_object_lifetime_defaults(tcx, item),\n-                _ => None,\n-            }\n+        object_lifetime_defaults_map: |tcx, id| match tcx.hir().find_by_def_id(id) {\n+            Some(Node::Item(item)) => compute_object_lifetime_defaults(tcx, item),\n+            _ => None,\n         },\n         late_bound_vars_map: |tcx, id| resolve_lifetimes_for(tcx, id).late_bound_vars.get(&id),\n         lifetime_scope_map: |tcx, id| {\n@@ -514,14 +511,14 @@ fn resolve_lifetimes_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx R\n \n /// Finds the `Item` that contains the given `LocalDefId`\n fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> LocalDefId {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n-    match tcx.hir().find(hir_id) {\n+    match tcx.hir().find_by_def_id(local_def_id) {\n         Some(Node::Item(item)) => {\n             return item.def_id;\n         }\n         _ => {}\n     }\n     let item = {\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n         let mut parent_iter = tcx.hir().parent_iter(hir_id);\n         loop {\n             let node = parent_iter.next().map(|n| n.1);\n@@ -1137,7 +1134,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir().get_parent_did(trait_item.hir_id())),\n+                    Some(tcx.hir().get_parent_item(trait_item.hir_id())),\n                     trait_item.hir_id(),\n                     &sig.decl,\n                     &trait_item.generics,\n@@ -1206,7 +1203,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n-                    Some(tcx.hir().get_parent_did(impl_item.hir_id())),\n+                    Some(tcx.hir().get_parent_item(impl_item.hir_id())),\n                     impl_item.hir_id(),\n                     &sig.decl,\n                     &impl_item.generics,\n@@ -1672,13 +1669,10 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n                     if let Some(def) =\n                         lifetimes.get(&hir::ParamName::Plain(label.normalize_to_macros_2_0()))\n                     {\n-                        let hir_id =\n-                            tcx.hir().local_def_id_to_hir_id(def.id().unwrap().expect_local());\n-\n                         signal_shadowing_problem(\n                             tcx,\n                             label.name,\n-                            original_lifetime(tcx.hir().span(hir_id)),\n+                            original_lifetime(tcx.def_span(def.id().unwrap().expect_local())),\n                             shadower_label(label.span),\n                         );\n                         return;\n@@ -1910,6 +1904,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let remove_decl = self\n             .tcx\n             .parent(def_id)\n+            .and_then(|parent_def_id| parent_def_id.as_local())\n             .and_then(|parent_def_id| self.tcx.hir().get_generics(parent_def_id))\n             .and_then(|generics| self.lifetime_deletion_span(name, generics));\n \n@@ -1950,7 +1945,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         };\n         if let Node::Lifetime(hir_lifetime) = self.tcx.hir().get(lifetime.hir_id) {\n             if let Some(parent) =\n-                self.tcx.hir().find(self.tcx.hir().get_parent_item(hir_lifetime.hir_id))\n+                self.tcx.hir().find_by_def_id(self.tcx.hir().get_parent_item(hir_lifetime.hir_id))\n             {\n                 match parent {\n                     Node::Item(item) => {\n@@ -2032,32 +2027,31 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n-                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-                    debug!(\"hir id first={:?}\", hir_id);\n-                    if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n-                        Node::Lifetime(hir_lifetime) => Some((\n-                            hir_lifetime.hir_id,\n-                            hir_lifetime.span,\n-                            hir_lifetime.name.ident(),\n-                        )),\n-                        Node::GenericParam(param) => {\n-                            Some((param.hir_id, param.span, param.name.ident()))\n+                    debug!(?def_id);\n+                    if let Some((id, span, name)) =\n+                        match self.tcx.hir().get_by_def_id(def_id.expect_local()) {\n+                            Node::Lifetime(hir_lifetime) => Some((\n+                                hir_lifetime.hir_id,\n+                                hir_lifetime.span,\n+                                hir_lifetime.name.ident(),\n+                            )),\n+                            Node::GenericParam(param) => {\n+                                Some((param.hir_id, param.span, param.name.ident()))\n+                            }\n+                            _ => None,\n                         }\n-                        _ => None,\n-                    } {\n+                    {\n                         debug!(\"id = {:?} span = {:?} name = {:?}\", id, span, name);\n                         if name.name == kw::UnderscoreLifetime {\n                             continue;\n                         }\n \n                         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n                             if let Some(def_id) = parent_def_id.as_local() {\n-                                let parent_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                                 // lifetimes in `derive` expansions don't count (Issue #53738)\n                                 if self\n                                     .tcx\n-                                    .hir()\n-                                    .attrs(parent_hir_id)\n+                                    .get_attrs(def_id.to_def_id())\n                                     .iter()\n                                     .any(|attr| attr.has_name(sym::automatically_derived))\n                                 {\n@@ -2069,7 +2063,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                 if let hir::Node::Item(hir::Item {\n                                     kind: hir::ItemKind::OpaqueTy(ref opaque),\n                                     ..\n-                                }) = self.tcx.hir().get(parent_hir_id)\n+                                }) = self.tcx.hir().get_by_def_id(def_id)\n                                 {\n                                     if !matches!(opaque.origin, hir::OpaqueTyOrigin::AsyncFn(..)) {\n                                         continue 'lifetimes;\n@@ -2115,18 +2109,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"not one use lifetime\");\n                 }\n                 None => {\n-                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-                    if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n-                        Node::Lifetime(hir_lifetime) => Some((\n-                            hir_lifetime.hir_id,\n-                            hir_lifetime.span,\n-                            hir_lifetime.name.ident(),\n-                        )),\n-                        Node::GenericParam(param) => {\n-                            Some((param.hir_id, param.span, param.name.ident()))\n+                    if let Some((id, span, name)) =\n+                        match self.tcx.hir().get_by_def_id(def_id.expect_local()) {\n+                            Node::Lifetime(hir_lifetime) => Some((\n+                                hir_lifetime.hir_id,\n+                                hir_lifetime.span,\n+                                hir_lifetime.name.ident(),\n+                            )),\n+                            Node::GenericParam(param) => {\n+                                Some((param.hir_id, param.span, param.name.ident()))\n+                            }\n+                            _ => None,\n                         }\n-                        _ => None,\n-                    } {\n+                    {\n                         debug!(\"id ={:?} span = {:?} name = {:?}\", id, span, name);\n                         self.tcx.struct_span_lint_hir(\n                             lint::builtin::UNUSED_LIFETIMES,\n@@ -2137,7 +2132,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                     .build(&format!(\"lifetime parameter `{}` never used\", name));\n                                 if let Some(parent_def_id) = self.tcx.parent(def_id) {\n                                     if let Some(generics) =\n-                                        self.tcx.hir().get_generics(parent_def_id)\n+                                        self.tcx.hir().get_generics(parent_def_id.expect_local())\n                                     {\n                                         let unused_lt_span =\n                                             self.lifetime_deletion_span(name, generics);\n@@ -2761,7 +2756,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             Node::TraitItem(&hir::TraitItem { kind: hir::TraitItemKind::Fn(_, ref m), .. }) => {\n                 if let hir::ItemKind::Trait(.., ref trait_items) =\n-                    self.tcx.hir().expect_item(self.tcx.hir().get_parent_did(parent)).kind\n+                    self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n                 {\n                     assoc_item_kind =\n                         trait_items.iter().find(|ti| ti.id.hir_id() == parent).map(|ti| ti.kind);\n@@ -2774,7 +2769,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, body), .. }) => {\n                 if let hir::ItemKind::Impl(hir::Impl { ref self_ty, ref items, .. }) =\n-                    self.tcx.hir().expect_item(self.tcx.hir().get_parent_did(parent)).kind\n+                    self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n                 {\n                     impl_self = Some(self_ty);\n                     assoc_item_kind =\n@@ -3339,13 +3334,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Binder { ref lifetimes, s, .. } => {\n                     if let Some(&def) = lifetimes.get(&param.name.normalize_to_macros_2_0()) {\n-                        let hir_id =\n-                            self.tcx.hir().local_def_id_to_hir_id(def.id().unwrap().expect_local());\n-\n                         signal_shadowing_problem(\n                             self.tcx,\n                             param.name.ident().name,\n-                            original_lifetime(self.tcx.hir().span(hir_id)),\n+                            original_lifetime(self.tcx.def_span(def.id().unwrap())),\n                             shadower_lifetime(&param),\n                         );\n                         return;"}, {"sha": "c5e85b14421cf082dec61a34e4a74ca6de6ab0f9", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -173,8 +173,7 @@ fn compute_symbol_name<'tcx>(\n             let stable_crate_id = tcx.sess.local_stable_crate_id();\n             return tcx.sess.generate_proc_macro_decls_symbol(stable_crate_id);\n         }\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        matches!(tcx.hir().get(hir_id), Node::ForeignItem(_))\n+        matches!(tcx.hir().get_by_def_id(def_id), Node::ForeignItem(_))\n     } else {\n         tcx.is_foreign_item(def_id)\n     };"}, {"sha": "b4d297a03ef21f3b552d8a15b9164fe0d77395b3", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -616,8 +616,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             self.tcx.sess.source_map().guess_head_span(\n                                 self.tcx.hir().span_if_local(closure_def_id).unwrap(),\n                             );\n-                        let hir_id =\n-                            self.tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             closure_span,\n@@ -640,6 +638,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         // Additional context information explaining why the closure only implements\n                         // a particular trait.\n                         if let Some(typeck_results) = self.in_progress_typeck_results {\n+                            let hir_id = self\n+                                .tcx\n+                                .hir()\n+                                .local_def_id_to_hir_id(closure_def_id.expect_local());\n                             let typeck_results = typeck_results.borrow();\n                             match (found_kind, typeck_results.closure_kind_origins().get(hir_id)) {\n                                 (ty::ClosureKind::FnOnce, Some((span, place))) => {"}, {"sha": "b06977c3f302e035d7bf2ef819cb3b9cc89af087", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -481,7 +481,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 _ => {}\n             }\n \n-            hir_id = self.tcx.hir().get_parent_item(hir_id);\n+            hir_id = self.tcx.hir().local_def_id_to_hir_id(self.tcx.hir().get_parent_item(hir_id));\n         }\n     }\n \n@@ -2301,7 +2301,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 {\n                     let in_progress_typeck_results =\n                         self.in_progress_typeck_results.map(|t| t.borrow());\n-                    let parent_id = hir.local_def_id(hir.get_parent_item(arg_hir_id));\n+                    let parent_id = hir.get_parent_item(arg_hir_id);\n                     let typeck_results: &TypeckResults<'tcx> = match &in_progress_typeck_results {\n                         Some(t) if t.hir_owner == parent_id => t,\n                         _ => self.tcx.typeck(parent_id),"}, {"sha": "45960bd365346ba6fe3ec36eb9d0b6733559111d", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -48,7 +48,6 @@ pub enum NonStructuralMatchTy<'tcx> {\n /// that arose when the requirement was not enforced completely, see\n /// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n pub fn search_for_structural_match_violation<'tcx>(\n-    _id: hir::HirId,\n     span: Span,\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,"}, {"sha": "781a639b09ebd0646b1e09e64d2ff961f52beebd", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -52,8 +52,7 @@ fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n \n fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n     let id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    let parent_id = tcx.hir().get_parent_item(id);\n-    let parent_def_id = tcx.hir().local_def_id(parent_id);\n+    let parent_def_id = tcx.hir().get_parent_item(id);\n     let parent_item = tcx.hir().expect_item(parent_def_id);\n     match parent_item.kind {\n         hir::ItemKind::Impl(ref impl_) => {"}, {"sha": "fb7fdacf5e6874925f5efc1e07033298146f206d", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -99,12 +99,7 @@ fn are_inner_types_recursive<'tcx>(\n             // Find non representable fields with their spans\n             fold_repr(def.all_fields().map(|field| {\n                 let ty = field.ty(tcx, substs);\n-                let span = match field\n-                    .did\n-                    .as_local()\n-                    .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n-                    .and_then(|id| tcx.hir().find(id))\n-                {\n+                let span = match field.did.as_local().and_then(|id| tcx.hir().find_by_def_id(id)) {\n                     Some(hir::Node::Field(field)) => field.ty.span,\n                     _ => sp,\n                 };"}, {"sha": "4d48cd25e362e094ec721e9c25cfd45f427a927f", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -279,8 +279,7 @@ fn well_formed_types_in_env<'tcx>(\n     if !def_id.is_local() {\n         return ty::List::empty();\n     }\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    let node = tcx.hir().get(hir_id);\n+    let node = tcx.hir().get_by_def_id(def_id.expect_local());\n \n     enum NodeKind {\n         TraitImpl,\n@@ -436,9 +435,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n \n /// Check if a function is async.\n fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-\n-    let node = tcx.hir().get(hir_id);\n+    let node = tcx.hir().get_by_def_id(def_id.expect_local());\n \n     let fn_kind = node.fn_kind().unwrap_or_else(|| {\n         bug!(\"asyncness: expected fn-like node but got `{:?}`\", def_id);"}, {"sha": "5044829cd89edb62b18f8778fac4fc1eb573e0f4", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -1914,7 +1914,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .and_then(|def_id| {\n                     def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n                 })\n-                .map(|hir_id| tcx.hir().get_parent_did(hir_id).to_def_id());\n+                .map(|hir_id| tcx.hir().get_parent_item(hir_id).to_def_id());\n \n             debug!(\"qpath_to_ty: parent_def_id={:?}\", parent_def_id);\n "}, {"sha": "89f9cbf22562d7c6b02616f91c623df15f93d98a", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -1314,7 +1314,7 @@ fn check_enum<'tcx>(\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n             let i_span = match variant_i.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n-                None => tcx.hir().span(variant_i_hir_id),\n+                None => tcx.def_span(variant_did),\n             };\n             let span = match v.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n@@ -1440,8 +1440,8 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'_>, def_id: LocalDefId, span: Span) {\n     let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n \n     let mut label = false;\n-    if let Some((hir_id, visitor)) = get_owner_return_paths(tcx, def_id) {\n-        let typeck_results = tcx.typeck(tcx.hir().local_def_id(hir_id));\n+    if let Some((def_id, visitor)) = get_owner_return_paths(tcx, def_id) {\n+        let typeck_results = tcx.typeck(def_id);\n         if visitor\n             .returns\n             .iter()"}, {"sha": "3668ecd234c64e1c8b216af4f6d07e653ba8038b", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -1575,7 +1575,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     expected,\n                     found,\n                     can_suggest,\n-                    fcx.tcx.hir().get_parent_item(id),\n+                    fcx.tcx.hir().local_def_id_to_hir_id(fcx.tcx.hir().get_parent_item(id)),\n                 );\n             }\n             if !pointing_at_return_type {\n@@ -1584,13 +1584,19 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         }\n \n         let parent_id = fcx.tcx.hir().get_parent_item(id);\n-        let parent_item = fcx.tcx.hir().get(parent_id);\n+        let parent_item = fcx.tcx.hir().get_by_def_id(parent_id);\n \n         if let (Some((expr, _)), Some((fn_decl, _, _))) =\n             (expression, fcx.get_node_fn_decl(parent_item))\n         {\n             fcx.suggest_missing_break_or_return_expr(\n-                &mut err, expr, fn_decl, expected, found, id, parent_id,\n+                &mut err,\n+                expr,\n+                fn_decl,\n+                expected,\n+                found,\n+                id,\n+                fcx.tcx.hir().local_def_id_to_hir_id(parent_id),\n             );\n         }\n "}, {"sha": "74327affede481e5d7e7b7913d835d42291385c0", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -435,10 +435,18 @@ fn check_region_bounds_on_impl_item<'tcx>(\n     if trait_params != impl_params {\n         let item_kind = assoc_item_kind_str(impl_m);\n         let def_span = tcx.sess.source_map().guess_head_span(span);\n-        let span = tcx.hir().get_generics(impl_m.def_id).map_or(def_span, |g| g.span);\n+        let span = impl_m\n+            .def_id\n+            .as_local()\n+            .and_then(|did| tcx.hir().get_generics(did))\n+            .map_or(def_span, |g| g.span);\n         let generics_span = tcx.hir().span_if_local(trait_m.def_id).map(|sp| {\n             let def_sp = tcx.sess.source_map().guess_head_span(sp);\n-            tcx.hir().get_generics(trait_m.def_id).map_or(def_sp, |g| g.span)\n+            trait_m\n+                .def_id\n+                .as_local()\n+                .and_then(|did| tcx.hir().get_generics(did))\n+                .map_or(def_sp, |g| g.span)\n         });\n \n         tcx.sess.emit_err(LifetimesOrBoundsMismatchOnTrait {"}, {"sha": "c8986aa7f53b04cf456b6e33c638f96723d0938a", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -184,8 +184,6 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // absent. So we report an error that the Drop impl injected a\n     // predicate that is not present on the struct definition.\n \n-    let self_type_hir_id = tcx.hir().local_def_id_to_hir_id(self_type_did);\n-\n     // We can assume the predicates attached to struct/enum definition\n     // hold.\n     let generic_assumptions = tcx.predicates_of(self_type_did);\n@@ -252,7 +250,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         };\n \n         if !assumptions_in_impl_context.iter().copied().any(predicate_matches_closure) {\n-            let item_span = tcx.hir().span(self_type_hir_id);\n+            let item_span = tcx.def_span(self_type_did);\n             let self_descr = tcx.def_kind(self_type_did).descr(self_type_did.to_def_id());\n             struct_span_err!(\n                 tcx.sess,"}, {"sha": "8f9f4e82e845d2b58066c7aa1b101a9154030fd4", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -742,7 +742,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 kind: hir::ImplItemKind::Fn(..),\n                 span: encl_fn_span,\n                 ..\n-            })) = self.tcx.hir().find(encl_item_id)\n+            })) = self.tcx.hir().find_by_def_id(encl_item_id)\n             {\n                 // We are inside a function body, so reporting \"return statement\n                 // outside of function body\" needs an explanation.\n@@ -751,7 +751,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 // If this didn't hold, we would not have to report an error in\n                 // the first place.\n-                assert_ne!(encl_item_id, encl_body_owner_id);\n+                assert_ne!(hir::HirId::make_owner(encl_item_id), encl_body_owner_id);\n \n                 let encl_body_id = self.tcx.hir().body_owned_by(encl_body_owner_id);\n                 let encl_body = self.tcx.hir().body(encl_body_id);"}, {"sha": "d9a597bce8a014ee8ce6a412f6dc707dd95747d1", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -846,7 +846,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn parent_item_span(&self, id: hir::HirId) -> Option<Span> {\n-        let node = self.tcx.hir().get(self.tcx.hir().get_parent_item(id));\n+        let node = self.tcx.hir().get_by_def_id(self.tcx.hir().get_parent_item(id));\n         match node {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })\n             | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, body_id), .. }) => {\n@@ -862,7 +862,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Given a function block's `HirId`, returns its `FnDecl` if it exists, or `None` otherwise.\n     fn get_parent_fn_decl(&self, blk_id: hir::HirId) -> Option<(&'tcx hir::FnDecl<'tcx>, Ident)> {\n-        let parent = self.tcx.hir().get(self.tcx.hir().get_parent_item(blk_id));\n+        let parent = self.tcx.hir().get_by_def_id(self.tcx.hir().get_parent_item(blk_id));\n         self.get_node_fn_decl(parent).map(|(fn_decl, ident, _)| (fn_decl, ident))\n     }\n "}, {"sha": "3a81af03162862f8c8d99024fd92681fd8cb7acb", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -188,8 +188,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     ) -> ty::GenericPredicates<'tcx> {\n         let tcx = self.tcx;\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-        let item_id = tcx.hir().ty_param_owner(hir_id);\n-        let item_def_id = tcx.hir().local_def_id(item_id);\n+        let item_def_id = tcx.hir().ty_param_owner(hir_id);\n         let generics = tcx.generics_of(item_def_id);\n         let index = generics.param_def_id_to_index[&def_id];\n         ty::GenericPredicates {"}, {"sha": "719266ad5a4355b9ff70add27239001e09b93fea", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -511,19 +511,15 @@ struct GeneratorTypes<'tcx> {\n fn get_owner_return_paths<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n-) -> Option<(hir::HirId, ReturnsVisitor<'tcx>)> {\n+) -> Option<(LocalDefId, ReturnsVisitor<'tcx>)> {\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let id = tcx.hir().get_parent_item(hir_id);\n-    tcx.hir()\n-        .find(id)\n-        .map(|n| (id, n))\n-        .and_then(|(hir_id, node)| node.body_id().map(|b| (hir_id, b)))\n-        .map(|(hir_id, body_id)| {\n-            let body = tcx.hir().body(body_id);\n-            let mut visitor = ReturnsVisitor::default();\n-            visitor.visit_body(body);\n-            (hir_id, visitor)\n-        })\n+    let parent_id = tcx.hir().get_parent_item(hir_id);\n+    tcx.hir().find_by_def_id(parent_id).and_then(|node| node.body_id()).map(|body_id| {\n+        let body = tcx.hir().body(body_id);\n+        let mut visitor = ReturnsVisitor::default();\n+        visitor.visit_body(body);\n+        (parent_id, visitor)\n+    })\n }\n \n // Forbid defining intrinsics in Rust code,"}, {"sha": "72eabab301ac7a421ad2d772ab7c50c7b8d4a647", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -972,7 +972,7 @@ fn suggest_constraining_param(\n     if let Some(generics) = param_def_id\n         .as_local()\n         .map(|id| hir.local_def_id_to_hir_id(id))\n-        .and_then(|id| hir.find(hir.get_parent_item(id)))\n+        .and_then(|id| hir.find_by_def_id(hir.get_parent_item(id)))\n         .as_ref()\n         .and_then(|node| node.generics())\n     {"}, {"sha": "c7b7bb7574bdea20677dddafead3a8f4c2fc1758", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -206,7 +206,7 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     check_object_unsafe_self_trait_by_name(tcx, trait_item);\n     check_associated_item(tcx, trait_item.def_id, span, method_sig);\n \n-    let encl_trait_def_id = tcx.hir().get_parent_did(hir_id);\n+    let encl_trait_def_id = tcx.hir().get_parent_item(hir_id);\n     let encl_trait = tcx.hir().expect_item(encl_trait_def_id);\n     let encl_trait_def_id = encl_trait.def_id.to_def_id();\n     let fn_lang_item_name = if Some(encl_trait_def_id) == tcx.lang_items().fn_trait() {\n@@ -668,13 +668,14 @@ fn could_be_self(trait_def_id: LocalDefId, ty: &hir::Ty<'_>) -> bool {\n /// Detect when an object unsafe trait is referring to itself in one of its associated items.\n /// When this is done, suggest using `Self` instead.\n fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem<'_>) {\n-    let (trait_name, trait_def_id) = match tcx.hir().get(tcx.hir().get_parent_item(item.hir_id())) {\n-        hir::Node::Item(item) => match item.kind {\n-            hir::ItemKind::Trait(..) => (item.ident, item.def_id),\n+    let (trait_name, trait_def_id) =\n+        match tcx.hir().get_by_def_id(tcx.hir().get_parent_item(item.hir_id())) {\n+            hir::Node::Item(item) => match item.kind {\n+                hir::ItemKind::Trait(..) => (item.ident, item.def_id),\n+                _ => return,\n+            },\n             _ => return,\n-        },\n-        _ => return,\n-    };\n+        };\n     let mut trait_should_be_self = vec![];\n     match &item.kind {\n         hir::TraitItemKind::Const(ty, _) | hir::TraitItemKind::Type(_, Some(ty))\n@@ -786,9 +787,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                 }\n             };\n \n-            if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n-                .is_some()\n-            {\n+            if traits::search_for_structural_match_violation(param.span, tcx, ty).is_some() {\n                 // We use the same error code in both branches, because this is really the same\n                 // issue: we just special-case the message for type parameters to make it\n                 // clearer."}, {"sha": "85d81cce100f8f08d5d8d3877e734c4c5b6eea45", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -28,7 +28,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind};\n-use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::weak_lang_items;\n use rustc_hir::{GenericParamKind, HirId, Node};\n@@ -435,7 +435,7 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n             match self.node() {\n                 hir::Node::Field(_) | hir::Node::Ctor(_) | hir::Node::Variant(_) => {\n                     let item =\n-                        self.tcx.hir().expect_item(self.tcx.hir().get_parent_did(self.hir_id()));\n+                        self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(self.hir_id()));\n                     match &item.kind {\n                         hir::ItemKind::Enum(_, generics)\n                         | hir::ItemKind::Struct(_, generics)\n@@ -569,13 +569,12 @@ fn type_param_predicates(\n \n     let param_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let param_owner = tcx.hir().ty_param_owner(param_id);\n-    let param_owner_def_id = tcx.hir().local_def_id(param_owner);\n-    let generics = tcx.generics_of(param_owner_def_id);\n+    let generics = tcx.generics_of(param_owner);\n     let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n     let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(param_id));\n \n     // Don't look for bounds where the type parameter isn't in scope.\n-    let parent = if item_def_id == param_owner_def_id.to_def_id() {\n+    let parent = if item_def_id == param_owner.to_def_id() {\n         None\n     } else {\n         tcx.generics_of(item_def_id).parent\n@@ -1396,13 +1395,12 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n         | Node::Ctor(..)\n         | Node::Field(_) => {\n             let parent_id = tcx.hir().get_parent_item(hir_id);\n-            Some(tcx.hir().local_def_id(parent_id).to_def_id())\n+            Some(parent_id.to_def_id())\n         }\n         // FIXME(#43408) always enable this once `lazy_normalization` is\n         // stable enough and does not need a feature gate anymore.\n         Node::AnonConst(_) => {\n-            let parent_id = tcx.hir().get_parent_item(hir_id);\n-            let parent_def_id = tcx.hir().local_def_id(parent_id);\n+            let parent_def_id = tcx.hir().get_parent_item(hir_id);\n \n             let mut in_param_ty = false;\n             for (_parent, node) in tcx.hir().parent_iter(hir_id) {\n@@ -1512,11 +1510,11 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n             }) => Some(fn_def_id.to_def_id()),\n             ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n                 let parent_id = tcx.hir().get_parent_item(hir_id);\n-                assert!(parent_id != hir_id && parent_id != CRATE_HIR_ID);\n+                assert_ne!(parent_id, CRATE_DEF_ID);\n                 debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n                 // Opaque types are always nested within another item, and\n                 // inherit the generics of the item.\n-                Some(tcx.hir().local_def_id(parent_id).to_def_id())\n+                Some(parent_id.to_def_id())\n             }\n             _ => None,\n         },\n@@ -1861,7 +1859,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n         }\n \n         Ctor(data) | Variant(hir::Variant { data, .. }) if data.ctor_hir_id().is_some() => {\n-            let ty = tcx.type_of(tcx.hir().get_parent_did(hir_id).to_def_id());\n+            let ty = tcx.type_of(tcx.hir().get_parent_item(hir_id));\n             let inputs =\n                 data.fields().iter().map(|f| tcx.type_of(tcx.hir().local_def_id(f.hir_id)));\n             ty::Binder::dummy(tcx.mk_fn_sig(\n@@ -2431,8 +2429,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                 //        parent of generics returned by `generics_of`\n                 //\n                 // In the above code we want the anon const to have predicates in its param env for `T: Trait`\n-                let item_id = tcx.hir().get_parent_item(hir_id);\n-                let item_def_id = tcx.hir().local_def_id(item_id).to_def_id();\n+                let item_def_id = tcx.hir().get_parent_item(hir_id);\n                 // In the above code example we would be calling `explicit_predicates_of(Foo)` here\n                 return tcx.explicit_predicates_of(item_def_id);\n             }\n@@ -3230,7 +3227,7 @@ fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span:\n     let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n     let node = tcx.hir().get(hir_id);\n     if let Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) = node {\n-        let parent_id = tcx.hir().get_parent_did(hir_id);\n+        let parent_id = tcx.hir().get_parent_item(hir_id);\n         let parent_item = tcx.hir().expect_item(parent_id);\n         if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = parent_item.kind {\n             tcx.sess"}, {"sha": "a216e8c2f883cf8b3b4a911675f57517f4b97594", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -348,7 +348,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 }\n             }\n             ImplItemKind::TyAlias(ty) => {\n-                if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id).to_def_id()).is_none() {\n+                if tcx.impl_trait_ref(tcx.hir().get_parent_item(hir_id)).is_none() {\n                     check_feature_inherent_assoc_ty(tcx, item.span);\n                 }\n \n@@ -458,7 +458,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n         Node::Ctor(&ref def) | Node::Variant(Variant { data: ref def, .. }) => match *def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n-                tcx.type_of(tcx.hir().get_parent_did(hir_id).to_def_id())\n+                tcx.type_of(tcx.hir().get_parent_item(hir_id))\n             }\n             VariantData::Tuple(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n@@ -507,7 +507,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 }\n \n                 Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => tcx\n-                    .adt_def(tcx.hir().get_parent_did(hir_id).to_def_id())\n+                    .adt_def(tcx.hir().get_parent_item(hir_id))\n                     .repr\n                     .discr_type()\n                     .to_ty(tcx),"}, {"sha": "6a9f154844a5752ab32cd328cbab24f6ee588dde", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -543,8 +543,7 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n-    let env_node_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n-    let env_def_id = tcx.hir().local_def_id(env_node_id);\n+    let env_def_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n     <dyn AstConv<'_>>::ast_ty_to_ty(&item_cx, hir_ty)\n }\n@@ -557,8 +556,7 @@ pub fn hir_trait_to_predicates<'tcx>(\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n-    let env_hir_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n-    let env_def_id = tcx.hir().local_def_id(env_hir_id);\n+    let env_def_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n     let mut bounds = Bounds::default();\n     let _ = <dyn AstConv<'_>>::instantiate_poly_trait_ref("}, {"sha": "78a9cb33fbac5e95504ef1176165abc19ddf3812", "filename": "compiler/rustc_typeck/src/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -35,8 +35,7 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n             //        parent of generics returned by `generics_of`\n             //\n             // In the above code we want the anon const to have predicates in its param env for `'b: 'a`\n-            let item_id = tcx.hir().get_parent_item(id);\n-            let item_def_id = tcx.hir().local_def_id(item_id).to_def_id();\n+            let item_def_id = tcx.hir().get_parent_item(id);\n             // In the above code example we would be calling `inferred_outlives_of(Foo)` here\n             return tcx.inferred_outlives_of(item_def_id);\n         }"}, {"sha": "a5bc70a74ae92b4163122d947a03cb21ec61cdce", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -1004,7 +1004,7 @@ impl Clean<Item> for hir::ImplItem<'_> {\n \n             let what_rustc_thinks =\n                 Item::from_def_id_and_parts(local_did, Some(self.ident.name), inner, cx);\n-            let parent_item = cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_did(self.hir_id()));\n+            let parent_item = cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(self.hir_id()));\n             if let hir::ItemKind::Impl(impl_) = &parent_item.kind {\n                 if impl_.of_trait.is_some() {\n                     // Trait impl items always inherit the impl's visibility --"}, {"sha": "3282309b9df3e04dbea36d3427119c0610f16c0c", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -173,7 +173,9 @@ where\n \n         // If the enclosing item has a span coming from a proc macro, then we also don't want to include\n         // the example.\n-        let enclosing_item_span = tcx.hir().span_with_body(tcx.hir().get_parent_item(ex.hir_id));\n+        let enclosing_item_span = tcx\n+            .hir()\n+            .span_with_body(tcx.hir().local_def_id_to_hir_id(tcx.hir().get_parent_item(ex.hir_id)));\n         if enclosing_item_span.from_expansion() {\n             trace!(\"Rejecting expr ({:?}) from macro item: {:?}\", span, enclosing_item_span);\n             return;"}, {"sha": "ee668501ae78b859dbe461d7e5e483b9c8dd3759", "filename": "src/test/ui-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingAllowedAttrPass {\n     ) {\n         let item = match cx.tcx.hir().get(id) {\n             Node::Item(item) => item,\n-            _ => cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(id).expect_owner()),\n+            _ => cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(id)),\n         };\n \n         let allowed = |attr| pprust::attribute_to_string(attr).contains(\"allowed_attr\");"}, {"sha": "5f95333a77407f7f65bc80465e2664f1a5a053ec", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -77,7 +77,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n         }\n \n         let parent_id = cx.tcx.hir().get_parent_item(hir_id);\n-        let parent_node = cx.tcx.hir().find(parent_id);\n+        let parent_node = cx.tcx.hir().find_by_def_id(parent_id);\n \n         let mut trait_self_ty = None;\n         if let Some(Node::Item(item)) = parent_node {"}, {"sha": "cbf52d19334c0f79a15a7fdc4b876dcca6d973b5", "filename": "src/tools/clippy/clippy_lints/src/exit.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexit.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -34,11 +34,10 @@ impl<'tcx> LateLintPass<'tcx> for Exit {\n             if let Some(def_id) = cx.qpath_res(path, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::EXIT);\n             let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n-            if let Some(Node::Item(Item{kind: ItemKind::Fn(..), ..})) = cx.tcx.hir().find(parent);\n+            if let Some(Node::Item(Item{kind: ItemKind::Fn(..), ..})) = cx.tcx.hir().find_by_def_id(parent);\n             // If the next item up is a function we check if it is an entry point\n             // and only then emit a linter warning\n-            let def_id = cx.tcx.hir().local_def_id(parent);\n-            if !is_entrypoint_fn(cx, def_id.to_def_id());\n+            if !is_entrypoint_fn(cx, parent.to_def_id());\n             then {\n                 span_lint(cx, EXIT, e.span, \"usage of `process::exit`\");\n             }"}, {"sha": "bf59103e3f4d2bce903907fc9c41653eff1cf155", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -48,7 +48,7 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n         let attr = must_use_attr(attrs);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.hir_id()).is_none() {\n+        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.def_id).is_none() {\n             check_must_use_candidate(\n                 cx,\n                 sig.decl,"}, {"sha": "120fcb2619c7c66dd59dd58bdb3b7c1ea8b30170", "filename": "src/tools/clippy/clippy_lints/src/functions/result_unit_err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -27,7 +27,7 @@ pub(super) fn check_impl_item(cx: &LateContext<'_>, item: &hir::ImplItem<'_>) {\n     if let hir::ImplItemKind::Fn(ref sig, _) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-        if is_public && trait_ref_of_method(cx, item.hir_id()).is_none() {\n+        if is_public && trait_ref_of_method(cx, item.def_id).is_none() {\n             check_result_unit_err(cx, sig.decl, item.span, fn_header_span);\n         }\n     }"}, {"sha": "55c04a1186fc3376fce1d70124b972727d9e0163", "filename": "src/tools/clippy/clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -116,7 +116,7 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n             if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id()), sym::String);\n \n             // Filters instances of to_string which are required by a trait\n-            if trait_ref_of_method(cx, impl_item.hir_id()).is_none();\n+            if trait_ref_of_method(cx, impl_item.def_id).is_none();\n \n             then {\n                 show_lint(cx, impl_item);"}, {"sha": "6dd7b22ff94b5f80c9d5e49d7210913dedcd6c90", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -91,7 +91,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Fn(ref sig, id) = item.kind {\n-            let report_extra_lifetimes = trait_ref_of_method(cx, item.hir_id()).is_none();\n+            let report_extra_lifetimes = trait_ref_of_method(cx, item.def_id).is_none();\n             check_fn_inner(\n                 cx,\n                 sig.decl,"}, {"sha": "33abd2a72d8809384618191316b2d4fb86c8b5c3", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -58,8 +58,7 @@ pub(super) fn check<'tcx>(\n \n                 // ensure that the indexed variable was declared before the loop, see #601\n                 if let Some(indexed_extent) = indexed_extent {\n-                    let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n-                    let parent_def_id = cx.tcx.hir().local_def_id(parent_id);\n+                    let parent_def_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n                     let region_scope_tree = cx.tcx.region_scope_tree(parent_def_id);\n                     let pat_extent = region_scope_tree.var_scope(pat.hir_id.local_id);\n                     if region_scope_tree.is_subscope_of(indexed_extent, pat_extent) {\n@@ -263,8 +262,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                 let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n                 match res {\n                     Res::Local(hir_id) => {\n-                        let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n-                        let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n+                        let parent_def_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n                         let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n                         if index_used_directly {\n                             self.indexed_directly.insert("}, {"sha": "cd038ecd5ce1ec4fcb2507ebc763c0b65b40f601", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -2053,7 +2053,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             return;\n         }\n         let name = impl_item.ident.name.as_str();\n-        let parent = cx.tcx.hir().get_parent_did(impl_item.hir_id());\n+        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n         let item = cx.tcx.hir().expect_item(parent);\n         let self_ty = cx.tcx.type_of(item.def_id);\n "}, {"sha": "77849e1800f6bf9f22aff0d916f55592d55fc42e", "filename": "src/tools/clippy/clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -121,7 +121,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n                 }\n             },\n             FnKind::Method(_, sig, ..) => {\n-                if trait_ref_of_method(cx, hir_id).is_some()\n+                if trait_ref_of_method(cx, def_id).is_some()\n                     || already_const(sig.header)\n                     || method_accepts_dropable(cx, sig.decl.inputs)\n                 {"}, {"sha": "1bdd805f658549801dec79a6bfd63d1d14e6e66f", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -89,7 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'tcx>) {\n         if let hir::ImplItemKind::Fn(ref sig, ..) = item.kind {\n-            if trait_ref_of_method(cx, item.hir_id()).is_none() {\n+            if trait_ref_of_method(cx, item.def_id).is_none() {\n                 check_sig(cx, item.hir_id(), sig.decl);\n             }\n         }"}, {"sha": "aec95530bba67ea3b3d2faaeaf93cec7b9612c44", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -101,7 +101,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             if sig.decl.inputs.is_empty();\n                             if name == sym::new;\n                             if cx.access_levels.is_reachable(impl_item.def_id);\n-                            let self_def_id = cx.tcx.hir().local_def_id(cx.tcx.hir().get_parent_item(id));\n+                            let self_def_id = cx.tcx.hir().get_parent_item(id);\n                             let self_ty = cx.tcx.type_of(self_def_id);\n                             if TyS::same_type(self_ty, return_ty(cx, id));\n                             if let Some(default_trait_id) = cx.tcx.get_diagnostic_item(sym::Default);"}, {"sha": "21ac6548b0179cafa486608e4f7153d04e137080", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -280,7 +280,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Const(hir_ty, body_id) = &impl_item.kind {\n-            let item_def_id = cx.tcx.hir().get_parent_did(impl_item.hir_id());\n+            let item_def_id = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n             let item = cx.tcx.hir().expect_item(item_def_id);\n \n             match &item.kind {"}, {"sha": "63de117a6f1dec08737ffb022427062517570395", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -164,7 +164,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Fn(ref sig, body_id) = item.kind {\n             let parent_item = cx.tcx.hir().get_parent_item(item.hir_id());\n-            if let Some(Node::Item(it)) = cx.tcx.hir().find(parent_item) {\n+            if let Some(Node::Item(it)) = cx.tcx.hir().find_by_def_id(parent_item) {\n                 if let ItemKind::Impl(Impl { of_trait: Some(_), .. }) = it.kind {\n                     return; // ignore trait impls\n                 }"}, {"sha": "9673d975cb4d3cc2becb0f501e3244bc2516e49c", "filename": "src/tools/clippy/clippy_lints/src/self_named_constructors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> LateLintPass<'tcx> for SelfNamedConstructors {\n             _ => return,\n         }\n \n-        let parent = cx.tcx.hir().get_parent_did(impl_item.hir_id());\n+        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n         let item = cx.tcx.hir().expect_item(parent);\n         let self_ty = cx.tcx.type_of(item.def_id);\n         let ret_ty = return_ty(cx, impl_item.hir_id());"}, {"sha": "92494159deeb53029c88592e4d6a7ffe93b24c98", "filename": "src/tools/clippy/clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -66,7 +66,7 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n             // Check for more than one binary operation in the implemented function\n             // Linting when multiple operations are involved can result in false positives\n             let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n-            if let hir::Node::ImplItem(impl_item) = cx.tcx.hir().get(parent_fn);\n+            if let hir::Node::ImplItem(impl_item) = cx.tcx.hir().get_by_def_id(parent_fn);\n             if let hir::ImplItemKind::Fn(_, body_id) = impl_item.kind;\n             let body = cx.tcx.hir().body(body_id);\n             let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);"}, {"sha": "67cc8913318962f2f849ab1441a166dd7b9d9eaa", "filename": "src/tools/clippy/clippy_lints/src/types/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -312,12 +312,12 @@ impl_lint_pass!(Types => [BOX_COLLECTION, VEC_BOX, OPTION_OPTION, LINKEDLIST, BO\n \n impl<'tcx> LateLintPass<'tcx> for Types {\n     fn check_fn(&mut self, cx: &LateContext<'_>, _: FnKind<'_>, decl: &FnDecl<'_>, _: &Body<'_>, _: Span, id: HirId) {\n-        let is_in_trait_impl = if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(id))\n-        {\n-            matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n-        } else {\n-            false\n-        };\n+        let is_in_trait_impl =\n+            if let Some(hir::Node::Item(item)) = cx.tcx.hir().find_by_def_id(cx.tcx.hir().get_parent_item(id)) {\n+                matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n+            } else {\n+                false\n+            };\n \n         let is_exported = cx.access_levels.is_exported(cx.tcx.hir().local_def_id(id));\n \n@@ -353,7 +353,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n         match item.kind {\n             ImplItemKind::Const(ty, _) => {\n                 let is_in_trait_impl = if let Some(hir::Node::Item(item)) =\n-                    cx.tcx.hir().find(cx.tcx.hir().get_parent_item(item.hir_id()))\n+                    cx.tcx.hir().find_by_def_id(cx.tcx.hir().get_parent_item(item.hir_id()))\n                 {\n                     matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n                 } else {"}, {"sha": "fd9d5b52e501f318199e5fa94ad9cf55dd79cad6", "filename": "src/tools/clippy/clippy_lints/src/unused_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n         if impl_item.span.from_expansion() {\n             return;\n         }\n-        let parent = cx.tcx.hir().get_parent_did(impl_item.hir_id());\n+        let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n         let parent_item = cx.tcx.hir().expect_item(parent);\n         let assoc_item = cx.tcx.associated_item(impl_item.def_id);\n         if_chain! {"}, {"sha": "70b0560e676044eef19feef0cff8f9733f5394d8", "filename": "src/tools/clippy/clippy_lints/src/zero_sized_map_values.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fzero_sized_map_values.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -69,7 +69,11 @@ impl LateLintPass<'_> for ZeroSizedMapValues {\n \n fn in_trait_impl(cx: &LateContext<'_>, hir_id: HirId) -> bool {\n     let parent_id = cx.tcx.hir().get_parent_item(hir_id);\n-    if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(parent_id)) {\n+    let second_parent_id = cx\n+        .tcx\n+        .hir()\n+        .get_parent_item(cx.tcx.hir().local_def_id_to_hir_id(parent_id));\n+    if let Some(Node::Item(item)) = cx.tcx.hir().find_by_def_id(second_parent_id) {\n         if let ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = item.kind {\n             return true;\n         }"}, {"sha": "e55817f13eb1a1c0c67a655f7aee1371d7f128e9", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d61cd2eda81b595862635914bd0224402a4a26/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=f9d61cd2eda81b595862635914bd0224402a4a26", "patch": "@@ -70,7 +70,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::unhash::UnhashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::hir_id::{HirIdMap, HirIdSet};\n use rustc_hir::intravisit::{walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -90,7 +90,6 @@ use rustc_middle::ty::binding::BindingMode;\n use rustc_middle::ty::{layout::IntegerExt, BorrowKind, DefIdTree, Ty, TyCtxt, TypeAndMut, TypeFoldable, UpvarCapture};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n-use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::sym;\n@@ -216,7 +215,7 @@ pub fn find_binding_init<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<\n /// ```\n pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n     let parent_id = cx.tcx.hir().get_parent_item(id);\n-    match cx.tcx.hir().get(parent_id) {\n+    match cx.tcx.hir().get_by_def_id(parent_id) {\n         Node::Item(&Item {\n             kind: ItemKind::Const(..) | ItemKind::Static(..),\n             ..\n@@ -607,12 +606,13 @@ pub fn get_trait_def_id(cx: &LateContext<'_>, path: &[&str]) -> Option<DefId> {\n ///     }\n /// }\n /// ```\n-pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx TraitRef<'tcx>> {\n+pub fn trait_ref_of_method<'tcx>(cx: &LateContext<'tcx>, def_id: LocalDefId) -> Option<&'tcx TraitRef<'tcx>> {\n     // Get the implemented trait for the current function\n+    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n     let parent_impl = cx.tcx.hir().get_parent_item(hir_id);\n     if_chain! {\n-        if parent_impl != hir::CRATE_HIR_ID;\n-        if let hir::Node::Item(item) = cx.tcx.hir().get(parent_impl);\n+        if parent_impl != CRATE_DEF_ID;\n+        if let hir::Node::Item(item) = cx.tcx.hir().get_by_def_id(parent_impl);\n         if let hir::ItemKind::Impl(impl_) = &item.kind;\n         then { return impl_.of_trait.as_ref(); }\n     }\n@@ -1122,14 +1122,13 @@ pub fn is_entrypoint_fn(cx: &LateContext<'_>, def_id: DefId) -> bool {\n /// Returns `true` if the expression is in the program's `#[panic_handler]`.\n pub fn is_in_panic_handler(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n     let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n-    let def_id = cx.tcx.hir().local_def_id(parent).to_def_id();\n-    Some(def_id) == cx.tcx.lang_items().panic_impl()\n+    Some(parent.to_def_id()) == cx.tcx.lang_items().panic_impl()\n }\n \n /// Gets the name of the item the expression is in, if available.\n pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n     let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n-    match cx.tcx.hir().find(parent_id) {\n+    match cx.tcx.hir().find_by_def_id(parent_id) {\n         Some(\n             Node::Item(Item { ident, .. })\n             | Node::TraitItem(TraitItem { ident, .. })\n@@ -1639,7 +1638,7 @@ pub fn any_parent_has_attr(tcx: TyCtxt<'_>, node: HirId, symbol: Symbol) -> bool\n             return true;\n         }\n         prev_enclosing_node = Some(enclosing_node);\n-        enclosing_node = map.get_parent_item(enclosing_node);\n+        enclosing_node = map.local_def_id_to_hir_id(map.get_parent_item(enclosing_node));\n     }\n \n     false"}]}