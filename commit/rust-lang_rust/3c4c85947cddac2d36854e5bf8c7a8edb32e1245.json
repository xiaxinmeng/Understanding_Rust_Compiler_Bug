{"sha": "3c4c85947cddac2d36854e5bf8c7a8edb32e1245", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNGM4NTk0N2NkZGFjMmQzNjg1NGU1YmY4YzdhOGVkYjMyZTEyNDU=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-09-21T02:16:28Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-04T21:53:18Z"}, "message": "Rename Parser::last_token_kind as prev_token_kind.\n\nLikewise, rename LastTokenKind as PrevTokenKind.\n\nThis is a [breaking-change] for libsyntax.", "tree": {"sha": "8ede118e6852731c133fcab9b81b42d294e406a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ede118e6852731c133fcab9b81b42d294e406a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c4c85947cddac2d36854e5bf8c7a8edb32e1245", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c4c85947cddac2d36854e5bf8c7a8edb32e1245", "html_url": "https://github.com/rust-lang/rust/commit/3c4c85947cddac2d36854e5bf8c7a8edb32e1245", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c4c85947cddac2d36854e5bf8c7a8edb32e1245/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2747923c272a355dbb6265586a884652e26b0ec7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2747923c272a355dbb6265586a884652e26b0ec7", "html_url": "https://github.com/rust-lang/rust/commit/2747923c272a355dbb6265586a884652e26b0ec7"}], "stats": {"total": 34, "additions": 17, "deletions": 17}, "files": [{"sha": "61268d457ce44a6658c0f46cdadc5a8a7c53d166", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3c4c85947cddac2d36854e5bf8c7a8edb32e1245/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4c85947cddac2d36854e5bf8c7a8edb32e1245/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3c4c85947cddac2d36854e5bf8c7a8edb32e1245", "patch": "@@ -238,7 +238,7 @@ fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n }\n \n #[derive(PartialEq)]\n-enum LastTokenKind {\n+enum PrevTokenKind {\n     DocComment,\n     Comma,\n     Interpolated,\n@@ -258,7 +258,7 @@ pub struct Parser<'a> {\n     pub prev_span: Span,\n     pub cfg: CrateConfig,\n     /// the previous token kind\n-    last_token_kind: LastTokenKind,\n+    prev_token_kind: PrevTokenKind,\n     pub buffer: [TokenAndSpan; 4],\n     pub buffer_start: isize,\n     pub buffer_end: isize,\n@@ -369,7 +369,7 @@ impl<'a> Parser<'a> {\n             token: tok0.tok,\n             span: span,\n             prev_span: span,\n-            last_token_kind: LastTokenKind::Other,\n+            prev_token_kind: PrevTokenKind::Other,\n             buffer: [\n                 placeholder.clone(),\n                 placeholder.clone(),\n@@ -504,7 +504,7 @@ impl<'a> Parser<'a> {\n                                  expr: PResult<'a, P<Expr>>)\n                                  -> PResult<'a, (Span, P<Expr>)> {\n         expr.map(|e| {\n-            if self.last_token_kind == LastTokenKind::Interpolated {\n+            if self.prev_token_kind == PrevTokenKind::Interpolated {\n                 (self.prev_span, e)\n             } else {\n                 (e.span, e)\n@@ -524,7 +524,7 @@ impl<'a> Parser<'a> {\n                 self.bug(\"ident interpolation not converted to real token\");\n             }\n             _ => {\n-                Err(if self.last_token_kind == LastTokenKind::DocComment {\n+                Err(if self.prev_token_kind == PrevTokenKind::DocComment {\n                     self.span_fatal_help(self.prev_span,\n                         \"found a documentation comment that doesn't document anything\",\n                         \"doc comments must come before what they document, maybe a comment was \\\n@@ -922,20 +922,20 @@ impl<'a> Parser<'a> {\n \n     /// Advance the parser by one token\n     pub fn bump(&mut self) {\n-        if self.last_token_kind == LastTokenKind::Eof {\n+        if self.prev_token_kind == PrevTokenKind::Eof {\n             // Bumping after EOF is a bad sign, usually an infinite loop.\n             self.bug(\"attempted to bump the parser past EOF (may be stuck in a loop)\");\n         }\n \n         self.prev_span = self.span;\n \n         // Record last token kind for possible error recovery.\n-        self.last_token_kind = match self.token {\n-            token::DocComment(..) => LastTokenKind::DocComment,\n-            token::Comma => LastTokenKind::Comma,\n-            token::Interpolated(..) => LastTokenKind::Interpolated,\n-            token::Eof => LastTokenKind::Eof,\n-            _ => LastTokenKind::Other,\n+        self.prev_token_kind = match self.token {\n+            token::DocComment(..) => PrevTokenKind::DocComment,\n+            token::Comma => PrevTokenKind::Comma,\n+            token::Interpolated(..) => PrevTokenKind::Interpolated,\n+            token::Eof => PrevTokenKind::Eof,\n+            _ => PrevTokenKind::Other,\n         };\n \n         let next = if self.buffer_start == self.buffer_end {\n@@ -976,8 +976,8 @@ impl<'a> Parser<'a> {\n         self.prev_span = mk_sp(self.span.lo, lo);\n         // It would be incorrect to record the kind of the current token, but\n         // fortunately for tokens currently using `bump_with`, the\n-        // last_token_kind will be of no use anyway.\n-        self.last_token_kind = LastTokenKind::Other;\n+        // prev_token_kind will be of no use anyway.\n+        self.prev_token_kind = PrevTokenKind::Other;\n         self.span = mk_sp(lo, hi);\n         self.token = next;\n         self.expected_tokens.clear();\n@@ -2950,7 +2950,7 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.push(TokenType::Operator);\n         while let Some(op) = AssocOp::from_token(&self.token) {\n \n-            let lhs_span = if self.last_token_kind == LastTokenKind::Interpolated {\n+            let lhs_span = if self.prev_token_kind == PrevTokenKind::Interpolated {\n                 self.prev_span\n             } else {\n                 lhs.span\n@@ -4019,7 +4019,7 @@ impl<'a> Parser<'a> {\n                 None => {\n                     let unused_attrs = |attrs: &[_], s: &mut Self| {\n                         if attrs.len() > 0 {\n-                            if s.last_token_kind == LastTokenKind::DocComment {\n+                            if s.prev_token_kind == PrevTokenKind::DocComment {\n                                 s.span_err_help(s.prev_span,\n                                     \"found a documentation comment that doesn't document anything\",\n                                     \"doc comments must come before what they document, maybe a \\\n@@ -4338,7 +4338,7 @@ impl<'a> Parser<'a> {\n \n         let missing_comma = !lifetimes.is_empty() &&\n                             !self.token.is_like_gt() &&\n-                            self.last_token_kind != LastTokenKind::Comma;\n+                            self.prev_token_kind != PrevTokenKind::Comma;\n \n         if missing_comma {\n "}]}