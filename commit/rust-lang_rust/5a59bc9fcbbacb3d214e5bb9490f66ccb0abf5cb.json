{"sha": "5a59bc9fcbbacb3d214e5bb9490f66ccb0abf5cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNTliYzlmY2JiYWNiM2QyMTRlNWJiOTQ5MGY2NmNjYjBhYmY1Y2I=", "commit": {"author": {"name": "Jeremy Kolb", "email": "kjeremy@gmail.com", "date": "2019-10-27T23:12:21Z"}, "committer": {"name": "Jeremy Kolb", "email": "kjeremy@gmail.com", "date": "2019-10-28T12:32:22Z"}, "message": "WIP: Expand signature help\n\nThis is hacky but works for tuple structs. Proof of concept.", "tree": {"sha": "ed2cae97531aaff1ddbd509858358aca33e46635", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed2cae97531aaff1ddbd509858358aca33e46635"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a59bc9fcbbacb3d214e5bb9490f66ccb0abf5cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a59bc9fcbbacb3d214e5bb9490f66ccb0abf5cb", "html_url": "https://github.com/rust-lang/rust/commit/5a59bc9fcbbacb3d214e5bb9490f66ccb0abf5cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a59bc9fcbbacb3d214e5bb9490f66ccb0abf5cb/comments", "author": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02828520a75f686d044cb9767572ea49e93c4828", "url": "https://api.github.com/repos/rust-lang/rust/commits/02828520a75f686d044cb9767572ea49e93c4828", "html_url": "https://github.com/rust-lang/rust/commit/02828520a75f686d044cb9767572ea49e93c4828"}], "stats": {"total": 68, "additions": 60, "deletions": 8}, "files": [{"sha": "dfd6e69c51643ab32ba1c2e90f0c41aba60c804d", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5a59bc9fcbbacb3d214e5bb9490f66ccb0abf5cb/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59bc9fcbbacb3d214e5bb9490f66ccb0abf5cb/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=5a59bc9fcbbacb3d214e5bb9490f66ccb0abf5cb", "patch": "@@ -20,24 +20,27 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     let name_ref = calling_node.name_ref()?;\n \n     let analyzer = hir::SourceAnalyzer::new(db, position.file_id, name_ref.syntax(), None);\n-    let function = match &calling_node {\n+    let (mut call_info, has_self) = match &calling_node {\n         FnCallNode::CallExpr(expr) => {\n             //FIXME: apply subst\n             let (callable_def, _subst) = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n             match callable_def {\n-                hir::CallableDef::Function(it) => it,\n+                hir::CallableDef::Function(it) => {\n+                    (CallInfo::with_fn(db, it), it.data(db).has_self_param())\n+                }\n+                hir::CallableDef::Struct(it) => (CallInfo::with_struct(db, it), false),\n                 //FIXME: handle other callables\n                 _ => return None,\n             }\n         }\n-        FnCallNode::MethodCallExpr(expr) => analyzer.resolve_method_call(&expr)?,\n+        FnCallNode::MethodCallExpr(expr) => {\n+            let function = analyzer.resolve_method_call(&expr)?;\n+            (CallInfo::with_fn(db, function), function.data(db).has_self_param())\n+        }\n     };\n \n-    let mut call_info = CallInfo::new(db, function);\n-\n     // If we have a calling expression let's find which argument we are on\n     let num_params = call_info.parameters().len();\n-    let has_self = function.data(db).has_self_param();\n \n     if num_params == 1 {\n         if !has_self {\n@@ -115,12 +118,18 @@ impl FnCallNode {\n }\n \n impl CallInfo {\n-    fn new(db: &RootDatabase, function: hir::Function) -> Self {\n+    fn with_fn(db: &RootDatabase, function: hir::Function) -> Self {\n         let signature = FunctionSignature::from_hir(db, function);\n \n         CallInfo { signature, active_parameter: None }\n     }\n \n+    fn with_struct(db: &RootDatabase, st: hir::Struct) -> Self {\n+        let signature = FunctionSignature::from_struct(db, st);\n+\n+        CallInfo { signature, active_parameter: None }\n+    }\n+\n     fn parameters(&self) -> &[String] {\n         &self.signature.parameters\n     }\n@@ -462,4 +471,20 @@ fn main() {\n         assert_eq!(info.active_parameter, Some(1));\n         assert_eq!(info.label(), \"fn bar(&self, _: u32)\");\n     }\n+    \n+    fn works_for_tuple_structs() {\n+        let info = call_info(\n+            r#\"\n+/// A cool tuple struct\n+struct TS(String, i32);\n+fn main() {\n+    let s = TS(\"\".into(), <|>);\n+}\"#,\n+        );\n+\n+        //assert_eq!(info.label(), \"struct TS(String, i32)\");\n+        assert_eq!(info.label(), \"fn TS(0: {unknown}, 1: i32) -> TS\");\n+        assert_eq!(info.doc().map(|it| it.into()), Some(\"A cool tuple struct\".to_string()));\n+        assert_eq!(info.active_parameter, Some(1));\n+    }\n }"}, {"sha": "0697a0727dfe5250b6e396d473374d0fc0f06710", "filename": "crates/ra_ide_api/src/display/function_signature.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5a59bc9fcbbacb3d214e5bb9490f66ccb0abf5cb/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a59bc9fcbbacb3d214e5bb9490f66ccb0abf5cb/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=5a59bc9fcbbacb3d214e5bb9490f66ccb0abf5cb", "patch": "@@ -2,7 +2,7 @@\n \n use std::fmt::{self, Display};\n \n-use hir::{Docs, Documentation, HasSource};\n+use hir::{Docs, Documentation, HasSource, HirDisplay};\n use join_to_string::join;\n use ra_syntax::ast::{self, AstNode, NameOwner, VisibilityOwner};\n use std::convert::From;\n@@ -42,6 +42,33 @@ impl FunctionSignature {\n         let ast_node = function.source(db).ast;\n         FunctionSignature::from(&ast_node).with_doc_opt(doc)\n     }\n+\n+    pub(crate) fn from_struct(db: &db::RootDatabase, st: hir::Struct) -> Self {\n+        let doc = st.docs(db);\n+\n+        let node: ast::StructDef = st.source(db).ast;\n+\n+        let params = st\n+            .fields(db)\n+            .into_iter()\n+            .map(|field: hir::StructField| {\n+                let name = field.name(db);\n+                let ty = field.ty(db);\n+                format!(\"{}: {}\", name, ty.display(db))\n+            })\n+            .collect();\n+\n+        FunctionSignature {\n+            visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n+            name: node.name().map(|n| n.text().to_string()),\n+            ret_type: node.name().map(|n| n.text().to_string()),\n+            parameters: /*param_list(node)*/ params,\n+            generic_parameters: generic_parameters(&node),\n+            where_predicates: where_predicates(&node),\n+            doc: None,\n+        }\n+        .with_doc_opt(doc)\n+    }\n }\n \n impl From<&'_ ast::FnDef> for FunctionSignature {"}]}