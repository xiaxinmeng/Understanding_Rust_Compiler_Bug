{"sha": "7b074d3ac7118a3f30c1f8782f15bfb081fbcaba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMDc0ZDNhYzcxMThhM2YzMGMxZjg3ODJmMTViZmIwODFmYmNhYmE=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-11T15:02:04Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2015-08-11T15:02:04Z"}, "message": "Remove tabs and trailing whitespace from lib and misc.", "tree": {"sha": "86f32c59d1e6c37d5a75d1c2bbd3cec1cfe03e60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86f32c59d1e6c37d5a75d1c2bbd3cec1cfe03e60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b074d3ac7118a3f30c1f8782f15bfb081fbcaba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b074d3ac7118a3f30c1f8782f15bfb081fbcaba", "html_url": "https://github.com/rust-lang/rust/commit/7b074d3ac7118a3f30c1f8782f15bfb081fbcaba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b074d3ac7118a3f30c1f8782f15bfb081fbcaba/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50ebdaa79d944514a6260b28526142908047053a", "url": "https://api.github.com/repos/rust-lang/rust/commits/50ebdaa79d944514a6260b28526142908047053a", "html_url": "https://github.com/rust-lang/rust/commit/50ebdaa79d944514a6260b28526142908047053a"}], "stats": {"total": 92, "additions": 46, "deletions": 46}, "files": [{"sha": "54f3bb11d262ca97c295f1350db4675a19a8295a", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b074d3ac7118a3f30c1f8782f15bfb081fbcaba/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b074d3ac7118a3f30c1f8782f15bfb081fbcaba/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=7b074d3ac7118a3f30c1f8782f15bfb081fbcaba", "patch": "@@ -53,11 +53,11 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_pass(box collapsible_if::CollapsibleIf as LintPassObject);\n     reg.register_lint_pass(box unicode::Unicode as LintPassObject);\n     reg.register_lint_pass(box strings::StringAdd as LintPassObject);\n-    \n+\n     reg.register_lint_group(\"clippy\", vec![types::BOX_VEC, types::LINKEDLIST,\n                                            misc::SINGLE_MATCH, misc::STR_TO_STRING,\n                                            misc::TOPLEVEL_REF_ARG, eq_op::EQ_OP,\n-                                           bit_mask::BAD_BIT_MASK, \n+                                           bit_mask::BAD_BIT_MASK,\n                                            bit_mask::INEFFECTIVE_BIT_MASK,\n                                            ptr_arg::PTR_ARG,\n                                            needless_bool::NEEDLESS_BOOL,"}, {"sha": "ff0594b2b5a161f1969a97e514cae91b5dcffcb2", "filename": "src/misc.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7b074d3ac7118a3f30c1f8782f15bfb081fbcaba/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b074d3ac7118a3f30c1f8782f15bfb081fbcaba/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=7b074d3ac7118a3f30c1f8782f15bfb081fbcaba", "patch": "@@ -41,7 +41,7 @@ impl LintPass for MiscPass {\n                     }\n                     // In some cases, an exhaustive match is preferred to catch situations when\n                     // an enum is extended. So we only consider cases where a `_` wildcard is used\n-                    if arms[1].pats[0].node == PatWild(PatWildSingle) && \n+                    if arms[1].pats[0].node == PatWild(PatWildSingle) &&\n                             arms[0].pats.len() == 1 {\n                         span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n                               \"You seem to be trying to use match for \\\n@@ -80,7 +80,7 @@ impl LintPass for StrToStringPass {\n         }\n \n         fn is_str(cx: &Context, expr: &ast::Expr) -> bool {\n-            match walk_ty(cx.tcx.expr_ty(expr)).sty { \n+            match walk_ty(cx.tcx.expr_ty(expr)).sty {\n                 ty::TyStr => true,\n                 _ => false\n             }\n@@ -102,7 +102,7 @@ impl LintPass for TopLevelRefPass {\n     fn check_fn(&mut self, cx: &Context, _: FnKind, decl: &FnDecl, _: &Block, _: Span, _: NodeId) {\n         for ref arg in decl.inputs.iter() {\n             if let PatIdent(BindByRef(_), _, _) = arg.pat.node {\n-                span_lint(cx, \n+                span_lint(cx,\n                     TOPLEVEL_REF_ARG,\n                     arg.pat.span,\n                     \"`ref` directly on a function argument is ignored. Have you considered using a reference type instead?\"\n@@ -121,7 +121,7 @@ impl LintPass for CmpNan {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(CMP_NAN)\n     }\n-    \n+\n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n             if is_comparison_binop(cmp.node) {\n@@ -137,59 +137,59 @@ impl LintPass for CmpNan {\n }\n \n fn check_nan(cx: &Context, path: &Path, span: Span) {\n-\tpath.segments.last().map(|seg| if seg.identifier.name == \"NAN\" {\n-\t\tspan_lint(cx, CMP_NAN, span, \n-\t\t\t\"Doomed comparison with NAN, use std::{f32,f64}::is_nan instead\");\n-\t});\n+    path.segments.last().map(|seg| if seg.identifier.name == \"NAN\" {\n+        span_lint(cx, CMP_NAN, span,\n+                  \"Doomed comparison with NAN, use std::{f32,f64}::is_nan instead\");\n+    });\n }\n \n declare_lint!(pub FLOAT_CMP, Warn,\n               \"Warn on ==/!= comparison of floaty values\");\n-              \n+\n #[derive(Copy,Clone)]\n pub struct FloatCmp;\n \n impl LintPass for FloatCmp {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(FLOAT_CMP)\n     }\n-    \n+\n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n             let op = cmp.node;\n             if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n                 span_lint(cx, FLOAT_CMP, expr.span, &format!(\n                     \"{}-Comparison of f32 or f64 detected. You may want to change this to 'abs({} - {}) < epsilon' for some suitable value of epsilon\",\n-                    binop_to_string(op), snippet(cx, left.span, \"..\"), \n+                    binop_to_string(op), snippet(cx, left.span, \"..\"),\n                     snippet(cx, right.span, \"..\")));\n             }\n         }\n     }\n }\n \n fn is_float(cx: &Context, expr: &Expr) -> bool {\n-    if let ty::TyFloat(_) = walk_ty(cx.tcx.expr_ty(expr)).sty { \n+    if let ty::TyFloat(_) = walk_ty(cx.tcx.expr_ty(expr)).sty {\n         true\n-    } else { \n-        false \n+    } else {\n+        false\n     }\n }\n \n declare_lint!(pub PRECEDENCE, Warn,\n               \"Warn on mixing bit ops with integer arithmetic without parenthesis\");\n-              \n+\n #[derive(Copy,Clone)]\n pub struct Precedence;\n \n impl LintPass for Precedence {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(PRECEDENCE)\n     }\n-    \n+\n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n         if let ExprBinary(Spanned { node: op, ..}, ref left, ref right) = expr.node {\n             if is_bit_op(op) && (is_arith_expr(left) || is_arith_expr(right)) {\n-                span_lint(cx, PRECEDENCE, expr.span, \n+                span_lint(cx, PRECEDENCE, expr.span,\n                     \"Operator precedence can trip the unwary. Consider adding parenthesis to the subexpression.\");\n             }\n         }\n@@ -219,15 +219,15 @@ fn is_arith_op(op : BinOp_) -> bool {\n \n declare_lint!(pub CMP_OWNED, Warn,\n               \"Warn on creating an owned string just for comparison\");\n-              \n+\n #[derive(Copy,Clone)]\n pub struct CmpOwned;\n \n impl LintPass for CmpOwned {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(CMP_OWNED)\n     }\n-    \n+\n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n             if is_comparison_binop(cmp.node) {\n@@ -239,33 +239,33 @@ impl LintPass for CmpOwned {\n }\n \n fn check_to_owned(cx: &Context, expr: &Expr, other_span: Span) {\n-\tmatch &expr.node {\n-\t\t&ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n-\t\t\tlet name = ident.name;\n-\t\t\tif name == \"to_string\" || \n-\t\t\t   name == \"to_owned\" && is_str_arg(cx, args) {\n-\t\t\t\tspan_lint(cx, CMP_OWNED, expr.span, &format!(\n-\t\t\t\t\t\"this creates an owned instance just for comparison. \\\n-\t\t\t\t\tConsider using {}.as_slice() to compare without allocation\",\n-\t\t\t\t\tsnippet(cx, other_span, \"..\")))\n-\t\t\t}\n-\t\t},\n-\t\t&ExprCall(ref path, _) => {\n-\t\t\tif let &ExprPath(None, ref path) = &path.node {\n-\t\t\t\tif match_path(path, &[\"String\", \"from_str\"]) ||\n-\t\t\t\t\t\tmatch_path(path, &[\"String\", \"from\"]) {\n-\t\t\t\t\tspan_lint(cx, CMP_OWNED, expr.span, &format!(\n-\t\t\t\t\t\"this creates an owned instance just for comparison. \\\n-\t\t\t\t\tConsider using {}.as_slice() to compare without allocation\",\n-\t\t\t\t\tsnippet(cx, other_span, \"..\")))\n-\t\t\t\t}\n-\t\t\t}\n-\t\t},\n-\t\t_ => ()\n-\t}\n+    match &expr.node {\n+        &ExprMethodCall(Spanned{node: ref ident, ..}, _, ref args) => {\n+            let name = ident.name;\n+            if name == \"to_string\" ||\n+                name == \"to_owned\" && is_str_arg(cx, args) {\n+                    span_lint(cx, CMP_OWNED, expr.span, &format!(\n+                        \"this creates an owned instance just for comparison. \\\n+                         Consider using {}.as_slice() to compare without allocation\",\n+                        snippet(cx, other_span, \"..\")))\n+                }\n+        },\n+        &ExprCall(ref path, _) => {\n+            if let &ExprPath(None, ref path) = &path.node {\n+                if match_path(path, &[\"String\", \"from_str\"]) ||\n+                    match_path(path, &[\"String\", \"from\"]) {\n+                        span_lint(cx, CMP_OWNED, expr.span, &format!(\n+                            \"this creates an owned instance just for comparison. \\\n+                             Consider using {}.as_slice() to compare without allocation\",\n+                            snippet(cx, other_span, \"..\")))\n+                    }\n+            }\n+        },\n+        _ => ()\n+    }\n }\n \n fn is_str_arg(cx: &Context, args: &[P<Expr>]) -> bool {\n-    args.len() == 1 && if let ty::TyStr = \n+    args.len() == 1 && if let ty::TyStr =\n         walk_ty(cx.tcx.expr_ty(&*args[0])).sty { true } else { false }\n }"}]}