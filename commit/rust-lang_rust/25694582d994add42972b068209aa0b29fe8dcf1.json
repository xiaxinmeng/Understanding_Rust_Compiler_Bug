{"sha": "25694582d994add42972b068209aa0b29fe8dcf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1Njk0NTgyZDk5NGFkZDQyOTcyYjA2ODIwOWFhMGIyOWZlOGRjZjE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-22T21:23:54Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-28T20:26:19Z"}, "message": "Fix bug in handling of expr_alt (postcond for alts was being intersected with postcond for scrutinee)", "tree": {"sha": "502feb0de8330390ab9aa9edee885578d38e1aea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/502feb0de8330390ab9aa9edee885578d38e1aea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25694582d994add42972b068209aa0b29fe8dcf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25694582d994add42972b068209aa0b29fe8dcf1", "html_url": "https://github.com/rust-lang/rust/commit/25694582d994add42972b068209aa0b29fe8dcf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25694582d994add42972b068209aa0b29fe8dcf1/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "707cd0281da28596f6f4b5e9cdf0af4f17bf50f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/707cd0281da28596f6f4b5e9cdf0af4f17bf50f0", "html_url": "https://github.com/rust-lang/rust/commit/707cd0281da28596f6f4b5e9cdf0af4f17bf50f0"}], "stats": {"total": 188, "additions": 136, "deletions": 52}, "files": [{"sha": "2bbcc3e72252036831fb72654c50ebe3cb7f47eb", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 102, "deletions": 52, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/25694582d994add42972b068209aa0b29fe8dcf1/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25694582d994add42972b068209aa0b29fe8dcf1/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=25694582d994add42972b068209aa0b29fe8dcf1", "patch": "@@ -214,7 +214,7 @@ fn log_bitv_err(fn_info enclosing, bitv.t v) {\n     log_err(bitv_to_str(enclosing, v));\n }\n \n-fn log_cond(vec[uint] v) -> () {\n+fn tos (vec[uint] v) -> str {\n   auto res = \"\";\n   for (uint i in v) {\n     if (i == 0u) {\n@@ -224,8 +224,16 @@ fn log_cond(vec[uint] v) -> () {\n       res += \"1\";\n     }\n   }\n-  log(res);\n+  ret res;\n+}\n+\n+fn log_cond(vec[uint] v) -> () {\n+    log(tos(v));\n+}\n+fn log_cond_err(vec[uint] v) -> () {\n+    log_err(tos(v));\n }\n+\n fn log_pp(&pre_and_post pp) -> () {\n   auto p1 = bitv.to_vec(pp.precondition);\n   auto p2 = bitv.to_vec(pp.postcondition);\n@@ -235,6 +243,15 @@ fn log_pp(&pre_and_post pp) -> () {\n   log_cond(p2);\n }\n \n+fn log_pp_err(&pre_and_post pp) -> () {\n+  auto p1 = bitv.to_vec(pp.precondition);\n+  auto p2 = bitv.to_vec(pp.postcondition);\n+  log_err(\"pre:\");\n+  log_cond_err(p1);\n+  log_err(\"post:\");\n+  log_cond_err(p2);\n+}\n+\n fn log_states(&pre_and_post_state pp) -> () {\n   auto p1 = bitv.to_vec(pp.prestate);\n   auto p2 = bitv.to_vec(pp.poststate);\n@@ -244,6 +261,15 @@ fn log_states(&pre_and_post_state pp) -> () {\n   log_cond(p2);\n }\n \n+fn log_states_err(&pre_and_post_state pp) -> () {\n+  auto p1 = bitv.to_vec(pp.prestate);\n+  auto p2 = bitv.to_vec(pp.poststate);\n+  log_err(\"prestate:\");\n+  log_cond_err(p1);\n+  log_err(\"poststate:\");\n+  log_cond_err(p2);\n+}\n+\n fn print_ident(&ident i) -> () {\n   log(\" \" + i + \" \");\n }\n@@ -707,17 +733,27 @@ fn with_pp(ann a, pre_and_post p) -> ann {\n // return the precondition for evaluating each expr in order.\n // So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n // precondition shouldn't include x.\n-fn seq_preconds(uint num_vars, vec[pre_and_post] pps) -> precond {\n+fn seq_preconds(fn_info enclosing, vec[pre_and_post] pps) -> precond {\n   let uint sz = len[pre_and_post](pps);\n- \n+  let uint num_vars = num_locals(enclosing);\n+\n   if (sz >= 1u) {\n     auto first   = pps.(0);\n     check (pps_len(first) == num_vars);\n-    let precond rest = seq_preconds(num_vars,\n+    let precond rest = seq_preconds(enclosing,\n                          slice[pre_and_post](pps, 1u, sz));\n     difference(rest, first.postcondition);\n     auto res = clone(first.precondition);\n     union(res, rest);\n+\n+    log(\"seq_preconds:\");\n+    log(\"first.postcondition =\");\n+    log_bitv(enclosing, first.postcondition);\n+    log(\"rest =\");\n+    log_bitv(enclosing, rest);\n+    log(\"returning\");\n+    log_bitv(enclosing, res);\n+\n     ret res;\n   }\n   else {\n@@ -863,7 +899,7 @@ fn find_pre_post_exprs(&fn_info_map fm, &fn_info enclosing,\n     auto h = get_post;\n \n     set_pre_and_post(a,\n-       rec(precondition=seq_preconds(nv, pps),\n+       rec(precondition=seq_preconds(enclosing, pps),\n            postcondition=union_postconds\n            (nv, (_vec.map[pre_and_post, postcond](h, pps)))));\n }\n@@ -873,7 +909,7 @@ fn find_pre_post_loop(&fn_info_map fm, &fn_info enclosing, &@decl d,\n     find_pre_post_expr(fm, enclosing, *index);\n     find_pre_post_block(fm, enclosing, body);\n     auto loop_precond = declare_var(enclosing, decl_lhs(d),\n-           seq_preconds(num_locals(enclosing), vec(expr_pp(*index),\n+           seq_preconds(enclosing, vec(expr_pp(*index),\n                                                    block_pp(body))));\n     auto loop_postcond = intersect_postconds\n         (vec(expr_postcond(*index), block_postcond(body)));\n@@ -1033,7 +1069,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             find_pre_post_block(fm, enclosing, conseq);\n             alt (maybe_alt) {\n                 case (none[@expr]) {\n-                    auto precond_res = seq_preconds(num_local_vars,\n+                    auto precond_res = seq_preconds(enclosing,\n                                                     vec(expr_pp(*antec),\n                                                         block_pp(conseq)));\n                     set_pre_and_post(a, rec(precondition=precond_res,\n@@ -1043,13 +1079,13 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n                 case (some[@expr](?altern)) {\n                     find_pre_post_expr(fm, enclosing, *altern);\n                     auto precond_true_case =\n-                        seq_preconds(num_local_vars,\n+                        seq_preconds(enclosing,\n                                      vec(expr_pp(*antec), block_pp(conseq)));\n                     auto postcond_true_case = union_postconds\n                         (num_local_vars,\n                          vec(expr_postcond(*antec), block_postcond(conseq)));\n                     auto precond_false_case = seq_preconds\n-                        (num_local_vars,\n+                        (enclosing,\n                          vec(expr_pp(*antec), expr_pp(*altern)));\n                     auto postcond_false_case = union_postconds\n                         (num_local_vars,\n@@ -1085,7 +1121,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             find_pre_post_block(fm, enclosing, body);\n             set_pre_and_post(a,\n               rec(precondition=\n-                    seq_preconds(num_local_vars,\n+                  seq_preconds(enclosing,\n                                  vec(expr_pp(*test), \n                                      block_pp(body))),\n                   postcondition=\n@@ -1105,7 +1141,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             }\n \n             set_pre_and_post(a, \n-               rec(precondition=seq_preconds(num_local_vars,\n+                             rec(precondition=seq_preconds(enclosing,\n                                              vec(block_pp(body),\n                                                  expr_pp(*test))),\n                    postcondition=loop_postcond));\n@@ -1129,18 +1165,22 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             auto f = bind do_an_alt(fm, enclosing, _);\n             auto alt_pps = _vec.map[arm, pre_and_post](f, alts);\n             fn combine_pp(pre_and_post antec, \n-                          uint num_local_vars, &pre_and_post pp,\n+                          fn_info enclosing, &pre_and_post pp,\n                           &pre_and_post next) -> pre_and_post {\n-                union(pp.precondition, seq_preconds(num_local_vars,\n+                union(pp.precondition, seq_preconds(enclosing,\n                                          vec(antec, next)));\n                 intersect(pp.postcondition, next.postcondition);\n                 ret pp;\n             }\n-            auto e_pp1 = expr_pp(*e);\n-            auto e_pp  = pp_clone(e_pp1);\n-            auto g = bind combine_pp(e_pp, num_local_vars, _, _);\n-            set_pre_and_post(a, _vec.foldl[pre_and_post, pre_and_post]\n-                             (g, e_pp, alt_pps));\n+            auto antec_pp = pp_clone(expr_pp(*e)); \n+            auto e_pp  = rec(precondition=empty_prestate(num_local_vars),\n+                             postcondition=false_postcond(num_local_vars));\n+            auto g = bind combine_pp(antec_pp, enclosing, _, _);\n+\n+            auto alts_overall_pp = _vec.foldl[pre_and_post, pre_and_post]\n+                                    (g, e_pp, alt_pps);\n+\n+            set_pre_and_post(a, alts_overall_pp);\n         }\n         case (expr_field(?operator, _, ?a)) {\n             find_pre_post_expr(fm, enclosing, *operator);\n@@ -1271,6 +1311,10 @@ fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n \n     fn do_one_(fn_info_map fm, fn_info i, &@stmt s) -> () {\n         find_pre_post_stmt(fm, i, *s);\n+        log(\"pre_post for stmt:\");\n+        log_stmt(*s);\n+        log(\"is:\");\n+        log_pp(stmt_pp(*s));\n     }\n     auto do_one = bind do_one_(fm, enclosing, _);\n     \n@@ -1294,7 +1338,8 @@ fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n     auto g = get_pp_expr;\n     plus_option[pre_and_post](pps,\n        option.map[@expr, pre_and_post](g, b.node.expr));\n-    auto block_precond  = seq_preconds(nv, pps);\n+\n+    auto block_precond  = seq_preconds(enclosing, pps);\n     auto h = get_post;\n     auto postconds =  _vec.map[pre_and_post, postcond](h, pps);\n     /* A block may be empty, so this next line ensures that the postconds\n@@ -1305,6 +1350,7 @@ fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n     if (! has_nonlocal_exits(b)) {\n         block_postcond = union_postconds(nv, postconds);\n     }\n+\n     set_pre_and_post(b.node.a, rec(precondition=block_precond,\n                                    postcondition=block_postcond));\n }\n@@ -1661,6 +1707,13 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                 changed = extend_poststate_ann(a, poststate_res) || changed;\n             }\n         }\n+        log(\"if:\");\n+        log_expr(*e);\n+        log(\"new prestate:\");\n+        log_bitv(enclosing, pres);\n+        log(\"new poststate:\");\n+        log_bitv(enclosing, expr_poststate(*e));\n+\n         ret changed;\n     }\n     case (expr_binary(?bop, ?l, ?r, ?a)) {\n@@ -1826,16 +1879,15 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n   auto stmt_ann_ = stmt_to_ann(*s);\n   check (!is_none[@ts_ann](stmt_ann_));\n   auto stmt_ann = *(get[@ts_ann](stmt_ann_));\n-  /*\n-              log_err(\"*At beginning: stmt = \");\n+              log(\"*At beginning: stmt = \");\n               log_stmt(*s);\n-              log_err(\"*prestate = \");\n-              log_err(bitv.to_str(stmt_ann.states.prestate));\n-              log_err(\"*poststate =\");\n-              log_err(bitv.to_str(stmt_ann.states.poststate));\n-              log_err(\"*changed =\");\n+              log(\"*prestate = \");\n+              log(bitv.to_str(stmt_ann.states.prestate));\n+              log(\"*poststate =\");\n+              log(bitv.to_str(stmt_ann.states.poststate));\n+              log(\"*changed =\");\n               log(changed);\n-  */\n+  \n   alt (s.node) {\n     case (stmt_decl(?adecl, ?a)) {\n       alt (adecl.node) {\n@@ -1850,17 +1902,16 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n                                            expr_poststate(*an_init.expr))\n                     || changed;\n                 changed = gen_poststate(enclosing, a, alocal.id) || changed;\n-                /*  \n-              log_err(\"Summary: stmt = \");\n+              log(\"Summary: stmt = \");\n               log_stmt(*s);\n-              log_err(\"prestate = \");\n-              log_err(bitv.to_str(stmt_ann.states.prestate));\n+              log(\"prestate = \");\n+              log(bitv.to_str(stmt_ann.states.prestate));\n               log_bitv(enclosing, stmt_ann.states.prestate);\n-              log_err(\"poststate =\");\n+              log(\"poststate =\");\n               log_bitv(enclosing, stmt_ann.states.poststate);\n-              log_err(\"changed =\");\n-              log_err(changed);\n-                */\n+              log(\"changed =\");\n+              log(changed);\n+  \n               ret changed;\n             }\n             case (none[ast.initializer]) {\n@@ -1888,16 +1939,17 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n       changed = extend_poststate(stmt_ann.states.poststate,\n                                  expr_poststate(*e)) || changed;\n \n-      /*              log_err(\"Summary: stmt = \");\n+                    log(\"Summary: stmt = \");\n               log_stmt(*s);\n-              log_err(\"prestate = \");\n-              log_err(bitv.to_str(stmt_ann.states.prestate));\n+              log(\"prestate = \");\n+              log(bitv.to_str(stmt_ann.states.prestate));\n               log_bitv(enclosing, stmt_ann.states.prestate);\n-              log_err(\"poststate =\");\n+              log(\"poststate =\");\n+              log(bitv.to_str(stmt_ann.states.poststate));\n               log_bitv(enclosing, stmt_ann.states.poststate);\n-              log_err(\"changed =\");\n-              log_err(changed);\n-      */\n+              log(\"changed =\");\n+              log(changed);\n+      \n       ret changed;\n     }\n     case (_) { ret false; }\n@@ -1909,9 +1961,7 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n                              &prestate pres0, &block b)\n   -> bool {\n-\n-    /* FIXME handle non-local exits */\n-\n+    \n   auto changed = false;\n   auto num_local_vars = num_locals(enclosing);\n \n@@ -1952,16 +2002,16 @@ fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n   set_prestate_ann(@b.node.a, pres0);\n   set_poststate_ann(b.node.a, post);\n \n-  /*\n-  log_err(\"For block:\");\n+\n+  log(\"For block:\");\n   log_block(b);\n-  log_err(\"poststate = \");\n+  log(\"poststate = \");\n   log_states(block_states(b));\n-  log_err(\"pres0:\");\n+  log(\"pres0:\");\n   log_bitv(enclosing, pres0);\n-  log_err(\"post:\");\n+  log(\"post:\");\n   log_bitv(enclosing, post);\n-  */\n+\n \n   ret changed;\n }"}, {"sha": "152fac5d7bc178d5d22f464bd0b50db0ea96bbc5", "filename": "src/test/run-pass/alt-join.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/25694582d994add42972b068209aa0b29fe8dcf1/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25694582d994add42972b068209aa0b29fe8dcf1/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=25694582d994add42972b068209aa0b29fe8dcf1", "patch": "@@ -0,0 +1,34 @@\n+use std;\n+import std.option;\n+import std.option.t;\n+import std.option.none;\n+import std.option.some;\n+\n+fn foo[T](&option.t[T] y) {\n+  let int x;\n+  \n+  let vec[int] res = vec();\n+  \n+  /* tests that x doesn't get put in the precondition for the \n+     entire if expression */\n+  if (true) {\n+  }\n+  else {\n+    alt (y) {\n+      case (none[T]) {\n+        x = 17;\n+      }\n+      case (_) {\n+        x = 42;\n+      }\n+    }\n+    res += vec(x);\n+  }\n+\n+  ret;\n+}\n+\n+fn main() {\n+  log(\"hello\");\n+  foo[int](some[int](5));\n+}\n\\ No newline at end of file"}]}