{"sha": "584b3593485ef144de7217de19ac8a98766c0532", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NGIzNTkzNDg1ZWYxNDRkZTcyMTdkZTE5YWM4YTk4NzY2YzA1MzI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-05T08:27:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:11Z"}, "message": "Migrate uv net bindings away from ~fn()", "tree": {"sha": "65cd7caecf85e3997516df9289c74b196aae27a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65cd7caecf85e3997516df9289c74b196aae27a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/584b3593485ef144de7217de19ac8a98766c0532", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/584b3593485ef144de7217de19ac8a98766c0532", "html_url": "https://github.com/rust-lang/rust/commit/584b3593485ef144de7217de19ac8a98766c0532", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/584b3593485ef144de7217de19ac8a98766c0532/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5842b606a7e11c671d92aac574389e359a8172f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5842b606a7e11c671d92aac574389e359a8172f6", "html_url": "https://github.com/rust-lang/rust/commit/5842b606a7e11c671d92aac574389e359a8172f6"}], "stats": {"total": 1685, "additions": 618, "deletions": 1067}, "files": [{"sha": "88818cf2b4d22d0f10009d69edd3043b34c7fad1", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=584b3593485ef144de7217de19ac8a98766c0532", "patch": "@@ -17,14 +17,9 @@ use std::rt::local::Local;\n use std::rt::sched::Scheduler;\n \n use net;\n-use super::{Loop, UvError, NativeHandle};\n-use uvll::UV_GETADDRINFO;\n+use super::{Loop, UvError, NativeHandle, Request};\n use uvll;\n \n-struct GetAddrInfoRequest {\n-    handle: *uvll::uv_getaddrinfo_t,\n-}\n-\n struct Addrinfo {\n     handle: *uvll::addrinfo,\n }\n@@ -35,13 +30,9 @@ struct Ctx {\n     addrinfo: Option<Addrinfo>,\n }\n \n-impl GetAddrInfoRequest {\n-    pub fn new() -> GetAddrInfoRequest {\n-        GetAddrInfoRequest {\n-            handle: unsafe { uvll::malloc_req(uvll::UV_GETADDRINFO) },\n-        }\n-    }\n+pub struct GetAddrInfoRequest;\n \n+impl GetAddrInfoRequest {\n     pub fn run(loop_: &Loop, node: Option<&str>, service: Option<&str>,\n                hints: Option<ai::Hint>) -> Result<~[ai::Info], UvError> {\n         assert!(node.is_some() || service.is_some());\n@@ -85,7 +76,7 @@ impl GetAddrInfoRequest {\n             }\n         });\n         let hint_ptr = hint.as_ref().map_default(null(), |x| x as *uvll::addrinfo);\n-        let req = GetAddrInfoRequest::new();\n+        let req = Request::new(uvll::UV_GETADDRINFO);\n \n         return match unsafe {\n             uvll::uv_getaddrinfo(loop_.native_handle(), req.handle,\n@@ -94,7 +85,8 @@ impl GetAddrInfoRequest {\n         } {\n             0 => {\n                 let mut cx = Ctx { slot: None, status: 0, addrinfo: None };\n-                unsafe { uvll::set_data_for_req(req.handle, &cx) }\n+                req.set_data(&cx);\n+                req.defuse();\n                 let scheduler: ~Scheduler = Local::take();\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n                     cx.slot = Some(task);\n@@ -112,9 +104,9 @@ impl GetAddrInfoRequest {\n         extern fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,\n                                  status: c_int,\n                                  res: *uvll::addrinfo) {\n-            let cx: &mut Ctx = unsafe {\n-                cast::transmute(uvll::get_data_for_req(req))\n-            };\n+            let req = Request::wrap(req);\n+            if status == uvll::ECANCELED { return }\n+            let cx: &mut Ctx = unsafe { cast::transmute(req.get_data()) };\n             cx.status = status;\n             cx.addrinfo = Some(Addrinfo { handle: res });\n \n@@ -124,12 +116,6 @@ impl GetAddrInfoRequest {\n     }\n }\n \n-impl Drop for GetAddrInfoRequest {\n-    fn drop(&mut self) {\n-        unsafe { uvll::free_req(self.handle) }\n-    }\n-}\n-\n impl Drop for Addrinfo {\n     fn drop(&mut self) {\n         unsafe { uvll::uv_freeaddrinfo(self.handle) }"}, {"sha": "5e79f6e13451f4c7f04a2a7ef617dab1a950954b", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 36, "deletions": 144, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=584b3593485ef144de7217de19ac8a98766c0532", "patch": "@@ -54,19 +54,18 @@ use std::libc::{c_void, c_int, size_t, malloc, free};\n use std::cast::transmute;\n use std::ptr::null;\n use std::unstable::finally::Finally;\n-use std::rt::io::net::ip::SocketAddr;\n \n use std::rt::io::IoError;\n \n //#[cfg(test)] use unstable::run_in_bare_thread;\n \n pub use self::file::{FsRequest, FileWatcher};\n-pub use self::net::{StreamWatcher, TcpWatcher, UdpWatcher};\n+pub use self::net::{TcpWatcher, TcpListener, TcpAcceptor, UdpWatcher};\n pub use self::idle::IdleWatcher;\n pub use self::timer::TimerWatcher;\n pub use self::async::AsyncWatcher;\n pub use self::process::Process;\n-pub use self::pipe::PipeWatcher;\n+pub use self::pipe::{PipeWatcher, PipeListener, PipeAcceptor};\n pub use self::signal::SignalWatcher;\n pub use self::tty::TtyWatcher;\n \n@@ -97,24 +96,6 @@ pub struct Loop {\n     priv handle: *uvll::uv_loop_t\n }\n \n-pub struct Handle(*uvll::uv_handle_t);\n-\n-impl Watcher for Handle {}\n-impl NativeHandle<*uvll::uv_handle_t> for Handle {\n-    fn from_native_handle(h: *uvll::uv_handle_t) -> Handle { Handle(h) }\n-    fn native_handle(&self) -> *uvll::uv_handle_t { **self }\n-}\n-\n-/// The trait implemented by uv 'watchers' (handles). Watchers are\n-/// non-owning wrappers around the uv handles and are not completely\n-/// safe - there may be multiple instances for a single underlying\n-/// handle.  Watchers are generally created, then `start`ed, `stop`ed\n-/// and `close`ed, but due to their complex life cycle may not be\n-/// entirely memory safe if used in unanticipated patterns.\n-pub trait Watcher { }\n-\n-pub trait Request { }\n-\n /// A type that wraps a native handle\n pub trait NativeHandle<T> {\n     fn from_native_handle(T) -> Self;\n@@ -160,32 +141,47 @@ pub trait UvHandle<T> {\n     }\n }\n \n-pub trait UvRequest<T> {\n-    fn uv_request(&self) -> *T;\n+pub struct Request {\n+    handle: *uvll::uv_req_t,\n+}\n \n-    // FIXME(#8888) dummy self\n-    fn alloc(_: Option<Self>, ty: uvll::uv_req_type) -> *T {\n-        unsafe {\n-            let handle = uvll::malloc_req(ty);\n-            assert!(!handle.is_null());\n-            handle as *T\n-        }\n+impl Request {\n+    pub fn new(ty: uvll::uv_req_type) -> Request {\n+        Request::wrap(unsafe { uvll::malloc_req(ty) })\n     }\n \n-    unsafe fn from_uv_request<'a>(h: &'a *T) -> &'a mut Self {\n-        cast::transmute(uvll::get_data_for_req(*h))\n+    pub fn wrap(handle: *uvll::uv_req_t) -> Request {\n+        Request { handle: handle }\n     }\n \n-    fn install(~self) -> ~Self {\n-        unsafe {\n-            let myptr = cast::transmute::<&~Self, &*u8>(&self);\n-            uvll::set_data_for_req(self.uv_request(), *myptr);\n-        }\n-        self\n+    pub fn set_data<T>(&self, t: *T) {\n+        unsafe { uvll::set_data_for_req(self.handle, t) }\n     }\n \n-    fn delete(&mut self) {\n-        unsafe { uvll::free_req(self.uv_request() as *c_void) }\n+    pub fn get_data(&self) -> *c_void {\n+        unsafe { uvll::get_data_for_req(self.handle) }\n+    }\n+\n+    // This function should be used when the request handle has been given to an\n+    // underlying uv function, and the uv function has succeeded. This means\n+    // that uv will at some point invoke the callback, and in the meantime we\n+    // can't deallocate the handle because libuv could be using it.\n+    //\n+    // This is still a problem in blocking situations due to linked failure. In\n+    // the connection callback the handle should be re-wrapped with the `wrap`\n+    // function to ensure its destruction.\n+    pub fn defuse(mut self) {\n+        self.handle = ptr::null();\n+    }\n+}\n+\n+impl Drop for Request {\n+    fn drop(&mut self) {\n+        unsafe {\n+            if self.handle != ptr::null() {\n+                uvll::free_req(self.handle)\n+            }\n+        }\n     }\n }\n \n@@ -214,110 +210,6 @@ impl NativeHandle<*uvll::uv_loop_t> for Loop {\n     }\n }\n \n-// XXX: The uv alloc callback also has a *uv_handle_t arg\n-pub type AllocCallback = ~fn(uint) -> Buf;\n-pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n-pub type NullCallback = ~fn();\n-pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n-pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n-pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n-\n-\n-/// Callbacks used by StreamWatchers, set as custom data on the foreign handle.\n-/// XXX: Would be better not to have all watchers allocate room for all callback types.\n-struct WatcherData {\n-    read_cb: Option<ReadCallback>,\n-    write_cb: Option<ConnectionCallback>,\n-    connect_cb: Option<ConnectionCallback>,\n-    close_cb: Option<NullCallback>,\n-    alloc_cb: Option<AllocCallback>,\n-    udp_recv_cb: Option<UdpReceiveCallback>,\n-    udp_send_cb: Option<UdpSendCallback>,\n-}\n-\n-pub trait WatcherInterop {\n-    fn event_loop(&self) -> Loop;\n-    fn install_watcher_data(&mut self);\n-    fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData;\n-    fn drop_watcher_data(&mut self);\n-    fn close(self, cb: NullCallback);\n-    fn close_async(self);\n-}\n-\n-impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n-    /// Get the uv event loop from a Watcher\n-    fn event_loop(&self) -> Loop {\n-        unsafe {\n-            let handle = self.native_handle();\n-            let loop_ = uvll::get_loop_for_uv_handle(handle);\n-            NativeHandle::from_native_handle(loop_)\n-        }\n-    }\n-\n-    fn install_watcher_data(&mut self) {\n-        unsafe {\n-            let data = ~WatcherData {\n-                read_cb: None,\n-                write_cb: None,\n-                connect_cb: None,\n-                close_cb: None,\n-                alloc_cb: None,\n-                udp_recv_cb: None,\n-                udp_send_cb: None,\n-            };\n-            let data = transmute::<~WatcherData, *c_void>(data);\n-            uvll::set_data_for_uv_handle(self.native_handle(), data);\n-        }\n-    }\n-\n-    fn get_watcher_data<'r>(&'r mut self) -> &'r mut WatcherData {\n-        unsafe {\n-            let data = uvll::get_data_for_uv_handle(self.native_handle());\n-            let data = transmute::<&*c_void, &mut ~WatcherData>(&data);\n-            return &mut **data;\n-        }\n-    }\n-\n-    fn drop_watcher_data(&mut self) {\n-        unsafe {\n-            let data = uvll::get_data_for_uv_handle(self.native_handle());\n-            let _data = transmute::<*c_void, ~WatcherData>(data);\n-            uvll::set_data_for_uv_handle(self.native_handle(), null::<()>());\n-        }\n-    }\n-\n-    fn close(mut self, cb: NullCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            assert!(data.close_cb.is_none());\n-            data.close_cb = Some(cb);\n-        }\n-\n-        unsafe {\n-            uvll::uv_close(self.native_handle() as *uvll::uv_handle_t, close_cb);\n-        }\n-\n-        extern fn close_cb(handle: *uvll::uv_handle_t) {\n-            let mut h: Handle = NativeHandle::from_native_handle(handle);\n-            h.get_watcher_data().close_cb.take_unwrap()();\n-            h.drop_watcher_data();\n-            unsafe { uvll::free_handle(handle as *c_void) }\n-        }\n-    }\n-\n-    fn close_async(self) {\n-        unsafe {\n-            uvll::uv_close(self.native_handle() as *uvll::uv_handle_t, close_cb);\n-        }\n-\n-        extern fn close_cb(handle: *uvll::uv_handle_t) {\n-            let mut h: Handle = NativeHandle::from_native_handle(handle);\n-            h.drop_watcher_data();\n-            unsafe { uvll::free_handle(handle as *c_void) }\n-        }\n-    }\n-}\n-\n // XXX: Need to define the error constants like EOF so they can be\n // compared to the UvError type\n "}, {"sha": "ef64b1e5cc5458ae66730eeec1dc59dff84ee513", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 503, "deletions": 299, "changes": 802, "blob_url": "https://github.com/rust-lang/rust/blob/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=584b3593485ef144de7217de19ac8a98766c0532", "patch": "@@ -8,18 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::cast;\n use std::libc::{size_t, ssize_t, c_int, c_void, c_uint, c_char};\n-use std::vec;\n+use std::ptr;\n+use std::rt::BlockedTask;\n+use std::rt::io::IoError;\n+use std::rt::io::net::ip::{Ipv4Addr, Ipv6Addr};\n+use std::rt::local::Local;\n+use std::rt::io::net::ip::{SocketAddr, IpAddr};\n+use std::rt::rtio;\n+use std::rt::sched::{Scheduler, SchedHandle};\n+use std::rt::tube::Tube;\n use std::str;\n-use std::rt::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n+use std::vec;\n \n use uvll;\n use uvll::*;\n-use super::{AllocCallback, ConnectionCallback, ReadCallback, UdpReceiveCallback,\n-            UdpSendCallback, Loop, Watcher, Request, UvError, Buf, NativeHandle,\n-            status_to_maybe_uv_error, empty_buf};\n+use super::{\n+            Loop, Request, UvError, Buf, NativeHandle,\n+            status_to_io_result,\n+            uv_error_to_io_error, UvHandle, slice_to_uv_buf};\n+use uvio::HomingIO;\n+use stream::StreamWatcher;\n \n-pub struct UvAddrInfo(*uvll::addrinfo);\n+////////////////////////////////////////////////////////////////////////////////\n+/// Generic functions related to dealing with sockaddr things\n+////////////////////////////////////////////////////////////////////////////////\n \n pub enum UvSocketAddr {\n     UvIpv4SocketAddr(*sockaddr_in),\n@@ -113,395 +127,585 @@ fn test_ip6_conversion() {\n     assert_eq!(ip6, socket_addr_as_uv_socket_addr(ip6, uv_socket_addr_to_socket_addr));\n }\n \n-// uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t\n-// and uv_file_t\n-pub struct StreamWatcher(*uvll::uv_stream_t);\n-impl Watcher for StreamWatcher { }\n+enum SocketNameKind {\n+    TcpPeer,\n+    Tcp,\n+    Udp\n+}\n \n-impl StreamWatcher {\n-    pub fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n-        unsafe {\n-            match uvll::uv_read_start(self.native_handle(), alloc_cb, read_cb) {\n-                0 => {\n-                    let data = self.get_watcher_data();\n-                    data.alloc_cb = Some(alloc);\n-                    data.read_cb = Some(cb);\n-                }\n-                n => {\n-                    cb(*self, 0, empty_buf(), Some(UvError(n)))\n-                }\n-            }\n-        }\n+fn socket_name(sk: SocketNameKind, handle: *c_void) -> Result<SocketAddr, IoError> {\n+    let getsockname = match sk {\n+        TcpPeer => uvll::tcp_getpeername,\n+        Tcp     => uvll::tcp_getsockname,\n+        Udp     => uvll::udp_getsockname,\n+    };\n \n-        extern fn alloc_cb(stream: *uvll::uv_stream_t, suggested_size: size_t) -> Buf {\n-            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let alloc_cb = stream_watcher.get_watcher_data().alloc_cb.get_ref();\n-            return (*alloc_cb)(suggested_size as uint);\n-        }\n+    // Allocate a sockaddr_storage\n+    // since we don't know if it's ipv4 or ipv6\n+    let r_addr = unsafe { uvll::malloc_sockaddr_storage() };\n \n-        extern fn read_cb(stream: *uvll::uv_stream_t, nread: ssize_t, buf: Buf) {\n-            uvdebug!(\"buf addr: {}\", buf.base);\n-            uvdebug!(\"buf len: {}\", buf.len);\n-            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let cb = stream_watcher.get_watcher_data().read_cb.get_ref();\n-            let status = status_to_maybe_uv_error(nread as c_int);\n-            (*cb)(stream_watcher, nread as int, buf, status);\n-        }\n-    }\n+    let r = unsafe {\n+        getsockname(handle, r_addr as *uvll::sockaddr_storage)\n+    };\n \n-    pub fn read_stop(&mut self) {\n-        // It would be nice to drop the alloc and read callbacks here,\n-        // but read_stop may be called from inside one of them and we\n-        // would end up freeing the in-use environment\n-        let handle = self.native_handle();\n-        unsafe { assert_eq!(uvll::uv_read_stop(handle), 0); }\n+    if r != 0 {\n+        return Err(uv_error_to_io_error(UvError(r)));\n     }\n \n-    pub fn write(&mut self, buf: Buf, cb: ConnectionCallback) {\n-        let req = WriteRequest::new();\n-        return unsafe {\n-            match uvll::uv_write(req.native_handle(), self.native_handle(),\n-                                 [buf], write_cb) {\n-                0 => {\n-                    let data = self.get_watcher_data();\n-                    assert!(data.write_cb.is_none());\n-                    data.write_cb = Some(cb);\n-                }\n-                n => {\n-                    req.delete();\n-                    cb(*self, Some(UvError(n)))\n-                }\n-            }\n-        };\n-\n-        extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n-            let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n-            let mut stream_watcher = write_request.stream();\n-            write_request.delete();\n-            let cb = stream_watcher.get_watcher_data().write_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(status);\n-            cb(stream_watcher, status);\n+    let addr = unsafe {\n+        if uvll::is_ip6_addr(r_addr as *uvll::sockaddr) {\n+            uv_socket_addr_to_socket_addr(UvIpv6SocketAddr(r_addr as *uvll::sockaddr_in6))\n+        } else {\n+            uv_socket_addr_to_socket_addr(UvIpv4SocketAddr(r_addr as *uvll::sockaddr_in))\n         }\n-    }\n+    };\n \n+    unsafe { uvll::free_sockaddr_storage(r_addr); }\n \n-    pub fn listen(&mut self, cb: ConnectionCallback) -> Result<(), UvError> {\n-        {\n-            let data = self.get_watcher_data();\n-            assert!(data.connect_cb.is_none());\n-            data.connect_cb = Some(cb);\n-        }\n+    Ok(addr)\n \n-        return unsafe {\n-            static BACKLOG: c_int = 128; // XXX should be configurable\n-            match uvll::uv_listen(self.native_handle(), BACKLOG, connection_cb) {\n-                0 => Ok(()),\n-                n => Err(UvError(n))\n-            }\n-        };\n+}\n \n-        extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n-            uvdebug!(\"connection_cb\");\n-            let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n-            let status = status_to_maybe_uv_error(status);\n-            (*cb)(stream_watcher, status);\n-        }\n-    }\n+////////////////////////////////////////////////////////////////////////////////\n+/// TCP implementation\n+////////////////////////////////////////////////////////////////////////////////\n \n-    pub fn accept(&mut self, stream: StreamWatcher) {\n-        let self_handle = self.native_handle() as *c_void;\n-        let stream_handle = stream.native_handle() as *c_void;\n-        assert_eq!(0, unsafe { uvll::uv_accept(self_handle, stream_handle) } );\n-    }\n+pub struct TcpWatcher {\n+    handle: *uvll::uv_tcp_t,\n+    stream: StreamWatcher,\n+    home: SchedHandle,\n }\n \n-impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n-    fn from_native_handle(handle: *uvll::uv_stream_t) -> StreamWatcher {\n-        StreamWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_stream_t {\n-        match self { &StreamWatcher(ptr) => ptr }\n-    }\n+pub struct TcpListener {\n+    home: SchedHandle,\n+    handle: *uvll::uv_pipe_t,\n+    priv closing_task: Option<BlockedTask>,\n+    priv outgoing: Tube<Result<~rtio::RtioTcpStream, IoError>>,\n+}\n+\n+pub struct TcpAcceptor {\n+    listener: ~TcpListener,\n+    priv incoming: Tube<Result<~rtio::RtioTcpStream, IoError>>,\n }\n \n-pub struct TcpWatcher(*uvll::uv_tcp_t);\n-impl Watcher for TcpWatcher { }\n+// TCP watchers (clients/streams)\n \n impl TcpWatcher {\n     pub fn new(loop_: &Loop) -> TcpWatcher {\n-        unsafe {\n-            let handle = malloc_handle(UV_TCP);\n-            assert!(handle.is_not_null());\n-            assert_eq!(0, uvll::uv_tcp_init(loop_.native_handle(), handle));\n-            let mut watcher: TcpWatcher = NativeHandle::from_native_handle(handle);\n-            watcher.install_watcher_data();\n-            return watcher;\n+        let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n+        assert_eq!(unsafe {\n+            uvll::uv_tcp_init(loop_.native_handle(), handle)\n+        }, 0);\n+        TcpWatcher {\n+            home: get_handle_to_current_scheduler!(),\n+            handle: handle,\n+            stream: StreamWatcher::new(handle),\n         }\n     }\n \n-    pub fn bind(&mut self, address: SocketAddr) -> Result<(), UvError> {\n-        do socket_addr_as_uv_socket_addr(address) |addr| {\n-            let result = unsafe {\n-                match addr {\n-                    UvIpv4SocketAddr(addr) => uvll::tcp_bind(self.native_handle(), addr),\n-                    UvIpv6SocketAddr(addr) => uvll::tcp_bind6(self.native_handle(), addr),\n-                }\n+    pub fn connect(loop_: &mut Loop, address: SocketAddr)\n+        -> Result<TcpWatcher, UvError>\n+    {\n+        struct Ctx { status: c_int, task: Option<BlockedTask> }\n+\n+        let tcp = TcpWatcher::new(loop_);\n+        let ret = do socket_addr_as_uv_socket_addr(address) |addr| {\n+            let req = Request::new(uvll::UV_CONNECT);\n+            let result = match addr {\n+                UvIpv4SocketAddr(addr) => unsafe {\n+                    uvll::tcp_connect(req.handle, tcp.handle, addr,\n+                                      connect_cb)\n+                },\n+                UvIpv6SocketAddr(addr) => unsafe {\n+                    uvll::tcp_connect6(req.handle, tcp.handle, addr,\n+                                       connect_cb)\n+                },\n             };\n             match result {\n-                0 => Ok(()),\n-                _ => Err(UvError(result)),\n+                0 => {\n+                    req.defuse();\n+                    let mut cx = Ctx { status: 0, task: None };\n+                    let scheduler: ~Scheduler = Local::take();\n+                    do scheduler.deschedule_running_task_and_then |_, task| {\n+                        cx.task = Some(task);\n+                    }\n+                    match cx.status {\n+                        0 => Ok(()),\n+                        n => Err(UvError(n)),\n+                    }\n+                }\n+                n => Err(UvError(n))\n             }\n-        }\n-    }\n+        };\n \n-    pub fn connect(&mut self, address: SocketAddr, cb: ConnectionCallback) {\n-        unsafe {\n-            assert!(self.get_watcher_data().connect_cb.is_none());\n-            self.get_watcher_data().connect_cb = Some(cb);\n-\n-            let connect_handle = ConnectRequest::new().native_handle();\n-            uvdebug!(\"connect_t: {}\", connect_handle);\n-            do socket_addr_as_uv_socket_addr(address) |addr| {\n-                let result = match addr {\n-                    UvIpv4SocketAddr(addr) => uvll::tcp_connect(connect_handle,\n-                                                      self.native_handle(), addr, connect_cb),\n-                    UvIpv6SocketAddr(addr) => uvll::tcp_connect6(connect_handle,\n-                                                       self.native_handle(), addr, connect_cb),\n-                };\n-                assert_eq!(0, result);\n-            }\n+        return match ret {\n+            Ok(()) => Ok(tcp),\n+            Err(e) => Err(e),\n+        };\n \n-            extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n-                uvdebug!(\"connect_t: {}\", req);\n-                let connect_request: ConnectRequest = NativeHandle::from_native_handle(req);\n-                let mut stream_watcher = connect_request.stream();\n-                connect_request.delete();\n-                let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n-                let status = status_to_maybe_uv_error(status);\n-                cb(stream_watcher, status);\n-            }\n+        extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n+            let _req = Request::wrap(req);\n+            if status == uvll::ECANCELED { return }\n+            let cx: &mut Ctx = unsafe {\n+                cast::transmute(uvll::get_data_for_req(req))\n+            };\n+            cx.status = status;\n+            let scheduler: ~Scheduler = Local::take();\n+            scheduler.resume_blocked_task_immediately(cx.task.take_unwrap());\n         }\n     }\n+}\n \n-    pub fn as_stream(&self) -> StreamWatcher {\n-        NativeHandle::from_native_handle(self.native_handle() as *uvll::uv_stream_t)\n+impl HomingIO for TcpWatcher {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl rtio::RtioSocket for TcpWatcher {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+        let _m = self.fire_missiles();\n+        socket_name(Tcp, self.handle)\n     }\n }\n \n-impl NativeHandle<*uvll::uv_tcp_t> for TcpWatcher {\n-    fn from_native_handle(handle: *uvll::uv_tcp_t) -> TcpWatcher {\n-        TcpWatcher(handle)\n+impl rtio::RtioTcpStream for TcpWatcher {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        let _m = self.fire_missiles();\n+        self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n-    fn native_handle(&self) -> *uvll::uv_tcp_t {\n-        match self { &TcpWatcher(ptr) => ptr }\n+\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        self.stream.write(buf).map_err(uv_error_to_io_error)\n     }\n-}\n \n-pub struct UdpWatcher(*uvll::uv_udp_t);\n-impl Watcher for UdpWatcher { }\n+    fn peer_name(&mut self) -> Result<SocketAddr, IoError> {\n+        let _m = self.fire_missiles();\n+        socket_name(TcpPeer, self.handle)\n+    }\n \n-impl UdpWatcher {\n-    pub fn new(loop_: &Loop) -> UdpWatcher {\n-        unsafe {\n-            let handle = malloc_handle(UV_UDP);\n-            assert!(handle.is_not_null());\n-            assert_eq!(0, uvll::uv_udp_init(loop_.native_handle(), handle));\n-            let mut watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n-            watcher.install_watcher_data();\n-            return watcher;\n-        }\n+    fn control_congestion(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            uvll::uv_tcp_nodelay(self.handle, 0 as c_int)\n+        })\n     }\n \n-    pub fn bind(&mut self, address: SocketAddr) -> Result<(), UvError> {\n-        do socket_addr_as_uv_socket_addr(address) |addr| {\n-            let result = unsafe {\n-                match addr {\n-                    UvIpv4SocketAddr(addr) => uvll::udp_bind(self.native_handle(), addr, 0u32),\n-                    UvIpv6SocketAddr(addr) => uvll::udp_bind6(self.native_handle(), addr, 0u32),\n-                }\n-            };\n-            match result {\n-                0 => Ok(()),\n-                _ => Err(UvError(result)),\n-            }\n-        }\n+    fn nodelay(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            uvll::uv_tcp_nodelay(self.handle, 1 as c_int)\n+        })\n     }\n \n-    pub fn recv_start(&mut self, alloc: AllocCallback, cb: UdpReceiveCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            data.alloc_cb = Some(alloc);\n-            data.udp_recv_cb = Some(cb);\n-        }\n+    fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            uvll::uv_tcp_keepalive(self.handle, 1 as c_int,\n+                                   delay_in_seconds as c_uint)\n+        })\n+    }\n \n-        unsafe { uvll::uv_udp_recv_start(self.native_handle(), alloc_cb, recv_cb); }\n+    fn letdie(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            uvll::uv_tcp_keepalive(self.handle, 0 as c_int, 0 as c_uint)\n+        })\n+    }\n+}\n \n-        extern fn alloc_cb(handle: *uvll::uv_udp_t, suggested_size: size_t) -> Buf {\n-            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n-            let alloc_cb = udp_watcher.get_watcher_data().alloc_cb.get_ref();\n-            return (*alloc_cb)(suggested_size as uint);\n-        }\n+impl Drop for TcpWatcher {\n+    fn drop(&mut self) {\n+        let _m = self.fire_missiles();\n+        self.stream.close(true);\n+    }\n+}\n \n-        extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: Buf,\n-                          addr: *uvll::sockaddr, flags: c_uint) {\n-            // When there's no data to read the recv callback can be a no-op.\n-            // This can happen if read returns EAGAIN/EWOULDBLOCK. By ignoring\n-            // this we just drop back to kqueue and wait for the next callback.\n-            if nread == 0 {\n-                return;\n+// TCP listeners (unbound servers)\n+\n+impl TcpListener {\n+    pub fn bind(loop_: &mut Loop, address: SocketAddr)\n+        -> Result<~TcpListener, UvError>\n+    {\n+        let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n+        assert_eq!(unsafe {\n+            uvll::uv_tcp_init(loop_.native_handle(), handle)\n+        }, 0);\n+        let l = ~TcpListener {\n+            home: get_handle_to_current_scheduler!(),\n+            handle: handle,\n+            closing_task: None,\n+            outgoing: Tube::new(),\n+        };\n+        let res = socket_addr_as_uv_socket_addr(address, |addr| unsafe {\n+            match addr {\n+                UvIpv4SocketAddr(addr) => uvll::tcp_bind(l.handle, addr),\n+                UvIpv6SocketAddr(addr) => uvll::tcp_bind6(l.handle, addr),\n             }\n-\n-            uvdebug!(\"buf addr: {}\", buf.base);\n-            uvdebug!(\"buf len: {}\", buf.len);\n-            let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n-            let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n-            let status = status_to_maybe_uv_error(nread as c_int);\n-            let addr = uv_socket_addr_to_socket_addr(sockaddr_to_UvSocketAddr(addr));\n-            (*cb)(udp_watcher, nread as int, buf, addr, flags as uint, status);\n+        });\n+        match res {\n+            0 => Ok(l.install()),\n+            n => Err(UvError(n))\n         }\n     }\n+}\n+\n+impl HomingIO for TcpListener {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl UvHandle<uvll::uv_tcp_t> for TcpListener {\n+    fn uv_handle(&self) -> *uvll::uv_tcp_t { self.handle }\n+}\n \n-    pub fn recv_stop(&mut self) {\n-        unsafe { uvll::uv_udp_recv_stop(self.native_handle()); }\n+impl rtio::RtioSocket for TcpListener {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+        let _m = self.fire_missiles();\n+        socket_name(Tcp, self.handle)\n     }\n+}\n+\n+impl rtio::RtioTcpListener for TcpListener {\n+    fn listen(mut ~self) -> Result<~rtio::RtioTcpAcceptor, IoError> {\n+        // create the acceptor object from ourselves\n+        let incoming = self.outgoing.clone();\n+        let mut acceptor = ~TcpAcceptor {\n+            listener: self,\n+            incoming: incoming,\n+        };\n \n-    pub fn send(&mut self, buf: Buf, address: SocketAddr, cb: UdpSendCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            assert!(data.udp_send_cb.is_none());\n-            data.udp_send_cb = Some(cb);\n+        let _m = acceptor.fire_missiles();\n+        // XXX: the 128 backlog should be configurable\n+        match unsafe { uvll::uv_listen(acceptor.listener.handle, 128, listen_cb) } {\n+            0 => Ok(acceptor as ~rtio::RtioTcpAcceptor),\n+            n => Err(uv_error_to_io_error(UvError(n))),\n         }\n+    }\n+}\n \n-        let req = UdpSendRequest::new();\n-        do socket_addr_as_uv_socket_addr(address) |addr| {\n-            let result = unsafe {\n-                match addr {\n-                    UvIpv4SocketAddr(addr) => uvll::udp_send(req.native_handle(),\n-                                                   self.native_handle(), [buf], addr, send_cb),\n-                    UvIpv6SocketAddr(addr) => uvll::udp_send6(req.native_handle(),\n-                                                    self.native_handle(), [buf], addr, send_cb),\n-                }\n-            };\n-            assert_eq!(0, result);\n+extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) {\n+    let msg = match status {\n+        0 => {\n+            let loop_ = NativeHandle::from_native_handle(unsafe {\n+                uvll::get_loop_for_uv_handle(server)\n+            });\n+            let client = TcpWatcher::new(&loop_);\n+            assert_eq!(unsafe { uvll::uv_accept(server, client.handle) }, 0);\n+            Ok(~client as ~rtio::RtioTcpStream)\n         }\n+        uvll::ECANCELED => return,\n+        n => Err(uv_error_to_io_error(UvError(n)))\n+    };\n \n-        extern fn send_cb(req: *uvll::uv_udp_send_t, status: c_int) {\n-            let send_request: UdpSendRequest = NativeHandle::from_native_handle(req);\n-            let mut udp_watcher = send_request.handle();\n-            send_request.delete();\n-            let cb = udp_watcher.get_watcher_data().udp_send_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(status);\n-            cb(udp_watcher, status);\n+    let tcp: &mut TcpListener = unsafe { UvHandle::from_uv_handle(&server) };\n+    tcp.outgoing.send(msg);\n+}\n+\n+impl Drop for TcpListener {\n+    fn drop(&mut self) {\n+        let (_m, sched) = self.fire_missiles_sched();\n+\n+        do sched.deschedule_running_task_and_then |_, task| {\n+            self.closing_task = Some(task);\n+            unsafe { uvll::uv_close(self.handle, listener_close_cb) }\n         }\n     }\n }\n \n-impl NativeHandle<*uvll::uv_udp_t> for UdpWatcher {\n-    fn from_native_handle(handle: *uvll::uv_udp_t) -> UdpWatcher {\n-        UdpWatcher(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_udp_t {\n-        match self { &UdpWatcher(ptr) => ptr }\n-    }\n+extern fn listener_close_cb(handle: *uvll::uv_handle_t) {\n+    let tcp: &mut TcpListener = unsafe { UvHandle::from_uv_handle(&handle) };\n+    unsafe { uvll::free_handle(handle) }\n+\n+    let sched: ~Scheduler = Local::take();\n+    sched.resume_blocked_task_immediately(tcp.closing_task.take_unwrap());\n }\n \n-// uv_connect_t is a subclass of uv_req_t\n-pub struct ConnectRequest(*uvll::uv_connect_t);\n-impl Request for ConnectRequest { }\n+// TCP acceptors (bound servers)\n+\n+impl HomingIO for TcpAcceptor {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n+}\n \n-impl ConnectRequest {\n+impl rtio::RtioSocket for TcpAcceptor {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+        let _m = self.fire_missiles();\n+        socket_name(Tcp, self.listener.handle)\n+    }\n+}\n \n-    pub fn new() -> ConnectRequest {\n-        let connect_handle = unsafe { malloc_req(UV_CONNECT) };\n-        assert!(connect_handle.is_not_null());\n-        ConnectRequest(connect_handle as *uvll::uv_connect_t)\n+impl rtio::RtioTcpAcceptor for TcpAcceptor {\n+    fn accept(&mut self) -> Result<~rtio::RtioTcpStream, IoError> {\n+        let _m = self.fire_missiles();\n+        self.incoming.recv()\n     }\n \n-    fn stream(&self) -> StreamWatcher {\n-        unsafe {\n-            let stream_handle = uvll::get_stream_handle_from_connect_req(self.native_handle());\n-            NativeHandle::from_native_handle(stream_handle)\n-        }\n+    fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            uvll::uv_tcp_simultaneous_accepts(self.listener.handle, 1)\n+        })\n     }\n \n-    fn delete(self) {\n-        unsafe { free_req(self.native_handle() as *c_void) }\n+    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            uvll::uv_tcp_simultaneous_accepts(self.listener.handle, 0)\n+        })\n     }\n }\n \n-impl NativeHandle<*uvll::uv_connect_t> for ConnectRequest {\n-    fn from_native_handle(handle: *uvll:: uv_connect_t) -> ConnectRequest {\n-        ConnectRequest(handle)\n+////////////////////////////////////////////////////////////////////////////////\n+/// UDP implementation\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct UdpWatcher {\n+    handle: *uvll::uv_udp_t,\n+    home: SchedHandle,\n+}\n+\n+impl UdpWatcher {\n+    pub fn bind(loop_: &Loop, address: SocketAddr)\n+        -> Result<UdpWatcher, UvError>\n+    {\n+        let udp = UdpWatcher {\n+            handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n+            home: get_handle_to_current_scheduler!(),\n+        };\n+        assert_eq!(unsafe {\n+            uvll::uv_udp_init(loop_.native_handle(), udp.handle)\n+        }, 0);\n+        let result = socket_addr_as_uv_socket_addr(address, |addr| unsafe {\n+            match addr {\n+                UvIpv4SocketAddr(addr) => uvll::udp_bind(udp.handle, addr, 0u32),\n+                UvIpv6SocketAddr(addr) => uvll::udp_bind6(udp.handle, addr, 0u32),\n+            }\n+        });\n+        match result {\n+            0 => Ok(udp),\n+            n => Err(UvError(n)),\n+        }\n     }\n-    fn native_handle(&self) -> *uvll::uv_connect_t {\n-        match self { &ConnectRequest(ptr) => ptr }\n+}\n+\n+impl HomingIO for UdpWatcher {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl rtio::RtioSocket for UdpWatcher {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+        let _m = self.fire_missiles();\n+        socket_name(Udp, self.handle)\n     }\n }\n \n-pub struct WriteRequest(*uvll::uv_write_t);\n+impl rtio::RtioUdpSocket for UdpWatcher {\n+    fn recvfrom(&mut self, buf: &mut [u8])\n+        -> Result<(uint, SocketAddr), IoError>\n+    {\n+        struct Ctx {\n+            task: Option<BlockedTask>,\n+            buf: Option<Buf>,\n+            result: Option<(ssize_t, SocketAddr)>,\n+        }\n+        let _m = self.fire_missiles();\n+\n+        return match unsafe {\n+            uvll::uv_udp_recv_start(self.handle, alloc_cb, recv_cb)\n+        } {\n+            0 => {\n+                let mut cx = Ctx {\n+                    task: None,\n+                    buf: Some(slice_to_uv_buf(buf)),\n+                    result: None,\n+                };\n+                unsafe { uvll::set_data_for_uv_handle(self.handle, &cx) }\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    cx.task = Some(task);\n+                }\n+                match cx.result.take_unwrap() {\n+                    (n, _) if n < 0 =>\n+                        Err(uv_error_to_io_error(UvError(n as c_int))),\n+                    (n, addr) => Ok((n as uint, addr))\n+                }\n+            }\n+            n => Err(uv_error_to_io_error(UvError(n)))\n+        };\n+\n+        extern fn alloc_cb(handle: *uvll::uv_udp_t,\n+                           _suggested_size: size_t) -> Buf {\n+            let cx: &mut Ctx = unsafe {\n+                cast::transmute(uvll::get_data_for_uv_handle(handle))\n+            };\n+            cx.buf.take().expect(\"alloc_cb called more than once\")\n+        }\n+\n+        extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, _buf: Buf,\n+                          addr: *uvll::sockaddr, _flags: c_uint) {\n \n-impl Request for WriteRequest { }\n+            // When there's no data to read the recv callback can be a no-op.\n+            // This can happen if read returns EAGAIN/EWOULDBLOCK. By ignoring\n+            // this we just drop back to kqueue and wait for the next callback.\n+            if nread == 0 { return }\n+            if nread == uvll::ECANCELED as ssize_t { return }\n \n-impl WriteRequest {\n-    pub fn new() -> WriteRequest {\n-        let write_handle = unsafe { malloc_req(UV_WRITE) };\n-        assert!(write_handle.is_not_null());\n-        WriteRequest(write_handle as *uvll::uv_write_t)\n+            unsafe {\n+                assert_eq!(uvll::uv_udp_recv_stop(handle), 0)\n+            }\n+\n+            let cx: &mut Ctx = unsafe {\n+                cast::transmute(uvll::get_data_for_uv_handle(handle))\n+            };\n+            let addr = sockaddr_to_UvSocketAddr(addr);\n+            let addr = uv_socket_addr_to_socket_addr(addr);\n+            cx.result = Some((nread, addr));\n+\n+            let sched: ~Scheduler = Local::take();\n+            sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n+        }\n     }\n \n-    pub fn stream(&self) -> StreamWatcher {\n-        unsafe {\n-            let stream_handle = uvll::get_stream_handle_from_write_req(self.native_handle());\n-            NativeHandle::from_native_handle(stream_handle)\n+    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n+        struct Ctx { task: Option<BlockedTask>, result: c_int }\n+\n+        let _m = self.fire_missiles();\n+\n+        let req = Request::new(uvll::UV_UDP_SEND);\n+        let buf = slice_to_uv_buf(buf);\n+        let result = socket_addr_as_uv_socket_addr(dst, |dst| unsafe {\n+            match dst {\n+                UvIpv4SocketAddr(dst) =>\n+                    uvll::udp_send(req.handle, self.handle, [buf], dst, send_cb),\n+                UvIpv6SocketAddr(dst) =>\n+                    uvll::udp_send6(req.handle, self.handle, [buf], dst, send_cb),\n+            }\n+        });\n+\n+        return match result {\n+            0 => {\n+                let mut cx = Ctx { task: None, result: 0 };\n+                req.set_data(&cx);\n+                req.defuse();\n+\n+                let sched: ~Scheduler = Local::take();\n+                do sched.deschedule_running_task_and_then |_, task| {\n+                    cx.task = Some(task);\n+                }\n+\n+                match cx.result {\n+                    0 => Ok(()),\n+                    n => Err(uv_error_to_io_error(UvError(n)))\n+                }\n+            }\n+            n => Err(uv_error_to_io_error(UvError(n)))\n+        };\n+\n+        extern fn send_cb(req: *uvll::uv_udp_send_t, status: c_int) {\n+            let req = Request::wrap(req);\n+            let cx: &mut Ctx = unsafe { cast::transmute(req.get_data()) };\n+            cx.result = status;\n+\n+            let sched: ~Scheduler = Local::take();\n+            sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n         }\n     }\n \n-    pub fn delete(self) {\n-        unsafe { free_req(self.native_handle() as *c_void) }\n+    fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            do multi.to_str().with_c_str |m_addr| {\n+                uvll::uv_udp_set_membership(self.handle,\n+                                            m_addr, ptr::null(),\n+                                            uvll::UV_JOIN_GROUP)\n+            }\n+        })\n     }\n-}\n \n-impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n-    fn from_native_handle(handle: *uvll:: uv_write_t) -> WriteRequest {\n-        WriteRequest(handle)\n+    fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            do multi.to_str().with_c_str |m_addr| {\n+                uvll::uv_udp_set_membership(self.handle,\n+                                            m_addr, ptr::null(),\n+                                            uvll::UV_LEAVE_GROUP)\n+            }\n+        })\n     }\n-    fn native_handle(&self) -> *uvll::uv_write_t {\n-        match self { &WriteRequest(ptr) => ptr }\n+\n+    fn loop_multicast_locally(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            uvll::uv_udp_set_multicast_loop(self.handle,\n+                                            1 as c_int)\n+        })\n     }\n-}\n \n-pub struct UdpSendRequest(*uvll::uv_udp_send_t);\n-impl Request for UdpSendRequest { }\n+    fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            uvll::uv_udp_set_multicast_loop(self.handle,\n+                                            0 as c_int)\n+        })\n+    }\n \n-impl UdpSendRequest {\n-    pub fn new() -> UdpSendRequest {\n-        let send_handle = unsafe { malloc_req(UV_UDP_SEND) };\n-        assert!(send_handle.is_not_null());\n-        UdpSendRequest(send_handle as *uvll::uv_udp_send_t)\n+    fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            uvll::uv_udp_set_multicast_ttl(self.handle,\n+                                           ttl as c_int)\n+        })\n     }\n \n-    pub fn handle(&self) -> UdpWatcher {\n-        let send_request_handle = unsafe {\n-            uvll::get_udp_handle_from_send_req(self.native_handle())\n-        };\n-        NativeHandle::from_native_handle(send_request_handle)\n+    fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            uvll::uv_udp_set_ttl(self.handle, ttl as c_int)\n+        })\n     }\n \n-    pub fn delete(self) {\n-        unsafe { free_req(self.native_handle() as *c_void) }\n+    fn hear_broadcasts(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            uvll::uv_udp_set_broadcast(self.handle,\n+                                       1 as c_int)\n+        })\n     }\n-}\n \n-impl NativeHandle<*uvll::uv_udp_send_t> for UdpSendRequest {\n-    fn from_native_handle(handle: *uvll::uv_udp_send_t) -> UdpSendRequest {\n-        UdpSendRequest(handle)\n+    fn ignore_broadcasts(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        status_to_io_result(unsafe {\n+            uvll::uv_udp_set_broadcast(self.handle,\n+                                       0 as c_int)\n+        })\n     }\n-    fn native_handle(&self) -> *uvll::uv_udp_send_t {\n-        match self { &UdpSendRequest(ptr) => ptr }\n+}\n+\n+impl Drop for UdpWatcher {\n+    fn drop(&mut self) {\n+        // Send ourselves home to close this handle (blocking while doing so).\n+        let (_m, sched) = self.fire_missiles_sched();\n+        let mut slot = None;\n+        unsafe {\n+            uvll::set_data_for_uv_handle(self.handle, &slot);\n+            uvll::uv_close(self.handle, close_cb);\n+        }\n+        do sched.deschedule_running_task_and_then |_, task| {\n+            slot = Some(task);\n+        }\n+\n+        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+            let slot: &mut Option<BlockedTask> = unsafe {\n+                cast::transmute(uvll::get_data_for_uv_handle(handle))\n+            };\n+            let sched: ~Scheduler = Local::take();\n+            sched.resume_blocked_task_immediately(slot.take_unwrap());\n+        }\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+/// UV request support\n+////////////////////////////////////////////////////////////////////////////////\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "2a41dd9efe19bccf099ad5f6216c18292225a79d", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=584b3593485ef144de7217de19ac8a98766c0532", "patch": "@@ -19,7 +19,7 @@ use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::tube::Tube;\n \n use stream::StreamWatcher;\n-use super::{Loop, UvError, NativeHandle, uv_error_to_io_error, UvHandle};\n+use super::{Loop, UvError, NativeHandle, uv_error_to_io_error, UvHandle, Request};\n use uvio::HomingIO;\n use uvll;\n \n@@ -79,23 +79,26 @@ impl PipeWatcher {\n             result: Option<Result<PipeWatcher, UvError>>,\n         }\n         let mut cx = Ctx { task: None, result: None };\n-        let req = unsafe { uvll::malloc_req(uvll::UV_CONNECT) };\n-        unsafe { uvll::set_data_for_req(req, &cx as *Ctx) }\n+        let req = Request::new(uvll::UV_CONNECT);\n+        unsafe {\n+            uvll::set_data_for_req(req.handle, &cx as *Ctx);\n+            uvll::uv_pipe_connect(req.handle,\n+                                  PipeWatcher::alloc(loop_, false),\n+                                  name.with_ref(|p| p),\n+                                  connect_cb)\n+        }\n+        req.defuse();\n \n         let sched: ~Scheduler = Local::take();\n         do sched.deschedule_running_task_and_then |_, task| {\n             cx.task = Some(task);\n-            unsafe {\n-                uvll::uv_pipe_connect(req,\n-                                      PipeWatcher::alloc(loop_, false),\n-                                      name.with_ref(|p| p),\n-                                      connect_cb)\n-            }\n         }\n         assert!(cx.task.is_none());\n         return cx.result.take().expect(\"pipe connect needs a result\");\n \n         extern fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {\n+            let _req = Request::wrap(req);\n+            if status == uvll::ECANCELED { return }\n             unsafe {\n                 let cx: &mut Ctx = cast::transmute(uvll::get_data_for_req(req));\n                 let stream = uvll::get_stream_handle_from_connect_req(req);\n@@ -106,7 +109,6 @@ impl PipeWatcher {\n                         Err(UvError(n))\n                     }\n                 });\n-                uvll::free_req(req);\n \n                 let sched: ~Scheduler = Local::take();\n                 sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n@@ -201,6 +203,7 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n             assert_eq!(unsafe { uvll::uv_accept(server, client) }, 0);\n             Ok(~PipeWatcher::new(client) as ~RtioPipe)\n         }\n+        uvll::ECANCELED => return,\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n "}, {"sha": "7b44c350f13de7996055ad0e5d198d34a03ae1c2", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=584b3593485ef144de7217de19ac8a98766c0532", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::Cell;\n use std::libc::c_int;\n use std::libc;\n use std::ptr;\n@@ -58,8 +57,7 @@ impl Process {\n             }\n         }\n \n-        let ret_io = Cell::new(ret_io);\n-        do with_argv(config.program, config.args) |argv| {\n+        let ret = do with_argv(config.program, config.args) |argv| {\n             do with_env(config.env) |envp| {\n                 let options = uvll::uv_process_options_t {\n                     exit_cb: on_exit,\n@@ -89,14 +87,19 @@ impl Process {\n                             exit_status: None,\n                             term_signal: None,\n                         };\n-                        Ok((process.install(), ret_io.take()))\n+                        Ok(process.install())\n                     }\n                     err => {\n                         unsafe { uvll::free_handle(handle) }\n                         Err(UvError(err))\n                     }\n                 }\n             }\n+        };\n+\n+        match ret {\n+            Ok(p) => Ok((p, ret_io)),\n+            Err(e) => Err(e),\n         }\n     }\n }"}, {"sha": "01bc02a50be900e269779258394f4a4b2da45cc4", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=584b3593485ef144de7217de19ac8a98766c0532", "patch": "@@ -15,7 +15,7 @@ use std::rt::BlockedTask;\n use std::rt::local::Local;\n use std::rt::sched::Scheduler;\n \n-use super::{UvError, Buf, slice_to_uv_buf};\n+use super::{UvError, Buf, slice_to_uv_buf, Request};\n use uvll;\n \n // This is a helper structure which is intended to get embedded into other\n@@ -29,17 +29,17 @@ pub struct StreamWatcher {\n     // every call to uv_write(). Ideally this would be a stack-allocated\n     // structure, but currently we don't have mappings for all the structures\n     // defined in libuv, so we're foced to malloc this.\n-    priv last_write_req: Option<*uvll::uv_write_t>,\n+    priv last_write_req: Option<Request>,\n }\n \n struct ReadContext {\n     buf: Option<Buf>,\n-    result: Option<Result<uint, UvError>>,\n+    result: ssize_t,\n     task: Option<BlockedTask>,\n }\n \n struct WriteContext {\n-    result: Option<Result<(), UvError>>,\n+    result: c_int,\n     task: Option<BlockedTask>,\n }\n \n@@ -72,7 +72,7 @@ impl StreamWatcher {\n             0 => {\n                 let mut rcx = ReadContext {\n                     buf: Some(slice_to_uv_buf(buf)),\n-                    result: None,\n+                    result: 0,\n                     task: None,\n                 };\n                 unsafe {\n@@ -82,7 +82,10 @@ impl StreamWatcher {\n                 do scheduler.deschedule_running_task_and_then |_sched, task| {\n                     rcx.task = Some(task);\n                 }\n-                rcx.result.take().expect(\"no result in read stream?\")\n+                match rcx.result {\n+                    n if n < 0 => Err(UvError(n as c_int)),\n+                    n => Ok(n as uint),\n+                }\n             }\n             n => Err(UvError(n))\n         }\n@@ -91,27 +94,29 @@ impl StreamWatcher {\n     pub fn write(&mut self, buf: &[u8]) -> Result<(), UvError> {\n         // Prepare the write request, either using a cached one or allocating a\n         // new one\n-        let req = match self.last_write_req {\n-            Some(req) => req,\n-            None => unsafe { uvll::malloc_req(uvll::UV_WRITE) },\n-        };\n-        self.last_write_req = Some(req);\n-        let mut wcx = WriteContext { result: None, task: None, };\n-        unsafe { uvll::set_data_for_req(req, &wcx as *WriteContext) }\n+        if self.last_write_req.is_none() {\n+            self.last_write_req = Some(Request::new(uvll::UV_WRITE));\n+        }\n+        let req = self.last_write_req.get_ref();\n \n         // Send off the request, but be careful to not block until we're sure\n         // that the write reqeust is queued. If the reqeust couldn't be queued,\n         // then we should return immediately with an error.\n         match unsafe {\n-            uvll::uv_write(req, self.handle, [slice_to_uv_buf(buf)], write_cb)\n+            uvll::uv_write(req.handle, self.handle, [slice_to_uv_buf(buf)],\n+                           write_cb)\n         } {\n             0 => {\n+                let mut wcx = WriteContext { result: 0, task: None, };\n+                req.set_data(&wcx);\n                 let scheduler: ~Scheduler = Local::take();\n                 do scheduler.deschedule_running_task_and_then |_sched, task| {\n                     wcx.task = Some(task);\n                 }\n-                assert!(wcx.task.is_none());\n-                wcx.result.take().expect(\"no result in write stream?\")\n+                match wcx.result {\n+                    0 => Ok(()),\n+                    n => Err(UvError(n)),\n+                }\n             }\n             n => Err(UvError(n)),\n         }\n@@ -124,12 +129,6 @@ impl StreamWatcher {\n     // synchronously (the task is blocked) or asynchronously (the task is not\n     // block, but the handle is still deallocated).\n     pub fn close(&mut self, synchronous: bool) {\n-        // clean up the cached write request if we have one\n-        match self.last_write_req {\n-            Some(req) => unsafe { uvll::free_req(req) },\n-            None => {}\n-        }\n-\n         if synchronous {\n             let mut closing_task = None;\n             unsafe {\n@@ -186,31 +185,24 @@ extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: Buf) {\n     // XXX: Is there a performance impact to calling\n     // stop here?\n     unsafe { assert_eq!(uvll::uv_read_stop(handle), 0); }\n+    rcx.result = nread;\n \n-    assert!(rcx.result.is_none());\n-    rcx.result = Some(match nread {\n-        n if n < 0 => Err(UvError(n as c_int)),\n-        n => Ok(n as uint),\n-    });\n-\n-    let task = rcx.task.take().expect(\"read_cb needs a task\");\n     let scheduler: ~Scheduler = Local::take();\n-    scheduler.resume_blocked_task_immediately(task);\n+    scheduler.resume_blocked_task_immediately(rcx.task.take_unwrap());\n }\n \n // Unlike reading, the WriteContext is stored in the uv_write_t request. Like\n // reading, however, all this does is wake up the blocked task after squirreling\n // away the error code as a result.\n extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n+    if status == uvll::ECANCELED { return }\n     // Remember to not free the request because it is re-used between writes on\n     // the same stream.\n-    unsafe {\n-        let wcx: &mut WriteContext = cast::transmute(uvll::get_data_for_req(req));\n-        wcx.result = Some(match status {\n-            0 => Ok(()),\n-            n => Err(UvError(n)),\n-        });\n-        let sched: ~Scheduler = Local::take();\n-        sched.resume_blocked_task_immediately(wcx.task.take_unwrap());\n-    }\n+    let req = Request::wrap(req);\n+    let wcx: &mut WriteContext = unsafe { cast::transmute(req.get_data()) };\n+    wcx.result = status;\n+\n+    let sched: ~Scheduler = Local::take();\n+    sched.resume_blocked_task_immediately(wcx.task.take_unwrap());\n+    req.defuse();\n }"}, {"sha": "46731993bc7b6c69397f85037d33ef7cc0ae6d59", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=584b3593485ef144de7217de19ac8a98766c0532", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::Cell;\n use std::comm::{oneshot, stream, PortOne, ChanOne, SendDeferred};\n use std::libc::c_int;\n use std::rt::BlockedTask;\n@@ -77,21 +76,19 @@ impl RtioTimer for TimerWatcher {\n \n     fn oneshot(&mut self, msecs: u64) -> PortOne<()> {\n         let (port, chan) = oneshot();\n-        let chan = Cell::new(chan);\n \n         let _m = self.fire_missiles();\n-        self.action = Some(SendOnce(chan.take()));\n+        self.action = Some(SendOnce(chan));\n         self.start(msecs, 0);\n \n         return port;\n     }\n \n     fn period(&mut self, msecs: u64) -> Port<()> {\n         let (port, chan) = stream();\n-        let chan = Cell::new(chan);\n \n         let _m = self.fire_missiles();\n-        self.action = Some(SendMany(chan.take()));\n+        self.action = Some(SendMany(chan));\n         self.start(msecs, msecs);\n \n         return port;"}, {"sha": "d0a160ba8ce9e94fe29adbc7720c7cdda94619c7", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 14, "deletions": 543, "changes": 557, "blob_url": "https://github.com/rust-lang/rust/blob/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=584b3593485ef144de7217de19ac8a98766c0532", "patch": "@@ -11,22 +11,17 @@\n use std::c_str::CString;\n use std::cast::transmute;\n use std::cast;\n-use std::cell::Cell;\n-use std::clone::Clone;\n use std::comm::{SharedChan, GenericChan};\n use std::libc;\n-use std::libc::{c_int, c_uint, c_void};\n-use std::ptr;\n+use std::libc::c_int;\n use std::str;\n use std::rt::io;\n use std::rt::io::IoError;\n-use std::rt::io::net::ip::{SocketAddr, IpAddr};\n-use std::rt::io::{standard_error, OtherIoError};\n+use std::rt::io::net::ip::SocketAddr;\n use std::rt::io::process::ProcessConfig;\n use std::rt::local::Local;\n use std::rt::rtio::*;\n use std::rt::sched::{Scheduler, SchedHandle};\n-use std::rt::tube::Tube;\n use std::rt::task::Task;\n use std::path::Path;\n use std::libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n@@ -45,9 +40,7 @@ use ai = std::rt::io::net::addrinfo;\n \n use super::*;\n use idle::IdleWatcher;\n-use net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n use addrinfo::GetAddrInfoRequest;\n-use pipe::PipeListener;\n \n // XXX we should not be calling uvll functions in here.\n \n@@ -137,47 +130,6 @@ impl Drop for HomingMissile {\n     }\n }\n \n-enum SocketNameKind {\n-    TcpPeer,\n-    Tcp,\n-    Udp\n-}\n-\n-fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n-                                                 handle: U) -> Result<SocketAddr, IoError> {\n-    let getsockname = match sk {\n-        TcpPeer => uvll::tcp_getpeername,\n-        Tcp     => uvll::tcp_getsockname,\n-        Udp     => uvll::udp_getsockname,\n-    };\n-\n-    // Allocate a sockaddr_storage\n-    // since we don't know if it's ipv4 or ipv6\n-    let r_addr = unsafe { uvll::malloc_sockaddr_storage() };\n-\n-    let r = unsafe {\n-        getsockname(handle.native_handle() as *c_void, r_addr as *uvll::sockaddr_storage)\n-    };\n-\n-    if r != 0 {\n-        let status = status_to_maybe_uv_error(r);\n-        return Err(uv_error_to_io_error(status.unwrap()));\n-    }\n-\n-    let addr = unsafe {\n-        if uvll::is_ip6_addr(r_addr as *uvll::sockaddr) {\n-            net::uv_socket_addr_to_socket_addr(UvIpv6SocketAddr(r_addr as *uvll::sockaddr_in6))\n-        } else {\n-            net::uv_socket_addr_to_socket_addr(UvIpv4SocketAddr(r_addr as *uvll::sockaddr_in))\n-        }\n-    };\n-\n-    unsafe { uvll::free_sockaddr_storage(r_addr); }\n-\n-    Ok(addr)\n-\n-}\n-\n // Obviously an Event Loop is always home.\n pub struct UvEventLoop {\n     priv uvio: UvIoFactory\n@@ -251,97 +203,26 @@ impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n     // It would probably be better to return a future\n-    fn tcp_connect(&mut self, addr: SocketAddr) -> Result<~RtioTcpStream, IoError> {\n-        // Create a cell in the task to hold the result. We will fill\n-        // the cell before resuming the task.\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~RtioTcpStream, IoError>> = &result_cell;\n-\n-        // Block this task and take ownership, switch to scheduler context\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-\n-                let mut tcp = TcpWatcher::new(self.uv_loop());\n-                let task_cell = Cell::new(task);\n-\n-                // Wait for a connection\n-                do tcp.connect(addr) |stream, status| {\n-                    match status {\n-                        None => {\n-                            let tcp = NativeHandle::from_native_handle(stream.native_handle());\n-                            let home = get_handle_to_current_scheduler!();\n-                            let res = Ok(~UvTcpStream { watcher: tcp, home: home }\n-                                                as ~RtioTcpStream);\n-\n-                            // Store the stream in the task's stack\n-                            unsafe { (*result_cell_ptr).put_back(res); }\n-\n-                            // Context switch\n-                            let scheduler: ~Scheduler = Local::take();\n-                            scheduler.resume_blocked_task_immediately(task_cell.take());\n-                        }\n-                        Some(_) => {\n-                            let task_cell = Cell::new(task_cell.take());\n-                            do stream.close {\n-                                let res = Err(uv_error_to_io_error(status.unwrap()));\n-                                unsafe { (*result_cell_ptr).put_back(res); }\n-                                let scheduler: ~Scheduler = Local::take();\n-                                scheduler.resume_blocked_task_immediately(task_cell.take());\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n+    fn tcp_connect(&mut self, addr: SocketAddr)\n+        -> Result<~RtioTcpStream, IoError>\n+    {\n+        match TcpWatcher::connect(self.uv_loop(), addr) {\n+            Ok(t) => Ok(~t as ~RtioTcpStream),\n+            Err(e) => Err(uv_error_to_io_error(e)),\n         }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n     }\n \n     fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListener, IoError> {\n-        let mut watcher = TcpWatcher::new(self.uv_loop());\n-        match watcher.bind(addr) {\n-            Ok(_) => {\n-                let home = get_handle_to_current_scheduler!();\n-                Ok(~UvTcpListener::new(watcher, home) as ~RtioTcpListener)\n-            }\n-            Err(uverr) => {\n-                do task::unkillable { // FIXME(#8674)\n-                    let scheduler: ~Scheduler = Local::take();\n-                    do scheduler.deschedule_running_task_and_then |_, task| {\n-                        let task_cell = Cell::new(task);\n-                        do watcher.as_stream().close {\n-                            let scheduler: ~Scheduler = Local::take();\n-                            scheduler.resume_blocked_task_immediately(task_cell.take());\n-                        }\n-                    }\n-                    Err(uv_error_to_io_error(uverr))\n-                }\n-            }\n+        match TcpListener::bind(self.uv_loop(), addr) {\n+            Ok(t) => Ok(t as ~RtioTcpListener),\n+            Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocket, IoError> {\n-        let mut watcher = UdpWatcher::new(self.uv_loop());\n-        match watcher.bind(addr) {\n-            Ok(_) => {\n-                let home = get_handle_to_current_scheduler!();\n-                Ok(~UvUdpSocket { watcher: watcher, home: home } as ~RtioUdpSocket)\n-            }\n-            Err(uverr) => {\n-                do task::unkillable { // FIXME(#8674)\n-                    let scheduler: ~Scheduler = Local::take();\n-                    do scheduler.deschedule_running_task_and_then |_, task| {\n-                        let task_cell = Cell::new(task);\n-                        do watcher.close {\n-                            let scheduler: ~Scheduler = Local::take();\n-                            scheduler.resume_blocked_task_immediately(task_cell.take());\n-                        }\n-                    }\n-                    Err(uv_error_to_io_error(uverr))\n-                }\n-            }\n+        match UdpWatcher::bind(self.uv_loop(), addr) {\n+            Ok(u) => Ok(~u as ~RtioUdpSocket),\n+            Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n@@ -487,416 +368,6 @@ impl IoFactory for UvIoFactory {\n     }\n }\n \n-pub struct UvTcpListener {\n-    priv watcher : TcpWatcher,\n-    priv home: SchedHandle,\n-}\n-\n-impl HomingIO for UvTcpListener {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl UvTcpListener {\n-    fn new(watcher: TcpWatcher, home: SchedHandle) -> UvTcpListener {\n-        UvTcpListener { watcher: watcher, home: home }\n-    }\n-}\n-\n-impl Drop for UvTcpListener {\n-    fn drop(&mut self) {\n-        let (_m, sched) = self.fire_homing_missile_sched();\n-        do sched.deschedule_running_task_and_then |_, task| {\n-            let task = Cell::new(task);\n-            do self.watcher.as_stream().close {\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task.take());\n-            }\n-        }\n-    }\n-}\n-\n-impl RtioSocket for UvTcpListener {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        let _m = self.fire_homing_missile();\n-        socket_name(Tcp, self.watcher)\n-    }\n-}\n-\n-impl RtioTcpListener for UvTcpListener {\n-    fn listen(mut ~self) -> Result<~RtioTcpAcceptor, IoError> {\n-        let _m = self.fire_homing_missile();\n-        let acceptor = ~UvTcpAcceptor::new(*self);\n-        let incoming = Cell::new(acceptor.incoming.clone());\n-        let mut stream = acceptor.listener.watcher.as_stream();\n-        let res = do stream.listen |mut server, status| {\n-            do incoming.with_mut_ref |incoming| {\n-                let inc = match status {\n-                    Some(_) => Err(standard_error(OtherIoError)),\n-                    None => {\n-                        let inc = TcpWatcher::new(&server.event_loop());\n-                        // first accept call in the callback guarenteed to succeed\n-                        server.accept(inc.as_stream());\n-                        let home = get_handle_to_current_scheduler!();\n-                        Ok(~UvTcpStream { watcher: inc, home: home }\n-                                as ~RtioTcpStream)\n-                    }\n-                };\n-                incoming.send(inc);\n-            }\n-        };\n-        match res {\n-            Ok(()) => Ok(acceptor as ~RtioTcpAcceptor),\n-            Err(e) => Err(uv_error_to_io_error(e)),\n-        }\n-    }\n-}\n-\n-pub struct UvTcpAcceptor {\n-    priv listener: UvTcpListener,\n-    priv incoming: Tube<Result<~RtioTcpStream, IoError>>,\n-}\n-\n-impl HomingIO for UvTcpAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n-}\n-\n-impl UvTcpAcceptor {\n-    fn new(listener: UvTcpListener) -> UvTcpAcceptor {\n-        UvTcpAcceptor { listener: listener, incoming: Tube::new() }\n-    }\n-}\n-\n-impl RtioSocket for UvTcpAcceptor {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        let _m = self.fire_homing_missile();\n-        socket_name(Tcp, self.listener.watcher)\n-    }\n-}\n-\n-fn accept_simultaneously(stream: StreamWatcher, a: int) -> Result<(), IoError> {\n-    let r = unsafe {\n-        uvll::uv_tcp_simultaneous_accepts(stream.native_handle(), a as c_int)\n-    };\n-    status_to_io_result(r)\n-}\n-\n-impl RtioTcpAcceptor for UvTcpAcceptor {\n-    fn accept(&mut self) -> Result<~RtioTcpStream, IoError> {\n-        let _m = self.fire_homing_missile();\n-        self.incoming.recv()\n-    }\n-\n-    fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        accept_simultaneously(self.listener.watcher.as_stream(), 1)\n-    }\n-\n-    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        accept_simultaneously(self.listener.watcher.as_stream(), 0)\n-    }\n-}\n-\n-fn read_stream(mut watcher: StreamWatcher,\n-               scheduler: ~Scheduler,\n-               buf: &mut [u8]) -> Result<uint, IoError> {\n-    let result_cell = Cell::new_empty();\n-    let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n-\n-    let uv_buf = slice_to_uv_buf(buf);\n-    do scheduler.deschedule_running_task_and_then |_sched, task| {\n-        let task_cell = Cell::new(task);\n-        // XXX: We shouldn't reallocate these callbacks every\n-        // call to read\n-        let alloc: AllocCallback = |_| uv_buf;\n-        do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n-\n-            // Stop reading so that no read callbacks are\n-            // triggered before the user calls `read` again.\n-            // XXX: Is there a performance impact to calling\n-            // stop here?\n-            watcher.read_stop();\n-\n-            let result = if status.is_none() {\n-                assert!(nread >= 0);\n-                Ok(nread as uint)\n-            } else {\n-                Err(uv_error_to_io_error(status.unwrap()))\n-            };\n-\n-            unsafe { (*result_cell_ptr).put_back(result); }\n-\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.resume_blocked_task_immediately(task_cell.take());\n-        }\n-    }\n-\n-    assert!(!result_cell.is_empty());\n-    result_cell.take()\n-}\n-\n-fn write_stream(mut watcher: StreamWatcher,\n-                scheduler: ~Scheduler,\n-                buf: &[u8]) -> Result<(), IoError> {\n-    let result_cell = Cell::new_empty();\n-    let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-    let buf_ptr: *&[u8] = &buf;\n-    do scheduler.deschedule_running_task_and_then |_, task| {\n-        let task_cell = Cell::new(task);\n-        let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-        do watcher.write(buf) |_watcher, status| {\n-            let result = if status.is_none() {\n-                Ok(())\n-            } else {\n-                Err(uv_error_to_io_error(status.unwrap()))\n-            };\n-\n-            unsafe { (*result_cell_ptr).put_back(result); }\n-\n-            let scheduler: ~Scheduler = Local::take();\n-            scheduler.resume_blocked_task_immediately(task_cell.take());\n-        }\n-    }\n-\n-    assert!(!result_cell.is_empty());\n-    result_cell.take()\n-}\n-\n-pub struct UvTcpStream {\n-    priv watcher: TcpWatcher,\n-    priv home: SchedHandle,\n-}\n-\n-impl HomingIO for UvTcpStream {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl Drop for UvTcpStream {\n-    fn drop(&mut self) {\n-        let (_m, sched) = self.fire_homing_missile_sched();\n-        do sched.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do self.watcher.as_stream().close {\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n-        }\n-    }\n-}\n-\n-impl RtioSocket for UvTcpStream {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        let _m = self.fire_homing_missile();\n-        socket_name(Tcp, self.watcher)\n-    }\n-}\n-\n-impl RtioTcpStream for UvTcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        let (_m, scheduler) = self.fire_homing_missile_sched();\n-        read_stream(self.watcher.as_stream(), scheduler, buf)\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let (_m, scheduler) = self.fire_homing_missile_sched();\n-        write_stream(self.watcher.as_stream(), scheduler, buf)\n-    }\n-\n-    fn peer_name(&mut self) -> Result<SocketAddr, IoError> {\n-        let _m = self.fire_homing_missile();\n-        socket_name(TcpPeer, self.watcher)\n-    }\n-\n-    fn control_congestion(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_tcp_nodelay(self.watcher.native_handle(), 0 as c_int)\n-        })\n-    }\n-\n-    fn nodelay(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_tcp_nodelay(self.watcher.native_handle(), 1 as c_int)\n-        })\n-    }\n-\n-    fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_tcp_keepalive(self.watcher.native_handle(), 1 as c_int,\n-                                   delay_in_seconds as c_uint)\n-        })\n-    }\n-\n-    fn letdie(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_tcp_keepalive(self.watcher.native_handle(),\n-                                   0 as c_int, 0 as c_uint)\n-        })\n-    }\n-}\n-\n-pub struct UvUdpSocket {\n-    priv watcher: UdpWatcher,\n-    priv home: SchedHandle,\n-}\n-\n-impl HomingIO for UvUdpSocket {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl Drop for UvUdpSocket {\n-    fn drop(&mut self) {\n-        let (_m, scheduler) = self.fire_homing_missile_sched();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do self.watcher.close {\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n-        }\n-    }\n-}\n-\n-impl RtioSocket for UvUdpSocket {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        let _m = self.fire_homing_missile();\n-        socket_name(Udp, self.watcher)\n-    }\n-}\n-\n-impl RtioUdpSocket for UvUdpSocket {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, SocketAddr), IoError> {\n-        let (_m, scheduler) = self.fire_homing_missile_sched();\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n-\n-        let buf_ptr: *&mut [u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n-            do self.watcher.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n-                let _ = flags; // /XXX add handling for partials?\n-\n-                watcher.recv_stop();\n-\n-                let result = match status {\n-                    None => {\n-                        assert!(nread >= 0);\n-                        Ok((nread as uint, addr))\n-                    }\n-                    Some(err) => Err(uv_error_to_io_error(err)),\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n-        }\n-\n-        assert!(!result_cell.is_empty());\n-        result_cell.take()\n-    }\n-\n-    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n-        let (_m, scheduler) = self.fire_homing_missile_sched();\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let buf_ptr: *&[u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-            do self.watcher.send(buf, dst) |_watcher, status| {\n-\n-                let result = match status {\n-                    None => Ok(()),\n-                    Some(err) => Err(uv_error_to_io_error(err)),\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n-        }\n-\n-        assert!(!result_cell.is_empty());\n-        result_cell.take()\n-    }\n-\n-    fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            do multi.to_str().with_c_str |m_addr| {\n-                uvll::uv_udp_set_membership(self.watcher.native_handle(),\n-                                            m_addr, ptr::null(),\n-                                            uvll::UV_JOIN_GROUP)\n-            }\n-        })\n-    }\n-\n-    fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            do multi.to_str().with_c_str |m_addr| {\n-                uvll::uv_udp_set_membership(self.watcher.native_handle(),\n-                                            m_addr, ptr::null(),\n-                                            uvll::UV_LEAVE_GROUP)\n-            }\n-        })\n-    }\n-\n-    fn loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_udp_set_multicast_loop(self.watcher.native_handle(),\n-                                            1 as c_int)\n-        })\n-    }\n-\n-    fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_udp_set_multicast_loop(self.watcher.native_handle(),\n-                                            0 as c_int)\n-        })\n-    }\n-\n-    fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_udp_set_multicast_ttl(self.watcher.native_handle(),\n-                                           ttl as c_int)\n-        })\n-    }\n-\n-    fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_udp_set_ttl(self.watcher.native_handle(), ttl as c_int)\n-        })\n-    }\n-\n-    fn hear_broadcasts(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_udp_set_broadcast(self.watcher.native_handle(),\n-                                       1 as c_int)\n-        })\n-    }\n-\n-    fn ignore_broadcasts(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        status_to_io_result(unsafe {\n-            uvll::uv_udp_set_broadcast(self.watcher.native_handle(),\n-                                       0 as c_int)\n-        })\n-    }\n-}\n-\n // this function is full of lies\n unsafe fn local_io() -> &'static mut IoFactory {\n     do Local::borrow |sched: &mut Scheduler| {"}, {"sha": "42e0f58d87d41bdfc3ab1ba4ea67cf660d30ca97", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/584b3593485ef144de7217de19ac8a98766c0532/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=584b3593485ef144de7217de19ac8a98766c0532", "patch": "@@ -53,6 +53,7 @@ pub mod errors {\n     pub static ENOTCONN: c_int = -4054;\n     pub static EPIPE: c_int = -4048;\n     pub static ECONNABORTED: c_int = -4080;\n+    pub static ECANCELED: c_int = -4082;\n }\n #[cfg(not(windows))]\n pub mod errors {\n@@ -65,6 +66,7 @@ pub mod errors {\n     pub static ENOTCONN: c_int = -libc::ENOTCONN;\n     pub static EPIPE: c_int = -libc::EPIPE;\n     pub static ECONNABORTED: c_int = -libc::ECONNABORTED;\n+    pub static ECANCELED : c_int = -libc::ECANCELED;\n }\n \n pub static PROCESS_SETUID: c_int = 1 << 0;\n@@ -127,6 +129,7 @@ pub struct uv_stdio_container_t {\n }\n \n pub type uv_handle_t = c_void;\n+pub type uv_req_t = c_void;\n pub type uv_loop_t = c_void;\n pub type uv_idle_t = c_void;\n pub type uv_tcp_t = c_void;"}]}