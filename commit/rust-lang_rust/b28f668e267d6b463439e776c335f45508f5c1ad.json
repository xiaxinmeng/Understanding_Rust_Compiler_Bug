{"sha": "b28f668e267d6b463439e776c335f45508f5c1ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyOGY2NjhlMjY3ZDZiNDYzNDM5ZTc3NmMzMzVmNDU1MDhmNWMxYWQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-22T19:44:40Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:32Z"}, "message": "rustc: move size, align & primitive_align from Abi::Aggregate to layout.", "tree": {"sha": "85338b3542a4772a8040de9398cce2aee5310c84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85338b3542a4772a8040de9398cce2aee5310c84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b28f668e267d6b463439e776c335f45508f5c1ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b28f668e267d6b463439e776c335f45508f5c1ad", "html_url": "https://github.com/rust-lang/rust/commit/b28f668e267d6b463439e776c335f45508f5c1ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b28f668e267d6b463439e776c335f45508f5c1ad/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b723af284a22e6c0f2d85c104067138c33f8859d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b723af284a22e6c0f2d85c104067138c33f8859d", "html_url": "https://github.com/rust-lang/rust/commit/b723af284a22e6c0f2d85c104067138c33f8859d"}], "stats": {"total": 682, "additions": 299, "deletions": 383}, "files": [{"sha": "dbad77b904ee05aa4426e616fe7d8e20abb319cc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 125, "deletions": 186, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -747,10 +747,7 @@ pub enum Abi {\n     Aggregate {\n         /// If true, the size is exact, otherwise it's only a lower bound.\n         sized: bool,\n-        packed: bool,\n-        align: Align,\n-        primitive_align: Align,\n-        size: Size\n+        packed: bool\n     }\n }\n \n@@ -770,68 +767,6 @@ impl Abi {\n             Abi::Aggregate { packed, .. } => packed\n         }\n     }\n-\n-    /// Returns true if the type is a ZST and not unsized.\n-    pub fn is_zst(&self) -> bool {\n-        match *self {\n-            Abi::Scalar(_) => false,\n-            Abi::Vector { count, .. } => count == 0,\n-            Abi::Aggregate { sized, size, .. } => sized && size.bytes() == 0\n-        }\n-    }\n-\n-    pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n-        let dl = cx.data_layout();\n-\n-        match *self {\n-            Abi::Scalar(value) => value.size(dl),\n-\n-            Abi::Vector { element, count } => {\n-                let element_size = element.size(dl);\n-                let vec_size = match element_size.checked_mul(count, dl) {\n-                    Some(size) => size,\n-                    None => bug!(\"Layout::size({:?}): {} * {} overflowed\",\n-                                 self, element_size.bytes(), count)\n-                };\n-                vec_size.abi_align(self.align(dl))\n-            }\n-\n-            Abi::Aggregate { size, .. } => size\n-        }\n-    }\n-\n-    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n-        let dl = cx.data_layout();\n-\n-        match *self {\n-            Abi::Scalar(value) => value.align(dl),\n-\n-            Abi::Vector { element, count } => {\n-                let elem_size = element.size(dl);\n-                let vec_size = match elem_size.checked_mul(count, dl) {\n-                    Some(size) => size,\n-                    None => bug!(\"Layout::align({:?}): {} * {} overflowed\",\n-                                 self, elem_size.bytes(), count)\n-                };\n-                dl.vector_align(vec_size)\n-            }\n-\n-            Abi::Aggregate { align, .. } => align\n-        }\n-    }\n-\n-    pub fn size_and_align<C: HasDataLayout>(&self, cx: C) -> (Size, Align) {\n-        (self.size(cx), self.align(cx))\n-    }\n-\n-    /// Returns alignment before repr alignment is applied\n-    pub fn primitive_align<C: HasDataLayout>(&self, cx: C) -> Align {\n-        match *self {\n-            Abi::Aggregate { primitive_align, .. } => primitive_align,\n-\n-            _ => self.align(cx.data_layout())\n-        }\n-    }\n }\n \n /// Type layout, from which size and alignment can be cheaply computed.\n@@ -911,6 +846,9 @@ pub struct CachedLayout {\n     pub layout: Layout,\n     pub fields: FieldPlacement,\n     pub abi: Abi,\n+    pub align: Align,\n+    pub primitive_align: Align,\n+    pub size: Size\n }\n \n fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -947,12 +885,16 @@ impl<'a, 'tcx> Layout {\n                         -> Result<&'tcx CachedLayout, LayoutError<'tcx>> {\n         let cx = (tcx, param_env);\n         let dl = cx.data_layout();\n-        let scalar = |value| {\n+        let scalar = |value: Primitive| {\n+            let align = value.align(dl);\n             tcx.intern_layout(CachedLayout {\n                 variant_index: None,\n                 layout: Layout::Scalar,\n                 fields: FieldPlacement::Union(0),\n-                abi: Abi::Scalar(value)\n+                abi: Abi::Scalar(value),\n+                size: value.size(dl),\n+                align,\n+                primitive_align: align\n             })\n         };\n         #[derive(Copy, Clone, Debug)]\n@@ -1005,11 +947,11 @@ impl<'a, 'tcx> Layout {\n                 if end > 0 {\n                     let optimizing  = &mut inverse_memory_index[..end];\n                     if sort_ascending {\n-                        optimizing.sort_by_key(|&x| fields[x as usize].align(dl).abi());\n+                        optimizing.sort_by_key(|&x| fields[x as usize].align.abi());\n                     } else {\n                         optimizing.sort_by(| &a, &b | {\n-                            let a = fields[a as usize].align(dl).abi();\n-                            let b = fields[b as usize].align(dl).abi();\n+                            let a = fields[a as usize].align.abi();\n+                            let b = fields[b as usize].align.abi();\n                             b.cmp(&a)\n                         });\n                     }\n@@ -1046,16 +988,15 @@ impl<'a, 'tcx> Layout {\n \n                 // Invariant: offset < dl.obj_size_bound() <= 1<<61\n                 if !packed {\n-                    let field_align = field.align(dl);\n-                    align = align.max(field_align);\n-                    primitive_align = primitive_align.max(field.primitive_align(dl));\n-                    offset = offset.abi_align(field_align);\n+                    offset = offset.abi_align(field.align);\n+                    align = align.max(field.align);\n+                    primitive_align = primitive_align.max(field.primitive_align);\n                 }\n \n-                debug!(\"univariant offset: {:?} field: {:?} {:?}\", offset, field, field.size(dl));\n+                debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n                 offsets[*i as usize] = offset;\n \n-                offset = offset.checked_add(field.size(dl), dl)\n+                offset = offset.checked_add(field.size, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n             }\n \n@@ -1095,11 +1036,11 @@ impl<'a, 'tcx> Layout {\n                 },\n                 abi: Abi::Aggregate {\n                     sized,\n-                    packed,\n-                    align,\n-                    primitive_align,\n-                    size: min_size.abi_align(align)\n-                }\n+                    packed\n+                },\n+                align,\n+                primitive_align,\n+                size: min_size.abi_align(align)\n             })\n         };\n         let univariant = |fields: &[TyLayout], repr: &ReprOptions, kind| {\n@@ -1137,11 +1078,11 @@ impl<'a, 'tcx> Layout {\n                 fields,\n                 abi: Abi::Aggregate {\n                     sized: true,\n-                    packed: false,\n-                    align,\n-                    primitive_align: align,\n-                    size: (meta_offset + metadata.size(dl)).abi_align(align)\n-                }\n+                    packed: false\n+                },\n+                align,\n+                primitive_align: align,\n+                size: (meta_offset + metadata.size(dl)).abi_align(align)\n             }))\n         };\n \n@@ -1183,25 +1124,24 @@ impl<'a, 'tcx> Layout {\n                 }\n \n                 let element = cx.layout_of(element)?;\n-                let element_size = element.size(dl);\n                 let count = count.val.to_const_int().unwrap().to_u64().unwrap();\n-                let size = element_size.checked_mul(count, dl)\n+                let size = element.size.checked_mul(count, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n \n                 tcx.intern_layout(CachedLayout {\n                     variant_index: None,\n                     layout: Layout::Array,\n                     fields: FieldPlacement::Array {\n-                        stride: element_size,\n+                        stride: element.size,\n                         count\n                     },\n                     abi: Abi::Aggregate {\n                         sized: true,\n-                        packed: false,\n-                        align: element.align(dl),\n-                        primitive_align: element.primitive_align(dl),\n-                        size\n-                    }\n+                        packed: false\n+                    },\n+                    align: element.align,\n+                    primitive_align: element.primitive_align,\n+                    size\n                 })\n             }\n             ty::TySlice(element) => {\n@@ -1210,16 +1150,16 @@ impl<'a, 'tcx> Layout {\n                     variant_index: None,\n                     layout: Layout::Array,\n                     fields: FieldPlacement::Array {\n-                        stride: element.size(dl),\n+                        stride: element.size,\n                         count: 0\n                     },\n                     abi: Abi::Aggregate {\n                         sized: false,\n-                        packed: false,\n-                        align: element.align(dl),\n-                        primitive_align: element.primitive_align(dl),\n-                        size: Size::from_bytes(0)\n-                    }\n+                        packed: false\n+                    },\n+                    align: element.align,\n+                    primitive_align: element.primitive_align,\n+                    size: Size::from_bytes(0)\n                 })\n             }\n             ty::TyStr => {\n@@ -1232,11 +1172,11 @@ impl<'a, 'tcx> Layout {\n                     },\n                     abi: Abi::Aggregate {\n                         sized: false,\n-                        packed: false,\n-                        align: dl.i8_align,\n-                        primitive_align: dl.i8_align,\n-                        size: Size::from_bytes(0)\n-                    }\n+                        packed: false\n+                    },\n+                    align: dl.i8_align,\n+                    primitive_align: dl.i8_align,\n+                    size: Size::from_bytes(0)\n                 })\n             }\n \n@@ -1283,23 +1223,34 @@ impl<'a, 'tcx> Layout {\n             // SIMD vector types.\n             ty::TyAdt(def, ..) if def.repr.simd() => {\n                 let count = ty.simd_size(tcx) as u64;\n-                let element = ty.simd_type(tcx);\n-                let element = match cx.layout_of(element)?.abi {\n+                let element = cx.layout_of(ty.simd_type(tcx))?;\n+                let element_scalar = match element.abi {\n                     Abi::Scalar(value) => value,\n                     _ => {\n                         tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` with \\\n                                                 a non-machine element type `{}`\",\n-                                                ty, element));\n+                                                ty, element.ty));\n                     }\n                 };\n+                let size = element.size.checked_mul(count, dl)\n+                    .ok_or(LayoutError::SizeOverflow(ty))?;\n+                let align = dl.vector_align(size);\n+                let size = size.abi_align(align);\n+\n                 tcx.intern_layout(CachedLayout {\n                     variant_index: None,\n                     layout: Layout::Vector,\n                     fields: FieldPlacement::Array {\n-                        stride: element.size(tcx),\n+                        stride: element.size,\n                         count\n                     },\n-                    abi: Abi::Vector { element, count }\n+                    abi: Abi::Vector {\n+                        element: element_scalar,\n+                        count\n+                    },\n+                    size,\n+                    align,\n+                    primitive_align: align\n                 })\n             }\n \n@@ -1344,10 +1295,10 @@ impl<'a, 'tcx> Layout {\n                         assert!(!field.is_unsized());\n \n                         if !packed {\n-                            align = align.max(field.align(dl));\n-                            primitive_align = primitive_align.max(field.primitive_align(dl));\n+                            align = align.max(field.align);\n+                            primitive_align = primitive_align.max(field.primitive_align);\n                         }\n-                        size = cmp::max(size, field.size(dl));\n+                        size = cmp::max(size, field.size);\n                     }\n \n                     return Ok(tcx.intern_layout(CachedLayout {\n@@ -1356,11 +1307,11 @@ impl<'a, 'tcx> Layout {\n                         fields: FieldPlacement::Union(variants[0].len()),\n                         abi: Abi::Aggregate {\n                             sized: true,\n-                            packed,\n-                            align,\n-                            primitive_align,\n-                            size: size.abi_align(align)\n-                        }\n+                            packed\n+                        },\n+                        align,\n+                        primitive_align,\n+                        size: size.abi_align(align)\n                     }));\n                 }\n \n@@ -1411,27 +1362,26 @@ impl<'a, 'tcx> Layout {\n                                 st[0].variant_index = Some(0);\n                                 st[1].variant_index = Some(1);\n                                 let offset = st[i].fields.offset(field_index) + offset;\n-                                let mut abi = st[i].abi;\n-                                if offset.bytes() == 0 && discr.size(dl) == abi.size(dl) {\n-                                    abi = Abi::Scalar(discr);\n-                                }\n+                                let CachedLayout {\n+                                    mut abi,\n+                                    size,\n+                                    mut align,\n+                                    mut primitive_align,\n+                                    ..\n+                                } = st[i];\n+\n                                 let mut discr_align = discr.align(dl);\n-                                match abi {\n-                                    Abi::Aggregate {\n-                                        ref mut align,\n-                                        ref mut primitive_align,\n-                                        ref mut packed,\n-                                        ..\n-                                    } => {\n-                                        if offset.abi_align(discr_align) != offset {\n-                                            *packed = true;\n-                                            discr_align = dl.i8_align;\n-                                        }\n-                                        *align = align.max(discr_align);\n-                                        *primitive_align = primitive_align.max(discr_align);\n+                                if offset.bytes() == 0 && discr.size(dl) == size {\n+                                    abi = Abi::Scalar(discr);\n+                                } else if let Abi::Aggregate { ref mut packed, .. } = abi {\n+                                    if offset.abi_align(discr_align) != offset {\n+                                        *packed = true;\n+                                        discr_align = dl.i8_align;\n                                     }\n-                                    _ => {}\n                                 }\n+                                align = align.max(discr_align);\n+                                primitive_align = primitive_align.max(discr_align);\n+\n                                 return Ok(tcx.intern_layout(CachedLayout {\n                                     variant_index: None,\n                                     layout: Layout::NullablePointer {\n@@ -1444,7 +1394,10 @@ impl<'a, 'tcx> Layout {\n                                         offsets: vec![offset],\n                                         memory_index: vec![0]\n                                     },\n-                                    abi\n+                                    abi,\n+                                    size,\n+                                    align,\n+                                    primitive_align\n                                 }));\n                             }\n                         }\n@@ -1477,15 +1430,14 @@ impl<'a, 'tcx> Layout {\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant.\n                     for field in st.fields.index_by_increasing_offset().map(|j| field_layouts[j]) {\n-                        let field_align = field.align(dl);\n-                        if !field.is_zst() || field_align.abi() != 1 {\n-                            start_align = start_align.min(field_align);\n+                        if !field.is_zst() || field.align.abi() != 1 {\n+                            start_align = start_align.min(field.align);\n                             break;\n                         }\n                     }\n-                    size = cmp::max(size, st.abi.size(dl));\n-                    align = align.max(st.abi.align(dl));\n-                    primitive_align = primitive_align.max(st.abi.primitive_align(dl));\n+                    size = cmp::max(size, st.size);\n+                    align = align.max(st.align);\n+                    primitive_align = primitive_align.max(st.primitive_align);\n                     Ok(st)\n                 }).collect::<Result<Vec<_>, _>>()?;\n \n@@ -1534,18 +1486,17 @@ impl<'a, 'tcx> Layout {\n                     let old_ity_size = min_ity.size();\n                     let new_ity_size = ity.size();\n                     for variant in &mut variants {\n-                        match (&mut variant.fields, &mut variant.abi) {\n-                            (&mut FieldPlacement::Arbitrary { ref mut offsets, .. },\n-                             &mut Abi::Aggregate { ref mut size, .. }) => {\n+                        match variant.fields {\n+                            FieldPlacement::Arbitrary { ref mut offsets, .. } => {\n                                 for i in offsets {\n                                     if *i <= old_ity_size {\n                                         assert_eq!(*i, old_ity_size);\n                                         *i = new_ity_size;\n                                     }\n                                 }\n                                 // We might be making the struct larger.\n-                                if *size <= old_ity_size {\n-                                    *size = new_ity_size;\n+                                if variant.size <= old_ity_size {\n+                                    variant.size = new_ity_size;\n                                 }\n                             }\n                             _ => bug!()\n@@ -1572,12 +1523,12 @@ impl<'a, 'tcx> Layout {\n                     } else {\n                         Abi::Aggregate {\n                             sized: true,\n-                            packed: false,\n-                            align,\n-                            primitive_align,\n-                            size\n+                            packed: false\n                         }\n-                    }\n+                    },\n+                    align,\n+                    primitive_align,\n+                    size\n                 })\n             }\n \n@@ -1629,12 +1580,10 @@ impl<'a, 'tcx> Layout {\n         // (delay format until we actually need it)\n         let record = |kind, opt_discr_size, variants| {\n             let type_desc = format!(\"{:?}\", ty);\n-            let overall_size = layout.size(tcx);\n-            let align = layout.align(tcx);\n             tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n                                                               type_desc,\n-                                                              align,\n-                                                              overall_size,\n+                                                              layout.align,\n+                                                              layout.size,\n                                                               opt_discr_size,\n                                                               variants);\n         };\n@@ -1670,16 +1619,15 @@ impl<'a, 'tcx> Layout {\n                     }\n                     Ok(field_layout) => {\n                         let offset = layout.fields.offset(i);\n-                        let field_size = field_layout.size(tcx);\n-                        let field_end = offset + field_size;\n+                        let field_end = offset + field_layout.size;\n                         if min_size < field_end {\n                             min_size = field_end;\n                         }\n                         session::FieldInfo {\n                             name: name.to_string(),\n                             offset: offset.bytes(),\n-                            size: field_size.bytes(),\n-                            align: field_layout.align(tcx).abi(),\n+                            size: field_layout.size.bytes(),\n+                            align: field_layout.align.abi(),\n                         }\n                     }\n                 }\n@@ -1692,9 +1640,9 @@ impl<'a, 'tcx> Layout {\n                 } else {\n                     session::SizeKind::Exact\n                 },\n-                align: layout.align(tcx).abi(),\n+                align: layout.align.abi(),\n                 size: if min_size.bytes() == 0 {\n-                    layout.size(tcx).bytes()\n+                    layout.size.bytes()\n                 } else {\n                     min_size.bytes()\n                 },\n@@ -1795,7 +1743,7 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n         // First try computing a static layout.\n         let err = match (tcx, param_env).layout_of(ty) {\n             Ok(layout) => {\n-                return Ok(SizeSkeleton::Known(layout.size(tcx)));\n+                return Ok(SizeSkeleton::Known(layout.size));\n             }\n             Err(err) => err\n         };\n@@ -2174,24 +2122,15 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n \n     /// Returns true if the type is a ZST and not unsized.\n     pub fn is_zst(&self) -> bool {\n-        self.abi.is_zst()\n-    }\n-\n-    pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n-        self.abi.size(cx)\n-    }\n-\n-    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n-        self.abi.align(cx)\n-    }\n-\n-    pub fn size_and_align<C: HasDataLayout>(&self, cx: C) -> (Size, Align) {\n-        self.abi.size_and_align(cx)\n+        match self.abi {\n+            Abi::Scalar(_) => false,\n+            Abi::Vector { count, .. } => count == 0,\n+            Abi::Aggregate { sized, .. } => sized && self.size.bytes() == 0\n+        }\n     }\n \n-    /// Returns alignment before repr alignment is applied\n-    pub fn primitive_align<C: HasDataLayout>(&self, cx: C) -> Align {\n-        self.abi.primitive_align(cx)\n+    pub fn size_and_align(&self) -> (Size, Align) {\n+        (self.size, self.align)\n     }\n \n     /// Find the offset of a non-zero leaf field, starting from\n@@ -2331,12 +2270,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n                 element.hash_stable(hcx, hasher);\n                 count.hash_stable(hcx, hasher);\n             }\n-            Aggregate { packed, sized, size, align, primitive_align } => {\n+            Aggregate { packed, sized } => {\n                 packed.hash_stable(hcx, hasher);\n                 sized.hash_stable(hcx, hasher);\n-                size.hash_stable(hcx, hasher);\n-                align.hash_stable(hcx, hasher);\n-                primitive_align.hash_stable(hcx, hasher);\n             }\n         }\n     }\n@@ -2346,7 +2282,10 @@ impl_stable_hash_for!(struct ::ty::layout::CachedLayout {\n     variant_index,\n     layout,\n     fields,\n-    abi\n+    abi,\n+    size,\n+    align,\n+    primitive_align\n });\n \n impl_stable_hash_for!(enum ::ty::layout::Integer {"}, {"sha": "a548c1df16e28987e1e5d5c94e716935ef41c234", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -320,12 +320,12 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             };\n             match &tcx.item_name(def_id)[..] {\n                 \"size_of\" => {\n-                    let size = layout_of(substs.type_at(0))?.size(tcx).bytes();\n+                    let size = layout_of(substs.type_at(0))?.size.bytes();\n                     return Ok(mk_const(Integral(Usize(ConstUsize::new(size,\n                         tcx.sess.target.usize_ty).unwrap()))));\n                 }\n                 \"min_align_of\" => {\n-                    let align = layout_of(substs.type_at(0))?.align(tcx).abi();\n+                    let align = layout_of(substs.type_at(0))?.align.abi();\n                     return Ok(mk_const(Integral(Usize(ConstUsize::new(align,\n                         tcx.sess.target.usize_ty).unwrap()))));\n                 }"}, {"sha": "761ca662178f919588ff917a6e7fa632c8ec802b", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -757,15 +757,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                     let discr_size = discr.size(cx.tcx).bytes();\n \n                     debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n-                      t, layout.size(cx.tcx).bytes(), layout);\n+                      t, layout.size.bytes(), layout);\n \n                     let (largest, slargest, largest_index) = enum_definition.variants\n                         .iter()\n                         .zip(variants)\n                         .map(|(variant, variant_layout)| {\n                             // Subtract the size of the enum discriminant\n-                            let bytes = variant_layout.abi.size(cx.tcx)\n-                                .bytes()\n+                            let bytes = variant_layout.size.bytes()\n                                 .saturating_sub(discr_size);\n \n                             debug!(\"- variant `{}` is {} bytes large\", variant.node.name, bytes);"}, {"sha": "4b7856f857b778b10637d570279343e41f05936a", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -626,7 +626,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n fn type_size_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_env: ty::ParamEnv<'tcx>,\n                           ty: Ty<'tcx>) -> Option<u64> {\n-    (tcx, param_env).layout_of(ty).ok().map(|layout| layout.size(tcx).bytes())\n+    (tcx, param_env).layout_of(ty).ok().map(|layout| layout.size.bytes())\n }\n \n fn subst_and_normalize<'a, 'tcx: 'a>("}, {"sha": "2659ca2f0d575e8c8ac8ee6e001f403109638641", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -296,14 +296,14 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n                 };\n                 Some(Reg {\n                     kind,\n-                    size: self.size(ccx)\n+                    size: self.size\n                 })\n             }\n \n             layout::Abi::Vector { .. } => {\n                 Some(Reg {\n                     kind: RegKind::Vector,\n-                    size: self.size(ccx)\n+                    size: self.size\n                 })\n             }\n \n@@ -345,7 +345,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n                     }\n \n                     // Keep track of the offset (without padding).\n-                    let size = field.size(ccx);\n+                    let size = field.size;\n                     if is_union {\n                         total = cmp::max(total, size);\n                     } else {\n@@ -354,7 +354,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n                 }\n \n                 // There needs to be no padding.\n-                if total != self.size(ccx) {\n+                if total != self.size {\n                     None\n                 } else {\n                     result\n@@ -446,7 +446,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         }\n     }\n \n-    pub fn make_indirect(&mut self, ccx: &CrateContext<'a, 'tcx>) {\n+    pub fn make_indirect(&mut self) {\n         assert!(self.nested.is_empty());\n         assert_eq!(self.kind, ArgKind::Direct);\n \n@@ -458,7 +458,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         // program-invisible so can't possibly capture\n         self.attrs.set(ArgAttribute::NoAlias)\n                   .set(ArgAttribute::NoCapture)\n-                  .set_dereferenceable(self.layout.size(ccx));\n+                  .set_dereferenceable(self.layout.size);\n \n         self.kind = ArgKind::Indirect;\n     }\n@@ -520,15 +520,15 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         }\n         let ccx = bcx.ccx;\n         if self.is_indirect() {\n-            let llsz = C_usize(ccx, self.layout.size(ccx).bytes());\n-            base::call_memcpy(bcx, dst.llval, val, llsz, self.layout.align(ccx));\n+            let llsz = C_usize(ccx, self.layout.size.bytes());\n+            base::call_memcpy(bcx, dst.llval, val, llsz, self.layout.align);\n         } else if let Some(ty) = self.cast {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n                 let cast_dst = bcx.pointercast(dst.llval, ty.llvm_type(ccx).ptr_to());\n-                bcx.store(val, cast_dst, Some(self.layout.align(ccx)));\n+                bcx.store(val, cast_dst, Some(self.layout.align));\n             } else {\n                 // The actual return type is a struct, but the ABI\n                 // adaptation code has cast it into some scalar type.  The\n@@ -556,8 +556,8 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 base::call_memcpy(bcx,\n                                   bcx.pointercast(dst.llval, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n-                                  C_usize(ccx, self.layout.size(ccx).bytes()),\n-                                  self.layout.align(ccx).min(ty.align(ccx)));\n+                                  C_usize(ccx, self.layout.size.bytes()),\n+                                  self.layout.align.min(ty.align(ccx)));\n \n                 bcx.lifetime_end(llscratch, scratch_size);\n             }\n@@ -828,7 +828,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                     _ => return\n                 }\n \n-                let size = arg.layout.size(ccx);\n+                let size = arg.layout.size;\n \n                 if let Some(unit) = arg.layout.homogeneous_aggregate(ccx) {\n                     // Replace newtypes with their inner-most type.\n@@ -851,7 +851,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 }\n \n                 if size > layout::Pointer.size(ccx) {\n-                    arg.make_indirect(ccx);\n+                    arg.make_indirect();\n                 } else {\n                     // We want to pass small aggregates as immediates, but using\n                     // a LLVM aggregate type for this leads to bad optimizations,\n@@ -897,7 +897,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n             \"x86_64\" => if abi == Abi::SysV64 {\n                 cabi_x86_64::compute_abi_info(ccx, self);\n             } else if abi == Abi::Win64 || ccx.sess().target.target.options.is_like_windows {\n-                cabi_x86_win64::compute_abi_info(ccx, self);\n+                cabi_x86_win64::compute_abi_info(self);\n             } else {\n                 cabi_x86_64::compute_abi_info(ccx, self);\n             },\n@@ -910,12 +910,12 @@ impl<'a, 'tcx> FnType<'tcx> {\n             \"s390x\" => cabi_s390x::compute_abi_info(ccx, self),\n             \"asmjs\" => cabi_asmjs::compute_abi_info(ccx, self),\n             \"wasm32\" => cabi_asmjs::compute_abi_info(ccx, self),\n-            \"msp430\" => cabi_msp430::compute_abi_info(ccx, self),\n+            \"msp430\" => cabi_msp430::compute_abi_info(self),\n             \"sparc\" => cabi_sparc::compute_abi_info(ccx, self),\n             \"sparc64\" => cabi_sparc64::compute_abi_info(ccx, self),\n-            \"nvptx\" => cabi_nvptx::compute_abi_info(ccx, self),\n-            \"nvptx64\" => cabi_nvptx64::compute_abi_info(ccx, self),\n-            \"hexagon\" => cabi_hexagon::compute_abi_info(ccx, self),\n+            \"nvptx\" => cabi_nvptx::compute_abi_info(self),\n+            \"nvptx64\" => cabi_nvptx64::compute_abi_info(self),\n+            \"hexagon\" => cabi_hexagon::compute_abi_info(self),\n             a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n "}, {"sha": "3c6626cfa7f3a6e1ecaff8c663219755fac42dfc", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -406,15 +406,13 @@ pub fn memcpy_ty<'a, 'tcx>(\n     layout: TyLayout<'tcx>,\n     align: Option<Align>,\n ) {\n-    let ccx = bcx.ccx;\n-\n-    let size = layout.size(ccx).bytes();\n+    let size = layout.size.bytes();\n     if size == 0 {\n         return;\n     }\n \n-    let align = align.unwrap_or_else(|| layout.align(ccx));\n-    call_memcpy(bcx, dst, src, C_usize(ccx, size), align);\n+    let align = align.unwrap_or(layout.align);\n+    call_memcpy(bcx, dst, src, C_usize(bcx.ccx, size), align);\n }\n \n pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,"}, {"sha": "d5f341f9685833dd987b2e0b1d94afed5b8ba875", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -14,7 +14,7 @@ use context::CrateContext;\n fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n-        let size = arg.layout.size(ccx);\n+        let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members.\n         if size > unit.size.checked_mul(4, ccx).unwrap() {\n@@ -47,7 +47,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         ret.cast_to(uniform);\n         return;\n     }\n-    let size = ret.layout.size(ccx);\n+    let size = ret.layout.size;\n     let bits = size.bits();\n     if bits <= 128 {\n         let unit = if bits <= 8 {\n@@ -66,7 +66,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         });\n         return;\n     }\n-    ret.make_indirect(ccx);\n+    ret.make_indirect();\n }\n \n fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n@@ -78,7 +78,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n         arg.cast_to(uniform);\n         return;\n     }\n-    let size = arg.layout.size(ccx);\n+    let size = arg.layout.size;\n     let bits = size.bits();\n     if bits <= 128 {\n         let unit = if bits <= 8 {\n@@ -97,7 +97,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n         });\n         return;\n     }\n-    arg.make_indirect(ccx);\n+    arg.make_indirect();\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {"}, {"sha": "438053d63b51d37bd638ad3c699464cc5b17ef17", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -15,7 +15,7 @@ use llvm::CallConv;\n fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n-        let size = arg.layout.size(ccx);\n+        let size = arg.layout.size;\n \n         // Ensure we have at most four uniquely addressable members.\n         if size > unit.size.checked_mul(4, ccx).unwrap() {\n@@ -52,7 +52,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         }\n     }\n \n-    let size = ret.layout.size(ccx);\n+    let size = ret.layout.size;\n     let bits = size.bits();\n     if bits <= 32 {\n         let unit = if bits <= 8 {\n@@ -68,7 +68,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         });\n         return;\n     }\n-    ret.make_indirect(ccx);\n+    ret.make_indirect();\n }\n \n fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>, vfp: bool) {\n@@ -84,8 +84,8 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n         }\n     }\n \n-    let align = arg.layout.align(ccx).abi();\n-    let total = arg.layout.size(ccx);\n+    let align = arg.layout.align.abi();\n+    let total = arg.layout.size;\n     arg.cast_to(Uniform {\n         unit: if align <= 4 { Reg::i32() } else { Reg::i64() },\n         total"}, {"sha": "da13b75c414afc1525963b5f2304cb1a23e0f8bc", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -19,7 +19,7 @@ use context::CrateContext;\n fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n     if ret.layout.is_aggregate() {\n         if let Some(unit) = ret.layout.homogeneous_aggregate(ccx) {\n-            let size = ret.layout.size(ccx);\n+            let size = ret.layout.size;\n             if unit.size == size {\n                 ret.cast_to(Uniform {\n                     unit,\n@@ -29,13 +29,13 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n             }\n         }\n \n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty(arg: &mut ArgType) {\n     if arg.layout.is_aggregate() {\n-        arg.make_indirect(ccx);\n+        arg.make_indirect();\n         arg.attrs.set(ArgAttribute::ByVal);\n     }\n }\n@@ -47,6 +47,6 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(arg);\n     }\n }"}, {"sha": "7e7e483fea0c0cd340cdddf514a0303c6b61e6ec", "filename": "src/librustc_trans/cabi_hexagon.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_hexagon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_hexagon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_hexagon.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -11,33 +11,32 @@\n #![allow(non_upper_case_globals)]\n \n use abi::{FnType, ArgType, LayoutExt};\n-use context::CrateContext;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n-    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 64 {\n-        ret.make_indirect(ccx);\n+fn classify_ret_ty(ret: &mut ArgType) {\n+    if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {\n+        ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n-    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 64 {\n-        arg.make_indirect(ccx);\n+fn classify_arg_ty(arg: &mut ArgType) {\n+    if arg.layout.is_aggregate() && arg.layout.size.bits() > 64 {\n+        arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info(fty: &mut FnType) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(arg);\n     }\n }"}, {"sha": "fe61670a1086f93157f8f8c02ee6e835f37bfbc0", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -19,15 +19,15 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n         *offset += ccx.tcx().data_layout.pointer_size;\n     }\n }\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n     let dl = &ccx.tcx().data_layout;\n-    let size = arg.layout.size(ccx);\n-    let align = arg.layout.align(ccx).max(dl.i32_align).min(dl.i64_align);\n+    let size = arg.layout.size;\n+    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n     if arg.layout.is_aggregate() {\n         arg.cast_to(Uniform {"}, {"sha": "16d0cfe072d5772d2070df703fbc7ff6dad219fe", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -19,15 +19,15 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n     } else {\n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n         *offset += ccx.tcx().data_layout.pointer_size;\n     }\n }\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n     let dl = &ccx.tcx().data_layout;\n-    let size = arg.layout.size(ccx);\n-    let align = arg.layout.align(ccx).max(dl.i32_align).min(dl.i64_align);\n+    let size = arg.layout.size;\n+    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n     if arg.layout.is_aggregate() {\n         arg.cast_to(Uniform {"}, {"sha": "d270886a19cd11c835da1cccde7230d153ed6f3f", "filename": "src/librustc_trans/cabi_msp430.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_msp430.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_msp430.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_msp430.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -12,39 +12,38 @@\n // http://www.ti.com/lit/an/slaa534/slaa534.pdf\n \n use abi::{ArgType, FnType, LayoutExt};\n-use context::CrateContext;\n \n // 3.5 Structures or Unions Passed and Returned by Reference\n //\n // \"Structures (including classes) and unions larger than 32 bits are passed and\n // returned by reference. To pass a structure or union by reference, the caller\n // places its address in the appropriate location: either in a register or on\n // the stack, according to its position in the argument list. (..)\"\n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n-    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 32 {\n-        ret.make_indirect(ccx);\n+fn classify_ret_ty(ret: &mut ArgType) {\n+    if ret.layout.is_aggregate() && ret.layout.size.bits() > 32 {\n+        ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(16);\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n-    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 32 {\n-        arg.make_indirect(ccx);\n+fn classify_arg_ty(arg: &mut ArgType) {\n+    if arg.layout.is_aggregate() && arg.layout.size.bits() > 32 {\n+        arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(16);\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info(fty: &mut FnType) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(arg);\n     }\n }"}, {"sha": "69cfc690a9f9d311888547718118789a8868b391", "filename": "src/librustc_trans/cabi_nvptx.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -12,33 +12,32 @@\n // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n \n use abi::{ArgType, FnType, LayoutExt};\n-use context::CrateContext;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n-    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 32 {\n-        ret.make_indirect(ccx);\n+fn classify_ret_ty(ret: &mut ArgType) {\n+    if ret.layout.is_aggregate() && ret.layout.size.bits() > 32 {\n+        ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n-    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 32 {\n-        arg.make_indirect(ccx);\n+fn classify_arg_ty(arg: &mut ArgType) {\n+    if arg.layout.is_aggregate() && arg.layout.size.bits() > 32 {\n+        arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info(fty: &mut FnType) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(arg);\n     }\n }"}, {"sha": "4d76c156038001569228bc8ca9770de4b65dc62d", "filename": "src/librustc_trans/cabi_nvptx64.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx64.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -12,33 +12,32 @@\n // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n \n use abi::{ArgType, FnType, LayoutExt};\n-use context::CrateContext;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n-    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 64 {\n-        ret.make_indirect(ccx);\n+fn classify_ret_ty(ret: &mut ArgType) {\n+    if ret.layout.is_aggregate() && ret.layout.size.bits() > 64 {\n+        ret.make_indirect();\n     } else {\n         ret.extend_integer_width_to(64);\n     }\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n-    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 64 {\n-        arg.make_indirect(ccx);\n+fn classify_arg_ty(arg: &mut ArgType) {\n+    if arg.layout.is_aggregate() && arg.layout.size.bits() > 64 {\n+        arg.make_indirect();\n     } else {\n         arg.extend_integer_width_to(64);\n     }\n }\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+pub fn compute_abi_info(fty: &mut FnType) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() {\n             continue;\n         }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(arg);\n     }\n }"}, {"sha": "c3c8c745e3a61c175b96b2abc8cc2511b6c872fe", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -19,15 +19,15 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n         *offset += ccx.tcx().data_layout.pointer_size;\n     }\n }\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n     let dl = &ccx.tcx().data_layout;\n-    let size = arg.layout.size(ccx);\n-    let align = arg.layout.align(ccx).max(dl.i32_align).min(dl.i64_align);\n+    let size = arg.layout.size;\n+    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n     if arg.layout.is_aggregate() {\n         arg.cast_to(Uniform {"}, {"sha": "2206a4fa00cc3af1ff41b49af4c9b142199604d5", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -28,25 +28,23 @@ fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                       abi: ABI)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n-        let size = arg.layout.size(ccx);\n-\n         // ELFv1 only passes one-member aggregates transparently.\n         // ELFv2 passes up to eight uniquely addressable members.\n-        if (abi == ELFv1 && size > unit.size)\n-                || size > unit.size.checked_mul(8, ccx).unwrap() {\n+        if (abi == ELFv1 && arg.layout.size > unit.size)\n+                || arg.layout.size > unit.size.checked_mul(8, ccx).unwrap() {\n             return None;\n         }\n \n         let valid_unit = match unit.kind {\n             RegKind::Integer => false,\n             RegKind::Float => true,\n-            RegKind::Vector => size.bits() == 128\n+            RegKind::Vector => arg.layout.size.bits() == 128\n         };\n \n         if valid_unit {\n             Some(Uniform {\n                 unit,\n-                total: size\n+                total: arg.layout.size\n             })\n         } else {\n             None\n@@ -62,7 +60,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n \n     // The ELFv1 ABI doesn't return aggregates in registers\n     if abi == ELFv1 {\n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n         return;\n     }\n \n@@ -71,7 +69,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         return;\n     }\n \n-    let size = ret.layout.size(ccx);\n+    let size = ret.layout.size;\n     let bits = size.bits();\n     if bits <= 128 {\n         let unit = if bits <= 8 {\n@@ -91,7 +89,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         return;\n     }\n \n-    ret.make_indirect(ccx);\n+    ret.make_indirect();\n }\n \n fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>, abi: ABI) {\n@@ -105,7 +103,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n         return;\n     }\n \n-    let size = arg.layout.size(ccx);\n+    let size = arg.layout.size;\n     let (unit, total) = match abi {\n         ELFv1 => {\n             // In ELFv1, aggregates smaller than a doubleword should appear in"}, {"sha": "9c24b637efd408f1767584247bd737027347bf4f", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -16,11 +16,11 @@ use context::CrateContext;\n \n use rustc::ty::layout::{self, TyLayout};\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n-    if !ret.layout.is_aggregate() && ret.layout.size(ccx).bits() <= 64 {\n+fn classify_ret_ty(ret: &mut ArgType) {\n+    if !ret.layout.is_aggregate() && ret.layout.size.bits() <= 64 {\n         ret.extend_integer_width_to(64);\n     } else {\n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n     }\n }\n \n@@ -41,32 +41,31 @@ fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n-    let size = arg.layout.size(ccx);\n-    if !arg.layout.is_aggregate() && size.bits() <= 64 {\n+    if !arg.layout.is_aggregate() && arg.layout.size.bits() <= 64 {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n     if is_single_fp_element(ccx, arg.layout) {\n-        match size.bytes() {\n+        match arg.layout.size.bytes() {\n             4 => arg.cast_to(Reg::f32()),\n             8 => arg.cast_to(Reg::f64()),\n-            _ => arg.make_indirect(ccx)\n+            _ => arg.make_indirect()\n         }\n     } else {\n-        match size.bytes() {\n+        match arg.layout.size.bytes() {\n             1 => arg.cast_to(Reg::i8()),\n             2 => arg.cast_to(Reg::i16()),\n             4 => arg.cast_to(Reg::i32()),\n             8 => arg.cast_to(Reg::i64()),\n-            _ => arg.make_indirect(ccx)\n+            _ => arg.make_indirect()\n         }\n     }\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(&mut fty.ret);\n     }\n \n     for arg in &mut fty.args {"}, {"sha": "fe61670a1086f93157f8f8c02ee6e835f37bfbc0", "filename": "src/librustc_trans/cabi_sparc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_sparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_sparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -19,15 +19,15 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n-        ret.make_indirect(ccx);\n+        ret.make_indirect();\n         *offset += ccx.tcx().data_layout.pointer_size;\n     }\n }\n \n fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut Size) {\n     let dl = &ccx.tcx().data_layout;\n-    let size = arg.layout.size(ccx);\n-    let align = arg.layout.align(ccx).max(dl.i32_align).min(dl.i64_align);\n+    let size = arg.layout.size;\n+    let align = arg.layout.align.max(dl.i32_align).min(dl.i64_align);\n \n     if arg.layout.is_aggregate() {\n         arg.cast_to(Uniform {"}, {"sha": "7c52e27fa67d1b2d2310e07f0090008ac0c82f61", "filename": "src/librustc_trans/cabi_sparc64.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc64.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -16,23 +16,21 @@ use context::CrateContext;\n fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n                                      -> Option<Uniform> {\n     arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n-        let size = arg.layout.size(ccx);\n-\n         // Ensure we have at most eight uniquely addressable members.\n-        if size > unit.size.checked_mul(8, ccx).unwrap() {\n+        if arg.layout.size > unit.size.checked_mul(8, ccx).unwrap() {\n             return None;\n         }\n \n         let valid_unit = match unit.kind {\n             RegKind::Integer => false,\n             RegKind::Float => true,\n-            RegKind::Vector => size.bits() == 128\n+            RegKind::Vector => arg.layout.size.bits() == 128\n         };\n \n         if valid_unit {\n             Some(Uniform {\n                 unit,\n-                total: size\n+                total: arg.layout.size\n             })\n         } else {\n             None\n@@ -50,7 +48,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n         ret.cast_to(uniform);\n         return;\n     }\n-    let size = ret.layout.size(ccx);\n+    let size = ret.layout.size;\n     let bits = size.bits();\n     if bits <= 128 {\n         let unit = if bits <= 8 {\n@@ -71,7 +69,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     }\n \n     // don't return aggregates in registers\n-    ret.make_indirect(ccx);\n+    ret.make_indirect();\n }\n \n fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n@@ -85,7 +83,7 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n         return;\n     }\n \n-    let total = arg.layout.size(ccx);\n+    let total = arg.layout.size;\n     arg.cast_to(Uniform {\n         unit: Reg::i64(),\n         total"}, {"sha": "401e75387c49df06ccbc8914a0bd4abf9dd2d393", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -50,27 +50,25 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let t = &ccx.sess().target.target;\n             if t.options.is_like_osx || t.options.is_like_windows\n                 || t.options.is_like_openbsd {\n-                let size = fty.ret.layout.size(ccx);\n-\n                 // According to Clang, everyone but MSVC returns single-element\n                 // float aggregates directly in a floating-point register.\n                 if !t.options.is_like_msvc && is_single_fp_element(ccx, fty.ret.layout) {\n-                    match size.bytes() {\n+                    match fty.ret.layout.size.bytes() {\n                         4 => fty.ret.cast_to(Reg::f32()),\n                         8 => fty.ret.cast_to(Reg::f64()),\n-                        _ => fty.ret.make_indirect(ccx)\n+                        _ => fty.ret.make_indirect()\n                     }\n                 } else {\n-                    match size.bytes() {\n+                    match fty.ret.layout.size.bytes() {\n                         1 => fty.ret.cast_to(Reg::i8()),\n                         2 => fty.ret.cast_to(Reg::i16()),\n                         4 => fty.ret.cast_to(Reg::i32()),\n                         8 => fty.ret.cast_to(Reg::i64()),\n-                        _ => fty.ret.make_indirect(ccx)\n+                        _ => fty.ret.make_indirect()\n                     }\n                 }\n             } else {\n-                fty.ret.make_indirect(ccx);\n+                fty.ret.make_indirect();\n             }\n         } else {\n             fty.ret.extend_integer_width_to(32);\n@@ -80,7 +78,7 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n         if arg.layout.is_aggregate() {\n-            arg.make_indirect(ccx);\n+            arg.make_indirect();\n             arg.attrs.set(ArgAttribute::ByVal);\n         } else {\n             arg.extend_integer_width_to(32);\n@@ -104,13 +102,12 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             // At this point we know this must be a primitive of sorts.\n             let unit = arg.layout.homogeneous_aggregate(ccx).unwrap();\n-            let size = arg.layout.size(ccx);\n-            assert_eq!(unit.size, size);\n+            assert_eq!(unit.size, arg.layout.size);\n             if unit.kind == RegKind::Float {\n                 continue;\n             }\n \n-            let size_in_regs = (size.bits() + 31) / 32;\n+            let size_in_regs = (arg.layout.size.bits() + 31) / 32;\n \n             if size_in_regs == 0 {\n                 continue;\n@@ -122,7 +119,7 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n             free_regs -= size_in_regs;\n \n-            if size.bits() <= 32 && unit.kind == RegKind::Integer {\n+            if arg.layout.size.bits() <= 32 && unit.kind == RegKind::Integer {\n                 arg.attrs.set(ArgAttribute::InReg);\n             }\n "}, {"sha": "36ac76aaaa5612110a521c7fab39be42c2ddf365", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -57,7 +57,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n                           cls: &mut [Class],\n                           off: Size)\n                           -> Result<(), Memory> {\n-        if !off.is_abi_aligned(layout.align(ccx)) {\n+        if !off.is_abi_aligned(layout.align) {\n             if !layout.is_zst() {\n                 return Err(Memory);\n             }\n@@ -106,7 +106,7 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n         Ok(())\n     }\n \n-    let n = ((arg.layout.size(ccx).bytes() + 7) / 8) as usize;\n+    let n = ((arg.layout.size.bytes() + 7) / 8) as usize;\n     if n > MAX_EIGHTBYTES {\n         return Err(Memory);\n     }\n@@ -213,7 +213,7 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType\n         };\n \n         if in_mem {\n-            arg.make_indirect(ccx);\n+            arg.make_indirect();\n             if is_arg {\n                 arg.attrs.set(ArgAttribute::ByVal);\n             } else {\n@@ -226,7 +226,7 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType\n             sse_regs -= needed_sse;\n \n             if arg.layout.is_aggregate() {\n-                let size = arg.layout.size(ccx);\n+                let size = arg.layout.size;\n                 arg.cast_to(cast_target(cls.as_ref().unwrap(), size))\n             } else {\n                 arg.extend_integer_width_to(32);"}, {"sha": "c6d0e5e3a073599f80dcb2f0ae6df1546fe4fbd3", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -9,32 +9,30 @@\n // except according to those terms.\n \n use abi::{ArgType, FnType, Reg};\n-use common::CrateContext;\n \n use rustc::ty::layout;\n \n // Win64 ABI: http://msdn.microsoft.com/en-us/library/zthk2dkh.aspx\n \n-pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n-    let fixup = |a: &mut ArgType<'tcx>| {\n-        let size = a.layout.size(ccx);\n+pub fn compute_abi_info(fty: &mut FnType) {\n+    let fixup = |a: &mut ArgType| {\n         match a.layout.abi {\n             layout::Abi::Aggregate { .. } => {\n-                match size.bits() {\n+                match a.layout.size.bits() {\n                     8 => a.cast_to(Reg::i8()),\n                     16 => a.cast_to(Reg::i16()),\n                     32 => a.cast_to(Reg::i32()),\n                     64 => a.cast_to(Reg::i64()),\n-                    _ => a.make_indirect(ccx)\n+                    _ => a.make_indirect()\n                 }\n             }\n             layout::Abi::Vector { .. } => {\n                 // FIXME(eddyb) there should be a size cap here\n                 // (probably what clang calls \"illegal vectors\").\n             }\n             layout::Abi::Scalar(_) => {\n-                if size.bytes() > 8 {\n-                    a.make_indirect(ccx);\n+                if a.layout.size.bytes() > 8 {\n+                    a.make_indirect();\n                 } else {\n                     a.extend_integer_width_to(32);\n                 }"}, {"sha": "6a7b35c05e70cbec71b3a34e581011d028b89904", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -430,16 +430,16 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 cx.tcx().mk_mut_ptr(cx.tcx().types.u8),\n                 syntax_pos::DUMMY_SP),\n             offset: layout.fields.offset(0),\n-            size: data_ptr_field.size(cx),\n-            align: data_ptr_field.align(cx),\n+            size: data_ptr_field.size,\n+            align: data_ptr_field.align,\n             flags: DIFlags::FlagArtificial,\n         },\n         MemberDescription {\n             name: \"vtable\".to_string(),\n             type_metadata: type_metadata(cx, vtable_field.ty, syntax_pos::DUMMY_SP),\n             offset: layout.fields.offset(1),\n-            size: vtable_field.size(cx),\n-            align: vtable_field.align(cx),\n+            size: vtable_field.size,\n+            align: vtable_field.align,\n             flags: DIFlags::FlagArtificial,\n         },\n     ];\n@@ -946,7 +946,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n                 f.name.to_string()\n             };\n             let field = layout.field(cx, i);\n-            let (size, align) = field.size_and_align(cx);\n+            let (size, align) = field.size_and_align();\n             MemberDescription {\n                 name,\n                 type_metadata: type_metadata(cx, field.ty, self.span),\n@@ -1062,7 +1062,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n                                       -> Vec<MemberDescription> {\n         self.variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = self.layout.field(cx, i);\n-            let (size, align) = field.size_and_align(cx);\n+            let (size, align) = field.size_and_align();\n             MemberDescription {\n                 name: f.name.to_string(),\n                 type_metadata: type_metadata(cx, field.ty, self.span),\n@@ -1153,8 +1153,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         name: \"\".to_string(),\n                         type_metadata: variant_type_metadata,\n                         offset: Size::from_bytes(0),\n-                        size: variant.size(cx),\n-                        align: variant.align(cx),\n+                        size: variant.size,\n+                        align: variant.align,\n                         flags: DIFlags::FlagZero\n                     }\n                 }).collect()\n@@ -1184,8 +1184,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                             name: \"\".to_string(),\n                             type_metadata: variant_type_metadata,\n                             offset: Size::from_bytes(0),\n-                            size: self.type_rep.size(cx),\n-                            align: self.type_rep.align(cx),\n+                            size: self.type_rep.size,\n+                            align: self.type_rep.align,\n                             flags: DIFlags::FlagZero\n                         }\n                     ]\n@@ -1230,7 +1230,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         }\n                         let inner_offset = offset - field_offset;\n                         let field = layout.field(ccx, i);\n-                        if inner_offset + size <= field.size(ccx) {\n+                        if inner_offset + size <= field.size {\n                             write!(name, \"{}$\", i).unwrap();\n                             compute_field_path(ccx, name, field, inner_offset, size);\n                         }\n@@ -1248,8 +1248,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         name,\n                         type_metadata: variant_type_metadata,\n                         offset: Size::from_bytes(0),\n-                        size: variant.size(cx),\n-                        align: variant.align(cx),\n+                        size: variant.size,\n+                        align: variant.align,\n                         flags: DIFlags::FlagZero\n                     }\n                 ]\n@@ -1443,7 +1443,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         _ => {}\n     }\n \n-    let (enum_type_size, enum_type_align) = type_rep.size_and_align(cx);\n+    let (enum_type_size, enum_type_align) = type_rep.size_and_align();\n \n     let enum_name = CString::new(enum_name).unwrap();\n     let unique_type_id_str = CString::new("}, {"sha": "6c7d7700adeb28b9b043e02c7c9a18a5ecaa4f44", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -60,7 +60,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n \n             let i = layout.fields.count() - 1;\n             let sized_size = layout.fields.offset(i).bytes();\n-            let sized_align = layout.align(ccx).abi();\n+            let sized_align = layout.align.abi();\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n             let sized_size = C_usize(ccx, sized_size);"}, {"sha": "e775c4897f7486b07bf47d47598ff89f3b09b223", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let load = bcx.load(\n                         bcx.pointercast(llslot, cast_ty.llvm_type(bcx.ccx).ptr_to()),\n-                        Some(self.fn_ty.ret.layout.align(bcx.ccx)));\n+                        Some(self.fn_ty.ret.layout.align));\n                     load\n                 } else {\n                     let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n@@ -672,7 +672,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 llval = base::to_immediate(bcx, llval, arg.layout);\n             } else if let Some(ty) = arg.cast {\n                 llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.ccx).ptr_to()),\n-                                 (align | Alignment::Packed(arg.layout.align(bcx.ccx)))\n+                                 (align | Alignment::Packed(arg.layout.align))\n                                     .non_abi());\n             } else {\n                 llval = bcx.load(llval, align.non_abi());\n@@ -892,7 +892,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let src = self.trans_operand(bcx, src);\n         let llty = src.layout.llvm_type(bcx.ccx);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n-        let align = src.layout.align(bcx.ccx).min(dst.layout.align(bcx.ccx));\n+        let align = src.layout.align.min(dst.layout.align);\n         src.val.store(bcx,\n             LvalueRef::new_sized(cast_ptr, src.layout, Alignment::Packed(align)));\n     }"}, {"sha": "45037a1f19836b3bbbac226cf3c32051d7cb41b6", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -1116,7 +1116,7 @@ fn trans_const_adt<'a, 'tcx>(\n             assert_eq!(variant_index, 0);\n             let contents = [\n                 vals[0].llval,\n-                padding(ccx, l.size(ccx) - ccx.size_of(vals[0].ty))\n+                padding(ccx, l.size - ccx.size_of(vals[0].ty))\n             ];\n \n             Const::new(C_struct(ccx, &contents, l.is_packed()), t)"}, {"sha": "f10791cae526067d26f98127f369b9b5578874c2", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -56,8 +56,8 @@ impl ops::BitOr for Alignment {\n \n impl<'a> From<TyLayout<'a>> for Alignment {\n     fn from(layout: TyLayout) -> Self {\n-        if let layout::Abi::Aggregate { packed: true, align, .. } = layout.abi {\n-            Alignment::Packed(align)\n+        if layout.is_packed() {\n+            Alignment::Packed(layout.align)\n         } else {\n             Alignment::AbiAligned\n         }\n@@ -109,7 +109,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                   -> LvalueRef<'tcx> {\n         debug!(\"alloca({:?}: {:?})\", name, layout);\n         let tmp = bcx.alloca(\n-            layout.llvm_type(bcx.ccx), name, layout.over_align(bcx.ccx));\n+            layout.llvm_type(bcx.ccx), name, layout.over_align());\n         Self::new_sized(tmp, layout, Alignment::AbiAligned)\n     }\n \n@@ -374,7 +374,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                         // than storing null to single target field.\n                         let llptr = bcx.pointercast(self.llval, Type::i8(bcx.ccx).ptr_to());\n                         let fill_byte = C_u8(bcx.ccx, 0);\n-                        let (size, align) = self.layout.size_and_align(bcx.ccx);\n+                        let (size, align) = self.layout.size_and_align();\n                         let size = C_usize(bcx.ccx, size.bytes());\n                         let align = C_u32(bcx.ccx, align.abi() as u32);\n                         base::call_memset(bcx, llptr, fill_byte, size, align, false);\n@@ -414,11 +414,11 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     }\n \n     pub fn storage_live(&self, bcx: &Builder<'a, 'tcx>) {\n-        bcx.lifetime_start(self.llval, self.layout.size(bcx.ccx));\n+        bcx.lifetime_start(self.llval, self.layout.size);\n     }\n \n     pub fn storage_dead(&self, bcx: &Builder<'a, 'tcx>) {\n-        bcx.lifetime_end(self.llval, self.layout.size(bcx.ccx));\n+        bcx.lifetime_end(self.llval, self.layout.size);\n     }\n }\n "}, {"sha": "0d183115211744c29828fbdba3c8d4df1d4d1ce4", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -107,9 +107,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 if let OperandValue::Immediate(v) = tr_elem.val {\n                     let align = dest.alignment.non_abi()\n-                        .unwrap_or_else(|| tr_elem.layout.align(bcx.ccx));\n+                        .unwrap_or(tr_elem.layout.align);\n                     let align = C_i32(bcx.ccx, align.abi() as i32);\n-                    let size = C_usize(bcx.ccx, dest.layout.size(bcx.ccx).bytes());\n+                    let size = C_usize(bcx.ccx, dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n                     if common::is_const_integral(v) && common::const_to_uint(v) == 0 {"}, {"sha": "52151035a826fac7d86b7e54e31bb08b5c52f8f2", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b28f668e267d6b463439e776c335f45508f5c1ad/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=b28f668e267d6b463439e776c335f45508f5c1ad", "patch": "@@ -50,7 +50,7 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     match layout.fields {\n         layout::FieldPlacement::Union(_) => {\n-            let size = layout.size(ccx).bytes();\n+            let size = layout.size.bytes();\n             let fill = Type::array(&Type::i8(ccx), size);\n             match name {\n                 None => {\n@@ -84,8 +84,6 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                              layout: TyLayout<'tcx>) -> Vec<Type> {\n     debug!(\"struct_llfields: {:#?}\", layout);\n-    let align = layout.align(ccx);\n-    let size = layout.size(ccx);\n     let field_count = layout.fields.count();\n \n     let mut offset = Size::from_bytes(0);\n@@ -105,52 +103,50 @@ fn struct_llfields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         if layout.is_packed() {\n             assert_eq!(padding.bytes(), 0);\n         } else {\n-            let field_align = field.align(ccx);\n-            assert!(field_align.abi() <= align.abi(),\n+            assert!(field.align.abi() <= layout.align.abi(),\n                     \"non-packed type has field with larger align ({}): {:#?}\",\n-                    field_align.abi(), layout);\n+                    field.align.abi(), layout);\n         }\n \n-        offset = target_offset + field.size(ccx);\n+        offset = target_offset + field.size;\n     }\n     if !layout.is_unsized() && field_count > 0 {\n-        if offset > size {\n+        if offset > layout.size {\n             bug!(\"layout: {:#?} stride: {:?} offset: {:?}\",\n-                 layout, size, offset);\n+                 layout, layout.size, offset);\n         }\n-        let padding = size - offset;\n+        let padding = layout.size - offset;\n         debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n-               padding, offset, size);\n+               padding, offset, layout.size);\n         result.push(Type::array(&Type::i8(ccx), padding.bytes()));\n         assert!(result.len() == 1 + field_count * 2);\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n-               offset, size);\n+               offset, layout.size);\n     }\n \n     result\n }\n \n impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     pub fn align_of(&self, ty: Ty<'tcx>) -> Align {\n-        self.layout_of(ty).align(self)\n+        self.layout_of(ty).align\n     }\n \n     pub fn size_of(&self, ty: Ty<'tcx>) -> Size {\n-        self.layout_of(ty).size(self)\n+        self.layout_of(ty).size\n     }\n \n     pub fn size_and_align_of(&self, ty: Ty<'tcx>) -> (Size, Align) {\n-        let layout = self.layout_of(ty);\n-        (layout.size(self), layout.align(self))\n+        self.layout_of(ty).size_and_align()\n     }\n }\n \n pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_immediate(&self) -> bool;\n     fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n     fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n-    fn over_align(&self, ccx: &CrateContext) -> Option<Align>;\n+    fn over_align(&self) -> Option<Align>;\n     fn llvm_field_index(&self, index: usize) -> u64;\n }\n \n@@ -251,11 +247,9 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         }\n     }\n \n-    fn over_align(&self, ccx: &CrateContext) -> Option<Align> {\n-        let align = self.align(ccx);\n-        let primitive_align = self.primitive_align(ccx);\n-        if align != primitive_align {\n-            Some(align)\n+    fn over_align(&self) -> Option<Align> {\n+        if self.align != self.primitive_align {\n+            Some(self.align)\n         } else {\n             None\n         }"}]}