{"sha": "9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "node_id": "C_kwDOAAsO6NoAKDlmNGQ1ZDJhMjg4NDllYzBlY2IyOTc2ZGRjOTk0NmY2NWI2MjZmZTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-29T22:49:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-29T22:49:04Z"}, "message": "Auto merge of #101167 - matthiaskrgr:rollup-yt3jdmp, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #100898 (Do not report too many expr field candidates)\n - #101056 (Add the syntax of references to their documentation summary.)\n - #101106 (Rustdoc-Json: Retain Stripped Modules when they are imported, not when they have items)\n - #101131 (CTFE: exposing pointers and calling extern fn is just impossible)\n - #101141 (Simplify `get_trait_ref` fn used for `virtual_function_elimination`)\n - #101146 (Various changes to logging of borrowck-related code)\n - #101156 (Remove `Sync` requirement from lint pass objects)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "659d6d0e27f56b1f2ff7e2a386c49e88899895de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/659d6d0e27f56b1f2ff7e2a386c49e88899895de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "html_url": "https://github.com/rust-lang/rust/commit/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365", "html_url": "https://github.com/rust-lang/rust/commit/bc4b39c271bbd36736cbf1c0a1ac23d5df38d365"}, {"sha": "bf42ba41a44dc9bd74b0e2abe2954ad0d818d3ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf42ba41a44dc9bd74b0e2abe2954ad0d818d3ed", "html_url": "https://github.com/rust-lang/rust/commit/bf42ba41a44dc9bd74b0e2abe2954ad0d818d3ed"}], "stats": {"total": 543, "additions": 341, "deletions": 202}, "files": [{"sha": "c94dfe39b6903aea57a90c87d3871358e04531a1", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -105,8 +105,8 @@ impl<'tcx> fmt::Debug for OutlivesConstraint<'tcx> {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             formatter,\n-            \"({:?}: {:?}) due to {:?} ({:?})\",\n-            self.sup, self.sub, self.locations, self.variance_info\n+            \"({:?}: {:?}) due to {:?} ({:?}) ({:?})\",\n+            self.sup, self.sub, self.locations, self.variance_info, self.category,\n         )\n     }\n }"}, {"sha": "5971f7623f215a4c3ed8c1a1832d8b31f32ba134", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -1119,20 +1119,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// short a lifetime. (But sometimes it is more useful to report\n     /// it as a more direct conflict between the execution of a\n     /// `Drop::drop` with an aliasing borrow.)\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn report_borrowed_value_does_not_live_long_enough(\n         &mut self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         place_span: (Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n     ) {\n-        debug!(\n-            \"report_borrowed_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}\\\n-             )\",\n-            location, borrow, place_span, kind\n-        );\n-\n         let drop_span = place_span.1;\n         let root_place =\n             self.prefixes(borrow.borrowed_place.as_ref(), PrefixSet::All).last().unwrap();\n@@ -1189,10 +1183,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let kind_place = kind.filter(|_| place_desc.is_some()).map(|k| (k, place_span.0));\n         let explanation = self.explain_why_borrow_contains_point(location, &borrow, kind_place);\n \n-        debug!(\n-            \"report_borrowed_value_does_not_live_long_enough(place_desc: {:?}, explanation: {:?})\",\n-            place_desc, explanation\n-        );\n+        debug!(?place_desc, ?explanation);\n+\n         let err = match (place_desc, explanation) {\n             // If the outlives constraint comes from inside the closure,\n             // for example:\n@@ -1464,6 +1456,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn report_temporary_value_does_not_live_long_enough(\n         &mut self,\n         location: Location,\n@@ -1473,13 +1466,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         proper_span: Span,\n         explanation: BorrowExplanation<'tcx>,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n-        debug!(\n-            \"report_temporary_value_does_not_live_long_enough(\\\n-             {:?}, {:?}, {:?}, {:?}\\\n-             )\",\n-            location, borrow, drop_span, proper_span\n-        );\n-\n         if let BorrowExplanation::MustBeValidFor { category, span, from_closure: false, .. } =\n             explanation\n         {"}, {"sha": "2f61849c383c528ea3c62e2e08062e26e2b13aff", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -336,26 +336,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ///   - second half is the place being accessed\n     ///\n     /// [d]: https://rust-lang.github.io/rfcs/2094-nll.html#leveraging-intuition-framing-errors-in-terms-of-points\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn explain_why_borrow_contains_point(\n         &self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         kind_place: Option<(WriteKind, Place<'tcx>)>,\n     ) -> BorrowExplanation<'tcx> {\n-        debug!(\n-            \"explain_why_borrow_contains_point(location={:?}, borrow={:?}, kind_place={:?})\",\n-            location, borrow, kind_place\n-        );\n-\n         let regioncx = &self.regioncx;\n         let body: &Body<'_> = &self.body;\n         let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = borrow.region;\n-        debug!(\"explain_why_borrow_contains_point: borrow_region_vid={:?}\", borrow_region_vid);\n+        debug!(?borrow_region_vid);\n \n         let region_sub = self.regioncx.find_sub_region_live_at(borrow_region_vid, location);\n-        debug!(\"explain_why_borrow_contains_point: region_sub={:?}\", region_sub);\n+        debug!(?region_sub);\n \n         match find_use::find(body, regioncx, tcx, region_sub, location) {\n             Some(Cause::LiveVar(local, location)) => {\n@@ -408,17 +404,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             opt_place_desc,\n                         }\n                     } else {\n-                        debug!(\n-                            \"explain_why_borrow_contains_point: \\\n-                             Could not generate a region name\"\n-                        );\n+                        debug!(\"Could not generate a region name\");\n                         BorrowExplanation::Unexplained\n                     }\n                 } else {\n-                    debug!(\n-                        \"explain_why_borrow_contains_point: \\\n-                         Could not generate an error region vid\"\n-                    );\n+                    debug!(\"Could not generate an error region vid\");\n                     BorrowExplanation::Unexplained\n                 }\n             }"}, {"sha": "362c45ecd7e670637de4156eb0175870aded9641", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -975,6 +975,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip(self, flow_state))]\n     fn check_access_for_conflict(\n         &mut self,\n         location: Location,\n@@ -983,11 +984,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         rw: ReadOrWrite,\n         flow_state: &Flows<'cx, 'tcx>,\n     ) -> bool {\n-        debug!(\n-            \"check_access_for_conflict(location={:?}, place_span={:?}, sd={:?}, rw={:?})\",\n-            location, place_span, sd, rw,\n-        );\n-\n         let mut error_reported = false;\n         let tcx = self.infcx.tcx;\n         let body = self.body;\n@@ -1451,13 +1447,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Checks whether a borrow of this place is invalidated when the function\n     /// exits\n+    #[instrument(level = \"debug\", skip(self))]\n     fn check_for_invalidation_at_exit(\n         &mut self,\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         span: Span,\n     ) {\n-        debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n         let place = borrow.borrowed_place;\n         let mut root_place = PlaceRef { local: place.local, projection: &[] };\n "}, {"sha": "6e5a96bee97e69031aebbf99662632eb9807249b", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -44,6 +44,7 @@ pub(crate) fn places_conflict<'tcx>(\n /// access depth. The `bias` parameter is used to determine how the unknowable (comparing runtime\n /// array indices, for example) should be interpreted - this depends on what the caller wants in\n /// order to make the conservative choice and preserve soundness.\n+#[instrument(level = \"debug\", skip(tcx, body))]\n pub(super) fn borrow_conflicts_with_place<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n@@ -53,11 +54,6 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n     access: AccessDepth,\n     bias: PlaceConflictBias,\n ) -> bool {\n-    debug!(\n-        \"borrow_conflicts_with_place({:?}, {:?}, {:?}, {:?})\",\n-        borrow_place, access_place, access, bias,\n-    );\n-\n     // This Local/Local case is handled by the more general code below, but\n     // it's so common that it's a speed win to check for it first.\n     if let Some(l1) = borrow_place.as_local() && let Some(l2) = access_place.as_local() {\n@@ -140,10 +136,9 @@ fn place_components_conflict<'tcx>(\n     for (i, (borrow_c, &access_c)) in\n         iter::zip(borrow_place.projection, access_place.projection).enumerate()\n     {\n-        debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n-        let borrow_proj_base = &borrow_place.projection[..i];\n+        debug!(?borrow_c, ?access_c);\n \n-        debug!(\"borrow_conflicts_with_place: access_c = {:?}\", access_c);\n+        let borrow_proj_base = &borrow_place.projection[..i];\n \n         // Borrow and access path both have more components.\n         //\n@@ -180,7 +175,7 @@ fn place_components_conflict<'tcx>(\n                 // idea, at least for now, so just give up and\n                 // report a conflict. This is unsafe code anyway so\n                 // the user could always use raw pointers.\n-                debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n+                debug!(\"arbitrary -> conflict\");\n                 return true;\n             }\n             Overlap::EqualOrDisjoint => {\n@@ -189,7 +184,7 @@ fn place_components_conflict<'tcx>(\n             Overlap::Disjoint => {\n                 // We have proven the borrow disjoint - further\n                 // projections will remain disjoint.\n-                debug!(\"borrow_conflicts_with_place: disjoint\");\n+                debug!(\"disjoint\");\n                 return false;\n             }\n         }"}, {"sha": "f5bd5cd3beaed0ab0006c2ba688a5fc8009f743a", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -1167,8 +1167,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Therefore, this method should only be used in diagnostic code,\n     /// where displaying *some* named universal region is better than\n     /// falling back to 'static.\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn approx_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\"approx_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n+        debug!(\"{}\", self.region_value_str(r));\n \n         // Find the smallest universal region that contains all other\n         // universal regions within `region`.\n@@ -1177,7 +1178,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let static_r = self.universal_regions.fr_static;\n         for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n             let new_lub = self.universal_region_relations.postdom_upper_bound(lub, ur);\n-            debug!(\"approx_universal_upper_bound: ur={:?} lub={:?} new_lub={:?}\", ur, lub, new_lub);\n+            debug!(?ur, ?lub, ?new_lub);\n             // The upper bound of two non-static regions is static: this\n             // means we know nothing about the relationship between these\n             // two regions. Pick a 'better' one to use when constructing\n@@ -1201,7 +1202,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        debug!(\"approx_universal_upper_bound: r={:?} lub={:?}\", r, lub);\n+        debug!(?r, ?lub);\n \n         lub\n     }\n@@ -2048,23 +2049,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// creating a constraint path that forces `R` to outlive\n     /// `from_region`, and then finding the best choices within that\n     /// path to blame.\n+    #[instrument(level = \"debug\", skip(self, target_test))]\n     pub(crate) fn best_blame_constraint(\n         &self,\n         body: &Body<'tcx>,\n         from_region: RegionVid,\n         from_region_origin: NllRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n     ) -> BlameConstraint<'tcx> {\n-        debug!(\n-            \"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n-            from_region, from_region_origin\n-        );\n-\n         // Find all paths\n         let (path, target_region) =\n             self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n         debug!(\n-            \"best_blame_constraint: path={:#?}\",\n+            \"path={:#?}\",\n             path.iter()\n                 .map(|c| format!(\n                     \"{:?} ({:?}: {:?})\",\n@@ -2116,7 +2113,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n             })\n             .collect();\n-        debug!(\"best_blame_constraint: categorized_path={:#?}\", categorized_path);\n+        debug!(\"categorized_path={:#?}\", categorized_path);\n \n         // To find the best span to cite, we first try to look for the\n         // final constraint that is interesting and where the `sup` is\n@@ -2214,10 +2211,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let best_choice =\n             if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n \n-        debug!(\n-            \"best_blame_constraint: best_choice={:?} blame_source={}\",\n-            best_choice, blame_source\n-        );\n+        debug!(?best_choice, ?blame_source);\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n@@ -2254,7 +2248,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // appears to be the most interesting point to report to the\n         // user via an even more ad-hoc guess.\n         categorized_path.sort_by(|p0, p1| p0.category.cmp(&p1.category));\n-        debug!(\"best_blame_constraint: sorted_path={:#?}\", categorized_path);\n+        debug!(\"sorted_path={:#?}\", categorized_path);\n \n         categorized_path.remove(0)\n     }"}, {"sha": "29195b3922fcdb24dc8734caa8f03dcb5f9ce230", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// **Any `rustc_infer::infer` operations that might generate region\n     /// constraints should occur within this method so that those\n     /// constraints can be properly localized!**\n-    #[instrument(skip(self, category, op), level = \"trace\")]\n+    #[instrument(skip(self, op), level = \"trace\")]\n     pub(super) fn fully_perform_op<R, Op>(\n         &mut self,\n         locations: Locations,"}, {"sha": "a620c987052ba0b987175df02e70fc9e5d3b9cd6", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -1043,6 +1043,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             let CanonicalUserTypeAnnotation { span, ref user_ty, inferred_ty } = *user_annotation;\n             let inferred_ty = self.normalize(inferred_ty, Locations::All(span));\n             let annotation = self.instantiate_canonical_with_fresh_inference_vars(span, user_ty);\n+            debug!(?annotation);\n             match annotation {\n                 UserType::Ty(mut ty) => {\n                     ty = self.normalize(ty, Locations::All(span));"}, {"sha": "f8e982b775189f7ed45ae19b5f0e572bb657f3af", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -1,6 +1,6 @@\n use crate::traits::*;\n \n-use rustc_middle::ty::{self, subst::GenericArgKind, ExistentialPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n use rustc_session::config::Lto;\n use rustc_symbol_mangling::typeid_for_trait_ref;\n use rustc_target::abi::call::FnAbi;\n@@ -29,7 +29,7 @@ impl<'a, 'tcx> VirtualIndex {\n             && bx.cx().sess().lto() == Lto::Fat\n         {\n             let typeid =\n-                bx.typeid_metadata(typeid_for_trait_ref(bx.tcx(), get_trait_ref(bx.tcx(), ty)));\n+                bx.typeid_metadata(typeid_for_trait_ref(bx.tcx(), expect_dyn_trait_in_self(ty)));\n             let vtable_byte_offset = self.0 * bx.data_layout().pointer_size.bytes();\n             let type_checked_load = bx.type_checked_load(llvtable, vtable_byte_offset, typeid);\n             let func = bx.extract_value(type_checked_load, 0);\n@@ -64,17 +64,13 @@ impl<'a, 'tcx> VirtualIndex {\n     }\n }\n \n-fn get_trait_ref<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ty::PolyExistentialTraitRef<'tcx> {\n+/// This takes a valid `self` receiver type and extracts the principal trait\n+/// ref of the type.\n+fn expect_dyn_trait_in_self<'tcx>(ty: Ty<'tcx>) -> ty::PolyExistentialTraitRef<'tcx> {\n     for arg in ty.peel_refs().walk() {\n         if let GenericArgKind::Type(ty) = arg.unpack() {\n-            if let ty::Dynamic(trait_refs, _) = ty.kind() {\n-                return trait_refs[0].map_bound(|trait_ref| match trait_ref {\n-                    ExistentialPredicate::Trait(tr) => tr,\n-                    ExistentialPredicate::Projection(proj) => proj.trait_ref(tcx),\n-                    ExistentialPredicate::AutoTrait(_) => {\n-                        bug!(\"auto traits don't have functions\")\n-                    }\n-                });\n+            if let ty::Dynamic(data, _) = ty.kind() {\n+                return data.principal().expect(\"expected principal trait object\");\n             }\n         }\n     }"}, {"sha": "bba4b1815b457ca475cf0a51bb9292485311d39d", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -15,7 +15,6 @@ use crate::interpret::{\n /// The CTFE machine has some custom error kinds.\n #[derive(Clone, Debug)]\n pub enum ConstEvalErrKind {\n-    NeedsRfc(String),\n     ConstAccessesStatic,\n     ModifiedGlobal,\n     AssertFailure(AssertKind<ConstInt>),\n@@ -42,9 +41,6 @@ impl fmt::Display for ConstEvalErrKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use self::ConstEvalErrKind::*;\n         match *self {\n-            NeedsRfc(ref msg) => {\n-                write!(f, \"\\\"{}\\\" needs an rfc before being allowed inside constants\", msg)\n-            }\n             ConstAccessesStatic => write!(f, \"constant accesses static\"),\n             ModifiedGlobal => {\n                 write!(f, \"modifying a static's initial value from another static's initializer\")"}, {"sha": "9ea9fbe0e0e54188260281048bf8bfd11edfc308", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -269,9 +269,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     );\n                     throw_inval!(AlreadyReported(guar));\n                 } else {\n+                    // `find_mir_or_eval_fn` checks that this is a const fn before even calling us,\n+                    // so this should be unreachable.\n                     let path = ecx.tcx.def_path_str(def.did);\n-                    Err(ConstEvalErrKind::NeedsRfc(format!(\"calling extern function `{}`\", path))\n-                        .into())\n+                    bug!(\"trying to call extern function `{path}` at compile-time\");\n                 }\n             }\n             _ => Ok(ecx.tcx.instance_mir(instance)),\n@@ -339,11 +340,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n         // CTFE-specific intrinsics.\n         let Some(ret) = target else {\n-            return Err(ConstEvalErrKind::NeedsRfc(format!(\n-                \"calling intrinsic `{}`\",\n-                intrinsic_name\n-            ))\n-            .into());\n+            throw_unsup_format!(\"intrinsic `{intrinsic_name}` is not supported at compile-time\");\n         };\n         match intrinsic_name {\n             sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n@@ -400,11 +397,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 }\n             }\n             _ => {\n-                return Err(ConstEvalErrKind::NeedsRfc(format!(\n-                    \"calling intrinsic `{}`\",\n-                    intrinsic_name\n-                ))\n-                .into());\n+                throw_unsup_format!(\n+                    \"intrinsic `{intrinsic_name}` is not supported at compile-time\"\n+                );\n             }\n         }\n \n@@ -447,7 +442,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _left: &ImmTy<'tcx>,\n         _right: &ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        Err(ConstEvalErrKind::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n+        throw_unsup_format!(\"pointer arithmetic or comparison is not supported at compile-time\");\n     }\n \n     fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n@@ -469,7 +464,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _ptr: Pointer<AllocId>,\n     ) -> InterpResult<'tcx> {\n-        Err(ConstEvalErrKind::NeedsRfc(\"exposing pointers\".to_string()).into())\n+        // This is only reachable with -Zunleash-the-miri-inside-of-you.\n+        throw_unsup_format!(\"exposing pointers is not possible at compile-time\")\n     }\n \n     #[inline(always)]"}, {"sha": "6ca983714978f241402dea52c9c7e96bcd9e146c", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -479,6 +479,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     ) -> InterpResult<$tcx, Pointer<Option<AllocId>>> {\n         // Allow these casts, but make the pointer not dereferenceable.\n         // (I.e., they behave like transmutation.)\n+        // This is correct because no pointers can ever be exposed in compile-time evaluation.\n         Ok(Pointer::from_addr(addr))\n     }\n "}, {"sha": "46f8c0e8d8b9acad49d334fcc9d3dc04852b53b8", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -372,7 +372,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 debug!(\n                     \"canonical: region var found with vid {:?}, \\\n                      opportunistically resolved to {:?}\",\n-                    vid, r\n+                    vid, resolved_vid\n                 );\n                 let r = self.tcx.reuse_or_mk_region(r, ty::ReVar(resolved_vid));\n                 self.canonicalize_mode.canonicalize_free_region(self, r)"}, {"sha": "64c759f73d410323cc08d6eeb8c688c5b5d7942f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -63,8 +63,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,\n     {\n         let query_response = self.make_query_response(inference_vars, answer, fulfill_cx)?;\n+        debug!(\"query_response = {:#?}\", query_response);\n         let canonical_result = self.canonicalize_response(query_response);\n-\n         debug!(\"canonical_result = {:#?}\", canonical_result);\n \n         Ok(self.tcx.arena.alloc(canonical_result))\n@@ -125,13 +125,15 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         debug!(\"ambig_errors = {:#?}\", ambig_errors);\n \n         let region_obligations = self.take_registered_region_obligations();\n+        debug!(?region_obligations);\n         let region_constraints = self.with_region_constraints(|region_constraints| {\n             make_query_region_constraints(\n                 tcx,\n                 region_obligations.iter().map(|r_o| (r_o.sup_type, r_o.sub_region)),\n                 region_constraints,\n             )\n         });\n+        debug!(?region_constraints);\n \n         let certainty =\n             if ambig_errors.is_empty() { Certainty::Proven } else { Certainty::Ambiguous };\n@@ -632,6 +634,8 @@ pub fn make_query_region_constraints<'tcx>(\n     assert!(verifys.is_empty());\n     assert!(givens.is_empty());\n \n+    debug!(?constraints);\n+\n     let outlives: Vec<_> = constraints\n         .iter()\n         .map(|(k, _)| match *k {"}, {"sha": "4689ebb6cee2429a1c8a8388515c3f488ba43130", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -504,7 +504,7 @@ pub enum FixupError<'tcx> {\n }\n \n /// See the `region_obligations` field for more information.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct RegionObligation<'tcx> {\n     pub sub_region: ty::Region<'tcx>,\n     pub sup_type: Ty<'tcx>,\n@@ -2027,16 +2027,6 @@ impl RegionVariableOrigin {\n     }\n }\n \n-impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n-            self.sub_region, self.sup_type\n-        )\n-    }\n-}\n-\n /// Replaces substs that reference param or infer variables with suitable\n /// placeholders. This function is meant to remove these param and infer\n /// substs when they're not actually needed to evaluate a constant."}, {"sha": "fe78890ff6ed7648b309d0b095b284b25c0dd4b3", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -92,6 +92,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         sub_region: Region<'tcx>,\n         cause: &ObligationCause<'tcx>,\n     ) {\n+        debug!(?sup_type, ?sub_region, ?cause);\n         let origin = SubregionOrigin::from_obligation_cause(cause, || {\n             infer::RelateParamBound(\n                 cause.span,\n@@ -248,14 +249,13 @@ where\n     /// - `origin`, the reason we need this constraint\n     /// - `ty`, the type `T`\n     /// - `region`, the region `'a`\n+    #[instrument(level = \"debug\", skip(self))]\n     pub fn type_must_outlive(\n         &mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n     ) {\n-        debug!(\"type_must_outlive(ty={:?}, region={:?}, origin={:?})\", ty, region, origin);\n-\n         assert!(!ty.has_escaping_bound_vars());\n \n         let mut components = smallvec![];"}, {"sha": "90c554c2e040bf248c36969efdbccb8409cca4ea", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -243,6 +243,5 @@ macro_rules! declare_combined_early_lint_pass {\n }\n \n /// A lint pass boxed up as a trait object.\n-pub type EarlyLintPassObject = Box<dyn EarlyLintPass + sync::Send + sync::Sync + 'static>;\n-pub type LateLintPassObject =\n-    Box<dyn for<'tcx> LateLintPass<'tcx> + sync::Send + sync::Sync + 'static>;\n+pub type EarlyLintPassObject = Box<dyn EarlyLintPass + sync::Send + 'static>;\n+pub type LateLintPassObject = Box<dyn for<'tcx> LateLintPass<'tcx> + sync::Send + 'static>;"}, {"sha": "6eca7dc52b26ac7d47d5fb83c6676ea9665a7b93", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -157,6 +157,7 @@ symbols! {\n         BTreeSet,\n         BinaryHeap,\n         Borrow,\n+        BorrowMut,\n         Break,\n         C,\n         CStr,"}, {"sha": "60e9b88107dd698a258c044d6042436bbdb9c74a", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -120,6 +120,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         EarlyBinder(value).subst(self.tcx(), substs)\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n     fn relate_mir_and_user_ty(\n         &mut self,\n         mir_ty: Ty<'tcx>,\n@@ -132,8 +133,8 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n \n         let ty = tcx.type_of(def_id);\n         let ty = self.subst(ty, substs);\n-        debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n         let ty = self.normalize(ty);\n+        debug!(\"relate_type_and_user_type: ty of def-id is {:?}\", ty);\n \n         self.relate(mir_ty, Variance::Invariant, ty)?;\n \n@@ -144,7 +145,7 @@ impl<'me, 'tcx> AscribeUserTypeCx<'me, 'tcx> {\n         // outlives\" error messages.\n         let instantiated_predicates =\n             self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n-        debug!(?instantiated_predicates.predicates);\n+        debug!(?instantiated_predicates);\n         for instantiated_predicate in instantiated_predicates.predicates {\n             let instantiated_predicate = self.normalize(instantiated_predicate);\n             self.prove_predicate(instantiated_predicate, span);"}, {"sha": "33d74249e7b940d7f59b4a00ea6ac5fbd3de6669", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -2605,32 +2605,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some((fields, substs)) =\n             self.get_field_candidates_considering_privacy(span, expr_t, mod_id)\n         {\n-            for candidate_field in fields {\n-                if let Some(mut field_path) = self.check_for_nested_field_satisfying(\n-                    span,\n-                    &|candidate_field, _| candidate_field.ident(self.tcx()) == field,\n-                    candidate_field,\n-                    substs,\n-                    vec![],\n-                    mod_id,\n-                ) {\n-                    // field_path includes `field` that we're looking for, so pop it.\n+            let candidate_fields: Vec<_> = fields\n+                .filter_map(|candidate_field| {\n+                    self.check_for_nested_field_satisfying(\n+                        span,\n+                        &|candidate_field, _| candidate_field.ident(self.tcx()) == field,\n+                        candidate_field,\n+                        substs,\n+                        vec![],\n+                        mod_id,\n+                    )\n+                })\n+                .map(|mut field_path| {\n                     field_path.pop();\n-\n-                    let field_path_str = field_path\n+                    field_path\n                         .iter()\n                         .map(|id| id.name.to_ident_string())\n                         .collect::<Vec<String>>()\n-                        .join(\".\");\n-                    debug!(\"field_path_str: {:?}\", field_path_str);\n-\n-                    err.span_suggestion_verbose(\n-                        field.span.shrink_to_lo(),\n-                        \"one of the expressions' fields has a field of the same name\",\n-                        format!(\"{field_path_str}.\"),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n+                        .join(\".\")\n+                })\n+                .collect::<Vec<_>>();\n+\n+            let len = candidate_fields.len();\n+            if len > 0 {\n+                err.span_suggestions(\n+                    field.span.shrink_to_lo(),\n+                    format!(\n+                        \"{} of the expressions' fields {} a field of the same name\",\n+                        if len > 1 { \"some\" } else { \"one\" },\n+                        if len > 1 { \"have\" } else { \"has\" },\n+                    ),\n+                    candidate_fields.iter().map(|path| format!(\"{path}.\")),\n+                    Applicability::MaybeIncorrect,\n+                );\n             }\n         }\n         err"}, {"sha": "e532f39215788662309e89e0e960840651580dd6", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 57, "deletions": 31, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -1350,42 +1350,68 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         item_name: Ident,\n     ) {\n         if let SelfSource::MethodCall(expr) = source\n-            && let mod_id = self.tcx.parent_module(expr.hir_id).to_def_id()\n-            && let Some((fields, substs)) = self.get_field_candidates_considering_privacy(span, actual, mod_id)\n+        && let mod_id = self.tcx.parent_module(expr.hir_id).to_def_id()\n+        && let Some((fields, substs)) =\n+            self.get_field_candidates_considering_privacy(span, actual, mod_id)\n         {\n             let call_expr = self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-            for candidate_field in fields {\n-                if let Some(field_path) = self.check_for_nested_field_satisfying(\n-                    span,\n-                    &|_, field_ty| {\n-                        self.lookup_probe(\n-                            span,\n-                            item_name,\n-                            field_ty,\n-                            call_expr,\n-                            ProbeScope::AllTraits,\n-                        )\n-                        .is_ok()\n-                    },\n-                    candidate_field,\n-                    substs,\n-                    vec![],\n-                    mod_id,\n-                ) {\n-                    let field_path_str = field_path\n+\n+            let lang_items = self.tcx.lang_items();\n+            let never_mention_traits = [\n+                lang_items.clone_trait(),\n+                lang_items.deref_trait(),\n+                lang_items.deref_mut_trait(),\n+                self.tcx.get_diagnostic_item(sym::AsRef),\n+                self.tcx.get_diagnostic_item(sym::AsMut),\n+                self.tcx.get_diagnostic_item(sym::Borrow),\n+                self.tcx.get_diagnostic_item(sym::BorrowMut),\n+            ];\n+            let candidate_fields: Vec<_> = fields\n+                .filter_map(|candidate_field| {\n+                    self.check_for_nested_field_satisfying(\n+                        span,\n+                        &|_, field_ty| {\n+                            self.lookup_probe(\n+                                span,\n+                                item_name,\n+                                field_ty,\n+                                call_expr,\n+                                ProbeScope::TraitsInScope,\n+                            )\n+                            .map_or(false, |pick| {\n+                                !never_mention_traits\n+                                    .iter()\n+                                    .flatten()\n+                                    .any(|def_id| self.tcx.parent(pick.item.def_id) == *def_id)\n+                            })\n+                        },\n+                        candidate_field,\n+                        substs,\n+                        vec![],\n+                        mod_id,\n+                    )\n+                })\n+                .map(|field_path| {\n+                    field_path\n                         .iter()\n                         .map(|id| id.name.to_ident_string())\n                         .collect::<Vec<String>>()\n-                        .join(\".\");\n-                    debug!(\"field_path_str: {:?}\", field_path_str);\n-\n-                    err.span_suggestion_verbose(\n-                        item_name.span.shrink_to_lo(),\n-                        \"one of the expressions' fields has a method of the same name\",\n-                        format!(\"{field_path_str}.\"),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n+                        .join(\".\")\n+                })\n+                .collect();\n+\n+            let len = candidate_fields.len();\n+            if len > 0 {\n+                err.span_suggestions(\n+                    item_name.span.shrink_to_lo(),\n+                    format!(\n+                        \"{} of the expressions' fields {} a method of the same name\",\n+                        if len > 1 { \"some\" } else { \"one\" },\n+                        if len > 1 { \"have\" } else { \"has\" },\n+                    ),\n+                    candidate_fields.iter().map(|path| format!(\"{path}.\")),\n+                    Applicability::MaybeIncorrect,\n+                );\n             }\n         }\n     }"}, {"sha": "242f44ade8a2d121a5ae775d1952e7594204b608", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -1223,7 +1223,7 @@ mod prim_usize {}\n #[doc(alias = \"&\")]\n #[doc(alias = \"&mut\")]\n //\n-/// References, both shared and mutable.\n+/// References, `&T` and `&mut T`.\n ///\n /// A reference represents a borrow of some owned value. You can get one by using the `&` or `&mut`\n /// operators on a value, or by using a [`ref`](../std/keyword.ref.html) or"}, {"sha": "242f44ade8a2d121a5ae775d1952e7594204b608", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -1223,7 +1223,7 @@ mod prim_usize {}\n #[doc(alias = \"&\")]\n #[doc(alias = \"&mut\")]\n //\n-/// References, both shared and mutable.\n+/// References, `&T` and `&mut T`.\n ///\n /// A reference represents a borrow of some owned value. You can get one by using the `&` or `&mut`\n /// operators on a value, or by using a [`ref`](../std/keyword.ref.html) or"}, {"sha": "025f320e3a103e0497722fcd0f0b59887aea18c8", "filename": "src/etc/check_missing_items.py", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Fetc%2Fcheck_missing_items.py", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Fetc%2Fcheck_missing_items.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck_missing_items.py?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -187,3 +187,9 @@ def check_type(ty):\n             check_generic_bound(bound)\n         if item[\"inner\"][\"default\"]:\n             check_type(item[\"inner\"][\"default\"])\n+    elif item[\"kind\"] == \"import\":\n+        if item[\"inner\"][\"id\"]:\n+            inner_id = item[\"inner\"][\"id\"]\n+            assert valid_id(inner_id)\n+            if inner_id in crate[\"index\"] and inner_id not in visited:\n+                work_list.add(inner_id)"}, {"sha": "20b9eb1c27e92cb046a2f55757e3c64e3e99ffd2", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -46,10 +46,14 @@ impl JsonRenderer<'_> {\n             clean::KeywordItem => return None,\n             clean::StrippedItem(ref inner) => {\n                 match &**inner {\n-                    // We document non-empty stripped modules as with `Module::is_stripped` set to\n+                    // We document stripped modules as with `Module::is_stripped` set to\n                     // `true`, to prevent contained items from being orphaned for downstream users,\n                     // as JSON does no inlining.\n-                    clean::ModuleItem(m) if !m.items.is_empty() => from_clean_item(item, self.tcx),\n+                    clean::ModuleItem(_)\n+                        if self.imported_items.contains(&item_id.expect_def_id()) =>\n+                    {\n+                        from_clean_item(item, self.tcx)\n+                    }\n                     _ => return None,\n                 }\n             }"}, {"sha": "c5c687df74fd88072f0f348134f219b19b96af8d", "filename": "src/librustdoc/json/import_finder.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Flibrustdoc%2Fjson%2Fimport_finder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Flibrustdoc%2Fjson%2Fimport_finder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fimport_finder.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -0,0 +1,38 @@\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def_id::DefId;\n+\n+use crate::{\n+    clean::{self, Import, ImportSource, Item},\n+    fold::DocFolder,\n+};\n+\n+/// Get the id's of all items that are `pub use`d in the crate.\n+///\n+/// We need this to know if a stripped module is `pub use mod::*`, to decide\n+/// if it needs to be kept in the index, despite being stripped.\n+///\n+/// See [#100973](https://github.com/rust-lang/rust/issues/100973) and\n+/// [#101103](https://github.com/rust-lang/rust/issues/101103) for times when\n+/// this information is needed.\n+pub(crate) fn get_imports(krate: clean::Crate) -> (clean::Crate, FxHashSet<DefId>) {\n+    let mut finder = ImportFinder { imported: FxHashSet::default() };\n+    let krate = finder.fold_crate(krate);\n+    (krate, finder.imported)\n+}\n+\n+struct ImportFinder {\n+    imported: FxHashSet<DefId>,\n+}\n+\n+impl DocFolder for ImportFinder {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        match *i.kind {\n+            clean::ImportItem(Import { source: ImportSource { did: Some(did), .. }, .. }) => {\n+                self.imported.insert(did);\n+                Some(i)\n+            }\n+\n+            _ => Some(self.fold_item_recur(i)),\n+        }\n+    }\n+}"}, {"sha": "6a1409c739424cf3c8533bb4fc925f2134c8b739", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -5,14 +5,15 @@\n //! docs for usage and details.\n \n mod conversions;\n+mod import_finder;\n \n use std::cell::RefCell;\n use std::fs::{create_dir_all, File};\n use std::io::{BufWriter, Write};\n use std::path::PathBuf;\n use std::rc::Rc;\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n@@ -39,6 +40,7 @@ pub(crate) struct JsonRenderer<'tcx> {\n     /// The directory where the blob will be written to.\n     out_path: PathBuf,\n     cache: Rc<Cache>,\n+    imported_items: FxHashSet<DefId>,\n }\n \n impl<'tcx> JsonRenderer<'tcx> {\n@@ -159,12 +161,16 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         tcx: TyCtxt<'tcx>,\n     ) -> Result<(Self, clean::Crate), Error> {\n         debug!(\"Initializing json renderer\");\n+\n+        let (krate, imported_items) = import_finder::get_imports(krate);\n+\n         Ok((\n             JsonRenderer {\n                 tcx,\n                 index: Rc::new(RefCell::new(FxHashMap::default())),\n                 out_path: options.output,\n                 cache: Rc::new(cache),\n+                imported_items,\n             },\n             krate,\n         ))"}, {"sha": "f91144dbfad502bcf1384b679db8b04d7d140295", "filename": "src/test/rustdoc-json/reexport/glob_collision.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Fglob_collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Fglob_collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fglob_collision.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -0,0 +1,28 @@\n+// Regression test for https://github.com/rust-lang/rust/issues/100973\n+\n+#![feature(no_core)]\n+#![no_core]\n+\n+// @set m1 = \"$.index[*][?(@.name == 'm1' && @.kind == 'module')].id\"\n+// @is \"$.index[*][?(@.name == 'm1' && @.kind == 'module')].inner.items\" []\n+// @is \"$.index[*][?(@.name == 'm1' && @.kind == 'module')].inner.is_stripped\" true\n+mod m1 {\n+    pub fn f() {}\n+}\n+// @set m2 = \"$.index[*][?(@.name == 'm2' && @.kind == 'module')].id\"\n+// @is \"$.index[*][?(@.name == 'm2' && @.kind == 'module')].inner.items\" []\n+// @is \"$.index[*][?(@.name == 'm2' && @.kind == 'module')].inner.is_stripped\" true\n+mod m2 {\n+    pub fn f(_: u8) {}\n+}\n+\n+// @set m1_use = \"$.index[*][?(@.inner.name=='m1')].id\"\n+// @is \"$.index[*][?(@.inner.name=='m1')].inner.id\" $m1\n+// @is \"$.index[*][?(@.inner.name=='m1')].inner.glob\" true\n+pub use m1::*;\n+// @set m2_use = \"$.index[*][?(@.inner.name=='m2')].id\"\n+// @is \"$.index[*][?(@.inner.name=='m2')].inner.id\" $m2\n+// @is \"$.index[*][?(@.inner.name=='m2')].inner.glob\" true\n+pub use m2::*;\n+\n+// @ismany \"$.index[*][?(@.inner.is_crate==true)].inner.items[*]\" $m1_use $m2_use"}, {"sha": "da68228352c1c2cc02cc97857d78ea164a60811e", "filename": "src/test/rustdoc-json/reexport/glob_empty_mod.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Fglob_empty_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Fglob_empty_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fglob_empty_mod.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -0,0 +1,8 @@\n+// Regression test for https://github.com/rust-lang/rust/issues/100973\n+\n+// @is \"$.index[*][?(@.name=='m1' && @.kind == 'module')].inner.is_stripped\" true\n+// @set m1 = \"$.index[*][?(@.name=='m1')].id\"\n+mod m1 {}\n+\n+// @is \"$.index[*][?(@.inner.name=='m1' && @.kind=='import')].inner.id\" $m1\n+pub use m1::*;"}, {"sha": "7b97ebf2129eb91ce0c7908f611e424555f1c0d0", "filename": "src/test/rustdoc-json/reexport/in_root_and_mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Fin_root_and_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Fin_root_and_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fin_root_and_mod.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -1,8 +1,7 @@\n #![feature(no_core)]\n #![no_core]\n \n-// @is \"$.index[*][?(@.name=='foo')].kind\" \\\"module\\\"\n-// @is \"$.index[*][?(@.name=='foo')].inner.is_stripped\" \"true\"\n+// @!has \"$.index[*][?(@.name=='foo')]\"\n mod foo {\n     // @has \"$.index[*][?(@.name=='Foo')]\"\n     pub struct Foo;"}, {"sha": "7b7600ef20f08b4ec0719558c4d9d20136c8cc88", "filename": "src/test/rustdoc-json/reexport/mod_not_included.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Fmod_not_included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Fmod_not_included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fmod_not_included.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -0,0 +1,14 @@\n+// Regression test for https://github.com/rust-lang/rust/issues/101103\n+\n+#![feature(no_core)]\n+#![no_core]\n+\n+mod m1 {\n+    pub fn x() {}\n+}\n+\n+pub use m1::x;\n+\n+// @has \"$.index[*][?(@.name=='x' && @.kind=='function')]\"\n+// @has \"$.index[*][?(@.kind=='import' && @.inner.name=='x')].inner.source\" '\"m1::x\"'\n+// @!has \"$.index[*][?(@.name=='m1')]\""}, {"sha": "9858538a9d046493b7926fc34c15303e47d115e3", "filename": "src/test/rustdoc-json/reexport/private_two_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Fprivate_two_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Fprivate_two_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fprivate_two_names.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -6,8 +6,7 @@\n #![no_core]\n #![feature(no_core)]\n \n-// @is \"$.index[*][?(@.name=='style')].kind\" \\\"module\\\"\n-// @is \"$.index[*][?(@.name=='style')].inner.is_stripped\" \"true\"\n+// @!has \"$.index[*][?(@.name=='style')]\"\n mod style {\n     // @set color_struct_id = \"$.index[*][?(@.kind=='struct' && @.name=='Color')].id\"\n     pub struct Color;"}, {"sha": "8fd850f9b1370ad7e00a78f59ef9b46ac2063f46", "filename": "src/test/rustdoc-json/reexport/rename_private.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Frename_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Frename_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Frename_private.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -3,8 +3,7 @@\n #![no_core]\n #![feature(no_core)]\n \n-// @is \"$.index[*][?(@.name=='inner')].kind\" \\\"module\\\"\n-// @is \"$.index[*][?(@.name=='inner')].inner.is_stripped\" \"true\"\n+// @!has \"$.index[*][?(@.kind=='inner')]\"\n mod inner {\n     // @has \"$.index[*][?(@.name=='Public')]\"\n     pub struct Public;"}, {"sha": "d058ce0598d43e557d1ecd998365a4252642e636", "filename": "src/test/rustdoc-json/reexport/simple_private.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Fsimple_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Freexport%2Fsimple_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fsimple_private.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -2,16 +2,15 @@\n #![no_core]\n #![feature(no_core)]\n \n-// @is \"$.index[*][?(@.name=='inner')].kind\" \\\"module\\\"\n-// @is \"$.index[*][?(@.name=='inner')].inner.is_stripped\" \"true\"\n+// @!has \"$.index[*][?(@.name=='inner')]\"\n mod inner {\n     // @set pub_id = \"$.index[*][?(@.name=='Public')].id\"\n     pub struct Public;\n }\n \n // @is \"$.index[*][?(@.kind=='import')].inner.name\" \\\"Public\\\"\n+// @is \"$.index[*][?(@.kind=='import')].inner.id\" $pub_id\n // @set use_id = \"$.index[*][?(@.kind=='import')].id\"\n pub use inner::Public;\n \n-// @ismany \"$.index[*][?(@.name=='inner')].inner.items[*]\" $pub_id\n // @ismany \"$.index[*][?(@.name=='simple_private')].inner.items[*]\" $use_id"}, {"sha": "d2664b49e9c29209897d6216d3480e2756820684", "filename": "src/test/rustdoc-json/stripped_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Fstripped_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Frustdoc-json%2Fstripped_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fstripped_modules.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -12,7 +12,7 @@ mod pub_inner_unreachable {\n     pub fn pub_inner_1() {}\n }\n \n-// @has \"$.index[*][?(@.name=='pub_inner_reachable')]\"\n+// @!has \"$.index[*][?(@.name=='pub_inner_reachable')]\"\n mod pub_inner_reachable {\n     // @has \"$.index[*][?(@.name=='pub_inner_2')]\"\n     pub fn pub_inner_2() {}"}, {"sha": "6a19b294585ae038bf6edfc87a432e6996dde9d7", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -8,7 +8,7 @@\n static PTR_INT_CAST: () = {\n     let x = &0 as *const _ as usize;\n     //~^ ERROR could not evaluate static initializer\n-    //~| \"exposing pointers\" needs an rfc before being allowed inside constants\n+    //~| exposing pointers\n     let _v = x == x;\n };\n \n@@ -19,4 +19,7 @@ static PTR_INT_TRANSMUTE: () = unsafe {\n     //~| unable to turn pointer into raw bytes\n };\n \n+// I'd love to test pointer comparison, but that is not possible since\n+// their `PartialEq` impl is non-`const`.\n+\n fn main() {}"}, {"sha": "f5c5ee2b8ebad330a511c8135d59483909a34d04", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -2,7 +2,7 @@ error[E0080]: could not evaluate static initializer\n   --> $DIR/ptr_arith.rs:9:13\n    |\n LL |     let x = &0 as *const _ as usize;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ \"exposing pointers\" needs an rfc before being allowed inside constants\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ exposing pointers is not possible at compile-time\n \n error[E0080]: could not evaluate static initializer\n   --> $DIR/ptr_arith.rs:17:14"}, {"sha": "128087f1e375522297267296a093509774bb30e1", "filename": "src/test/ui/copy-a-resource.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcopy-a-resource.stderr?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -10,10 +10,6 @@ LL |     let _y = x.clone();\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n-help: one of the expressions' fields has a method of the same name\n-   |\n-LL |     let _y = x.i.clone();\n-   |                ++\n \n error: aborting due to previous error\n "}, {"sha": "b5a2b2f55a6d4905af0425b580efa1406101b0a9", "filename": "src/test/ui/issues/issue-2823.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -10,10 +10,6 @@ LL |     let _d = c.clone();\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n-help: one of the expressions' fields has a method of the same name\n-   |\n-LL |     let _d = c.x.clone();\n-   |                ++\n \n error: aborting due to previous error\n "}, {"sha": "0c696163a26c5cba2737b6bf51ae504c1e84af26", "filename": "src/test/ui/noncopyable-class.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnoncopyable-class.stderr?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -10,14 +10,6 @@ LL |     let _y = x.clone();\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n-help: one of the expressions' fields has a method of the same name\n-   |\n-LL |     let _y = x.i.clone();\n-   |                ++\n-help: one of the expressions' fields has a method of the same name\n-   |\n-LL |     let _y = x.j.x.clone();\n-   |                ++++\n \n error: aborting due to previous error\n "}, {"sha": "905f9502cf5be5270b501c9eafb0714886c01a09", "filename": "src/test/ui/suggestions/too-many-field-suggestions.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fsuggestions%2Ftoo-many-field-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fsuggestions%2Ftoo-many-field-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftoo-many-field-suggestions.rs?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -0,0 +1,29 @@\n+struct Thing {\n+    a0: Foo,\n+    a1: Foo,\n+    a2: Foo,\n+    a3: Foo,\n+    a4: Foo,\n+    a5: Foo,\n+    a6: Foo,\n+    a7: Foo,\n+    a8: Foo,\n+    a9: Foo,\n+}\n+\n+struct Foo {\n+    field: Field,\n+}\n+\n+struct Field;\n+\n+impl Foo {\n+    fn bar(&self) {}\n+}\n+\n+fn bar(t: Thing) {\n+    t.bar(); //~ ERROR no method named `bar` found for struct `Thing`\n+    t.field; //~ ERROR no field `field` on type `Thing`\n+}\n+\n+fn main() {}"}, {"sha": "63ad6fdb1699441327f85ff05cd5b354f87f0a96", "filename": "src/test/ui/suggestions/too-many-field-suggestions.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fsuggestions%2Ftoo-many-field-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8/src%2Ftest%2Fui%2Fsuggestions%2Ftoo-many-field-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftoo-many-field-suggestions.stderr?ref=9f4d5d2a28849ec0ecb2976ddc9946f65b626fe8", "patch": "@@ -0,0 +1,44 @@\n+error[E0599]: no method named `bar` found for struct `Thing` in the current scope\n+  --> $DIR/too-many-field-suggestions.rs:25:7\n+   |\n+LL | struct Thing {\n+   | ------------ method `bar` not found for this struct\n+...\n+LL |     t.bar();\n+   |       ^^^ method not found in `Thing`\n+   |\n+help: some of the expressions' fields have a method of the same name\n+   |\n+LL |     t.a0.bar();\n+   |       +++\n+LL |     t.a1.bar();\n+   |       +++\n+LL |     t.a2.bar();\n+   |       +++\n+LL |     t.a3.bar();\n+   |       +++\n+     and 6 other candidates\n+\n+error[E0609]: no field `field` on type `Thing`\n+  --> $DIR/too-many-field-suggestions.rs:26:7\n+   |\n+LL |     t.field;\n+   |       ^^^^^ unknown field\n+   |\n+   = note: available fields are: `a0`, `a1`, `a2`, `a3`, `a4` ... and 5 others\n+help: some of the expressions' fields have a field of the same name\n+   |\n+LL |     t.a0.field;\n+   |       +++\n+LL |     t.a1.field;\n+   |       +++\n+LL |     t.a2.field;\n+   |       +++\n+LL |     t.a3.field;\n+   |       +++\n+     and 6 other candidates\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0599, E0609.\n+For more information about an error, try `rustc --explain E0599`."}]}