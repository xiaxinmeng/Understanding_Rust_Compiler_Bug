{"sha": "4cf720abbe8ee038b6261fad75a4aba79f606f0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZjcyMGFiYmU4ZWUwMzhiNjI2MWZhZDc1YTRhYmE3OWY2MDZmMGQ=", "commit": {"author": {"name": "Wilco Kusee", "email": "wilcokusee@gmail.com", "date": "2019-01-19T11:53:21Z"}, "committer": {"name": "Wilco Kusee", "email": "wilcokusee@gmail.com", "date": "2019-02-26T16:27:41Z"}, "message": "Move lint_map_unwrap_or to its own file", "tree": {"sha": "ee7ec0475cd87e3d662f98ff051ac4dae1bf1d48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee7ec0475cd87e3d662f98ff051ac4dae1bf1d48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cf720abbe8ee038b6261fad75a4aba79f606f0d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQEcBAABAgAGBQJcdWj9AAoJENWyu1zcMzS8L+cH/2WXCUFGQo2R75LIw6zcPnWB\n5oHzlYdntObav23Lqk3wcQW3Ko5MtMCOmBaUtrRQ6CJ5O18ihj4UjJDDGU+Yo+mH\n41uGvNugBY5ifkREXn312/QFWhyQQjMrkSFo+gVpq5uyzYsnkYD55tzZmF7EBu6U\nM91Ucr39k42Y31ZA0ZoiyJzMG8qHV+UobXX98AYcGWVSh+OfL/6n0X/SvSqAWN4p\ngC8L08xu+cNisyn9i3rw2HxWYgbcdLk/qAJ1Yuy14huwNswMm/9uOHDoW+u8yovC\n17o66PaXmikKR3BUWB7C8Zy2BWsvax4MXEYzzzYo/JyhwWVVOBGznPqfUkyb/GA=\n=PENL\n-----END PGP SIGNATURE-----", "payload": "tree ee7ec0475cd87e3d662f98ff051ac4dae1bf1d48\nparent 54ab22f6dbfc8493dfb2cbcc5030d70c5770531f\nauthor Wilco Kusee <wilcokusee@gmail.com> 1547898801 +0100\ncommitter Wilco Kusee <wilcokusee@gmail.com> 1551198461 +0100\n\nMove lint_map_unwrap_or to its own file\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cf720abbe8ee038b6261fad75a4aba79f606f0d", "html_url": "https://github.com/rust-lang/rust/commit/4cf720abbe8ee038b6261fad75a4aba79f606f0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cf720abbe8ee038b6261fad75a4aba79f606f0d/comments", "author": {"login": "detrumi", "id": 5758008, "node_id": "MDQ6VXNlcjU3NTgwMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/5758008?v=4", "gravatar_id": "", "url": "https://api.github.com/users/detrumi", "html_url": "https://github.com/detrumi", "followers_url": "https://api.github.com/users/detrumi/followers", "following_url": "https://api.github.com/users/detrumi/following{/other_user}", "gists_url": "https://api.github.com/users/detrumi/gists{/gist_id}", "starred_url": "https://api.github.com/users/detrumi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/detrumi/subscriptions", "organizations_url": "https://api.github.com/users/detrumi/orgs", "repos_url": "https://api.github.com/users/detrumi/repos", "events_url": "https://api.github.com/users/detrumi/events{/privacy}", "received_events_url": "https://api.github.com/users/detrumi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "detrumi", "id": 5758008, "node_id": "MDQ6VXNlcjU3NTgwMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/5758008?v=4", "gravatar_id": "", "url": "https://api.github.com/users/detrumi", "html_url": "https://github.com/detrumi", "followers_url": "https://api.github.com/users/detrumi/followers", "following_url": "https://api.github.com/users/detrumi/following{/other_user}", "gists_url": "https://api.github.com/users/detrumi/gists{/gist_id}", "starred_url": "https://api.github.com/users/detrumi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/detrumi/subscriptions", "organizations_url": "https://api.github.com/users/detrumi/orgs", "repos_url": "https://api.github.com/users/detrumi/repos", "events_url": "https://api.github.com/users/detrumi/events{/privacy}", "received_events_url": "https://api.github.com/users/detrumi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54ab22f6dbfc8493dfb2cbcc5030d70c5770531f", "url": "https://api.github.com/repos/rust-lang/rust/commits/54ab22f6dbfc8493dfb2cbcc5030d70c5770531f", "html_url": "https://github.com/rust-lang/rust/commit/54ab22f6dbfc8493dfb2cbcc5030d70c5770531f"}], "stats": {"total": 95, "additions": 51, "deletions": 44}, "files": [{"sha": "8d4bb06e59be63e951034e742295330aab33bdf2", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 44, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4cf720abbe8ee038b6261fad75a4aba79f606f0d/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf720abbe8ee038b6261fad75a4aba79f606f0d/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=4cf720abbe8ee038b6261fad75a4aba79f606f0d", "patch": "@@ -22,6 +22,7 @@ use syntax::ast;\n use syntax::source_map::{BytePos, Span};\n use syntax::symbol::LocalInternedString;\n \n+mod option_map_unwrap_or;\n mod unnecessary_filter_map;\n \n #[derive(Clone)]\n@@ -836,7 +837,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             [\"unwrap\", \"get_mut\"] => lint_get_unwrap(cx, expr, arg_lists[1], true),\n             [\"unwrap\", ..] => lint_unwrap(cx, expr, arg_lists[0]),\n             [\"expect\", \"ok\"] => lint_ok_expect(cx, expr, arg_lists[1]),\n-            [\"unwrap_or\", \"map\"] => lint_map_unwrap_or(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"unwrap_or\", \"map\"] => option_map_unwrap_or::lint(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"unwrap_or_else\", \"map\"] => lint_map_unwrap_or_else(cx, expr, arg_lists[1], arg_lists[0]),\n             [\"map_or\", ..] => lint_map_or_none(cx, expr, arg_lists[0]),\n             [\"next\", \"filter\"] => lint_filter_next(cx, expr, arg_lists[1]),\n@@ -1769,49 +1770,6 @@ fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, ok_args: &[hir::Ex\n     }\n }\n \n-/// lint use of `map().unwrap_or()` for `Option`s\n-fn lint_map_unwrap_or(cx: &LateContext<'_, '_>, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n-    // lint if the caller of `map()` is an `Option`\n-    let unwrap_ty = cx.tables.expr_ty(&unwrap_args[1]);\n-    if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) && is_copy(cx, unwrap_ty) {\n-        // get snippets for args to map() and unwrap_or()\n-        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n-        // lint message\n-        // comparing the snippet from source to raw text (\"None\") below is safe\n-        // because we already have checked the type.\n-        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n-        let suggest = if unwrap_snippet == \"None\" {\n-            \"and_then(f)\"\n-        } else {\n-            \"map_or(a, f)\"\n-        };\n-        let msg = &format!(\n-            \"called `map(f).unwrap_or({})` on an Option value. \\\n-             This can be done more directly by calling `{}` instead\",\n-            arg, suggest\n-        );\n-        // lint, with note if neither arg is > 1 line and both map() and\n-        // unwrap_or() have the same span\n-        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n-        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n-        if same_span && !multiline {\n-            let suggest = if unwrap_snippet == \"None\" {\n-                format!(\"and_then({})\", map_snippet)\n-            } else {\n-                format!(\"map_or({}, {})\", unwrap_snippet, map_snippet)\n-            };\n-            let note = format!(\n-                \"replace `map({}).unwrap_or({})` with `{}`\",\n-                map_snippet, unwrap_snippet, suggest\n-            );\n-            span_note_and_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span, &note);\n-        } else if same_span && multiline {\n-            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n-        };\n-    }\n-}\n-\n /// lint use of `map().flatten()` for `Iterators`\n fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_args: &'tcx [hir::Expr]) {\n     // lint if caller of `.map().flatten()` is an Iterator"}, {"sha": "39bcf415fe9290928d19fcd7f1abfe0158aabb5f", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4cf720abbe8ee038b6261fad75a4aba79f606f0d/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cf720abbe8ee038b6261fad75a4aba79f606f0d/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=4cf720abbe8ee038b6261fad75a4aba79f606f0d", "patch": "@@ -0,0 +1,49 @@\n+use crate::utils::paths;\n+use crate::utils::{is_copy, match_type, snippet, span_lint, span_note_and_lint};\n+use rustc::hir;\n+use rustc::lint::LateContext;\n+\n+use super::OPTION_MAP_UNWRAP_OR;\n+\n+/// lint use of `map().unwrap_or()` for `Option`s\n+pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, map_args: &[hir::Expr], unwrap_args: &[hir::Expr]) {\n+    // lint if the caller of `map()` is an `Option`\n+    let unwrap_ty = cx.tables.expr_ty(&unwrap_args[1]);\n+    if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) && is_copy(cx, unwrap_ty) {\n+        // get snippets for args to map() and unwrap_or()\n+        let map_snippet = snippet(cx, map_args[1].span, \"..\");\n+        let unwrap_snippet = snippet(cx, unwrap_args[1].span, \"..\");\n+        // lint message\n+        // comparing the snippet from source to raw text (\"None\") below is safe\n+        // because we already have checked the type.\n+        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n+        let suggest = if unwrap_snippet == \"None\" {\n+            \"and_then(f)\"\n+        } else {\n+            \"map_or(a, f)\"\n+        };\n+        let msg = &format!(\n+            \"called `map(f).unwrap_or({})` on an Option value. \\\n+             This can be done more directly by calling `{}` instead\",\n+            arg, suggest\n+        );\n+        // lint, with note if neither arg is > 1 line and both map() and\n+        // unwrap_or() have the same span\n+        let multiline = map_snippet.lines().count() > 1 || unwrap_snippet.lines().count() > 1;\n+        let same_span = map_args[1].span.ctxt() == unwrap_args[1].span.ctxt();\n+        if same_span && !multiline {\n+            let suggest = if unwrap_snippet == \"None\" {\n+                format!(\"and_then({})\", map_snippet)\n+            } else {\n+                format!(\"map_or({}, {})\", unwrap_snippet, map_snippet)\n+            };\n+            let note = format!(\n+                \"replace `map({}).unwrap_or({})` with `{}`\",\n+                map_snippet, unwrap_snippet, suggest\n+            );\n+            span_note_and_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg, expr.span, &note);\n+        } else if same_span && multiline {\n+            span_lint(cx, OPTION_MAP_UNWRAP_OR, expr.span, msg);\n+        };\n+    }\n+}"}]}