{"sha": "521a6e62b14b2e44d58972c9e28772fc9685b6d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMWE2ZTYyYjE0YjJlNDRkNTg5NzJjOWUyODc3MmZjOTY4NWI2ZDU=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-09T21:04:19Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-13T22:03:48Z"}, "message": "librustc_typeck: use unboxed closures", "tree": {"sha": "c352cc891db33455d4a3c7e1f0b106f500022a9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c352cc891db33455d4a3c7e1f0b106f500022a9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/521a6e62b14b2e44d58972c9e28772fc9685b6d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/521a6e62b14b2e44d58972c9e28772fc9685b6d5", "html_url": "https://github.com/rust-lang/rust/commit/521a6e62b14b2e44d58972c9e28772fc9685b6d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/521a6e62b14b2e44d58972c9e28772fc9685b6d5/comments", "author": null, "committer": null, "parents": [{"sha": "888f24969fc06d9aa783c71ab0d1f1b88a58f170", "url": "https://api.github.com/repos/rust-lang/rust/commits/888f24969fc06d9aa783c71ab0d1f1b88a58f170", "html_url": "https://github.com/rust-lang/rust/commit/888f24969fc06d9aa783c71ab0d1f1b88a58f170"}], "stats": {"total": 133, "additions": 72, "deletions": 61}, "files": [{"sha": "980097eaead997648819ae2d6a529115a2bf650c", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/521a6e62b14b2e44d58972c9e28772fc9685b6d5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521a6e62b14b2e44d58972c9e28772fc9685b6d5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=521a6e62b14b2e44d58972c9e28772fc9685b6d5", "patch": "@@ -28,12 +28,14 @@ pub fn suptype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn suptype_with_fn<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                 sp: Span,\n-                                 b_is_expected: bool,\n-                                 ty_a: Ty<'tcx>,\n-                                 ty_b: Ty<'tcx>,\n-                                 handle_err: |Span, Ty<'tcx>, Ty<'tcx>, &ty::type_err<'tcx>|) {\n+pub fn suptype_with_fn<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                    sp: Span,\n+                                    b_is_expected: bool,\n+                                    ty_a: Ty<'tcx>,\n+                                    ty_b: Ty<'tcx>,\n+                                    handle_err: F) where\n+    F: FnOnce(Span, Ty<'tcx>, Ty<'tcx>, &ty::type_err<'tcx>),\n+{\n     // n.b.: order of actual, expected is reversed\n     match infer::mk_subty(fcx.infcx(), b_is_expected, infer::Misc(sp),\n                           ty_b, ty_a) {"}, {"sha": "3c7cecc96a320d0f18254c3cab648ad298baffe2", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/521a6e62b14b2e44d58972c9e28772fc9685b6d5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521a6e62b14b2e44d58972c9e28772fc9685b6d5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=521a6e62b14b2e44d58972c9e28772fc9685b6d5", "patch": "@@ -286,11 +286,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         }\n     }\n \n-    fn extract_trait_ref<R>(&mut self,\n-                            self_ty: Ty<'tcx>,\n-                            closure: |&mut ConfirmContext<'a,'tcx>,\n-                                      Ty<'tcx>, &ty::TyTrait<'tcx>| -> R)\n-                            -> R\n+    fn extract_trait_ref<R, F>(&mut self, self_ty: Ty<'tcx>, mut closure: F) -> R where\n+        F: FnMut(&mut ConfirmContext<'a, 'tcx>, Ty<'tcx>, &ty::TyTrait<'tcx>) -> R,\n     {\n         // If we specified that this is an object method, then the\n         // self-type ought to be something that can be dereferenced to\n@@ -665,9 +662,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n }\n \n-fn wrap_autoref<'tcx>(mut deref: ty::AutoDerefRef<'tcx>,\n-                      base_fn: |Option<Box<ty::AutoRef<'tcx>>>| -> ty::AutoRef<'tcx>)\n-                      -> ty::AutoDerefRef<'tcx> {\n+fn wrap_autoref<'tcx, F>(mut deref: ty::AutoDerefRef<'tcx>,\n+                         base_fn: F)\n+                         -> ty::AutoDerefRef<'tcx> where\n+    F: FnOnce(Option<Box<ty::AutoRef<'tcx>>>) -> ty::AutoRef<'tcx>,\n+{\n     let autoref = mem::replace(&mut deref.autoref, None);\n     let autoref = autoref.map(|r| box r);\n     deref.autoref = Some(base_fn(autoref));"}, {"sha": "adcfc491dcc4fecf7a0cd057e6211cc217508355", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/521a6e62b14b2e44d58972c9e28772fc9685b6d5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521a6e62b14b2e44d58972c9e28772fc9685b6d5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=521a6e62b14b2e44d58972c9e28772fc9685b6d5", "patch": "@@ -710,10 +710,12 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                mutbl: m }))\n     }\n \n-    fn search_mutabilities(&mut self,\n-                           mk_adjustment: |ast::Mutability| -> PickAdjustment,\n-                           mk_autoref_ty: |ast::Mutability, ty::Region| -> Ty<'tcx>)\n-                           -> Option<PickResult<'tcx>>\n+    fn search_mutabilities<F, G>(&mut self,\n+                                 mut mk_adjustment: F,\n+                                 mut mk_autoref_ty: G)\n+                                 -> Option<PickResult<'tcx>> where\n+        F: FnMut(ast::Mutability) -> PickAdjustment,\n+        G: FnMut(ast::Mutability, ty::Region) -> Ty<'tcx>,\n     {\n         // In general, during probing we erase regions. See\n         // `impl_self_ty()` for an explanation."}, {"sha": "18a773fb949fcec1ec1c3b4e728d9b57031f557d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/521a6e62b14b2e44d58972c9e28772fc9685b6d5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521a6e62b14b2e44d58972c9e28772fc9685b6d5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=521a6e62b14b2e44d58972c9e28772fc9685b6d5", "patch": "@@ -1885,9 +1885,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.inh.item_substs.borrow()\n     }\n \n-    pub fn opt_node_ty_substs(&self,\n-                              id: ast::NodeId,\n-                              f: |&ty::ItemSubsts<'tcx>|) {\n+    pub fn opt_node_ty_substs<F>(&self,\n+                                 id: ast::NodeId,\n+                                 f: F) where\n+        F: FnOnce(&ty::ItemSubsts<'tcx>),\n+    {\n         match self.inh.item_substs.borrow().get(&id) {\n             Some(s) => { f(s) }\n             None => { }\n@@ -2027,12 +2029,14 @@ impl Copy for LvaluePreference {}\n ///\n /// Note: this method does not modify the adjustments table. The caller is responsible for\n /// inserting an AutoAdjustment record into the `fcx` using one of the suitable methods.\n-pub fn autoderef<'a, 'tcx, T>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                              base_ty: Ty<'tcx>,\n-                              expr_id: Option<ast::NodeId>,\n-                              mut lvalue_pref: LvaluePreference,\n-                              should_stop: |Ty<'tcx>, uint| -> Option<T>)\n-                              -> (Ty<'tcx>, uint, Option<T>) {\n+pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n+                                 base_ty: Ty<'tcx>,\n+                                 expr_id: Option<ast::NodeId>,\n+                                 mut lvalue_pref: LvaluePreference,\n+                                 mut should_stop: F)\n+                                 -> (Ty<'tcx>, uint, Option<T>) where\n+    F: FnMut(Ty<'tcx>, uint) -> Option<T>,\n+{\n     let mut t = base_ty;\n     for autoderefs in range(0, fcx.tcx().sess.recursion_limit.get()) {\n         let resolved_t = structurally_resolved_type(fcx, sp, t);\n@@ -2194,12 +2198,13 @@ fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-fn autoderef_for_index<'a, 'tcx, T>(fcx: &FnCtxt<'a, 'tcx>,\n-                                    base_expr: &ast::Expr,\n-                                    base_ty: Ty<'tcx>,\n-                                    lvalue_pref: LvaluePreference,\n-                                    step: |Ty<'tcx>, ty::AutoDerefRef<'tcx>| -> Option<T>)\n-                                    -> Option<T>\n+fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                       base_expr: &ast::Expr,\n+                                       base_ty: Ty<'tcx>,\n+                                       lvalue_pref: LvaluePreference,\n+                                       mut step: F)\n+                                       -> Option<T> where\n+    F: FnMut(Ty<'tcx>, ty::AutoDerefRef<'tcx>) -> Option<T>,\n {\n     // FIXME(#18741) -- this is almost but not quite the same as the\n     // autoderef that normal method probing does. They could likely be\n@@ -2938,11 +2943,12 @@ enum TupleArgumentsFlag {\n /// Note that inspecting a type's structure *directly* may expose the fact\n /// that there are actually multiple representations for `ty_err`, so avoid\n /// that when err needs to be handled differently.\n-fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                     expr: &ast::Expr,\n-                                     expected: Expectation<'tcx>,\n-                                     lvalue_pref: LvaluePreference,\n-                                     unifier: ||)\n+fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                        expr: &ast::Expr,\n+                                        expected: Expectation<'tcx>,\n+                                        lvalue_pref: LvaluePreference,\n+                                        unifier: F) where\n+    F: FnOnce(),\n {\n     debug!(\">> typechecking: expr={} expected={}\",\n            expr.repr(fcx.tcx()), expected.repr(fcx.tcx()));\n@@ -3117,14 +3123,16 @@ fn check_expr_with_unifier<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, if_ty);\n     }\n \n-    fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n-                                  op_ex: &ast::Expr,\n-                                  lhs_ty: Ty<'tcx>,\n-                                  opname: ast::Name,\n-                                  trait_did: Option<ast::DefId>,\n-                                  lhs: &'a ast::Expr,\n-                                  rhs: Option<&P<ast::Expr>>,\n-                                  unbound_method: ||) -> Ty<'tcx> {\n+    fn lookup_op_method<'a, 'tcx, F>(fcx: &'a FnCtxt<'a, 'tcx>,\n+                                     op_ex: &ast::Expr,\n+                                     lhs_ty: Ty<'tcx>,\n+                                     opname: ast::Name,\n+                                     trait_did: Option<ast::DefId>,\n+                                     lhs: &'a ast::Expr,\n+                                     rhs: Option<&P<ast::Expr>>,\n+                                     unbound_method: F) -> Ty<'tcx> where\n+        F: FnOnce(),\n+    {\n         let method = match trait_did {\n             Some(trait_did) => {\n                 // We do eager coercions to make using operators\n@@ -4376,19 +4384,17 @@ impl<'tcx> Expectation<'tcx> {\n         }\n     }\n \n-    fn map<'a>(self, fcx: &FnCtxt<'a, 'tcx>,\n-               unpack: |&ty::sty<'tcx>| -> Expectation<'tcx>)\n-               -> Expectation<'tcx> {\n+    fn map<'a, F>(self, fcx: &FnCtxt<'a, 'tcx>, unpack: F) -> Expectation<'tcx> where\n+        F: FnOnce(&ty::sty<'tcx>) -> Expectation<'tcx>\n+    {\n         match self.resolve(fcx) {\n             NoExpectation => NoExpectation,\n             ExpectCastableToType(t) | ExpectHasType(t) => unpack(&t.sty),\n         }\n     }\n \n-    fn map_to_option<'a, O>(self,\n-                            fcx: &FnCtxt<'a, 'tcx>,\n-                            unpack: |&ty::sty<'tcx>| -> Option<O>)\n-                            -> Option<O>\n+    fn map_to_option<'a, O, F>(self, fcx: &FnCtxt<'a, 'tcx>, unpack: F) -> Option<O> where\n+        F: FnOnce(&ty::sty<'tcx>) -> Option<O>,\n     {\n         match self.resolve(fcx) {\n             NoExpectation => None,"}, {"sha": "32c732c2467167aab02e7e31b911a59af52bdf71", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/521a6e62b14b2e44d58972c9e28772fc9685b6d5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/521a6e62b14b2e44d58972c9e28772fc9685b6d5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=521a6e62b14b2e44d58972c9e28772fc9685b6d5", "patch": "@@ -170,14 +170,16 @@ fn no_params<'tcx>(t: Ty<'tcx>) -> ty::Polytype<'tcx> {\n     }\n }\n \n-fn require_same_types<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                    maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n-                                    t1_is_expected: bool,\n-                                    span: Span,\n-                                    t1: Ty<'tcx>,\n-                                    t2: Ty<'tcx>,\n-                                    msg: || -> String)\n-                                    -> bool {\n+fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n+                                   maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n+                                   t1_is_expected: bool,\n+                                   span: Span,\n+                                   t1: Ty<'tcx>,\n+                                   t2: Ty<'tcx>,\n+                                   msg: M)\n+                                   -> bool where\n+    M: FnOnce() -> String,\n+{\n     let result = match maybe_infcx {\n         None => {\n             let infcx = infer::new_infer_ctxt(tcx);"}]}