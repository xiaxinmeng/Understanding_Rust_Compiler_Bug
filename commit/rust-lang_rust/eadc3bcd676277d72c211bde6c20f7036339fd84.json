{"sha": "eadc3bcd676277d72c211bde6c20f7036339fd84", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhZGMzYmNkNjc2Mjc3ZDcyYzIxMWJkZTZjMjBmNzAzNjMzOWZkODQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-03T22:44:14Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-10T08:03:38Z"}, "message": "std: Unconditionally close all file descriptors\n\nThe logic for only closing file descriptors >= 3 was inherited from quite some\ntime ago and ends up meaning that some internal APIs are less consistent than\nthey should be. By unconditionally closing everything entering a `FileDesc` we\nensure that we're consistent in our behavior as well as robustly handling the\nstdio case.", "tree": {"sha": "7ec781b484adac13c8b4ad3bbb676bb5383faa0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ec781b484adac13c8b4ad3bbb676bb5383faa0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eadc3bcd676277d72c211bde6c20f7036339fd84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eadc3bcd676277d72c211bde6c20f7036339fd84", "html_url": "https://github.com/rust-lang/rust/commit/eadc3bcd676277d72c211bde6c20f7036339fd84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eadc3bcd676277d72c211bde6c20f7036339fd84/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33a2191d0b880242b3bf9a32477a6b432f931c80", "url": "https://api.github.com/repos/rust-lang/rust/commits/33a2191d0b880242b3bf9a32477a6b432f931c80", "html_url": "https://github.com/rust-lang/rust/commit/33a2191d0b880242b3bf9a32477a6b432f931c80"}], "stats": {"total": 153, "additions": 86, "deletions": 67}, "files": [{"sha": "90eabaee77b6b28e47b89ed8226c07c28c0638cf", "filename": "src/libstd/process.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eadc3bcd676277d72c211bde6c20f7036339fd84/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eadc3bcd676277d72c211bde6c20f7036339fd84/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=eadc3bcd676277d72c211bde6c20f7036339fd84", "patch": "@@ -19,13 +19,13 @@ use io::prelude::*;\n use ffi::OsStr;\n use fmt;\n use io::{self, Error, ErrorKind};\n-use libc;\n use path;\n use sync::mpsc::{channel, Receiver};\n use sys::pipe2::{self, AnonPipe};\n use sys::process2::Command as CommandImp;\n use sys::process2::Process as ProcessImp;\n use sys::process2::ExitStatus as ExitStatusImp;\n+use sys::process2::Stdio as StdioImp2;\n use sys_common::{AsInner, AsInnerMut};\n use thread;\n \n@@ -229,13 +229,13 @@ impl Command {\n \n     fn spawn_inner(&self, default_io: StdioImp) -> io::Result<Child> {\n         let (their_stdin, our_stdin) = try!(\n-            setup_io(self.stdin.as_ref().unwrap_or(&default_io), 0, true)\n+            setup_io(self.stdin.as_ref().unwrap_or(&default_io), true)\n         );\n         let (their_stdout, our_stdout) = try!(\n-            setup_io(self.stdout.as_ref().unwrap_or(&default_io), 1, false)\n+            setup_io(self.stdout.as_ref().unwrap_or(&default_io), false)\n         );\n         let (their_stderr, our_stderr) = try!(\n-            setup_io(self.stderr.as_ref().unwrap_or(&default_io), 2, false)\n+            setup_io(self.stderr.as_ref().unwrap_or(&default_io), false)\n         );\n \n         match ProcessImp::spawn(&self.inner, their_stdin, their_stdout, their_stderr) {\n@@ -328,23 +328,19 @@ impl AsInnerMut<CommandImp> for Command {\n     fn as_inner_mut(&mut self) -> &mut CommandImp { &mut self.inner }\n }\n \n-fn setup_io(io: &StdioImp, fd: libc::c_int, readable: bool)\n-            -> io::Result<(Option<AnonPipe>, Option<AnonPipe>)>\n+fn setup_io(io: &StdioImp, readable: bool)\n+            -> io::Result<(StdioImp2, Option<AnonPipe>)>\n {\n     use self::StdioImp::*;\n     Ok(match *io {\n-        Null => {\n-            (None, None)\n-        }\n-        Inherit => {\n-            (Some(AnonPipe::from_fd(fd)), None)\n-        }\n+        Null => (StdioImp2::None, None),\n+        Inherit => (StdioImp2::Inherit, None),\n         Piped => {\n             let (reader, writer) = try!(pipe2::anon_pipe());\n             if readable {\n-                (Some(reader), Some(writer))\n+                (StdioImp2::Piped(reader), Some(writer))\n             } else {\n-                (Some(writer), Some(reader))\n+                (StdioImp2::Piped(writer), Some(reader))\n             }\n         }\n     })"}, {"sha": "d86c77624e833eb5c559c2654c7a5941343d3bcf", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eadc3bcd676277d72c211bde6c20f7036339fd84/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eadc3bcd676277d72c211bde6c20f7036339fd84/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=eadc3bcd676277d72c211bde6c20f7036339fd84", "patch": "@@ -59,13 +59,6 @@ impl FileDesc {\n             debug_assert_eq!(ret, 0);\n         }\n     }\n-\n-    pub fn unset_cloexec(&self) {\n-        unsafe {\n-            let ret = c::ioctl(self.fd, c::FIONCLEX);\n-            debug_assert_eq!(ret, 0);\n-        }\n-    }\n }\n \n impl AsInner<c_int> for FileDesc {\n@@ -74,14 +67,11 @@ impl AsInner<c_int> for FileDesc {\n \n impl Drop for FileDesc {\n     fn drop(&mut self) {\n-        // closing stdio file handles makes no sense, so never do it. Also, note\n-        // that errors are ignored when closing a file descriptor. The reason\n-        // for this is that if an error occurs we don't actually know if the\n-        // file descriptor was closed or not, and if we retried (for something\n-        // like EINTR), we might close another valid file descriptor (opened\n-        // after we closed ours.\n-        if self.fd > libc::STDERR_FILENO {\n-            let _ = unsafe { libc::close(self.fd) };\n-        }\n+        // Note that errors are ignored when closing a file descriptor. The\n+        // reason for this is that if an error occurs we don't actually know if\n+        // the file descriptor was closed or not, and if we retried (for\n+        // something like EINTR), we might close another valid file descriptor\n+        // (opened after we closed ours.\n+        let _ = unsafe { libc::close(self.fd) };\n     }\n }"}, {"sha": "0b4e871454db044d347fc3b03a421e39c358d254", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/eadc3bcd676277d72c211bde6c20f7036339fd84/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eadc3bcd676277d72c211bde6c20f7036339fd84/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=eadc3bcd676277d72c211bde6c20f7036339fd84", "patch": "@@ -119,6 +119,12 @@ pub struct Process {\n     pid: pid_t\n }\n \n+pub enum Stdio {\n+    Inherit,\n+    Piped(AnonPipe),\n+    None,\n+}\n+\n const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n \n impl Process {\n@@ -128,9 +134,9 @@ impl Process {\n     }\n \n     pub fn spawn(cfg: &Command,\n-                 in_fd: Option<AnonPipe>,\n-                 out_fd: Option<AnonPipe>,\n-                 err_fd: Option<AnonPipe>) -> io::Result<Process> {\n+                 in_fd: Stdio,\n+                 out_fd: Stdio,\n+                 err_fd: Stdio) -> io::Result<Process> {\n         let dirp = cfg.cwd.as_ref().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n \n         let (envp, _a, _b) = make_envp(cfg.env.as_ref());\n@@ -224,9 +230,9 @@ impl Process {\n                                argv: *const *const libc::c_char,\n                                envp: *const libc::c_void,\n                                dirp: *const libc::c_char,\n-                               in_fd: Option<AnonPipe>,\n-                               out_fd: Option<AnonPipe>,\n-                               err_fd: Option<AnonPipe>) -> ! {\n+                               in_fd: Stdio,\n+                               out_fd: Stdio,\n+                               err_fd: Stdio) -> ! {\n         fn fail(output: &mut AnonPipe) -> ! {\n             let errno = sys::os::errno() as u32;\n             let bytes = [\n@@ -244,23 +250,30 @@ impl Process {\n             unsafe { libc::_exit(1) }\n         }\n \n-        // If a stdio file descriptor is set to be ignored, we don't\n-        // actually close it, but rather open up /dev/null into that\n-        // file descriptor. Otherwise, the first file descriptor opened\n-        // up in the child would be numbered as one of the stdio file\n-        // descriptors, which is likely to wreak havoc.\n-        let setup = |src: Option<AnonPipe>, dst: c_int| {\n-            src.map(|p| p.into_fd()).or_else(|| {\n-                let mut opts = OpenOptions::new();\n-                opts.read(dst == libc::STDIN_FILENO);\n-                opts.write(dst != libc::STDIN_FILENO);\n-                let devnull = CStr::from_ptr(b\"/dev/null\\0\".as_ptr()\n-                                                as *const _);\n-                File::open_c(devnull, &opts).ok().map(|f| f.into_fd())\n-            }).map(|fd| {\n-                fd.unset_cloexec();\n-                retry(|| libc::dup2(fd.raw(), dst)) != -1\n-            }).unwrap_or(false)\n+        let setup = |src: Stdio, dst: c_int| {\n+            let fd = match src {\n+                Stdio::Inherit => return true,\n+                Stdio::Piped(pipe) => pipe.into_fd(),\n+\n+                // If a stdio file descriptor is set to be ignored, we open up\n+                // /dev/null into that file descriptor. Otherwise, the first\n+                // file descriptor opened up in the child would be numbered as\n+                // one of the stdio file descriptors, which is likely to wreak\n+                // havoc.\n+                Stdio::None => {\n+                    let mut opts = OpenOptions::new();\n+                    opts.read(dst == libc::STDIN_FILENO);\n+                    opts.write(dst != libc::STDIN_FILENO);\n+                    let devnull = CStr::from_ptr(b\"/dev/null\\0\".as_ptr()\n+                                                    as *const _);\n+                    if let Ok(f) = File::open_c(devnull, &opts) {\n+                        f.into_fd()\n+                    } else {\n+                        return false\n+                    }\n+                }\n+            };\n+            retry(|| libc::dup2(fd.raw(), dst)) != -1\n         };\n \n         if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }"}, {"sha": "7495392192170ab91914a6bd9196c2954f2737a2", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/eadc3bcd676277d72c211bde6c20f7036339fd84/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eadc3bcd676277d72c211bde6c20f7036339fd84/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=eadc3bcd676277d72c211bde6c20f7036339fd84", "patch": "@@ -105,11 +105,18 @@ pub struct Process {\n     handle: Handle,\n }\n \n+pub enum Stdio {\n+    Inherit,\n+    Piped(AnonPipe),\n+    None,\n+}\n+\n impl Process {\n     #[allow(deprecated)]\n     pub fn spawn(cfg: &Command,\n-                 in_fd: Option<AnonPipe>, out_fd: Option<AnonPipe>, err_fd: Option<AnonPipe>)\n-                 -> io::Result<Process>\n+                 in_fd: Stdio,\n+                 out_fd: Stdio,\n+                 err_fd: Stdio) -> io::Result<Process>\n     {\n         use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n         use libc::consts::os::extra::{\n@@ -156,13 +163,16 @@ impl Process {\n \n             let cur_proc = GetCurrentProcess();\n \n-            // Similarly to unix, we don't actually leave holes for the stdio file\n-            // descriptors, but rather open up /dev/null equivalents. These\n-            // equivalents are drawn from libuv's windows process spawning.\n-            let set_fd = |fd: &Option<AnonPipe>, slot: &mut HANDLE,\n+            let set_fd = |fd: &Stdio, slot: &mut HANDLE,\n                           is_stdin: bool| {\n                 match *fd {\n-                    None => {\n+                    Stdio::Inherit => {}\n+\n+                    // Similarly to unix, we don't actually leave holes for the\n+                    // stdio file descriptors, but rather open up /dev/null\n+                    // equivalents. These equivalents are drawn from libuv's\n+                    // windows process spawning.\n+                    Stdio::None => {\n                         let access = if is_stdin {\n                             libc::FILE_GENERIC_READ\n                         } else {\n@@ -188,11 +198,8 @@ impl Process {\n                             return Err(Error::last_os_error())\n                         }\n                     }\n-                    Some(ref pipe) => {\n+                    Stdio::Piped(ref pipe) => {\n                         let orig = pipe.raw();\n-                        if orig == INVALID_HANDLE_VALUE {\n-                            return Err(Error::last_os_error())\n-                        }\n                         if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n                                            0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n                             return Err(Error::last_os_error())\n@@ -235,9 +242,15 @@ impl Process {\n                 })\n             });\n \n-            assert!(CloseHandle(si.hStdInput) != 0);\n-            assert!(CloseHandle(si.hStdOutput) != 0);\n-            assert!(CloseHandle(si.hStdError) != 0);\n+            if !in_fd.inherited() {\n+                assert!(CloseHandle(si.hStdInput) != 0);\n+            }\n+            if !out_fd.inherited() {\n+                assert!(CloseHandle(si.hStdOutput) != 0);\n+            }\n+            if !err_fd.inherited() {\n+                assert!(CloseHandle(si.hStdError) != 0);\n+            }\n \n             match create_err {\n                 Some(err) => return Err(err),\n@@ -296,6 +309,12 @@ impl Process {\n     }\n }\n \n+impl Stdio {\n+    fn inherited(&self) -> bool {\n+        match *self { Stdio::Inherit => true, _ => false }\n+    }\n+}\n+\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub struct ExitStatus(i32);\n "}, {"sha": "cbf7830513ac9bb6f6d958d6bf27e5e514651614", "filename": "src/test/run-pass/fds-are-cloexec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eadc3bcd676277d72c211bde6c20f7036339fd84/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eadc3bcd676277d72c211bde6c20f7036339fd84/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs?ref=eadc3bcd676277d72c211bde6c20f7036339fd84", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // ignore-windows\n+// ignore-android\n \n #![feature(libc)]\n "}]}