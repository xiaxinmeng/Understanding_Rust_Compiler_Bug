{"sha": "23624504250058c36f42fe3eb76300da962e393b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNjI0NTA0MjUwMDU4YzM2ZjQyZmUzZWI3NjMwMGRhOTYyZTM5M2I=", "commit": {"author": {"name": "Fabian Wolff", "email": "fabian.wolff@alumni.ethz.ch", "date": "2021-07-13T11:18:03Z"}, "committer": {"name": "Fabian Wolff", "email": "fabian.wolff@alumni.ethz.ch", "date": "2021-07-13T23:15:59Z"}, "message": "Suggest a path separator if a stray colon is found in a match arm\n\nCo-authored-by: Esteban Kuber <estebank@users.noreply.github.com>", "tree": {"sha": "008ca675ae6696e0fc9458ee75d38d752398529a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/008ca675ae6696e0fc9458ee75d38d752398529a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23624504250058c36f42fe3eb76300da962e393b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23624504250058c36f42fe3eb76300da962e393b", "html_url": "https://github.com/rust-lang/rust/commit/23624504250058c36f42fe3eb76300da962e393b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23624504250058c36f42fe3eb76300da962e393b/comments", "author": {"login": "FabianWolff", "id": 16052130, "node_id": "MDQ6VXNlcjE2MDUyMTMw", "avatar_url": "https://avatars.githubusercontent.com/u/16052130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FabianWolff", "html_url": "https://github.com/FabianWolff", "followers_url": "https://api.github.com/users/FabianWolff/followers", "following_url": "https://api.github.com/users/FabianWolff/following{/other_user}", "gists_url": "https://api.github.com/users/FabianWolff/gists{/gist_id}", "starred_url": "https://api.github.com/users/FabianWolff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FabianWolff/subscriptions", "organizations_url": "https://api.github.com/users/FabianWolff/orgs", "repos_url": "https://api.github.com/users/FabianWolff/repos", "events_url": "https://api.github.com/users/FabianWolff/events{/privacy}", "received_events_url": "https://api.github.com/users/FabianWolff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "FabianWolff", "id": 16052130, "node_id": "MDQ6VXNlcjE2MDUyMTMw", "avatar_url": "https://avatars.githubusercontent.com/u/16052130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/FabianWolff", "html_url": "https://github.com/FabianWolff", "followers_url": "https://api.github.com/users/FabianWolff/followers", "following_url": "https://api.github.com/users/FabianWolff/following{/other_user}", "gists_url": "https://api.github.com/users/FabianWolff/gists{/gist_id}", "starred_url": "https://api.github.com/users/FabianWolff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/FabianWolff/subscriptions", "organizations_url": "https://api.github.com/users/FabianWolff/orgs", "repos_url": "https://api.github.com/users/FabianWolff/repos", "events_url": "https://api.github.com/users/FabianWolff/events{/privacy}", "received_events_url": "https://api.github.com/users/FabianWolff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "394804bb23bf0889c135a21f945b2fe44881ada8", "url": "https://api.github.com/repos/rust-lang/rust/commits/394804bb23bf0889c135a21f945b2fe44881ada8", "html_url": "https://github.com/rust-lang/rust/commit/394804bb23bf0889c135a21f945b2fe44881ada8"}], "stats": {"total": 238, "additions": 219, "deletions": 19}, "files": [{"sha": "76832c03c0997668d44cbb67f319d9f63b048d59", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/23624504250058c36f42fe3eb76300da962e393b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23624504250058c36f42fe3eb76300da962e393b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=23624504250058c36f42fe3eb76300da962e393b", "patch": "@@ -22,7 +22,9 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, FatalError, PResult};\n use rustc_feature::Features;\n-use rustc_parse::parser::{AttemptLocalParseRecovery, ForceCollect, Parser, RecoverComma};\n+use rustc_parse::parser::{\n+    AttemptLocalParseRecovery, ForceCollect, Parser, RecoverColon, RecoverComma,\n+};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -930,9 +932,11 @@ pub fn parse_ast_fragment<'a>(\n             }\n         }\n         AstFragmentKind::Ty => AstFragment::Ty(this.parse_ty()?),\n-        AstFragmentKind::Pat => {\n-            AstFragment::Pat(this.parse_pat_allow_top_alt(None, RecoverComma::No)?)\n-        }\n+        AstFragmentKind::Pat => AstFragment::Pat(this.parse_pat_allow_top_alt(\n+            None,\n+            RecoverComma::No,\n+            RecoverColon::Yes,\n+        )?),\n         AstFragmentKind::Arms\n         | AstFragmentKind::Fields\n         | AstFragmentKind::FieldPats"}, {"sha": "47fdd852d90de0e503f1996a413902d015935e10", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/23624504250058c36f42fe3eb76300da962e393b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23624504250058c36f42fe3eb76300da962e393b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=23624504250058c36f42fe3eb76300da962e393b", "patch": "@@ -1,4 +1,4 @@\n-use super::pat::{RecoverComma, PARAM_EXPECTED};\n+use super::pat::{RecoverColon, RecoverComma, PARAM_EXPECTED};\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{AttrWrapper, BlockMode, ForceCollect, Parser, PathStyle, Restrictions, TokenType};\n use super::{SemiColonMode, SeqSep, TokenExpectType, TrailingToken};\n@@ -1813,7 +1813,7 @@ impl<'a> Parser<'a> {\n     /// The `let` token has already been eaten.\n     fn parse_let_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n-        let pat = self.parse_pat_allow_top_alt(None, RecoverComma::Yes)?;\n+        let pat = self.parse_pat_allow_top_alt(None, RecoverComma::Yes, RecoverColon::Yes)?;\n         self.expect(&token::Eq)?;\n         let expr = self.with_res(self.restrictions | Restrictions::NO_STRUCT_LITERAL, |this| {\n             this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n@@ -1876,7 +1876,7 @@ impl<'a> Parser<'a> {\n             _ => None,\n         };\n \n-        let pat = self.parse_pat_allow_top_alt(None, RecoverComma::Yes)?;\n+        let pat = self.parse_pat_allow_top_alt(None, RecoverComma::Yes, RecoverColon::Yes)?;\n         if !self.eat_keyword(kw::In) {\n             self.error_missing_in_for_loop();\n         }\n@@ -2083,7 +2083,7 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_outer_attributes()?;\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n             let lo = this.token.span;\n-            let pat = this.parse_pat_allow_top_alt(None, RecoverComma::Yes)?;\n+            let pat = this.parse_pat_allow_top_alt(None, RecoverComma::Yes, RecoverColon::Yes)?;\n             let guard = if this.eat_keyword(kw::If) {\n                 let if_span = this.prev_token.span;\n                 let cond = this.parse_expr()?;"}, {"sha": "51d4e007b5984c21c7ec96e72d4740b80587a6e3", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23624504250058c36f42fe3eb76300da962e393b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23624504250058c36f42fe3eb76300da962e393b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=23624504250058c36f42fe3eb76300da962e393b", "patch": "@@ -14,7 +14,7 @@ use crate::lexer::UnmatchedBrace;\n pub use attr_wrapper::AttrWrapper;\n pub use diagnostics::AttemptLocalParseRecovery;\n use diagnostics::Error;\n-pub use pat::RecoverComma;\n+pub use pat::{RecoverColon, RecoverComma};\n pub use path::PathStyle;\n \n use rustc_ast::ptr::P;"}, {"sha": "313d9db58fc3febec5eb8010f23fd02cdb2f589e", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23624504250058c36f42fe3eb76300da962e393b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23624504250058c36f42fe3eb76300da962e393b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=23624504250058c36f42fe3eb76300da962e393b", "patch": "@@ -5,7 +5,7 @@ use rustc_ast_pretty::pprust;\n use rustc_errors::PResult;\n use rustc_span::symbol::{kw, Ident};\n \n-use crate::parser::pat::RecoverComma;\n+use crate::parser::pat::{RecoverColon, RecoverComma};\n use crate::parser::{FollowedByType, ForceCollect, Parser, PathStyle};\n \n impl<'a> Parser<'a> {\n@@ -125,7 +125,7 @@ impl<'a> Parser<'a> {\n                 token::NtPat(self.collect_tokens_no_attrs(|this| match kind {\n                     NonterminalKind::PatParam { .. } => this.parse_pat_no_top_alt(None),\n                     NonterminalKind::PatWithOr { .. } => {\n-                        this.parse_pat_allow_top_alt(None, RecoverComma::No)\n+                        this.parse_pat_allow_top_alt(None, RecoverComma::No, RecoverColon::No)\n                     }\n                     _ => unreachable!(),\n                 })?)"}, {"sha": "e047dae15973ec416cf1241ac7b9daa2ed644414", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 70, "deletions": 8, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/23624504250058c36f42fe3eb76300da962e393b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23624504250058c36f42fe3eb76300da962e393b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=23624504250058c36f42fe3eb76300da962e393b", "patch": "@@ -24,6 +24,13 @@ pub enum RecoverComma {\n     No,\n }\n \n+/// Whether or not to recover a `:` when parsing patterns that were meant to be paths.\n+#[derive(PartialEq, Copy, Clone)]\n+pub enum RecoverColon {\n+    Yes,\n+    No,\n+}\n+\n /// The result of `eat_or_separator`. We want to distinguish which case we are in to avoid\n /// emitting duplicate diagnostics.\n #[derive(Debug, Clone, Copy)]\n@@ -58,8 +65,9 @@ impl<'a> Parser<'a> {\n         &mut self,\n         expected: Expected,\n         rc: RecoverComma,\n+        ra: RecoverColon,\n     ) -> PResult<'a, P<Pat>> {\n-        self.parse_pat_allow_top_alt_inner(expected, rc).map(|(pat, _)| pat)\n+        self.parse_pat_allow_top_alt_inner(expected, rc, ra).map(|(pat, _)| pat)\n     }\n \n     /// Returns the pattern and a bool indicating whether we recovered from a trailing vert (true =\n@@ -68,6 +76,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         expected: Expected,\n         rc: RecoverComma,\n+        ra: RecoverColon,\n     ) -> PResult<'a, (P<Pat>, bool)> {\n         // Keep track of whether we recovered from a trailing vert so that we can avoid duplicated\n         // suggestions (which bothers rustfix).\n@@ -89,6 +98,56 @@ impl<'a> Parser<'a> {\n             // If we parsed a leading `|` which should be gated,\n             // then we should really gate the leading `|`.\n             // This complicated procedure is done purely for diagnostics UX.\n+            let mut first_pat = first_pat;\n+\n+            if let (RecoverColon::Yes, token::Colon) = (ra, &self.token.kind) {\n+                if matches!(\n+                    first_pat.kind,\n+                    PatKind::Ident(BindingMode::ByValue(Mutability::Not), _, None)\n+                        | PatKind::Path(..)\n+                ) && self.look_ahead(1, |token| token.is_ident() && !token.is_reserved_ident())\n+                {\n+                    // The pattern looks like it might be a path with a `::` -> `:` typo:\n+                    // `match foo { bar:baz => {} }`\n+                    let span = self.token.span;\n+                    // We only emit \"unexpected `:`\" error here if we can successfully parse the\n+                    // whole pattern correctly in that case.\n+                    let snapshot = self.clone();\n+\n+                    // Create error for \"unexpected `:`\".\n+                    match self.expected_one_of_not_found(&[], &[]) {\n+                        Err(mut err) => {\n+                            self.bump(); // Skip the `:`.\n+                            match self.parse_pat_no_top_alt(expected) {\n+                                Err(mut inner_err) => {\n+                                    // Carry on as if we had not done anything, callers will emit a\n+                                    // reasonable error.\n+                                    inner_err.cancel();\n+                                    err.cancel();\n+                                    *self = snapshot;\n+                                }\n+                                Ok(pat) => {\n+                                    // We've parsed the rest of the pattern.\n+                                    err.span_suggestion(\n+                                        span,\n+                                        \"maybe write a path separator here\",\n+                                        \"::\".to_string(),\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                    err.emit();\n+                                    first_pat =\n+                                        self.mk_pat(first_pat.span.to(pat.span), PatKind::Wild);\n+                                }\n+                            }\n+                        }\n+                        _ => {\n+                            // Carry on as if we had not done anything. This should be unreachable.\n+                            *self = snapshot;\n+                        }\n+                    };\n+                }\n+            }\n+\n             if let Some(leading_vert_span) = leading_vert_span {\n                 // If there was a leading vert, treat this as an or-pattern. This improves\n                 // diagnostics.\n@@ -140,7 +199,8 @@ impl<'a> Parser<'a> {\n         // We use `parse_pat_allow_top_alt` regardless of whether we actually want top-level\n         // or-patterns so that we can detect when a user tries to use it. This allows us to print a\n         // better error message.\n-        let (pat, trailing_vert) = self.parse_pat_allow_top_alt_inner(expected, rc)?;\n+        let (pat, trailing_vert) =\n+            self.parse_pat_allow_top_alt_inner(expected, rc, RecoverColon::No)?;\n         let colon = self.eat(&token::Colon);\n \n         if let PatKind::Or(pats) = &pat.kind {\n@@ -350,7 +410,7 @@ impl<'a> Parser<'a> {\n         } else if self.check(&token::OpenDelim(token::Bracket)) {\n             // Parse `[pat, pat,...]` as a slice pattern.\n             let (pats, _) = self.parse_delim_comma_seq(token::Bracket, |p| {\n-                p.parse_pat_allow_top_alt(None, RecoverComma::No)\n+                p.parse_pat_allow_top_alt(None, RecoverComma::No, RecoverColon::No)\n             })?;\n             PatKind::Slice(pats)\n         } else if self.check(&token::DotDot) && !self.is_pat_range_end_start(1) {\n@@ -563,8 +623,9 @@ impl<'a> Parser<'a> {\n \n     /// Parse a tuple or parenthesis pattern.\n     fn parse_pat_tuple_or_parens(&mut self) -> PResult<'a, PatKind> {\n-        let (fields, trailing_comma) =\n-            self.parse_paren_comma_seq(|p| p.parse_pat_allow_top_alt(None, RecoverComma::No))?;\n+        let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| {\n+            p.parse_pat_allow_top_alt(None, RecoverComma::No, RecoverColon::No)\n+        })?;\n \n         // Here, `(pat,)` is a tuple pattern.\n         // For backward compatibility, `(..)` is a tuple pattern as well.\n@@ -873,8 +934,9 @@ impl<'a> Parser<'a> {\n \n     /// Parse tuple struct or tuple variant pattern (e.g. `Foo(...)` or `Foo::Bar(...)`).\n     fn parse_pat_tuple_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n-        let (fields, _) =\n-            self.parse_paren_comma_seq(|p| p.parse_pat_allow_top_alt(None, RecoverComma::No))?;\n+        let (fields, _) = self.parse_paren_comma_seq(|p| {\n+            p.parse_pat_allow_top_alt(None, RecoverComma::No, RecoverColon::No)\n+        })?;\n         if qself.is_some() {\n             self.sess.gated_spans.gate(sym::more_qualified_paths, path.span);\n         }\n@@ -1033,7 +1095,7 @@ impl<'a> Parser<'a> {\n             // Parsing a pattern of the form `fieldname: pat`.\n             let fieldname = self.parse_field_name()?;\n             self.bump();\n-            let pat = self.parse_pat_allow_top_alt(None, RecoverComma::No)?;\n+            let pat = self.parse_pat_allow_top_alt(None, RecoverComma::No, RecoverColon::No)?;\n             hi = pat.span;\n             (pat, fieldname, false)\n         } else {"}, {"sha": "4ee0b2054ff772dcc3c92ca5bbc99a06dc5ffb04", "filename": "src/test/ui/parser/issue-87086-colon-path-sep.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/23624504250058c36f42fe3eb76300da962e393b/src%2Ftest%2Fui%2Fparser%2Fissue-87086-colon-path-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23624504250058c36f42fe3eb76300da962e393b/src%2Ftest%2Fui%2Fparser%2Fissue-87086-colon-path-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-87086-colon-path-sep.rs?ref=23624504250058c36f42fe3eb76300da962e393b", "patch": "@@ -0,0 +1,66 @@\n+// Tests that a suggestion is issued if the user wrote a colon instead of\n+// a path separator in a match arm.\n+\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+\n+fn f() -> Foo { Foo::Bar }\n+\n+fn g1() {\n+    match f() {\n+        Foo:Bar => {}\n+        //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n+        _ => {}\n+    }\n+    match f() {\n+        Foo::Bar:Baz => {}\n+        //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n+        _ => {}\n+    }\n+    match f() {\n+        Foo:Bar::Baz => {}\n+        //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n+        _ => {}\n+    }\n+    match f() {\n+        Foo: Bar::Baz if true => {}\n+        //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n+        _ => {}\n+    }\n+    if let Bar:Baz = f() {\n+    //~^ ERROR: expected one of\n+    //~| HELP: maybe write a path separator here\n+    }\n+}\n+\n+fn g1_neg() {\n+    match f() {\n+        ref Foo: Bar::Baz => {}\n+        //~^ ERROR: expected one of\n+        _ => {}\n+    }\n+}\n+\n+fn g2_neg() {\n+    match f() {\n+        mut Foo: Bar::Baz => {}\n+        //~^ ERROR: expected one of\n+        _ => {}\n+    }\n+}\n+\n+fn main() {\n+    let myfoo = Foo::Bar;\n+    match myfoo {\n+        Foo::Bar => {}\n+        Foo:Bar::Baz => {}\n+        //~^ ERROR: expected one of\n+        //~| HELP: maybe write a path separator here\n+    }\n+}"}, {"sha": "8f93661a626467f7e85ef154140fbbbf292b15be", "filename": "src/test/ui/parser/issue-87086-colon-path-sep.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/23624504250058c36f42fe3eb76300da962e393b/src%2Ftest%2Fui%2Fparser%2Fissue-87086-colon-path-sep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23624504250058c36f42fe3eb76300da962e393b/src%2Ftest%2Fui%2Fparser%2Fissue-87086-colon-path-sep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-87086-colon-path-sep.stderr?ref=23624504250058c36f42fe3eb76300da962e393b", "patch": "@@ -0,0 +1,68 @@\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:13:12\n+   |\n+LL |         Foo:Bar => {}\n+   |            ^\n+   |            |\n+   |            expected one of `@` or `|`\n+   |            help: maybe write a path separator here: `::`\n+\n+error: expected one of `!`, `(`, `...`, `..=`, `..`, `::`, `{`, or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:19:17\n+   |\n+LL |         Foo::Bar:Baz => {}\n+   |                 ^\n+   |                 |\n+   |                 expected one of 8 possible tokens\n+   |                 help: maybe write a path separator here: `::`\n+\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:25:12\n+   |\n+LL |         Foo:Bar::Baz => {}\n+   |            ^\n+   |            |\n+   |            expected one of `@` or `|`\n+   |            help: maybe write a path separator here: `::`\n+\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:31:12\n+   |\n+LL |         Foo: Bar::Baz if true => {}\n+   |            ^\n+   |            |\n+   |            expected one of `@` or `|`\n+   |            help: maybe write a path separator here: `::`\n+\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:36:15\n+   |\n+LL |     if let Bar:Baz = f() {\n+   |               ^\n+   |               |\n+   |               expected one of `@` or `|`\n+   |               help: maybe write a path separator here: `::`\n+\n+error: expected one of `=>`, `@`, `if`, or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:44:16\n+   |\n+LL |         ref Foo: Bar::Baz => {}\n+   |                ^ expected one of `=>`, `@`, `if`, or `|`\n+\n+error: expected one of `=>`, `@`, `if`, or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:52:16\n+   |\n+LL |         mut Foo: Bar::Baz => {}\n+   |                ^ expected one of `=>`, `@`, `if`, or `|`\n+\n+error: expected one of `@` or `|`, found `:`\n+  --> $DIR/issue-87086-colon-path-sep.rs:62:12\n+   |\n+LL |         Foo:Bar::Baz => {}\n+   |            ^\n+   |            |\n+   |            expected one of `@` or `|`\n+   |            help: maybe write a path separator here: `::`\n+\n+error: aborting due to 8 previous errors\n+"}]}