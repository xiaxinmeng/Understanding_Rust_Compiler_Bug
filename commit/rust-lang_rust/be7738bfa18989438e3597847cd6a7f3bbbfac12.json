{"sha": "be7738bfa18989438e3597847cd6a7f3bbbfac12", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNzczOGJmYTE4OTg5NDM4ZTM1OTc4NDdjZDZhN2YzYmJiZmFjMTI=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-02T01:57:15Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-02T21:31:44Z"}, "message": "Add SendDeferred trait and use it to fix #8214.", "tree": {"sha": "0076916ccef19cffc68622602477c9aa3df11e41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0076916ccef19cffc68622602477c9aa3df11e41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be7738bfa18989438e3597847cd6a7f3bbbfac12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be7738bfa18989438e3597847cd6a7f3bbbfac12", "html_url": "https://github.com/rust-lang/rust/commit/be7738bfa18989438e3597847cd6a7f3bbbfac12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be7738bfa18989438e3597847cd6a7f3bbbfac12/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f", "html_url": "https://github.com/rust-lang/rust/commit/f1c1f92d0c555d6e38ad1cac55926d6d9c9b090f"}], "stats": {"total": 190, "additions": 162, "deletions": 28}, "files": [{"sha": "045aeb0feda0a1cfccba3ad03a8992afe304d765", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/be7738bfa18989438e3597847cd6a7f3bbbfac12/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7738bfa18989438e3597847cd6a7f3bbbfac12/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=be7738bfa18989438e3597847cd6a7f3bbbfac12", "patch": "@@ -18,6 +18,7 @@\n \n use std::borrow;\n use std::comm;\n+use std::comm::SendDeferred;\n use std::task;\n use std::unstable::sync::{Exclusive, UnsafeAtomicRcBox};\n use std::unstable::atomics;\n@@ -49,7 +50,7 @@ impl WaitQueue {\n         if self.head.peek() {\n             // Pop and send a wakeup signal. If the waiter was killed, its port\n             // will have closed. Keep trying until we get a live task.\n-            if comm::try_send_one(self.head.recv(), ()) {\n+            if self.head.recv().try_send_deferred(()) {\n                 true\n             } else {\n                 self.signal()\n@@ -62,7 +63,7 @@ impl WaitQueue {\n     fn broadcast(&self) -> uint {\n         let mut count = 0;\n         while self.head.peek() {\n-            if comm::try_send_one(self.head.recv(), ()) {\n+            if self.head.recv().try_send_deferred(()) {\n                 count += 1;\n             }\n         }\n@@ -102,7 +103,7 @@ impl<Q:Send> Sem<Q> {\n                     // Tell outer scope we need to block.\n                     waiter_nobe = Some(WaitEnd);\n                     // Enqueue ourself.\n-                    state.waiters.tail.send(SignalEnd);\n+                    state.waiters.tail.send_deferred(SignalEnd);\n                 }\n             }\n             // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n@@ -256,7 +257,7 @@ impl<'self> Condvar<'self> {\n                         }\n                         // Enqueue ourself to be woken up by a signaller.\n                         let SignalEnd = SignalEnd.take_unwrap();\n-                        state.blocked[condvar_id].tail.send(SignalEnd);\n+                        state.blocked[condvar_id].tail.send_deferred(SignalEnd);\n                     } else {\n                         out_of_bounds = Some(state.blocked.len());\n                     }"}, {"sha": "a0731dc3494c20d617daa4005be8bf55befdd9a5", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/be7738bfa18989438e3597847cd6a7f3bbbfac12/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7738bfa18989438e3597847cd6a7f3bbbfac12/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=be7738bfa18989438e3597847cd6a7f3bbbfac12", "patch": "@@ -19,6 +19,7 @@ use either::{Either, Left, Right};\n use kinds::Send;\n use option::{Option, Some};\n use unstable::sync::Exclusive;\n+pub use rt::comm::SendDeferred;\n use rtcomm = rt::comm;\n use rt;\n \n@@ -105,6 +106,21 @@ impl<T: Send> GenericSmartChan<T> for Chan<T> {\n     }\n }\n \n+impl<T: Send> SendDeferred<T> for Chan<T> {\n+    fn send_deferred(&self, x: T) {\n+        match self.inner {\n+            Left(ref chan) => chan.send(x),\n+            Right(ref chan) => chan.send_deferred(x)\n+        }\n+    }\n+    fn try_send_deferred(&self, x: T) -> bool {\n+        match self.inner {\n+            Left(ref chan) => chan.try_send(x),\n+            Right(ref chan) => chan.try_send_deferred(x)\n+        }\n+    }\n+}\n+\n impl<T: Send> GenericPort<T> for Port<T> {\n     fn recv(&self) -> T {\n         match self.inner {\n@@ -250,6 +266,20 @@ impl<T: Send> ChanOne<T> {\n             Right(p) => p.try_send(data)\n         }\n     }\n+    pub fn send_deferred(self, data: T) {\n+        let ChanOne { inner } = self;\n+        match inner {\n+            Left(p) => p.send(data),\n+            Right(p) => p.send_deferred(data)\n+        }\n+    }\n+    pub fn try_send_deferred(self, data: T) -> bool {\n+        let ChanOne { inner } = self;\n+        match inner {\n+            Left(p) => p.try_send(data),\n+            Right(p) => p.try_send_deferred(data)\n+        }\n+    }\n }\n \n pub fn recv_one<T: Send>(port: PortOne<T>) -> T {"}, {"sha": "c19ac8aa33714721cb6b498eeb2c1ced82b515f8", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 127, "deletions": 24, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/be7738bfa18989438e3597847cd6a7f3bbbfac12/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be7738bfa18989438e3597847cd6a7f3bbbfac12/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=be7738bfa18989438e3597847cd6a7f3bbbfac12", "patch": "@@ -25,6 +25,7 @@ use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n use cell::Cell;\n use clone::Clone;\n use rt::{context, SchedulerContext};\n+use tuple::ImmutableTuple;\n \n /// A combined refcount / BlockedTask-as-uint pointer.\n ///\n@@ -86,12 +87,32 @@ impl<T> ChanOne<T> {\n         }\n     }\n \n+    /// Send a message on the one-shot channel. If a receiver task is blocked\n+    /// waiting for the message, will wake it up and reschedule to it.\n     pub fn send(self, val: T) {\n         self.try_send(val);\n     }\n \n+    /// As `send`, but also returns whether or not the receiver endpoint is still open.\n     pub fn try_send(self, val: T) -> bool {\n+        self.try_send_inner(val, true)\n+    }\n+\n+    /// Send a message without immediately rescheduling to a blocked receiver.\n+    /// This can be useful in contexts where rescheduling is forbidden, or to\n+    /// optimize for when the sender expects to still have useful work to do.\n+    pub fn send_deferred(self, val: T) {\n+        self.try_send_deferred(val);\n+    }\n+\n+    /// As `send_deferred` and `try_send` together.\n+    pub fn try_send_deferred(self, val: T) -> bool {\n+        self.try_send_inner(val, false)\n+    }\n \n+    // 'do_resched' configures whether the scheduler immediately switches to\n+    // the receiving task, or leaves the sending task still running.\n+    fn try_send_inner(self, val: T, do_resched: bool) -> bool {\n         rtassert!(context() != SchedulerContext);\n \n         let mut this = self;\n@@ -130,9 +151,16 @@ impl<T> ChanOne<T> {\n                 task_as_state => {\n                     // Port is blocked. Wake it up.\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    do recvr.wake().map_consume |woken_task| {\n-                        Scheduler::run_task(woken_task);\n-                    };\n+                    if do_resched {\n+                        do recvr.wake().map_consume |woken_task| {\n+                            Scheduler::run_task(woken_task);\n+                        };\n+                    } else {\n+                        let recvr = Cell::new(recvr);\n+                        do Local::borrow::<Scheduler, ()> |sched| {\n+                            sched.enqueue_blocked_task(recvr.take());\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -152,6 +180,7 @@ impl<T> PortOne<T> {\n         }\n     }\n \n+    /// Wait for a message on the one-shot port. Fails if the send end is closed.\n     pub fn recv(self) -> T {\n         match self.try_recv() {\n             Some(val) => val,\n@@ -161,6 +190,7 @@ impl<T> PortOne<T> {\n         }\n     }\n \n+    /// As `recv`, but returns `None` if the send end is closed rather than failing.\n     pub fn try_recv(self) -> Option<T> {\n         let mut this = self;\n \n@@ -382,6 +412,12 @@ impl<T> Drop for PortOne<T> {\n     }\n }\n \n+/// Trait for non-rescheduling send operations, similar to `send_deferred` on ChanOne.\n+pub trait SendDeferred<T> {\n+    fn send_deferred(&self, val: T);\n+    fn try_send_deferred(&self, val: T) -> bool;\n+}\n+\n struct StreamPayload<T> {\n     val: T,\n     next: PortOne<StreamPayload<T>>\n@@ -409,6 +445,15 @@ pub fn stream<T: Send>() -> (Port<T>, Chan<T>) {\n     return (port, chan);\n }\n \n+impl<T: Send> Chan<T> {\n+    fn try_send_inner(&self, val: T, do_resched: bool) -> bool {\n+        let (next_pone, next_cone) = oneshot();\n+        let cone = self.next.take();\n+        self.next.put_back(next_cone);\n+        cone.try_send_inner(StreamPayload { val: val, next: next_pone }, do_resched)\n+    }\n+}\n+\n impl<T: Send> GenericChan<T> for Chan<T> {\n     fn send(&self, val: T) {\n         self.try_send(val);\n@@ -417,10 +462,16 @@ impl<T: Send> GenericChan<T> for Chan<T> {\n \n impl<T: Send> GenericSmartChan<T> for Chan<T> {\n     fn try_send(&self, val: T) -> bool {\n-        let (next_pone, next_cone) = oneshot();\n-        let cone = self.next.take();\n-        self.next.put_back(next_cone);\n-        cone.try_send(StreamPayload { val: val, next: next_pone })\n+        self.try_send_inner(val, true)\n+    }\n+}\n+\n+impl<T: Send> SendDeferred<T> for Chan<T> {\n+    fn send_deferred(&self, val: T) {\n+        self.try_send_deferred(val);\n+    }\n+    fn try_send_deferred(&self, val: T) -> bool {\n+        self.try_send_inner(val, false)\n     }\n }\n \n@@ -495,6 +546,17 @@ impl<T> SharedChan<T> {\n     }\n }\n \n+impl<T: Send> SharedChan<T> {\n+    fn try_send_inner(&self, val: T, do_resched: bool) -> bool {\n+        unsafe {\n+            let (next_pone, next_cone) = oneshot();\n+            let cone = (*self.next.get()).swap(~next_cone, SeqCst);\n+            cone.unwrap().try_send_inner(StreamPayload { val: val, next: next_pone },\n+                                         do_resched)\n+        }\n+    }\n+}\n+\n impl<T: Send> GenericChan<T> for SharedChan<T> {\n     fn send(&self, val: T) {\n         self.try_send(val);\n@@ -503,11 +565,16 @@ impl<T: Send> GenericChan<T> for SharedChan<T> {\n \n impl<T: Send> GenericSmartChan<T> for SharedChan<T> {\n     fn try_send(&self, val: T) -> bool {\n-        unsafe {\n-            let (next_pone, next_cone) = oneshot();\n-            let cone = (*self.next.get()).swap(~next_cone, SeqCst);\n-            cone.unwrap().try_send(StreamPayload { val: val, next: next_pone })\n-        }\n+        self.try_send_inner(val, true)\n+    }\n+}\n+\n+impl<T: Send> SendDeferred<T> for SharedChan<T> {\n+    fn send_deferred(&self, val: T) {\n+        self.try_send_deferred(val);\n+    }\n+    fn try_send_deferred(&self, val: T) -> bool {\n+        self.try_send_inner(val, false)\n     }\n }\n \n@@ -584,31 +651,32 @@ pub fn megapipe<T: Send>() -> MegaPipe<T> {\n \n impl<T: Send> GenericChan<T> for MegaPipe<T> {\n     fn send(&self, val: T) {\n-        match *self {\n-            (_, ref c) => c.send(val)\n-        }\n+        self.second_ref().send(val)\n     }\n }\n \n impl<T: Send> GenericSmartChan<T> for MegaPipe<T> {\n     fn try_send(&self, val: T) -> bool {\n-        match *self {\n-            (_, ref c) => c.try_send(val)\n-        }\n+        self.second_ref().try_send(val)\n     }\n }\n \n impl<T: Send> GenericPort<T> for MegaPipe<T> {\n     fn recv(&self) -> T {\n-        match *self {\n-            (ref p, _) => p.recv()\n-        }\n+        self.first_ref().recv()\n     }\n \n     fn try_recv(&self) -> Option<T> {\n-        match *self {\n-            (ref p, _) => p.try_recv()\n-        }\n+        self.first_ref().try_recv()\n+    }\n+}\n+\n+impl<T: Send> SendDeferred<T> for MegaPipe<T> {\n+    fn send_deferred(&self, val: T) {\n+        self.second_ref().send_deferred(val)\n+    }\n+    fn try_send_deferred(&self, val: T) -> bool {\n+        self.second_ref().try_send_deferred(val)\n     }\n }\n \n@@ -1017,4 +1085,39 @@ mod test {\n             }\n         }\n     }\n+\n+    #[test]\n+    fn send_deferred() {\n+        use unstable::sync::atomically;\n+\n+        // Tests no-rescheduling of send_deferred on all types of channels.\n+        do run_in_newsched_task {\n+            let (pone, cone) = oneshot();\n+            let (pstream, cstream) = stream();\n+            let (pshared, cshared) = stream();\n+            let cshared = SharedChan::new(cshared);\n+            let mp = megapipe();\n+\n+            let pone = Cell::new(pone);\n+            do spawntask { pone.take().recv(); }\n+            let pstream = Cell::new(pstream);\n+            do spawntask { pstream.take().recv(); }\n+            let pshared = Cell::new(pshared);\n+            do spawntask { pshared.take().recv(); }\n+            let p_mp = Cell::new(mp.clone());\n+            do spawntask { p_mp.take().recv(); }\n+\n+            let cs = Cell::new((cone, cstream, cshared, mp));\n+            unsafe {\n+                do atomically {\n+                    let (cone, cstream, cshared, mp) = cs.take();\n+                    cone.send_deferred(());\n+                    cstream.send_deferred(());\n+                    cshared.send_deferred(());\n+                    mp.send_deferred(());\n+                }\n+            }\n+        }\n+    }\n+\n }"}]}