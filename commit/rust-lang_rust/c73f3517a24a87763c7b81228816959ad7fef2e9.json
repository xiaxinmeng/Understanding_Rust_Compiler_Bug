{"sha": "c73f3517a24a87763c7b81228816959ad7fef2e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3M2YzNTE3YTI0YTg3NzYzYzdiODEyMjg4MTY5NTlhZDdmZWYyZTk=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-02T13:50:27Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-16T11:34:25Z"}, "message": "Revised mir-dataflow.\n\nIncorporates many fixes contributed by arielb1.\n\n----\n\nrevise borrowck::mir::dataflow code to allow varying domain for bitvectors.\n\nThis particular code implements the `BitDenotation` trait for three\nanalyses:\n\n * `MovingOutStatements`, which, like `borrowck::move_data`, maps each\n   bit-index to a move instruction, and a 1 means \"the effect of this\n   move reaches this point\" (and the assigned l-value, if a scoped\n   declaration, is still in scope).\n\n * `MaybeInitializedLvals`, which maps each bit-index to an l-value.\n   A 1 means \"there exists a control flow path to this point that\n   initializes the associated l-value.\"\n\n * `MaybeUninitializedLvals`, which maps each bit-index to an l-value\n   A 1 means \"there exists a control flow path to this point that\n   de-initializes the associated l-value.\"\n\n----\n\nRevised `graphviz` dataflow-rendering support in `borrowck::mir`.\n\nOne big difference is that this code is now parameterized over the\n`BitDenotation`, so that it can be used to render dataflow results\nindependent of how the dataflow bitvectors are interpreted; see where\nreference to `MoveOut` is replaced by the type parameter `D`.\n\n----\n\nFactor out routine to query subattributes in `#[rustc_mir(..)]`.\n\n(Later commits build upon this for some unit testing and instrumentation.)\n\n----\n\nthread through a tcx so that I can query types of lvalues as part of analysis.\n\n----\n\nRevised `BitDenotation::Ctxt`, allowing variation beyond `MoveData`.\n\nThe main motivation is to ease threading through a `TyCtxt`.\n\n(In hindsight it might have been better to instead attach the `TyCtxt`\nto each of the different dataflow implementations, but that would\nrequire e.g. switching away from having a `Default` impl, so I am\nleaving that experiment for another time.)", "tree": {"sha": "54cb2ca9003551a9d83a949f2b5a08bffad7647b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54cb2ca9003551a9d83a949f2b5a08bffad7647b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c73f3517a24a87763c7b81228816959ad7fef2e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c73f3517a24a87763c7b81228816959ad7fef2e9", "html_url": "https://github.com/rust-lang/rust/commit/c73f3517a24a87763c7b81228816959ad7fef2e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c73f3517a24a87763c7b81228816959ad7fef2e9/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c72c5fa883cc8d33cee90b14fda506eb91d846e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c72c5fa883cc8d33cee90b14fda506eb91d846e", "html_url": "https://github.com/rust-lang/rust/commit/6c72c5fa883cc8d33cee90b14fda506eb91d846e"}], "stats": {"total": 2088, "additions": 1368, "deletions": 720}, "files": [{"sha": "f9a671435ffdb3327506c4b5286088517035efe6", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c73f3517a24a87763c7b81228816959ad7fef2e9/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73f3517a24a87763c7b81228816959ad7fef2e9/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=c73f3517a24a87763c7b81228816959ad7fef2e9", "patch": "@@ -226,7 +226,8 @@ pub struct UpvarDecl {\n /// list of the `Mir`.\n ///\n /// (We use a `u32` internally just to save memory.)\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord,\n+         RustcEncodable, RustcDecodable)]\n pub struct BasicBlock(u32);\n \n impl BasicBlock {"}, {"sha": "828a48532a2fc1b7c2de1f475a60b593befdccda", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c73f3517a24a87763c7b81228816959ad7fef2e9/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73f3517a24a87763c7b81228816959ad7fef2e9/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=c73f3517a24a87763c7b81228816959ad7fef2e9", "patch": "@@ -18,7 +18,7 @@ use ty::TyCtxt;\n use syntax::ast::NodeId;\n \n /// Where a specific Mir comes from.\n-#[derive(Copy, Clone)]\n+#[derive(Debug, Copy, Clone)]\n pub enum MirSource {\n     /// Functions and methods.\n     Fn(NodeId),"}, {"sha": "5a508ba9e961048ce8366ed81bbd76041362b396", "filename": "src/librustc_borrowck/borrowck/mir/dataflow.rs", "status": "removed", "additions": 0, "deletions": 629, "changes": 629, "blob_url": "https://github.com/rust-lang/rust/blob/6c72c5fa883cc8d33cee90b14fda506eb91d846e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c72c5fa883cc8d33cee90b14fda506eb91d846e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs?ref=6c72c5fa883cc8d33cee90b14fda506eb91d846e", "patch": "@@ -1,629 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use syntax::attr::AttrMetaMethods;\n-\n-use rustc::ty::TyCtxt;\n-use rustc::mir::repr::{self, Mir};\n-\n-use std::io;\n-use std::marker::PhantomData;\n-use std::mem;\n-use std::usize;\n-\n-use super::MirBorrowckCtxt;\n-use super::gather_moves::{Location, MoveData, MovePathData, MovePathIndex, MoveOutIndex, PathMap};\n-use super::graphviz;\n-use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n-\n-pub trait Dataflow {\n-    fn dataflow(&mut self);\n-}\n-\n-impl<'b, 'a: 'b, 'tcx: 'a> Dataflow for MirBorrowckCtxt<'b, 'a, 'tcx> {\n-    fn dataflow(&mut self) {\n-        self.build_gen_and_kill_sets();\n-        self.pre_dataflow_instrumentation().unwrap();\n-        self.propagate();\n-        self.post_dataflow_instrumentation().unwrap();\n-    }\n-}\n-\n-struct PropagationContext<'c, 'b: 'c, 'a: 'b, 'tcx: 'a, OnReturn>\n-    where OnReturn: Fn(&MoveData, &mut [usize], &repr::Lvalue)\n-{\n-    mbcx: &'c mut MirBorrowckCtxt<'b, 'a, 'tcx>,\n-    changed: bool,\n-    on_return: OnReturn\n-}\n-\n-impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n-    fn propagate(&mut self) {\n-        let mut temp = vec![0; self.flow_state.sets.words_per_block];\n-        let mut propcx = PropagationContext {\n-            mbcx: &mut *self,\n-            changed: true,\n-            on_return: |move_data, in_out, dest_lval| {\n-                let move_path_index = move_data.rev_lookup.find(dest_lval);\n-                on_all_children_bits(in_out,\n-                                     &move_data.path_map,\n-                                     &move_data.move_paths,\n-                                     move_path_index,\n-                                     &|in_out, mpi| {\n-                                         in_out.clear_bit(mpi.idx());\n-                                     });\n-            },\n-        };\n-        while propcx.changed {\n-            propcx.changed = false;\n-            propcx.reset(&mut temp);\n-            propcx.walk_cfg(&mut temp);\n-        }\n-    }\n-\n-    fn build_gen_and_kill_sets(&mut self) {\n-        // First we need to build the gen- and kill-sets. The\n-        // gather_moves information provides a high-level mapping from\n-        // mir-locations to the MoveOuts (and those correspond\n-        // directly to gen-sets here). But we still need to figure out\n-        // the kill-sets.\n-\n-        let move_data = &self.flow_state.operator;\n-        let move_paths = &move_data.move_paths;\n-        let loc_map = &move_data.loc_map;\n-        let path_map = &move_data.path_map;\n-        let rev_lookup = &move_data.rev_lookup;\n-\n-        for bb in self.mir.all_basic_blocks() {\n-            let &repr::BasicBlockData { ref statements,\n-                                        ref terminator,\n-                                        is_cleanup: _ } =\n-                self.mir.basic_block_data(bb);\n-\n-            let mut sets = self.flow_state.sets.for_block(bb.index());\n-            for (j, stmt) in statements.iter().enumerate() {\n-                let loc = Location { block: bb, index: j };\n-                debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n-                       stmt, loc, &loc_map[loc]);\n-                for move_index in &loc_map[loc] {\n-                    // Every path deinitialized by a *particular move*\n-                    // has corresponding bit, \"gen'ed\" (i.e. set)\n-                    // here, in dataflow vector\n-                    zero_to_one(&mut sets.gen_set, *move_index);\n-                }\n-                match stmt.kind {\n-                    repr::StatementKind::Assign(ref lvalue, _) => {\n-                        // assigning into this `lvalue` kills all\n-                        // MoveOuts from it, and *also* all MoveOuts\n-                        // for children and associated fragment sets.\n-                        let move_path_index = rev_lookup.find(lvalue);\n-\n-                        on_all_children_bits(sets.kill_set,\n-                                             path_map,\n-                                             move_paths,\n-                                             move_path_index,\n-                                             &|kill_set, mpi| {\n-                                                 kill_set.set_bit(mpi.idx());\n-                                             });\n-                    }\n-                }\n-            }\n-\n-            let loc = Location { block: bb, index: statements.len() };\n-            debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n-                   terminator, loc, &loc_map[loc]);\n-            for move_index in &loc_map[loc] {\n-                zero_to_one(&mut sets.gen_set, *move_index);\n-            }\n-        }\n-\n-        fn zero_to_one(gen_set: &mut [usize], move_index: MoveOutIndex) {\n-            let retval = gen_set.set_bit(move_index.idx());\n-            assert!(retval);\n-        }\n-    }\n-}\n-\n-fn on_all_children_bits<Each>(set: &mut [usize],\n-                              path_map: &PathMap,\n-                              move_paths: &MovePathData,\n-                              move_path_index: MovePathIndex,\n-                              each_child: &Each)\n-    where Each: Fn(&mut [usize], MoveOutIndex)\n-{\n-    // 1. invoke `each_child` callback for all moves that directly\n-    //    influence path for `move_path_index`\n-    for move_index in &path_map[move_path_index] {\n-        each_child(set, *move_index);\n-    }\n-\n-    // 2. for each child of the path (that is named in this\n-    //    function), recur.\n-    //\n-    // (Unnamed children are irrelevant to dataflow; by\n-    // definition they have no associated moves.)\n-    let mut next_child_index = move_paths[move_path_index].first_child;\n-    while let Some(child_index) = next_child_index {\n-        on_all_children_bits(set, path_map, move_paths, child_index, each_child);\n-        next_child_index = move_paths[child_index].next_sibling;\n-    }\n-}\n-\n-impl<'c, 'b: 'c, 'a: 'b, 'tcx: 'a, OnReturn> PropagationContext<'c, 'b, 'a, 'tcx, OnReturn>\n-    where OnReturn: Fn(&MoveData, &mut [usize], &repr::Lvalue)\n-{\n-    fn reset(&mut self, bits: &mut [usize]) {\n-        let e = if MoveData::initial_value() {usize::MAX} else {0};\n-        for b in bits {\n-            *b = e;\n-        }\n-    }\n-\n-    fn walk_cfg(&mut self, in_out: &mut [usize]) {\n-        let &mut MirBorrowckCtxt { ref mir, ref mut flow_state, .. } = self.mbcx;\n-        for (idx, bb) in mir.basic_blocks.iter().enumerate() {\n-            {\n-                let sets = flow_state.sets.for_block(idx);\n-                debug_assert!(in_out.len() == sets.on_entry.len());\n-                in_out.clone_from_slice(sets.on_entry);\n-                bitwise(in_out, sets.gen_set, &Union);\n-                bitwise(in_out, sets.kill_set, &Subtract);\n-            }\n-            flow_state.propagate_bits_into_graph_successors_of(in_out,\n-                                                               &mut self.changed,\n-                                                               bb,\n-                                                               &self.on_return);\n-        }\n-    }\n-}\n-\n-impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n-    fn pre_dataflow_instrumentation(&self) -> io::Result<()> {\n-        self.if_attr_meta_name_found(\n-            \"borrowck_graphviz_preflow\",\n-            |this, path: &str| {\n-                graphviz::print_borrowck_graph_to(this, \"preflow\", path)\n-            })\n-    }\n-\n-    fn post_dataflow_instrumentation(&self) -> io::Result<()> {\n-        self.if_attr_meta_name_found(\n-            \"borrowck_graphviz_postflow\",\n-            |this, path: &str| {\n-                graphviz::print_borrowck_graph_to(this, \"postflow\", path)\n-            })\n-    }\n-\n-    fn if_attr_meta_name_found<F>(&self,\n-                                  name: &str,\n-                                  callback: F) -> io::Result<()>\n-        where F: for <'aa, 'bb> FnOnce(&'aa Self, &'bb str) -> io::Result<()>\n-    {\n-        for attr in self.attributes {\n-            if attr.check_name(\"rustc_mir\") {\n-                let items = attr.meta_item_list();\n-                for item in items.iter().flat_map(|l| l.iter()) {\n-                    if item.check_name(name) {\n-                        if let Some(s) = item.value_str() {\n-                            return callback(self, &s);\n-                        } else {\n-                            self.bcx.tcx.sess.span_err(\n-                                item.span,\n-                                &format!(\"{} attribute requires a path\", item.name()));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n-/// Maps each block to a set of bits\n-#[derive(Clone, Debug)]\n-struct Bits {\n-    bits: Vec<usize>,\n-}\n-\n-impl Bits {\n-    fn new(init_word: usize, num_words: usize) -> Self {\n-        Bits { bits: vec![init_word; num_words] }\n-    }\n-}\n-\n-pub struct DataflowState<O: BitDenotation>\n-{\n-    /// All the sets for the analysis. (Factored into its\n-    /// own structure so that we can borrow it mutably\n-    /// on its own separate from other fields.)\n-    pub sets: AllSets,\n-\n-    /// operator used to initialize, combine, and interpret bits.\n-    operator: O,\n-}\n-\n-pub struct AllSets {\n-    /// Analysis bitwidth for each block.\n-    bits_per_block: usize,\n-\n-    /// Number of words associated with each block entry\n-    /// equal to bits_per_block / usize::BITS, rounded up.\n-    words_per_block: usize,\n-\n-    /// For each block, bits generated by executing the statements in\n-    /// the block. (For comparison, the Terminator for each block is\n-    /// handled in a flow-specific manner during propagation.)\n-    gen_sets: Bits,\n-\n-    /// For each block, bits killed by executing the statements in the\n-    /// block. (For comparison, the Terminator for each block is\n-    /// handled in a flow-specific manner during propagation.)\n-    kill_sets: Bits,\n-\n-    /// For each block, bits valid on entry to the block.\n-    on_entry_sets: Bits,\n-}\n-\n-pub struct BlockSets<'a> {\n-    on_entry: &'a mut [usize],\n-    gen_set: &'a mut [usize],\n-    kill_set: &'a mut [usize],\n-}\n-\n-impl AllSets {\n-    pub fn bits_per_block(&self) -> usize { self.bits_per_block }\n-    pub fn bytes_per_block(&self) -> usize { (self.bits_per_block + 7) / 8 }\n-    pub fn for_block(&mut self, block_idx: usize) -> BlockSets {\n-        let offset = self.words_per_block * block_idx;\n-        let range = offset..(offset + self.words_per_block);\n-        BlockSets {\n-            on_entry: &mut self.on_entry_sets.bits[range.clone()],\n-            gen_set: &mut self.gen_sets.bits[range.clone()],\n-            kill_set: &mut self.kill_sets.bits[range],\n-        }\n-    }\n-\n-    fn lookup_set_for<'a>(&self, sets: &'a Bits, block_idx: usize) -> &'a [usize] {\n-        let offset = self.words_per_block * block_idx;\n-        &sets.bits[offset..(offset + self.words_per_block)]\n-    }\n-    pub fn gen_set_for(&self, block_idx: usize) -> &[usize] {\n-        self.lookup_set_for(&self.gen_sets, block_idx)\n-    }\n-    pub fn kill_set_for(&self, block_idx: usize) -> &[usize] {\n-        self.lookup_set_for(&self.kill_sets, block_idx)\n-    }\n-    pub fn on_entry_set_for(&self, block_idx: usize) -> &[usize] {\n-        self.lookup_set_for(&self.on_entry_sets, block_idx)\n-    }\n-    pub fn on_exit_set_for(&self, block_idx: usize) -> Vec<usize> {\n-        let mut set: Vec<_> = self.on_entry_set_for(block_idx).iter()\n-            .map(|x|*x)\n-            .collect();\n-        bitwise(&mut set[..], self.gen_set_for(block_idx), &Union);\n-        bitwise(&mut set[..], self.kill_set_for(block_idx), &Subtract);\n-        return set;\n-    }\n-}\n-\n-impl<O: BitDenotation> DataflowState<O> {\n-    fn each_bit<F>(&self, words: &[usize], mut f: F)\n-        where F: FnMut(usize) {\n-        //! Helper for iterating over the bits in a bitvector.\n-\n-        for (word_index, &word) in words.iter().enumerate() {\n-            if word != 0 {\n-                let usize_bits: usize = mem::size_of::<usize>();\n-                let base_index = word_index * usize_bits;\n-                for offset in 0..usize_bits {\n-                    let bit = 1 << offset;\n-                    if (word & bit) != 0 {\n-                        // NB: we round up the total number of bits\n-                        // that we store in any given bit set so that\n-                        // it is an even multiple of usize::BITS. This\n-                        // means that there may be some stray bits at\n-                        // the end that do not correspond to any\n-                        // actual value; that's why we first check\n-                        // that we are in range of bits_per_block.\n-                        let bit_index = base_index + offset as usize;\n-                        if bit_index >= self.sets.bits_per_block() {\n-                            return;\n-                        } else {\n-                            f(bit_index);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn interpret_set(&self, words: &[usize]) -> Vec<&O::Bit> {\n-        let mut v = Vec::new();\n-        self.each_bit(words, |i| {\n-            v.push(self.operator.interpret(i));\n-        });\n-        v\n-    }\n-}\n-\n-pub trait BitwiseOperator {\n-    /// Joins two predecessor bits together, typically either `|` or `&`\n-    fn join(&self, pred1: usize, pred2: usize) -> usize;\n-}\n-\n-/// Parameterization for the precise form of data flow that is used.\n-pub trait DataflowOperator : BitwiseOperator {\n-    /// Specifies the initial value for each bit in the `on_entry` set\n-    fn initial_value() -> bool;\n-}\n-\n-pub trait BitDenotation: DataflowOperator {\n-    /// Specifies what is represented by each bit in the dataflow bitvector.\n-    type Bit;\n-    /// Size of each bivector allocated for each block in the analysis.\n-    fn bits_per_block(&self) -> usize;\n-    /// Provides the meaning of each entry in the dataflow bitvector.\n-    /// (Mostly intended for use for better debug instrumentation.)\n-    fn interpret(&self, idx: usize) -> &Self::Bit;\n-}\n-\n-impl<D: BitDenotation> DataflowState<D> {\n-    pub fn new(mir: &Mir, denotation: D) -> Self {\n-        let bits_per_block = denotation.bits_per_block();\n-        let usize_bits = mem::size_of::<usize>() * 8;\n-        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n-        let num_blocks = mir.basic_blocks.len();\n-        let num_words = num_blocks * words_per_block;\n-\n-        let entry = if D::initial_value() { usize::MAX } else {0};\n-\n-        let zeroes = Bits::new(0, num_words);\n-        let on_entry = Bits::new(entry, num_words);\n-\n-        DataflowState {\n-            sets: AllSets {\n-                bits_per_block: bits_per_block,\n-                words_per_block: words_per_block,\n-                gen_sets: zeroes.clone(),\n-                kill_sets: zeroes,\n-                on_entry_sets: on_entry,\n-            },\n-            operator: denotation,\n-        }\n-    }\n-}\n-\n-impl<D: BitDenotation> DataflowState<D> {\n-    /// Propagates the bits of `in_out` into all the successors of `bb`,\n-    /// using bitwise operator denoted by `self.operator`.\n-    ///\n-    /// For most blocks, this is entirely uniform. However, for blocks\n-    /// that end with a call terminator, the effect of the call on the\n-    /// dataflow state may depend on whether the call returned\n-    /// successfully or unwound. To reflect this, the `on_return`\n-    /// callback mutates `in_out` when propagating `in_out` via a call\n-    /// terminator; such mutation is performed *last*, to ensure its\n-    /// side-effects do not leak elsewhere (e.g. into unwind target).\n-    fn propagate_bits_into_graph_successors_of<OnReturn>(\n-        &mut self,\n-        in_out: &mut [usize],\n-        changed: &mut bool,\n-        bb: &repr::BasicBlockData,\n-        on_return: OnReturn) where OnReturn: Fn(&D, &mut [usize], &repr::Lvalue)\n-    {\n-        match bb.terminator().kind {\n-            repr::TerminatorKind::Return |\n-            repr::TerminatorKind::Resume => {}\n-            repr::TerminatorKind::Goto { ref target } |\n-            repr::TerminatorKind::Drop { ref target, value: _, unwind: None } => {\n-                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n-            }\n-            repr::TerminatorKind::Drop { ref target, value: _, unwind: Some(ref unwind) } => {\n-                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n-                self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n-            }\n-            repr::TerminatorKind::If { ref targets, .. } => {\n-                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.0);\n-                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.1);\n-            }\n-            repr::TerminatorKind::Switch { ref targets, .. } |\n-            repr::TerminatorKind::SwitchInt { ref targets, .. } => {\n-                for target in targets {\n-                    self.propagate_bits_into_entry_set_for(in_out, changed, target);\n-                }\n-            }\n-            repr::TerminatorKind::Call { ref cleanup, ref destination, func: _, args: _ } => {\n-                if let Some(ref unwind) = *cleanup {\n-                    self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n-                }\n-                if let Some((ref dest_lval, ref dest_bb)) = *destination {\n-                    // N.B.: This must be done *last*, after all other\n-                    // propagation, as documented in comment above.\n-                    on_return(&self.operator, in_out, dest_lval);\n-                    self.propagate_bits_into_entry_set_for(in_out, changed, dest_bb);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn propagate_bits_into_entry_set_for(&mut self,\n-                                         in_out: &[usize],\n-                                         changed: &mut bool,\n-                                         bb: &repr::BasicBlock) {\n-        let entry_set = self.sets.for_block(bb.index()).on_entry;\n-        let set_changed = bitwise(entry_set, in_out, &self.operator);\n-        if set_changed {\n-            *changed = true;\n-        }\n-    }\n-}\n-\n-// Dataflow analyses are built upon some interpretation of the\n-// bitvectors attached to each basic block, represented via a\n-// zero-sized structure.\n-//\n-// Note on PhantomData: Each interpretation will need to instantiate\n-// the `Bit` and `Ctxt` associated types, and in this case, those\n-// associated types need an associated lifetime `'tcx`. The\n-// interpretive structures are zero-sized, so they all need to carry a\n-// `PhantomData` representing how the structures relate to the `'tcx`\n-// lifetime.\n-//\n-// But, since all of the uses of `'tcx` are solely via instances of\n-// `Ctxt` that are passed into the `BitDenotation` methods, we can\n-// consistently use a `PhantomData` that is just a function over a\n-// `&Ctxt` (== `&MoveData<'tcx>).\n-\n-/// `MaybeInitializedLvals` tracks all l-values that might be\n-/// initialized upon reaching a particular point in the control flow\n-/// for a function.\n-///\n-/// For example, in code like the following, we have corresponding\n-/// dataflow information shown in the right-hand comments.\n-///\n-/// ```rust\n-/// struct S;\n-/// fn foo(pred: bool) {                       // maybe-init:\n-///                                            // {}\n-///     let a = S; let b = S; let c; let d;    // {a, b}\n-///\n-///     if pred {\n-///         drop(a);                           // {   b}\n-///         b = S;                             // {   b}\n-///\n-///     } else {\n-///         drop(b);                           // {a}\n-///         d = S;                             // {a,       d}\n-///\n-///     }                                      // {a, b,    d}\n-///\n-///     c = S;                                 // {a, b, c, d}\n-/// }\n-/// ```\n-///\n-/// To determine whether an l-value *must* be initialized at a\n-/// particular control-flow point, one can take the set-difference\n-/// between this data and the data from `MaybeUninitializedLvals` at the\n-/// corresponding control-flow point.\n-///\n-/// Similarly, at a given `drop` statement, the set-intersection\n-/// between this data and `MaybeUninitializedLvals` yields the set of\n-/// l-values that would require a dynamic drop-flag at that statement.\n-#[derive(Debug, Default)]\n-pub struct MaybeInitializedLvals<'tcx> {\n-    // See \"Note on PhantomData\" above.\n-    phantom: PhantomData<for <'a> Fn(&'a MoveData<'tcx>)>,\n-}\n-\n-/// `MaybeUninitializedLvals` tracks all l-values that might be\n-/// uninitialized upon reaching a particular point in the control flow\n-/// for a function.\n-///\n-/// For example, in code like the following, we have corresponding\n-/// dataflow information shown in the right-hand comments.\n-///\n-/// ```rust\n-/// struct S;\n-/// fn foo(pred: bool) {                       // maybe-uninit:\n-///                                            // {a, b, c, d}\n-///     let a = S; let b = S; let c; let d;    // {      c, d}\n-///\n-///     if pred {\n-///         drop(a);                           // {a,    c, d}\n-///         b = S;                             // {a,    c, d}\n-///\n-///     } else {\n-///         drop(b);                           // {   b, c, d}\n-///         d = S;                             // {   b, c   }\n-///\n-///     }                                      // {a, b, c, d}\n-///\n-///     c = S;                                 // {a, b,    d}\n-/// }\n-/// ```\n-///\n-/// To determine whether an l-value *must* be uninitialized at a\n-/// particular control-flow point, one can take the set-difference\n-/// between this data and the data from `MaybeInitializedLvals` at the\n-/// corresponding control-flow point.\n-///\n-/// Similarly, at a given `drop` statement, the set-intersection\n-/// between this data and `MaybeInitializedLvals` yields the set of\n-/// l-values that would require a dynamic drop-flag at that statement.\n-#[derive(Debug, Default)]\n-pub struct MaybeUninitializedLvals<'tcx> {\n-    // See \"Note on PhantomData\" above.\n-    phantom: PhantomData<for <'a> Fn(&'a MoveData<'tcx>)>,\n-}\n-\n-/// `MovingOutStatements` tracks the statements that perform moves out\n-/// of particular l-values. More precisely, it tracks whether the\n-/// *effect* of such moves (namely, the uninitialization of the\n-/// l-value in question) can reach some point in the control-flow of\n-/// the function, or if that effect is \"killed\" by some intervening\n-/// operation reinitializing that l-value.\n-///\n-/// The resulting dataflow is a more enriched version of\n-/// `MaybeUninitializedLvals`. Both structures on their own only tell\n-/// you if an l-value *might* be uninitialized at a given point in the\n-/// control flow. But `MovingOutStatements` also includes the added\n-/// data of *which* particular statement causing the deinitialization\n-/// that the borrow checker's error meessage may need to report.\n-#[derive(Debug, Default)]\n-pub struct MovingOutStatements<'tcx> {\n-    // See \"Note on PhantomData\" above.\n-    phantom: PhantomData<for <'a> Fn(&'a MoveData<'tcx>)>,\n-}\n-\n-impl<'a, 'tcx> DataflowState<MoveData<'tcx>> {\n-    pub fn new_move_analysis(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n-        let move_data = MoveData::gather_moves(mir, tcx);\n-        DataflowState::new(mir, move_data)\n-    }\n-}\n-\n-impl<'tcx> BitwiseOperator for MoveData<'tcx> {\n-    #[inline]\n-    fn join(&self, pred1: usize, pred2: usize) -> usize {\n-        pred1 | pred2 // moves from both preds are in scope\n-    }\n-}\n-\n-impl<'tcx> DataflowOperator for MoveData<'tcx> {\n-    #[inline]\n-    fn initial_value() -> bool {\n-        false // no loans in scope by default\n-    }\n-}\n-\n-#[inline]\n-fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n-                               in_vec: &[usize],\n-                               op: &Op) -> bool {\n-    assert_eq!(out_vec.len(), in_vec.len());\n-    let mut changed = false;\n-    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n-        let old_val = *out_elt;\n-        let new_val = op.join(old_val, *in_elt);\n-        *out_elt = new_val;\n-        changed |= old_val != new_val;\n-    }\n-    changed\n-}\n-\n-struct Union;\n-impl BitwiseOperator for Union {\n-    fn join(&self, a: usize, b: usize) -> usize { a | b }\n-}\n-struct Subtract;\n-impl BitwiseOperator for Subtract {\n-    fn join(&self, a: usize, b: usize) -> usize { a & !b }\n-}"}, {"sha": "bc6ee89fa25774c2cf2aff7f23325a791d411702", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/graphviz.rs", "status": "renamed", "additions": 93, "deletions": 47, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/c73f3517a24a87763c7b81228816959ad7fef2e9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73f3517a24a87763c7b81228816959ad7fef2e9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fgraphviz.rs?ref=c73f3517a24a87763c7b81228816959ad7fef2e9", "patch": "@@ -10,30 +10,58 @@\n \n //! Hook into libgraphviz for rendering dataflow graphs for MIR.\n \n+use syntax::ast::NodeId;\n use rustc::mir::repr::{BasicBlock, Mir};\n \n use dot;\n use dot::IntoCow;\n \n+use std::fmt::Debug;\n use std::fs::File;\n use std::io;\n use std::io::prelude::*;\n+use std::marker::PhantomData;\n+use std::path::Path;\n \n-use super::MirBorrowckCtxt;\n+use super::super::MirBorrowckCtxtPreDataflow;\n use bitslice::bits_to_string;\n-use super::gather_moves::MoveOut;\n+use super::{BitDenotation, DataflowState};\n+use super::{HasMoveData};\n \n-struct Graph<'c, 'b:'c, 'a:'b, 'tcx:'a> { mbcx: &'c MirBorrowckCtxt<'b, 'a, 'tcx>,\n-                                          context: &'b str }\n+pub trait MirWithFlowState<'tcx> {\n+    type BD: BitDenotation;\n+    fn node_id(&self) -> NodeId;\n+    fn mir(&self) -> &Mir<'tcx>;\n+    fn analysis_ctxt(&self) -> &<Self::BD as BitDenotation>::Ctxt;\n+    fn flow_state(&self) -> &DataflowState<Self::BD>;\n+}\n+\n+impl<'a, 'tcx: 'a, BD> MirWithFlowState<'tcx> for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n+    where 'a, 'tcx: 'a, BD: BitDenotation, BD::Ctxt: HasMoveData<'tcx>\n+{\n+    type BD = BD;\n+    fn node_id(&self) -> NodeId { self.node_id }\n+    fn mir(&self) -> &Mir<'tcx> { self.flow_state.mir() }\n+    fn analysis_ctxt(&self) -> &BD::Ctxt { &self.flow_state.ctxt }\n+    fn flow_state(&self) -> &DataflowState<Self::BD> { &self.flow_state.flow_state }\n+}\n \n-pub fn print_borrowck_graph_to(mbcx: &MirBorrowckCtxt,\n-                               context: &str,\n-                               path: &str) -> io::Result<()> {\n-    let g = Graph { mbcx: mbcx, context: context };\n+struct Graph<'a, 'tcx, MWF:'a> where MWF: MirWithFlowState<'tcx>,\n+{\n+    mbcx: &'a MWF,\n+    phantom: PhantomData<&'tcx ()>\n+}\n+\n+pub fn print_borrowck_graph_to<'a, 'tcx, BD>(\n+    mbcx: &MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>,\n+    path: &Path) -> io::Result<()> where BD: BitDenotation,\n+                                        BD::Bit: Debug, BD::Ctxt: HasMoveData<'tcx>\n+{\n+    let g = Graph { mbcx: mbcx, phantom: PhantomData };\n     let mut v = Vec::new();\n     dot::render(&g, &mut v)?;\n-    println!(\"print_borrowck_graph_to path: {} context: {} node_id: {}\",\n-             path, context, mbcx.node_id);\n+    debug!(\"print_borrowck_graph_to path: {} node_id: {}\",\n+           path.display(), mbcx.node_id);\n     File::create(path).and_then(|mut f| f.write_all(&v))\n }\n \n@@ -47,13 +75,14 @@ fn outgoing(mir: &Mir, bb: BasicBlock) -> Vec<Edge> {\n     (0..succ_len).map(|index| Edge { source: bb, index: index}).collect()\n }\n \n-impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::Labeller<'c> for Graph<'c,'b,'a,'tcx> {\n+impl<'a, 'tcx, MWF> dot::Labeller<'a> for Graph<'a, 'tcx, MWF>\n+    where MWF: MirWithFlowState<'tcx>, <MWF::BD as BitDenotation>::Bit: Debug\n+{\n     type Node = Node;\n     type Edge = Edge;\n     fn graph_id(&self) -> dot::Id {\n-        dot::Id::new(format!(\"graph_for_node_{}_{}\",\n-                             self.mbcx.node_id,\n-                             self.context))\n+        dot::Id::new(format!(\"graph_for_node_{}\",\n+                             self.mbcx.node_id()))\n             .unwrap()\n     }\n \n@@ -106,10 +135,10 @@ impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::Labeller<'c> for Graph<'c,'b,'a,'tcx> {\n         const BG_FLOWCONTENT: &'static str = r#\"bgcolor=\"pink\"\"#;\n         const ALIGN_RIGHT: &'static str = r#\"align=\"right\"\"#;\n         const FACE_MONOSPACE: &'static str = r#\"FACE=\"Courier\"\"#;\n-        fn chunked_present_left<W:io::Write>(w: &mut W,\n-                                             interpreted: &[&MoveOut],\n-                                             chunk_size: usize)\n-                                             -> io::Result<()>\n+        fn chunked_present_left<D: Debug, W:io::Write>(w: &mut W,\n+                                                       interpreted: &[&D],\n+                                                       chunk_size: usize)\n+                                                       -> io::Result<()>\n         {\n             // This function may emit a sequence of <tr>'s, but it\n             // always finishes with an (unfinished)\n@@ -137,40 +166,55 @@ impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::Labeller<'c> for Graph<'c,'b,'a,'tcx> {\n             Ok(())\n         }\n         ::rustc_mir::graphviz::write_node_label(\n-            *n, self.mbcx.mir, &mut v, 4,\n+            *n, self.mbcx.mir(), &mut v, 4,\n             |w| {\n-                let flow = &self.mbcx.flow_state;\n-                let entry = flow.interpret_set(flow.sets.on_entry_set_for(i));\n-                chunked_present_left(w, &entry[..], chunk_size)?;\n+                let ctxt = self.mbcx.analysis_ctxt();\n+                let flow = self.mbcx.flow_state();\n+                let entry_interp = flow.interpret_set(ctxt, flow.sets.on_entry_set_for(i));\n+                chunked_present_left(w, &entry_interp[..], chunk_size)?;\n+                let bits_per_block = flow.sets.bits_per_block();\n+                let entry = flow.sets.on_entry_set_for(i);\n+                debug!(\"entry set for i={i} bits_per_block: {bpb} entry: {e:?} interp: {ei:?}\",\n+                       i=i, e=entry, bpb=bits_per_block, ei=entry_interp);\n                 write!(w, \"= ENTRY:</td><td {bg}><FONT {face}>{entrybits:?}</FONT></td>\\\n                                         <td></td></tr>\",\n                        bg = BG_FLOWCONTENT,\n                        face = FACE_MONOSPACE,\n-                       entrybits=bits_to_string(flow.sets.on_entry_set_for(i),\n-                                                flow.sets.bytes_per_block()))\n+                       entrybits=bits_to_string(entry, bits_per_block))\n             },\n             |w| {\n-                let flow = &self.mbcx.flow_state;\n-                let gen = flow.interpret_set( flow.sets.gen_set_for(i));\n-                let kill = flow.interpret_set(flow.sets.kill_set_for(i));\n-                chunked_present_left(w, &gen[..], chunk_size)?;\n-                write!(w, \" = GEN:</td><td {bg}><FONT {face}>{genbits:?}</FONT></td>\\\n-                                       <td></td></tr>\",\n-                       bg = BG_FLOWCONTENT,\n-                       face = FACE_MONOSPACE,\n-                       genbits=bits_to_string( flow.sets.gen_set_for(i),\n-                                               flow.sets.bytes_per_block()))?;\n-                write!(w, \"<tr><td></td><td {bg} {align}>KILL:</td>\\\n-                                        <td {bg}><FONT {face}>{killbits:?}</FONT></td>\",\n-                       bg = BG_FLOWCONTENT,\n-                       align = ALIGN_RIGHT,\n-                       face = FACE_MONOSPACE,\n-                       killbits=bits_to_string(flow.sets.kill_set_for(i),\n-                                               flow.sets.bytes_per_block()))?;\n+                let ctxt = self.mbcx.analysis_ctxt();\n+                let flow = self.mbcx.flow_state();\n+                let gen_interp = flow.interpret_set(ctxt, flow.sets.gen_set_for(i));\n+                let kill_interp = flow.interpret_set(ctxt, flow.sets.kill_set_for(i));\n+                chunked_present_left(w, &gen_interp[..], chunk_size)?;\n+                let bits_per_block = flow.sets.bits_per_block();\n+                {\n+                    let gen = flow.sets.gen_set_for(i);\n+                    debug!(\"gen set for i={i} bits_per_block: {bpb} gen: {g:?} interp: {gi:?}\",\n+                           i=i, g=gen, bpb=bits_per_block, gi=gen_interp);\n+                    write!(w, \" = GEN:</td><td {bg}><FONT {face}>{genbits:?}</FONT></td>\\\n+                                           <td></td></tr>\",\n+                           bg = BG_FLOWCONTENT,\n+                           face = FACE_MONOSPACE,\n+                           genbits=bits_to_string(gen, bits_per_block))?;\n+                }\n+\n+                {\n+                    let kill = flow.sets.kill_set_for(i);\n+                    debug!(\"kill set for i={i} bits_per_block: {bpb} kill: {k:?} interp: {ki:?}\",\n+                           i=i, k=kill, bpb=bits_per_block, ki=kill_interp);\n+                    write!(w, \"<tr><td></td><td {bg} {align}>KILL:</td>\\\n+                                            <td {bg}><FONT {face}>{killbits:?}</FONT></td>\",\n+                           bg = BG_FLOWCONTENT,\n+                           align = ALIGN_RIGHT,\n+                           face = FACE_MONOSPACE,\n+                           killbits=bits_to_string(kill, bits_per_block))?;\n+                }\n \n                 // (chunked_present_right)\n                 let mut seen_one = false;\n-                for k in kill.chunks(chunk_size) {\n+                for k in kill_interp.chunks(chunk_size) {\n                     if !seen_one {\n                         // continuation of row; this is fourth <td>\n                         write!(w, \"<td {bg}>= {kill:?}</td></tr>\",\n@@ -200,16 +244,18 @@ impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::Labeller<'c> for Graph<'c,'b,'a,'tcx> {\n     }\n }\n \n-impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::GraphWalk<'c> for Graph<'c,'b,'a,'tcx> {\n+impl<'a, 'tcx, MWF> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF>\n+    where MWF: MirWithFlowState<'tcx>\n+{\n     type Node = Node;\n     type Edge = Edge;\n     fn nodes(&self) -> dot::Nodes<Node> {\n-        self.mbcx.mir.all_basic_blocks().into_cow()\n+        self.mbcx.mir().all_basic_blocks().into_cow()\n     }\n \n     fn edges(&self) -> dot::Edges<Edge> {\n-        let mir = self.mbcx.mir;\n-        let blocks = self.mbcx.mir.all_basic_blocks();\n+        let mir = self.mbcx.mir();\n+        let blocks = mir.all_basic_blocks();\n         // base initial capacity on assumption every block has at\n         // least one outgoing edge (Which should be true for all\n         // blocks but one, the exit-block).\n@@ -226,7 +272,7 @@ impl<'c, 'b:'c, 'a:'b, 'tcx:'a> dot::GraphWalk<'c> for Graph<'c,'b,'a,'tcx> {\n     }\n \n     fn target(&self, edge: &Edge) -> Node {\n-        let mir = self.mbcx.mir;\n+        let mir = self.mbcx.mir();\n         mir.basic_block_data(edge.source).terminator().successors()[edge.index]\n     }\n }", "previous_filename": "src/librustc_borrowck/borrowck/mir/graphviz.rs"}, {"sha": "41fe6079526cf795c81f4073c0ec1525e1affa9d", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "added", "additions": 1024, "deletions": 0, "changes": 1024, "blob_url": "https://github.com/rust-lang/rust/blob/c73f3517a24a87763c7b81228816959ad7fef2e9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73f3517a24a87763c7b81228816959ad7fef2e9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=c73f3517a24a87763c7b81228816959ad7fef2e9", "patch": "@@ -0,0 +1,1024 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TyCtxt;\n+use rustc::mir::repr::{self, Mir};\n+\n+use std::fmt::Debug;\n+use std::io;\n+use std::marker::PhantomData;\n+use std::mem;\n+use std::path::PathBuf;\n+use std::usize;\n+\n+use super::MirBorrowckCtxtPreDataflow;\n+use super::gather_moves::{Location, MoveData, MovePathData, MovePathIndex, MoveOutIndex, PathMap};\n+use super::gather_moves::{MoveOut, MovePath};\n+use super::DropFlagState;\n+\n+use bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n+\n+mod graphviz;\n+\n+pub trait Dataflow {\n+    fn dataflow(&mut self);\n+}\n+\n+impl<'a, 'tcx: 'a, BD> Dataflow for MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n+    where BD: BitDenotation, BD::Bit: Debug, BD::Ctxt: HasMoveData<'tcx>\n+{\n+    fn dataflow(&mut self) {\n+        self.flow_state.build_sets();\n+        self.pre_dataflow_instrumentation().unwrap();\n+        self.flow_state.propagate();\n+        self.post_dataflow_instrumentation().unwrap();\n+    }\n+}\n+\n+struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O>\n+    where O: 'b + BitDenotation, O::Ctxt: HasMoveData<'tcx>,\n+{\n+    builder: &'b mut DataflowAnalysis<'a, 'tcx, O>,\n+    changed: bool,\n+}\n+\n+impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD>\n+    where BD: BitDenotation, BD::Ctxt: HasMoveData<'tcx>\n+{\n+    fn propagate(&mut self) {\n+        let mut temp = vec![0; self.flow_state.sets.words_per_block];\n+        let mut propcx = PropagationContext {\n+            builder: self,\n+            changed: true,\n+        };\n+        while propcx.changed {\n+            propcx.changed = false;\n+            propcx.reset(&mut temp);\n+            propcx.walk_cfg(&mut temp);\n+        }\n+    }\n+\n+    fn build_sets(&mut self) {\n+        // First we need to build the entry-, gen- and kill-sets. The\n+        // gather_moves information provides a high-level mapping from\n+        // mir-locations to the MoveOuts (and those correspond\n+        // directly to gen-sets here). But we still need to figure out\n+        // the kill-sets.\n+\n+        {\n+            let sets = &mut self.flow_state.sets.for_block(repr::START_BLOCK.index());\n+            self.flow_state.operator.start_block_effect(&self.ctxt, sets);\n+        }\n+\n+        for bb in self.mir.all_basic_blocks() {\n+            let &repr::BasicBlockData { ref statements,\n+                                        ref terminator,\n+                                        is_cleanup: _ } =\n+                self.mir.basic_block_data(bb);\n+\n+            let sets = &mut self.flow_state.sets.for_block(bb.index());\n+            for j_stmt in 0..statements.len() {\n+                self.flow_state.operator.statement_effect(&self.ctxt, sets, bb, j_stmt);\n+            }\n+\n+            if terminator.is_some() {\n+                let stmts_len = statements.len();\n+                self.flow_state.operator.terminator_effect(&self.ctxt, sets, bb, stmts_len);\n+            }\n+        }\n+    }\n+}\n+\n+fn on_all_children_bits<Each>(path_map: &PathMap,\n+                              move_paths: &MovePathData,\n+                              move_path_index: MovePathIndex,\n+                              mut each_child: Each)\n+    where Each: FnMut(MoveOutIndex)\n+{\n+    return on_all_children_bits_recur(\n+        path_map, move_paths, move_path_index, &mut each_child);\n+\n+    fn on_all_children_bits_recur<Each>(path_map: &PathMap,\n+                                        move_paths: &MovePathData,\n+                                        move_path_index: MovePathIndex,\n+                                        each_child: &mut Each)\n+        where Each: FnMut(MoveOutIndex)\n+    {\n+        // 1. invoke `each_child` callback for all moves that directly\n+        //    influence path for `move_path_index`\n+        for move_index in &path_map[move_path_index] {\n+            each_child(*move_index);\n+        }\n+\n+        // 2. for each child of the path (that is named in this\n+        //    function), recur.\n+        //\n+        // (Unnamed children are irrelevant to dataflow; by\n+        // definition they have no associated moves.)\n+        let mut next_child_index = move_paths[move_path_index].first_child;\n+        while let Some(child_index) = next_child_index {\n+            on_all_children_bits_recur(path_map, move_paths, child_index, each_child);\n+            next_child_index = move_paths[child_index].next_sibling;\n+        }\n+    }\n+}\n+\n+impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD>\n+    where BD: BitDenotation, BD::Ctxt: HasMoveData<'tcx>\n+{\n+    fn reset(&mut self, bits: &mut [usize]) {\n+        let e = if BD::initial_value() {usize::MAX} else {0};\n+        for b in bits {\n+            *b = e;\n+        }\n+    }\n+\n+    fn walk_cfg(&mut self, in_out: &mut [usize]) {\n+        let mir = self.builder.mir;\n+        for (bb_idx, bb_data) in mir.basic_blocks.iter().enumerate() {\n+            let builder = &mut self.builder;\n+            {\n+                let sets = builder.flow_state.sets.for_block(bb_idx);\n+                debug_assert!(in_out.len() == sets.on_entry.len());\n+                in_out.clone_from_slice(sets.on_entry);\n+                bitwise(in_out, sets.gen_set, &Union);\n+                bitwise(in_out, sets.kill_set, &Subtract);\n+            }\n+            builder.propagate_bits_into_graph_successors_of(in_out,\n+                                                            &mut self.changed,\n+                                                            (repr::BasicBlock::new(bb_idx), bb_data));\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a, BD> MirBorrowckCtxtPreDataflow<'a, 'tcx, BD>\n+    where BD: BitDenotation, BD::Bit: Debug, BD::Ctxt: HasMoveData<'tcx>\n+{\n+    fn path(context: &str, prepost: &str, path: &str) -> PathBuf {\n+        format!(\"{}_{}\", context, prepost);\n+        let mut path = PathBuf::from(path);\n+        let new_file_name = {\n+            let orig_file_name = path.file_name().unwrap().to_str().unwrap();\n+            format!(\"{}_{}\", context, orig_file_name)\n+        };\n+        path.set_file_name(new_file_name);\n+        path\n+    }\n+\n+    fn pre_dataflow_instrumentation(&self) -> io::Result<()> {\n+        if let Some(ref path_str) = self.print_preflow_to {\n+            let path = Self::path(BD::name(), \"preflow\", path_str);\n+            graphviz::print_borrowck_graph_to(self, &path)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    fn post_dataflow_instrumentation(&self) -> io::Result<()> {\n+        if let Some(ref path_str) = self.print_postflow_to {\n+            let path = Self::path(BD::name(), \"postflow\", path_str);\n+            graphviz::print_borrowck_graph_to(self, &path)\n+        } else{\n+            Ok(())\n+        }\n+    }\n+}\n+\n+/// Maps each block to a set of bits\n+#[derive(Clone, Debug)]\n+struct Bits {\n+    bits: Vec<usize>,\n+}\n+\n+impl Bits {\n+    fn new(init_word: usize, num_words: usize) -> Self {\n+        Bits { bits: vec![init_word; num_words] }\n+    }\n+}\n+\n+pub trait HasMoveData<'tcx> {\n+    fn move_data(&self) -> &MoveData<'tcx>;\n+}\n+\n+impl<'tcx> HasMoveData<'tcx> for MoveData<'tcx> {\n+    fn move_data(&self) -> &MoveData<'tcx> { self }\n+}\n+impl<'tcx, A, B> HasMoveData<'tcx> for (A, B, MoveData<'tcx>) {\n+    fn move_data(&self) -> &MoveData<'tcx> { &self.2 }\n+}\n+\n+pub struct DataflowAnalysis<'a, 'tcx: 'a, O>\n+    where O: BitDenotation, O::Ctxt: HasMoveData<'tcx>\n+{\n+    flow_state: DataflowState<O>,\n+    ctxt: O::Ctxt,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O>\n+    where O: BitDenotation, O::Ctxt: HasMoveData<'tcx>\n+{\n+    pub fn results(self) -> (O::Ctxt, DataflowResults<O>) {\n+        (self.ctxt, DataflowResults(self.flow_state))\n+    }\n+\n+    pub fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n+}\n+\n+#[derive(Debug)]\n+pub struct DataflowResults<O: BitDenotation>(DataflowState<O>);\n+\n+// FIXME: This type shouldn't be public, but the graphviz::MirWithFlowState trait\n+// references it in a method signature. Look into using `pub(crate)` to address this.\n+#[derive(Debug)]\n+pub struct DataflowState<O: BitDenotation>\n+{\n+    /// All the sets for the analysis. (Factored into its\n+    /// own structure so that we can borrow it mutably\n+    /// on its own separate from other fields.)\n+    pub sets: AllSets,\n+\n+    /// operator used to initialize, combine, and interpret bits.\n+    operator: O,\n+}\n+\n+#[derive(Debug)]\n+pub struct AllSets {\n+    /// Analysis bitwidth for each block.\n+    bits_per_block: usize,\n+\n+    /// Number of words associated with each block entry\n+    /// equal to bits_per_block / usize::BITS, rounded up.\n+    words_per_block: usize,\n+\n+    /// For each block, bits generated by executing the statements in\n+    /// the block. (For comparison, the Terminator for each block is\n+    /// handled in a flow-specific manner during propagation.)\n+    gen_sets: Bits,\n+\n+    /// For each block, bits killed by executing the statements in the\n+    /// block. (For comparison, the Terminator for each block is\n+    /// handled in a flow-specific manner during propagation.)\n+    kill_sets: Bits,\n+\n+    /// For each block, bits valid on entry to the block.\n+    on_entry_sets: Bits,\n+}\n+\n+pub struct BlockSets<'a> {\n+    on_entry: &'a mut [usize],\n+    gen_set: &'a mut [usize],\n+    kill_set: &'a mut [usize],\n+}\n+\n+impl AllSets {\n+    pub fn bits_per_block(&self) -> usize { self.bits_per_block }\n+    pub fn for_block(&mut self, block_idx: usize) -> BlockSets {\n+        let offset = self.words_per_block * block_idx;\n+        let range = offset..(offset + self.words_per_block);\n+        BlockSets {\n+            on_entry: &mut self.on_entry_sets.bits[range.clone()],\n+            gen_set: &mut self.gen_sets.bits[range.clone()],\n+            kill_set: &mut self.kill_sets.bits[range],\n+        }\n+    }\n+\n+    fn lookup_set_for<'a>(&self, sets: &'a Bits, block_idx: usize) -> &'a [usize] {\n+        let offset = self.words_per_block * block_idx;\n+        &sets.bits[offset..(offset + self.words_per_block)]\n+    }\n+    pub fn gen_set_for(&self, block_idx: usize) -> &[usize] {\n+        self.lookup_set_for(&self.gen_sets, block_idx)\n+    }\n+    pub fn kill_set_for(&self, block_idx: usize) -> &[usize] {\n+        self.lookup_set_for(&self.kill_sets, block_idx)\n+    }\n+    pub fn on_entry_set_for(&self, block_idx: usize) -> &[usize] {\n+        self.lookup_set_for(&self.on_entry_sets, block_idx)\n+    }\n+}\n+\n+impl<O: BitDenotation> DataflowState<O> {\n+    fn each_bit<F>(&self, ctxt: &O::Ctxt, words: &[usize], mut f: F)\n+        where F: FnMut(usize) {\n+        //! Helper for iterating over the bits in a bitvector.\n+\n+        let bits_per_block = self.operator.bits_per_block(ctxt);\n+        let usize_bits: usize = mem::size_of::<usize>() * 8;\n+\n+        for (word_index, &word) in words.iter().enumerate() {\n+            if word != 0 {\n+                let base_index = word_index * usize_bits;\n+                for offset in 0..usize_bits {\n+                    let bit = 1 << offset;\n+                    if (word & bit) != 0 {\n+                        // NB: we round up the total number of bits\n+                        // that we store in any given bit set so that\n+                        // it is an even multiple of usize::BITS. This\n+                        // means that there may be some stray bits at\n+                        // the end that do not correspond to any\n+                        // actual value; that's why we first check\n+                        // that we are in range of bits_per_block.\n+                        let bit_index = base_index + offset as usize;\n+                        if bit_index >= bits_per_block {\n+                            return;\n+                        } else {\n+                            f(bit_index);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn interpret_set<'c>(&self, ctxt: &'c O::Ctxt, words: &[usize]) -> Vec<&'c O::Bit> {\n+        let mut v = Vec::new();\n+        self.each_bit(ctxt, words, |i| {\n+            v.push(self.operator.interpret(ctxt, i));\n+        });\n+        v\n+    }\n+}\n+\n+pub trait BitwiseOperator {\n+    /// Joins two predecessor bits together, typically either `|` or `&`\n+    fn join(&self, pred1: usize, pred2: usize) -> usize;\n+}\n+\n+/// Parameterization for the precise form of data flow that is used.\n+pub trait DataflowOperator : BitwiseOperator {\n+    /// Specifies the initial value for each bit in the `on_entry` set\n+    fn initial_value() -> bool;\n+}\n+\n+pub trait BitDenotation: DataflowOperator {\n+    /// Specifies what is represented by each bit in the dataflow bitvector.\n+    type Bit;\n+\n+    /// Specifies what, if any, separate context needs to be supplied for methods below.\n+    type Ctxt;\n+\n+    /// A name describing the dataflow analysis that this\n+    /// BitDenotation is supporting.  The name should be something\n+    /// suitable for plugging in as part of a filename e.g. avoid\n+    /// space-characters or other things that tend to look bad on a\n+    /// file system, like slashes or periods. It is also better for\n+    /// the name to be reasonably short, again because it will be\n+    /// plugged into a filename.\n+    fn name() -> &'static str;\n+\n+    /// Size of each bitvector allocated for each block in the analysis.\n+    fn bits_per_block(&self, &Self::Ctxt) -> usize;\n+\n+    /// Provides the meaning of each entry in the dataflow bitvector.\n+    /// (Mostly intended for use for better debug instrumentation.)\n+    fn interpret<'a>(&self, &'a Self::Ctxt, idx: usize) -> &'a Self::Bit;\n+\n+    /// Mutates the block-sets (the flow sets for the given\n+    /// basic block) according to the effects that have been\n+    /// established *prior* to entering the start block.\n+    ///\n+    /// (For example, establishing the call arguments.)\n+    ///\n+    /// (Typically this should only modify `sets.on_entry`, since the\n+    /// gen and kill sets should reflect the effects of *executing*\n+    /// the start block itself.)\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets);\n+\n+    /// Mutates the block-sets (the flow sets for the given\n+    /// basic block) according to the effects of evaluating statement.\n+    ///\n+    /// This is used, in particular, for building up the\n+    /// \"transfer-function\" represnting the overall-effect of the\n+    /// block, represented via GEN and KILL sets.\n+    ///\n+    /// The statement here is `idx_stmt.1`; `idx_stmt.0` is just\n+    /// an identifying index: namely, the index of the statement\n+    /// in the basic block.\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets,\n+                        bb: repr::BasicBlock,\n+                        idx_stmt: usize);\n+\n+    /// Mutates the block-sets (the flow sets for the given\n+    /// basic block) according to the effects of evaluating\n+    /// the terminator.\n+    ///\n+    /// This is used, in particular, for building up the\n+    /// \"transfer-function\" represnting the overall-effect of the\n+    /// block, represented via GEN and KILL sets.\n+    ///\n+    /// The terminator here is `idx_term.1`; `idx_term.0` is just an\n+    /// identifying index: namely, the number of statements in `bb`\n+    /// itself.\n+    ///\n+    /// The effects applied here cannot depend on which branch the\n+    /// terminator took.\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets,\n+                         bb: repr::BasicBlock,\n+                         idx_term: usize);\n+\n+    /// Mutates the block-sets according to the (flow-dependent)\n+    /// effect of a successful return from a Call terminator.\n+    ///\n+    /// If basic-block BB_x ends with a call-instruction that, upon\n+    /// successful return, flows to BB_y, then this method will be\n+    /// called on the exit flow-state of BB_x in order to set up the\n+    /// entry flow-state of BB_y.\n+    ///\n+    /// This is used, in particular, as a special case during the\n+    /// \"propagate\" loop where all of the basic blocks are repeatedly\n+    /// visited. Since the effects of a Call terminator are\n+    /// flow-dependent, the current MIR cannot encode them via just\n+    /// GEN and KILL sets attached to the block, and so instead we add\n+    /// this extra machinery to represent the flow-dependent effect.\n+    ///\n+    /// Note: as a historical artifact, this currently takes as input\n+    /// the *entire* packed collection of bitvectors in `in_out`.  We\n+    /// might want to look into narrowing that to something more\n+    /// specific, just to make the interface more self-documenting.\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut [usize],\n+                             call_bb: repr::BasicBlock,\n+                             dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue);\n+}\n+\n+impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n+    where D: BitDenotation, D::Ctxt: HasMoveData<'tcx>\n+{\n+    pub fn new(_tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               mir: &'a Mir<'tcx>,\n+               ctxt: D::Ctxt,\n+               denotation: D) -> Self {\n+        let bits_per_block = denotation.bits_per_block(&ctxt);\n+        let usize_bits = mem::size_of::<usize>() * 8;\n+        let words_per_block = (bits_per_block + usize_bits - 1) / usize_bits;\n+        let num_blocks = mir.basic_blocks.len();\n+        let num_words = num_blocks * words_per_block;\n+\n+        let entry = if D::initial_value() { usize::MAX } else {0};\n+\n+        let zeroes = Bits::new(0, num_words);\n+        let on_entry = Bits::new(entry, num_words);\n+\n+        DataflowAnalysis { flow_state: DataflowState {\n+            sets: AllSets {\n+                bits_per_block: bits_per_block,\n+                words_per_block: words_per_block,\n+                gen_sets: zeroes.clone(),\n+                kill_sets: zeroes,\n+                on_entry_sets: on_entry,\n+            },\n+            operator: denotation,\n+        },\n+                           ctxt: ctxt,\n+                           mir: mir,\n+        }\n+\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n+    where D: BitDenotation, D::Ctxt: HasMoveData<'tcx>\n+{\n+    /// Propagates the bits of `in_out` into all the successors of `bb`,\n+    /// using bitwise operator denoted by `self.operator`.\n+    ///\n+    /// For most blocks, this is entirely uniform. However, for blocks\n+    /// that end with a call terminator, the effect of the call on the\n+    /// dataflow state may depend on whether the call returned\n+    /// successfully or unwound.\n+    ///\n+    /// To reflect this, the `propagate_call_return` method of the\n+    /// `BitDenotation` mutates `in_out` when propagating `in_out` via\n+    /// a call terminator; such mutation is performed *last*, to\n+    /// ensure its side-effects do not leak elsewhere (e.g. into\n+    /// unwind target).\n+    fn propagate_bits_into_graph_successors_of(\n+        &mut self,\n+        in_out: &mut [usize],\n+        changed: &mut bool,\n+        (bb, bb_data): (repr::BasicBlock, &repr::BasicBlockData))\n+    {\n+        match bb_data.terminator().kind {\n+            repr::TerminatorKind::Return |\n+            repr::TerminatorKind::Resume => {}\n+            repr::TerminatorKind::Goto { ref target } |\n+            repr::TerminatorKind::Drop { ref target, value: _, unwind: None } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+            }\n+            repr::TerminatorKind::Drop { ref target, value: _, unwind: Some(ref unwind) } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n+            }\n+            repr::TerminatorKind::If { ref targets, .. } => {\n+                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.0);\n+                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.1);\n+            }\n+            repr::TerminatorKind::Switch { ref targets, .. } |\n+            repr::TerminatorKind::SwitchInt { ref targets, .. } => {\n+                for target in targets {\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, target);\n+                }\n+            }\n+            repr::TerminatorKind::Call { ref cleanup, ref destination, func: _, args: _ } => {\n+                if let Some(ref unwind) = *cleanup {\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n+                }\n+                if let Some((ref dest_lval, ref dest_bb)) = *destination {\n+                    // N.B.: This must be done *last*, after all other\n+                    // propagation, as documented in comment above.\n+                    self.flow_state.operator.propagate_call_return(\n+                        &self.ctxt, in_out, bb, *dest_bb, dest_lval);\n+                    self.propagate_bits_into_entry_set_for(in_out, changed, dest_bb);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn propagate_bits_into_entry_set_for(&mut self,\n+                                         in_out: &[usize],\n+                                         changed: &mut bool,\n+                                         bb: &repr::BasicBlock) {\n+        let entry_set = self.flow_state.sets.for_block(bb.index()).on_entry;\n+        let set_changed = bitwise(entry_set, in_out, &self.flow_state.operator);\n+        if set_changed {\n+            *changed = true;\n+        }\n+    }\n+}\n+\n+// Dataflow analyses are built upon some interpretation of the\n+// bitvectors attached to each basic block, represented via a\n+// zero-sized structure.\n+//\n+// Note on PhantomData: Each interpretation will need to instantiate\n+// the `Bit` and `Ctxt` associated types, and in this case, those\n+// associated types need an associated lifetime `'tcx`. The\n+// interpretive structures are zero-sized, so they all need to carry a\n+// `PhantomData` representing how the structures relate to the `'tcx`\n+// lifetime.\n+//\n+// But, since all of the uses of `'tcx` are solely via instances of\n+// `Ctxt` that are passed into the `BitDenotation` methods, we can\n+// consistently use a `PhantomData` that is just a function over a\n+// `&Ctxt` (== `&MoveData<'tcx>).\n+\n+/// `MaybeInitializedLvals` tracks all l-values that might be\n+/// initialized upon reaching a particular point in the control flow\n+/// for a function.\n+///\n+/// For example, in code like the following, we have corresponding\n+/// dataflow information shown in the right-hand comments.\n+///\n+/// ```rust\n+/// struct S;\n+/// fn foo(pred: bool) {                       // maybe-init:\n+///                                            // {}\n+///     let a = S; let b = S; let c; let d;    // {a, b}\n+///\n+///     if pred {\n+///         drop(a);                           // {   b}\n+///         b = S;                             // {   b}\n+///\n+///     } else {\n+///         drop(b);                           // {a}\n+///         d = S;                             // {a,       d}\n+///\n+///     }                                      // {a, b,    d}\n+///\n+///     c = S;                                 // {a, b, c, d}\n+/// }\n+/// ```\n+///\n+/// To determine whether an l-value *must* be initialized at a\n+/// particular control-flow point, one can take the set-difference\n+/// between this data and the data from `MaybeUninitializedLvals` at the\n+/// corresponding control-flow point.\n+///\n+/// Similarly, at a given `drop` statement, the set-intersection\n+/// between this data and `MaybeUninitializedLvals` yields the set of\n+/// l-values that would require a dynamic drop-flag at that statement.\n+#[derive(Debug, Default)]\n+pub struct MaybeInitializedLvals<'a, 'tcx: 'a> {\n+    // See \"Note on PhantomData\" above.\n+    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n+}\n+\n+/// `MaybeUninitializedLvals` tracks all l-values that might be\n+/// uninitialized upon reaching a particular point in the control flow\n+/// for a function.\n+///\n+/// For example, in code like the following, we have corresponding\n+/// dataflow information shown in the right-hand comments.\n+///\n+/// ```rust\n+/// struct S;\n+/// fn foo(pred: bool) {                       // maybe-uninit:\n+///                                            // {a, b, c, d}\n+///     let a = S; let b = S; let c; let d;    // {      c, d}\n+///\n+///     if pred {\n+///         drop(a);                           // {a,    c, d}\n+///         b = S;                             // {a,    c, d}\n+///\n+///     } else {\n+///         drop(b);                           // {   b, c, d}\n+///         d = S;                             // {   b, c   }\n+///\n+///     }                                      // {a, b, c, d}\n+///\n+///     c = S;                                 // {a, b,    d}\n+/// }\n+/// ```\n+///\n+/// To determine whether an l-value *must* be uninitialized at a\n+/// particular control-flow point, one can take the set-difference\n+/// between this data and the data from `MaybeInitializedLvals` at the\n+/// corresponding control-flow point.\n+///\n+/// Similarly, at a given `drop` statement, the set-intersection\n+/// between this data and `MaybeInitializedLvals` yields the set of\n+/// l-values that would require a dynamic drop-flag at that statement.\n+#[derive(Debug, Default)]\n+pub struct MaybeUninitializedLvals<'a, 'tcx: 'a> {\n+    // See \"Note on PhantomData\" above.\n+    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n+}\n+\n+/// `MovingOutStatements` tracks the statements that perform moves out\n+/// of particular l-values. More precisely, it tracks whether the\n+/// *effect* of such moves (namely, the uninitialization of the\n+/// l-value in question) can reach some point in the control-flow of\n+/// the function, or if that effect is \"killed\" by some intervening\n+/// operation reinitializing that l-value.\n+///\n+/// The resulting dataflow is a more enriched version of\n+/// `MaybeUninitializedLvals`. Both structures on their own only tell\n+/// you if an l-value *might* be uninitialized at a given point in the\n+/// control flow. But `MovingOutStatements` also includes the added\n+/// data of *which* particular statement causing the deinitialization\n+/// that the borrow checker's error meessage may need to report.\n+#[derive(Debug, Default)]\n+pub struct MovingOutStatements<'a, 'tcx: 'a> {\n+    // See \"Note on PhantomData\" above.\n+    phantom: PhantomData<Fn(&'a MoveData<'tcx>, TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>)>\n+}\n+\n+impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n+    type Bit = MoveOut;\n+    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n+    fn name() -> &'static str { \"moving_out\" }\n+    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n+        ctxt.2.moves.len()\n+    }\n+    fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n+        &ctxt.2.moves[idx]\n+    }\n+    fn start_block_effect(&self,_move_data: &Self::Ctxt, _sets: &mut BlockSets) {\n+        // no move-statements have been executed prior to function\n+        // execution, so this method has no effect on `_sets`.\n+    }\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets,\n+                        bb: repr::BasicBlock,\n+                        idx: usize) {\n+        let &(_tcx, mir, ref move_data) = ctxt;\n+        let stmt = &mir.basic_block_data(bb).statements[idx];\n+        let move_paths = &move_data.move_paths;\n+        let loc_map = &move_data.loc_map;\n+        let path_map = &move_data.path_map;\n+        let rev_lookup = &move_data.rev_lookup;\n+\n+        let loc = Location { block: bb, index: idx };\n+        debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n+               stmt, loc, &loc_map[loc]);\n+        for move_index in &loc_map[loc] {\n+            // Every path deinitialized by a *particular move*\n+            // has corresponding bit, \"gen'ed\" (i.e. set)\n+            // here, in dataflow vector\n+            zero_to_one(&mut sets.gen_set, *move_index);\n+        }\n+        let bits_per_block = self.bits_per_block(ctxt);\n+        match stmt.kind {\n+            repr::StatementKind::Assign(ref lvalue, _) => {\n+                // assigning into this `lvalue` kills all\n+                // MoveOuts from it, and *also* all MoveOuts\n+                // for children and associated fragment sets.\n+                let move_path_index = rev_lookup.find(lvalue);\n+\n+                sets.kill_set.set_bit(move_path_index.idx());\n+                on_all_children_bits(path_map,\n+                                     move_paths,\n+                                     move_path_index,\n+                                     |moi| {\n+                                         assert!(moi.idx() < bits_per_block);\n+                                         sets.kill_set.set_bit(moi.idx());\n+                                     });\n+            }\n+        }\n+    }\n+\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets,\n+                         bb: repr::BasicBlock,\n+                         statements_len: usize)\n+    {\n+        let &(_tcx, mir, ref move_data) = ctxt;\n+        let term = mir.basic_block_data(bb).terminator.as_ref().unwrap();\n+        let loc_map = &move_data.loc_map;\n+        let loc = Location { block: bb, index: statements_len };\n+        debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n+               term, loc, &loc_map[loc]);\n+        let bits_per_block = self.bits_per_block(ctxt);\n+        for move_index in &loc_map[loc] {\n+            assert!(move_index.idx() < bits_per_block);\n+            zero_to_one(&mut sets.gen_set, *move_index);\n+        }\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut [usize],\n+                             _call_bb: repr::BasicBlock,\n+                             _dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue) {\n+        let move_data = &ctxt.2;\n+        let move_path_index = move_data.rev_lookup.find(dest_lval);\n+        let bits_per_block = self.bits_per_block(ctxt);\n+\n+        in_out.clear_bit(move_path_index.idx());\n+        on_all_children_bits(&move_data.path_map,\n+                             &move_data.move_paths,\n+                             move_path_index,\n+                             |moi| {\n+                                 assert!(moi.idx() < bits_per_block);\n+                                 in_out.clear_bit(moi.idx());\n+                             });\n+    }\n+}\n+\n+impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n+    fn update_bits(sets: &mut BlockSets, path: MovePathIndex,\n+                   state: super::DropFlagState)\n+    {\n+        match state {\n+            DropFlagState::Dead => {\n+                sets.gen_set.clear_bit(path.idx());\n+                sets.kill_set.set_bit(path.idx());\n+            }\n+            DropFlagState::Live => {\n+                sets.gen_set.set_bit(path.idx());\n+                sets.kill_set.clear_bit(path.idx());\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> MaybeUninitializedLvals<'a, 'tcx> {\n+    fn update_bits(sets: &mut BlockSets, path: MovePathIndex,\n+                   state: super::DropFlagState)\n+    {\n+        match state {\n+            DropFlagState::Dead => {\n+                sets.gen_set.set_bit(path.idx());\n+                sets.kill_set.clear_bit(path.idx());\n+            }\n+            DropFlagState::Live => {\n+                sets.gen_set.clear_bit(path.idx());\n+                sets.kill_set.set_bit(path.idx());\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n+    type Bit = MovePath<'tcx>;\n+    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n+    fn name() -> &'static str { \"maybe_init\" }\n+    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n+        ctxt.2.move_paths.len()\n+    }\n+    fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n+        &ctxt.2.move_paths[MovePathIndex::new(idx)]\n+    }\n+\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets)\n+    {\n+        super::drop_flag_effects_for_function_entry(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            |path, s| {\n+                assert!(s == DropFlagState::Live);\n+                sets.on_entry.set_bit(path.idx());\n+            });\n+    }\n+\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets,\n+                        bb: repr::BasicBlock,\n+                        idx: usize)\n+    {\n+        super::drop_flag_effects_for_location(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            Location { block: bb, index: idx },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets,\n+                         bb: repr::BasicBlock,\n+                         statements_len: usize)\n+    {\n+        super::drop_flag_effects_for_location(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            Location { block: bb, index: statements_len },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut [usize],\n+                             _call_bb: repr::BasicBlock,\n+                             _dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue) {\n+        // when a call returns successfully, that means we need to set\n+        // the bits for that dest_lval to 1 (initialized).\n+        let move_data = &ctxt.2;\n+        let move_path_index = move_data.rev_lookup.find(dest_lval);\n+        super::on_all_children_bits(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            move_path_index,\n+            |mpi| { in_out.set_bit(mpi.idx()); }\n+        );\n+    }\n+}\n+\n+impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n+    type Bit = MovePath<'tcx>;\n+    type Ctxt = (TyCtxt<'a, 'tcx, 'tcx>, &'a Mir<'tcx>, MoveData<'tcx>);\n+    fn name() -> &'static str { \"maybe_uninit\" }\n+    fn bits_per_block(&self, ctxt: &Self::Ctxt) -> usize {\n+        ctxt.2.move_paths.len()\n+    }\n+    fn interpret<'c>(&self, ctxt: &'c Self::Ctxt, idx: usize) -> &'c Self::Bit {\n+        &ctxt.2.move_paths[MovePathIndex::new(idx)]\n+    }\n+\n+    // sets on_entry bits for Arg lvalues\n+    fn start_block_effect(&self, ctxt: &Self::Ctxt, sets: &mut BlockSets) {\n+        for e in &mut sets.on_entry[..] { *e = !0; }\n+\n+        super::drop_flag_effects_for_function_entry(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            |path, s| {\n+                assert!(s == DropFlagState::Live);\n+                sets.on_entry.clear_bit(path.idx());\n+            });\n+    }\n+\n+    fn statement_effect(&self,\n+                        ctxt: &Self::Ctxt,\n+                        sets: &mut BlockSets,\n+                        bb: repr::BasicBlock,\n+                        idx: usize)\n+    {\n+        super::drop_flag_effects_for_location(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            Location { block: bb, index: idx },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn terminator_effect(&self,\n+                         ctxt: &Self::Ctxt,\n+                         sets: &mut BlockSets,\n+                         bb: repr::BasicBlock,\n+                         statements_len: usize)\n+    {\n+        super::drop_flag_effects_for_location(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            Location { block: bb, index: statements_len },\n+            |path, s| Self::update_bits(sets, path, s)\n+        )\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             ctxt: &Self::Ctxt,\n+                             in_out: &mut [usize],\n+                             _call_bb: repr::BasicBlock,\n+                             _dest_bb: repr::BasicBlock,\n+                             dest_lval: &repr::Lvalue) {\n+        // when a call returns successfully, that means we need to set\n+        // the bits for that dest_lval to 1 (initialized).\n+        let move_path_index = ctxt.2.rev_lookup.find(dest_lval);\n+        super::on_all_children_bits(\n+            ctxt.0, ctxt.1, &ctxt.2,\n+            move_path_index,\n+            |mpi| { in_out.clear_bit(mpi.idx()); }\n+        );\n+    }\n+}\n+\n+fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n+    let retval = bitvec.set_bit(move_index.idx());\n+    assert!(retval);\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // moves from both preds are in scope\n+    }\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // \"maybe\" means we union effects of both preds\n+    }\n+}\n+\n+impl<'a, 'tcx> BitwiseOperator for MaybeUninitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // \"maybe\" means we union effects of both preds\n+    }\n+}\n+\n+// FIXME: I'm not sure it ever makes sense to use `true` for a\n+// DataflowOperator::initial_value implementation, because: the way\n+// that dataflow fixed point iteration works, you want to start at\n+// bottom and work your way to a fixed point.\n+//\n+// This means, for propagation across the graph, that you either want\n+// to start at all-zeroes and then use Union as your merge when\n+// propagating, or you start at all-ones and then use Intersect as\n+// your merge when propagating.\n+//\n+// (An alternative could be, when propagating from Block A into block\n+// B, to clear B's on_entry bits, and then iterate over all of B's\n+// immediate predecessors. This would require storing on_exit state\n+// for each block, however.)\n+   \n+impl<'a, 'tcx> DataflowOperator for MovingOutStatements<'a, 'tcx> {\n+    #[inline]\n+    fn initial_value() -> bool {\n+        false // bottom = no loans in scope by default\n+    }\n+}\n+\n+impl<'a, 'tcx> DataflowOperator for MaybeInitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn initial_value() -> bool {\n+        false // bottom = uninitialized\n+    }\n+}\n+\n+impl<'a, 'tcx> DataflowOperator for MaybeUninitializedLvals<'a, 'tcx> {\n+    #[inline]\n+    fn initial_value() -> bool {\n+        false // bottom = uninitialized\n+    }\n+}\n+\n+#[inline]\n+fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n+                               in_vec: &[usize],\n+                               op: &Op) -> bool {\n+    assert_eq!(out_vec.len(), in_vec.len());\n+    let mut changed = false;\n+    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n+        let old_val = *out_elt;\n+        let new_val = op.join(old_val, *in_elt);\n+        *out_elt = new_val;\n+        changed |= old_val != new_val;\n+    }\n+    changed\n+}\n+\n+struct Union;\n+impl BitwiseOperator for Union {\n+    fn join(&self, a: usize, b: usize) -> usize { a | b }\n+}\n+struct Subtract;\n+impl BitwiseOperator for Subtract {\n+    fn join(&self, a: usize, b: usize) -> usize { a & !b }\n+}"}, {"sha": "519e9398436b8a73bcddd6a1f036e203ddf93f5f", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c73f3517a24a87763c7b81228816959ad7fef2e9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73f3517a24a87763c7b81228816959ad7fef2e9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=c73f3517a24a87763c7b81228816959ad7fef2e9", "patch": "@@ -19,7 +19,6 @@ use std::fmt;\n use std::iter;\n use std::ops::Index;\n \n-use super::dataflow::BitDenotation;\n use super::abs_domain::{AbstractElem, Lift};\n \n // This submodule holds some newtype'd Index wrappers that are using\n@@ -32,7 +31,7 @@ mod indexes {\n \n     macro_rules! new_index {\n         ($Index:ident) => {\n-            #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+            #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n             pub struct $Index(NonZero<usize>);\n \n             impl $Index {\n@@ -56,6 +55,12 @@ mod indexes {\n pub use self::indexes::MovePathIndex;\n pub use self::indexes::MoveOutIndex;\n \n+impl self::indexes::MoveOutIndex {\n+    pub fn move_path_index(&self, move_data: &MoveData) -> MovePathIndex {\n+        move_data.moves[self.idx()].path\n+    }\n+}\n+\n /// `MovePath` is a canonicalized representation of a path that is\n /// moved or assigned to.\n ///\n@@ -125,6 +130,7 @@ impl<'tcx> fmt::Debug for MovePath<'tcx> {\n     }\n }\n \n+#[derive(Debug)]\n pub struct MoveData<'tcx> {\n     pub move_paths: MovePathData<'tcx>,\n     pub moves: Vec<MoveOut>,\n@@ -133,6 +139,7 @@ pub struct MoveData<'tcx> {\n     pub rev_lookup: MovePathLookup<'tcx>,\n }\n \n+#[derive(Debug)]\n pub struct LocMap {\n     /// Location-indexed (BasicBlock for outer index, index within BB\n     /// for inner index) map to list of MoveOutIndex's.\n@@ -153,6 +160,7 @@ impl Index<Location> for LocMap {\n     }\n }\n \n+#[derive(Debug)]\n pub struct PathMap {\n     /// Path-indexed map to list of MoveOutIndex's.\n     ///\n@@ -187,7 +195,7 @@ impl fmt::Debug for MoveOut {\n     }\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n pub struct Location {\n     /// block where action is located\n     pub block: BasicBlock,\n@@ -202,10 +210,15 @@ impl fmt::Debug for Location {\n     }\n }\n \n+#[derive(Debug)]\n pub struct MovePathData<'tcx> {\n     move_paths: Vec<MovePath<'tcx>>,\n }\n \n+impl<'tcx> MovePathData<'tcx> {\n+    pub fn len(&self) -> usize { self.move_paths.len() }\n+}\n+\n impl<'tcx> Index<MovePathIndex> for MovePathData<'tcx> {\n     type Output = MovePath<'tcx>;\n     fn index(&self, i: MovePathIndex) -> &MovePath<'tcx> {\n@@ -224,6 +237,7 @@ struct MovePathDataBuilder<'a, 'tcx: 'a> {\n }\n \n /// Tables mapping from an l-value to its MovePathIndex.\n+#[derive(Debug)]\n pub struct MovePathLookup<'tcx> {\n     vars: MovePathInverseMap,\n     temps: MovePathInverseMap,\n@@ -272,6 +286,7 @@ impl<T:Clone> FillTo for Vec<T> {\n \n #[derive(Clone, Debug)]\n enum LookupKind { Generate, Reuse }\n+#[derive(Clone, Debug)]\n struct Lookup<T>(LookupKind, T);\n \n impl Lookup<MovePathIndex> {\n@@ -425,6 +440,8 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n     }\n \n     fn move_path_for(&mut self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n+        debug!(\"move_path_for({:?})\", lval);\n+\n         let lookup: Lookup<MovePathIndex> = self.lookup(lval);\n \n         // `lookup` is either the previously assigned index or a\n@@ -547,7 +564,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n         debug_assert!(loc_map_bb.len() == len + 1);\n \n         let mut bb_ctxt = BlockContext {\n-            tcx: tcx,\n+            _tcx: tcx,\n             moves: &mut moves,\n             builder: builder,\n             path_map: &mut path_map,\n@@ -608,23 +625,17 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                             // example where I am seeing this arise is\n                             // `TargetDataLayout::parse(&Session)` in\n                             // `rustc::ty::layout`.\n-                            debug!(\"encountered Rvalue::Slice as RHS of Assign, source: {:?} \\n{}\",\n-                                   source, {\n-                                       let mut out = Vec::new();\n-                                       {\n-                                           use std::io::Write;\n-                                           use rustc_mir::pretty::write_mir_named;\n-                                           let mut w: &mut Write = &mut out;\n-                                           write_mir_named(tcx, \"boo_attempt_move_out_of_slice\", mir, &mut w, None).unwrap();\n-                                       }\n-                                       String::from_utf8(out).unwrap()\n-                                   });\n+                            //\n+                            // this should be removed soon.\n+                            debug!(\"encountered Rvalue::Slice as RHS of Assign, source: {:?}\",\n+                                   source);\n                         }\n                     }\n                 }\n             }\n         }\n \n+        debug!(\"gather_moves({:?})\", bb_data.terminator());\n         match bb_data.terminator().kind {\n             TerminatorKind::Goto { target: _ } | TerminatorKind::Resume => { }\n \n@@ -642,7 +653,6 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n             TerminatorKind::If { ref cond, targets: _ } => {\n                 let source = Location { block: bb,\n                                         index: bb_data.statements.len() };\n-                debug!(\"gather_moves If on_operand {:?} {:?}\", cond, source);\n                 bb_ctxt.on_operand(SK::If, cond, source);\n             }\n \n@@ -658,10 +668,8 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n             TerminatorKind::Drop { value: ref lval, target: _, unwind: _ } => {\n                 let source = Location { block: bb,\n                                         index: bb_data.statements.len() };\n-                debug!(\"gather_moves Drop on_move_out_lval {:?} {:?}\", lval, source);\n                 bb_ctxt.on_move_out_lval(SK::Drop, lval, source);\n             }\n-\n             TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n                 let source = Location { block: bb,\n                                         index: bb_data.statements.len() };\n@@ -727,7 +735,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n }\n \n struct BlockContext<'b, 'a: 'b, 'tcx: 'a> {\n-    tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+    _tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     moves: &'b mut Vec<MoveOut>,\n     builder: MovePathDataBuilder<'a, 'tcx>,\n     path_map: &'b mut Vec<Vec<MoveOutIndex>>,\n@@ -739,7 +747,6 @@ impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n                         stmt_kind: StmtKind,\n                         lval: &Lvalue<'tcx>,\n                         source: Location) {\n-        let tcx = self.tcx;\n         let i = source.index;\n         let index = MoveOutIndex::new(self.moves.len());\n \n@@ -774,13 +781,3 @@ impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n         }\n     }\n }\n-\n-impl<'tcx> BitDenotation for MoveData<'tcx>{\n-    type Bit = MoveOut;\n-    fn bits_per_block(&self) -> usize {\n-        self.moves.len()\n-    }\n-    fn interpret(&self, idx: usize) -> &Self::Bit {\n-        &self.moves[idx]\n-    }\n-}"}, {"sha": "44a53a2352869e68838b89351e9ada3c59886e0b", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 221, "deletions": 12, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/c73f3517a24a87763c7b81228816959ad7fef2e9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73f3517a24a87763c7b81228816959ad7fef2e9/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=c73f3517a24a87763c7b81228816959ad7fef2e9", "patch": "@@ -10,24 +10,49 @@\n \n use borrowck::BorrowckCtxt;\n \n-use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax::ast::{self, MetaItem};\n+use syntax::attr::AttrMetaMethods;\n+use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::ptr::P;\n \n use rustc::hir;\n use rustc::hir::intravisit::{FnKind};\n \n+use rustc::mir::repr;\n use rustc::mir::repr::{BasicBlock, BasicBlockData, Mir, Statement, Terminator};\n+use rustc::session::Session;\n+use rustc::ty::{self, TyCtxt};\n \n mod abs_domain;\n mod dataflow;\n mod gather_moves;\n-mod graphviz;\n+// mod graphviz;\n \n-use self::dataflow::{Dataflow, DataflowState};\n-use self::gather_moves::{MoveData};\n+use self::dataflow::{BitDenotation};\n+use self::dataflow::{Dataflow, DataflowAnalysis, DataflowResults};\n+use self::dataflow::{HasMoveData};\n+use self::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use self::gather_moves::{MoveData, MovePathIndex, Location};\n+use self::gather_moves::{MovePathContent};\n \n-pub fn borrowck_mir<'b, 'a: 'b, 'tcx: 'a>(\n-    bcx: &'b mut BorrowckCtxt<'a, 'tcx>,\n+use std::fmt::Debug;\n+\n+fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<P<MetaItem>> {\n+    for attr in attrs {\n+        if attr.check_name(\"rustc_mir\") {\n+            let items = attr.meta_item_list();\n+            for item in items.iter().flat_map(|l| l.iter()) {\n+                if item.check_name(name) {\n+                    return Some(item.clone())\n+                }\n+            }\n+        }\n+    }\n+    return None;\n+}\n+\n+pub fn borrowck_mir<'a, 'tcx: 'a>(\n+    bcx: &mut BorrowckCtxt<'a, 'tcx>,\n     fk: FnKind,\n     _decl: &hir::FnDecl,\n     mir: &'a Mir<'tcx>,\n@@ -45,29 +70,89 @@ pub fn borrowck_mir<'b, 'a: 'b, 'tcx: 'a>(\n         }\n     }\n \n+    let tcx = bcx.tcx;\n+\n+    let move_data = MoveData::gather_moves(mir, tcx);\n+    let ctxt = (tcx, mir, move_data);\n+    let (ctxt, flow_inits) =\n+        do_dataflow(bcx, mir, id, attributes, ctxt, MaybeInitializedLvals::default());\n+    let ((_, _, move_data), flow_uninits) =\n+        do_dataflow(bcx, mir, id, attributes, ctxt, MaybeUninitializedLvals::default());\n+\n     let mut mbcx = MirBorrowckCtxt {\n-        flow_state: DataflowState::new_move_analysis(mir, bcx.tcx),\n         bcx: bcx,\n         mir: mir,\n         node_id: id,\n-        attributes: attributes,\n+        move_data: move_data,\n+        flow_inits: flow_inits,\n+        flow_uninits: flow_uninits,\n     };\n \n     for bb in mir.all_basic_blocks() {\n         mbcx.process_basic_block(bb);\n     }\n \n+    debug!(\"borrowck_mir done\");\n+}\n+\n+fn do_dataflow<'a, 'tcx, BD>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             mir: &Mir<'tcx>,\n+                             node_id: ast::NodeId,\n+                             attributes: &[ast::Attribute],\n+                             ctxt: BD::Ctxt,\n+                             bd: BD) -> (BD::Ctxt, DataflowResults<BD>)\n+    where BD: BitDenotation, BD::Bit: Debug, BD::Ctxt: HasMoveData<'tcx>\n+{\n+    use syntax::attr::AttrMetaMethods;\n+\n+    let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n+        if let Some(item) = has_rustc_mir_with(attrs, name) {\n+            if let Some(s) = item.value_str() {\n+                return Some(s.to_string())\n+            } else {\n+                sess.span_err(\n+                    item.span,\n+                    &format!(\"{} attribute requires a path\", item.name()));\n+                return None;\n+            }\n+        }\n+        return None;\n+    };\n+\n+    let print_preflow_to =\n+        name_found(tcx.sess, attributes, \"borrowck_graphviz_preflow\");\n+    let print_postflow_to =\n+        name_found(tcx.sess, attributes, \"borrowck_graphviz_postflow\");\n+\n+    let mut mbcx = MirBorrowckCtxtPreDataflow {\n+        node_id: node_id,\n+        print_preflow_to: print_preflow_to,\n+        print_postflow_to: print_postflow_to,\n+        flow_state: DataflowAnalysis::new(tcx, mir, ctxt, bd),\n+    };\n+\n     mbcx.dataflow();\n+    mbcx.flow_state.results()\n+}\n \n-    debug!(\"borrowck_mir done\");\n+\n+pub struct MirBorrowckCtxtPreDataflow<'a, 'tcx: 'a, BD>\n+    where BD: BitDenotation, BD::Ctxt: HasMoveData<'tcx>\n+{\n+    node_id: ast::NodeId,\n+    flow_state: DataflowAnalysis<'a, 'tcx, BD>,\n+    print_preflow_to: Option<String>,\n+    print_postflow_to: Option<String>,\n }\n \n+#[allow(dead_code)]\n pub struct MirBorrowckCtxt<'b, 'a: 'b, 'tcx: 'a> {\n     bcx: &'b mut BorrowckCtxt<'a, 'tcx>,\n     mir: &'b Mir<'tcx>,\n     node_id: ast::NodeId,\n-    attributes: &'b [ast::Attribute],\n-    flow_state: DataflowState<MoveData<'tcx>>,\n+    move_data: MoveData<'tcx>,\n+    flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx>>,\n+    flow_uninits: DataflowResults<MaybeUninitializedLvals<'a, 'tcx>>\n }\n \n impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n@@ -89,3 +174,127 @@ impl<'b, 'a: 'b, 'tcx: 'a> MirBorrowckCtxt<'b, 'a, 'tcx> {\n         debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?})\", bb, term);\n     }\n }\n+\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+enum DropFlagState {\n+    Live,\n+    Dead\n+}\n+\n+fn on_all_children_bits<'a, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    move_data: &MoveData<'tcx>,\n+    move_path_index: MovePathIndex,\n+    mut each_child: F)\n+    where F: FnMut(MovePathIndex)\n+{\n+    fn is_terminal_path<'a, 'tcx>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        move_data: &MoveData<'tcx>,\n+        path: MovePathIndex) -> bool\n+    {\n+        match move_data.move_paths[path].content {\n+            MovePathContent::Lvalue(ref lvalue) => {\n+                match mir.lvalue_ty(tcx, lvalue).to_ty(tcx).sty {\n+                    // don't trace paths past arrays, slices, and\n+                    // pointers. They can only be accessed while\n+                    // their parents are initialized.\n+                    //\n+                    // FIXME: we have to do something for moving\n+                    // slice patterns.\n+                    ty::TyArray(..) | ty::TySlice(..) |\n+                    ty::TyRef(..) | ty::TyRawPtr(..) => true,\n+                    _ => false\n+                }\n+            }\n+            _ => true\n+        }\n+    }\n+\n+    fn on_all_children_bits<'a, 'tcx, F>(\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        move_data: &MoveData<'tcx>,\n+        move_path_index: MovePathIndex,\n+        each_child: &mut F)\n+        where F: FnMut(MovePathIndex)\n+    {\n+        each_child(move_path_index);\n+\n+        if is_terminal_path(tcx, mir, move_data, move_path_index) {\n+            return\n+        }\n+\n+        let mut next_child_index = move_data.move_paths[move_path_index].first_child;\n+        while let Some(child_index) = next_child_index {\n+            on_all_children_bits(tcx, mir, move_data, child_index, each_child);\n+            next_child_index = move_data.move_paths[child_index].next_sibling;\n+        }\n+    }\n+    on_all_children_bits(tcx, mir, move_data, move_path_index, &mut each_child);\n+}\n+\n+fn drop_flag_effects_for_function_entry<'a, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    move_data: &MoveData<'tcx>,\n+    mut callback: F)\n+    where F: FnMut(MovePathIndex, DropFlagState)\n+{\n+    for i in 0..(mir.arg_decls.len() as u32) {\n+        let lvalue = repr::Lvalue::Arg(i);\n+        let move_path_index = move_data.rev_lookup.find(&lvalue);\n+        on_all_children_bits(tcx, mir, move_data,\n+                             move_path_index,\n+                             |moi| callback(moi, DropFlagState::Live));\n+    }\n+}\n+\n+fn drop_flag_effects_for_location<'a, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    move_data: &MoveData<'tcx>,\n+    loc: Location,\n+    mut callback: F)\n+    where F: FnMut(MovePathIndex, DropFlagState)\n+{\n+    debug!(\"drop_flag_effects_for_location({:?})\", loc);\n+\n+    // first, move out of the RHS\n+    for mi in &move_data.loc_map[loc] {\n+        let path = mi.move_path_index(move_data);\n+        debug!(\"moving out of path {:?}\", move_data.move_paths[path]);\n+\n+        // don't move out of non-Copy things\n+        if let MovePathContent::Lvalue(ref lvalue) = move_data.move_paths[path].content {\n+            let ty = mir.lvalue_ty(tcx, lvalue).to_ty(tcx);\n+            let empty_param_env = tcx.empty_parameter_environment();\n+            if !ty.moves_by_default(tcx, &empty_param_env, DUMMY_SP) {\n+                continue;\n+            }\n+        }\n+\n+        on_all_children_bits(tcx, mir, move_data,\n+                             path,\n+                             |moi| callback(moi, DropFlagState::Dead))\n+    }\n+\n+    let bb = mir.basic_block_data(loc.block);\n+    match bb.statements.get(loc.index) {\n+        Some(stmt) => match stmt.kind {\n+            repr::StatementKind::Assign(ref lvalue, _) => {\n+                debug!(\"drop_flag_effects: assignment {:?}\", stmt);\n+                on_all_children_bits(tcx, mir, move_data,\n+                                     move_data.rev_lookup.find(lvalue),\n+                                     |moi| callback(moi, DropFlagState::Live))\n+            }\n+        },\n+        None => {\n+            // terminator - no move-ins except for function return edge\n+            let term = bb.terminator();\n+            debug!(\"drop_flag_effects: terminator {:?}\", term);\n+        }\n+    }\n+}"}]}