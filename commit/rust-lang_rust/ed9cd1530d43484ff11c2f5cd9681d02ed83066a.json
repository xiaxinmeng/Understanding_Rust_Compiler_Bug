{"sha": "ed9cd1530d43484ff11c2f5cd9681d02ed83066a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkOWNkMTUzMGQ0MzQ4NGZmMTFjMmY1Y2Q5NjgxZDAyZWQ4MzA2NmE=", "commit": {"author": {"name": "Josh Holmer", "email": "jholmer.in@gmail.com", "date": "2018-09-04T03:58:10Z"}, "committer": {"name": "Josh Holmer", "email": "jholmer.in@gmail.com", "date": "2018-09-04T03:58:10Z"}, "message": "More if_chain", "tree": {"sha": "cd3b4a1be22f58454eb7e84e1062393df98ff157", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd3b4a1be22f58454eb7e84e1062393df98ff157"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed9cd1530d43484ff11c2f5cd9681d02ed83066a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed9cd1530d43484ff11c2f5cd9681d02ed83066a", "html_url": "https://github.com/rust-lang/rust/commit/ed9cd1530d43484ff11c2f5cd9681d02ed83066a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed9cd1530d43484ff11c2f5cd9681d02ed83066a/comments", "author": {"login": "shssoichiro", "id": 5951392, "node_id": "MDQ6VXNlcjU5NTEzOTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5951392?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shssoichiro", "html_url": "https://github.com/shssoichiro", "followers_url": "https://api.github.com/users/shssoichiro/followers", "following_url": "https://api.github.com/users/shssoichiro/following{/other_user}", "gists_url": "https://api.github.com/users/shssoichiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/shssoichiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shssoichiro/subscriptions", "organizations_url": "https://api.github.com/users/shssoichiro/orgs", "repos_url": "https://api.github.com/users/shssoichiro/repos", "events_url": "https://api.github.com/users/shssoichiro/events{/privacy}", "received_events_url": "https://api.github.com/users/shssoichiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "shssoichiro", "id": 5951392, "node_id": "MDQ6VXNlcjU5NTEzOTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5951392?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shssoichiro", "html_url": "https://github.com/shssoichiro", "followers_url": "https://api.github.com/users/shssoichiro/followers", "following_url": "https://api.github.com/users/shssoichiro/following{/other_user}", "gists_url": "https://api.github.com/users/shssoichiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/shssoichiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shssoichiro/subscriptions", "organizations_url": "https://api.github.com/users/shssoichiro/orgs", "repos_url": "https://api.github.com/users/shssoichiro/repos", "events_url": "https://api.github.com/users/shssoichiro/events{/privacy}", "received_events_url": "https://api.github.com/users/shssoichiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48e6be42d7827210107f363e60dd86125c7b385e", "url": "https://api.github.com/repos/rust-lang/rust/commits/48e6be42d7827210107f363e60dd86125c7b385e", "html_url": "https://github.com/rust-lang/rust/commit/48e6be42d7827210107f363e60dd86125c7b385e"}], "stats": {"total": 98, "additions": 48, "deletions": 50}, "files": [{"sha": "8a12530cb0d2591636f2490923d6d76c1cae190b", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ed9cd1530d43484ff11c2f5cd9681d02ed83066a/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed9cd1530d43484ff11c2f5cd9681d02ed83066a/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=ed9cd1530d43484ff11c2f5cd9681d02ed83066a", "patch": "@@ -2271,56 +2271,54 @@ impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>) {\n-    if let ExprKind::MethodCall(ref method, _, ref args) = expr.node {\n-        if let ExprKind::MethodCall(ref chain_method, _, _) = args[0].node {\n-            if chain_method.ident.name == \"collect\" &&\n-                match_trait_method(cx, &args[0], &paths::ITERATOR) &&\n-                chain_method.args.is_some() {\n-                let generic_args = chain_method.args.as_ref().unwrap();\n-                if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0) {\n-                    let ty = cx.tables.node_id_to_type(ty.hir_id);\n-                    if match_type(cx, ty, &paths::VEC) ||\n-                        match_type(cx, ty, &paths::VEC_DEQUE) ||\n-                        match_type(cx, ty, &paths::BTREEMAP) ||\n-                        match_type(cx, ty, &paths::HASHMAP) {\n-                        if method.ident.name == \"len\" {\n-                            let span = shorten_needless_collect_span(expr);\n-                            span_lint_and_then(cx, NEEDLESS_COLLECT, span, NEEDLESS_COLLECT_MSG, |db| {\n-                                db.span_suggestion_with_applicability(\n-                                    span,\n-                                    \"replace with\",\n-                                    \".count()\".to_string(),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            });\n-                        }\n-                        if method.ident.name == \"is_empty\" {\n-                            let span = shorten_needless_collect_span(expr);\n-                            span_lint_and_then(cx, NEEDLESS_COLLECT, span, NEEDLESS_COLLECT_MSG, |db| {\n-                                db.span_suggestion_with_applicability(\n-                                    span,\n-                                    \"replace with\",\n-                                    \".next().is_none()\".to_string(),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            });\n-                        }\n-                        if method.ident.name == \"contains\" {\n-                            let contains_arg = snippet(cx, args[1].span, \"??\");\n-                            let span = shorten_needless_collect_span(expr);\n-                            span_lint_and_then(cx, NEEDLESS_COLLECT, span, NEEDLESS_COLLECT_MSG, |db| {\n-                                db.span_suggestion_with_applicability(\n-                                    span,\n-                                    \"replace with\",\n-                                    format!(\n-                                        \".any(|&x| x == {})\",\n-                                        if contains_arg.starts_with('&') { &contains_arg[1..] } else { &contains_arg }\n-                                    ),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            });\n-                        }\n-                    }\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method, _, ref args) = expr.node;\n+        if let ExprKind::MethodCall(ref chain_method, _, _) = args[0].node;\n+        if chain_method.ident.name == \"collect\" && match_trait_method(cx, &args[0], &paths::ITERATOR);\n+        if let Some(ref generic_args) = chain_method.args;\n+        if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n+        then {\n+            let ty = cx.tables.node_id_to_type(ty.hir_id);\n+            if match_type(cx, ty, &paths::VEC) ||\n+                match_type(cx, ty, &paths::VEC_DEQUE) ||\n+                match_type(cx, ty, &paths::BTREEMAP) ||\n+                match_type(cx, ty, &paths::HASHMAP) {\n+                if method.ident.name == \"len\" {\n+                    let span = shorten_needless_collect_span(expr);\n+                    span_lint_and_then(cx, NEEDLESS_COLLECT, span, NEEDLESS_COLLECT_MSG, |db| {\n+                        db.span_suggestion_with_applicability(\n+                            span,\n+                            \"replace with\",\n+                            \".count()\".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    });\n+                }\n+                if method.ident.name == \"is_empty\" {\n+                    let span = shorten_needless_collect_span(expr);\n+                    span_lint_and_then(cx, NEEDLESS_COLLECT, span, NEEDLESS_COLLECT_MSG, |db| {\n+                        db.span_suggestion_with_applicability(\n+                            span,\n+                            \"replace with\",\n+                            \".next().is_none()\".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    });\n+                }\n+                if method.ident.name == \"contains\" {\n+                    let contains_arg = snippet(cx, args[1].span, \"??\");\n+                    let span = shorten_needless_collect_span(expr);\n+                    span_lint_and_then(cx, NEEDLESS_COLLECT, span, NEEDLESS_COLLECT_MSG, |db| {\n+                        db.span_suggestion_with_applicability(\n+                            span,\n+                            \"replace with\",\n+                            format!(\n+                                \".any(|&x| x == {})\",\n+                                if contains_arg.starts_with('&') { &contains_arg[1..] } else { &contains_arg }\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    });\n                 }\n             }\n         }"}]}