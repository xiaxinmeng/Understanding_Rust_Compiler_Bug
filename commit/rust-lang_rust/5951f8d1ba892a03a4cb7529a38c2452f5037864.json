{"sha": "5951f8d1ba892a03a4cb7529a38c2452f5037864", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NTFmOGQxYmE4OTJhMDNhNGNiNzUyOWEzOGMyNDUyZjUwMzc4NjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-12T00:52:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-12T00:52:20Z"}, "message": "Auto merge of #46657 - nikomatsakis:resolve-lifetimes-query, r=arielb1\n\nmove `resolve_lifetimes` into a proper query\n\nNow that we made `resolve_lifetimes` into a query, elision errors no\nlonger abort compilation, which affects some tests.\n\nAlso, remove `dep_graph_crosscontaminate_tables` -- there is no a path in\nthe dep-graph, though red-green handles it. The same scenario\nis (correctly) tested by issue-42602.rs in any case.\n\nr? @michaelwoerister", "tree": {"sha": "58f6b0d8bcf3efebc6a2300ba08761955ca6fcfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58f6b0d8bcf3efebc6a2300ba08761955ca6fcfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5951f8d1ba892a03a4cb7529a38c2452f5037864", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5951f8d1ba892a03a4cb7529a38c2452f5037864", "html_url": "https://github.com/rust-lang/rust/commit/5951f8d1ba892a03a4cb7529a38c2452f5037864", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5951f8d1ba892a03a4cb7529a38c2452f5037864/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fe7aa353fac5084d0a44d6a15970310e9be67f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fe7aa353fac5084d0a44d6a15970310e9be67f4", "html_url": "https://github.com/rust-lang/rust/commit/9fe7aa353fac5084d0a44d6a15970310e9be67f4"}, {"sha": "fdbd9b0dd5cd6cec755bb7bfe688d78cab3d3e83", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdbd9b0dd5cd6cec755bb7bfe688d78cab3d3e83", "html_url": "https://github.com/rust-lang/rust/commit/fdbd9b0dd5cd6cec755bb7bfe688d78cab3d3e83"}], "stats": {"total": 1584, "additions": 937, "deletions": 647}, "files": [{"sha": "06b745dbaaf1ca459723b3302960646cb949506b", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -588,9 +588,10 @@ define_dep_nodes!( <'tcx>\n     [] NativeLibraryKind(DefId),\n     [input] LinkArgs,\n \n-    [input] NamedRegion(DefIndex),\n-    [input] IsLateBound(DefIndex),\n-    [input] ObjectLifetimeDefaults(DefIndex),\n+    [] ResolveLifetimes(CrateNum),\n+    [] NamedRegion(DefIndex),\n+    [] IsLateBound(DefIndex),\n+    [] ObjectLifetimeDefaults(DefIndex),\n \n     [] Visibility(DefId),\n     [] DepKind(CrateNum),"}, {"sha": "d6107a8f55197320f1845a3638d67ffd37407009", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -28,7 +28,7 @@ pub use self::UnsafeSource::*;\n pub use self::Visibility::{Public, Inherited};\n \n use hir::def::Def;\n-use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n use util::nodemap::{NodeMap, FxHashSet};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -92,6 +92,16 @@ pub struct HirId {\n     pub local_id: ItemLocalId,\n }\n \n+impl HirId {\n+    pub fn owner_def_id(self) -> DefId {\n+        DefId::local(self.owner)\n+    }\n+\n+    pub fn owner_local_def_id(self) -> LocalDefId {\n+        LocalDefId::from_def_id(DefId::local(self.owner))\n+    }\n+}\n+\n impl serialize::UseSpecializedEncodable for HirId {\n     fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         let HirId {"}, {"sha": "bafd1e8e6cc5d5bddc1b4eb3c7a9cd148360a7c9", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 860, "deletions": 540, "changes": 1400, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -17,24 +17,23 @@\n \n use hir::map::Map;\n use hir::def::Def;\n-use hir::def_id::DefId;\n-use middle::cstore::CrateStore;\n-use session::Session;\n-use ty;\n+use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n+use hir::ItemLocalId;\n+use ty::{self, TyCtxt};\n \n use std::cell::Cell;\n use std::mem::replace;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::attr;\n use syntax::ptr::P;\n use syntax_pos::Span;\n use errors::DiagnosticBuilder;\n-use util::common::ErrorReported;\n-use util::nodemap::{NodeMap, NodeSet, FxHashSet, FxHashMap, DefIdMap};\n+use util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n use std::slice;\n \n use hir;\n-use hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use hir::intravisit::{self, NestedVisitorMap, Visitor};\n \n /// The origin of a named lifetime definition.\n ///\n@@ -60,16 +59,26 @@ impl LifetimeDefOrigin {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum Region {\n     Static,\n-    EarlyBound(/* index */ u32, /* lifetime decl */ DefId, LifetimeDefOrigin),\n-    LateBound(ty::DebruijnIndex, /* lifetime decl */ DefId, LifetimeDefOrigin),\n+    EarlyBound(\n+        /* index */ u32,\n+        /* lifetime decl */ DefId,\n+        LifetimeDefOrigin,\n+    ),\n+    LateBound(\n+        ty::DebruijnIndex,\n+        /* lifetime decl */ DefId,\n+        LifetimeDefOrigin,\n+    ),\n     LateBoundAnon(ty::DebruijnIndex, /* anon index */ u32),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n \n impl Region {\n-    fn early(hir_map: &Map, index: &mut u32, def: &hir::LifetimeDef)\n-        -> (hir::LifetimeName, Region)\n-    {\n+    fn early(\n+        hir_map: &Map,\n+        index: &mut u32,\n+        def: &hir::LifetimeDef,\n+    ) -> (hir::LifetimeName, Region) {\n         let i = *index;\n         *index += 1;\n         let def_id = hir_map.local_def_id(def.lifetime.id);\n@@ -94,12 +103,11 @@ impl Region {\n \n     fn id(&self) -> Option<DefId> {\n         match *self {\n-            Region::Static |\n-            Region::LateBoundAnon(..) => None,\n+            Region::Static | Region::LateBoundAnon(..) => None,\n \n-            Region::EarlyBound(_, id, _) |\n-            Region::LateBound(_, id, _) |\n-            Region::Free(_, id) => Some(id)\n+            Region::EarlyBound(_, id, _) | Region::LateBound(_, id, _) | Region::Free(_, id) => {\n+                Some(id)\n+            }\n         }\n     }\n \n@@ -111,32 +119,34 @@ impl Region {\n             Region::LateBoundAnon(depth, index) => {\n                 Region::LateBoundAnon(depth.shifted(amount), index)\n             }\n-            _ => self\n+            _ => self,\n         }\n     }\n \n     fn from_depth(self, depth: u32) -> Region {\n         match self {\n-            Region::LateBound(debruijn, id, origin) => {\n-                Region::LateBound(ty::DebruijnIndex {\n-                    depth: debruijn.depth - (depth - 1)\n-                }, id, origin)\n-            }\n-            Region::LateBoundAnon(debruijn, index) => {\n-                Region::LateBoundAnon(ty::DebruijnIndex {\n-                    depth: debruijn.depth - (depth - 1)\n-                }, index)\n-            }\n-            _ => self\n+            Region::LateBound(debruijn, id, origin) => Region::LateBound(\n+                ty::DebruijnIndex {\n+                    depth: debruijn.depth - (depth - 1),\n+                },\n+                id,\n+                origin,\n+            ),\n+            Region::LateBoundAnon(debruijn, index) => Region::LateBoundAnon(\n+                ty::DebruijnIndex {\n+                    depth: debruijn.depth - (depth - 1),\n+                },\n+                index,\n+            ),\n+            _ => self,\n         }\n     }\n \n-    fn subst(self, params: &[hir::Lifetime], map: &NamedRegionMap)\n-             -> Option<Region> {\n+    fn subst(self, params: &[hir::Lifetime], map: &NamedRegionMap) -> Option<Region> {\n         if let Region::EarlyBound(index, _, _) = self {\n-            params.get(index as usize).and_then(|lifetime| {\n-                map.defs.get(&lifetime.id).cloned()\n-            })\n+            params\n+                .get(index as usize)\n+                .and_then(|lifetime| map.defs.get(&lifetime.id).cloned())\n         } else {\n             Some(self)\n         }\n@@ -150,7 +160,7 @@ impl Region {\n pub enum Set1<T> {\n     Empty,\n     One(T),\n-    Many\n+    Many,\n }\n \n impl<T: PartialEq> Set1<T> {\n@@ -170,9 +180,14 @@ impl<T: PartialEq> Set1<T> {\n \n pub type ObjectLifetimeDefault = Set1<Region>;\n \n-// Maps the id of each lifetime reference to the lifetime decl\n-// that it corresponds to.\n-pub struct NamedRegionMap {\n+/// Maps the id of each lifetime reference to the lifetime decl\n+/// that it corresponds to.\n+///\n+/// FIXME. This struct gets converted to a `ResolveLifetimes` for\n+/// actual use. It has the same data, but indexed by `DefIndex`.  This\n+/// is silly.\n+#[derive(Default)]\n+struct NamedRegionMap {\n     // maps from every use of a named (not anonymous) lifetime to a\n     // `Region` describing how that region is bound\n     pub defs: NodeMap<Region>,\n@@ -187,10 +202,22 @@ pub struct NamedRegionMap {\n     pub object_lifetime_defaults: NodeMap<Vec<ObjectLifetimeDefault>>,\n }\n \n+/// See `NamedRegionMap`.\n+pub struct ResolveLifetimes {\n+    defs: FxHashMap<LocalDefId, Rc<FxHashMap<ItemLocalId, Region>>>,\n+    late_bound: FxHashMap<LocalDefId, Rc<FxHashSet<ItemLocalId>>>,\n+    object_lifetime_defaults:\n+        FxHashMap<LocalDefId, Rc<FxHashMap<ItemLocalId, Rc<Vec<ObjectLifetimeDefault>>>>>,\n+}\n+\n+impl_stable_hash_for!(struct ::middle::resolve_lifetime::ResolveLifetimes {\n+    defs,\n+    late_bound,\n+    object_lifetime_defaults\n+});\n+\n struct LifetimeContext<'a, 'tcx: 'a> {\n-    sess: &'a Session,\n-    cstore: &'a CrateStore,\n-    hir_map: &'a Map<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n     // Deep breath. Our representation for poly trait refs contains a single\n@@ -233,7 +260,7 @@ enum Scope<'a> {\n         /// we should use for an early-bound region?\n         next_early_index: u32,\n \n-        s: ScopeRef<'a>\n+        s: ScopeRef<'a>,\n     },\n \n     /// Lifetimes introduced by a fn are scoped to the call-site for that fn,\n@@ -242,25 +269,25 @@ enum Scope<'a> {\n     /// e.g. `(&T, fn(&T) -> &T);` becomes `(&'_ T, for<'a> fn(&'a T) -> &'a T)`.\n     Body {\n         id: hir::BodyId,\n-        s: ScopeRef<'a>\n+        s: ScopeRef<'a>,\n     },\n \n     /// A scope which either determines unspecified lifetimes or errors\n     /// on them (e.g. due to ambiguity). For more details, see `Elide`.\n     Elision {\n         elide: Elide,\n-        s: ScopeRef<'a>\n+        s: ScopeRef<'a>,\n     },\n \n     /// Use a specific lifetime (if `Some`) or leave it unset (to be\n     /// inferred in a function body or potentially error outside one),\n     /// for the default choice of lifetime in a trait object type.\n     ObjectLifetimeDefault {\n         lifetime: Option<Region>,\n-        s: ScopeRef<'a>\n+        s: ScopeRef<'a>,\n     },\n \n-    Root\n+    Root,\n }\n \n #[derive(Clone, Debug)]\n@@ -271,7 +298,7 @@ enum Elide {\n     /// Always use this one lifetime.\n     Exact(Region),\n     /// Less or more than one lifetime were found, error on unspecified.\n-    Error(Vec<ElisionFailureInfo>)\n+    Error(Vec<ElisionFailureInfo>),\n }\n \n #[derive(Clone, Debug)]\n@@ -281,28 +308,99 @@ struct ElisionFailureInfo {\n     /// The index of the argument in the original definition.\n     index: usize,\n     lifetime_count: usize,\n-    have_bound_regions: bool\n+    have_bound_regions: bool,\n }\n \n type ScopeRef<'a> = &'a Scope<'a>;\n \n const ROOT_SCOPE: ScopeRef<'static> = &Scope::Root;\n \n-pub fn krate(sess: &Session,\n-             cstore: &CrateStore,\n-             hir_map: &Map)\n-             -> Result<NamedRegionMap, ErrorReported> {\n-    let krate = hir_map.krate();\n+pub fn provide(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        resolve_lifetimes,\n+\n+        named_region_map: |tcx, id| {\n+            let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n+            tcx.resolve_lifetimes(LOCAL_CRATE).defs.get(&id).cloned()\n+        },\n+\n+        is_late_bound_map: |tcx, id| {\n+            let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n+            tcx.resolve_lifetimes(LOCAL_CRATE)\n+                .late_bound\n+                .get(&id)\n+                .cloned()\n+        },\n+\n+        object_lifetime_defaults_map: |tcx, id| {\n+            let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n+            tcx.resolve_lifetimes(LOCAL_CRATE)\n+                .object_lifetime_defaults\n+                .get(&id)\n+                .cloned()\n+        },\n+\n+        ..*providers\n+    };\n+\n+    // (*) FIXME the query should be defined to take a LocalDefId\n+}\n+\n+/// Computes the `ResolveLifetimes` map that contains data for the\n+/// entire crate. You should not read the result of this query\n+/// directly, but rather use `named_region_map`, `is_late_bound_map`,\n+/// etc.\n+fn resolve_lifetimes<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    for_krate: CrateNum,\n+) -> Rc<ResolveLifetimes> {\n+    assert_eq!(for_krate, LOCAL_CRATE);\n+\n+    let named_region_map = krate(tcx);\n+\n+    let mut defs = FxHashMap();\n+    for (k, v) in named_region_map.defs {\n+        let hir_id = tcx.hir.node_to_hir_id(k);\n+        let map = defs.entry(hir_id.owner_local_def_id())\n+            .or_insert_with(|| Rc::new(FxHashMap()));\n+        Rc::get_mut(map).unwrap().insert(hir_id.local_id, v);\n+    }\n+    let mut late_bound = FxHashMap();\n+    for k in named_region_map.late_bound {\n+        let hir_id = tcx.hir.node_to_hir_id(k);\n+        let map = late_bound\n+            .entry(hir_id.owner_local_def_id())\n+            .or_insert_with(|| Rc::new(FxHashSet()));\n+        Rc::get_mut(map).unwrap().insert(hir_id.local_id);\n+    }\n+    let mut object_lifetime_defaults = FxHashMap();\n+    for (k, v) in named_region_map.object_lifetime_defaults {\n+        let hir_id = tcx.hir.node_to_hir_id(k);\n+        let map = object_lifetime_defaults\n+            .entry(hir_id.owner_local_def_id())\n+            .or_insert_with(|| Rc::new(FxHashMap()));\n+        Rc::get_mut(map)\n+            .unwrap()\n+            .insert(hir_id.local_id, Rc::new(v));\n+    }\n+\n+    Rc::new(ResolveLifetimes {\n+        defs,\n+        late_bound,\n+        object_lifetime_defaults,\n+    })\n+}\n+\n+fn krate<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>) -> NamedRegionMap {\n+    let krate = tcx.hir.krate();\n     let mut map = NamedRegionMap {\n         defs: NodeMap(),\n         late_bound: NodeSet(),\n-        object_lifetime_defaults: compute_object_lifetime_defaults(sess, hir_map),\n+        object_lifetime_defaults: compute_object_lifetime_defaults(tcx),\n     };\n-    sess.track_errors(|| {\n+    {\n         let mut visitor = LifetimeContext {\n-            sess,\n-            cstore,\n-            hir_map,\n+            tcx,\n             map: &mut map,\n             scope: ROOT_SCOPE,\n             trait_ref_hack: false,\n@@ -313,13 +411,13 @@ pub fn krate(sess: &Session,\n         for (_, item) in &krate.items {\n             visitor.visit_item(item);\n         }\n-    })?;\n-    Ok(map)\n+    }\n+    map\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(self.hir_map)\n+        NestedVisitorMap::All(&self.tcx.hir)\n     }\n \n     // We want to nest trait/impl items in their parent, but nothing else.\n@@ -328,11 +426,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n         // Each body has their own set of labels, save labels.\n         let saved = replace(&mut self.labels_in_fn, vec![]);\n-        let body = self.hir_map.body(body);\n+        let body = self.tcx.hir.body(body);\n         extract_labels(self, body);\n-        self.with(Scope::Body { id: body.id(), s: self.scope }, |_, this| {\n-            this.visit_body(body);\n-        });\n+        self.with(\n+            Scope::Body {\n+                id: body.id(),\n+                s: self.scope,\n+            },\n+            |_, this| {\n+                this.visit_body(body);\n+            },\n+        );\n         replace(&mut self.labels_in_fn, saved);\n     }\n \n@@ -343,44 +447,45 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_item(this, item);\n                 });\n             }\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemAutoImpl(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemGlobalAsm(..) => {\n+            hir::ItemExternCrate(_)\n+            | hir::ItemUse(..)\n+            | hir::ItemMod(..)\n+            | hir::ItemAutoImpl(..)\n+            | hir::ItemForeignMod(..)\n+            | hir::ItemGlobalAsm(..) => {\n                 // These sorts of items have no lifetime parameters at all.\n                 intravisit::walk_item(self, item);\n             }\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) => {\n+            hir::ItemStatic(..) | hir::ItemConst(..) => {\n                 // No lifetime parameters, but implied 'static.\n                 let scope = Scope::Elision {\n                     elide: Elide::Exact(Region::Static),\n-                    s: ROOT_SCOPE\n+                    s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |_, this| intravisit::walk_item(this, item));\n             }\n-            hir::ItemTy(_, ref generics) |\n-            hir::ItemEnum(_, ref generics) |\n-            hir::ItemStruct(_, ref generics) |\n-            hir::ItemUnion(_, ref generics) |\n-            hir::ItemTrait(_, _, ref generics, ..) |\n-            hir::ItemImpl(_, _, _, ref generics, ..) => {\n+            hir::ItemTy(_, ref generics)\n+            | hir::ItemEnum(_, ref generics)\n+            | hir::ItemStruct(_, ref generics)\n+            | hir::ItemUnion(_, ref generics)\n+            | hir::ItemTrait(_, _, ref generics, ..)\n+            | hir::ItemImpl(_, _, _, ref generics, ..) => {\n                 // These kinds of items have only early bound lifetime parameters.\n                 let mut index = if let hir::ItemTrait(..) = item.node {\n                     1 // Self comes before lifetimes\n                 } else {\n                     0\n                 };\n-                let lifetimes = generics.lifetimes.iter().map(|def| {\n-                    Region::early(self.hir_map, &mut index, def)\n-                }).collect();\n+                let lifetimes = generics\n+                    .lifetimes\n+                    .iter()\n+                    .map(|def| Region::early(&self.tcx.hir, &mut index, def))\n+                    .collect();\n                 let next_early_index = index + generics.ty_params.len() as u32;\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index,\n-                    s: ROOT_SCOPE\n+                    s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_defs(old_scope, &generics.lifetimes);\n@@ -414,11 +519,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let was_in_fn_syntax = self.is_in_fn_syntax;\n                 self.is_in_fn_syntax = true;\n                 let scope = Scope::Binder {\n-                    lifetimes: c.lifetimes.iter().map(|def| {\n-                        Region::late(self.hir_map, def)\n-                    }).collect(),\n+                    lifetimes: c.lifetimes\n+                        .iter()\n+                        .map(|def| Region::late(&self.tcx.hir, def))\n+                        .collect(),\n+                    s: self.scope,\n                     next_early_index,\n-                    s: self.scope\n                 };\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -442,7 +548,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.visit_lifetime(lifetime_ref);\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: self.map.defs.get(&lifetime_ref.id).cloned(),\n-                    s: self.scope\n+                    s: self.scope,\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n             }\n@@ -461,19 +567,23 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     // In the future, this should be fixed and this error should be removed.\n                     let def = self.map.defs.get(&lifetime.id);\n                     if let Some(&Region::LateBound(_, def_id, _)) = def {\n-                        if let Some(node_id) = self.hir_map.as_local_node_id(def_id) {\n+                        if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                             // Ensure that the parent of the def is an item, not HRTB\n-                            let parent_id = self.hir_map.get_parent_node(node_id);\n+                            let parent_id = self.tcx.hir.get_parent_node(node_id);\n                             let parent_impl_id = hir::ImplItemId { node_id: parent_id };\n                             let parent_trait_id = hir::TraitItemId { node_id: parent_id };\n-                            let krate = self.hir_map.forest.krate();\n-                            if !(krate.items.contains_key(&parent_id) ||\n-                                 krate.impl_items.contains_key(&parent_impl_id) ||\n-                                 krate.trait_items.contains_key(&parent_trait_id))\n+                            let krate = self.tcx.hir.forest.krate();\n+                            if !(krate.items.contains_key(&parent_id)\n+                                || krate.impl_items.contains_key(&parent_impl_id)\n+                                || krate.trait_items.contains_key(&parent_trait_id))\n                             {\n-                                span_err!(self.sess, lifetime.span, E0657,\n-                                  \"`impl Trait` can only capture lifetimes \\\n-                                  bound at the fn or impl level\");\n+                                span_err!(\n+                                    self.tcx.sess,\n+                                    lifetime.span,\n+                                    E0657,\n+                                    \"`impl Trait` can only capture lifetimes \\\n+                                     bound at the fn or impl level\"\n+                                );\n                             }\n                         }\n                     }\n@@ -484,45 +594,58 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n                 //                          ^            ^ this gets resolved in the scope of\n                 //                                         the exist_ty generics\n-                let hir::ExistTy { ref generics, ref bounds } = *exist_ty;\n+                let hir::ExistTy {\n+                    ref generics,\n+                    ref bounds,\n+                } = *exist_ty;\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.lifetimes.iter()\n-                    .map(|lt_def| Region::early(self.hir_map, &mut index, lt_def))\n+                let lifetimes = generics\n+                    .lifetimes\n+                    .iter()\n+                    .map(|lt_def| Region::early(&self.tcx.hir, &mut index, lt_def))\n                     .collect();\n \n                 let next_early_index = index + generics.ty_params.len() as u32;\n-                let scope = Scope::Binder { lifetimes, next_early_index, s: self.scope };\n+                let scope = Scope::Binder {\n+                    lifetimes,\n+                    next_early_index,\n+                    s: self.scope,\n+                };\n                 self.with(scope, |_old_scope, this| {\n                     this.visit_generics(generics);\n                     for bound in bounds {\n                         this.visit_ty_param_bound(bound);\n                     }\n                 });\n             }\n-            _ => {\n-                intravisit::walk_ty(self, ty)\n-            }\n+            _ => intravisit::walk_ty(self, ty),\n         }\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n+        let tcx = self.tcx;\n         if let hir::TraitItemKind::Method(ref sig, _) = trait_item.node {\n             self.visit_early_late(\n-                Some(self.hir_map.get_parent(trait_item.id)),\n-                &sig.decl, &trait_item.generics,\n-                |this| intravisit::walk_trait_item(this, trait_item))\n+                Some(tcx.hir.get_parent(trait_item.id)),\n+                &sig.decl,\n+                &trait_item.generics,\n+                |this| intravisit::walk_trait_item(this, trait_item),\n+            )\n         } else {\n             intravisit::walk_trait_item(self, trait_item);\n         }\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        let tcx = self.tcx;\n         if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n             self.visit_early_late(\n-                Some(self.hir_map.get_parent(impl_item.id)),\n-                &sig.decl, &impl_item.generics,\n-                |this| intravisit::walk_impl_item(this, impl_item))\n+                Some(tcx.hir.get_parent(impl_item.id)),\n+                &sig.decl,\n+                &impl_item.generics,\n+                |this| intravisit::walk_impl_item(this, impl_item),\n+            )\n         } else {\n             intravisit::walk_impl_item(self, impl_item);\n         }\n@@ -552,13 +675,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_fn_decl(&mut self, fd: &'tcx hir::FnDecl) {\n         let output = match fd.output {\n             hir::DefaultReturn(_) => None,\n-            hir::Return(ref ty) => Some(ty)\n+            hir::Return(ref ty) => Some(ty),\n         };\n         self.visit_fn_like_elision(&fd.inputs, output);\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        check_mixed_explicit_and_in_band_defs(&self.sess, &generics.lifetimes);\n+        check_mixed_explicit_and_in_band_defs(self.tcx, &generics.lifetimes);\n         for ty_param in generics.ty_params.iter() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n             if let Some(ref ty) = ty_param.default {\n@@ -567,19 +690,22 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n-                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{ ref bounded_ty,\n-                                                                               ref bounds,\n-                                                                               ref bound_lifetimes,\n-                                                                               .. }) => {\n+                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                    ref bounded_ty,\n+                    ref bounds,\n+                    ref bound_lifetimes,\n+                    ..\n+                }) => {\n                     if !bound_lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n                         let next_early_index = self.next_early_index();\n                         let scope = Scope::Binder {\n-                            lifetimes: bound_lifetimes.iter().map(|def| {\n-                                    Region::late(self.hir_map, def)\n-                            }).collect(),\n+                            lifetimes: bound_lifetimes\n+                                .iter()\n+                                .map(|def| Region::late(&self.tcx.hir, def))\n+                                .collect(),\n+                            s: self.scope,\n                             next_early_index,\n-                            s: self.scope\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_defs(old_scope, bound_lifetimes);\n@@ -593,42 +719,53 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         walk_list!(self, visit_ty_param_bound, bounds);\n                     }\n                 }\n-                &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,\n-                                                                                ref bounds,\n-                                                                                .. }) => {\n-\n+                &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                    ref lifetime,\n+                    ref bounds,\n+                    ..\n+                }) => {\n                     self.visit_lifetime(lifetime);\n                     for bound in bounds {\n                         self.visit_lifetime(bound);\n                     }\n                 }\n-                &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ref lhs_ty,\n-                                                                        ref rhs_ty,\n-                                                                        .. }) => {\n+                &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n+                    ref lhs_ty,\n+                    ref rhs_ty,\n+                    ..\n+                }) => {\n                     self.visit_ty(lhs_ty);\n                     self.visit_ty(rhs_ty);\n                 }\n             }\n         }\n     }\n \n-    fn visit_poly_trait_ref(&mut self,\n-                            trait_ref: &'tcx hir::PolyTraitRef,\n-                            _modifier: hir::TraitBoundModifier) {\n+    fn visit_poly_trait_ref(\n+        &mut self,\n+        trait_ref: &'tcx hir::PolyTraitRef,\n+        _modifier: hir::TraitBoundModifier,\n+    ) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n         if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n             if self.trait_ref_hack {\n-                span_err!(self.sess, trait_ref.span, E0316,\n-                          \"nested quantification of lifetimes\");\n+                span_err!(\n+                    self.tcx.sess,\n+                    trait_ref.span,\n+                    E0316,\n+                    \"nested quantification of lifetimes\"\n+                );\n             }\n             let next_early_index = self.next_early_index();\n             let scope = Scope::Binder {\n-                lifetimes: trait_ref.bound_lifetimes.iter().map(|def| {\n-                        Region::late(self.hir_map, def)\n-                }).collect(),\n+                lifetimes: trait_ref\n+                    .bound_lifetimes\n+                    .iter()\n+                    .map(|def| Region::late(&self.tcx.hir, def))\n+                    .collect(),\n+                s: self.scope,\n                 next_early_index,\n-                s: self.scope\n             };\n             self.with(scope, |old_scope, this| {\n                 this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n@@ -644,21 +781,42 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-enum ShadowKind { Label, Lifetime }\n-struct Original { kind: ShadowKind, span: Span }\n-struct Shadower { kind: ShadowKind, span: Span }\n+enum ShadowKind {\n+    Label,\n+    Lifetime,\n+}\n+struct Original {\n+    kind: ShadowKind,\n+    span: Span,\n+}\n+struct Shadower {\n+    kind: ShadowKind,\n+    span: Span,\n+}\n \n fn original_label(span: Span) -> Original {\n-    Original { kind: ShadowKind::Label, span: span }\n+    Original {\n+        kind: ShadowKind::Label,\n+        span: span,\n+    }\n }\n fn shadower_label(span: Span) -> Shadower {\n-    Shadower { kind: ShadowKind::Label, span: span }\n+    Shadower {\n+        kind: ShadowKind::Label,\n+        span: span,\n+    }\n }\n fn original_lifetime(span: Span) -> Original {\n-    Original { kind: ShadowKind::Lifetime, span: span }\n+    Original {\n+        kind: ShadowKind::Lifetime,\n+        span: span,\n+    }\n }\n fn shadower_lifetime(l: &hir::Lifetime) -> Shadower {\n-    Shadower { kind: ShadowKind::Lifetime, span: l.span }\n+    Shadower {\n+        kind: ShadowKind::Lifetime,\n+        span: l.span,\n+    }\n }\n \n impl ShadowKind {\n@@ -671,55 +829,75 @@ impl ShadowKind {\n }\n \n fn check_mixed_explicit_and_in_band_defs(\n-    sess: &Session,\n+    tcx: TyCtxt<'_, '_, '_>,\n     lifetime_defs: &[hir::LifetimeDef],\n ) {\n     let oob_def = lifetime_defs.iter().find(|lt| !lt.in_band);\n     let in_band_def = lifetime_defs.iter().find(|lt| lt.in_band);\n \n     if let (Some(oob_def), Some(in_band_def)) = (oob_def, in_band_def) {\n-        struct_span_err!(sess, in_band_def.lifetime.span, E0688,\n-                         \"cannot mix in-band and explicit lifetime definitions\")\n-            .span_label(in_band_def.lifetime.span, \"in-band lifetime definition here\")\n+        struct_span_err!(\n+            tcx.sess,\n+            in_band_def.lifetime.span,\n+            E0688,\n+            \"cannot mix in-band and explicit lifetime definitions\"\n+        ).span_label(\n+            in_band_def.lifetime.span,\n+            \"in-band lifetime definition here\",\n+        )\n             .span_label(oob_def.lifetime.span, \"explicit lifetime definition here\")\n             .emit();\n     }\n }\n \n-fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, shadower: Shadower) {\n+fn signal_shadowing_problem(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    name: ast::Name,\n+    orig: Original,\n+    shadower: Shadower,\n+) {\n     let mut err = if let (ShadowKind::Lifetime, ShadowKind::Lifetime) = (orig.kind, shadower.kind) {\n         // lifetime/lifetime shadowing is an error\n-        struct_span_err!(sess, shadower.span, E0496,\n-                         \"{} name `{}` shadows a \\\n-                          {} name that is already in scope\",\n-                         shadower.kind.desc(), name, orig.kind.desc())\n+        struct_span_err!(\n+            tcx.sess,\n+            shadower.span,\n+            E0496,\n+            \"{} name `{}` shadows a \\\n+             {} name that is already in scope\",\n+            shadower.kind.desc(),\n+            name,\n+            orig.kind.desc()\n+        )\n     } else {\n         // shadowing involving a label is only a warning, due to issues with\n         // labels and lifetimes not being macro-hygienic.\n-        sess.struct_span_warn(shadower.span,\n-                              &format!(\"{} name `{}` shadows a \\\n-                                        {} name that is already in scope\",\n-                                       shadower.kind.desc(), name, orig.kind.desc()))\n+        tcx.sess.struct_span_warn(\n+            shadower.span,\n+            &format!(\n+                \"{} name `{}` shadows a \\\n+                 {} name that is already in scope\",\n+                shadower.kind.desc(),\n+                name,\n+                orig.kind.desc()\n+            ),\n+        )\n     };\n     err.span_label(orig.span, \"first declared here\");\n-    err.span_label(shadower.span,\n-                   format!(\"lifetime {} already in scope\", name));\n+    err.span_label(shadower.span, format!(\"lifetime {} already in scope\", name));\n     err.emit();\n }\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n+fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     struct GatherLabels<'a, 'tcx: 'a> {\n-        sess: &'a Session,\n-        hir_map: &'a Map<'tcx>,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         scope: ScopeRef<'a>,\n         labels_in_fn: &'a mut Vec<(ast::Name, Span)>,\n     }\n \n     let mut gather = GatherLabels {\n-        sess: ctxt.sess,\n-        hir_map: ctxt.hir_map,\n+        tcx: ctxt.tcx,\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n@@ -735,18 +913,16 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n                 for &(prior, prior_span) in &self.labels_in_fn[..] {\n                     // FIXME (#24278): non-hygienic comparison\n                     if label == prior {\n-                        signal_shadowing_problem(self.sess,\n-                                                 label,\n-                                                 original_label(prior_span),\n-                                                 shadower_label(label_span));\n+                        signal_shadowing_problem(\n+                            self.tcx,\n+                            label,\n+                            original_label(prior_span),\n+                            shadower_label(label_span),\n+                        );\n                     }\n                 }\n \n-                check_if_label_shadows_lifetime(self.sess,\n-                                                self.hir_map,\n-                                                self.scope,\n-                                                label,\n-                                                label_span);\n+                check_if_label_shadows_lifetime(self.tcx, self.scope, label, label_span);\n \n                 self.labels_in_fn.push((label, label_span));\n             }\n@@ -756,36 +932,46 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n \n     fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n         match ex.node {\n-            hir::ExprWhile(.., Some(label)) |\n-            hir::ExprLoop(_, Some(label), _) => Some((label.node, label.span)),\n+            hir::ExprWhile(.., Some(label)) | hir::ExprLoop(_, Some(label), _) => {\n+                Some((label.node, label.span))\n+            }\n             _ => None,\n         }\n     }\n \n-    fn check_if_label_shadows_lifetime<'a>(sess: &'a Session,\n-                                           hir_map: &Map,\n-                                           mut scope: ScopeRef<'a>,\n-                                           label: ast::Name,\n-                                           label_span: Span) {\n+    fn check_if_label_shadows_lifetime(\n+        tcx: TyCtxt<'_, '_, '_>,\n+        mut scope: ScopeRef<'_>,\n+        label: ast::Name,\n+        label_span: Span,\n+    ) {\n         loop {\n             match *scope {\n-                Scope::Body { s, .. } |\n-                Scope::Elision { s, .. } |\n-                Scope::ObjectLifetimeDefault { s, .. } => { scope = s; }\n+                Scope::Body { s, .. }\n+                | Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. } => {\n+                    scope = s;\n+                }\n \n-                Scope::Root => { return; }\n+                Scope::Root => {\n+                    return;\n+                }\n \n-                Scope::Binder { ref lifetimes, s, next_early_index: _ } => {\n+                Scope::Binder {\n+                    ref lifetimes,\n+                    s,\n+                    next_early_index: _,\n+                } => {\n                     // FIXME (#24278): non-hygienic comparison\n                     if let Some(def) = lifetimes.get(&hir::LifetimeName::Name(label)) {\n-                        let node_id = hir_map.as_local_node_id(def.id().unwrap())\n-                                             .unwrap();\n+                        let node_id = tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n-                            sess,\n+                            tcx,\n                             label,\n-                            original_lifetime(hir_map.span(node_id)),\n-                            shadower_label(label_span));\n+                            original_lifetime(tcx.hir.span(node_id)),\n+                            shadower_label(label_span),\n+                        );\n                         return;\n                     }\n                     scope = s;\n@@ -795,33 +981,38 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n     }\n }\n \n-fn compute_object_lifetime_defaults(sess: &Session, hir_map: &Map)\n-                                    -> NodeMap<Vec<ObjectLifetimeDefault>> {\n+fn compute_object_lifetime_defaults(\n+    tcx: TyCtxt<'_, '_, '_>,\n+) -> NodeMap<Vec<ObjectLifetimeDefault>> {\n     let mut map = NodeMap();\n-    for item in hir_map.krate().items.values() {\n+    for item in tcx.hir.krate().items.values() {\n         match item.node {\n-            hir::ItemStruct(_, ref generics) |\n-            hir::ItemUnion(_, ref generics) |\n-            hir::ItemEnum(_, ref generics) |\n-            hir::ItemTy(_, ref generics) |\n-            hir::ItemTrait(_, _, ref generics, ..) => {\n-                let result = object_lifetime_defaults_for_item(hir_map, generics);\n+            hir::ItemStruct(_, ref generics)\n+            | hir::ItemUnion(_, ref generics)\n+            | hir::ItemEnum(_, ref generics)\n+            | hir::ItemTy(_, ref generics)\n+            | hir::ItemTrait(_, _, ref generics, ..) => {\n+                let result = object_lifetime_defaults_for_item(tcx, generics);\n \n                 // Debugging aid.\n                 if attr::contains_name(&item.attrs, \"rustc_object_lifetime_default\") {\n-                    let object_lifetime_default_reprs: String =\n-                        result.iter().map(|set| {\n-                            match *set {\n-                                Set1::Empty => \"BaseDefault\".to_string(),\n-                                Set1::One(Region::Static) => \"'static\".to_string(),\n-                                Set1::One(Region::EarlyBound(i, _, _)) => {\n-                                    generics.lifetimes[i as usize].lifetime.name.name().to_string()\n-                                }\n-                                Set1::One(_) => bug!(),\n-                                Set1::Many => \"Ambiguous\".to_string(),\n-                            }\n-                        }).collect::<Vec<String>>().join(\",\");\n-                    sess.span_err(item.span, &object_lifetime_default_reprs);\n+                    let object_lifetime_default_reprs: String = result\n+                        .iter()\n+                        .map(|set| match *set {\n+                            Set1::Empty => \"BaseDefault\".to_string(),\n+                            Set1::One(Region::Static) => \"'static\".to_string(),\n+                            Set1::One(Region::EarlyBound(i, _, _)) => generics.lifetimes\n+                                [i as usize]\n+                                .lifetime\n+                                .name\n+                                .name()\n+                                .to_string(),\n+                            Set1::One(_) => bug!(),\n+                            Set1::Many => \"Ambiguous\".to_string(),\n+                        })\n+                        .collect::<Vec<String>>()\n+                        .join(\",\");\n+                    tcx.sess.span_err(item.span, &object_lifetime_default_reprs);\n                 }\n \n                 map.insert(item.id, result);\n@@ -835,8 +1026,10 @@ fn compute_object_lifetime_defaults(sess: &Session, hir_map: &Map)\n /// Scan the bounds and where-clauses on parameters to extract bounds\n /// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n /// for each type parameter.\n-fn object_lifetime_defaults_for_item(hir_map: &Map, generics: &hir::Generics)\n-                                     -> Vec<ObjectLifetimeDefault> {\n+fn object_lifetime_defaults_for_item(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    generics: &hir::Generics,\n+) -> Vec<ObjectLifetimeDefault> {\n     fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::TyParamBound]) {\n         for bound in bounds {\n             if let hir::RegionTyParamBound(ref lifetime) = *bound {\n@@ -845,74 +1038,83 @@ fn object_lifetime_defaults_for_item(hir_map: &Map, generics: &hir::Generics)\n         }\n     }\n \n-    generics.ty_params.iter().map(|param| {\n-        let mut set = Set1::Empty;\n+    generics\n+        .ty_params\n+        .iter()\n+        .map(|param| {\n+            let mut set = Set1::Empty;\n \n-        add_bounds(&mut set, &param.bounds);\n+            add_bounds(&mut set, &param.bounds);\n \n-        let param_def_id = hir_map.local_def_id(param.id);\n-        for predicate in &generics.where_clause.predicates {\n-            // Look for `type: ...` where clauses.\n-            let data = match *predicate {\n-                hir::WherePredicate::BoundPredicate(ref data) => data,\n-                _ => continue\n-            };\n+            let param_def_id = tcx.hir.local_def_id(param.id);\n+            for predicate in &generics.where_clause.predicates {\n+                // Look for `type: ...` where clauses.\n+                let data = match *predicate {\n+                    hir::WherePredicate::BoundPredicate(ref data) => data,\n+                    _ => continue,\n+                };\n \n-            // Ignore `for<'a> type: ...` as they can change what\n-            // lifetimes mean (although we could \"just\" handle it).\n-            if !data.bound_lifetimes.is_empty() {\n-                continue;\n-            }\n+                // Ignore `for<'a> type: ...` as they can change what\n+                // lifetimes mean (although we could \"just\" handle it).\n+                if !data.bound_lifetimes.is_empty() {\n+                    continue;\n+                }\n \n-            let def = match data.bounded_ty.node {\n-                hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n-                _ => continue\n-            };\n+                let def = match data.bounded_ty.node {\n+                    hir::TyPath(hir::QPath::Resolved(None, ref path)) => path.def,\n+                    _ => continue,\n+                };\n \n-            if def == Def::TyParam(param_def_id) {\n-                add_bounds(&mut set, &data.bounds);\n+                if def == Def::TyParam(param_def_id) {\n+                    add_bounds(&mut set, &data.bounds);\n+                }\n             }\n-        }\n \n-        match set {\n-            Set1::Empty => Set1::Empty,\n-            Set1::One(name) => {\n-                if name == hir::LifetimeName::Static {\n-                    Set1::One(Region::Static)\n-                } else {\n-                    generics.lifetimes.iter().enumerate().find(|&(_, def)| {\n-                        def.lifetime.name == name\n-                    }).map_or(Set1::Many, |(i, def)| {\n-                        let def_id = hir_map.local_def_id(def.lifetime.id);\n-                        let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n-                        Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n-                    })\n+            match set {\n+                Set1::Empty => Set1::Empty,\n+                Set1::One(name) => {\n+                    if name == hir::LifetimeName::Static {\n+                        Set1::One(Region::Static)\n+                    } else {\n+                        generics\n+                            .lifetimes\n+                            .iter()\n+                            .enumerate()\n+                            .find(|&(_, def)| def.lifetime.name == name)\n+                            .map_or(Set1::Many, |(i, def)| {\n+                                let def_id = tcx.hir.local_def_id(def.lifetime.id);\n+                                let origin = LifetimeDefOrigin::from_is_in_band(def.in_band);\n+                                Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n+                            })\n+                    }\n                 }\n+                Set1::Many => Set1::Many,\n             }\n-            Set1::Many => Set1::Many\n-        }\n-    }).collect()\n+        })\n+        .collect()\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     // FIXME(#37666) this works around a limitation in the region inferencer\n-    fn hack<F>(&mut self, f: F) where\n+    fn hack<F>(&mut self, f: F)\n+    where\n         F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n     {\n         f(self)\n     }\n \n-    fn with<F>(&mut self, wrap_scope: Scope, f: F) where\n+    fn with<F>(&mut self, wrap_scope: Scope, f: F)\n+    where\n         F: for<'b> FnOnce(ScopeRef, &mut LifetimeContext<'b, 'tcx>),\n     {\n-        let LifetimeContext {sess, cstore, hir_map, ref mut map, ..} = *self;\n+        let LifetimeContext {\n+            tcx, ref mut map, ..\n+        } = *self;\n         let labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n         let xcrate_object_lifetime_defaults =\n             replace(&mut self.xcrate_object_lifetime_defaults, DefIdMap());\n         let mut this = LifetimeContext {\n-            sess,\n-            cstore,\n-            hir_map,\n+            tcx,\n             map: *map,\n             scope: &wrap_scope,\n             trait_ref_hack: self.trait_ref_hack,\n@@ -945,45 +1147,51 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// already in scope (for a fn item, that will be 0, but for a method it might not be). Late\n     /// bound lifetimes are resolved by name and associated with a binder id (`binder_id`), so the\n     /// ordering is not important there.\n-    fn visit_early_late<F>(&mut self,\n-                           parent_id: Option<ast::NodeId>,\n-                           decl: &'tcx hir::FnDecl,\n-                           generics: &'tcx hir::Generics,\n-                           walk: F) where\n+    fn visit_early_late<F>(\n+        &mut self,\n+        parent_id: Option<ast::NodeId>,\n+        decl: &'tcx hir::FnDecl,\n+        generics: &'tcx hir::Generics,\n+        walk: F,\n+    ) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n         insert_late_bound_lifetimes(self.map, decl, generics);\n \n         // Find the start of nested early scopes, e.g. in methods.\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n-            let parent = self.hir_map.expect_item(parent_id);\n+            let parent = self.tcx.hir.expect_item(parent_id);\n             if let hir::ItemTrait(..) = parent.node {\n                 index += 1; // Self comes first.\n             }\n             match parent.node {\n-                hir::ItemTrait(_, _, ref generics, ..) |\n-                hir::ItemImpl(_, _, _, ref generics, ..) => {\n+                hir::ItemTrait(_, _, ref generics, ..)\n+                | hir::ItemImpl(_, _, _, ref generics, ..) => {\n                     index += (generics.lifetimes.len() + generics.ty_params.len()) as u32;\n                 }\n                 _ => {}\n             }\n         }\n \n-        let lifetimes = generics.lifetimes.iter().map(|def| {\n-            if self.map.late_bound.contains(&def.lifetime.id) {\n-                Region::late(self.hir_map, def)\n-            } else {\n-                Region::early(self.hir_map, &mut index, def)\n-            }\n-        }).collect();\n+        let lifetimes = generics\n+            .lifetimes\n+            .iter()\n+            .map(|def| {\n+                if self.map.late_bound.contains(&def.lifetime.id) {\n+                    Region::late(&self.tcx.hir, def)\n+                } else {\n+                    Region::early(&self.tcx.hir, &mut index, def)\n+                }\n+            })\n+            .collect();\n \n         let next_early_index = index + generics.ty_params.len() as u32;\n \n         let scope = Scope::Binder {\n             lifetimes,\n             next_early_index,\n-            s: self.scope\n+            s: self.scope,\n         };\n         self.with(scope, move |old_scope, this| {\n             this.check_lifetime_defs(old_scope, &generics.lifetimes);\n@@ -997,16 +1205,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut scope = self.scope;\n         loop {\n             match *scope {\n-                Scope::Root =>\n-                    return 0,\n+                Scope::Root => return 0,\n \n-                Scope::Binder { next_early_index, .. } =>\n-                    return next_early_index,\n+                Scope::Binder {\n+                    next_early_index, ..\n+                } => return next_early_index,\n \n-                Scope::Body { s, .. } |\n-                Scope::Elision { s, .. } |\n-                Scope::ObjectLifetimeDefault { s, .. } =>\n-                    scope = s,\n+                Scope::Body { s, .. }\n+                | Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. } => scope = s,\n             }\n         }\n     }\n@@ -1032,7 +1239,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n-                Scope::Binder { ref lifetimes, s, next_early_index: _ } => {\n+                Scope::Binder {\n+                    ref lifetimes,\n+                    s,\n+                    next_early_index: _,\n+                } => {\n                     if let Some(&def) = lifetimes.get(&lifetime_ref.name) {\n                         break Some(def.shifted(late_depth));\n                     } else {\n@@ -1041,8 +1252,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     }\n                 }\n \n-                Scope::Elision { s, .. } |\n-                Scope::ObjectLifetimeDefault { s, .. } => {\n+                Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -1052,18 +1262,21 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             if let Region::EarlyBound(..) = def {\n                 // Do not free early-bound regions, only late-bound ones.\n             } else if let Some(body_id) = outermost_body {\n-                let fn_id = self.hir_map.body_owner(body_id);\n-                match self.hir_map.get(fn_id) {\n+                let fn_id = self.tcx.hir.body_owner(body_id);\n+                match self.tcx.hir.get(fn_id) {\n                     hir::map::NodeItem(&hir::Item {\n-                        node: hir::ItemFn(..), ..\n-                    }) |\n-                    hir::map::NodeTraitItem(&hir::TraitItem {\n-                        node: hir::TraitItemKind::Method(..), ..\n-                    }) |\n-                    hir::map::NodeImplItem(&hir::ImplItem {\n-                        node: hir::ImplItemKind::Method(..), ..\n+                        node: hir::ItemFn(..),\n+                        ..\n+                    })\n+                    | hir::map::NodeTraitItem(&hir::TraitItem {\n+                        node: hir::TraitItemKind::Method(..),\n+                        ..\n+                    })\n+                    | hir::map::NodeImplItem(&hir::ImplItem {\n+                        node: hir::ImplItemKind::Method(..),\n+                        ..\n                     }) => {\n-                        let scope = self.hir_map.local_def_id(fn_id);\n+                        let scope = self.tcx.hir.local_def_id(fn_id);\n                         def = Region::Free(scope, def.id().unwrap());\n                     }\n                     _ => {}\n@@ -1073,38 +1286,45 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             // Check for fn-syntax conflicts with in-band lifetime definitions\n             if self.is_in_fn_syntax {\n                 match def {\n-                    Region::EarlyBound(_, _, LifetimeDefOrigin::InBand) |\n-                    Region::LateBound(_, _, LifetimeDefOrigin::InBand) => {\n-                        struct_span_err!(self.sess, lifetime_ref.span, E0687,\n+                    Region::EarlyBound(_, _, LifetimeDefOrigin::InBand)\n+                    | Region::LateBound(_, _, LifetimeDefOrigin::InBand) => {\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            lifetime_ref.span,\n+                            E0687,\n                             \"lifetimes used in `fn` or `Fn` syntax must be \\\n-                            explicitly declared using `<...>` binders\")\n-                            .span_label(lifetime_ref.span,\n-                                        \"in-band lifetime definition\")\n+                             explicitly declared using `<...>` binders\"\n+                        ).span_label(lifetime_ref.span, \"in-band lifetime definition\")\n                             .emit();\n-                    },\n+                    }\n \n-                    Region::Static |\n-                    Region::EarlyBound(_, _, LifetimeDefOrigin::Explicit) |\n-                    Region::LateBound(_, _, LifetimeDefOrigin::Explicit) |\n-                    Region::LateBoundAnon(..) |\n-                    Region::Free(..) => {}\n+                    Region::Static\n+                    | Region::EarlyBound(_, _, LifetimeDefOrigin::Explicit)\n+                    | Region::LateBound(_, _, LifetimeDefOrigin::Explicit)\n+                    | Region::LateBoundAnon(..)\n+                    | Region::Free(..) => {}\n                 }\n             }\n \n             self.insert_lifetime(lifetime_ref, def);\n         } else {\n-            struct_span_err!(self.sess, lifetime_ref.span, E0261,\n-                \"use of undeclared lifetime name `{}`\", lifetime_ref.name.name())\n-                .span_label(lifetime_ref.span, \"undeclared lifetime\")\n+            struct_span_err!(\n+                self.tcx.sess,\n+                lifetime_ref.span,\n+                E0261,\n+                \"use of undeclared lifetime name `{}`\",\n+                lifetime_ref.name.name()\n+            ).span_label(lifetime_ref.span, \"undeclared lifetime\")\n                 .emit();\n         }\n     }\n \n-    fn visit_segment_parameters(&mut self,\n-                                def: Def,\n-                                depth: usize,\n-                                params: &'tcx hir::PathParameters) {\n-\n+    fn visit_segment_parameters(\n+        &mut self,\n+        def: Def,\n+        depth: usize,\n+        params: &'tcx hir::PathParameters,\n+    ) {\n         if params.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n@@ -1116,35 +1336,32 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if params.lifetimes.iter().all(|l| l.is_elided()) {\n             self.resolve_elided_lifetimes(&params.lifetimes);\n         } else {\n-            for l in &params.lifetimes { self.visit_lifetime(l); }\n+            for l in &params.lifetimes {\n+                self.visit_lifetime(l);\n+            }\n         }\n \n         // Figure out if this is a type/trait segment,\n         // which requires object lifetime defaults.\n         let parent_def_id = |this: &mut Self, def_id: DefId| {\n-            let def_key = if def_id.is_local() {\n-                this.hir_map.def_key(def_id)\n-            } else {\n-                this.cstore.def_key(def_id)\n-            };\n+            let def_key = this.tcx.def_key(def_id);\n             DefId {\n                 krate: def_id.krate,\n-                index: def_key.parent.expect(\"missing parent\")\n+                index: def_key.parent.expect(\"missing parent\"),\n             }\n         };\n         let type_def_id = match def {\n-            Def::AssociatedTy(def_id) if depth == 1 => {\n-                Some(parent_def_id(self, def_id))\n+            Def::AssociatedTy(def_id) if depth == 1 => Some(parent_def_id(self, def_id)),\n+            Def::Variant(def_id) if depth == 0 => Some(parent_def_id(self, def_id)),\n+            Def::Struct(def_id)\n+            | Def::Union(def_id)\n+            | Def::Enum(def_id)\n+            | Def::TyAlias(def_id)\n+            | Def::Trait(def_id) if depth == 0 =>\n+            {\n+                Some(def_id)\n             }\n-            Def::Variant(def_id) if depth == 0 => {\n-                Some(parent_def_id(self, def_id))\n-            }\n-            Def::Struct(def_id) |\n-            Def::Union(def_id) |\n-            Def::Enum(def_id) |\n-            Def::TyAlias(def_id) |\n-            Def::Trait(def_id) if depth == 0 => Some(def_id),\n-            _ => None\n+            _ => None,\n         };\n \n         let object_lifetime_defaults = type_def_id.map_or(vec![], |def_id| {\n@@ -1156,66 +1373,70 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                         Scope::Body { .. } => break true,\n \n-                        Scope::Binder { s, .. } |\n-                        Scope::Elision { s, .. } |\n-                        Scope::ObjectLifetimeDefault { s, .. } => {\n+                        Scope::Binder { s, .. }\n+                        | Scope::Elision { s, .. }\n+                        | Scope::ObjectLifetimeDefault { s, .. } => {\n                             scope = s;\n                         }\n                     }\n                 }\n             };\n \n             let map = &self.map;\n-            let unsubst = if let Some(id) = self.hir_map.as_local_node_id(def_id) {\n+            let unsubst = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                 &map.object_lifetime_defaults[&id]\n             } else {\n-                let cstore = self.cstore;\n-                let sess = self.sess;\n-                self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n-                    cstore.item_generics_cloned_untracked(def_id, sess)\n-                          .types\n-                          .into_iter()\n-                          .map(|def| {\n-                        def.object_lifetime_default\n-                    }).collect()\n-                })\n+                let tcx = self.tcx;\n+                self.xcrate_object_lifetime_defaults\n+                    .entry(def_id)\n+                    .or_insert_with(|| {\n+                        tcx.generics_of(def_id)\n+                            .types\n+                            .iter()\n+                            .map(|def| def.object_lifetime_default)\n+                            .collect()\n+                    })\n             };\n-            unsubst.iter().map(|set| {\n-                match *set {\n-                    Set1::Empty => {\n-                        if in_body {\n-                            None\n-                        } else {\n-                            Some(Region::Static)\n-                        }\n-                    }\n+            unsubst\n+                .iter()\n+                .map(|set| match *set {\n+                    Set1::Empty => if in_body {\n+                        None\n+                    } else {\n+                        Some(Region::Static)\n+                    },\n                     Set1::One(r) => r.subst(&params.lifetimes, map),\n-                    Set1::Many => None\n-                }\n-            }).collect()\n+                    Set1::Many => None,\n+                })\n+                .collect()\n         });\n \n         for (i, ty) in params.types.iter().enumerate() {\n             if let Some(&lt) = object_lifetime_defaults.get(i) {\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: lt,\n-                    s: self.scope\n+                    s: self.scope,\n                 };\n                 self.with(scope, |_, this| this.visit_ty(ty));\n             } else {\n                 self.visit_ty(ty);\n             }\n         }\n \n-        for b in &params.bindings { self.visit_assoc_type_binding(b); }\n+        for b in &params.bindings {\n+            self.visit_assoc_type_binding(b);\n+        }\n     }\n \n-    fn visit_fn_like_elision(&mut self, inputs: &'tcx [P<hir::Ty>],\n-                             output: Option<&'tcx P<hir::Ty>>) {\n+    fn visit_fn_like_elision(\n+        &mut self,\n+        inputs: &'tcx [P<hir::Ty>],\n+        output: Option<&'tcx P<hir::Ty>>,\n+    ) {\n         let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n         let arg_scope = Scope::Elision {\n             elide: arg_elide.clone(),\n-            s: self.scope\n+            s: self.scope,\n         };\n         self.with(arg_scope, |_, this| {\n             for input in inputs {\n@@ -1225,33 +1446,41 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Elision { ref elide, .. } => {\n                     arg_elide = elide.clone();\n                 }\n-                _ => bug!()\n+                _ => bug!(),\n             }\n         });\n \n         let output = match output {\n             Some(ty) => ty,\n-            None => return\n+            None => return,\n         };\n \n         // Figure out if there's a body we can get argument names from,\n         // and whether there's a `self` argument (treated specially).\n         let mut assoc_item_kind = None;\n         let mut impl_self = None;\n-        let parent = self.hir_map.get_parent_node(output.id);\n-        let body = match self.hir_map.get(parent) {\n+        let parent = self.tcx.hir.get_parent_node(output.id);\n+        let body = match self.tcx.hir.get(parent) {\n             // `fn` definitions and methods.\n             hir::map::NodeItem(&hir::Item {\n-                node: hir::ItemFn(.., body), ..\n-            })  => Some(body),\n+                node: hir::ItemFn(.., body),\n+                ..\n+            }) => Some(body),\n \n             hir::map::NodeTraitItem(&hir::TraitItem {\n-                node: hir::TraitItemKind::Method(_, ref m), ..\n+                node: hir::TraitItemKind::Method(_, ref m),\n+                ..\n             }) => {\n-                match self.hir_map.expect_item(self.hir_map.get_parent(parent)).node {\n+                match self.tcx\n+                    .hir\n+                    .expect_item(self.tcx.hir.get_parent(parent))\n+                    .node\n+                {\n                     hir::ItemTrait(.., ref trait_items) => {\n-                        assoc_item_kind = trait_items.iter().find(|ti| ti.id.node_id == parent)\n-                                                            .map(|ti| ti.kind);\n+                        assoc_item_kind = trait_items\n+                            .iter()\n+                            .find(|ti| ti.id.node_id == parent)\n+                            .map(|ti| ti.kind);\n                     }\n                     _ => {}\n                 }\n@@ -1262,13 +1491,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             hir::map::NodeImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Method(_, body), ..\n+                node: hir::ImplItemKind::Method(_, body),\n+                ..\n             }) => {\n-                match self.hir_map.expect_item(self.hir_map.get_parent(parent)).node {\n+                match self.tcx\n+                    .hir\n+                    .expect_item(self.tcx.hir.get_parent(parent))\n+                    .node\n+                {\n                     hir::ItemImpl(.., ref self_ty, ref impl_items) => {\n                         impl_self = Some(self_ty);\n-                        assoc_item_kind = impl_items.iter().find(|ii| ii.id.node_id == parent)\n-                                                           .map(|ii| ii.kind);\n+                        assoc_item_kind = impl_items\n+                            .iter()\n+                            .find(|ii| ii.id.node_id == parent)\n+                            .map(|ii| ii.kind);\n                     }\n                     _ => {}\n                 }\n@@ -1288,7 +1524,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let has_self = match assoc_item_kind {\n             Some(hir::AssociatedItemKind::Method { has_self }) => has_self,\n-            _ => false\n+            _ => false,\n         };\n \n         // In accordance with the rules for lifetime elision, we can determine\n@@ -1311,10 +1547,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         // Whitelist the types that unambiguously always\n                         // result in the same type constructor being used\n                         // (it can't differ between `Self` and `self`).\n-                        Def::Struct(_) |\n-                        Def::Union(_) |\n-                        Def::Enum(_) |\n-                        Def::PrimTy(_) => return def == path.def,\n+                        Def::Struct(_) | Def::Union(_) | Def::Enum(_) | Def::PrimTy(_) => {\n+                            return def == path.def\n+                        }\n                         _ => {}\n                     }\n                 }\n@@ -1328,7 +1563,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n                             let scope = Scope::Elision {\n                                 elide: Elide::Exact(lifetime),\n-                                s: self.scope\n+                                s: self.scope,\n                             };\n                             self.with(scope, |_, this| this.visit_ty(output));\n                             return;\n@@ -1343,31 +1578,36 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // have that lifetime.\n         let mut possible_implied_output_region = None;\n         let mut lifetime_count = 0;\n-        let arg_lifetimes = inputs.iter().enumerate().skip(has_self as usize).map(|(i, input)| {\n-            let mut gather = GatherLifetimes {\n-                map: self.map,\n-                binder_depth: 1,\n-                have_bound_regions: false,\n-                lifetimes: FxHashSet()\n-            };\n-            gather.visit_ty(input);\n+        let arg_lifetimes = inputs\n+            .iter()\n+            .enumerate()\n+            .skip(has_self as usize)\n+            .map(|(i, input)| {\n+                let mut gather = GatherLifetimes {\n+                    map: self.map,\n+                    binder_depth: 1,\n+                    have_bound_regions: false,\n+                    lifetimes: FxHashSet(),\n+                };\n+                gather.visit_ty(input);\n \n-            lifetime_count += gather.lifetimes.len();\n+                lifetime_count += gather.lifetimes.len();\n \n-            if lifetime_count == 1 && gather.lifetimes.len() == 1 {\n-                // there's a chance that the unique lifetime of this\n-                // iteration will be the appropriate lifetime for output\n-                // parameters, so lets store it.\n-                possible_implied_output_region = gather.lifetimes.iter().cloned().next();\n-            }\n+                if lifetime_count == 1 && gather.lifetimes.len() == 1 {\n+                    // there's a chance that the unique lifetime of this\n+                    // iteration will be the appropriate lifetime for output\n+                    // parameters, so lets store it.\n+                    possible_implied_output_region = gather.lifetimes.iter().cloned().next();\n+                }\n \n-            ElisionFailureInfo {\n-                parent: body,\n-                index: i,\n-                lifetime_count: gather.lifetimes.len(),\n-                have_bound_regions: gather.have_bound_regions\n-            }\n-        }).collect();\n+                ElisionFailureInfo {\n+                    parent: body,\n+                    index: i,\n+                    lifetime_count: gather.lifetimes.len(),\n+                    have_bound_regions: gather.have_bound_regions,\n+                }\n+            })\n+            .collect();\n \n         let elide = if lifetime_count == 1 {\n             Elide::Exact(possible_implied_output_region.unwrap())\n@@ -1377,7 +1617,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let scope = Scope::Elision {\n             elide,\n-            s: self.scope\n+            s: self.scope,\n         };\n         self.with(scope, |_, this| this.visit_ty(output));\n \n@@ -1415,34 +1655,38 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            fn visit_poly_trait_ref(&mut self,\n-                                    trait_ref: &hir::PolyTraitRef,\n-                                    modifier: hir::TraitBoundModifier) {\n+            fn visit_poly_trait_ref(\n+                &mut self,\n+                trait_ref: &hir::PolyTraitRef,\n+                modifier: hir::TraitBoundModifier,\n+            ) {\n                 self.binder_depth += 1;\n                 intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n                 self.binder_depth -= 1;\n             }\n \n             fn visit_lifetime_def(&mut self, lifetime_def: &hir::LifetimeDef) {\n-                for l in &lifetime_def.bounds { self.visit_lifetime(l); }\n+                for l in &lifetime_def.bounds {\n+                    self.visit_lifetime(l);\n+                }\n             }\n \n             fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n                 if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n                     match lifetime {\n-                        Region::LateBound(debruijn, _, _) |\n-                        Region::LateBoundAnon(debruijn, _)\n-                                if debruijn.depth < self.binder_depth => {\n+                        Region::LateBound(debruijn, _, _) | Region::LateBoundAnon(debruijn, _)\n+                            if debruijn.depth < self.binder_depth =>\n+                        {\n                             self.have_bound_regions = true;\n                         }\n                         _ => {\n-                            self.lifetimes.insert(lifetime.from_depth(self.binder_depth));\n+                            self.lifetimes\n+                                .insert(lifetime.from_depth(self.binder_depth));\n                         }\n                     }\n                 }\n             }\n         }\n-\n     }\n \n     fn resolve_elided_lifetimes(&mut self, lifetime_refs: &[hir::Lifetime]) {\n@@ -1475,7 +1719,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             return;\n                         }\n                         Elide::Exact(l) => l.shifted(late_depth),\n-                        Elide::Error(ref e) => break Some(e)\n+                        Elide::Error(ref e) => break Some(e),\n                     };\n                     for lifetime_ref in lifetime_refs {\n                         self.insert_lifetime(lifetime_ref, lifetime);\n@@ -1489,9 +1733,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        let mut err = struct_span_err!(self.sess, span, E0106,\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0106,\n             \"missing lifetime specifier{}\",\n-            if lifetime_refs.len() > 1 { \"s\" } else { \"\" });\n+            if lifetime_refs.len() > 1 { \"s\" } else { \"\" }\n+        );\n         let msg = if lifetime_refs.len() > 1 {\n             format!(\"expected {} lifetime parameters\", lifetime_refs.len())\n         } else {\n@@ -1507,36 +1755,49 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         err.emit();\n     }\n \n-    fn report_elision_failure(&mut self,\n-                              db: &mut DiagnosticBuilder,\n-                              params: &[ElisionFailureInfo]) {\n+    fn report_elision_failure(\n+        &mut self,\n+        db: &mut DiagnosticBuilder,\n+        params: &[ElisionFailureInfo],\n+    ) {\n         let mut m = String::new();\n         let len = params.len();\n \n-        let elided_params: Vec<_> = params.iter().cloned()\n-                                          .filter(|info| info.lifetime_count > 0)\n-                                          .collect();\n+        let elided_params: Vec<_> = params\n+            .iter()\n+            .cloned()\n+            .filter(|info| info.lifetime_count > 0)\n+            .collect();\n \n         let elided_len = elided_params.len();\n \n         for (i, info) in elided_params.into_iter().enumerate() {\n             let ElisionFailureInfo {\n-                parent, index, lifetime_count: n, have_bound_regions\n+                parent,\n+                index,\n+                lifetime_count: n,\n+                have_bound_regions,\n             } = info;\n \n             let help_name = if let Some(body) = parent {\n-                let arg = &self.hir_map.body(body).arguments[index];\n-                format!(\"`{}`\", self.hir_map.node_to_pretty_string(arg.pat.id))\n+                let arg = &self.tcx.hir.body(body).arguments[index];\n+                format!(\"`{}`\", self.tcx.hir.node_to_pretty_string(arg.pat.id))\n             } else {\n                 format!(\"argument {}\", index + 1)\n             };\n \n-            m.push_str(&(if n == 1 {\n-                help_name\n-            } else {\n-                format!(\"one of {}'s {} {}lifetimes\", help_name, n,\n-                        if have_bound_regions { \"free \" } else { \"\" } )\n-            })[..]);\n+            m.push_str(\n+                &(if n == 1 {\n+                    help_name\n+                } else {\n+                    format!(\n+                        \"one of {}'s {} {}lifetimes\",\n+                        help_name,\n+                        n,\n+                        if have_bound_regions { \"free \" } else { \"\" }\n+                    )\n+                })[..],\n+            );\n \n             if elided_len == 2 && i == 0 {\n                 m.push_str(\" or \");\n@@ -1545,33 +1806,41 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else if i != elided_len - 1 {\n                 m.push_str(\", \");\n             }\n-\n         }\n \n         if len == 0 {\n-            help!(db,\n-                  \"this function's return type contains a borrowed value, but \\\n-                   there is no value for it to be borrowed from\");\n-            help!(db,\n-                  \"consider giving it a 'static lifetime\");\n+            help!(\n+                db,\n+                \"this function's return type contains a borrowed value, but \\\n+                 there is no value for it to be borrowed from\"\n+            );\n+            help!(db, \"consider giving it a 'static lifetime\");\n         } else if elided_len == 0 {\n-            help!(db,\n-                  \"this function's return type contains a borrowed value with \\\n-                   an elided lifetime, but the lifetime cannot be derived from \\\n-                   the arguments\");\n-            help!(db,\n-                  \"consider giving it an explicit bounded or 'static \\\n-                   lifetime\");\n+            help!(\n+                db,\n+                \"this function's return type contains a borrowed value with \\\n+                 an elided lifetime, but the lifetime cannot be derived from \\\n+                 the arguments\"\n+            );\n+            help!(\n+                db,\n+                \"consider giving it an explicit bounded or 'static \\\n+                 lifetime\"\n+            );\n         } else if elided_len == 1 {\n-            help!(db,\n-                  \"this function's return type contains a borrowed value, but \\\n-                   the signature does not say which {} it is borrowed from\",\n-                  m);\n+            help!(\n+                db,\n+                \"this function's return type contains a borrowed value, but \\\n+                 the signature does not say which {} it is borrowed from\",\n+                m\n+            );\n         } else {\n-            help!(db,\n-                  \"this function's return type contains a borrowed value, but \\\n-                   the signature does not say whether it is borrowed from {}\",\n-                  m);\n+            help!(\n+                db,\n+                \"this function's return type contains a borrowed value, but \\\n+                 the signature does not say whether it is borrowed from {}\",\n+                m\n+            );\n         }\n     }\n \n@@ -1585,13 +1854,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root |\n-                Scope::Elision { .. } => break Region::Static,\n+                Scope::Root | Scope::Elision { .. } => break Region::Static,\n \n-                Scope::Body { .. } |\n-                Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n+                Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n-                Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l\n+                Scope::ObjectLifetimeDefault {\n+                    lifetime: Some(l), ..\n+                } => break l,\n             }\n         };\n         self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n@@ -1606,10 +1875,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     hir::LifetimeName::Static | hir::LifetimeName::Underscore => {\n                         let lifetime = lifetime.lifetime;\n                         let name = lifetime.name.name();\n-                        let mut err = struct_span_err!(self.sess, lifetime.span, E0262,\n-                                      \"invalid lifetime parameter name: `{}`\", name);\n-                        err.span_label(lifetime.span,\n-                                       format!(\"{} is a reserved lifetime name\", name));\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            lifetime.span,\n+                            E0262,\n+                            \"invalid lifetime parameter name: `{}`\",\n+                            name\n+                        );\n+                        err.span_label(\n+                            lifetime.span,\n+                            format!(\"{} is a reserved lifetime name\", name),\n+                        );\n                         err.emit();\n                     }\n                     hir::LifetimeName::Implicit | hir::LifetimeName::Name(_) => {}\n@@ -1621,13 +1897,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 let lifetime_j = &lifetimes[j];\n \n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n-                    struct_span_err!(self.sess, lifetime_j.lifetime.span, E0263,\n-                                     \"lifetime name `{}` declared twice in the same scope\",\n-                                     lifetime_j.lifetime.name.name())\n-                        .span_label(lifetime_j.lifetime.span,\n-                                    \"declared twice\")\n-                        .span_label(lifetime_i.lifetime.span,\n-                                   \"previous declaration here\")\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        lifetime_j.lifetime.span,\n+                        E0263,\n+                        \"lifetime name `{}` declared twice in the same scope\",\n+                        lifetime_j.lifetime.name.name()\n+                    ).span_label(lifetime_j.lifetime.span, \"declared twice\")\n+                        .span_label(lifetime_i.lifetime.span, \"previous declaration here\")\n                         .emit();\n                 }\n             }\n@@ -1638,68 +1915,81 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             for bound in &lifetime_i.bounds {\n                 match bound.name {\n                     hir::LifetimeName::Underscore => {\n-                        let mut err = struct_span_err!(self.sess, bound.span, E0637,\n-                            \"invalid lifetime bound name: `'_`\");\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            bound.span,\n+                            E0637,\n+                            \"invalid lifetime bound name: `'_`\"\n+                        );\n                         err.span_label(bound.span, \"`'_` is a reserved lifetime name\");\n                         err.emit();\n                     }\n                     hir::LifetimeName::Static => {\n                         self.insert_lifetime(bound, Region::Static);\n-                        self.sess.struct_span_warn(lifetime_i.lifetime.span.to(bound.span),\n-                            &format!(\"unnecessary lifetime parameter `{}`\",\n-                                    lifetime_i.lifetime.name.name()))\n+                        self.tcx\n+                            .sess\n+                            .struct_span_warn(\n+                                lifetime_i.lifetime.span.to(bound.span),\n+                                &format!(\n+                                    \"unnecessary lifetime parameter `{}`\",\n+                                    lifetime_i.lifetime.name.name()\n+                                ),\n+                            )\n                             .help(&format!(\n                                 \"you can use the `'static` lifetime directly, in place \\\n-                                of `{}`\", lifetime_i.lifetime.name.name()))\n+                                 of `{}`\",\n+                                lifetime_i.lifetime.name.name()\n+                            ))\n                             .emit();\n                     }\n-                    hir::LifetimeName::Implicit |\n-                    hir::LifetimeName::Name(_) => {\n+                    hir::LifetimeName::Implicit | hir::LifetimeName::Name(_) => {\n                         self.resolve_lifetime_ref(bound);\n                     }\n                 }\n             }\n         }\n     }\n \n-    fn check_lifetime_def_for_shadowing(&self,\n-                                        mut old_scope: ScopeRef,\n-                                        lifetime: &hir::Lifetime)\n-    {\n+    fn check_lifetime_def_for_shadowing(&self, mut old_scope: ScopeRef, lifetime: &hir::Lifetime) {\n         for &(label, label_span) in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n             if lifetime.name.name() == label {\n-                signal_shadowing_problem(self.sess,\n-                                         label,\n-                                         original_label(label_span),\n-                                         shadower_lifetime(&lifetime));\n+                signal_shadowing_problem(\n+                    self.tcx,\n+                    label,\n+                    original_label(label_span),\n+                    shadower_lifetime(&lifetime),\n+                );\n                 return;\n             }\n         }\n \n         loop {\n             match *old_scope {\n-                Scope::Body { s, .. } |\n-                Scope::Elision { s, .. } |\n-                Scope::ObjectLifetimeDefault { s, .. } => {\n+                Scope::Body { s, .. }\n+                | Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. } => {\n                     old_scope = s;\n                 }\n \n                 Scope::Root => {\n                     return;\n                 }\n \n-                Scope::Binder { ref lifetimes, s, next_early_index: _ } => {\n+                Scope::Binder {\n+                    ref lifetimes,\n+                    s,\n+                    next_early_index: _,\n+                } => {\n                     if let Some(&def) = lifetimes.get(&lifetime.name) {\n-                        let node_id = self.hir_map\n-                                          .as_local_node_id(def.id().unwrap())\n-                                          .unwrap();\n+                        let node_id = self.tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n-                            self.sess,\n+                            self.tcx,\n                             lifetime.name.name(),\n-                            original_lifetime(self.hir_map.span(node_id)),\n-                            shadower_lifetime(&lifetime));\n+                            original_lifetime(self.tcx.hir.span(node_id)),\n+                            shadower_lifetime(&lifetime),\n+                        );\n                         return;\n                     }\n \n@@ -1709,19 +1999,21 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn insert_lifetime(&mut self,\n-                       lifetime_ref: &hir::Lifetime,\n-                       def: Region) {\n+    fn insert_lifetime(&mut self, lifetime_ref: &hir::Lifetime, def: Region) {\n         if lifetime_ref.id == ast::DUMMY_NODE_ID {\n-            span_bug!(lifetime_ref.span,\n-                      \"lifetime reference not renumbered, \\\n-                       probably a bug in syntax::fold\");\n+            span_bug!(\n+                lifetime_ref.span,\n+                \"lifetime reference not renumbered, \\\n+                 probably a bug in syntax::fold\"\n+            );\n         }\n \n-        debug!(\"insert_lifetime: {} resolved to {:?} span={:?}\",\n-               self.hir_map.node_to_string(lifetime_ref.id),\n-               def,\n-               self.sess.codemap().span_to_string(lifetime_ref.span));\n+        debug!(\n+            \"insert_lifetime: {} resolved to {:?} span={:?}\",\n+            self.tcx.hir.node_to_string(lifetime_ref.id),\n+            def,\n+            self.tcx.sess.codemap().span_to_string(lifetime_ref.span)\n+        );\n         self.map.defs.insert(lifetime_ref.id, def);\n     }\n }\n@@ -1738,12 +2030,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// \"Constrained\" basically means that it appears in any type but\n /// not amongst the inputs to a projection.  In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n-fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n-                               decl: &hir::FnDecl,\n-                               generics: &hir::Generics) {\n-    debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n+fn insert_late_bound_lifetimes(\n+    map: &mut NamedRegionMap,\n+    decl: &hir::FnDecl,\n+    generics: &hir::Generics,\n+) {\n+    debug!(\n+        \"insert_late_bound_lifetimes(decl={:?}, generics={:?})\",\n+        decl,\n+        generics\n+    );\n \n-    let mut constrained_by_input = ConstrainedCollector { regions: FxHashSet() };\n+    let mut constrained_by_input = ConstrainedCollector {\n+        regions: FxHashSet(),\n+    };\n     for arg_ty in &decl.inputs {\n         constrained_by_input.visit_ty(arg_ty);\n     }\n@@ -1753,8 +2053,10 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     };\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n \n-    debug!(\"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n-           constrained_by_input.regions);\n+    debug!(\n+        \"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n+        constrained_by_input.regions\n+    );\n \n     // Walk the lifetimes that appear in where clauses.\n     //\n@@ -1764,33 +2066,41 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         regions: FxHashSet(),\n     };\n     for ty_param in generics.ty_params.iter() {\n-        walk_list!(&mut appears_in_where_clause,\n-                   visit_ty_param_bound,\n-                   &ty_param.bounds);\n+        walk_list!(\n+            &mut appears_in_where_clause,\n+            visit_ty_param_bound,\n+            &ty_param.bounds\n+        );\n     }\n-    walk_list!(&mut appears_in_where_clause,\n-               visit_where_predicate,\n-               &generics.where_clause.predicates);\n+    walk_list!(\n+        &mut appears_in_where_clause,\n+        visit_where_predicate,\n+        &generics.where_clause.predicates\n+    );\n     // We need to collect argument impl Trait lifetimes as well,\n     // we do so here.\n-    walk_list!(&mut appears_in_where_clause,\n-               visit_ty,\n-               decl.inputs.iter().filter(|ty| {\n-                   if let hir::TyImplTraitUniversal(..) = ty.node {\n-                       true\n-                   } else {\n-                       false\n-                   }\n-               }));\n+    walk_list!(\n+        &mut appears_in_where_clause,\n+        visit_ty,\n+        decl.inputs\n+            .iter()\n+            .filter(|ty| if let hir::TyImplTraitUniversal(..) = ty.node {\n+                true\n+            } else {\n+                false\n+            })\n+    );\n     for lifetime_def in &generics.lifetimes {\n         if !lifetime_def.bounds.is_empty() {\n             // `'a: 'b` means both `'a` and `'b` are referenced\n             appears_in_where_clause.visit_lifetime_def(lifetime_def);\n         }\n     }\n \n-    debug!(\"insert_late_bound_lifetimes: appears_in_where_clause={:?}\",\n-           appears_in_where_clause.regions);\n+    debug!(\n+        \"insert_late_bound_lifetimes: appears_in_where_clause={:?}\",\n+        appears_in_where_clause.regions\n+    );\n \n     // Late bound regions are those that:\n     // - appear in the inputs\n@@ -1800,20 +2110,30 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         let name = lifetime.lifetime.name;\n \n         // appears in the where clauses? early-bound.\n-        if appears_in_where_clause.regions.contains(&name) { continue; }\n+        if appears_in_where_clause.regions.contains(&name) {\n+            continue;\n+        }\n \n         // does not appear in the inputs, but appears in the return type? early-bound.\n-        if !constrained_by_input.regions.contains(&name) &&\n-            appears_in_output.regions.contains(&name) {\n+        if !constrained_by_input.regions.contains(&name)\n+            && appears_in_output.regions.contains(&name)\n+        {\n             continue;\n         }\n \n-        debug!(\"insert_late_bound_lifetimes: \\\n-                lifetime {:?} with id {:?} is late-bound\",\n-               lifetime.lifetime.name, lifetime.lifetime.id);\n+        debug!(\n+            \"insert_late_bound_lifetimes: \\\n+             lifetime {:?} with id {:?} is late-bound\",\n+            lifetime.lifetime.name,\n+            lifetime.lifetime.id\n+        );\n \n         let inserted = map.late_bound.insert(lifetime.lifetime.id);\n-        assert!(inserted, \"visited lifetime {:?} twice\", lifetime.lifetime.id);\n+        assert!(\n+            inserted,\n+            \"visited lifetime {:?} twice\",\n+            lifetime.lifetime.id\n+        );\n     }\n \n     return;\n@@ -1829,8 +2149,8 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n \n         fn visit_ty(&mut self, ty: &'v hir::Ty) {\n             match ty.node {\n-                hir::TyPath(hir::QPath::Resolved(Some(_), _)) |\n-                hir::TyPath(hir::QPath::TypeRelative(..)) => {\n+                hir::TyPath(hir::QPath::Resolved(Some(_), _))\n+                | hir::TyPath(hir::QPath::TypeRelative(..)) => {\n                     // ignore lifetimes appearing in associated type\n                     // projections, as they are not *constrained*\n                     // (defined above)"}, {"sha": "4315d59f77165f65e1cf290b7400d714a9436909", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -802,8 +802,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Export map produced by name resolution.\n     export_map: FxHashMap<DefId, Rc<Vec<Export>>>,\n \n-    named_region_map: NamedRegionMap,\n-\n     pub hir: hir_map::Map<'tcx>,\n \n     /// A map from DefPathHash -> DefId. Includes DefIds from the local crate\n@@ -986,7 +984,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   arenas: &'tcx GlobalArenas<'tcx>,\n                                   arena: &'tcx DroplessArena,\n                                   resolutions: ty::Resolutions,\n-                                  named_region_map: resolve_lifetime::NamedRegionMap,\n                                   hir: hir_map::Map<'tcx>,\n                                   on_disk_query_result_cache: maps::OnDiskCache<'tcx>,\n                                   crate_name: &str,\n@@ -1044,27 +1041,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                             .insert(hir_id.local_id,\n                                     Rc::new(StableVec::new(v)));\n         }\n-        let mut defs = FxHashMap();\n-        for (k, v) in named_region_map.defs {\n-            let hir_id = hir.node_to_hir_id(k);\n-            let map = defs.entry(hir_id.owner)\n-                .or_insert_with(|| Rc::new(FxHashMap()));\n-            Rc::get_mut(map).unwrap().insert(hir_id.local_id, v);\n-        }\n-        let mut late_bound = FxHashMap();\n-        for k in named_region_map.late_bound {\n-            let hir_id = hir.node_to_hir_id(k);\n-            let map = late_bound.entry(hir_id.owner)\n-                .or_insert_with(|| Rc::new(FxHashSet()));\n-            Rc::get_mut(map).unwrap().insert(hir_id.local_id);\n-        }\n-        let mut object_lifetime_defaults = FxHashMap();\n-        for (k, v) in named_region_map.object_lifetime_defaults {\n-            let hir_id = hir.node_to_hir_id(k);\n-            let map = object_lifetime_defaults.entry(hir_id.owner)\n-                .or_insert_with(|| Rc::new(FxHashMap()));\n-            Rc::get_mut(map).unwrap().insert(hir_id.local_id, Rc::new(v));\n-        }\n \n         tls::enter_global(GlobalCtxt {\n             sess: s,\n@@ -1074,11 +1050,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             dep_graph: dep_graph.clone(),\n             on_disk_query_result_cache,\n             types: common_types,\n-            named_region_map: NamedRegionMap {\n-                defs,\n-                late_bound,\n-                object_lifetime_defaults,\n-            },\n             trait_map,\n             export_map: resolutions.export_map.into_iter().map(|(k, v)| {\n                 (k, Rc::new(v))\n@@ -2176,27 +2147,12 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n     }\n }\n \n-struct NamedRegionMap {\n-    defs: FxHashMap<DefIndex, Rc<FxHashMap<ItemLocalId, resolve_lifetime::Region>>>,\n-    late_bound: FxHashMap<DefIndex, Rc<FxHashSet<ItemLocalId>>>,\n-    object_lifetime_defaults:\n-        FxHashMap<\n-            DefIndex,\n-            Rc<FxHashMap<ItemLocalId, Rc<Vec<ObjectLifetimeDefault>>>>,\n-        >,\n-}\n-\n pub fn provide(providers: &mut ty::maps::Providers) {\n     // FIXME(#44234) - almost all of these queries have no sub-queries and\n     // therefore no actual inputs, they're just reading tables calculated in\n     // resolve! Does this work? Unsure! That's what the issue is about\n     providers.in_scope_traits_map = |tcx, id| tcx.gcx.trait_map.get(&id).cloned();\n     providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).cloned();\n-    providers.named_region_map = |tcx, id| tcx.gcx.named_region_map.defs.get(&id).cloned();\n-    providers.is_late_bound_map = |tcx, id| tcx.gcx.named_region_map.late_bound.get(&id).cloned();\n-    providers.object_lifetime_defaults_map = |tcx, id| {\n-        tcx.gcx.named_region_map.object_lifetime_defaults.get(&id).cloned()\n-    };\n     providers.crate_name = |tcx, id| {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.crate_name"}, {"sha": "a556861147e396f85b728666f564206f448fdcea", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -443,6 +443,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::link_args<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription<'tcx> for queries::resolve_lifetimes<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"resolving lifetimes\")\n+    }\n+}\n+\n impl<'tcx> QueryDescription<'tcx> for queries::named_region_map<'tcx> {\n     fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n         format!(\"looking up a named region\")"}, {"sha": "7ba063adff4c2b7cb1080a472132761273406925", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -23,7 +23,7 @@ use middle::cstore::{NativeLibraryKind, DepKind, CrateSource, ExternConstBody};\n use middle::privacy::AccessLevels;\n use middle::reachable::ReachableSet;\n use middle::region;\n-use middle::resolve_lifetime::{Region, ObjectLifetimeDefault};\n+use middle::resolve_lifetime::{ResolveLifetimes, Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n use middle::lang_items::{LanguageItems, LangItem};\n use middle::exported_symbols::SymbolExportLevel;\n@@ -306,6 +306,8 @@ define_maps! { <'tcx>\n         -> Option<NativeLibraryKind>,\n     [] fn link_args: link_args_node(CrateNum) -> Rc<Vec<String>>,\n \n+    // Lifetime resolution. See `middle::resolve_lifetimes`.\n+    [] fn resolve_lifetimes: ResolveLifetimes(CrateNum) -> Rc<ResolveLifetimes>,\n     [] fn named_region_map: NamedRegion(DefIndex) ->\n         Option<Rc<FxHashMap<ItemLocalId, Region>>>,\n     [] fn is_late_bound_map: IsLateBound(DefIndex) ->"}, {"sha": "8875439be6b3d08833ab255ce6113ee7c0368fdb", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -875,6 +875,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::NativeLibraryKind => { force!(native_library_kind, def_id!()); }\n         DepKind::LinkArgs => { force!(link_args, LOCAL_CRATE); }\n \n+        DepKind::ResolveLifetimes => { force!(resolve_lifetimes, krate!()); }\n         DepKind::NamedRegion => { force!(named_region_map, def_id!().index); }\n         DepKind::IsLateBound => { force!(is_late_bound_map, def_id!().index); }\n         DepKind::ObjectLifetimeDefaults => {"}, {"sha": "86b05955f19727c77cc5d14e9a32f674cf2d18ae", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -19,7 +19,7 @@ use rustc::session::CompileIncomplete;\n use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n-use rustc::middle::{self, stability, reachable};\n+use rustc::middle::{self, stability, reachable, resolve_lifetime};\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n@@ -928,6 +928,7 @@ pub fn default_provide(providers: &mut ty::maps::Providers) {\n     borrowck::provide(providers);\n     mir::provide(providers);\n     reachable::provide(providers);\n+    resolve_lifetime::provide(providers);\n     rustc_privacy::provide(providers);\n     DefaultTransCrate::provide(providers);\n     typeck::provide(providers);\n@@ -984,10 +985,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(control: &CompileController,\n         \"load query result cache\",\n         || rustc_incremental::load_query_result_cache(sess));\n \n-    let named_region_map = time(time_passes,\n-                                \"lifetime resolution\",\n-                                || middle::resolve_lifetime::krate(sess, cstore, &hir_map))?;\n-\n     time(time_passes,\n          \"looking for entry point\",\n          || middle::entry::find_entry_point(sess, &hir_map));\n@@ -1022,7 +1019,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(control: &CompileController,\n                              arenas,\n                              arena,\n                              resolutions,\n-                             named_region_map,\n                              hir_map,\n                              query_result_on_disk_cache,\n                              name,"}, {"sha": "2f55bee210838a55a0098de2af70c4fee74362f9", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -18,7 +18,6 @@ use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n use rustc_trans;\n use rustc::middle::region;\n-use rustc::middle::resolve_lifetime;\n use rustc::ty::subst::{Kind, Subst};\n use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -137,7 +136,6 @@ fn test_env<F>(source_string: &str,\n     let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n \n     // run just enough stuff to build a tcx:\n-    let named_region_map = resolve_lifetime::krate(&sess, &*cstore, &hir_map);\n     let (tx, _rx) = mpsc::channel();\n     let outputs = OutputFilenames {\n         out_directory: PathBuf::new(),\n@@ -153,7 +151,6 @@ fn test_env<F>(source_string: &str,\n                              &arenas,\n                              &arena,\n                              resolutions,\n-                             named_region_map.unwrap(),\n                              hir_map,\n                              OnDiskCache::new_empty(sess.codemap()),\n                              \"test_crate\","}, {"sha": "83aec27c15315d4e5af72a1873e9010753be9cb1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -140,7 +140,18 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n \n             None => {\n-                self.re_infer(lifetime.span, def).expect(\"unelided lifetime in signature\")\n+                self.re_infer(lifetime.span, def)\n+                    .unwrap_or_else(|| {\n+                        // This indicates an illegal lifetime\n+                        // elision. `resolve_lifetime` should have\n+                        // reported an error in this case -- but if\n+                        // not, let's error out.\n+                        tcx.sess.delay_span_bug(lifetime.span, \"unelided lifetime in signature\");\n+\n+                        // Supply some dummy value. We don't have an\n+                        // `re_error`, annoyingly, so use `'static`.\n+                        tcx.types.re_static\n+                    })\n             }\n         };\n "}, {"sha": "2520e3a095e1d623bb510f8e4ae125d3cf7c6ed3", "filename": "src/test/compile-fail/dep_graph_crosscontaminate_tables.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9fe7aa353fac5084d0a44d6a15970310e9be67f4/src%2Ftest%2Fcompile-fail%2Fdep_graph_crosscontaminate_tables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fe7aa353fac5084d0a44d6a15970310e9be67f4/src%2Ftest%2Fcompile-fail%2Fdep_graph_crosscontaminate_tables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdep_graph_crosscontaminate_tables.rs?ref=9fe7aa353fac5084d0a44d6a15970310e9be67f4", "patch": "@@ -1,40 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that the `TypeckTables` nodes for impl items are independent from\n-// one another.\n-\n-// compile-flags: -Z query-dep-graph\n-\n-#![feature(rustc_attrs)]\n-\n-struct Foo {\n-    x: u8\n-}\n-\n-impl Foo {\n-    // Changing the item `new`...\n-    #[rustc_if_this_changed(HirBody)]\n-    fn new() -> Foo {\n-        Foo { x: 0 }\n-    }\n-\n-    // ...should not cause us to recompute the tables for `with`!\n-    #[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path\n-    fn with(x: u8) -> Foo {\n-        Foo { x: x }\n-    }\n-}\n-\n-fn main() {\n-    let f = Foo::new();\n-    let g = Foo::with(22);\n-    assert_eq!(f.x, g.x - 22);\n-}"}, {"sha": "1204cc0df47b1e568b20444ca7e1069a9ccae372", "filename": "src/test/compile-fail/where-lifetime-resolution.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fcompile-fail%2Fwhere-lifetime-resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fcompile-fail%2Fwhere-lifetime-resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-lifetime-resolution.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Trait1 {}\n-trait Trait2 {}\n+trait Trait1<'a> {}\n+trait Trait2<'a, 'b> {}\n \n fn f() where\n     for<'a> Trait1<'a>: Trait1<'a>, // OK"}, {"sha": "6afd794de8484384aab05d5373236a383f4f6a68", "filename": "src/test/incremental/issue-42602.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fincremental%2Fissue-42602.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fincremental%2Fissue-42602.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-42602.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -16,8 +16,9 @@\n // This was fixed by improving the resolution of the `FnOnce` trait\n // selection node.\n \n-// revisions:cfail1\n+// revisions:cfail1 cfail2 cfail3\n // compile-flags:-Zquery-dep-graph\n+// must-compile-successfully\n \n #![feature(rustc_attrs)]\n \n@@ -27,16 +28,24 @@ fn main() {\n }\n \n mod a {\n-    #[rustc_if_this_changed(HirBody)]\n+    #[cfg(cfail1)]\n     pub fn foo() {\n         let x = vec![1, 2, 3];\n         let v = || ::std::mem::drop(x);\n         v();\n     }\n+\n+    #[cfg(not(cfail1))]\n+    pub fn foo() {\n+        let x = vec![1, 2, 3, 4];\n+        let v = || ::std::mem::drop(x);\n+        v();\n+    }\n }\n \n mod b {\n-    #[rustc_then_this_would_need(TypeckTables)] //[cfail1]~ ERROR no path\n+    #[rustc_clean(cfg=\"cfail2\")]\n+    #[rustc_clean(cfg=\"cfail3\")]\n     pub fn bar() {\n         let x = vec![1, 2, 3];\n         let v = || ::std::mem::drop(x);"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/anonymous.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stderr?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/anonymous.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stdout?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/multiple_types.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.stderr?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/packed.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stderr?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/repr-align.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stderr?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864"}, {"sha": "208fc2ea08957d2922e38fb2d405bffcb12116f8", "filename": "src/test/ui/rfc1598-generic-associated-types/construct_with_other_type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -23,6 +23,7 @@ trait Baz {\n impl<T> Baz for T where T: Foo {\n     type Quux<'a> = <T as Foo>::Bar<'a, 'static>;\n     //~^ ERROR undeclared lifetime\n+    //~| ERROR lifetime parameters are not allowed on this type [E0110]\n }\n \n fn main() {}"}, {"sha": "6a2047d10e6a54ad130e7bf48520372748d82de8", "filename": "src/test/ui/rfc1598-generic-associated-types/construct_with_other_type.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fconstruct_with_other_type.stderr?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -4,5 +4,11 @@ error[E0261]: use of undeclared lifetime name `'a`\n 24 |     type Quux<'a> = <T as Foo>::Bar<'a, 'static>;\n    |                                     ^^ undeclared lifetime\n \n-error: aborting due to previous error\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/construct_with_other_type.rs:24:37\n+   |\n+24 |     type Quux<'a> = <T as Foo>::Bar<'a, 'static>;\n+   |                                     ^^ lifetime parameter not allowed on this type\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "b99cb2a18309e11b1ed2961a47f94e67438cea2f", "filename": "src/test/ui/rfc1598-generic-associated-types/generic-associated-types-where.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric-associated-types-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric-associated-types-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric-associated-types-where.stderr?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -4,5 +4,5 @@ error[E0261]: use of undeclared lifetime name `'a`\n 34 |     type WithDefault<'a, T> = &'a Iterator<T>;\n    |                                ^^ undeclared lifetime\n \n-error: aborting due to previous error\n+error: cannot continue compilation due to previous error\n "}, {"sha": "219554b587a9e45adf110426b2e1b4fc22b18b2e", "filename": "src/test/ui/rfc1598-generic-associated-types/iterable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.rs?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -16,8 +16,10 @@ trait Iterable {\n     type Item<'a>;\n     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n     //~^ ERROR undeclared lifetime\n+    //~| ERROR lifetime parameters are not allowed on this type [E0110]\n \n     fn iter<'a>(&'a self) -> Self::Iter<'a>;\n+    //~^ ERROR lifetime parameters are not allowed on this type [E0110]\n }\n \n fn main() {}"}, {"sha": "fb91d38ba7a1494e220f0859f1a5775da275741e", "filename": "src/test/ui/rfc1598-generic-associated-types/iterable.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5951f8d1ba892a03a4cb7529a38c2452f5037864/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fiterable.stderr?ref=5951f8d1ba892a03a4cb7529a38c2452f5037864", "patch": "@@ -4,5 +4,17 @@ error[E0261]: use of undeclared lifetime name `'a`\n 17 |     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n    |                                               ^^ undeclared lifetime\n \n-error: aborting due to previous error\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/iterable.rs:17:47\n+   |\n+17 |     type Iter<'a>: Iterator<Item = Self::Item<'a>>;\n+   |                                               ^^ lifetime parameter not allowed on this type\n+\n+error[E0110]: lifetime parameters are not allowed on this type\n+  --> $DIR/iterable.rs:21:41\n+   |\n+21 |     fn iter<'a>(&'a self) -> Self::Iter<'a>;\n+   |                                         ^^ lifetime parameter not allowed on this type\n+\n+error: aborting due to 3 previous errors\n "}]}