{"sha": "6caa533dc7508b63c57b771b6d0195c43262c614", "node_id": "C_kwDOAAsO6NoAKDZjYWE1MzNkYzc1MDhiNjNjNTdiNzcxYjZkMDE5NWM0MzI2MmM2MTQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-27T21:32:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-27T21:32:26Z"}, "message": "Rollup merge of #93325 - tmiasko:lev, r=davidtwco\n\nIntroduce a limit to Levenshtein distance computation\n\nIncorporate distance limit from `find_best_match_for_name` directly into\nLevenshtein distance computation.\n\nUse the string size difference as a lower bound on the distance and exit\nearly when it exceeds the specified limit.\n\nAfter finding a candidate within a limit, lower the limit further to\nrestrict the search space.", "tree": {"sha": "10e326816dfdff6cb360027d726e5e82349458d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10e326816dfdff6cb360027d726e5e82349458d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6caa533dc7508b63c57b771b6d0195c43262c614", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh8w9rCRBK7hj4Ov3rIwAAjU4IAHPlkH2DYzASdjPn4rXwT5dS\ncM7PgHutQQg6CCA3Fh5qvd4S4dzrrv4y9MJvXsb2ai6dzCadR4IaeVWjxvA1oGdK\nVuVNAXn6PPC1yNP0fxLYnuPHfR6fsNruqM3RGE/5Aq3EDEeDouAUG3/cLVn+qHB2\n2vRsU5PDfJYbm4m+eujNxmjDqbCUf6jPAOU+VOAZ4XiLs+0PBOgmSbez9PDSbjbP\noZ4nKKjlpvbxnvOs/1/KO8YmUsGmzuO0wsVCTH2aP9mriKDXn+YslD88x9CwIkWk\nTCxd+RJljkbpoq8CBzXtsM3kA6YSIetqkkxdCq52zLovyZOwlCTl9ZRBu196th8=\n=0X7B\n-----END PGP SIGNATURE-----\n", "payload": "tree 10e326816dfdff6cb360027d726e5e82349458d0\nparent bc26f97394e520f4bf9237c043841fab4a27ba85\nparent 6236882127eb2a9213a58bf431399727a6c3505d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1643319146 +0100\ncommitter GitHub <noreply@github.com> 1643319146 +0100\n\nRollup merge of #93325 - tmiasko:lev, r=davidtwco\n\nIntroduce a limit to Levenshtein distance computation\n\nIncorporate distance limit from `find_best_match_for_name` directly into\nLevenshtein distance computation.\n\nUse the string size difference as a lower bound on the distance and exit\nearly when it exceeds the specified limit.\n\nAfter finding a candidate within a limit, lower the limit further to\nrestrict the search space.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6caa533dc7508b63c57b771b6d0195c43262c614", "html_url": "https://github.com/rust-lang/rust/commit/6caa533dc7508b63c57b771b6d0195c43262c614", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6caa533dc7508b63c57b771b6d0195c43262c614/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc26f97394e520f4bf9237c043841fab4a27ba85", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc26f97394e520f4bf9237c043841fab4a27ba85", "html_url": "https://github.com/rust-lang/rust/commit/bc26f97394e520f4bf9237c043841fab4a27ba85"}, {"sha": "6236882127eb2a9213a58bf431399727a6c3505d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6236882127eb2a9213a58bf431399727a6c3505d", "html_url": "https://github.com/rust-lang/rust/commit/6236882127eb2a9213a58bf431399727a6c3505d"}], "stats": {"total": 102, "additions": 60, "deletions": 42}, "files": [{"sha": "06849b3125683b5a13ddf1098c8b0df42f7fc6dd", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6caa533dc7508b63c57b771b6d0195c43262c614/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6caa533dc7508b63c57b771b6d0195c43262c614/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=6caa533dc7508b63c57b771b6d0195c43262c614", "patch": "@@ -423,7 +423,7 @@ impl<'a> Parser<'a> {\n                 // Maybe the user misspelled `macro_rules` (issue #91227)\n                 if self.token.is_ident()\n                     && path.segments.len() == 1\n-                    && lev_distance(\"macro_rules\", &path.segments[0].ident.to_string()) <= 3\n+                    && lev_distance(\"macro_rules\", &path.segments[0].ident.to_string(), 3).is_some()\n                 {\n                     err.span_suggestion(\n                         path.span,"}, {"sha": "93cf965f1056be7b1e95415e4d2d16592f73fd9b", "filename": "compiler/rustc_span/src/lev_distance.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6caa533dc7508b63c57b771b6d0195c43262c614/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6caa533dc7508b63c57b771b6d0195c43262c614/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs?ref=6caa533dc7508b63c57b771b6d0195c43262c614", "patch": "@@ -11,16 +11,21 @@ use std::cmp;\n mod tests;\n \n /// Finds the Levenshtein distance between two strings.\n-pub fn lev_distance(a: &str, b: &str) -> usize {\n-    // cases which don't require further computation\n-    if a.is_empty() {\n-        return b.chars().count();\n-    } else if b.is_empty() {\n-        return a.chars().count();\n+///\n+/// Returns None if the distance exceeds the limit.\n+pub fn lev_distance(a: &str, b: &str, limit: usize) -> Option<usize> {\n+    let n = a.chars().count();\n+    let m = b.chars().count();\n+    let min_dist = if n < m { m - n } else { n - m };\n+\n+    if min_dist > limit {\n+        return None;\n+    }\n+    if n == 0 || m == 0 {\n+        return (min_dist <= limit).then_some(min_dist);\n     }\n \n-    let mut dcol: Vec<_> = (0..=b.len()).collect();\n-    let mut t_last = 0;\n+    let mut dcol: Vec<_> = (0..=m).collect();\n \n     for (i, sc) in a.chars().enumerate() {\n         let mut current = i;\n@@ -35,10 +40,10 @@ pub fn lev_distance(a: &str, b: &str) -> usize {\n                 dcol[j + 1] = cmp::min(dcol[j + 1], dcol[j]) + 1;\n             }\n             current = next;\n-            t_last = j;\n         }\n     }\n-    dcol[t_last + 1]\n+\n+    (dcol[m] <= limit).then_some(dcol[m])\n }\n \n /// Finds the best match for a given word in the given iterator.\n@@ -51,39 +56,38 @@ pub fn lev_distance(a: &str, b: &str) -> usize {\n /// on an edge case with a lower(upper)case letters mismatch.\n #[cold]\n pub fn find_best_match_for_name(\n-    name_vec: &[Symbol],\n+    candidates: &[Symbol],\n     lookup: Symbol,\n     dist: Option<usize>,\n ) -> Option<Symbol> {\n     let lookup = lookup.as_str();\n-    let max_dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n+    let lookup_uppercase = lookup.to_uppercase();\n \n     // Priority of matches:\n     // 1. Exact case insensitive match\n     // 2. Levenshtein distance match\n     // 3. Sorted word match\n-    if let Some(case_insensitive_match) =\n-        name_vec.iter().find(|candidate| candidate.as_str().to_uppercase() == lookup.to_uppercase())\n-    {\n-        return Some(*case_insensitive_match);\n+    if let Some(c) = candidates.iter().find(|c| c.as_str().to_uppercase() == lookup_uppercase) {\n+        return Some(*c);\n     }\n-    let levenshtein_match = name_vec\n-        .iter()\n-        .filter_map(|&name| {\n-            let dist = lev_distance(lookup, name.as_str());\n-            if dist <= max_dist { Some((name, dist)) } else { None }\n-        })\n-        // Here we are collecting the next structure:\n-        // (levenshtein_match, levenshtein_distance)\n-        .fold(None, |result, (candidate, dist)| match result {\n-            None => Some((candidate, dist)),\n-            Some((c, d)) => Some(if dist < d { (candidate, dist) } else { (c, d) }),\n-        });\n-    if levenshtein_match.is_some() {\n-        levenshtein_match.map(|(candidate, _)| candidate)\n-    } else {\n-        find_match_by_sorted_words(name_vec, lookup)\n+\n+    let mut dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n+    let mut best = None;\n+    for c in candidates {\n+        match lev_distance(lookup, c.as_str(), dist) {\n+            Some(0) => return Some(*c),\n+            Some(d) => {\n+                dist = d - 1;\n+                best = Some(*c);\n+            }\n+            None => {}\n+        }\n     }\n+    if best.is_some() {\n+        return best;\n+    }\n+\n+    find_match_by_sorted_words(candidates, lookup)\n }\n \n fn find_match_by_sorted_words(iter_names: &[Symbol], lookup: &str) -> Option<Symbol> {"}, {"sha": "4e34219248d413bbc62e1364c211ca17d8c8ffbf", "filename": "compiler/rustc_span/src/lev_distance/tests.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6caa533dc7508b63c57b771b6d0195c43262c614/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6caa533dc7508b63c57b771b6d0195c43262c614/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs?ref=6caa533dc7508b63c57b771b6d0195c43262c614", "patch": "@@ -5,18 +5,26 @@ fn test_lev_distance() {\n     use std::char::{from_u32, MAX};\n     // Test bytelength agnosticity\n     for c in (0..MAX as u32).filter_map(from_u32).map(|i| i.to_string()) {\n-        assert_eq!(lev_distance(&c[..], &c[..]), 0);\n+        assert_eq!(lev_distance(&c[..], &c[..], usize::MAX), Some(0));\n     }\n \n     let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n     let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n     let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    assert_eq!(lev_distance(a, b), 1);\n-    assert_eq!(lev_distance(b, a), 1);\n-    assert_eq!(lev_distance(a, c), 2);\n-    assert_eq!(lev_distance(c, a), 2);\n-    assert_eq!(lev_distance(b, c), 1);\n-    assert_eq!(lev_distance(c, b), 1);\n+    assert_eq!(lev_distance(a, b, usize::MAX), Some(1));\n+    assert_eq!(lev_distance(b, a, usize::MAX), Some(1));\n+    assert_eq!(lev_distance(a, c, usize::MAX), Some(2));\n+    assert_eq!(lev_distance(c, a, usize::MAX), Some(2));\n+    assert_eq!(lev_distance(b, c, usize::MAX), Some(1));\n+    assert_eq!(lev_distance(c, b, usize::MAX), Some(1));\n+}\n+\n+#[test]\n+fn test_lev_distance_limit() {\n+    assert_eq!(lev_distance(\"abc\", \"abcd\", 1), Some(1));\n+    assert_eq!(lev_distance(\"abc\", \"abcd\", 0), None);\n+    assert_eq!(lev_distance(\"abc\", \"xyz\", 3), Some(3));\n+    assert_eq!(lev_distance(\"abc\", \"xyz\", 2), None);\n }\n \n #[test]"}, {"sha": "29c76027c150e622297e3d222d33d7f7d18e920e", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6caa533dc7508b63c57b771b6d0195c43262c614/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6caa533dc7508b63c57b771b6d0195c43262c614/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=6caa533dc7508b63c57b771b6d0195c43262c614", "patch": "@@ -15,6 +15,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n+#![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(negative_impls)]"}, {"sha": "3815fd1992bf318b6806873052bfc84a554df097", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6caa533dc7508b63c57b771b6d0195c43262c614/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6caa533dc7508b63c57b771b6d0195c43262c614/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=6caa533dc7508b63c57b771b6d0195c43262c614", "patch": "@@ -1904,8 +1904,13 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     .associated_items(def_id)\n                     .in_definition_order()\n                     .filter(|x| {\n-                        let dist = lev_distance(name.as_str(), x.name.as_str());\n-                        x.kind.namespace() == Namespace::ValueNS && dist > 0 && dist <= max_dist\n+                        if x.kind.namespace() != Namespace::ValueNS {\n+                            return false;\n+                        }\n+                        match lev_distance(name.as_str(), x.name.as_str(), max_dist) {\n+                            Some(d) => d > 0,\n+                            None => false,\n+                        }\n                     })\n                     .copied()\n                     .collect()"}]}