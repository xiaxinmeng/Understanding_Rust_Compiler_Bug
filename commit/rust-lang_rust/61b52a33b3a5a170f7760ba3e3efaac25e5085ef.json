{"sha": "61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxYjUyYTMzYjNhNWExNzBmNzc2MGJhM2UzZWZhYWMyNWU1MDg1ZWY=", "commit": {"author": {"name": "SNCPlay42", "email": "SNCPlay42@gmail.com", "date": "2020-09-08T04:35:24Z"}, "committer": {"name": "SNCPlay42", "email": "SNCPlay42@gmail.com", "date": "2020-11-09T16:14:40Z"}, "message": "use RegionNameHighlight for async fn and closure returns", "tree": {"sha": "b52c75b9396221fedea82fefc667db42cf7fde02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b52c75b9396221fedea82fefc667db42cf7fde02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "html_url": "https://github.com/rust-lang/rust/commit/61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/comments", "author": {"login": "SNCPlay42", "id": 5455518, "node_id": "MDQ6VXNlcjU0NTU1MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5455518?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SNCPlay42", "html_url": "https://github.com/SNCPlay42", "followers_url": "https://api.github.com/users/SNCPlay42/followers", "following_url": "https://api.github.com/users/SNCPlay42/following{/other_user}", "gists_url": "https://api.github.com/users/SNCPlay42/gists{/gist_id}", "starred_url": "https://api.github.com/users/SNCPlay42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SNCPlay42/subscriptions", "organizations_url": "https://api.github.com/users/SNCPlay42/orgs", "repos_url": "https://api.github.com/users/SNCPlay42/repos", "events_url": "https://api.github.com/users/SNCPlay42/events{/privacy}", "received_events_url": "https://api.github.com/users/SNCPlay42/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SNCPlay42", "id": 5455518, "node_id": "MDQ6VXNlcjU0NTU1MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5455518?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SNCPlay42", "html_url": "https://github.com/SNCPlay42", "followers_url": "https://api.github.com/users/SNCPlay42/followers", "following_url": "https://api.github.com/users/SNCPlay42/following{/other_user}", "gists_url": "https://api.github.com/users/SNCPlay42/gists{/gist_id}", "starred_url": "https://api.github.com/users/SNCPlay42/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SNCPlay42/subscriptions", "organizations_url": "https://api.github.com/users/SNCPlay42/orgs", "repos_url": "https://api.github.com/users/SNCPlay42/repos", "events_url": "https://api.github.com/users/SNCPlay42/events{/privacy}", "received_events_url": "https://api.github.com/users/SNCPlay42/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5042dbdb2e27b141ccc4cffc34efcf06ec24d59f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5042dbdb2e27b141ccc4cffc34efcf06ec24d59f", "html_url": "https://github.com/rust-lang/rust/commit/5042dbdb2e27b141ccc4cffc34efcf06ec24d59f"}], "stats": {"total": 212, "additions": 173, "deletions": 39}, "files": [{"sha": "2a90fb042dd7183408b0d5d72b73c14c9dff1e89", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 118, "deletions": 34, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "patch": "@@ -6,8 +6,8 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_middle::ty::print::RegionHighlightMode;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::symbol::kw;\n-use rustc_span::{symbol::Symbol, Span, DUMMY_SP};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::{Span, DUMMY_SP};\n \n use crate::borrow_check::{nll::ToRegionVid, universal_regions::DefiningTy, MirBorrowckCtxt};\n \n@@ -39,7 +39,7 @@ crate enum RegionNameSource {\n     /// The region corresponding to a closure upvar.\n     AnonRegionFromUpvar(Span, String),\n     /// The region corresponding to the return type of a closure.\n-    AnonRegionFromOutput(Span, String, String),\n+    AnonRegionFromOutput(RegionNameHighlight, String),\n     /// The region from a type yielded by a generator.\n     AnonRegionFromYieldTy(Span, String),\n     /// An anonymous region from an async fn.\n@@ -85,10 +85,10 @@ impl RegionName {\n             | RegionNameSource::NamedFreeRegion(span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(span, _)\n             | RegionNameSource::AnonRegionFromUpvar(span, _)\n-            | RegionNameSource::AnonRegionFromOutput(span, _, _)\n             | RegionNameSource::AnonRegionFromYieldTy(span, _)\n             | RegionNameSource::AnonRegionFromAsyncFn(span) => Some(span),\n-            RegionNameSource::AnonRegionFromArgument(ref highlight) => match *highlight {\n+            RegionNameSource::AnonRegionFromArgument(ref highlight)\n+            | RegionNameSource::AnonRegionFromOutput(ref highlight, _) => match *highlight {\n                 RegionNameHighlight::MatchedHirTy(span)\n                 | RegionNameHighlight::MatchedAdtAndSegment(span)\n                 | RegionNameHighlight::CannotMatchHirTy(span, _)\n@@ -117,6 +117,7 @@ impl RegionName {\n                 diag.span_label(*span, format!(\"has type `{}`\", type_name));\n             }\n             RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::MatchedHirTy(span))\n+            | RegionNameSource::AnonRegionFromOutput(RegionNameHighlight::MatchedHirTy(span), _)\n             | RegionNameSource::AnonRegionFromAsyncFn(span) => {\n                 diag.span_label(\n                     *span,\n@@ -125,6 +126,10 @@ impl RegionName {\n             }\n             RegionNameSource::AnonRegionFromArgument(\n                 RegionNameHighlight::MatchedAdtAndSegment(span),\n+            )\n+            | RegionNameSource::AnonRegionFromOutput(\n+                RegionNameHighlight::MatchedAdtAndSegment(span),\n+                _,\n             ) => {\n                 diag.span_label(*span, format!(\"let's call this `{}`\", self));\n             }\n@@ -137,13 +142,28 @@ impl RegionName {\n                     format!(\"lifetime `{}` appears in the type {}\", self, type_name),\n                 );\n             }\n+            RegionNameSource::AnonRegionFromOutput(\n+                RegionNameHighlight::Occluded(span, type_name),\n+                mir_description,\n+            ) => {\n+                diag.span_label(\n+                    *span,\n+                    format!(\n+                        \"return type{} `{}` contains a lifetime `{}`\",\n+                        mir_description, type_name, self\n+                    ),\n+                );\n+            }\n             RegionNameSource::AnonRegionFromUpvar(span, upvar_name) => {\n                 diag.span_label(\n                     *span,\n                     format!(\"lifetime `{}` appears in the type of `{}`\", self, upvar_name),\n                 );\n             }\n-            RegionNameSource::AnonRegionFromOutput(span, mir_description, type_name) => {\n+            RegionNameSource::AnonRegionFromOutput(\n+                RegionNameHighlight::CannotMatchHirTy(span, type_name),\n+                mir_description,\n+            ) => {\n                 diag.span_label(*span, format!(\"return type{} is {}\", mir_description, type_name));\n             }\n             RegionNameSource::AnonRegionFromYieldTy(span, type_name) => {\n@@ -659,67 +679,131 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// or be early bound (named, not in argument).\n     fn give_name_if_anonymous_region_appears_in_output(&self, fr: RegionVid) -> Option<RegionName> {\n         let tcx = self.infcx.tcx;\n+        let hir = tcx.hir();\n \n         let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n         debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n         if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n             return None;\n         }\n \n-        let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n-        let type_name =\n-            self.infcx.extract_inference_diagnostics_data(return_ty.into(), Some(highlight)).name;\n+        let mir_hir_id = self.mir_hir_id();\n \n-        let (return_span, mir_description) = match tcx.hir().get(self.mir_hir_id()) {\n+        let (return_span, mir_description, hir_ty) = match hir.get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n                 kind: hir::ExprKind::Closure(_, return_ty, body_id, span, _),\n                 ..\n             }) => {\n-                let mut span = match return_ty.output {\n-                    hir::FnRetTy::DefaultReturn(_) => tcx.sess.source_map().end_point(*span),\n-                    hir::FnRetTy::Return(_) => return_ty.output.span(),\n+                let (mut span, mut hir_ty) = match return_ty.output {\n+                    hir::FnRetTy::DefaultReturn(_) => {\n+                        (tcx.sess.source_map().end_point(*span), None)\n+                    }\n+                    hir::FnRetTy::Return(hir_ty) => (return_ty.output.span(), Some(hir_ty)),\n                 };\n-                let mir_description = match tcx.hir().body(*body_id).generator_kind {\n+                let mir_description = match hir.body(*body_id).generator_kind {\n                     Some(hir::GeneratorKind::Async(gen)) => match gen {\n                         hir::AsyncGeneratorKind::Block => \" of async block\",\n                         hir::AsyncGeneratorKind::Closure => \" of async closure\",\n                         hir::AsyncGeneratorKind::Fn => {\n-                            span = tcx\n-                                .hir()\n-                                .get(tcx.hir().get_parent_item(mir_hir_id))\n+                            let parent_item = hir.get(hir.get_parent_item(mir_hir_id));\n+                            let output = &parent_item\n                                 .fn_decl()\n                                 .expect(\"generator lowered from async fn should be in fn\")\n-                                .output\n-                                .span();\n+                                .output;\n+                            span = output.span();\n+                            if let hir::FnRetTy::Return(ret) = output {\n+                                hir_ty = Some(self.get_future_inner_return_ty(*ret));\n+                            }\n                             \" of async function\"\n                         }\n                     },\n                     Some(hir::GeneratorKind::Gen) => \" of generator\",\n                     None => \" of closure\",\n                 };\n-                (span, mir_description)\n+                (span, mir_description, hir_ty)\n             }\n-            hir::Node::ImplItem(hir::ImplItem {\n-                kind: hir::ImplItemKind::Fn(method_sig, _),\n-                ..\n-            }) => (method_sig.decl.output.span(), \"\"),\n-            _ => (self.body.span, \"\"),\n+            node => match node.fn_decl() {\n+                Some(fn_decl) => {\n+                    let hir_ty = match fn_decl.output {\n+                        hir::FnRetTy::DefaultReturn(_) => None,\n+                        hir::FnRetTy::Return(ty) => Some(ty),\n+                    };\n+                    (fn_decl.output.span(), \"\", hir_ty)\n+                }\n+                None => (self.body.span, \"\", None),\n+            },\n         };\n \n+        let highlight = hir_ty\n+            .and_then(|hir_ty| self.highlight_if_we_can_match_hir_ty(fr, return_ty, hir_ty))\n+            .unwrap_or_else(|| {\n+                // `highlight_if_we_cannot_match_hir_ty` needs to know the number we will give to\n+                // the anonymous region. If it succeeds, the `synthesize_region_name` call below\n+                // will increment the counter, \"reserving\" the number we just used.\n+                let counter = *self.next_region_name.try_borrow().unwrap();\n+                self.highlight_if_we_cannot_match_hir_ty(fr, return_ty, return_span, counter)\n+            });\n+\n         Some(RegionName {\n-            // This counter value will already have been used, so this function will increment it\n-            // so the next value will be used next and return the region name that would have been\n-            // used.\n             name: self.synthesize_region_name(),\n-            source: RegionNameSource::AnonRegionFromOutput(\n-                return_span,\n-                mir_description.to_string(),\n-                type_name,\n-            ),\n+            source: RegionNameSource::AnonRegionFromOutput(highlight, mir_description.to_string()),\n         })\n     }\n \n+    /// From the [`hir::Ty`] of an async function's lowered return type,\n+    /// retrieve the `hir::Ty` representing the type the user originally wrote.\n+    ///\n+    /// e.g. given the function:\n+    ///\n+    /// ```\n+    /// async fn foo() -> i32 {}\n+    /// ```\n+    ///\n+    /// this function, given the lowered return type of `foo`, an [`OpaqueDef`] that implements `Future<Output=i32>`,\n+    /// returns the `i32`.\n+    ///\n+    /// [`OpaqueDef`]: hir::TyKind::OpaqueDef\n+    fn get_future_inner_return_ty(&self, hir_ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n+        let hir = self.infcx.tcx.hir();\n+\n+        if let hir::TyKind::OpaqueDef(id, _) = hir_ty.kind {\n+            let opaque_ty = hir.item(id.id);\n+            if let hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                bounds:\n+                    [hir::GenericBound::LangItemTrait(\n+                        hir::LangItem::Future,\n+                        _,\n+                        _,\n+                        hir::GenericArgs {\n+                            bindings:\n+                                [hir::TypeBinding {\n+                                    ident: Ident { name: sym::Output, .. },\n+                                    kind: hir::TypeBindingKind::Equality { ty },\n+                                    ..\n+                                }],\n+                            ..\n+                        },\n+                    )],\n+                ..\n+            }) = opaque_ty.kind\n+            {\n+                ty\n+            } else {\n+                span_bug!(\n+                    hir_ty.span,\n+                    \"bounds from lowered return type of async fn did not match expected format: {:?}\",\n+                    opaque_ty\n+                );\n+            }\n+        } else {\n+            span_bug!(\n+                hir_ty.span,\n+                \"lowered return type of async fn is not OpaqueDef: {:?}\",\n+                hir_ty\n+            );\n+        }\n+    }\n+\n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n         fr: RegionVid,"}, {"sha": "95683241aba26738fb72c501138ccc1956f80d74", "filename": "src/test/ui/async-await/issue-74072-lifetime-name-annotations.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.rs?ref=61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "patch": "@@ -18,6 +18,14 @@ pub fn async_closure(x: &mut i32) -> impl Future<Output=&i32> {\n     })()\n }\n \n+pub fn async_closure_explicit_return_type(x: &mut i32) -> impl Future<Output=&i32> {\n+    (async move || -> &i32 {\n+        let y = &*x;\n+        *x += 1; //~ ERROR cannot assign to `*x` because it is borrowed\n+        y\n+    })()\n+}\n+\n pub fn async_block(x: &mut i32) -> impl Future<Output=&i32> {\n     async move {\n         let y = &*x;"}, {"sha": "123c3192cffba66552ab8130dbcad9643b32f0ef", "filename": "src/test/ui/async-await/issue-74072-lifetime-name-annotations.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74072-lifetime-name-annotations.stderr?ref=61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "patch": "@@ -2,7 +2,7 @@ error[E0506]: cannot assign to `*x` because it is borrowed\n   --> $DIR/issue-74072-lifetime-name-annotations.rs:9:5\n    |\n LL | pub async fn async_fn(x: &mut i32) -> &i32 {\n-   |                                       ---- return type of async function is &'1 i32\n+   |                                       - let's call the lifetime of this reference `'1`\n LL |     let y = &*x;\n    |             --- borrow of `*x` occurs here\n LL |     *x += 1;\n@@ -25,6 +25,18 @@ LL |     })()\n error[E0506]: cannot assign to `*x` because it is borrowed\n   --> $DIR/issue-74072-lifetime-name-annotations.rs:24:9\n    |\n+LL |     (async move || -> &i32 {\n+   |                       - let's call the lifetime of this reference `'1`\n+LL |         let y = &*x;\n+   |                 --- borrow of `*x` occurs here\n+LL |         *x += 1;\n+   |         ^^^^^^^ assignment to borrowed `*x` occurs here\n+LL |         y\n+   |         - returning this value requires that `*x` is borrowed for `'1`\n+\n+error[E0506]: cannot assign to `*x` because it is borrowed\n+  --> $DIR/issue-74072-lifetime-name-annotations.rs:32:9\n+   |\n LL |         let y = &*x;\n    |                 --- borrow of `*x` occurs here\n LL |         *x += 1;\n@@ -34,6 +46,6 @@ LL |         y\n LL |     }\n    |     - return type of async block is &'1 i32\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0506`."}, {"sha": "2d765eb41be07ecca0865d24d74a5250d4c3e489", "filename": "src/test/ui/async-await/issue-74497-lifetime-in-opaque.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.rs?ref=61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "patch": "@@ -0,0 +1,19 @@\n+// edition:2018\n+\n+// test that names give to anonymous lifetimes in opaque types like `impl Future` are correctly\n+// introduced in error messages\n+\n+use std::future::Future;\n+\n+pub async fn foo<F, T>(_: F)\n+where\n+    F: Fn(&u8) -> T,\n+    T: Future<Output = ()>,\n+{\n+}\n+\n+pub async fn bar(_: &u8) {}\n+\n+fn main() {\n+    let _ = foo(|x| bar(x)); //~ ERROR lifetime may not live long enough\n+}"}, {"sha": "89fe1abb3656b5c3e2eda9076c53b0528993fd65", "filename": "src/test/ui/async-await/issue-74497-lifetime-in-opaque.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-74497-lifetime-in-opaque.stderr?ref=61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "patch": "@@ -0,0 +1,11 @@\n+error: lifetime may not live long enough\n+  --> $DIR/issue-74497-lifetime-in-opaque.rs:18:21\n+   |\n+LL |     let _ = foo(|x| bar(x));\n+   |                  -- ^^^^^^ returning this value requires that `'1` must outlive `'2`\n+   |                  ||\n+   |                  |return type of closure `impl Future` contains a lifetime `'2`\n+   |                  has type `&'1 u8`\n+\n+error: aborting due to previous error\n+"}, {"sha": "a7c3b9eec73c5624cb94f2c1718ae4e81299720a", "filename": "src/test/ui/borrowck/issue-53432-nested-closure-outlives-borrowed-value.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/src%2Ftest%2Fui%2Fborrowck%2Fissue-53432-nested-closure-outlives-borrowed-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/src%2Ftest%2Fui%2Fborrowck%2Fissue-53432-nested-closure-outlives-borrowed-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-53432-nested-closure-outlives-borrowed-value.stderr?ref=61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "patch": "@@ -4,7 +4,7 @@ error: lifetime may not live long enough\n LL |     let _action = move || {\n    |                   -------\n    |                   |     |\n-   |                   |     return type of closure is [closure@$DIR/issue-53432-nested-closure-outlives-borrowed-value.rs:4:9: 4:15]\n+   |                   |     return type of closure `[closure@$DIR/issue-53432-nested-closure-outlives-borrowed-value.rs:4:9: 4:15]` contains a lifetime `'2`\n    |                   lifetime `'1` represents this closure's body\n LL |         || f() // The `nested` closure\n    |         ^^^^^^ returning this value requires that `'1` must outlive `'2`"}, {"sha": "e41ee8a89709caf48ed2af2c6b3d953c35c325a4", "filename": "src/test/ui/nll/issue-58053.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/src%2Ftest%2Fui%2Fnll%2Fissue-58053.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61b52a33b3a5a170f7760ba3e3efaac25e5085ef/src%2Ftest%2Fui%2Fnll%2Fissue-58053.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-58053.stderr?ref=61b52a33b3a5a170f7760ba3e3efaac25e5085ef", "patch": "@@ -2,9 +2,9 @@ error: lifetime may not live long enough\n   --> $DIR/issue-58053.rs:6:33\n    |\n LL |     let f = |x: &i32| -> &i32 { x };\n-   |                 -        ----   ^ returning this value requires that `'1` must outlive `'2`\n+   |                 -        -      ^ returning this value requires that `'1` must outlive `'2`\n    |                 |        |\n-   |                 |        return type of closure is &'2 i32\n+   |                 |        let's call the lifetime of this reference `'2`\n    |                 let's call the lifetime of this reference `'1`\n \n error: lifetime may not live long enough"}]}