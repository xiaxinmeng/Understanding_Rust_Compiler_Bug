{"sha": "2108b6bc9534c1991b5d13a8f8738d4013ddee08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMDhiNmJjOTUzNGMxOTkxYjVkMTNhOGY4NzM4ZDQwMTNkZGVlMDg=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-10-25T14:09:42Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-08T13:52:02Z"}, "message": "Move UndefMask and Relocations into `allocation.rs`", "tree": {"sha": "6a4826d93c62a19d96065c797d12554ac7f87053", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a4826d93c62a19d96065c797d12554ac7f87053"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2108b6bc9534c1991b5d13a8f8738d4013ddee08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2108b6bc9534c1991b5d13a8f8738d4013ddee08", "html_url": "https://github.com/rust-lang/rust/commit/2108b6bc9534c1991b5d13a8f8738d4013ddee08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2108b6bc9534c1991b5d13a8f8738d4013ddee08/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6def30ba6a4a3217f4571e5795ac8b3c269bbbb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6def30ba6a4a3217f4571e5795ac8b3c269bbbb3", "html_url": "https://github.com/rust-lang/rust/commit/6def30ba6a4a3217f4571e5795ac8b3c269bbbb3"}], "stats": {"total": 276, "additions": 138, "deletions": 138}, "files": [{"sha": "0610863310807e0a071a5c25045cc0ea397ffc4a", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 134, "deletions": 5, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/2108b6bc9534c1991b5d13a8f8738d4013ddee08/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2108b6bc9534c1991b5d13a8f8738d4013ddee08/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=2108b6bc9534c1991b5d13a8f8738d4013ddee08", "patch": "@@ -10,13 +10,13 @@\n \n //! The virtual memory representation of the MIR interpreter\n \n-use super::{\n-    UndefMask,\n-    Relocations,\n-};\n-\n use ty::layout::{Size, Align};\n use syntax::ast::Mutability;\n+use rustc_target::abi::HasDataLayout;\n+use std::iter;\n+use mir;\n+use std::ops::{Deref, DerefMut};\n+use rustc_data_structures::sorted_map::SortedMap;\n \n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Allocation<Tag=(),Extra=()> {\n@@ -103,3 +103,132 @@ impl<Tag, Extra: Default> Allocation<Tag, Extra> {\n }\n \n impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct Relocations<Tag=(), Id=AllocId>(SortedMap<Size, (Tag, Id)>);\n+\n+impl<Tag, Id> Relocations<Tag, Id> {\n+    pub fn new() -> Self {\n+        Relocations(SortedMap::new())\n+    }\n+\n+    // The caller must guarantee that the given relocations are already sorted\n+    // by address and contain no duplicates.\n+    pub fn from_presorted(r: Vec<(Size, (Tag, Id))>) -> Self {\n+        Relocations(SortedMap::from_presorted_elements(r))\n+    }\n+}\n+\n+impl<Tag> Deref for Relocations<Tag> {\n+    type Target = SortedMap<Size, (Tag, AllocId)>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl<Tag> DerefMut for Relocations<Tag> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Undefined byte tracking\n+////////////////////////////////////////////////////////////////////////////////\n+\n+type Block = u64;\n+const BLOCK_SIZE: u64 = 64;\n+\n+#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub struct UndefMask {\n+    blocks: Vec<Block>,\n+    len: Size,\n+}\n+\n+impl_stable_hash_for!(struct mir::interpret::UndefMask{blocks, len});\n+\n+impl UndefMask {\n+    pub fn new(size: Size) -> Self {\n+        let mut m = UndefMask {\n+            blocks: vec![],\n+            len: Size::ZERO,\n+        };\n+        m.grow(size, false);\n+        m\n+    }\n+\n+    /// Check whether the range `start..end` (end-exclusive) is entirely defined.\n+    ///\n+    /// Returns `Ok(())` if it's defined. Otherwise returns the index of the byte\n+    /// at which the first undefined access begins.\n+    #[inline]\n+    pub fn is_range_defined(&self, start: Size, end: Size) -> Result<(), Size> {\n+        if end > self.len {\n+            return Err(self.len);\n+        }\n+\n+        let idx = (start.bytes()..end.bytes())\n+            .map(|i| Size::from_bytes(i))\n+            .find(|&i| !self.get(i));\n+\n+        match idx {\n+            Some(idx) => Err(idx),\n+            None => Ok(())\n+        }\n+    }\n+\n+    pub fn set_range(&mut self, start: Size, end: Size, new_state: bool) {\n+        let len = self.len;\n+        if end > len {\n+            self.grow(end - len, new_state);\n+        }\n+        self.set_range_inbounds(start, end, new_state);\n+    }\n+\n+    pub fn set_range_inbounds(&mut self, start: Size, end: Size, new_state: bool) {\n+        for i in start.bytes()..end.bytes() {\n+            self.set(Size::from_bytes(i), new_state);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get(&self, i: Size) -> bool {\n+        let (block, bit) = bit_index(i);\n+        (self.blocks[block] & 1 << bit) != 0\n+    }\n+\n+    #[inline]\n+    pub fn set(&mut self, i: Size, new_state: bool) {\n+        let (block, bit) = bit_index(i);\n+        if new_state {\n+            self.blocks[block] |= 1 << bit;\n+        } else {\n+            self.blocks[block] &= !(1 << bit);\n+        }\n+    }\n+\n+    pub fn grow(&mut self, amount: Size, new_state: bool) {\n+        let unused_trailing_bits = self.blocks.len() as u64 * BLOCK_SIZE - self.len.bytes();\n+        if amount.bytes() > unused_trailing_bits {\n+            let additional_blocks = amount.bytes() / BLOCK_SIZE + 1;\n+            assert_eq!(additional_blocks as usize as u64, additional_blocks);\n+            self.blocks.extend(\n+                iter::repeat(0).take(additional_blocks as usize),\n+            );\n+        }\n+        let start = self.len;\n+        self.len += amount;\n+        self.set_range_inbounds(start, start + amount, new_state);\n+    }\n+}\n+\n+#[inline]\n+fn bit_index(bits: Size) -> (usize, usize) {\n+    let bits = bits.bytes();\n+    let a = bits / BLOCK_SIZE;\n+    let b = bits % BLOCK_SIZE;\n+    assert_eq!(a as usize as u64, a);\n+    assert_eq!(b as usize as u64, b);\n+    (a as usize, b as usize)\n+}"}, {"sha": "3f1e51b890ef3c621c8875f44fcd48c5780ecc31", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 4, "deletions": 133, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/2108b6bc9534c1991b5d13a8f8738d4013ddee08/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2108b6bc9534c1991b5d13a8f8738d4013ddee08/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=2108b6bc9534c1991b5d13a8f8738d4013ddee08", "patch": "@@ -26,20 +26,20 @@ pub use self::error::{\n \n pub use self::value::{Scalar, ConstValue};\n \n-pub use self::allocation::{Allocation, MemoryAccess};\n+pub use self::allocation::{\n+    Allocation, AllocationExtra,\n+    Relocations, UndefMask,\n+};\n \n use std::fmt;\n use mir;\n use hir::def_id::DefId;\n use ty::{self, TyCtxt, Instance};\n use ty::layout::{self, HasDataLayout, Size};\n use middle::region;\n-use std::iter;\n use std::io;\n-use std::ops::{Deref, DerefMut};\n use std::hash::Hash;\n use rustc_serialize::{Encoder, Decodable, Encodable};\n-use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{Lock as Mutex, HashMapExt};\n use rustc_data_structures::tiny_list::TinyList;\n@@ -530,35 +530,6 @@ impl<'tcx, M: fmt::Debug + Eq + Hash + Clone> AllocMap<'tcx, M> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct Relocations<Tag=(), Id=AllocId>(SortedMap<Size, (Tag, Id)>);\n-\n-impl<Tag, Id> Relocations<Tag, Id> {\n-    pub fn new() -> Self {\n-        Relocations(SortedMap::new())\n-    }\n-\n-    // The caller must guarantee that the given relocations are already sorted\n-    // by address and contain no duplicates.\n-    pub fn from_presorted(r: Vec<(Size, (Tag, Id))>) -> Self {\n-        Relocations(SortedMap::from_presorted_elements(r))\n-    }\n-}\n-\n-impl<Tag> Deref for Relocations<Tag> {\n-    type Target = SortedMap<Size, (Tag, AllocId)>;\n-\n-    fn deref(&self) -> &Self::Target {\n-        &self.0\n-    }\n-}\n-\n-impl<Tag> DerefMut for Relocations<Tag> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.0\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Methods to access integers in the target endianness\n ////////////////////////////////////////////////////////////////////////////////\n@@ -602,106 +573,6 @@ pub fn truncate(value: u128, size: Size) -> u128 {\n     (value << shift) >> shift\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Undefined byte tracking\n-////////////////////////////////////////////////////////////////////////////////\n-\n-type Block = u64;\n-const BLOCK_SIZE: u64 = 64;\n-\n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub struct UndefMask {\n-    blocks: Vec<Block>,\n-    len: Size,\n-}\n-\n-impl_stable_hash_for!(struct mir::interpret::UndefMask{blocks, len});\n-\n-impl UndefMask {\n-    pub fn new(size: Size) -> Self {\n-        let mut m = UndefMask {\n-            blocks: vec![],\n-            len: Size::ZERO,\n-        };\n-        m.grow(size, false);\n-        m\n-    }\n-\n-    /// Check whether the range `start..end` (end-exclusive) is entirely defined.\n-    ///\n-    /// Returns `Ok(())` if it's defined. Otherwise returns the index of the byte\n-    /// at which the first undefined access begins.\n-    #[inline]\n-    pub fn is_range_defined(&self, start: Size, end: Size) -> Result<(), Size> {\n-        if end > self.len {\n-            return Err(self.len);\n-        }\n-\n-        let idx = (start.bytes()..end.bytes())\n-            .map(|i| Size::from_bytes(i))\n-            .find(|&i| !self.get(i));\n-\n-        match idx {\n-            Some(idx) => Err(idx),\n-            None => Ok(())\n-        }\n-    }\n-\n-    pub fn set_range(&mut self, start: Size, end: Size, new_state: bool) {\n-        let len = self.len;\n-        if end > len {\n-            self.grow(end - len, new_state);\n-        }\n-        self.set_range_inbounds(start, end, new_state);\n-    }\n-\n-    pub fn set_range_inbounds(&mut self, start: Size, end: Size, new_state: bool) {\n-        for i in start.bytes()..end.bytes() {\n-            self.set(Size::from_bytes(i), new_state);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn get(&self, i: Size) -> bool {\n-        let (block, bit) = bit_index(i);\n-        (self.blocks[block] & 1 << bit) != 0\n-    }\n-\n-    #[inline]\n-    pub fn set(&mut self, i: Size, new_state: bool) {\n-        let (block, bit) = bit_index(i);\n-        if new_state {\n-            self.blocks[block] |= 1 << bit;\n-        } else {\n-            self.blocks[block] &= !(1 << bit);\n-        }\n-    }\n-\n-    pub fn grow(&mut self, amount: Size, new_state: bool) {\n-        let unused_trailing_bits = self.blocks.len() as u64 * BLOCK_SIZE - self.len.bytes();\n-        if amount.bytes() > unused_trailing_bits {\n-            let additional_blocks = amount.bytes() / BLOCK_SIZE + 1;\n-            assert_eq!(additional_blocks as usize as u64, additional_blocks);\n-            self.blocks.extend(\n-                iter::repeat(0).take(additional_blocks as usize),\n-            );\n-        }\n-        let start = self.len;\n-        self.len += amount;\n-        self.set_range_inbounds(start, start + amount, new_state);\n-    }\n-}\n-\n-#[inline]\n-fn bit_index(bits: Size) -> (usize, usize) {\n-    let bits = bits.bytes();\n-    let a = bits / BLOCK_SIZE;\n-    let b = bits % BLOCK_SIZE;\n-    assert_eq!(a as usize as u64, a);\n-    assert_eq!(b as usize as u64, b);\n-    (a as usize, b as usize)\n-}\n-\n #[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n pub enum ScalarMaybeUndef<Tag=(), Id=AllocId> {\n     Scalar(Scalar<Tag, Id>),"}]}