{"sha": "045105b1a2ed4d93d5e72bc34fdce55e0b3e6dad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0NTEwNWIxYTJlZDRkOTNkNWU3MmJjMzRmZGNlNTVlMGIzZTZkYWQ=", "commit": {"author": {"name": "Ashley Mannix", "email": "kodraus@hey.com", "date": "2020-11-13T04:32:03Z"}, "committer": {"name": "Ashley Mannix", "email": "kodraus@hey.com", "date": "2020-11-13T04:43:45Z"}, "message": "remove internal simd_size_and_ty from llvm backend", "tree": {"sha": "de49af4daee04cf4015254ff994c641572481835", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de49af4daee04cf4015254ff994c641572481835"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/045105b1a2ed4d93d5e72bc34fdce55e0b3e6dad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/045105b1a2ed4d93d5e72bc34fdce55e0b3e6dad", "html_url": "https://github.com/rust-lang/rust/commit/045105b1a2ed4d93d5e72bc34fdce55e0b3e6dad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/045105b1a2ed4d93d5e72bc34fdce55e0b3e6dad/comments", "author": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "540b5db6306e0e7e96fb9d8dfda94cc82f6ba3bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/540b5db6306e0e7e96fb9d8dfda94cc82f6ba3bb", "html_url": "https://github.com/rust-lang/rust/commit/540b5db6306e0e7e96fb9d8dfda94cc82f6ba3bb"}], "stats": {"total": 58, "additions": 23, "deletions": 35}, "files": [{"sha": "3df0ab5d36ca088a1348e5e91cacd550ada05156", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/045105b1a2ed4d93d5e72bc34fdce55e0b3e6dad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045105b1a2ed4d93d5e72bc34fdce55e0b3e6dad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=045105b1a2ed4d93d5e72bc34fdce55e0b3e6dad", "patch": "@@ -740,23 +740,6 @@ fn generic_simd_intrinsic(\n     llret_ty: &'ll Type,\n     span: Span,\n ) -> Result<&'ll Value, ()> {\n-    // Given a SIMD vector type `x` return the element type and the number of\n-    // elements in the vector.\n-    fn simd_ty_and_len(bx: &Builder<'a, 'll, 'tcx>, simd_ty: Ty<'tcx>) -> (Ty<'tcx>, u64) {\n-        let ty = if let ty::Adt(_def, _substs) = simd_ty.kind() {\n-            let f0_ty = bx.layout_of(simd_ty).field(bx, 0).ty;\n-            if let ty::Array(element_ty, _) = f0_ty.kind() { element_ty } else { f0_ty }\n-        } else {\n-            bug!(\"should only be called with a SIMD type\")\n-        };\n-        let count = if let abi::Abi::Vector { count, .. } = bx.layout_of(simd_ty).abi {\n-            count\n-        } else {\n-            bug!(\"should only be called with a SIMD type\")\n-        };\n-        (ty, count)\n-    }\n-\n     // macros for error handling:\n     macro_rules! emit_error {\n         ($msg: tt) => {\n@@ -809,7 +792,7 @@ fn generic_simd_intrinsic(\n             _ => return_error!(\"`{}` is not an integral type\", in_ty),\n         };\n         require_simd!(arg_tys[1], \"argument\");\n-        let (_, v_len) = simd_ty_and_len(bx, arg_tys[1]);\n+        let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         require!(\n             // Allow masks for vectors with fewer than 8 elements to be\n             // represented with a u8 or i8.\n@@ -840,11 +823,11 @@ fn generic_simd_intrinsic(\n         _ => None,\n     };\n \n-    let (in_elem, in_len) = simd_ty_and_len(bx, arg_tys[0]);\n+    let (in_len, in_elem) = arg_tys[0].simd_size_and_type(bx.tcx());\n     if let Some(cmp_op) = comparison {\n         require_simd!(ret_ty, \"return\");\n \n-        let (out_ty, out_len) = simd_ty_and_len(bx, ret_ty);\n+        let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n             \"expected return type with length {} (same as input type `{}`), \\\n@@ -878,7 +861,7 @@ fn generic_simd_intrinsic(\n \n         require_simd!(ret_ty, \"return\");\n \n-        let (out_ty, out_len) = simd_ty_and_len(bx, ret_ty);\n+        let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             out_len == n,\n             \"expected return type of length {}, found `{}` with length {}\",\n@@ -962,7 +945,7 @@ fn generic_simd_intrinsic(\n         let m_elem_ty = in_elem;\n         let m_len = in_len;\n         require_simd!(arg_tys[1], \"argument\");\n-        let (_, v_len) = simd_ty_and_len(bx, arg_tys[1]);\n+        let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         require!(\n             m_len == v_len,\n             \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n@@ -1187,8 +1170,8 @@ fn generic_simd_intrinsic(\n         require_simd!(ret_ty, \"return\");\n \n         // Of the same length:\n-        let (_, out_len) = simd_ty_and_len(bx, arg_tys[1]);\n-        let (_, out_len2) = simd_ty_and_len(bx, arg_tys[2]);\n+        let (out_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (out_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n             \"expected {} argument with length {} (same as input type `{}`), \\\n@@ -1231,8 +1214,8 @@ fn generic_simd_intrinsic(\n \n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n-        let (element_ty0, _) = simd_ty_and_len(bx, arg_tys[0]);\n-        let (element_ty1, _) = simd_ty_and_len(bx, arg_tys[1]);\n+        let (_, element_ty0) = arg_tys[0].simd_size_and_type(bx.tcx());\n+        let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n         let (pointer_count, underlying_ty) = match element_ty1.kind() {\n             ty::RawPtr(p) if p.ty == in_elem => (ptr_count(element_ty1), non_ptr(element_ty1)),\n             _ => {\n@@ -1256,7 +1239,7 @@ fn generic_simd_intrinsic(\n         assert_eq!(underlying_ty, non_ptr(element_ty0));\n \n         // The element type of the third argument must be a signed integer type of any width:\n-        let (element_ty2, _) = simd_ty_and_len(bx, arg_tys[2]);\n+        let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n         match element_ty2.kind() {\n             ty::Int(_) => (),\n             _ => {\n@@ -1316,8 +1299,8 @@ fn generic_simd_intrinsic(\n         require_simd!(arg_tys[2], \"third\");\n \n         // Of the same length:\n-        let (_, element_len1) = simd_ty_and_len(bx, arg_tys[1]);\n-        let (_, element_len2) = simd_ty_and_len(bx, arg_tys[2]);\n+        let (element_len1, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (element_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n         require!(\n             in_len == element_len1,\n             \"expected {} argument with length {} (same as input type `{}`), \\\n@@ -1357,9 +1340,9 @@ fn generic_simd_intrinsic(\n \n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n-        let (element_ty0, _element_len0) = simd_ty_and_len(bx, arg_tys[0]);\n-        let (element_ty1, _element_len1) = simd_ty_and_len(bx, arg_tys[1]);\n-        let (element_ty2, _element_len2) = simd_ty_and_len(bx, arg_tys[2]);\n+        let (_, element_ty0) = arg_tys[0].simd_size_and_type(bx.tcx());\n+        let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n         let (pointer_count, underlying_ty) = match element_ty1.kind() {\n             ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut => {\n                 (ptr_count(element_ty1), non_ptr(element_ty1))\n@@ -1589,7 +1572,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n \n     if name == sym::simd_cast {\n         require_simd!(ret_ty, \"return\");\n-        let (out_elem, out_len) = simd_ty_and_len(bx, ret_ty);\n+        let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n             \"expected return type with length {} (same as input type `{}`), \\\n@@ -1715,7 +1698,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                 return_error!(\n                     \"expected element type `{}` of vector type `{}` \\\n                      to be a signed or unsigned integer type\",\n-                    simd_ty_and_len(bx, arg_tys[0]).0,\n+                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n                     arg_tys[0]\n                 );\n             }"}, {"sha": "d1f83d0a83e0edf6d74ef48c54dd456d730f7988", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/045105b1a2ed4d93d5e72bc34fdce55e0b3e6dad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/045105b1a2ed4d93d5e72bc34fdce55e0b3e6dad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=045105b1a2ed4d93d5e72bc34fdce55e0b3e6dad", "patch": "@@ -1963,7 +1963,12 @@ impl<'tcx> TyS<'tcx> {\n         match self.kind() {\n             Adt(def, substs) => {\n                 let variant = def.non_enum_variant();\n-                (variant.fields.len() as u64, variant.fields[0].ty(tcx, substs))\n+                let f0_ty = variant.fields[0].ty(tcx, substs);\n+\n+                match f0_ty.kind() {\n+                    Array(f0_elem_ty, f0_len) => (f0_len.eval_usize(tcx, ParamEnv::empty()) as u64, f0_elem_ty),\n+                    _ => (variant.fields.len() as u64, f0_ty),\n+                }\n             }\n             _ => bug!(\"`simd_size_and_type` called on invalid type\"),\n         }"}]}