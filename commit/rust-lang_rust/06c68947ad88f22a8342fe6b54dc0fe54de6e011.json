{"sha": "06c68947ad88f22a8342fe6b54dc0fe54de6e011", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YzY4OTQ3YWQ4OGYyMmE4MzQyZmU2YjU0ZGMwZmU1NGRlNmUwMTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-29T13:53:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-29T13:53:08Z"}, "message": "Auto merge of #64158 - tmandry:libtest-panic-abort, r=alexcrichton\n\npanic=abort support in libtest\n\nAdd experimental support for tests compiled with panic=abort. Enabled with `-Z panic_abort_tests`.\n\nr? @alexcrichton\ncc @cramertj", "tree": {"sha": "a089b62086145e14456513f992702b5252bef213", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a089b62086145e14456513f992702b5252bef213"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06c68947ad88f22a8342fe6b54dc0fe54de6e011", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06c68947ad88f22a8342fe6b54dc0fe54de6e011", "html_url": "https://github.com/rust-lang/rust/commit/06c68947ad88f22a8342fe6b54dc0fe54de6e011", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06c68947ad88f22a8342fe6b54dc0fe54de6e011/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50", "url": "https://api.github.com/repos/rust-lang/rust/commits/d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50", "html_url": "https://github.com/rust-lang/rust/commit/d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50"}, {"sha": "3f0254e3cf7656bd3726372106e98532b1575e2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f0254e3cf7656bd3726372106e98532b1575e2d", "html_url": "https://github.com/rust-lang/rust/commit/3f0254e3cf7656bd3726372106e98532b1575e2d"}], "stats": {"total": 556, "additions": 438, "deletions": 118}, "files": [{"sha": "50aa036f723a0f802b774142ceec6b3774832ae1", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -1279,6 +1279,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"show extended diagnostic help\"),\n     terminal_width: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n         \"set the current terminal width\"),\n+    panic_abort_tests: bool = (false, parse_bool, [TRACKED],\n+        \"support compiling tests with panic=abort\"),\n     continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n         \"attempt to recover from parse errors (experimental)\"),\n     dep_tasks: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "8474bae5a71d207f8531b165fc13ba936eb8c2ad", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -440,6 +440,9 @@ fn configure_and_expand_inner<'a>(\n             &mut krate,\n             sess.diagnostic(),\n             &sess.features_untracked(),\n+            sess.panic_strategy(),\n+            sess.target.target.options.panic_strategy,\n+            sess.opts.debugging_opts.panic_abort_tests,\n         )\n     });\n "}, {"sha": "f79ad1419e0b1079764c89053ef2c563000563d7", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -2,6 +2,7 @@\n \n use log::debug;\n use smallvec::{smallvec, SmallVec};\n+use rustc_target::spec::PanicStrategy;\n use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::entry::{self, EntryPointType};\n@@ -25,6 +26,7 @@ struct Test {\n \n struct TestCtxt<'a> {\n     ext_cx: ExtCtxt<'a>,\n+    panic_strategy: PanicStrategy,\n     def_site: Span,\n     test_cases: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n@@ -40,6 +42,9 @@ pub fn inject(\n     krate: &mut ast::Crate,\n     span_diagnostic: &errors::Handler,\n     features: &Features,\n+    panic_strategy: PanicStrategy,\n+    platform_panic_strategy: PanicStrategy,\n+    enable_panic_abort_tests: bool,\n ) {\n     // Check for #![reexport_test_harness_main = \"some_name\"] which gives the\n     // main test function the name `some_name` without hygiene. This needs to be\n@@ -53,8 +58,22 @@ pub fn inject(\n     let test_runner = get_test_runner(span_diagnostic, &krate);\n \n     if should_test {\n+        let panic_strategy = match (panic_strategy, enable_panic_abort_tests) {\n+            (PanicStrategy::Abort, true) =>\n+                PanicStrategy::Abort,\n+            (PanicStrategy::Abort, false) if panic_strategy == platform_panic_strategy => {\n+                // Silently allow compiling with panic=abort on these platforms,\n+                // but with old behavior (abort if a test fails).\n+                PanicStrategy::Unwind\n+            }\n+            (PanicStrategy::Abort, false) => {\n+                span_diagnostic.err(\"building tests with panic=abort is not yet supported\");\n+                PanicStrategy::Unwind\n+            }\n+            (PanicStrategy::Unwind, _) => PanicStrategy::Unwind,\n+        };\n         generate_test_harness(sess, resolver, reexport_test_harness_main,\n-                              krate, features, test_runner)\n+                              krate, features, panic_strategy, test_runner)\n     }\n }\n \n@@ -183,6 +202,7 @@ fn generate_test_harness(sess: &ParseSess,\n                          reexport_test_harness_main: Option<Symbol>,\n                          krate: &mut ast::Crate,\n                          features: &Features,\n+                         panic_strategy: PanicStrategy,\n                          test_runner: Option<ast::Path>) {\n     let mut econfig = ExpansionConfig::default(\"test\".to_string());\n     econfig.features = Some(features);\n@@ -203,6 +223,7 @@ fn generate_test_harness(sess: &ParseSess,\n \n     let cx = TestCtxt {\n         ext_cx,\n+        panic_strategy,\n         def_site,\n         test_cases: Vec::new(),\n         reexport_test_harness_main,\n@@ -248,9 +269,14 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     let ecx = &cx.ext_cx;\n     let test_id = Ident::new(sym::test, sp);\n \n+    let runner_name = match cx.panic_strategy {\n+        PanicStrategy::Unwind => \"test_main_static\",\n+        PanicStrategy::Abort => \"test_main_static_abort\",\n+    };\n+\n     // test::test_main_static(...)\n     let mut test_runner = cx.test_runner.clone().unwrap_or(\n-        ecx.path(sp, vec![test_id, ecx.ident_of(\"test_main_static\", sp)]));\n+        ecx.path(sp, vec![test_id, ecx.ident_of(runner_name, sp)]));\n \n     test_runner.span = sp;\n "}, {"sha": "dd202fb3ab6faa0536b4843d7c4d2a6f9b8855f6", "filename": "src/libtest/formatters/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Flibtest%2Fformatters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Flibtest%2Fformatters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fmod.rs?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -22,3 +22,12 @@ pub(crate) trait OutputFormatter {\n     ) -> io::Result<()>;\n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool>;\n }\n+\n+pub(crate) fn write_stderr_delimiter(test_output: &mut Vec<u8>, test_name: &TestName) {\n+    match test_output.last() {\n+        Some(b'\\n') => (),\n+        Some(_) => test_output.push(b'\\n'),\n+        None => (),\n+    }\n+    write!(test_output, \"---- {} stderr ----\\n\", test_name).unwrap();\n+}"}, {"sha": "f04d289c4ef332227b1e9ef2ef333cb8ed820cbf", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 274, "deletions": 90, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -21,7 +21,8 @@\n #![unstable(feature = \"test\", issue = \"50297\")]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n #![feature(asm)]\n-#![cfg_attr(any(unix, target_os = \"cloudabi\"), feature(libc, rustc_private))]\n+#![cfg_attr(any(unix, target_os = \"cloudabi\"), feature(libc))]\n+#![feature(rustc_private)]\n #![feature(nll)]\n #![feature(set_stdio)]\n #![feature(panic_unwind)]\n@@ -34,16 +35,6 @@ use getopts;\n extern crate libc;\n use term;\n \n-// FIXME(#54291): rustc and/or LLVM don't yet support building with panic-unwind\n-//                on aarch64-pc-windows-msvc, or thumbv7a-pc-windows-msvc\n-//                so we don't link libtest against libunwind (for the time being)\n-//                even though it means that libtest won't be fully functional on\n-//                these platforms.\n-//\n-// See also: https://github.com/rust-lang/rust/issues/54190#issuecomment-422904437\n-#[cfg(not(all(windows, any(target_arch = \"aarch64\", target_arch = \"arm\"))))]\n-extern crate panic_unwind;\n-\n pub use self::ColorConfig::*;\n use self::NamePadding::*;\n use self::OutputLocation::*;\n@@ -61,10 +52,10 @@ use std::fmt;\n use std::fs::File;\n use std::io;\n use std::io::prelude::*;\n-use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo};\n use std::path::PathBuf;\n use std::process;\n-use std::process::Termination;\n+use std::process::{ExitStatus, Command, Termination};\n use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n use std::thread;\n@@ -76,13 +67,21 @@ mod tests;\n const TEST_WARN_TIMEOUT_S: u64 = 60;\n const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in quiet mode\n \n+const SECONDARY_TEST_INVOKER_VAR: &'static str = \"__RUST_TEST_INVOKE\";\n+\n+// Return codes for secondary process.\n+// Start somewhere other than 0 so we know the return code means what we think\n+// it means.\n+const TR_OK: i32 = 50;\n+const TR_FAILED: i32 = 51;\n+\n // to be used by rustc to compile tests in libtest\n pub mod test {\n     pub use crate::{\n         assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n-        Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, ShouldPanic,\n-        StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName, TestOpts,\n-        TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk,\n+        Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, RunStrategy,\n+        ShouldPanic, StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName,\n+        TestOpts, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk,\n     };\n }\n \n@@ -257,19 +256,26 @@ impl Metric {\n #[derive(Copy, Clone, Debug)]\n pub struct Options {\n     display_output: bool,\n+    panic_abort: bool,\n }\n \n impl Options {\n     pub fn new() -> Options {\n         Options {\n             display_output: false,\n+            panic_abort: false,\n         }\n     }\n \n     pub fn display_output(mut self, display_output: bool) -> Options {\n         self.display_output = display_output;\n         self\n     }\n+\n+    pub fn panic_abort(mut self, panic_abort: bool) -> Options {\n+        self.panic_abort = panic_abort;\n+        self\n+    }\n }\n \n // The default console test runner. It accepts the command line\n@@ -303,32 +309,66 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Option<Opt\n     }\n }\n \n-// A variant optimized for invocation with a static test vector.\n-// This will panic (intentionally) when fed any dynamic tests, because\n-// it is copying the static values out into a dynamic vector and cannot\n-// copy dynamic values. It is doing this because from this point on\n-// a Vec<TestDescAndFn> is used in order to effect ownership-transfer\n-// semantics into parallel test runners, which in turn requires a Vec<>\n-// rather than a &[].\n+/// A variant optimized for invocation with a static test vector.\n+/// This will panic (intentionally) when fed any dynamic tests.\n+///\n+/// This is the entry point for the main function generated by `rustc --test`\n+/// when panic=unwind.\n pub fn test_main_static(tests: &[&TestDescAndFn]) {\n     let args = env::args().collect::<Vec<_>>();\n-    let owned_tests = tests\n-        .iter()\n-        .map(|t| match t.testfn {\n-            StaticTestFn(f) => TestDescAndFn {\n-                testfn: StaticTestFn(f),\n-                desc: t.desc.clone(),\n-            },\n-            StaticBenchFn(f) => TestDescAndFn {\n-                testfn: StaticBenchFn(f),\n-                desc: t.desc.clone(),\n-            },\n-            _ => panic!(\"non-static tests passed to test::test_main_static\"),\n-        })\n-        .collect();\n+    let owned_tests: Vec<_> = tests.iter().map(make_owned_test).collect();\n     test_main(&args, owned_tests, None)\n }\n \n+/// A variant optimized for invocation with a static test vector.\n+/// This will panic (intentionally) when fed any dynamic tests.\n+///\n+/// Runs tests in panic=abort mode, which involves spawning subprocesses for\n+/// tests.\n+///\n+/// This is the entry point for the main function generated by `rustc --test`\n+/// when panic=abort.\n+pub fn test_main_static_abort(tests: &[&TestDescAndFn]) {\n+    // If we're being run in SpawnedSecondary mode, run the test here. run_test\n+    // will then exit the process.\n+    if let Ok(name) = env::var(SECONDARY_TEST_INVOKER_VAR) {\n+        let test = tests\n+            .iter()\n+            .filter(|test| test.desc.name.as_slice() == name)\n+            .map(make_owned_test)\n+            .next()\n+            .expect(\"couldn't find a test with the provided name\");\n+        let TestDescAndFn { desc, testfn } = test;\n+        let testfn = match testfn {\n+            StaticTestFn(f) => f,\n+            _ => panic!(\"only static tests are supported\"),\n+        };\n+        run_test_in_spawned_subprocess(desc, Box::new(testfn));\n+    }\n+\n+    let args = env::args().collect::<Vec<_>>();\n+    let owned_tests: Vec<_> = tests.iter().map(make_owned_test).collect();\n+    test_main(&args, owned_tests, Some(Options::new().panic_abort(true)))\n+}\n+\n+/// Clones static values for putting into a dynamic vector, which test_main()\n+/// needs to hand out ownership of tests to parallel test runners.\n+///\n+/// This will panic when fed any dynamic tests, because they cannot be cloned.\n+fn make_owned_test(test: &&TestDescAndFn) -> TestDescAndFn {\n+    match test.testfn {\n+        StaticTestFn(f) => TestDescAndFn {\n+            testfn: StaticTestFn(f),\n+            desc: test.desc.clone(),\n+        },\n+        StaticBenchFn(f) => TestDescAndFn {\n+            testfn: StaticBenchFn(f),\n+            desc: test.desc.clone(),\n+        },\n+        _ => panic!(\"non-static tests passed to test::test_main_static\"),\n+    }\n+}\n+\n /// Invoked when unit tests terminate. Should panic if the unit\n /// Tests is considered a failure. By default, invokes `report()`\n /// and checks for a `0` result.\n@@ -1062,6 +1102,18 @@ impl Write for Sink {\n     }\n }\n \n+#[derive(Clone, Copy)]\n+pub enum RunStrategy {\n+    /// Runs the test in the current process, and sends the result back over the\n+    /// supplied channel.\n+    InProcess,\n+\n+    /// Spawns a subprocess to run the test, and sends the result back over the\n+    /// supplied channel. Requires argv[0] to exist and point to the binary\n+    /// that's currently running.\n+    SpawnPrimary,\n+}\n+\n pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n where\n     F: FnMut(TestEvent) -> io::Result<()>,\n@@ -1109,6 +1161,11 @@ where\n     let mut pending = 0;\n \n     let (tx, rx) = channel::<MonitorMsg>();\n+    let run_strategy = if opts.options.panic_abort {\n+        RunStrategy::SpawnPrimary\n+    } else {\n+        RunStrategy::InProcess\n+    };\n \n     let mut running_tests: TestMap = HashMap::default();\n \n@@ -1145,7 +1202,7 @@ where\n         while !remaining.is_empty() {\n             let test = remaining.pop().unwrap();\n             callback(TeWait(test.desc.clone()))?;\n-            run_test(opts, !opts.run_tests, test, tx.clone(), Concurrent::No);\n+            run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::No);\n             let (test, result, exec_time, stdout) = rx.recv().unwrap();\n             callback(TeResult(test, result, exec_time, stdout))?;\n         }\n@@ -1156,7 +1213,7 @@ where\n                 let timeout = Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S);\n                 running_tests.insert(test.desc.clone(), timeout);\n                 callback(TeWait(test.desc.clone()))?; //here no pad\n-                run_test(opts, !opts.run_tests, test, tx.clone(), Concurrent::Yes);\n+                run_test(opts, !opts.run_tests, test, run_strategy, tx.clone(), Concurrent::Yes);\n                 pending += 1;\n             }\n \n@@ -1188,7 +1245,7 @@ where\n         // All benchmarks run at the end, in serial.\n         for b in filtered_benchs {\n             callback(TeWait(b.desc.clone()))?;\n-            run_test(opts, false, b, tx.clone(), Concurrent::No);\n+            run_test(opts, false, b, run_strategy, tx.clone(), Concurrent::No);\n             let (test, result, exec_time, stdout) = rx.recv().unwrap();\n             callback(TeResult(test, result, exec_time, stdout))?;\n         }\n@@ -1415,64 +1472,38 @@ pub fn run_test(\n     opts: &TestOpts,\n     force_ignore: bool,\n     test: TestDescAndFn,\n+    strategy: RunStrategy,\n     monitor_ch: Sender<MonitorMsg>,\n     concurrency: Concurrent,\n ) {\n     let TestDescAndFn { desc, testfn } = test;\n \n-    let ignore_because_panic_abort = cfg!(target_arch = \"wasm32\")\n+    let ignore_because_no_process_support = cfg!(target_arch = \"wasm32\")\n         && !cfg!(target_os = \"emscripten\")\n         && desc.should_panic != ShouldPanic::No;\n \n-    if force_ignore || desc.ignore || ignore_because_panic_abort {\n+    if force_ignore || desc.ignore || ignore_because_no_process_support {\n         monitor_ch.send((desc, TrIgnored, None, Vec::new())).unwrap();\n         return;\n     }\n \n     fn run_test_inner(\n         desc: TestDesc,\n-        monitor_ch: Sender<MonitorMsg>,\n         nocapture: bool,\n         report_time: bool,\n+        strategy: RunStrategy,\n+        monitor_ch: Sender<MonitorMsg>,\n         testfn: Box<dyn FnOnce() + Send>,\n         concurrency: Concurrent,\n     ) {\n-        // Buffer for capturing standard I/O\n-        let data = Arc::new(Mutex::new(Vec::new()));\n-        let data2 = data.clone();\n-\n         let name = desc.name.clone();\n-        let runtest = move || {\n-            let oldio = if !nocapture {\n-                Some((\n-                    io::set_print(Some(Box::new(Sink(data2.clone())))),\n-                    io::set_panic(Some(Box::new(Sink(data2)))),\n-                ))\n-            } else {\n-                None\n-            };\n-\n-            let start = if report_time {\n-                Some(Instant::now())\n-            } else {\n-                None\n-            };\n-            let result = catch_unwind(AssertUnwindSafe(testfn));\n-            let exec_time = start.map(|start| {\n-                let duration = start.elapsed();\n-                TestExecTime(duration)\n-            });\n-\n-            if let Some((printio, panicio)) = oldio {\n-                io::set_print(printio);\n-                io::set_panic(panicio);\n-            };\n \n-            let test_result = calc_result(&desc, result);\n-            let stdout = data.lock().unwrap().to_vec();\n-            monitor_ch\n-                .send((desc.clone(), test_result, exec_time, stdout))\n-                .unwrap();\n+        let runtest = move || {\n+            match strategy {\n+                RunStrategy::InProcess =>\n+                    run_test_in_process(desc, nocapture, report_time, testfn, monitor_ch),\n+                RunStrategy::SpawnPrimary => spawn_test_subprocess(desc, report_time, monitor_ch),\n+            }\n         };\n \n         // If the platform is single-threaded we're just going to run\n@@ -1489,31 +1520,38 @@ pub fn run_test(\n \n     match testfn {\n         DynBenchFn(bencher) => {\n+            // Benchmarks aren't expected to panic, so we run them all in-process.\n             crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n                 bencher.run(harness)\n             });\n         }\n         StaticBenchFn(benchfn) => {\n+            // Benchmarks aren't expected to panic, so we run them all in-process.\n             crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n                 (benchfn.clone())(harness)\n             });\n         }\n         DynTestFn(f) => {\n-            let cb = move || __rust_begin_short_backtrace(f);\n+            match strategy {\n+                RunStrategy::InProcess => (),\n+                _ => panic!(\"Cannot run dynamic test fn out-of-process\"),\n+            };\n             run_test_inner(\n                 desc,\n-                monitor_ch,\n                 opts.nocapture,\n                 opts.report_time,\n-                Box::new(cb),\n-                concurrency,\n-            )\n+                strategy,\n+                monitor_ch,\n+                Box::new(move || __rust_begin_short_backtrace(f)),\n+                concurrency\n+            );\n         }\n         StaticTestFn(f) => run_test_inner(\n             desc,\n-            monitor_ch,\n             opts.nocapture,\n             opts.report_time,\n+            strategy,\n+            monitor_ch,\n             Box::new(move || __rust_begin_short_backtrace(f)),\n             concurrency,\n         ),\n@@ -1526,7 +1564,9 @@ fn __rust_begin_short_backtrace<F: FnOnce()>(f: F) {\n     f()\n }\n \n-fn calc_result(desc: &TestDesc, task_result: Result<(), Box<dyn Any + Send>>) -> TestResult {\n+fn calc_result<'a>(desc: &TestDesc,\n+                   task_result: Result<(), &'a (dyn Any + 'static + Send)>)\n+-> TestResult {\n     match (&desc.should_panic, task_result) {\n         (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TrOk,\n         (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n@@ -1552,6 +1592,150 @@ fn calc_result(desc: &TestDesc, task_result: Result<(), Box<dyn Any + Send>>) ->\n     }\n }\n \n+fn get_result_from_exit_code(desc: &TestDesc, code: i32) -> TestResult {\n+    match (desc.allow_fail, code) {\n+        (_, TR_OK) => TrOk,\n+        (true, TR_FAILED) => TrAllowedFail,\n+        (false, TR_FAILED) => TrFailed,\n+        (_, _) => TrFailedMsg(format!(\"got unexpected return code {}\", code)),\n+    }\n+}\n+\n+fn run_test_in_process(desc: TestDesc,\n+                       nocapture: bool,\n+                       report_time: bool,\n+                       testfn: Box<dyn FnOnce() + Send>,\n+                       monitor_ch: Sender<MonitorMsg>) {\n+    // Buffer for capturing standard I/O\n+    let data = Arc::new(Mutex::new(Vec::new()));\n+\n+    let oldio = if !nocapture {\n+        Some((\n+            io::set_print(Some(Box::new(Sink(data.clone())))),\n+            io::set_panic(Some(Box::new(Sink(data.clone())))),\n+        ))\n+    } else {\n+        None\n+    };\n+\n+    let start = if report_time {\n+        Some(Instant::now())\n+    } else {\n+        None\n+    };\n+    let result = catch_unwind(AssertUnwindSafe(testfn));\n+    let exec_time = start.map(|start| {\n+        let duration = start.elapsed();\n+        TestExecTime(duration)\n+    });\n+\n+    if let Some((printio, panicio)) = oldio {\n+        io::set_print(printio);\n+        io::set_panic(panicio);\n+    }\n+\n+    let test_result = match result {\n+        Ok(()) => calc_result(&desc, Ok(())),\n+        Err(e) => calc_result(&desc, Err(e.as_ref())),\n+    };\n+    let stdout = data.lock().unwrap().to_vec();\n+    monitor_ch.send((desc.clone(), test_result, exec_time, stdout)).unwrap();\n+}\n+\n+fn spawn_test_subprocess(desc: TestDesc, report_time: bool, monitor_ch: Sender<MonitorMsg>) {\n+    let (result, test_output, exec_time) = (|| {\n+        let args = env::args().collect::<Vec<_>>();\n+        let current_exe = &args[0];\n+\n+        let start = if report_time {\n+            Some(Instant::now())\n+        } else {\n+            None\n+        };\n+        let output = match Command::new(current_exe)\n+            .env(SECONDARY_TEST_INVOKER_VAR, desc.name.as_slice())\n+            .output() {\n+                Ok(out) => out,\n+                Err(e) => {\n+                    let err = format!(\"Failed to spawn {} as child for test: {:?}\", args[0], e);\n+                    return (TrFailed, err.into_bytes(), None);\n+                }\n+            };\n+        let exec_time = start.map(|start| {\n+            let duration = start.elapsed();\n+            TestExecTime(duration)\n+        });\n+\n+        let std::process::Output { stdout, stderr, status } = output;\n+        let mut test_output = stdout;\n+        formatters::write_stderr_delimiter(&mut test_output, &desc.name);\n+        test_output.extend_from_slice(&stderr);\n+\n+        let result = match (|| -> Result<TestResult, String> {\n+            let exit_code = get_exit_code(status)?;\n+            Ok(get_result_from_exit_code(&desc, exit_code))\n+        })() {\n+            Ok(r) => r,\n+            Err(e) => {\n+                write!(&mut test_output, \"Unexpected error: {}\", e).unwrap();\n+                TrFailed\n+            }\n+        };\n+\n+        (result, test_output, exec_time)\n+    })();\n+\n+    monitor_ch.send((desc.clone(), result, exec_time, test_output)).unwrap();\n+}\n+\n+fn run_test_in_spawned_subprocess(desc: TestDesc, testfn: Box<dyn FnOnce() + Send>) -> ! {\n+    let builtin_panic_hook = panic::take_hook();\n+    let record_result = Arc::new(move |panic_info: Option<&'_ PanicInfo<'_>>| {\n+        let test_result = match panic_info {\n+            Some(info) => calc_result(&desc, Err(info.payload())),\n+            None => calc_result(&desc, Ok(())),\n+        };\n+\n+        // We don't support serializing TrFailedMsg, so just\n+        // print the message out to stderr.\n+        if let TrFailedMsg(msg) = &test_result {\n+            eprintln!(\"{}\", msg);\n+        }\n+\n+        if let Some(info) = panic_info {\n+            builtin_panic_hook(info);\n+        }\n+\n+        if let TrOk = test_result {\n+            process::exit(TR_OK);\n+        } else {\n+            process::exit(TR_FAILED);\n+        }\n+    });\n+    let record_result2 = record_result.clone();\n+    panic::set_hook(Box::new(move |info| record_result2(Some(&info))));\n+    testfn();\n+    record_result(None);\n+    unreachable!(\"panic=abort callback should have exited the process\")\n+}\n+\n+#[cfg(not(unix))]\n+fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n+    status.code().ok_or(\"received no exit code from child process\".into())\n+}\n+\n+#[cfg(unix)]\n+fn get_exit_code(status: ExitStatus) -> Result<i32, String> {\n+    use std::os::unix::process::ExitStatusExt;\n+    match status.code() {\n+        Some(code) => Ok(code),\n+        None => match status.signal() {\n+            Some(signal) => Err(format!(\"child process exited with signal {}\", signal)),\n+            None => Err(\"child process exited with unknown signal\".into()),\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq)]\n pub struct MetricMap(BTreeMap<String, Metric>);\n \n@@ -1700,7 +1884,9 @@ where\n }\n \n pub mod bench {\n-    use super::{BenchMode, BenchSamples, Bencher, MonitorMsg, Sender, Sink, TestDesc, TestResult};\n+    use super::{\n+        BenchMode, BenchSamples, Bencher, MonitorMsg, Sender, Sink, TestDesc, TestResult\n+    };\n     use crate::stats;\n     use std::cmp;\n     use std::io;\n@@ -1718,12 +1904,10 @@ pub mod bench {\n         };\n \n         let data = Arc::new(Mutex::new(Vec::new()));\n-        let data2 = data.clone();\n-\n         let oldio = if !nocapture {\n             Some((\n-                io::set_print(Some(Box::new(Sink(data2.clone())))),\n-                io::set_panic(Some(Box::new(Sink(data2)))),\n+                io::set_print(Some(Box::new(Sink(data.clone())))),\n+                io::set_panic(Some(Box::new(Sink(data.clone())))),\n             ))\n         } else {\n             None\n@@ -1734,7 +1918,7 @@ pub mod bench {\n         if let Some((printio, panicio)) = oldio {\n             io::set_print(printio);\n             io::set_panic(panicio);\n-        };\n+        }\n \n         let test_result = match result {\n             //bs.bench(f) {"}, {"sha": "b95fb5df710d35873be882a3900c6b8c4dd97ac7", "filename": "src/libtest/tests.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -1,7 +1,7 @@\n use super::*;\n \n use crate::test::{\n-    filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n+    filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored, RunStrategy,\n     ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailedMsg,\n     TrIgnored, TrOk,\n };\n@@ -67,7 +67,7 @@ pub fn do_not_run_ignored_tests() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res != TrOk);\n }\n@@ -85,7 +85,7 @@ pub fn ignored_tests_result_in_ignored() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrIgnored);\n }\n@@ -105,7 +105,7 @@ fn test_should_panic() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrOk);\n }\n@@ -125,7 +125,7 @@ fn test_should_panic_good_message() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrOk);\n }\n@@ -147,7 +147,7 @@ fn test_should_panic_bad_message() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n }\n@@ -165,7 +165,7 @@ fn test_should_panic_but_succeeds() {\n         testfn: DynTestFn(Box::new(f)),\n     };\n     let (tx, rx) = channel();\n-    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    run_test(&TestOpts::new(), false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, res, _, _) = rx.recv().unwrap();\n     assert!(res == TrFailedMsg(\"test did not panic as expected\".to_string()));\n }\n@@ -186,7 +186,7 @@ fn report_time_test_template(report_time: bool) -> Option<TestExecTime> {\n         ..TestOpts::new()\n     };\n     let (tx, rx) = channel();\n-    run_test(&test_opts, false, desc, tx, Concurrent::No);\n+    run_test(&test_opts, false, desc, RunStrategy::InProcess, tx, Concurrent::No);\n     let (_, _, exec_time, _) = rx.recv().unwrap();\n     exec_time\n }"}, {"sha": "bc13072612a29cec2597024af5607b572d677a04", "filename": "src/test/ui/panic-runtime/libtest-unwinds.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50/src%2Ftest%2Fui%2Fpanic-runtime%2Flibtest-unwinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50/src%2Ftest%2Fui%2Fpanic-runtime%2Flibtest-unwinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Flibtest-unwinds.rs?ref=d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50", "patch": "@@ -1,10 +0,0 @@\n-// error-pattern:is not compiled with this crate's panic strategy `abort`\n-// compile-flags:-C panic=abort\n-// ignore-wasm32-bare compiled with panic=abort by default\n-\n-#![feature(test)]\n-\n-extern crate test;\n-\n-fn main() {\n-}"}, {"sha": "704b81ae1ce089a2dbd682a8e3cfd004f892c851", "filename": "src/test/ui/panic-runtime/libtest-unwinds.stderr", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50/src%2Ftest%2Fui%2Fpanic-runtime%2Flibtest-unwinds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50/src%2Ftest%2Fui%2Fpanic-runtime%2Flibtest-unwinds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-runtime%2Flibtest-unwinds.stderr?ref=d046ffddc4bd50e04ffc3ff9f766e2ac71f74d50", "patch": "@@ -1,4 +0,0 @@\n-error: the linked panic runtime `panic_unwind` is not compiled with this crate's panic strategy `abort`\n-\n-error: aborting due to previous error\n-"}, {"sha": "f24046ff0e8d2e2355428588a48edc64dd41e92d", "filename": "src/test/ui/test-panic-abort-disabled.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftest%2Fui%2Ftest-panic-abort-disabled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftest%2Fui%2Ftest-panic-abort-disabled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-panic-abort-disabled.rs?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -0,0 +1,20 @@\n+// error-pattern:building tests with panic=abort is not yet supported\n+// no-prefer-dynamic\n+// compile-flags: --test -Cpanic=abort\n+// run-flags: --test-threads=1\n+\n+// ignore-wasm no panic or subprocess support\n+// ignore-emscripten no panic or subprocess support\n+\n+#![cfg(test)]\n+\n+#[test]\n+fn it_works() {\n+    assert_eq!(1 + 1, 2);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn it_panics() {\n+    assert_eq!(1 + 1, 4);\n+}"}, {"sha": "a8d9bad43ed3c4ae81479cb8734e092afbbc267a", "filename": "src/test/ui/test-panic-abort-disabled.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftest%2Fui%2Ftest-panic-abort-disabled.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftest%2Fui%2Ftest-panic-abort-disabled.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-panic-abort-disabled.stderr?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -0,0 +1,4 @@\n+error: building tests with panic=abort is not yet supported\n+\n+error: aborting due to previous error\n+"}, {"sha": "415ecbf7b38cd3203cdd823113fe993178ce6b9e", "filename": "src/test/ui/test-panic-abort.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftest%2Fui%2Ftest-panic-abort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftest%2Fui%2Ftest-panic-abort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-panic-abort.rs?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -0,0 +1,36 @@\n+// no-prefer-dynamic\n+// compile-flags: --test -Cpanic=abort -Zpanic_abort_tests\n+// run-flags: --test-threads=1\n+// run-fail\n+// check-run-results\n+\n+// ignore-wasm no panic or subprocess support\n+// ignore-emscripten no panic or subprocess support\n+\n+#![cfg(test)]\n+\n+use std::io::Write;\n+\n+#[test]\n+fn it_works() {\n+    assert_eq!(1 + 1, 2);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn it_panics() {\n+    assert_eq!(1 + 1, 4);\n+}\n+\n+#[test]\n+fn it_fails() {\n+    println!(\"hello, world\");\n+    writeln!(std::io::stdout(), \"testing123\").unwrap();\n+    writeln!(std::io::stderr(), \"testing321\").unwrap();\n+    assert_eq!(1 + 1, 5);\n+}\n+\n+#[test]\n+fn it_exits() {\n+    std::process::exit(123);\n+}"}, {"sha": "32c96b4f849c84c7fc51fe9bd49b0aec051e22dd", "filename": "src/test/ui/test-panic-abort.run.stdout", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftest%2Fui%2Ftest-panic-abort.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftest%2Fui%2Ftest-panic-abort.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-panic-abort.run.stdout?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -0,0 +1,29 @@\n+\n+running 4 tests\n+test it_exits ... FAILED\n+test it_fails ... FAILED\n+test it_panics ... ok\n+test it_works ... ok\n+\n+failures:\n+\n+---- it_exits stdout ----\n+---- it_exits stderr ----\n+note: got unexpected return code 123\n+---- it_fails stdout ----\n+hello, world\n+testing123\n+---- it_fails stderr ----\n+testing321\n+thread 'main' panicked at 'assertion failed: `(left == right)`\n+  left: `2`,\n+ right: `5`', $DIR/test-panic-abort.rs:30:5\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n+\n+\n+failures:\n+    it_exits\n+    it_fails\n+\n+test result: FAILED. 2 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out\n+"}, {"sha": "2358a065d62d1359d8b08ab67d4fc86fb06a9d83", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -100,6 +100,7 @@ pub enum PassMode {\n     Check,\n     Build,\n     Run,\n+    RunFail,\n }\n \n impl FromStr for PassMode {\n@@ -120,6 +121,7 @@ impl fmt::Display for PassMode {\n             PassMode::Check => \"check\",\n             PassMode::Build => \"build\",\n             PassMode::Run => \"run\",\n+            PassMode::RunFail => \"run-fail\",\n         };\n         fmt::Display::fmt(s, f)\n     }"}, {"sha": "df56448dd225df39686f1ef541cb395776f8ee5d", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -610,6 +610,11 @@ impl TestProps {\n                 panic!(\"`run-pass` header is only supported in UI tests\")\n             }\n             Some(PassMode::Run)\n+        } else if config.parse_name_directive(ln, \"run-fail\") {\n+            if config.mode != Mode::Ui {\n+                panic!(\"`run-fail` header is only supported in UI tests\")\n+            }\n+            Some(PassMode::RunFail)\n         } else {\n             None\n         };"}, {"sha": "ea31f37c7a52b7c44a756d088a9c288b39f481d2", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c68947ad88f22a8342fe6b54dc0fe54de6e011/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=06c68947ad88f22a8342fe6b54dc0fe54de6e011", "patch": "@@ -326,6 +326,14 @@ impl<'test> TestCx<'test> {\n         self.props.pass_mode(self.config)\n     }\n \n+    fn should_run(&self) -> bool {\n+        let pass_mode = self.pass_mode();\n+        match self.config.mode {\n+            Ui => pass_mode == Some(PassMode::Run) || pass_mode == Some(PassMode::RunFail),\n+            mode => panic!(\"unimplemented for mode {:?}\", mode),\n+        }\n+    }\n+\n     fn should_run_successfully(&self) -> bool {\n         let pass_mode = self.pass_mode();\n         match self.config.mode {\n@@ -1534,7 +1542,7 @@ impl<'test> TestCx<'test> {\n     fn compile_test(&self) -> ProcRes {\n         // Only use `make_exe_name` when the test ends up being executed.\n         let will_execute = match self.config.mode {\n-            Ui => self.should_run_successfully(),\n+            Ui => self.should_run(),\n             Incremental => self.revision.unwrap().starts_with(\"r\"),\n             RunFail | RunPassValgrind | MirOpt |\n             DebugInfoCdb | DebugInfoGdbLldb | DebugInfoGdb | DebugInfoLldb => true,\n@@ -3107,7 +3115,7 @@ impl<'test> TestCx<'test> {\n \n         let expected_errors = errors::load_errors(&self.testpaths.file, self.revision);\n \n-        if self.should_run_successfully() {\n+        if self.should_run() {\n             let proc_res = self.exec_compiled_test();\n             let run_output_errors = if self.props.check_run_results {\n                 self.load_compare_outputs(&proc_res, TestOutput::Run, explicit)\n@@ -3120,8 +3128,14 @@ impl<'test> TestCx<'test> {\n                     &proc_res,\n                 );\n             }\n-            if !proc_res.status.success() {\n-                self.fatal_proc_rec(\"test run failed!\", &proc_res);\n+            if self.should_run_successfully() {\n+                if !proc_res.status.success() {\n+                    self.fatal_proc_rec(\"test run failed!\", &proc_res);\n+                }\n+            } else {\n+                if proc_res.status.success() {\n+                    self.fatal_proc_rec(\"test run succeeded!\", &proc_res);\n+                }\n             }\n         }\n "}]}