{"sha": "885f9e72d742341179ff697869d6f233e4136626", "node_id": "C_kwDOAAsO6NoAKDg4NWY5ZTcyZDc0MjM0MTE3OWZmNjk3ODY5ZDZmMjMzZTQxMzY2MjY", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-02-25T13:53:42Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-02-25T15:19:13Z"}, "message": "Complete migrating `ast_passes` to derive diagnostics", "tree": {"sha": "81b9be5aebe9904aaf8abda83b2eaa0272dba49f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81b9be5aebe9904aaf8abda83b2eaa0272dba49f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/885f9e72d742341179ff697869d6f233e4136626", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/885f9e72d742341179ff697869d6f233e4136626", "html_url": "https://github.com/rust-lang/rust/commit/885f9e72d742341179ff697869d6f233e4136626", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/885f9e72d742341179ff697869d6f233e4136626/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07c993eba8b76eae497e98433ae075b00f01be10", "url": "https://api.github.com/repos/rust-lang/rust/commits/07c993eba8b76eae497e98433ae075b00f01be10", "html_url": "https://github.com/rust-lang/rust/commit/07c993eba8b76eae497e98433ae075b00f01be10"}], "stats": {"total": 1270, "additions": 833, "deletions": 437}, "files": [{"sha": "747bd52b22c7d6b14fe9ffdb88d5a4bdd4877113", "filename": "compiler/rustc_ast_passes/locales/en-US.ftl", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_ast_passes%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_ast_passes%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Flocales%2Fen-US.ftl?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -87,3 +87,150 @@ ast_passes_fn_without_body =\n     .suggestion = provide a definition for the function\n \n ast_passes_extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block\n+\n+ast_passes_bound_in_context = bounds on `type`s in {$ctx} have no effect\n+\n+ast_passes_extern_types_cannot = `type`s inside `extern` blocks cannot have {$descr}\n+    .suggestion = remove the {$remove_descr}\n+    .label = `extern` block begins here\n+\n+ast_passes_extern_keyword_link = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+ast_passes_body_in_extern = incorrect `{$kind}` inside `extern` block\n+    .cannot_have = cannot have a body\n+    .invalid = the invalid body\n+    .existing = `extern` blocks define existing foreign {$kind}s and {$kind}s inside of them cannot have a body\n+\n+ast_passes_fn_body_extern = incorrect function inside `extern` block\n+    .cannot_have = cannot have a body\n+    .suggestion = remove the invalid body\n+    .help = you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n+    .label = `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n+\n+ast_passes_extern_fn_qualifiers = functions in `extern` blocks cannot have qualifiers\n+    .label = in this `extern` block\n+    .suggestion = remove the qualifiers\n+\n+ast_passes_extern_item_ascii = items in `extern` blocks cannot use non-ascii identifiers\n+    .label = in this `extern` block\n+    .note = this limitation may be lifted in the future; see issue #83942 <https://github.com/rust-lang/rust/issues/83942> for more information\n+\n+ast_passes_bad_c_variadic = only foreign or `unsafe extern \"C\"` functions may be C-variadic\n+\n+ast_passes_item_underscore = `{$kind}` items in this context need a name\n+    .label = `_` is not a valid name for this `{$kind}` item\n+\n+ast_passes_nomangle_ascii = `#[no_mangle]` requires ASCII identifier\n+\n+ast_passes_module_nonascii = trying to load file for module `{$name}` with non-ascii identifier name\n+    .help = consider using the `#[path]` attribute to specify filesystem path\n+\n+ast_passes_auto_generic = auto traits cannot have generic parameters\n+    .label = auto trait cannot have generic parameters\n+    .suggestion = remove the parameters\n+\n+ast_passes_auto_super_lifetime = auto traits cannot have super traits or lifetime bounds\n+    .label = {ast_passes_auto_super_lifetime}\n+    .suggestion = remove the super traits or lifetime bounds\n+\n+ast_passes_auto_items = auto traits cannot have associated items\n+    .label = {ast_passes_auto_items}\n+    .suggestion = remove these associated items\n+\n+ast_passes_generic_before_constraints = generic arguments must come before the first constraint\n+    .constraints = {$constraint_len ->\n+    [one] constraint\n+    *[other] constraints\n+    }\n+    .args = generic {$args_len ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+    .empty_string = {\"\"},\n+    .suggestion = move the {$constraint_len ->\n+    [one] constraint\n+    *[other] constraints\n+    } after the generic {$args_len ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+\n+ast_passes_pattern_in_fn_pointer = patterns aren't allowed in function pointer types\n+\n+ast_passes_trait_object_single_bound = only a single explicit lifetime bound is permitted\n+\n+ast_passes_impl_trait_path = `impl Trait` is not allowed in path parameters\n+\n+ast_passes_nested_impl_trait = nested `impl Trait` is not allowed\n+    .outer = outer `impl Trait`\n+    .inner = nested `impl Trait` here\n+\n+ast_passes_at_least_one_trait = at least one trait must be specified\n+\n+ast_passes_extern_without_abi = extern declarations without an explicit ABI are deprecated\n+\n+ast_passes_out_of_order_params = {$param_ord} parameters must be declared prior to {$max_param} parameters\n+    .suggestion = reorder the parameters: lifetimes, then consts and types\n+\n+ast_passes_obsolete_auto = `impl Trait for .. {\"{}\"}` is an obsolete syntax\n+    .help = use `auto trait Trait {\"{}\"}` instead\n+\n+ast_passes_unsafe_negative_impl = negative impls cannot be unsafe\n+    .negative = negative because of this\n+    .unsafe = unsafe because of this\n+\n+ast_passes_inherent_cannot_be = inherent impls cannot be {$annotation}\n+    .because = {$annotation} because of this\n+    .type = inherent impl for this type\n+    .only_trait = only trait implementations may be annotated with {$annotation}\n+\n+ast_passes_unsafe_item = {$kind} cannot be declared unsafe\n+\n+ast_passes_fieldless_union = unions cannot have zero fields\n+\n+ast_passes_where_after_type_alias = where clauses are not allowed after the type for type aliases\n+    .note = see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information\n+\n+ast_passes_generic_default_trailing = generic parameters with a default must be trailing\n+\n+ast_passes_nested_lifetimes = nested quantification of lifetimes\n+\n+ast_passes_optional_trait_supertrait = `?Trait` is not permitted in supertraits\n+    .note = traits are `?{$path_str}` by default\n+\n+ast_passes_optional_trait_object = `?Trait` is not permitted in trait object types\n+\n+ast_passes_tilde_const_disallowed = `~const` is not allowed here\n+    .trait = trait objects cannot have `~const` trait bounds\n+    .closure = closures cannot have `~const` trait bounds\n+    .function = this function is not `const`, so it cannot have `~const` trait bounds\n+\n+ast_passes_optional_const_exclusive = `~const` and `?` are mutually exclusive\n+\n+ast_passes_const_and_async = functions cannot be both `const` and `async`\n+    .const = `const` because of this\n+    .async = `async` because of this\n+    .label = {\"\"}\n+\n+ast_passes_pattern_in_foreign = patterns aren't allowed in foreign function declarations\n+    .label = pattern not allowed in foreign function\n+\n+ast_passes_pattern_in_bodiless = patterns aren't allowed in functions without bodies\n+    .label = pattern not allowed in function without body\n+\n+ast_passes_equality_in_where = equality constraints are not yet supported in `where` clauses\n+    .label = not supported\n+    .suggestion = if `{$ident}` is an associated type you're trying to set, use the associated type binding syntax\n+    .suggestion_path = if `{$trait_segment}::{$potential_assoc}` is an associated type you're trying to set, use the associated type binding syntax\n+    .note = see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\n+\n+ast_passes_stability_outside_std = stability attributes may not be used outside of the standard library\n+\n+ast_passes_feature_on_non_nightly = `#![feature]` may not be used on the {$channel} release channel\n+    .suggestion = remove the attribute\n+    .stable_since = the feature `{$name}` has been stable since `{$since}` and no longer requires an attribute to enable\n+\n+ast_passes_incompatbile_features = `{$f1}` and `{$f2}` are incompatible, using them at the same time is not allowed\n+    .help = remove one of these features\n+\n+ast_passes_show_span = {$msg}"}, {"sha": "1c561375626cf2d3325c3370ddf57a6727605f28", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 176, "deletions": 382, "changes": 558, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -13,7 +13,6 @@ use rustc_ast::walk_list;\n use rustc_ast::*;\n use rustc_ast_pretty::pprust::{self, State};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{error_code, pluralize, struct_span_err, Applicability};\n use rustc_macros::Subdiagnostic;\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::{\n@@ -29,12 +28,9 @@ use std::mem;\n use std::ops::{Deref, DerefMut};\n use thin_vec::thin_vec;\n \n-use crate::errors::*;\n+use crate::errors;\n use crate::fluent_generated as fluent;\n \n-const MORE_EXTERN: &str =\n-    \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\";\n-\n /// Is `self` allowed semantically as the first parameter in an `FnDecl`?\n enum SelfSemantic {\n     Yes,\n@@ -134,9 +130,9 @@ impl<'a> AstValidator<'a> {\n     fn ban_let_expr(&self, expr: &'a Expr, forbidden_let_reason: ForbiddenLetReason) {\n         let sess = &self.session;\n         if sess.opts.unstable_features.is_nightly_build() {\n-            sess.emit_err(ForbiddenLet { span: expr.span, reason: forbidden_let_reason });\n+            sess.emit_err(errors::ForbiddenLet { span: expr.span, reason: forbidden_let_reason });\n         } else {\n-            sess.emit_err(ForbiddenLetStable { span: expr.span });\n+            sess.emit_err(errors::ForbiddenLetStable { span: expr.span });\n         }\n     }\n \n@@ -234,22 +230,22 @@ impl<'a> AstValidator<'a> {\n     fn check_lifetime(&self, ident: Ident) {\n         let valid_names = [kw::UnderscoreLifetime, kw::StaticLifetime, kw::Empty];\n         if !valid_names.contains(&ident.name) && ident.without_first_quote().is_reserved() {\n-            self.session.emit_err(KeywordLifetime { span: ident.span });\n+            self.session.emit_err(errors::KeywordLifetime { span: ident.span });\n         }\n     }\n \n     fn check_label(&self, ident: Ident) {\n         if ident.without_first_quote().is_reserved() {\n-            self.session.emit_err(InvalidLabel { span: ident.span, name: ident.name });\n+            self.session.emit_err(errors::InvalidLabel { span: ident.span, name: ident.name });\n         }\n     }\n \n-    fn invalid_visibility(&self, vis: &Visibility, note: Option<InvalidVisibilityNote>) {\n+    fn invalid_visibility(&self, vis: &Visibility, note: Option<errors::InvalidVisibilityNote>) {\n         if let VisibilityKind::Inherited = vis.kind {\n             return;\n         }\n \n-        self.session.emit_err(InvalidVisibility {\n+        self.session.emit_err(errors::InvalidVisibility {\n             span: vis.span,\n             implied: vis.kind.is_pub().then_some(vis.span),\n             note,\n@@ -270,7 +266,7 @@ impl<'a> AstValidator<'a> {\n \n     fn check_trait_fn_not_const(&self, constness: Const) {\n         if let Const::Yes(span) = constness {\n-            self.session.emit_err(TraitFnConst { span });\n+            self.session.emit_err(errors::TraitFnConst { span });\n         }\n     }\n \n@@ -287,21 +283,21 @@ impl<'a> AstValidator<'a> {\n         let max_num_args: usize = u16::MAX.into();\n         if fn_decl.inputs.len() > max_num_args {\n             let Param { span, .. } = fn_decl.inputs[0];\n-            self.session.emit_fatal(FnParamTooMany { span, max_num_args });\n+            self.session.emit_fatal(errors::FnParamTooMany { span, max_num_args });\n         }\n     }\n \n     fn check_decl_cvaradic_pos(&self, fn_decl: &FnDecl) {\n         match &*fn_decl.inputs {\n             [Param { ty, span, .. }] => {\n                 if let TyKind::CVarArgs = ty.kind {\n-                    self.session.emit_err(FnParamCVarArgsOnly { span: *span });\n+                    self.session.emit_err(errors::FnParamCVarArgsOnly { span: *span });\n                 }\n             }\n             [ps @ .., _] => {\n                 for Param { ty, span, .. } in ps {\n                     if let TyKind::CVarArgs = ty.kind {\n-                        self.session.emit_err(FnParamCVarArgsNotLast { span: *span });\n+                        self.session.emit_err(errors::FnParamCVarArgsNotLast { span: *span });\n                     }\n                 }\n             }\n@@ -328,25 +324,25 @@ impl<'a> AstValidator<'a> {\n             })\n             .for_each(|attr| {\n                 if attr.is_doc_comment() {\n-                    self.session.emit_err(FnParamDocComment { span: attr.span });\n+                    self.session.emit_err(errors::FnParamDocComment { span: attr.span });\n                 } else {\n-                    self.session.emit_err(FnParamForbiddenAttr { span: attr.span });\n+                    self.session.emit_err(errors::FnParamForbiddenAttr { span: attr.span });\n                 }\n             });\n     }\n \n     fn check_decl_self_param(&self, fn_decl: &FnDecl, self_semantic: SelfSemantic) {\n         if let (SelfSemantic::No, [param, ..]) = (self_semantic, &*fn_decl.inputs) {\n             if param.is_self() {\n-                self.session.emit_err(FnParamForbiddenSelf { span: param.span });\n+                self.session.emit_err(errors::FnParamForbiddenSelf { span: param.span });\n             }\n         }\n     }\n \n     fn check_defaultness(&self, span: Span, defaultness: Defaultness) {\n         if let Defaultness::Default(def_span) = defaultness {\n             let span = self.session.source_map().guess_head_span(span);\n-            self.session.emit_err(ForbiddenDefault { span, def_span });\n+            self.session.emit_err(errors::ForbiddenDefault { span, def_span });\n         }\n     }\n \n@@ -369,27 +365,17 @@ impl<'a> AstValidator<'a> {\n             [b0] => b0.span(),\n             [b0, .., bl] => b0.span().to(bl.span()),\n         };\n-        self.err_handler()\n-            .struct_span_err(span, &format!(\"bounds on `type`s in {} have no effect\", ctx))\n-            .emit();\n+        self.err_handler().emit_err(errors::BoundInContext { span, ctx });\n     }\n \n     fn check_foreign_ty_genericless(&self, generics: &Generics, where_span: Span) {\n         let cannot_have = |span, descr, remove_descr| {\n-            self.err_handler()\n-                .struct_span_err(\n-                    span,\n-                    &format!(\"`type`s inside `extern` blocks cannot have {}\", descr),\n-                )\n-                .span_suggestion(\n-                    span,\n-                    &format!(\"remove the {}\", remove_descr),\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .span_label(self.current_extern_span(), \"`extern` block begins here\")\n-                .note(MORE_EXTERN)\n-                .emit();\n+            self.err_handler().emit_err(errors::ExternTypesCannotHave {\n+                span,\n+                descr,\n+                remove_descr,\n+                block_span: self.current_extern_span(),\n+            });\n         };\n \n         if !generics.params.is_empty() {\n@@ -405,47 +391,24 @@ impl<'a> AstValidator<'a> {\n         let Some(body) = body else {\n             return;\n         };\n-        self.err_handler()\n-            .struct_span_err(ident.span, &format!(\"incorrect `{}` inside `extern` block\", kind))\n-            .span_label(ident.span, \"cannot have a body\")\n-            .span_label(body, \"the invalid body\")\n-            .span_label(\n-                self.current_extern_span(),\n-                format!(\n-                    \"`extern` blocks define existing foreign {0}s and {0}s \\\n-                    inside of them cannot have a body\",\n-                    kind\n-                ),\n-            )\n-            .note(MORE_EXTERN)\n-            .emit();\n+        self.err_handler().emit_err(errors::BodyInExtern {\n+            span: ident.span,\n+            body,\n+            block: self.current_extern_span(),\n+            kind,\n+        });\n     }\n \n     /// An `fn` in `extern { ... }` cannot have a body `{ ... }`.\n     fn check_foreign_fn_bodyless(&self, ident: Ident, body: Option<&Block>) {\n         let Some(body) = body else {\n             return;\n         };\n-        self.err_handler()\n-            .struct_span_err(ident.span, \"incorrect function inside `extern` block\")\n-            .span_label(ident.span, \"cannot have a body\")\n-            .span_suggestion(\n-                body.span,\n-                \"remove the invalid body\",\n-                \";\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .help(\n-                \"you might have meant to write a function accessible through FFI, \\\n-                which can be done by writing `extern fn` outside of the `extern` block\",\n-            )\n-            .span_label(\n-                self.current_extern_span(),\n-                \"`extern` blocks define existing foreign functions and functions \\\n-                inside of them cannot have a body\",\n-            )\n-            .note(MORE_EXTERN)\n-            .emit();\n+        self.err_handler().emit_err(errors::FnBodyInExtern {\n+            span: ident.span,\n+            body: body.span,\n+            block: self.current_extern_span(),\n+        });\n     }\n \n     fn current_extern_span(&self) -> Span {\n@@ -455,34 +418,21 @@ impl<'a> AstValidator<'a> {\n     /// An `fn` in `extern { ... }` cannot have qualifiers, e.g. `async fn`.\n     fn check_foreign_fn_headerless(&self, ident: Ident, span: Span, header: FnHeader) {\n         if header.has_qualifiers() {\n-            self.err_handler()\n-                .struct_span_err(ident.span, \"functions in `extern` blocks cannot have qualifiers\")\n-                .span_label(self.current_extern_span(), \"in this `extern` block\")\n-                .span_suggestion_verbose(\n-                    span.until(ident.span.shrink_to_lo()),\n-                    \"remove the qualifiers\",\n-                    \"fn \",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.err_handler().emit_err(errors::FnQualifierInExtern {\n+                span: ident.span,\n+                block: self.current_extern_span(),\n+                sugg_span: span.until(ident.span.shrink_to_lo()),\n+            });\n         }\n     }\n \n     /// An item in `extern { ... }` cannot use non-ascii identifier.\n     fn check_foreign_item_ascii_only(&self, ident: Ident) {\n         if !ident.as_str().is_ascii() {\n-            let n = 83942;\n-            self.err_handler()\n-                .struct_span_err(\n-                    ident.span,\n-                    \"items in `extern` blocks cannot use non-ascii identifiers\",\n-                )\n-                .span_label(self.current_extern_span(), \"in this `extern` block\")\n-                .note(&format!(\n-                    \"this limitation may be lifted in the future; see issue #{} <https://github.com/rust-lang/rust/issues/{}> for more information\",\n-                    n, n,\n-                ))\n-                .emit();\n+            self.err_handler().emit_err(errors::ExternItemAscii {\n+                span: ident.span,\n+                block: self.current_extern_span(),\n+            });\n         }\n     }\n \n@@ -505,12 +455,7 @@ impl<'a> AstValidator<'a> {\n \n         for Param { ty, span, .. } in &fk.decl().inputs {\n             if let TyKind::CVarArgs = ty.kind {\n-                self.err_handler()\n-                    .struct_span_err(\n-                        *span,\n-                        \"only foreign or `unsafe extern \\\"C\\\"` functions may be C-variadic\",\n-                    )\n-                    .emit();\n+                self.err_handler().emit_err(errors::BadCVariadic { span: *span });\n             }\n         }\n     }\n@@ -519,75 +464,32 @@ impl<'a> AstValidator<'a> {\n         if ident.name != kw::Underscore {\n             return;\n         }\n-        self.err_handler()\n-            .struct_span_err(ident.span, &format!(\"`{}` items in this context need a name\", kind))\n-            .span_label(ident.span, format!(\"`_` is not a valid name for this `{}` item\", kind))\n-            .emit();\n+        self.err_handler().emit_err(errors::ItemUnderscore { span: ident.span, kind });\n     }\n \n     fn check_nomangle_item_asciionly(&self, ident: Ident, item_span: Span) {\n         if ident.name.as_str().is_ascii() {\n             return;\n         }\n-        let head_span = self.session.source_map().guess_head_span(item_span);\n-        struct_span_err!(\n-            self.session,\n-            head_span,\n-            E0754,\n-            \"`#[no_mangle]` requires ASCII identifier\"\n-        )\n-        .emit();\n+        let span = self.session.source_map().guess_head_span(item_span);\n+        self.session.emit_err(errors::NoMangleAscii { span });\n     }\n \n     fn check_mod_file_item_asciionly(&self, ident: Ident) {\n         if ident.name.as_str().is_ascii() {\n             return;\n         }\n-        struct_span_err!(\n-            self.session,\n-            ident.span,\n-            E0754,\n-            \"trying to load file for module `{}` with non-ascii identifier name\",\n-            ident.name\n-        )\n-        .help(\"consider using `#[path]` attribute to specify filesystem path\")\n-        .emit();\n+        self.session.emit_err(errors::ModuleNonAscii { span: ident.span, name: ident.name });\n     }\n \n-    fn deny_generic_params(&self, generics: &Generics, ident_span: Span) {\n+    fn deny_generic_params(&self, generics: &Generics, ident: Span) {\n         if !generics.params.is_empty() {\n-            struct_span_err!(\n-                self.session,\n-                generics.span,\n-                E0567,\n-                \"auto traits cannot have generic parameters\"\n-            )\n-            .span_label(ident_span, \"auto trait cannot have generic parameters\")\n-            .span_suggestion(\n-                generics.span,\n-                \"remove the parameters\",\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.session.emit_err(errors::AutoTraitGeneric { span: generics.span, ident });\n         }\n     }\n \n-    fn emit_e0568(&self, span: Span, ident_span: Span) {\n-        struct_span_err!(\n-            self.session,\n-            span,\n-            E0568,\n-            \"auto traits cannot have super traits or lifetime bounds\"\n-        )\n-        .span_label(ident_span, \"auto trait cannot have super traits or lifetime bounds\")\n-        .span_suggestion(\n-            span,\n-            \"remove the super traits or lifetime bounds\",\n-            \"\",\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+    fn emit_e0568(&self, span: Span, ident: Span) {\n+        self.session.emit_err(errors::AutoTraitBounds { span, ident });\n     }\n \n     fn deny_super_traits(&self, bounds: &GenericBounds, ident_span: Span) {\n@@ -603,24 +505,11 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn deny_items(&self, trait_items: &[P<AssocItem>], ident_span: Span) {\n+    fn deny_items(&self, trait_items: &[P<AssocItem>], ident: Span) {\n         if !trait_items.is_empty() {\n             let spans: Vec<_> = trait_items.iter().map(|i| i.ident.span).collect();\n-            let total_span = trait_items.first().unwrap().span.to(trait_items.last().unwrap().span);\n-            struct_span_err!(\n-                self.session,\n-                spans,\n-                E0380,\n-                \"auto traits cannot have associated items\"\n-            )\n-            .span_suggestion(\n-                total_span,\n-                \"remove these associated items\",\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .span_label(ident_span, \"auto trait cannot have associated items\")\n-            .emit();\n+            let total = trait_items.first().unwrap().span.to(trait_items.last().unwrap().span);\n+            self.session.emit_err(errors::AutoTraitItems { spans, total, ident });\n         }\n     }\n \n@@ -666,43 +555,25 @@ impl<'a> AstValidator<'a> {\n         let args_len = arg_spans.len();\n         let constraint_len = constraint_spans.len();\n         // ...and then error:\n-        self.err_handler()\n-            .struct_span_err(\n-                arg_spans.clone(),\n-                \"generic arguments must come before the first constraint\",\n-            )\n-            .span_label(constraint_spans[0], &format!(\"constraint{}\", pluralize!(constraint_len)))\n-            .span_label(\n-                *arg_spans.iter().last().unwrap(),\n-                &format!(\"generic argument{}\", pluralize!(args_len)),\n-            )\n-            .span_labels(constraint_spans, \"\")\n-            .span_labels(arg_spans, \"\")\n-            .span_suggestion_verbose(\n-                data.span,\n-                &format!(\n-                    \"move the constraint{} after the generic argument{}\",\n-                    pluralize!(constraint_len),\n-                    pluralize!(args_len)\n-                ),\n-                self.correct_generic_order_suggestion(&data),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.err_handler().emit_err(errors::ArgsBeforeConstraint {\n+            arg_spans: arg_spans.clone(),\n+            constraints: constraint_spans[0],\n+            args: *arg_spans.iter().last().unwrap(),\n+            data: data.span,\n+            constraint_spans: errors::EmptyLabelManySpans(constraint_spans),\n+            arg_spans2: errors::EmptyLabelManySpans(arg_spans),\n+            suggestion: self.correct_generic_order_suggestion(&data),\n+            constraint_len,\n+            args_len,\n+        });\n     }\n \n     fn visit_ty_common(&mut self, ty: &'a Ty) {\n         match &ty.kind {\n             TyKind::BareFn(bfty) => {\n                 self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n                 Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n-                    struct_span_err!(\n-                        self.session,\n-                        span,\n-                        E0561,\n-                        \"patterns aren't allowed in function pointer types\"\n-                    )\n-                    .emit();\n+                    self.session.emit_err(errors::PatternFnPointer { span });\n                 });\n                 if let Extern::Implicit(_) = bfty.ext {\n                     let sig_span = self.session.source_map().next_point(ty.span.shrink_to_lo());\n@@ -714,13 +585,8 @@ impl<'a> AstValidator<'a> {\n                 for bound in bounds {\n                     if let GenericBound::Outlives(lifetime) = bound {\n                         if any_lifetime_bounds {\n-                            struct_span_err!(\n-                                self.session,\n-                                lifetime.ident.span,\n-                                E0226,\n-                                \"only a single explicit lifetime bound is permitted\"\n-                            )\n-                            .emit();\n+                            self.session\n+                                .emit_err(errors::TraitObjectBound { span: lifetime.ident.span });\n                             break;\n                         }\n                         any_lifetime_bounds = true;\n@@ -729,29 +595,19 @@ impl<'a> AstValidator<'a> {\n             }\n             TyKind::ImplTrait(_, bounds) => {\n                 if self.is_impl_trait_banned {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0667,\n-                        \"`impl Trait` is not allowed in path parameters\"\n-                    )\n-                    .emit();\n+                    self.session.emit_err(errors::ImplTraitPath { span: ty.span });\n                 }\n \n                 if let Some(outer_impl_trait_sp) = self.outer_impl_trait {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0666,\n-                        \"nested `impl Trait` is not allowed\"\n-                    )\n-                    .span_label(outer_impl_trait_sp, \"outer `impl Trait`\")\n-                    .span_label(ty.span, \"nested `impl Trait` here\")\n-                    .emit();\n+                    self.session.emit_err(errors::NestedImplTrait {\n+                        span: ty.span,\n+                        outer: outer_impl_trait_sp,\n+                        inner: ty.span,\n+                    });\n                 }\n \n                 if !bounds.iter().any(|b| matches!(b, GenericBound::Trait(..))) {\n-                    self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n+                    self.err_handler().emit_err(errors::AtLeastOneTrait { span: ty.span });\n                 }\n             }\n             _ => {}\n@@ -772,7 +628,7 @@ impl<'a> AstValidator<'a> {\n                 MISSING_ABI,\n                 id,\n                 span,\n-                \"extern declarations without an explicit ABI are deprecated\",\n+                fluent::ast_passes_extern_without_abi,\n                 BuiltinLintDiagnostics::MissingAbi(span, abi::Abi::FALLBACK),\n             )\n         }\n@@ -845,20 +701,13 @@ fn validate_generic_param_order(\n         ordered_params += \">\";\n \n         for (param_ord, (max_param, spans)) in &out_of_order {\n-            let mut err = handler.struct_span_err(\n-                spans.clone(),\n-                &format!(\n-                    \"{} parameters must be declared prior to {} parameters\",\n-                    param_ord, max_param,\n-                ),\n-            );\n-            err.span_suggestion(\n-                span,\n-                \"reorder the parameters: lifetimes, then consts and types\",\n-                &ordered_params,\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n+            handler.emit_err(errors::OutOfOrderParams {\n+                spans: spans.clone(),\n+                sugg_span: span,\n+                param_ord,\n+                max_param,\n+                ordered_params: &ordered_params,\n+            });\n         }\n     }\n }\n@@ -972,25 +821,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.with_in_trait_impl(true, Some(*constness), |this| {\n                     this.invalid_visibility(&item.vis, None);\n                     if let TyKind::Err = self_ty.kind {\n-                        this.err_handler()\n-                            .struct_span_err(\n-                                item.span,\n-                                \"`impl Trait for .. {}` is an obsolete syntax\",\n-                            )\n-                            .help(\"use `auto trait Trait {}` instead\")\n-                            .emit();\n+                        this.err_handler().emit_err(errors::ObsoleteAuto { span: item.span });\n                     }\n                     if let (&Unsafe::Yes(span), &ImplPolarity::Negative(sp)) = (unsafety, polarity)\n                     {\n-                        struct_span_err!(\n-                            this.session,\n-                            sp.to(t.path.span),\n-                            E0198,\n-                            \"negative impls cannot be unsafe\"\n-                        )\n-                        .span_label(sp, \"negative because of this\")\n-                        .span_label(span, \"unsafe because of this\")\n-                        .emit();\n+                        this.session.emit_err(errors::UnsafeNegativeImpl {\n+                            span: sp.to(t.path.span),\n+                            negative: sp,\n+                            r#unsafe: span,\n+                        });\n                     }\n \n                     this.visit_vis(&item.vis);\n@@ -1018,52 +857,54 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self_ty,\n                 items: _,\n             }) => {\n-                let error = |annotation_span, annotation| {\n-                    let mut err = self.err_handler().struct_span_err(\n-                        self_ty.span,\n-                        &format!(\"inherent impls cannot be {}\", annotation),\n-                    );\n-                    err.span_label(annotation_span, &format!(\"{} because of this\", annotation));\n-                    err.span_label(self_ty.span, \"inherent impl for this type\");\n-                    err\n-                };\n+                let error =\n+                    |annotation_span, annotation, only_trait: bool| errors::InherentImplCannot {\n+                        span: self_ty.span,\n+                        annotation_span,\n+                        annotation,\n+                        self_ty: self_ty.span,\n+                        only_trait: only_trait.then_some(()),\n+                    };\n \n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(InvalidVisibilityNote::IndividualImplItems),\n+                    Some(errors::InvalidVisibilityNote::IndividualImplItems),\n                 );\n                 if let &Unsafe::Yes(span) = unsafety {\n-                    error(span, \"unsafe\").code(error_code!(E0197)).emit();\n+                    self.err_handler().emit_err(errors::InherentImplCannotUnsafe {\n+                        span: self_ty.span,\n+                        annotation_span: span,\n+                        annotation: \"unsafe\",\n+                        self_ty: self_ty.span,\n+                    });\n                 }\n                 if let &ImplPolarity::Negative(span) = polarity {\n-                    error(span, \"negative\").emit();\n+                    self.err_handler().emit_err(error(span, \"negative\", false));\n                 }\n                 if let &Defaultness::Default(def_span) = defaultness {\n-                    error(def_span, \"`default`\")\n-                        .note(\"only trait implementations may be annotated with `default`\")\n-                        .emit();\n+                    self.err_handler().emit_err(error(def_span, \"`default`\", true));\n                 }\n                 if let &Const::Yes(span) = constness {\n-                    error(span, \"`const`\")\n-                        .note(\"only trait implementations may be annotated with `const`\")\n-                        .emit();\n+                    self.err_handler().emit_err(error(span, \"`const`\", true));\n                 }\n             }\n             ItemKind::Fn(box Fn { defaultness, sig, generics, body }) => {\n                 self.check_defaultness(item.span, *defaultness);\n \n                 if body.is_none() {\n-                    self.session.emit_err(FnWithoutBody {\n+                    self.session.emit_err(errors::FnWithoutBody {\n                         span: item.span,\n                         replace_span: self.ending_semi_or_hi(item.span),\n                         extern_block_suggestion: match sig.header.ext {\n                             Extern::None => None,\n-                            Extern::Implicit(start_span) => Some(ExternBlockSuggestion::Implicit {\n-                                start_span,\n-                                end_span: item.span.shrink_to_hi(),\n-                            }),\n+                            Extern::Implicit(start_span) => {\n+                                Some(errors::ExternBlockSuggestion::Implicit {\n+                                    start_span,\n+                                    end_span: item.span.shrink_to_hi(),\n+                                })\n+                            }\n                             Extern::Explicit(abi, start_span) => {\n-                                Some(ExternBlockSuggestion::Explicit {\n+                                Some(errors::ExternBlockSuggestion::Explicit {\n                                     start_span,\n                                     end_span: item.span.shrink_to_hi(),\n                                     abi: abi.symbol_unescaped,\n@@ -1085,10 +926,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 let old_item = mem::replace(&mut self.extern_mod, Some(item));\n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(InvalidVisibilityNote::IndividualForeignItems),\n+                    Some(errors::InvalidVisibilityNote::IndividualForeignItems),\n                 );\n                 if let &Unsafe::Yes(span) = unsafety {\n-                    self.err_handler().span_err(span, \"extern block cannot be declared unsafe\");\n+                    self.err_handler().emit_err(errors::UnsafeItem { span, kind: \"extern block\" });\n                 }\n                 if abi.is_none() {\n                     self.maybe_lint_missing_abi(item.span, item.id);\n@@ -1128,7 +969,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Mod(unsafety, mod_kind) => {\n                 if let &Unsafe::Yes(span) = unsafety {\n-                    self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n+                    self.err_handler().emit_err(errors::UnsafeItem { span, kind: \"module\" });\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n                 if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _))\n@@ -1139,40 +980,34 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Union(vdata, ..) => {\n                 if vdata.fields().is_empty() {\n-                    self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n+                    self.err_handler().emit_err(errors::FieldlessUnion { span: item.span });\n                 }\n             }\n             ItemKind::Const(def, .., None) => {\n                 self.check_defaultness(item.span, *def);\n-                self.session.emit_err(ConstWithoutBody {\n+                self.session.emit_err(errors::ConstWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n                 });\n             }\n             ItemKind::Static(.., None) => {\n-                self.session.emit_err(StaticWithoutBody {\n+                self.session.emit_err(errors::StaticWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n                 });\n             }\n             ItemKind::TyAlias(box TyAlias { defaultness, where_clauses, bounds, ty, .. }) => {\n                 self.check_defaultness(item.span, *defaultness);\n                 if ty.is_none() {\n-                    self.session.emit_err(TyAliasWithoutBody {\n+                    self.session.emit_err(errors::TyAliasWithoutBody {\n                         span: item.span,\n                         replace_span: self.ending_semi_or_hi(item.span),\n                     });\n                 }\n                 self.check_type_no_bounds(bounds, \"this context\");\n                 if where_clauses.1.0 {\n-                    let mut err = self.err_handler().struct_span_err(\n-                        where_clauses.1.1,\n-                        \"where clauses are not allowed after the type for type aliases\",\n-                    );\n-                    err.note(\n-                        \"see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information\",\n-                    );\n-                    err.emit();\n+                    self.err_handler()\n+                        .emit_err(errors::WhereAfterTypeAlias { span: where_clauses.1.1 });\n                 }\n             }\n             _ => {}\n@@ -1254,11 +1089,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                     if let Some(span) = prev_param_default {\n-                        let mut err = self.err_handler().struct_span_err(\n-                            span,\n-                            \"generic parameters with a default must be trailing\",\n-                        );\n-                        err.emit();\n+                        self.err_handler().emit_err(errors::GenericDefaultTrailing { span });\n                         break;\n                     }\n                 }\n@@ -1286,13 +1117,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                             match bound {\n                                 GenericBound::Trait(t, _) => {\n                                     if !t.bound_generic_params.is_empty() {\n-                                        struct_span_err!(\n-                                            self.err_handler(),\n-                                            t.span,\n-                                            E0316,\n-                                            \"nested quantification of lifetimes\"\n-                                        )\n-                                        .emit();\n+                                        self.err_handler()\n+                                            .emit_err(errors::NestedLifetimes { span: t.span });\n                                     }\n                                 }\n                                 GenericBound::Outlives(_) => {}\n@@ -1317,32 +1143,27 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         if let GenericBound::Trait(poly, modify) = bound {\n             match (ctxt, modify) {\n                 (BoundKind::SuperTraits, TraitBoundModifier::Maybe) => {\n-                    let mut err = self\n-                        .err_handler()\n-                        .struct_span_err(poly.span, \"`?Trait` is not permitted in supertraits\");\n-                    let path_str = pprust::path_to_string(&poly.trait_ref.path);\n-                    err.note(&format!(\"traits are `?{}` by default\", path_str));\n-                    err.emit();\n+                    self.err_handler().emit_err(errors::OptionalTraitSupertrait {\n+                        span: poly.span,\n+                        path_str: pprust::path_to_string(&poly.trait_ref.path)\n+                    });\n                 }\n                 (BoundKind::TraitObject, TraitBoundModifier::Maybe) => {\n-                    let mut err = self.err_handler().struct_span_err(\n-                        poly.span,\n-                        \"`?Trait` is not permitted in trait object types\",\n-                    );\n-                    err.emit();\n+                    self.err_handler().emit_err(errors::OptionalTraitObject {span: poly.span});\n                 }\n                 (_, TraitBoundModifier::MaybeConst) if let Some(reason) = &self.disallow_tilde_const => {\n-                    let mut err = self.err_handler().struct_span_err(bound.span(), \"`~const` is not allowed here\");\n-                    match reason {\n-                        DisallowTildeConstContext::TraitObject => err.note(\"trait objects cannot have `~const` trait bounds\"),\n-                        DisallowTildeConstContext::Fn(FnKind::Closure(..)) => err.note(\"closures cannot have `~const` trait bounds\"),\n-                        DisallowTildeConstContext::Fn(FnKind::Fn(_, ident, ..)) => err.span_note(ident.span, \"this function is not `const`, so it cannot have `~const` trait bounds\"),\n+                    let reason = match reason {\n+                        DisallowTildeConstContext::TraitObject => errors::TildeConstReason::TraitObject,\n+                        DisallowTildeConstContext::Fn(FnKind::Closure(..)) => errors::TildeConstReason::Closure,\n+                        DisallowTildeConstContext::Fn(FnKind::Fn(_, ident, ..)) => errors::TildeConstReason::Function { ident: ident.span },\n                     };\n-                    err.emit();\n+                    self.err_handler().emit_err(errors::TildeConstDisallowed {\n+                        span: bound.span(),\n+                        reason\n+                    });\n                 }\n                 (_, TraitBoundModifier::MaybeConstMaybe) => {\n-                    self.err_handler()\n-                        .span_err(bound.span(), \"`~const` and `?` are mutually exclusive\");\n+                    self.err_handler().emit_err(errors::OptionalConstExclusive {span: bound.span()});\n                 }\n                 _ => {}\n             }\n@@ -1362,21 +1183,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         self.check_c_variadic_type(fk);\n \n         // Functions cannot both be `const async`\n-        if let Some(FnHeader {\n+        if let Some(&FnHeader {\n             constness: Const::Yes(cspan),\n             asyncness: Async::Yes { span: aspan, .. },\n             ..\n         }) = fk.header()\n         {\n-            self.err_handler()\n-                .struct_span_err(\n-                    vec![*cspan, *aspan],\n-                    \"functions cannot be both `const` and `async`\",\n-                )\n-                .span_label(*cspan, \"`const` because of this\")\n-                .span_label(*aspan, \"`async` because of this\")\n-                .span_label(span, \"\") // Point at the fn header.\n-                .emit();\n+            self.err_handler().emit_err(errors::ConstAndAsync {\n+                spans: vec![cspan, aspan],\n+                cspan,\n+                aspan,\n+                span,\n+            });\n         }\n \n         if let FnKind::Fn(\n@@ -1394,20 +1212,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         // Functions without bodies cannot have patterns.\n         if let FnKind::Fn(ctxt, _, sig, _, _, None) = fk {\n             Self::check_decl_no_pat(&sig.decl, |span, ident, mut_ident| {\n-                let (code, msg, label) = match ctxt {\n-                    FnCtxt::Foreign => (\n-                        error_code!(E0130),\n-                        \"patterns aren't allowed in foreign function declarations\",\n-                        \"pattern not allowed in foreign function\",\n-                    ),\n-                    _ => (\n-                        error_code!(E0642),\n-                        \"patterns aren't allowed in functions without bodies\",\n-                        \"pattern not allowed in function without body\",\n-                    ),\n-                };\n                 if mut_ident && matches!(ctxt, FnCtxt::Assoc(_)) {\n                     if let Some(ident) = ident {\n+                        let msg = match ctxt {\n+                            FnCtxt::Foreign => fluent::ast_passes_pattern_in_foreign,\n+                            _ => fluent::ast_passes_pattern_in_bodiless,\n+                        };\n                         let diag = BuiltinLintDiagnostics::PatternsInFnsWithoutBody(span, ident);\n                         self.lint_buffer.buffer_lint_with_diagnostic(\n                             PATTERNS_IN_FNS_WITHOUT_BODY,\n@@ -1418,11 +1228,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         )\n                     }\n                 } else {\n-                    self.err_handler()\n-                        .struct_span_err(span, msg)\n-                        .span_label(span, label)\n-                        .code(code)\n-                        .emit();\n+                    match ctxt {\n+                        FnCtxt::Foreign => {\n+                            self.err_handler().emit_err(errors::PatternInForeign { span })\n+                        }\n+                        _ => self.err_handler().emit_err(errors::PatternInBodiless { span }),\n+                    };\n                 }\n             });\n         }\n@@ -1449,15 +1260,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             match &item.kind {\n                 AssocItemKind::Const(_, _, body) => {\n                     if body.is_none() {\n-                        self.session.emit_err(AssocConstWithoutBody {\n+                        self.session.emit_err(errors::AssocConstWithoutBody {\n                             span: item.span,\n                             replace_span: self.ending_semi_or_hi(item.span),\n                         });\n                     }\n                 }\n                 AssocItemKind::Fn(box Fn { body, .. }) => {\n                     if body.is_none() {\n-                        self.session.emit_err(AssocFnWithoutBody {\n+                        self.session.emit_err(errors::AssocFnWithoutBody {\n                             span: item.span,\n                             replace_span: self.ending_semi_or_hi(item.span),\n                         });\n@@ -1472,7 +1283,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     ..\n                 }) => {\n                     if ty.is_none() {\n-                        self.session.emit_err(AssocTypeWithoutBody {\n+                        self.session.emit_err(errors::AssocTypeWithoutBody {\n                             span: item.span,\n                             replace_span: self.ending_semi_or_hi(item.span),\n                         });\n@@ -1544,11 +1355,7 @@ fn deny_equality_constraints(\n     predicate: &WhereEqPredicate,\n     generics: &Generics,\n ) {\n-    let mut err = this.err_handler().struct_span_err(\n-        predicate.span,\n-        \"equality constraints are not yet supported in `where` clauses\",\n-    );\n-    err.span_label(predicate.span, \"not supported\");\n+    let mut err = errors::EqualityInWhere { span: predicate.span, assoc: None, assoc2: None };\n \n     // Given `<A as Foo>::Bar = RhsTy`, suggest `A: Foo<Bar = RhsTy>`.\n     if let TyKind::Path(Some(qself), full_path) = &predicate.lhs_ty.kind {\n@@ -1592,20 +1399,12 @@ fn deny_equality_constraints(\n                                             .into();\n                                         }\n                                     }\n-                                    err.span_suggestion_verbose(\n-                                        predicate.span,\n-                                        &format!(\n-                                            \"if `{}` is an associated type you're trying to set, \\\n-                                            use the associated type binding syntax\",\n-                                            ident\n-                                        ),\n-                                        format!(\n-                                            \"{}: {}\",\n-                                            param,\n-                                            pprust::path_to_string(&assoc_path)\n-                                        ),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n+                                    err.assoc = Some(errors::AssociatedSuggestion {\n+                                        span: predicate.span,\n+                                        ident: *ident,\n+                                        param: *param,\n+                                        path: pprust::path_to_string(&assoc_path),\n+                                    })\n                                 }\n                                 _ => {}\n                             };\n@@ -1647,26 +1446,21 @@ fn deny_equality_constraints(\n                                         trait_segment.span().shrink_to_hi(),\n                                     ),\n                                 };\n-                                err.multipart_suggestion(\n-                                    &format!(\n-                                        \"if `{}::{}` is an associated type you're trying to set, \\\n-                                        use the associated type binding syntax\",\n-                                        trait_segment.ident, potential_assoc.ident,\n-                                    ),\n-                                    vec![(span, args), (predicate.span, String::new())],\n-                                    Applicability::MaybeIncorrect,\n-                                );\n+                                err.assoc2 = Some(errors::AssociatedSuggestion2 {\n+                                    span,\n+                                    args,\n+                                    predicate: predicate.span,\n+                                    trait_segment: trait_segment.ident,\n+                                    potential_assoc: potential_assoc.ident,\n+                                });\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n     }\n-    err.note(\n-        \"see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\",\n-    );\n-    err.emit();\n+    this.err_handler().emit_err(err);\n }\n \n pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) -> bool {"}, {"sha": "d007097d91818b6c705b7ad3d34ddbf60139be52", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 475, "deletions": 1, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -1,9 +1,12 @@\n //! Errors emitted by ast_passes.\n \n+use rustc_ast::ParamKindOrd;\n+use rustc_errors::AddToDiagnostic;\n use rustc_macros::{Diagnostic, Subdiagnostic};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::{symbol::Ident, Span, Symbol};\n \n use crate::ast_validation::ForbiddenLetReason;\n+use crate::fluent_generated as fluent;\n \n #[derive(Diagnostic)]\n #[diag(ast_passes_forbidden_let)]\n@@ -217,3 +220,474 @@ pub enum ExternBlockSuggestion {\n         abi: Symbol,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_bound_in_context)]\n+pub struct BoundInContext<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ctx: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_extern_types_cannot)]\n+#[note(ast_passes_extern_keyword_link)]\n+pub struct ExternTypesCannotHave<'a> {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+    pub descr: &'a str,\n+    pub remove_descr: &'a str,\n+    #[label]\n+    pub block_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_body_in_extern)]\n+#[note(ast_passes_extern_keyword_link)]\n+pub struct BodyInExtern<'a> {\n+    #[primary_span]\n+    #[label(ast_passes_cannot_have)]\n+    pub span: Span,\n+    #[label(ast_passes_invalid)]\n+    pub body: Span,\n+    #[label(ast_passes_existing)]\n+    pub block: Span,\n+    pub kind: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_fn_body_extern)]\n+#[help]\n+#[note(ast_passes_extern_keyword_link)]\n+pub struct FnBodyInExtern {\n+    #[primary_span]\n+    #[label(ast_passes_cannot_have)]\n+    pub span: Span,\n+    #[suggestion(code = \";\", applicability = \"maybe-incorrect\")]\n+    pub body: Span,\n+    #[label]\n+    pub block: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_extern_fn_qualifiers)]\n+pub struct FnQualifierInExtern {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub block: Span,\n+    #[suggestion(code = \"fn \", applicability = \"maybe-incorrect\", style = \"verbose\")]\n+    pub sugg_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_extern_item_ascii)]\n+#[note]\n+pub struct ExternItemAscii {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub block: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_bad_c_variadic)]\n+pub struct BadCVariadic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_item_underscore)]\n+pub struct ItemUnderscore<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub kind: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_nomangle_ascii, code = \"E0754\")]\n+pub struct NoMangleAscii {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_module_nonascii, code = \"E0754\")]\n+#[help]\n+pub struct ModuleNonAscii {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_auto_generic, code = \"E0567\")]\n+pub struct AutoTraitGeneric {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[label]\n+    pub ident: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_auto_super_lifetime, code = \"E0568\")]\n+pub struct AutoTraitBounds {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[label]\n+    pub ident: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_auto_items, code = \"E0380\")]\n+pub struct AutoTraitItems {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub total: Span,\n+    #[label]\n+    pub ident: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_generic_before_constraints)]\n+pub struct ArgsBeforeConstraint {\n+    #[primary_span]\n+    pub arg_spans: Vec<Span>,\n+    #[label(ast_passes_constraints)]\n+    pub constraints: Span,\n+    #[label(ast_passes_args)]\n+    pub args: Span,\n+    #[suggestion(code = \"{suggestion}\", applicability = \"machine-applicable\", style = \"verbose\")]\n+    pub data: Span,\n+    pub suggestion: String,\n+    pub constraint_len: usize,\n+    pub args_len: usize,\n+    #[subdiagnostic]\n+    pub constraint_spans: EmptyLabelManySpans,\n+    #[subdiagnostic]\n+    pub arg_spans2: EmptyLabelManySpans,\n+}\n+\n+pub struct EmptyLabelManySpans(pub Vec<Span>);\n+\n+// The derive for `Vec<Span>` does multiple calls to `span_label`, adding commas between each\n+impl AddToDiagnostic for EmptyLabelManySpans {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.span_labels(self.0, \"\");\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_pattern_in_fn_pointer, code = \"E0561\")]\n+pub struct PatternFnPointer {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_trait_object_single_bound, code = \"E0226\")]\n+pub struct TraitObjectBound {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_impl_trait_path, code = \"E0667\")]\n+pub struct ImplTraitPath {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_nested_impl_trait, code = \"E0666\")]\n+pub struct NestedImplTrait {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_outer)]\n+    pub outer: Span,\n+    #[label(ast_passes_inner)]\n+    pub inner: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_at_least_one_trait)]\n+pub struct AtLeastOneTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_out_of_order_params)]\n+pub struct OutOfOrderParams<'a> {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[suggestion(code = \"{ordered_params}\", applicability = \"machine-applicable\")]\n+    pub sugg_span: Span,\n+    pub param_ord: &'a ParamKindOrd,\n+    pub max_param: &'a ParamKindOrd,\n+    pub ordered_params: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_obsolete_auto)]\n+#[help]\n+pub struct ObsoleteAuto {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_unsafe_negative_impl, code = \"E0198\")]\n+pub struct UnsafeNegativeImpl {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_negative)]\n+    pub negative: Span,\n+    #[label(ast_passes_unsafe)]\n+    pub r#unsafe: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_inherent_cannot_be)]\n+pub struct InherentImplCannot<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_because)]\n+    pub annotation_span: Span,\n+    pub annotation: &'a str,\n+    #[label(ast_passes_type)]\n+    pub self_ty: Span,\n+    #[note(ast_passes_only_trait)]\n+    pub only_trait: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_inherent_cannot_be, code = \"E0197\")]\n+pub struct InherentImplCannotUnsafe<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_because)]\n+    pub annotation_span: Span,\n+    pub annotation: &'a str,\n+    #[label(ast_passes_type)]\n+    pub self_ty: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_unsafe_item)]\n+pub struct UnsafeItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_fieldless_union)]\n+pub struct FieldlessUnion {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_where_after_type_alias)]\n+#[note]\n+pub struct WhereAfterTypeAlias {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_generic_default_trailing)]\n+pub struct GenericDefaultTrailing {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_nested_lifetimes, code = \"E0316\")]\n+pub struct NestedLifetimes {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_optional_trait_supertrait)]\n+#[note]\n+pub struct OptionalTraitSupertrait {\n+    #[primary_span]\n+    pub span: Span,\n+    pub path_str: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_optional_trait_object)]\n+pub struct OptionalTraitObject {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_tilde_const_disallowed)]\n+pub struct TildeConstDisallowed {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub reason: TildeConstReason,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum TildeConstReason {\n+    #[note(ast_passes_trait)]\n+    TraitObject,\n+    #[note(ast_passes_closure)]\n+    Closure,\n+    #[note(ast_passes_function)]\n+    Function {\n+        #[primary_span]\n+        ident: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_optional_const_exclusive)]\n+pub struct OptionalConstExclusive {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_const_and_async)]\n+pub struct ConstAndAsync {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[label(ast_passes_const)]\n+    pub cspan: Span,\n+    #[label(ast_passes_async)]\n+    pub aspan: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_pattern_in_foreign, code = \"E0130\")]\n+pub struct PatternInForeign {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_pattern_in_bodiless, code = \"E0642\")]\n+pub struct PatternInBodiless {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_equality_in_where)]\n+#[note]\n+pub struct EqualityInWhere {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub assoc: Option<AssociatedSuggestion>,\n+    #[subdiagnostic]\n+    pub assoc2: Option<AssociatedSuggestion2>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    ast_passes_suggestion,\n+    code = \"{param}: {path}\",\n+    style = \"verbose\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct AssociatedSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ident: Ident,\n+    pub param: Ident,\n+    pub path: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(ast_passes_suggestion_path, applicability = \"maybe-incorrect\")]\n+pub struct AssociatedSuggestion2 {\n+    #[suggestion_part(code = \"{args}\")]\n+    pub span: Span,\n+    pub args: String,\n+    #[suggestion_part(code = \"\")]\n+    pub predicate: Span,\n+    pub trait_segment: Ident,\n+    pub potential_assoc: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_stability_outside_std, code = \"E0734\")]\n+pub struct StabilityOutsideStd {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_feature_on_non_nightly, code = \"E0554\")]\n+pub struct FeatureOnNonNightly {\n+    #[primary_span]\n+    pub span: Span,\n+    pub channel: &'static str,\n+    #[subdiagnostic]\n+    pub stable_features: Vec<StableFeature>,\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub sugg: Option<Span>,\n+}\n+\n+pub struct StableFeature {\n+    pub name: Symbol,\n+    pub since: Symbol,\n+}\n+\n+impl AddToDiagnostic for StableFeature {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"name\", self.name);\n+        diag.set_arg(\"since\", self.since);\n+        diag.help(fluent::ast_passes_stable_since);\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_incompatbile_features)]\n+#[help]\n+pub struct IncompatibleFeatures {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    pub f1: Symbol,\n+    pub f2: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_show_span)]\n+pub struct ShowSpan {\n+    #[primary_span]\n+    pub span: Span,\n+    pub msg: &'static str,\n+}"}, {"sha": "926b0da2ec610a70a0c5896abc32b3195048485f", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 15, "deletions": 39, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -2,7 +2,7 @@ use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd};\n-use rustc_errors::{struct_span_err, Applicability, StashKey};\n+use rustc_errors::{Applicability, StashKey};\n use rustc_feature::{AttributeGate, BuiltinAttribute, Features, GateIssue, BUILTIN_ATTRIBUTE_MAP};\n use rustc_session::parse::{feature_err, feature_err_issue, feature_warn};\n use rustc_session::Session;\n@@ -13,7 +13,7 @@ use rustc_target::spec::abi;\n use thin_vec::ThinVec;\n use tracing::debug;\n \n-use crate::errors::ForbiddenLifetimeBound;\n+use crate::errors;\n \n macro_rules! gate_feature_fn {\n     ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $help: expr) => {{\n@@ -164,7 +164,7 @@ impl<'a> PostExpansionVisitor<'a> {\n         for param in params {\n             if !param.bounds.is_empty() {\n                 let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-                self.sess.emit_err(ForbiddenLifetimeBound { spans });\n+                self.sess.emit_err(errors::ForbiddenLifetimeBound { spans });\n             }\n         }\n     }\n@@ -218,13 +218,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 || attr.has_name(sym::rustc_const_stable)\n                 || attr.has_name(sym::rustc_default_body_unstable)\n             {\n-                struct_span_err!(\n-                    self.sess,\n-                    attr.span,\n-                    E0734,\n-                    \"stability attributes may not be used outside of the standard library\",\n-                )\n-                .emit();\n+                self.sess.emit_err(errors::StabilityOutsideStd { span: attr.span });\n             }\n         }\n     }\n@@ -635,13 +629,13 @@ fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n             return;\n         }\n         for attr in krate.attrs.iter().filter(|attr| attr.has_name(sym::feature)) {\n-            let mut err = struct_span_err!(\n-                sess.parse_sess.span_diagnostic,\n-                attr.span,\n-                E0554,\n-                \"`#![feature]` may not be used on the {} release channel\",\n-                option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\")\n-            );\n+            let mut err = errors::FeatureOnNonNightly {\n+                span: attr.span,\n+                channel: option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\"),\n+                stable_features: vec![],\n+                sugg: None,\n+            };\n+\n             let mut all_stable = true;\n             for ident in\n                 attr.meta_item_list().into_iter().flatten().flat_map(|nested| nested.ident())\n@@ -652,24 +646,15 @@ fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n                     .flat_map(|&(feature, _, since)| if feature == name { since } else { None })\n                     .next();\n                 if let Some(since) = stable_since {\n-                    err.help(&format!(\n-                        \"the feature `{}` has been stable since {} and no longer requires \\\n-                                  an attribute to enable\",\n-                        name, since\n-                    ));\n+                    err.stable_features.push(errors::StableFeature { name, since });\n                 } else {\n                     all_stable = false;\n                 }\n             }\n             if all_stable {\n-                err.span_suggestion(\n-                    attr.span,\n-                    \"remove the attribute\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n+                err.sugg = Some(attr.span);\n             }\n-            err.emit();\n+            sess.parse_sess.span_diagnostic.emit_err(err);\n         }\n     }\n }\n@@ -692,16 +677,7 @@ fn check_incompatible_features(sess: &Session) {\n             if let Some((f2_name, f2_span)) = declared_features.clone().find(|(name, _)| name == f2)\n             {\n                 let spans = vec![f1_span, f2_span];\n-                sess.struct_span_err(\n-                    spans,\n-                    &format!(\n-                        \"features `{}` and `{}` are incompatible, using them at the same time \\\n-                        is not allowed\",\n-                        f1_name, f2_name\n-                    ),\n-                )\n-                .help(\"remove one of these features\")\n-                .emit();\n+                sess.emit_err(errors::IncompatibleFeatures { spans, f1: f1_name, f2: f2_name });\n             }\n         }\n     }"}, {"sha": "b9dcaee2373d2f049035383ecde336230b96157f", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -10,6 +10,8 @@\n #![feature(iter_is_partitioned)]\n #![feature(let_chains)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_macros::fluent_messages;"}, {"sha": "280cf3284c38ccd4940902c8c6346a7059ba7603", "filename": "compiler/rustc_ast_passes/src/show_span.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -9,6 +9,8 @@ use rustc_ast as ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n \n+use crate::errors;\n+\n enum Mode {\n     Expression,\n     Pattern,\n@@ -36,21 +38,21 @@ struct ShowSpanVisitor<'a> {\n impl<'a> Visitor<'a> for ShowSpanVisitor<'a> {\n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         if let Mode::Expression = self.mode {\n-            self.span_diagnostic.span_warn(e.span, \"expression\");\n+            self.span_diagnostic.emit_warning(errors::ShowSpan { span: e.span, msg: \"expression\" });\n         }\n         visit::walk_expr(self, e);\n     }\n \n     fn visit_pat(&mut self, p: &'a ast::Pat) {\n         if let Mode::Pattern = self.mode {\n-            self.span_diagnostic.span_warn(p.span, \"pattern\");\n+            self.span_diagnostic.emit_warning(errors::ShowSpan { span: p.span, msg: \"pattern\" });\n         }\n         visit::walk_pat(self, p);\n     }\n \n     fn visit_ty(&mut self, t: &'a ast::Ty) {\n         if let Mode::Type = self.mode {\n-            self.span_diagnostic.span_warn(t.span, \"type\");\n+            self.span_diagnostic.emit_warning(errors::ShowSpan { span: t.span, msg: \"type\" });\n         }\n         visit::walk_ty(self, t);\n     }"}, {"sha": "e82bad67b21ecc122043dc34ff5eceb5c857f0c0", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -54,6 +54,7 @@ macro_rules! into_diagnostic_arg_using_display {\n }\n \n into_diagnostic_arg_using_display!(\n+    ast::ParamKindOrd,\n     i8,\n     u8,\n     i16,"}, {"sha": "89b63d23d4c8eeabbf0fde0f67ccb416678508ee", "filename": "tests/ui/auto-traits/auto-trait-validation.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fauto-traits%2Fauto-trait-validation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fauto-traits%2Fauto-trait-validation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Fauto-trait-validation.stderr?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -12,15 +12,15 @@ error[E0568]: auto traits cannot have super traits or lifetime bounds\n LL | auto trait Bound : Copy {}\n    |            -----^^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error[E0568]: auto traits cannot have super traits or lifetime bounds\n   --> $DIR/auto-trait-validation.rs:9:25\n    |\n LL | auto trait LifetimeBound : 'static {}\n    |            -------------^^^^^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error[E0380]: auto traits cannot have associated items\n   --> $DIR/auto-trait-validation.rs:11:25\n@@ -29,7 +29,7 @@ LL | auto trait MyTrait { fn foo() {} }\n    |            -------   ---^^^-----\n    |            |         |\n    |            |         help: remove these associated items\n-   |            auto trait cannot have associated items\n+   |            auto traits cannot have associated items\n \n error: aborting due to 4 previous errors\n "}, {"sha": "fed485612daca458e94871a5d86ade61b0ed90d0", "filename": "tests/ui/auto-traits/issue-23080-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fauto-traits%2Fissue-23080-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fauto-traits%2Fissue-23080-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Fissue-23080-2.stderr?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -2,7 +2,7 @@ error[E0380]: auto traits cannot have associated items\n   --> $DIR/issue-23080-2.rs:5:10\n    |\n LL | unsafe auto trait Trait {\n-   |                   ----- auto trait cannot have associated items\n+   |                   ----- auto traits cannot have associated items\n LL |     type Output;\n    |     -----^^^^^^- help: remove these associated items\n "}, {"sha": "f5d607298b7977d37764e571f9c39f2131d5591e", "filename": "tests/ui/auto-traits/issue-23080.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fauto-traits%2Fissue-23080.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fauto-traits%2Fissue-23080.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Fissue-23080.stderr?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -2,7 +2,7 @@ error[E0380]: auto traits cannot have associated items\n   --> $DIR/issue-23080.rs:5:8\n    |\n LL |   unsafe auto trait Trait {\n-   |                     ----- auto trait cannot have associated items\n+   |                     ----- auto traits cannot have associated items\n LL |       fn method(&self) {\n    |  _____-  ^^^^^^\n LL | |         println!(\"Hello\");"}, {"sha": "6fbdc669b6ffbe83aed3266905655d6e712ea12a", "filename": "tests/ui/auto-traits/issue-84075.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fauto-traits%2Fissue-84075.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fauto-traits%2Fissue-84075.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Fissue-84075.stderr?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -4,7 +4,7 @@ error[E0568]: auto traits cannot have super traits or lifetime bounds\n LL | auto trait Magic where Self: Copy {}\n    |            ----- ^^^^^^^^^^^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "547b4bb54489dc6fd27319a63f7ecb25845481f4", "filename": "tests/ui/auto-traits/typeck-auto-trait-no-supertraits-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fauto-traits%2Ftypeck-auto-trait-no-supertraits-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fauto-traits%2Ftypeck-auto-trait-no-supertraits-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Ftypeck-auto-trait-no-supertraits-2.stderr?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -4,15 +4,15 @@ error[E0568]: auto traits cannot have super traits or lifetime bounds\n LL | auto trait Magic : Sized where Option<Self> : Magic {}\n    |            -----^^^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error[E0568]: auto traits cannot have super traits or lifetime bounds\n   --> $DIR/typeck-auto-trait-no-supertraits-2.rs:4:26\n    |\n LL | auto trait Magic : Sized where Option<Self> : Magic {}\n    |            -----         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error: aborting due to 2 previous errors\n "}, {"sha": "80f07410381272281c118a025723672f4c0474ab", "filename": "tests/ui/auto-traits/typeck-auto-trait-no-supertraits.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fauto-traits%2Ftypeck-auto-trait-no-supertraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fauto-traits%2Ftypeck-auto-trait-no-supertraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauto-traits%2Ftypeck-auto-trait-no-supertraits.stderr?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -4,7 +4,7 @@ error[E0568]: auto traits cannot have super traits or lifetime bounds\n LL | auto trait Magic: Copy {}\n    |            -----^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error: aborting due to previous error\n "}, {"sha": "19ccd2de685a1aade402157b8527eca8af7e5203", "filename": "tests/ui/methods/issues/issue-105732.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fmethods%2Fissues%2Fissue-105732.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Fmethods%2Fissues%2Fissue-105732.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fissues%2Fissue-105732.stderr?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -2,7 +2,7 @@ error[E0380]: auto traits cannot have associated items\n   --> $DIR/issue-105732.rs:4:8\n    |\n LL | auto trait Foo {\n-   |            --- auto trait cannot have associated items\n+   |            --- auto traits cannot have associated items\n LL |     fn g(&self);\n    |     ---^-------- help: remove these associated items\n "}, {"sha": "7639ae9f6a4fd09a334805bf6e102e6e1bacb3e6", "filename": "tests/ui/rfc-2457/mod_file_nonascii_forbidden.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Frfc-2457%2Fmod_file_nonascii_forbidden.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Frfc-2457%2Fmod_file_nonascii_forbidden.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2457%2Fmod_file_nonascii_forbidden.stderr?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -12,7 +12,7 @@ error[E0754]: trying to load file for module `\u0159\u0173\u015b\u0165` with non-ascii identifie\n LL | mod \u0159\u0173\u015b\u0165;\n    |     ^^^^\n    |\n-   = help: consider using `#[path]` attribute to specify filesystem path\n+   = help: consider using the `#[path]` attribute to specify filesystem path\n \n error: aborting due to 2 previous errors\n "}, {"sha": "dc967d51298710e841ce8739a3ca60ea2ab6fba1", "filename": "tests/ui/traits/inductive-overflow/supertrait-auto-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Ftraits%2Finductive-overflow%2Fsupertrait-auto-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/885f9e72d742341179ff697869d6f233e4136626/tests%2Fui%2Ftraits%2Finductive-overflow%2Fsupertrait-auto-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Finductive-overflow%2Fsupertrait-auto-trait.stderr?ref=885f9e72d742341179ff697869d6f233e4136626", "patch": "@@ -4,7 +4,7 @@ error[E0568]: auto traits cannot have super traits or lifetime bounds\n LL | auto trait Magic: Copy {}\n    |            -----^^^^^^ help: remove the super traits or lifetime bounds\n    |            |\n-   |            auto trait cannot have super traits or lifetime bounds\n+   |            auto traits cannot have super traits or lifetime bounds\n \n error[E0277]: the trait bound `NoClone: Copy` is not satisfied\n   --> $DIR/supertrait-auto-trait.rs:16:23"}]}