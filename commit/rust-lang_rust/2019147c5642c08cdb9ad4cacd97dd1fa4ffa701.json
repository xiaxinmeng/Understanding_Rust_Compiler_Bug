{"sha": "2019147c5642c08cdb9ad4cacd97dd1fa4ffa701", "node_id": "C_kwDOAAsO6NoAKDIwMTkxNDdjNTY0MmMwOGNkYjlhZDRjYWNkOTdkZDFmYTRmZmE3MDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-19T17:27:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-19T17:27:30Z"}, "message": "Auto merge of #101894 - dingxiangfei2009:let-else-avoid-duplicate-storage-live, r=oli-obk\n\nAvoid duplicating StorageLive in let-else\n\ncc `@est31`\n\nFix #101867\nFix #101932\n\n#101410 introduced directives to activate storages of bindings in let-else earlier. However, since it is using the machinery of `match` and friends for pattern matching and binding, those storages are activated for the second time. This PR adjusts this behavior and avoid the duplicated activation for let-else statements.", "tree": {"sha": "ceabbffecba326758c0f577b333de45b4e36c7b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ceabbffecba326758c0f577b333de45b4e36c7b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701", "html_url": "https://github.com/rust-lang/rust/commit/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11bb80a92b4f46fa7dfa9148d0bdfc185a7621bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/11bb80a92b4f46fa7dfa9148d0bdfc185a7621bd", "html_url": "https://github.com/rust-lang/rust/commit/11bb80a92b4f46fa7dfa9148d0bdfc185a7621bd"}, {"sha": "eb36f5ee5b71cbe3eb356f8e56e9c9a69b6d649d", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb36f5ee5b71cbe3eb356f8e56e9c9a69b6d649d", "html_url": "https://github.com/rust-lang/rust/commit/eb36f5ee5b71cbe3eb356f8e56e9c9a69b6d649d"}], "stats": {"total": 145, "additions": 136, "deletions": 9}, "files": [{"sha": "4bab583c96018004d9791b25f0583fd1c30c7095", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=2019147c5642c08cdb9ad4cacd97dd1fa4ffa701", "patch": "@@ -232,7 +232,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         pattern,\n                         UserTypeProjections::none(),\n                         &mut |this, _, _, _, node, span, _, _| {\n-                            this.storage_live_binding(block, node, span, OutsideGuard, false);\n+                            this.storage_live_binding(block, node, span, OutsideGuard, true);\n+                            this.schedule_drop_for_binding(node, span, OutsideGuard);\n                         },\n                     );\n                     let failure = unpack!("}, {"sha": "82067ceebfd6d899820f4f1393796f1ca8a1e6d7", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=2019147c5642c08cdb9ad4cacd97dd1fa4ffa701", "patch": "@@ -371,6 +371,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         Some(arm.span),\n                         Some(arm.scope),\n                         Some(match_scope),\n+                        false,\n                     );\n \n                     if let Some(source_scope) = scope {\n@@ -416,6 +417,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         arm_span: Option<Span>,\n         arm_scope: Option<region::Scope>,\n         match_scope: Option<region::Scope>,\n+        storages_alive: bool,\n     ) -> BasicBlock {\n         if candidate.subcandidates.is_empty() {\n             // Avoid generating another `BasicBlock` when we only have one\n@@ -429,6 +431,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 arm_span,\n                 match_scope,\n                 true,\n+                storages_alive,\n             )\n         } else {\n             // It's helpful to avoid scheduling drops multiple times to save\n@@ -466,6 +469,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         arm_span,\n                         match_scope,\n                         schedule_drops,\n+                        storages_alive,\n                     );\n                     if arm_scope.is_none() {\n                         schedule_drops = false;\n@@ -641,6 +645,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             None,\n             None,\n             None,\n+            false,\n         )\n         .unit()\n     }\n@@ -1813,6 +1818,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             None,\n             None,\n             None,\n+            false,\n         );\n \n         post_guard_block.unit()\n@@ -1836,6 +1842,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         arm_span: Option<Span>,\n         match_scope: Option<region::Scope>,\n         schedule_drops: bool,\n+        storages_alive: bool,\n     ) -> BasicBlock {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n \n@@ -2051,7 +2058,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 self.cfg.push_fake_read(post_guard_block, guard_end, cause, Place::from(local_id));\n             }\n             assert!(schedule_drops, \"patterns with guards must schedule drops\");\n-            self.bind_matched_candidate_for_arm_body(post_guard_block, true, by_value_bindings);\n+            self.bind_matched_candidate_for_arm_body(\n+                post_guard_block,\n+                true,\n+                by_value_bindings,\n+                storages_alive,\n+            );\n \n             post_guard_block\n         } else {\n@@ -2065,6 +2077,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     .iter()\n                     .flat_map(|(bindings, _)| bindings)\n                     .chain(&candidate.bindings),\n+                storages_alive,\n             );\n             block\n         }\n@@ -2154,6 +2167,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         block: BasicBlock,\n         schedule_drops: bool,\n         bindings: impl IntoIterator<Item = &'b Binding<'tcx>>,\n+        storages_alive: bool,\n     ) where\n         'tcx: 'b,\n     {\n@@ -2163,13 +2177,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n             let source_info = self.source_info(binding.span);\n-            let local = self.storage_live_binding(\n-                block,\n-                binding.var_id,\n-                binding.span,\n-                OutsideGuard,\n-                schedule_drops,\n-            );\n+            let local = if storages_alive {\n+                // Here storages are already alive, probably because this is a binding\n+                // from let-else.\n+                // We just need to schedule drop for the value.\n+                self.var_local_id(binding.var_id, OutsideGuard).into()\n+            } else {\n+                self.storage_live_binding(\n+                    block,\n+                    binding.var_id,\n+                    binding.span,\n+                    OutsideGuard,\n+                    schedule_drops,\n+                )\n+            };\n             if schedule_drops {\n                 self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n             }\n@@ -2300,6 +2321,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 None,\n                 None,\n                 None,\n+                true,\n             );\n             // This block is for the failure case\n             let failure = this.bind_pattern(\n@@ -2311,6 +2333,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 None,\n                 None,\n                 None,\n+                true,\n             );\n             this.break_for_else(failure, *let_else_scope, this.source_info(initializer_span));\n             matching.unit()"}, {"sha": "931396e2171f053a9172fe37becbe451e932dae5", "filename": "src/test/mir-opt/issue-101867.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701/src%2Ftest%2Fmir-opt%2Fissue-101867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701/src%2Ftest%2Fmir-opt%2Fissue-101867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-101867.rs?ref=2019147c5642c08cdb9ad4cacd97dd1fa4ffa701", "patch": "@@ -0,0 +1,9 @@\n+#![cfg_attr(bootstrap, feature(let_else))]\n+\n+// EMIT_MIR issue_101867.main.mir_map.0.mir\n+fn main() {\n+    let x: Option<u8> = Some(1);\n+    let Some(y) = x else {\n+        panic!();\n+    };\n+}"}, {"sha": "98501ac8c9d840e25929d2e5b84618385a0c3ead", "filename": "src/test/mir-opt/issue_101867.main.mir_map.0.mir", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701/src%2Ftest%2Fmir-opt%2Fissue_101867.main.mir_map.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701/src%2Ftest%2Fmir-opt%2Fissue_101867.main.mir_map.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_101867.main.mir_map.0.mir?ref=2019147c5642c08cdb9ad4cacd97dd1fa4ffa701", "patch": "@@ -0,0 +1,75 @@\n+// MIR for `main` 0 mir_map\n+\n+| User Type Annotations\n+| 0: user_ty: Canonical { max_universe: U0, variables: [], value: Ty(std::option::Option<u8>) }, span: $DIR/issue-101867.rs:5:12: 5:22, inferred_ty: std::option::Option<u8>\n+| 1: user_ty: Canonical { max_universe: U0, variables: [], value: Ty(std::option::Option<u8>) }, span: $DIR/issue-101867.rs:5:12: 5:22, inferred_ty: std::option::Option<u8>\n+|\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/issue-101867.rs:+0:11: +0:11\n+    let _1: std::option::Option<u8> as UserTypeProjection { base: UserType(0), projs: [] }; // in scope 0 at $DIR/issue-101867.rs:+1:9: +1:10\n+    let mut _2: !;                       // in scope 0 at $DIR/issue-101867.rs:+2:26: +4:6\n+    let _3: ();                          // in scope 0 at $SRC_DIR/std/src/panic.rs:LL:COL\n+    let mut _4: !;                       // in scope 0 at $SRC_DIR/std/src/panic.rs:LL:COL\n+    let mut _6: isize;                   // in scope 0 at $DIR/issue-101867.rs:+2:9: +2:16\n+    scope 1 {\n+        debug x => _1;                   // in scope 1 at $DIR/issue-101867.rs:+1:9: +1:10\n+        let _5: u8;                      // in scope 1 at $DIR/issue-101867.rs:+2:14: +2:15\n+        scope 2 {\n+            debug y => _5;               // in scope 2 at $DIR/issue-101867.rs:+2:14: +2:15\n+        }\n+    }\n+\n+    bb0: {\n+        StorageLive(_1);                 // scope 0 at $DIR/issue-101867.rs:+1:9: +1:10\n+        _1 = Option::<u8>::Some(const 1_u8); // scope 0 at $DIR/issue-101867.rs:+1:25: +1:32\n+        FakeRead(ForLet(None), _1);      // scope 0 at $DIR/issue-101867.rs:+1:9: +1:10\n+        AscribeUserType(_1, o, UserTypeProjection { base: UserType(1), projs: [] }); // scope 0 at $DIR/issue-101867.rs:+1:12: +1:22\n+        StorageLive(_5);                 // scope 1 at $DIR/issue-101867.rs:+2:14: +2:15\n+        FakeRead(ForMatchedPlace(None), _1); // scope 1 at $DIR/issue-101867.rs:+2:19: +2:20\n+        _6 = discriminant(_1);           // scope 1 at $DIR/issue-101867.rs:+2:19: +2:20\n+        switchInt(move _6) -> [1_isize: bb4, otherwise: bb3]; // scope 1 at $DIR/issue-101867.rs:+2:9: +2:16\n+    }\n+\n+    bb1: {\n+        StorageLive(_3);                 // scope 1 at $SRC_DIR/std/src/panic.rs:LL:COL\n+        StorageLive(_4);                 // scope 1 at $SRC_DIR/std/src/panic.rs:LL:COL\n+        _4 = begin_panic::<&str>(const \"explicit panic\") -> bb7; // scope 1 at $SRC_DIR/std/src/panic.rs:LL:COL\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/std/src/panic.rs:LL:COL\n+                                         // + literal: Const { ty: fn(&str) -> ! {begin_panic::<&str>}, val: Value(<ZST>) }\n+                                         // mir::Constant\n+                                         // + span: $SRC_DIR/std/src/panic.rs:LL:COL\n+                                         // + literal: Const { ty: &str, val: Value(Slice(..)) }\n+    }\n+\n+    bb2: {\n+        StorageDead(_4);                 // scope 1 at $SRC_DIR/std/src/panic.rs:LL:COL\n+        StorageDead(_3);                 // scope 1 at $DIR/issue-101867.rs:+3:16: +3:17\n+        unreachable;                     // scope 1 at $DIR/issue-101867.rs:+2:26: +4:6\n+    }\n+\n+    bb3: {\n+        goto -> bb6;                     // scope 1 at $DIR/issue-101867.rs:+2:19: +2:20\n+    }\n+\n+    bb4: {\n+        falseEdge -> [real: bb5, imaginary: bb3]; // scope 1 at $DIR/issue-101867.rs:+2:9: +2:16\n+    }\n+\n+    bb5: {\n+        _5 = ((_1 as Some).0: u8);       // scope 1 at $DIR/issue-101867.rs:+2:14: +2:15\n+        _0 = const ();                   // scope 0 at $DIR/issue-101867.rs:+0:11: +5:2\n+        StorageDead(_5);                 // scope 1 at $DIR/issue-101867.rs:+5:1: +5:2\n+        StorageDead(_1);                 // scope 0 at $DIR/issue-101867.rs:+5:1: +5:2\n+        return;                          // scope 0 at $DIR/issue-101867.rs:+5:2: +5:2\n+    }\n+\n+    bb6: {\n+        StorageDead(_5);                 // scope 1 at $DIR/issue-101867.rs:+5:1: +5:2\n+        goto -> bb1;                     // scope 0 at $DIR/issue-101867.rs:+0:11: +5:2\n+    }\n+\n+    bb7 (cleanup): {\n+        resume;                          // scope 0 at $DIR/issue-101867.rs:+0:1: +5:2\n+    }\n+}"}, {"sha": "336b0b4b72ad5c518a39a246950382db4e86cd62", "filename": "src/test/ui/let-else/const-fn.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701/src%2Ftest%2Fui%2Flet-else%2Fconst-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2019147c5642c08cdb9ad4cacd97dd1fa4ffa701/src%2Ftest%2Fui%2Flet-else%2Fconst-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Fconst-fn.rs?ref=2019147c5642c08cdb9ad4cacd97dd1fa4ffa701", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+// issue #101932\n+\n+#![cfg_attr(bootstrap, feature(let_else))]\n+\n+const fn foo(a: Option<i32>) -> i32 {\n+    let Some(a) = a else {\n+        return 42\n+    };\n+\n+    a + 1\n+}\n+\n+fn main() {\n+    const A: i32 = foo(None);\n+    const B: i32 = foo(Some(1));\n+\n+    println!(\"{} {}\", A, B);\n+}"}]}