{"sha": "0c35d82329bc0952bd179ec37933c0955fd5ed26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMzVkODIzMjliYzA5NTJiZDE3OWVjMzc5MzNjMDk1NWZkNWVkMjY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-22T20:06:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-22T20:06:32Z"}, "message": "Merge #1721 #1723\n\n1721: Impl/dyn trait r=flodiebold a=flodiebold\n\nThis adds support for `impl Trait` and `dyn Trait` types as far as possible without Chalk. So we can represent them in the type system, and handle them in method resolution, but Chalk doesn't know about them yet. There's a small temporary hack here where we bypass Chalk during method resolution, so we can handle simple method calls on them and completion works.\r\n\r\nFixes #1608.\n\n1723: Make sysroot use `RUST_SRC_PATH` if set r=matklad a=bkchr\n\n\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Bastian K\u00f6cher <git@kchr.de>", "tree": {"sha": "43ca00aad8f53cfe282a201b7bb9218598e5486c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43ca00aad8f53cfe282a201b7bb9218598e5486c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c35d82329bc0952bd179ec37933c0955fd5ed26", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdXvXICRBK7hj4Ov3rIwAAdHIIABRY+ADzWzixBxlTs2BtTnX0\nOEDEbIzHd7Grmppz3EcnIeb+BOjvXX+mpZA+eYQqsYomg3fu12AXNJ4K8kM8Eq5p\nweU0UOo1MHGxsHxVcreC7w7HAe17rlqshYeFw90oklLMpfjYX4QSJpWeBkC491lZ\ndDopmohM9XzXTWWkoyK31G2crI54Ru9B0jswcBeUrbwzBetlDj1Z7kpG2EtOIhVj\nR20myI9NAOVc1DyjnKI2jEcqUKClDTVkI3dsqEN8UuXjRw5kRLdOd3PiQuFBRWYk\nWYl++73IvtJKzQWspkVKzVt0TET1/LH0A3fuo5wR26q1UdYWC4+SNwlc4IZOB5I=\n=bzUm\n-----END PGP SIGNATURE-----\n", "payload": "tree 43ca00aad8f53cfe282a201b7bb9218598e5486c\nparent daf1a96ff07d7b6e7ae3e2878b300058091bbf6e\nparent 4768f5e7177159b894d65a50b1e4492cb4048ac3\nparent 18c7a1ebe7ced9d8039132da06dcd954affec2eb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1566504392 +0000\ncommitter GitHub <noreply@github.com> 1566504392 +0000\n\nMerge #1721 #1723\n\n1721: Impl/dyn trait r=flodiebold a=flodiebold\n\nThis adds support for `impl Trait` and `dyn Trait` types as far as possible without Chalk. So we can represent them in the type system, and handle them in method resolution, but Chalk doesn't know about them yet. There's a small temporary hack here where we bypass Chalk during method resolution, so we can handle simple method calls on them and completion works.\r\n\r\nFixes #1608.\n\n1723: Make sysroot use `RUST_SRC_PATH` if set r=matklad a=bkchr\n\n\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\nCo-authored-by: Bastian K\u00f6cher <git@kchr.de>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c35d82329bc0952bd179ec37933c0955fd5ed26", "html_url": "https://github.com/rust-lang/rust/commit/0c35d82329bc0952bd179ec37933c0955fd5ed26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c35d82329bc0952bd179ec37933c0955fd5ed26/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daf1a96ff07d7b6e7ae3e2878b300058091bbf6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/daf1a96ff07d7b6e7ae3e2878b300058091bbf6e", "html_url": "https://github.com/rust-lang/rust/commit/daf1a96ff07d7b6e7ae3e2878b300058091bbf6e"}, {"sha": "4768f5e7177159b894d65a50b1e4492cb4048ac3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4768f5e7177159b894d65a50b1e4492cb4048ac3", "html_url": "https://github.com/rust-lang/rust/commit/4768f5e7177159b894d65a50b1e4492cb4048ac3"}, {"sha": "18c7a1ebe7ced9d8039132da06dcd954affec2eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/18c7a1ebe7ced9d8039132da06dcd954affec2eb", "html_url": "https://github.com/rust-lang/rust/commit/18c7a1ebe7ced9d8039132da06dcd954affec2eb"}], "stats": {"total": 526, "additions": 471, "deletions": 55}, "files": [{"sha": "d6728cc9f4fd6c2bd53efd16f8f7ad081bbe2ea5", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=0c35d82329bc0952bd179ec37933c0955fd5ed26", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     name::SELF_TYPE,\n     path::Path,\n-    type_ref::TypeRef,\n+    type_ref::{TypeBound, TypeRef},\n     AdtDef, AsName, Container, Enum, EnumVariant, Function, HasSource, ImplBlock, Name, Struct,\n     Trait, TypeAlias, Union,\n };\n@@ -35,10 +35,12 @@ pub struct GenericParams {\n \n /// A single predicate from a where clause, i.e. `where Type: Trait`. Combined\n /// where clauses like `where T: Foo + Bar` are turned into multiple of these.\n+/// It might still result in multiple actual predicates though, because of\n+/// associated type bindings like `Iterator<Item = u32>`.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct WherePredicate {\n     pub(crate) type_ref: TypeRef,\n-    pub(crate) trait_ref: Path,\n+    pub(crate) bound: TypeBound,\n }\n \n // FIXME: consts can have type parameters from their parents (i.e. associated consts of traits)\n@@ -143,18 +145,8 @@ impl GenericParams {\n             // FIXME: remove this bound\n             return;\n         }\n-        let path = bound\n-            .type_ref()\n-            .and_then(|tr| match tr {\n-                ast::TypeRef::PathType(path) => path.path(),\n-                _ => None,\n-            })\n-            .and_then(Path::from_ast);\n-        let path = match path {\n-            Some(p) => p,\n-            None => return,\n-        };\n-        self.where_predicates.push(WherePredicate { type_ref, trait_ref: path });\n+        let bound = TypeBound::from_ast(bound);\n+        self.where_predicates.push(WherePredicate { type_ref, bound });\n     }\n \n     pub(crate) fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {"}, {"sha": "b54c80318522f0caf6efbdbf855b88e3eea07b32", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 123, "deletions": 10, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=0c35d82329bc0952bd179ec37933c0955fd5ed26", "patch": "@@ -161,14 +161,28 @@ pub enum Ty {\n         name: Name,\n     },\n \n-    /// A bound type variable. Only used during trait resolution to represent\n-    /// Chalk variables.\n+    /// A bound type variable. Used during trait resolution to represent Chalk\n+    /// variables, and in `Dyn` and `Opaque` bounds to represent the `Self` type.\n     Bound(u32),\n \n     /// A type variable used during type checking. Not to be confused with a\n     /// type parameter.\n     Infer(InferTy),\n \n+    /// A trait object (`dyn Trait` or bare `Trait` in pre-2018 Rust).\n+    ///\n+    /// The predicates are quantified over the `Self` type, i.e. `Ty::Bound(0)`\n+    /// represents the `Self` type inside the bounds. This is currently\n+    /// implicit; Chalk has the `Binders` struct to make it explicit, but it\n+    /// didn't seem worth the overhead yet.\n+    Dyn(Arc<[GenericPredicate]>),\n+\n+    /// An opaque type (`impl Trait`).\n+    ///\n+    /// The predicates are quantified over the `Self` type; see `Ty::Dyn` for\n+    /// more.\n+    Opaque(Arc<[GenericPredicate]>),\n+\n     /// A placeholder for a type which could not be computed; this is propagated\n     /// to avoid useless error messages. Doubles as a placeholder where type\n     /// variables are inserted before type checking, since we want to try to\n@@ -194,6 +208,12 @@ impl Substs {\n         Substs(self.0.iter().cloned().take(n).collect::<Vec<_>>().into())\n     }\n \n+    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.0.iter() {\n+            t.walk(f);\n+        }\n+    }\n+\n     pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         // Without an Arc::make_mut_slice, we can't avoid the clone here:\n         let mut v: Vec<_> = self.0.iter().cloned().collect();\n@@ -270,6 +290,14 @@ impl TraitRef {\n         });\n         self\n     }\n+\n+    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.substs.walk(f);\n+    }\n+\n+    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.substs.walk_mut(f);\n+    }\n }\n \n /// Like `generics::WherePredicate`, but with resolved types: A condition on the\n@@ -299,6 +327,20 @@ impl GenericPredicate {\n             GenericPredicate::Error => self,\n         }\n     }\n+\n+    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.walk(f),\n+            GenericPredicate::Error => {}\n+        }\n+    }\n+\n+    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut(f),\n+            GenericPredicate::Error => {}\n+        }\n+    }\n }\n \n /// Basically a claim (currently not validated / checked) that the contained\n@@ -386,6 +428,11 @@ impl Ty {\n                     t.walk(f);\n                 }\n             }\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                for p in predicates.iter() {\n+                    p.walk(f);\n+                }\n+            }\n             Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n@@ -402,6 +449,13 @@ impl Ty {\n             Ty::UnselectedProjection(p_ty) => {\n                 p_ty.parameters.walk_mut(f);\n             }\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                let mut v: Vec<_> = predicates.iter().cloned().collect();\n+                for p in &mut v {\n+                    p.walk_mut(f);\n+                }\n+                *predicates = v.into();\n+            }\n             Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n@@ -529,6 +583,19 @@ impl Ty {\n             ty => ty,\n         })\n     }\n+\n+    /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n+    pub fn inherent_trait(&self) -> Option<Trait> {\n+        match self {\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                predicates.iter().find_map(|pred| match pred {\n+                    GenericPredicate::Implemented(tr) => Some(tr.trait_),\n+                    _ => None,\n+                })\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n impl HirDisplay for &Ty {\n@@ -669,21 +736,45 @@ impl HirDisplay for Ty {\n             Ty::UnselectedProjection(p_ty) => p_ty.hir_fmt(f)?,\n             Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n             Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                match self {\n+                    Ty::Dyn(_) => write!(f, \"dyn \")?,\n+                    Ty::Opaque(_) => write!(f, \"impl \")?,\n+                    _ => unreachable!(),\n+                };\n+                // looping by hand here just to format the bounds in a slightly nicer way\n+                let mut first = true;\n+                for p in predicates.iter() {\n+                    if !first {\n+                        write!(f, \" + \")?;\n+                    }\n+                    first = false;\n+                    match p {\n+                        // don't show the $0 self type\n+                        GenericPredicate::Implemented(trait_ref) => {\n+                            trait_ref.hir_fmt_ext(f, false)?\n+                        }\n+                        GenericPredicate::Error => p.hir_fmt(f)?,\n+                    }\n+                }\n+            }\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n             Ty::Infer(..) => write!(f, \"_\")?,\n         }\n         Ok(())\n     }\n }\n \n-impl HirDisplay for TraitRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"{}: {}\",\n-            self.substs[0].display(f.db),\n-            self.trait_.name(f.db).unwrap_or_else(Name::missing)\n-        )?;\n+impl TraitRef {\n+    fn hir_fmt_ext(\n+        &self,\n+        f: &mut HirFormatter<impl HirDatabase>,\n+        with_self_ty: bool,\n+    ) -> fmt::Result {\n+        if with_self_ty {\n+            write!(f, \"{}: \", self.substs[0].display(f.db),)?;\n+        }\n+        write!(f, \"{}\", self.trait_.name(f.db).unwrap_or_else(Name::missing))?;\n         if self.substs.len() > 1 {\n             write!(f, \"<\")?;\n             f.write_joined(&self.substs[1..], \", \")?;\n@@ -693,6 +784,28 @@ impl HirDisplay for TraitRef {\n     }\n }\n \n+impl HirDisplay for TraitRef {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        self.hir_fmt_ext(f, true)\n+    }\n+}\n+\n+impl HirDisplay for &GenericPredicate {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        HirDisplay::hir_fmt(*self, f)\n+    }\n+}\n+\n+impl HirDisplay for GenericPredicate {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n+            GenericPredicate::Error => write!(f, \"{{error}}\")?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl HirDisplay for Obligation {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n         match self {"}, {"sha": "47d1612770c8bd7f847db00eb0fe435695b73e58", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 54, "deletions": 11, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=0c35d82329bc0952bd179ec37933c0955fd5ed26", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     path::{GenericArg, PathSegment},\n     resolve::{Resolution, Resolver},\n     ty::AdtDef,\n-    type_ref::TypeRef,\n+    type_ref::{TypeBound, TypeRef},\n     BuiltinType, Const, Enum, EnumVariant, Function, HirDatabase, ModuleDef, Path, Static, Struct,\n     StructField, Trait, TypeAlias, Union,\n };\n@@ -58,6 +58,22 @@ impl Ty {\n                 let sig = Substs(inner_tys.into());\n                 Ty::apply(TypeCtor::FnPtr { num_args: sig.len() as u16 - 1 }, sig)\n             }\n+            TypeRef::DynTrait(bounds) => {\n+                let self_ty = Ty::Bound(0);\n+                let predicates = bounds\n+                    .iter()\n+                    .map(|b| GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone()))\n+                    .collect::<Vec<_>>();\n+                Ty::Dyn(predicates.into())\n+            }\n+            TypeRef::ImplTrait(bounds) => {\n+                let self_ty = Ty::Bound(0);\n+                let predicates = bounds\n+                    .iter()\n+                    .map(|b| GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone()))\n+                    .collect::<Vec<_>>();\n+                Ty::Opaque(predicates.into())\n+            }\n             TypeRef::Error => Ty::Unknown,\n         }\n     }\n@@ -310,13 +326,46 @@ impl TraitRef {\n         TraitRef { trait_, substs }\n     }\n \n-    pub(crate) fn for_where_predicate(\n+    pub(crate) fn from_where_predicate(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         pred: &WherePredicate,\n     ) -> Option<TraitRef> {\n         let self_ty = Ty::from_hir(db, resolver, &pred.type_ref);\n-        TraitRef::from_path(db, resolver, &pred.trait_ref, Some(self_ty))\n+        TraitRef::from_type_bound(db, resolver, &pred.bound, self_ty)\n+    }\n+\n+    pub(crate) fn from_type_bound(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        bound: &TypeBound,\n+        self_ty: Ty,\n+    ) -> Option<TraitRef> {\n+        match bound {\n+            TypeBound::Path(path) => TraitRef::from_path(db, resolver, path, Some(self_ty)),\n+            TypeBound::Error => None,\n+        }\n+    }\n+}\n+\n+impl GenericPredicate {\n+    pub(crate) fn from_where_predicate(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        where_predicate: &WherePredicate,\n+    ) -> GenericPredicate {\n+        TraitRef::from_where_predicate(db, &resolver, where_predicate)\n+            .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n+    }\n+\n+    pub(crate) fn from_type_bound(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        bound: &TypeBound,\n+        self_ty: Ty,\n+    ) -> GenericPredicate {\n+        TraitRef::from_type_bound(db, &resolver, bound, self_ty)\n+            .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n     }\n }\n \n@@ -376,10 +425,7 @@ pub(crate) fn trait_env(\n ) -> Arc<super::TraitEnvironment> {\n     let predicates = resolver\n         .where_predicates_in_scope()\n-        .map(|pred| {\n-            TraitRef::for_where_predicate(db, &resolver, pred)\n-                .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n-        })\n+        .map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n         .collect::<Vec<_>>();\n \n     Arc::new(super::TraitEnvironment { predicates })\n@@ -393,10 +439,7 @@ pub(crate) fn generic_predicates_query(\n     let resolver = def.resolver(db);\n     let predicates = resolver\n         .where_predicates_in_scope()\n-        .map(|pred| {\n-            TraitRef::for_where_predicate(db, &resolver, pred)\n-                .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n-        })\n+        .map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n         .collect::<Vec<_>>();\n     predicates.into()\n }"}, {"sha": "9873a0440bcdcd07f7dbc28f778fc6856a9e7cb7", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=0c35d82329bc0952bd179ec37933c0955fd5ed26", "patch": "@@ -211,12 +211,19 @@ fn iterate_trait_method_candidates<T>(\n     let krate = resolver.krate()?;\n     // FIXME: maybe put the trait_env behind a query (need to figure out good input parameters for that)\n     let env = lower::trait_env(db, resolver);\n-    'traits: for t in resolver.traits_in_scope(db) {\n+    // if ty is `impl Trait` or `dyn Trait`, the trait doesn't need to be in scope\n+    let traits = ty.value.inherent_trait().into_iter().chain(resolver.traits_in_scope(db));\n+    'traits: for t in traits {\n         let data = t.trait_data(db);\n+\n+        // FIXME this is a bit of a hack, since Chalk should say the same thing\n+        // anyway, but currently Chalk doesn't implement `dyn/impl Trait` yet\n+        let inherently_implemented = ty.value.inherent_trait() == Some(t);\n+\n         // we'll be lazy about checking whether the type implements the\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n         // iteration\n-        let mut known_implemented = false;\n+        let mut known_implemented = inherently_implemented;\n         for item in data.items() {\n             if let TraitItem::Function(m) = *item {\n                 let data = m.data(db);\n@@ -271,6 +278,11 @@ pub(crate) fn implements_trait(\n     krate: Crate,\n     trait_: Trait,\n ) -> bool {\n+    if ty.value.inherent_trait() == Some(trait_) {\n+        // FIXME this is a bit of a hack, since Chalk should say the same thing\n+        // anyway, but currently Chalk doesn't implement `dyn/impl Trait` yet\n+        return true;\n+    }\n     let env = lower::trait_env(db, resolver);\n     let goal = generic_implements_goal(db, env.clone(), trait_, ty.clone());\n     let solution = db.trait_solve(krate, goal);"}, {"sha": "c5818b738f0c41e7efb2eb99ef3bd08c84eb2176", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=0c35d82329bc0952bd179ec37933c0955fd5ed26", "patch": "@@ -3273,6 +3273,181 @@ fn test<T: ApplyL>(t: T) {\n     assert_eq!(t, \"{unknown}\");\n }\n \n+#[test]\n+fn impl_trait() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n+}\n+fn bar() -> impl Trait<u64> {}\n+\n+fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n+}\n+\"#),\n+        @r###\"\n+   \u22ee\n+   \u22ee[30; 34) 'self': &Self\n+   \u22ee[55; 59) 'self': &Self\n+   \u22ee[99; 101) '{}': ()\n+   \u22ee[111; 112) 'x': impl Trait<u64>\n+   \u22ee[131; 132) 'y': &impl Trait<u64>\n+   \u22ee[152; 269) '{     ...2(); }': ()\n+   \u22ee[158; 159) 'x': impl Trait<u64>\n+   \u22ee[165; 166) 'y': &impl Trait<u64>\n+   \u22ee[176; 177) 'z': impl Trait<u64>\n+   \u22ee[180; 183) 'bar': fn bar() -> impl Trait<u64>\n+   \u22ee[180; 185) 'bar()': impl Trait<u64>\n+   \u22ee[191; 192) 'x': impl Trait<u64>\n+   \u22ee[191; 198) 'x.foo()': {unknown}\n+   \u22ee[204; 205) 'y': &impl Trait<u64>\n+   \u22ee[204; 211) 'y.foo()': {unknown}\n+   \u22ee[217; 218) 'z': impl Trait<u64>\n+   \u22ee[217; 224) 'z.foo()': {unknown}\n+   \u22ee[230; 231) 'x': impl Trait<u64>\n+   \u22ee[230; 238) 'x.foo2()': i64\n+   \u22ee[244; 245) 'y': &impl Trait<u64>\n+   \u22ee[244; 252) 'y.foo2()': i64\n+   \u22ee[258; 259) 'z': impl Trait<u64>\n+   \u22ee[258; 266) 'z.foo2()': i64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn dyn_trait() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+    fn foo2(&self) -> i64;\n+}\n+fn bar() -> dyn Trait<u64> {}\n+\n+fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+    x.foo2();\n+    y.foo2();\n+    z.foo2();\n+}\n+\"#),\n+        @r###\"\n+   \u22ee\n+   \u22ee[30; 34) 'self': &Self\n+   \u22ee[55; 59) 'self': &Self\n+   \u22ee[98; 100) '{}': ()\n+   \u22ee[110; 111) 'x': dyn Trait<u64>\n+   \u22ee[129; 130) 'y': &dyn Trait<u64>\n+   \u22ee[149; 266) '{     ...2(); }': ()\n+   \u22ee[155; 156) 'x': dyn Trait<u64>\n+   \u22ee[162; 163) 'y': &dyn Trait<u64>\n+   \u22ee[173; 174) 'z': dyn Trait<u64>\n+   \u22ee[177; 180) 'bar': fn bar() -> dyn Trait<u64>\n+   \u22ee[177; 182) 'bar()': dyn Trait<u64>\n+   \u22ee[188; 189) 'x': dyn Trait<u64>\n+   \u22ee[188; 195) 'x.foo()': {unknown}\n+   \u22ee[201; 202) 'y': &dyn Trait<u64>\n+   \u22ee[201; 208) 'y.foo()': {unknown}\n+   \u22ee[214; 215) 'z': dyn Trait<u64>\n+   \u22ee[214; 221) 'z.foo()': {unknown}\n+   \u22ee[227; 228) 'x': dyn Trait<u64>\n+   \u22ee[227; 235) 'x.foo2()': i64\n+   \u22ee[241; 242) 'y': &dyn Trait<u64>\n+   \u22ee[241; 249) 'y.foo2()': i64\n+   \u22ee[255; 256) 'z': dyn Trait<u64>\n+   \u22ee[255; 263) 'z.foo2()': i64\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn dyn_trait_bare() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+trait Trait {\n+    fn foo(&self) -> u64;\n+}\n+fn bar() -> Trait {}\n+\n+fn test(x: Trait, y: &Trait) -> u64 {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+}\n+\"#),\n+        @r###\"\n+   \u22ee\n+   \u22ee[27; 31) 'self': &Self\n+   \u22ee[61; 63) '{}': ()\n+   \u22ee[73; 74) 'x': {unknown}\n+   \u22ee[83; 84) 'y': &{unknown}\n+   \u22ee[101; 176) '{     ...o(); }': ()\n+   \u22ee[107; 108) 'x': {unknown}\n+   \u22ee[114; 115) 'y': &{unknown}\n+   \u22ee[125; 126) 'z': {unknown}\n+   \u22ee[129; 132) 'bar': fn bar() -> {unknown}\n+   \u22ee[129; 134) 'bar()': {unknown}\n+   \u22ee[140; 141) 'x': {unknown}\n+   \u22ee[140; 147) 'x.foo()': {unknown}\n+   \u22ee[153; 154) 'y': &{unknown}\n+   \u22ee[153; 160) 'y.foo()': {unknown}\n+   \u22ee[166; 167) 'z': {unknown}\n+   \u22ee[166; 173) 'z.foo()': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn weird_bounds() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+trait Trait {}\n+fn test() {\n+    let a: impl Trait + 'lifetime = foo;\n+    let b: impl 'lifetime = foo;\n+    let b: impl (Trait) = foo;\n+    let b: impl ('lifetime) = foo;\n+    let d: impl ?Sized = foo;\n+    let e: impl Trait + ?Sized = foo;\n+}\n+\"#),\n+        @r###\"\n+   \u22ee\n+   \u22ee[26; 237) '{     ...foo; }': ()\n+   \u22ee[36; 37) 'a': impl Trait + {error}\n+   \u22ee[64; 67) 'foo': impl Trait + {error}\n+   \u22ee[77; 78) 'b': impl {error}\n+   \u22ee[97; 100) 'foo': impl {error}\n+   \u22ee[110; 111) 'b': impl Trait\n+   \u22ee[128; 131) 'foo': impl Trait\n+   \u22ee[141; 142) 'b': impl {error}\n+   \u22ee[163; 166) 'foo': impl {error}\n+   \u22ee[176; 177) 'd': impl {error}\n+   \u22ee[193; 196) 'foo': impl {error}\n+   \u22ee[206; 207) 'e': impl Trait + {error}\n+   \u22ee[231; 234) 'foo': impl Trait + {error}\n+    \"###\n+    );\n+}\n+\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}, {"sha": "2ebc06135a13bd3fa2e286f5ef53671042e5261d", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=0c35d82329bc0952bd179ec37933c0955fd5ed26", "patch": "@@ -80,7 +80,9 @@ impl ToChalk for Ty {\n             // FIXME this is clearly incorrect, but probably not too incorrect\n             // and I'm not sure what to actually do with Ty::Unknown\n             // maybe an alternative would be `for<T> T`? (meaningless in rust, but expressible in chalk's Ty)\n-            Ty::Unknown => {\n+            //\n+            // FIXME also dyn and impl Trait are currently handled like Unknown because Chalk doesn't have them yet\n+            Ty::Unknown | Ty::Dyn(_) | Ty::Opaque(_) => {\n                 PlaceholderIndex { ui: UniverseIndex::ROOT, idx: usize::max_value() }.to_ty()\n             }\n         }"}, {"sha": "fa91bfb22f06764c8b48895ac59748ca94742e27", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=0c35d82329bc0952bd179ec37933c0955fd5ed26", "patch": "@@ -1,7 +1,7 @@\n //! HIR for references to types. Paths in these are not yet resolved. They can\n //! be directly created from an ast::TypeRef, without further queries.\n \n-use ra_syntax::ast::{self, TypeAscriptionOwner};\n+use ra_syntax::ast::{self, TypeAscriptionOwner, TypeBoundsOwner};\n \n use crate::Path;\n \n@@ -49,8 +49,16 @@ pub enum TypeRef {\n     /// A fn pointer. Last element of the vector is the return type.\n     Fn(Vec<TypeRef>),\n     // For\n-    // ImplTrait,\n-    // DynTrait,\n+    ImplTrait(Vec<TypeBound>),\n+    DynTrait(Vec<TypeBound>),\n+    Error,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum TypeBound {\n+    Path(Path),\n+    // also for<> bounds\n+    // also Lifetimes\n     Error,\n }\n \n@@ -95,8 +103,12 @@ impl TypeRef {\n             }\n             // for types are close enough for our purposes to the inner type for now...\n             ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n-            ast::TypeRef::ImplTraitType(_inner) => TypeRef::Error,\n-            ast::TypeRef::DynTraitType(_inner) => TypeRef::Error,\n+            ast::TypeRef::ImplTraitType(inner) => {\n+                TypeRef::ImplTrait(type_bounds_from_ast(inner.type_bound_list()))\n+            }\n+            ast::TypeRef::DynTraitType(inner) => {\n+                TypeRef::DynTrait(type_bounds_from_ast(inner.type_bound_list()))\n+            }\n         }\n     }\n \n@@ -112,3 +124,30 @@ impl TypeRef {\n         TypeRef::Tuple(Vec::new())\n     }\n }\n+\n+pub(crate) fn type_bounds_from_ast(type_bounds_opt: Option<ast::TypeBoundList>) -> Vec<TypeBound> {\n+    if let Some(type_bounds) = type_bounds_opt {\n+        type_bounds.bounds().map(TypeBound::from_ast).collect()\n+    } else {\n+        vec![]\n+    }\n+}\n+\n+impl TypeBound {\n+    pub(crate) fn from_ast(node: ast::TypeBound) -> Self {\n+        match node.kind() {\n+            ast::TypeBoundKind::PathType(path_type) => {\n+                let path = match path_type.path() {\n+                    Some(p) => p,\n+                    None => return TypeBound::Error,\n+                };\n+                let path = match Path::from_ast(path) {\n+                    Some(p) => p,\n+                    None => return TypeBound::Error,\n+                };\n+                TypeBound::Path(path)\n+            }\n+            ast::TypeBoundKind::ForType(_) | ast::TypeBoundKind::Lifetime(_) => TypeBound::Error,\n+        }\n+    }\n+}"}, {"sha": "0c27d4f4b312ae9e5bfdcd75ad812e16e025a4d8", "filename": "crates/ra_project_model/src/sysroot.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs?ref=0c35d82329bc0952bd179ec37933c0955fd5ed26", "patch": "@@ -1,4 +1,5 @@\n use std::{\n+    env,\n     path::{Path, PathBuf},\n     process::Command,\n };\n@@ -33,21 +34,13 @@ impl Sysroot {\n     }\n \n     pub fn discover(cargo_toml: &Path) -> Result<Sysroot> {\n-        let rustc_output = Command::new(\"rustc\")\n-            .current_dir(cargo_toml.parent().unwrap())\n-            .args(&[\"--print\", \"sysroot\"])\n-            .output()?;\n-        if !rustc_output.status.success() {\n-            Err(\"failed to locate sysroot\")?\n-        }\n-        let stdout = String::from_utf8(rustc_output.stdout)?;\n-        let sysroot_path = Path::new(stdout.trim());\n-        let src = sysroot_path.join(\"lib/rustlib/src/rust/src\");\n+        let src = try_find_src_path(cargo_toml)?;\n+\n         if !src.exists() {\n             Err(format!(\n                 \"can't load standard library from sysroot\\n\\\n                  {:?}\\n\\\n-                 try running `rustup component add rust-src`\",\n+                 try running `rustup component add rust-src` or set `RUST_SRC_PATH`\",\n                 src,\n             ))?;\n         }\n@@ -83,6 +76,23 @@ impl Sysroot {\n     }\n }\n \n+fn try_find_src_path(cargo_toml: &Path) -> Result<PathBuf> {\n+    if let Ok(path) = env::var(\"RUST_SRC_PATH\") {\n+        return Ok(path.into());\n+    }\n+\n+    let rustc_output = Command::new(\"rustc\")\n+        .current_dir(cargo_toml.parent().unwrap())\n+        .args(&[\"--print\", \"sysroot\"])\n+        .output()?;\n+    if !rustc_output.status.success() {\n+        Err(\"failed to locate sysroot\")?;\n+    }\n+    let stdout = String::from_utf8(rustc_output.stdout)?;\n+    let sysroot_path = Path::new(stdout.trim());\n+    Ok(sysroot_path.join(\"lib/rustlib/src/rust/src\"))\n+}\n+\n impl SysrootCrate {\n     pub fn name(self, sysroot: &Sysroot) -> &str {\n         &sysroot.crates[self].name"}, {"sha": "afdfca66e310683dd1f93802d51a4152a4bab4c8", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=0c35d82329bc0952bd179ec37933c0955fd5ed26", "patch": "@@ -15,7 +15,7 @@ use crate::{\n \n pub use self::{\n     expr_extensions::{ArrayExprKind, BinOp, ElseBranch, LiteralKind, PrefixOp},\n-    extensions::{FieldKind, PathSegmentKind, SelfParamKind, StructKind},\n+    extensions::{FieldKind, PathSegmentKind, SelfParamKind, StructKind, TypeBoundKind},\n     generated::*,\n     tokens::*,\n     traits::*,"}, {"sha": "e0ea3e5ab1e2263dc224d6558df92d3f96de0531", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c35d82329bc0952bd179ec37933c0955fd5ed26/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=0c35d82329bc0952bd179ec37933c0955fd5ed26", "patch": "@@ -382,7 +382,36 @@ impl ast::WherePred {\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum TypeBoundKind {\n+    /// Trait\n+    PathType(ast::PathType),\n+    /// for<'a> ...\n+    ForType(ast::ForType),\n+    /// 'a\n+    Lifetime(ast::SyntaxToken),\n+}\n+\n impl ast::TypeBound {\n+    pub fn kind(&self) -> TypeBoundKind {\n+        if let Some(path_type) = children(self).next() {\n+            TypeBoundKind::PathType(path_type)\n+        } else if let Some(for_type) = children(self).next() {\n+            TypeBoundKind::ForType(for_type)\n+        } else if let Some(lifetime) = self.lifetime() {\n+            TypeBoundKind::Lifetime(lifetime)\n+        } else {\n+            unreachable!()\n+        }\n+    }\n+\n+    fn lifetime(&self) -> Option<SyntaxToken> {\n+        self.syntax()\n+            .children_with_tokens()\n+            .filter_map(|it| it.into_token())\n+            .find(|it| it.kind() == LIFETIME)\n+    }\n+\n     pub fn question_mark_token(&self) -> Option<SyntaxToken> {\n         self.syntax()\n             .children_with_tokens()"}, {"sha": "453e8e273f82eb4c982374fbdf0be2acc3b4d10a", "filename": "docs/user/README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c35d82329bc0952bd179ec37933c0955fd5ed26/docs%2Fuser%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c35d82329bc0952bd179ec37933c0955fd5ed26/docs%2Fuser%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2FREADME.md?ref=0c35d82329bc0952bd179ec37933c0955fd5ed26", "patch": "@@ -78,6 +78,7 @@ See https://github.com/microsoft/vscode/issues/72308[microsoft/vscode#72308] for\n   (e.g: `--features=\"shumway,pdf\"` will run as `cargo watch -x \"check --features=\"shumway,pdf\"\"` )\n * `rust-analyzer.trace.server`: enables internal logging\n * `rust-analyzer.trace.cargo-watch`: enables cargo-watch logging\n+* `RUST_SRC_PATH`: environment variable that overwrites the sysroot\n \n \n ## Emacs"}]}