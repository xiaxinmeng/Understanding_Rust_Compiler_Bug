{"sha": "2852fea61e51752a0a7f6c2aeb8fe798a2890c4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NTJmZWE2MWU1MTc1MmEwYTdmNmMyYWViOGZlNzk4YTI4OTBjNGU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-02-14T07:55:49Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-02-15T01:45:54Z"}, "message": "mk: Move most of Makefile.in to .mk files\n\nBecause the build system treats Makefile.in and the .mk files slightly\ndifferently (.in is copied, .mk are included), this makes the system\nmore uniform. Fewer build system changes will require a complete\nreconfigure.", "tree": {"sha": "1dbc173afb21a2c1597d446dc2f90c236e77fd54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dbc173afb21a2c1597d446dc2f90c236e77fd54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2852fea61e51752a0a7f6c2aeb8fe798a2890c4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2852fea61e51752a0a7f6c2aeb8fe798a2890c4e", "html_url": "https://github.com/rust-lang/rust/commit/2852fea61e51752a0a7f6c2aeb8fe798a2890c4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2852fea61e51752a0a7f6c2aeb8fe798a2890c4e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94d2c8a21fae1b30340750346d15f6da84a76a87", "url": "https://api.github.com/repos/rust-lang/rust/commits/94d2c8a21fae1b30340750346d15f6da84a76a87", "html_url": "https://github.com/rust-lang/rust/commit/94d2c8a21fae1b30340750346d15f6da84a76a87"}], "stats": {"total": 989, "additions": 518, "deletions": 471}, "files": [{"sha": "599984623e2581a13a3313e934e4f9f2894b66b6", "filename": "Makefile.in", "status": "modified", "additions": 26, "deletions": 471, "changes": 497, "blob_url": "https://github.com/rust-lang/rust/blob/2852fea61e51752a0a7f6c2aeb8fe798a2890c4e/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/2852fea61e51752a0a7f6c2aeb8fe798a2890c4e/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=2852fea61e51752a0a7f6c2aeb8fe798a2890c4e", "patch": "@@ -99,490 +99,45 @@\n #\n # Admittedly this is a little convoluted.\n \n-STAGES = 0 1 2 3\n-\n-######################################################################\n-# Residual auto-configuration\n-######################################################################\n-\n-# Recursive wildcard function\n-# http://blog.jgc.org/2011/07/gnu-make-recursive-wildcard-function.html\n-rwildcard=$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2) \\\n-  $(filter $(subst *,%,$2),$d))\n-\n-include config.mk\n-\n-# We track all of the object files we might build so that we can find\n-# and include all of the .d files in one fell swoop.\n-ALL_OBJ_FILES :=\n-\n-MKFILE_DEPS := config.stamp $(call rwildcard,$(CFG_SRC_DIR)mk/,*)\n-NON_BUILD_HOST = $(filter-out $(CFG_BUILD),$(CFG_HOST))\n-NON_BUILD_TARGET = $(filter-out $(CFG_BUILD),$(CFG_TARGET))\n-\n-ifneq ($(MAKE_RESTARTS),)\n-CFG_INFO := $(info cfg: make restarts: $(MAKE_RESTARTS))\n-endif\n-\n-CFG_INFO := $(info cfg: build triple $(CFG_BUILD))\n-CFG_INFO := $(info cfg: host triples $(CFG_HOST))\n-CFG_INFO := $(info cfg: target triples $(CFG_TARGET))\n-\n-ifneq ($(wildcard $(NON_BUILD_HOST)),)\n-CFG_INFO := $(info cfg: non-build host triples $(NON_BUILD_HOST))\n-endif\n-ifneq ($(wildcard $(NON_BUILD_TARGET)),)\n-CFG_INFO := $(info cfg: non-build target triples $(NON_BUILD_TARGET))\n-endif\n-\n-CFG_RUSTC_FLAGS := $(RUSTFLAGS)\n-CFG_GCCISH_CFLAGS :=\n-CFG_GCCISH_LINK_FLAGS :=\n-\n-ifdef CFG_DISABLE_OPTIMIZE\n-  $(info cfg: disabling rustc optimization (CFG_DISABLE_OPTIMIZE))\n-  CFG_RUSTC_FLAGS +=\n-else\n-  # The rtopt cfg turns off runtime sanity checks\n-  CFG_RUSTC_FLAGS += -O --cfg rtopt\n-endif\n-\n-ifdef CFG_DISABLE_DEBUG\n-  CFG_RUSTC_FLAGS += --cfg ndebug\n-  CFG_GCCISH_CFLAGS += -DRUST_NDEBUG\n-else\n-  $(info cfg: enabling more debugging (CFG_ENABLE_DEBUG))\n-  CFG_RUSTC_FLAGS += --cfg debug\n-  CFG_GCCISH_CFLAGS += -DRUST_DEBUG\n-endif\n-\n-ifdef SAVE_TEMPS\n-  CFG_RUSTC_FLAGS += --save-temps\n-endif\n-ifdef ASM_COMMENTS\n-  CFG_RUSTC_FLAGS += -Z asm-comments\n-endif\n-ifdef TIME_PASSES\n-  CFG_RUSTC_FLAGS += -Z time-passes\n-endif\n-ifdef TIME_LLVM_PASSES\n-  CFG_RUSTC_FLAGS += -Z time-llvm-passes\n-endif\n-ifdef TRACE\n-  CFG_RUSTC_FLAGS += -Z trace\n-endif\n-ifdef CFG_DISABLE_RPATH\n-CFG_RUSTC_FLAGS += -C no-rpath\n-endif\n-\n-# The executables crated during this compilation process have no need to include\n-# static copies of libstd and libextra. We also generate dynamic versions of all\n-# libraries, so in the interest of space, prefer dynamic linking throughout the\n-# compilation process.\n-#\n-# Note though that these flags are omitted for stage2+. This means that the\n-# snapshot will be generated with a statically linked rustc so we only have to\n-# worry about the distribution of one file (with its native dynamic\n-# dependencies)\n-RUSTFLAGS_STAGE0 += -C prefer-dynamic\n-RUSTFLAGS_STAGE1 += -C prefer-dynamic\n-\n-# platform-specific auto-configuration\n-include $(CFG_SRC_DIR)mk/platform.mk\n-\n-# Run the stage1/2 compilers under valgrind\n-ifdef VALGRIND_COMPILE\n-  CFG_VALGRIND_COMPILE :=$(CFG_VALGRIND)\n-else\n-  CFG_VALGRIND_COMPILE :=\n-endif\n-\n-# version-string calculation\n-CFG_GIT_DIR := $(CFG_SRC_DIR).git\n-CFG_RELEASE = 0.10-pre\n-CFG_VERSION = $(CFG_RELEASE)\n-# windows exe's need numeric versions - don't use anything but\n-# numbers and dots here\n-CFG_VERSION_WIN = 0.10\n-\n-# since $(CFG_GIT) may contain spaces (especially on Windows),\n-# we need to escape them. (\" \" to r\"\\ \")\n-# Note that $(subst ...) ignores space after `subst`,\n-# so we use a hack: define $(SPACE) which contains space character.\n-SPACE :=\n-SPACE +=\n-ifneq ($(wildcard $(subst $(SPACE),\\$(SPACE),$(CFG_GIT))),)\n-ifneq ($(wildcard $(subst $(SPACE),\\$(SPACE),$(CFG_GIT_DIR))),)\n-    CFG_VERSION += $(shell git --git-dir='$(CFG_GIT_DIR)' log -1 \\\n-                     --pretty=format:'(%h %ci)')\n-    CFG_VER_HASH = $(shell git --git-dir='$(CFG_GIT_DIR)' rev-parse HEAD)\n-endif\n-endif\n-\n-ifdef CFG_ENABLE_VALGRIND\n-  $(info cfg: enabling valgrind (CFG_ENABLE_VALGRIND))\n-else\n-  CFG_VALGRIND :=\n-endif\n-ifdef CFG_BAD_VALGRIND\n-  $(info cfg: disabling valgrind due to its unreliability on this platform)\n-  CFG_VALGRIND :=\n-endif\n-\n-\n-######################################################################\n-# Target-and-rule \"utility variables\"\n-######################################################################\n-\n-ifdef VERBOSE\n-  Q :=\n-  E =\n-else\n-  Q := @\n-  E = echo $(1)\n-endif\n-\n-S := $(CFG_SRC_DIR)\n-\n-define DEF_X\n-X_$(1) := $(CFG_EXE_SUFFIX_$(1))\n-endef\n-$(foreach target,$(CFG_TARGET),\\\n-  $(eval $(call DEF_X,$(target))))\n-\n-# \"Source\" files we generate in builddir along the way.\n-GENERATED :=\n-\n-# Delete the built-in rules.\n-.SUFFIXES:\n-%:: %,v\n-%:: RCS/%,v\n-%:: RCS/%\n-%:: s.%\n-%:: SCCS/s.%\n-\n-\n ######################################################################\n-# Cleaning out old crates\n-######################################################################\n-\n-# $(1) is the path for directory to match against\n-# $(2) is the glob to use in the match\n-#\n-# Note that a common bug is to accidentally construct the glob denoted\n-# by $(2) with a space character prefix, which invalidates the\n-# construction $(1)$(2).\n-define CHECK_FOR_OLD_GLOB_MATCHES\n-  $(Q)MATCHES=\"$(wildcard $(1))\"; if [ -n \"$$MATCHES\" ] ; then echo \"warning: there are previous\" \\'$(notdir $(2))\\' \"libraries:\" $$MATCHES; fi\n-endef\n-\n-# Same interface as above, but deletes rather than just listing the files.\n-ifdef VERBOSE\n-define REMOVE_ALL_OLD_GLOB_MATCHES\n-  $(Q)MATCHES=\"$(wildcard $(1))\"; if [ -n \"$$MATCHES\" ] ; then echo \"warning: removing previous\" \\'$(notdir $(1))\\' \"libraries:\" $$MATCHES; rm $$MATCHES ; fi\n-endef\n-else\n-define REMOVE_ALL_OLD_GLOB_MATCHES\n-  $(Q)MATCHES=\"$(wildcard $(1))\"; if [ -n \"$$MATCHES\" ] ; then rm $$MATCHES ; fi\n-endef\n-endif\n-\n-# We use a different strategy for LIST_ALL_OLD_GLOB_MATCHES_EXCEPT\n-# than in the macros above because it needs the result of running the\n-# `ls` command after other rules in the command list have run; the\n-# macro-expander for $(wildcard ...) would deliver its results too\n-# soon. (This is in contrast to the macros above, which are meant to\n-# be run at the outset of a command list in a rule.)\n-ifdef VERBOSE\n-define LIST_ALL_OLD_GLOB_MATCHES\n-  @echo \"info: now are following matches for\" '$(notdir $(1))' \"libraries:\"\n-  @( ls $(1) 2>/dev/null || true )\n-endef\n-else\n-define LIST_ALL_OLD_GLOB_MATCHES\n-endef\n-endif\n-\n-######################################################################\n-# LLVM macros\n-######################################################################\n-\n-# FIXME: x86-ism\n-LLVM_COMPONENTS=x86 arm mips ipo bitreader bitwriter linker asmparser jit mcjit \\\n-                interpreter instrumentation\n-\n-# Only build these LLVM tools\n-LLVM_TOOLS=bugpoint llc llvm-ar llvm-as llvm-dis llvm-mc opt llvm-extract\n-\n-define DEF_LLVM_VARS\n-# The configure script defines these variables with the target triples\n-# separated by Z. This defines new ones with the expected format.\n-CFG_LLVM_BUILD_DIR_$(1):=$$(CFG_LLVM_BUILD_DIR_$(subst -,_,$(1)))\n-CFG_LLVM_INST_DIR_$(1):=$$(CFG_LLVM_INST_DIR_$(subst -,_,$(1)))\n-\n-# Any rules that depend on LLVM should depend on LLVM_CONFIG\n-LLVM_CONFIG_$(1):=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-config$$(X_$(1))\n-LLVM_MC_$(1):=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-mc$$(X_$(1))\n-LLVM_VERSION_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --version)\n-LLVM_BINDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --bindir)\n-LLVM_INCDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --includedir)\n-LLVM_LIBDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --libdir)\n-LLVM_LIBS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --libs $$(LLVM_COMPONENTS))\n-LLVM_LDFLAGS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --ldflags)\n-# On FreeBSD, it may search wrong headers (that are for pre-installed LLVM),\n-# so we replace -I with -iquote to ensure that it searches bundled LLVM first.\n-LLVM_CXXFLAGS_$(1)=$$(subst -I, -iquote , $$(shell \"$$(LLVM_CONFIG_$(1))\" --cxxflags))\n-LLVM_HOST_TRIPLE_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --host-target)\n-\n-LLVM_AS_$(1)=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-as$$(X_$(1))\n-LLC_$(1)=$$(CFG_LLVM_INST_DIR_$(1))/bin/llc$$(X_$(1))\n-\n-endef\n-\n-$(foreach host,$(CFG_HOST), \\\n- $(eval $(call DEF_LLVM_VARS,$(host))))\n-\n-######################################################################\n-# Exports for sub-utilities\n-######################################################################\n-\n-# Note that any variable that re-configure should pick up needs to be\n-# exported\n-\n-export CFG_SRC_DIR\n-export CFG_BUILD_DIR\n-export CFG_VERSION\n-export CFG_VERSION_WIN\n-export CFG_RELEASE\n-export CFG_BUILD\n-export CFG_LLVM_ROOT\n-export CFG_ENABLE_MINGW_CROSS\n-export CFG_PREFIX\n-export CFG_LIBDIR\n-export CFG_RUSTLIBDIR\n-export CFG_LIBDIR_RELATIVE\n-export CFG_DISABLE_INJECT_STD_VERSION\n-\n-######################################################################\n-# Per-stage targets and runner\n-######################################################################\n-\n-include $(CFG_SRC_DIR)mk/crates.mk\n-\n-define SREQ\n-# $(1) is the stage number\n-# $(2) is the target triple\n-# $(3) is the host triple\n-\n-# Destinations of artifacts for the host compiler\n-HROOT$(1)_H_$(3) = $(3)/stage$(1)\n-HBIN$(1)_H_$(3) = $$(HROOT$(1)_H_$(3))/bin\n-HLIB$(1)_H_$(3) = $$(HROOT$(1)_H_$(3))/$$(CFG_LIBDIR_RELATIVE)\n-\n-# Destinations of artifacts for target architectures\n-TROOT$(1)_T_$(2)_H_$(3) = $$(HLIB$(1)_H_$(3))/$$(CFG_RUSTLIBDIR)/$(2)\n-TBIN$(1)_T_$(2)_H_$(3) = $$(TROOT$(1)_T_$(2)_H_$(3))/bin\n-TLIB$(1)_T_$(2)_H_$(3) = $$(TROOT$(1)_T_$(2)_H_$(3))/lib\n-\n-# Preqrequisites for using the stageN compiler\n-ifeq ($(1),0)\n-HSREQ$(1)_H_$(3) = $$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\n-else\n-HSREQ$(1)_H_$(3) = \\\n-\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3)) \\\n-\t$$(HLIB$(1)_H_$(3))/stamp.rustc \\\n-\t$$(foreach dep,$$(RUST_DEPS_rustc),$$(HLIB$(1)_H_$(3))/stamp.$$(dep)) \\\n-\t$$(MKFILE_DEPS)\n-endif\n-\n-# Prerequisites for using the stageN compiler to build target artifacts\n-TSREQ$(1)_T_$(2)_H_$(3) = \\\n-\t$$(HSREQ$(1)_H_$(3)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/libcompiler-rt.a\n-\n-# Prerequisites for a working stageN compiler and libraries, for a specific\n-# target\n-SREQ$(1)_T_$(2)_H_$(3) = \\\n-\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n-\t$$(foreach dep,$$(TARGET_CRATES),\\\n-\t    $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep))\n-\n-# Prerequisites for a working stageN compiler and complete set of target\n-# libraries\n-CSREQ$(1)_T_$(2)_H_$(3) = \\\n-\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n-\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n-\t$$(foreach dep,$$(CRATES),$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep)) \\\n-\t$$(foreach dep,$$(HOST_CRATES),$$(HLIB$(1)_H_$(3))/stamp.$$(dep))\n-\n-ifeq ($(1),0)\n-# Don't run the the stage0 compiler under valgrind - that ship has sailed\n-CFG_VALGRIND_COMPILE$(1) =\n-else\n-CFG_VALGRIND_COMPILE$(1) = $$(CFG_VALGRIND_COMPILE)\n-endif\n-\n-# Add RUSTFLAGS_STAGEN values to the build command\n-EXTRAFLAGS_STAGE$(1) = $$(RUSTFLAGS_STAGE$(1))\n-\n-CFGFLAG$(1)_T_$(2)_H_$(3) = stage$(1)\n-\n-# Pass --cfg stage0 only for the build->host part of stage0;\n-# if you're building a cross config, the host->* parts are\n-# effectively stage1, since it uses the just-built stage0.\n-ifeq ($(1),0)\n-ifneq ($(strip $(CFG_BUILD)),$(strip $(3)))\n-CFGFLAG$(1)_T_$(2)_H_$(3) = stage1\n-endif\n-endif\n-\n-ifdef CFG_DISABLE_RPATH\n-ifeq ($$(OSTYPE_$(3)),apple-darwin)\n-  RPATH_VAR$(1)_T_$(2)_H_$(3) := \\\n-      DYLD_LIBRARY_PATH=\"$$$$DYLD_LIBRARY_PATH:$$(HLIB$(1)_H_$(3))\"\n-else\n-  RPATH_VAR$(1)_T_$(2)_H_$(3) := \\\n-      LD_LIBRARY_PATH=\"$$$$LD_LIBRARY_PATH:$$(HLIB$(1)_H_$(3))\"\n-endif\n-else\n-    RPATH_VAR$(1)_T_$(2)_H_$(3) :=\n-endif\n-\n-STAGE$(1)_T_$(2)_H_$(3) := \t\t\t\t\t\t\\\n-\t$$(Q)$$(RPATH_VAR$(1)_T_$(2)_H_$(3))                            \\\n-\t\t$$(call CFG_RUN_TARG_$(3),$(1),\t\t\t\t\\\n-\t\t$$(CFG_VALGRIND_COMPILE$(1))\t\t\t\t\\\n-\t\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\t\t\t\\\n-\t\t--cfg $$(CFGFLAG$(1)_T_$(2)_H_$(3))\t\t\t\\\n-\t\t$$(CFG_RUSTC_FLAGS) $$(EXTRAFLAGS_STAGE$(1)) --target=$(2)) \\\n-                $$(RUSTC_FLAGS_$(2))\n-\n-PERF_STAGE$(1)_T_$(2)_H_$(3) :=\t\t\t\t\t\t\\\n-\t$$(Q)$$(call CFG_RUN_TARG_$(3),$(1),\t\t\t\t\\\n-\t\t$$(CFG_PERF_TOOL) \t\t\t\t\t\\\n-\t\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\t\t\t\\\n-\t\t--cfg $$(CFGFLAG$(1)_T_$(2)_H_$(3))\t\t\t\\\n-\t\t$$(CFG_RUSTC_FLAGS) $$(EXTRAFLAGS_STAGE$(1)) --target=$(2)) \\\n-                $$(RUSTC_FLAGS_$(2))\n-\n-endef\n-\n-$(foreach build,$(CFG_HOST), \\\n- $(eval $(foreach target,$(CFG_TARGET), \\\n-  $(eval $(foreach stage,$(STAGES), \\\n-   $(eval $(call SREQ,$(stage),$(target),$(build))))))))\n-\n-######################################################################\n-# rustc-H-targets\n-#\n-# Builds a functional Rustc for the given host.\n-######################################################################\n-\n-define DEF_RUSTC_STAGE_TARGET\n-# $(1) == architecture\n-# $(2) == stage\n-\n-rustc-stage$(2)-H-$(1):\t\t\t\t\t\t\t\\\n-\t$$(foreach target,$$(CFG_TARGET),$$(SREQ$(2)_T_$$(target)_H_$(1)))\n-\n-endef\n-\n-$(foreach host,$(CFG_HOST),\t\t\t\t\t\t\\\n- $(eval $(foreach stage,1 2 3,\t\t\t\t\t\t\\\n-  $(eval $(call DEF_RUSTC_STAGE_TARGET,$(host),$(stage))))))\n-\n-rustc-stage1: rustc-stage1-H-$(CFG_BUILD)\n-rustc-stage2: rustc-stage2-H-$(CFG_BUILD)\n-rustc-stage3: rustc-stage3-H-$(CFG_BUILD)\n-\n-define DEF_RUSTC_TARGET\n-# $(1) == architecture\n-\n-rustc-H-$(1): rustc-stage2-H-$(1)\n-endef\n-\n-$(foreach host,$(CFG_TARGET),\t\t\t\\\n- $(eval $(call DEF_RUSTC_TARGET,$(host))))\n-\n-rustc-stage1: rustc-stage1-H-$(CFG_BUILD)\n-rustc-stage2: rustc-stage2-H-$(CFG_BUILD)\n-rustc-stage3: rustc-stage3-H-$(CFG_BUILD)\n-rustc: rustc-H-$(CFG_BUILD)\n-\n-rustc-H-all: $(foreach host,$(CFG_HOST),rustc-H-$(host))\n-\n-######################################################################\n-# Entrypoint rule\n-######################################################################\n-\n-.DEFAULT_GOAL := all\n-\n-define ALL_TARGET_N\n-ifneq ($$(findstring $(1),$$(CFG_HOST)),)\n-# This is a host\n-all-target-$(1)-host-$(2): $$(CSREQ2_T_$(1)_H_$(2))\n-else\n-# This is a target only\n-all-target-$(1)-host-$(2): $$(SREQ2_T_$(1)_H_$(2))\n-endif\n-endef\n-\n-$(foreach target,$(CFG_TARGET), \\\n- $(foreach host,$(CFG_HOST), \\\n- $(eval $(call ALL_TARGET_N,$(target),$(host)))))\n-\n-ALL_TARGET_RULES = $(foreach target,$(CFG_TARGET), \\\n-\t$(foreach host,$(CFG_HOST), \\\n- all-target-$(target)-host-$(host)))\n-\n-all: $(ALL_TARGET_RULES) $(GENERATED) docs\n-\n-\n-######################################################################\n-# Re-configuration\n-######################################################################\n-\n-ifndef CFG_DISABLE_MANAGE_SUBMODULES\n-# This is a pretty expensive operation but I don't see any way to avoid it\n-NEED_GIT_RECONFIG=$(shell cd \"$(CFG_SRC_DIR)\" && \"$(CFG_GIT)\" submodule status | grep -c '^\\(+\\|-\\)')\n-else\n-NEED_GIT_RECONFIG=0\n-endif\n-\n-ifeq ($(NEED_GIT_RECONFIG),0)\n-else\n-# If the submodules have changed then always execute config.mk\n-.PHONY: config.stamp\n-endif\n-\n-Makefile config.mk: config.stamp\n-\n-config.stamp: $(S)configure $(S)Makefile.in $(S)src/snapshots.txt\n-\t@$(call E, cfg: reconfiguring)\n-\t$(Q)$(S)configure $(CFG_CONFIGURE_ARGS)\n-\n-\n-######################################################################\n-# Primary-target makefiles\n+# Primary rules\n ######################################################################\n \n # Issue #9531: If you change the order of any of the following (or add\n # new definitions), make sure definitions always precede their uses,\n # especially for the dependency lists of recipes.\n \n+# First, load the variables exported by the configure script\n+include config.mk\n+\n+# Just a few macros used everywhere\n+include $(CFG_SRC_DIR)mk/util.mk\n+# All crates and their dependencies\n+include $(CFG_SRC_DIR)mk/crates.mk\n+# Reconfiguring when the makefiles or submodules change\n+include $(CFG_SRC_DIR)mk/reconfig.mk\n+# Various bits of setup, common macros, and top-level rules\n+include $(CFG_SRC_DIR)mk/main.mk\n+# C and assembly components that are not LLVM\n include $(CFG_SRC_DIR)mk/rt.mk\n+# Rules for crates in the target directories\n include $(CFG_SRC_DIR)mk/target.mk\n+# Rules for crates in the host directories\n include $(CFG_SRC_DIR)mk/host.mk\n+# Special rules for bootstrapping stage0\n include $(CFG_SRC_DIR)mk/stage0.mk\n+# Rust-specific LLVM extensions\n include $(CFG_SRC_DIR)mk/rustllvm.mk\n+# Documentation\n include $(CFG_SRC_DIR)mk/docs.mk\n+# LLVM\n include $(CFG_SRC_DIR)mk/llvm.mk\n \n ######################################################################\n # Secondary makefiles, conditionalized for speed\n ######################################################################\n \n+# Source and binary distribution artifacts\n ifneq ($(strip $(findstring dist,$(MAKECMDGOALS))   \\\n                $(findstring check,$(MAKECMDGOALS))  \\\n                $(findstring test,$(MAKECMDGOALS))   \\\n@@ -592,12 +147,14 @@ ifneq ($(strip $(findstring dist,$(MAKECMDGOALS))   \\\n   include $(CFG_SRC_DIR)mk/dist.mk\n endif\n \n+# Binary snapshots\n ifneq ($(strip $(findstring snap,$(MAKECMDGOALS))   \\\n                $(findstring clean,$(MAKECMDGOALS))),)\n   CFG_INFO := $(info cfg: including snap rules)\n   include $(CFG_SRC_DIR)mk/snap.mk\n endif\n \n+# The test suite\n ifneq ($(strip $(findstring check,$(MAKECMDGOALS)) \\\n                $(findstring test,$(MAKECMDGOALS))  \\\n                $(findstring perf,$(MAKECMDGOALS))  \\\n@@ -606,21 +163,25 @@ ifneq ($(strip $(findstring check,$(MAKECMDGOALS)) \\\n   include $(CFG_SRC_DIR)mk/tests.mk\n endif\n \n+# Performance and benchmarking\n ifneq ($(findstring perf,$(MAKECMDGOALS)),)\n   CFG_INFO := $(info cfg: including perf rules)\n   include $(CFG_SRC_DIR)mk/perf.mk\n endif\n \n+# Cleaning\n ifneq ($(findstring clean,$(MAKECMDGOALS)),)\n   CFG_INFO := $(info cfg: including clean rules)\n   include $(CFG_SRC_DIR)mk/clean.mk\n endif\n \n+# Installation from the build directory\n ifneq ($(findstring install,$(MAKECMDGOALS)),)\n   CFG_INFO := $(info cfg: including install rules)\n   include $(CFG_SRC_DIR)mk/install.mk\n endif\n \n+# CTAGS building\n ifneq ($(strip $(findstring TAGS.emacs,$(MAKECMDGOALS)) \\\n                $(findstring TAGS.vi,$(MAKECMDGOALS))),)\n   CFG_INFO := $(info cfg: including ctags rules)\n@@ -631,9 +192,3 @@ endif\n # header file dependencies.\n ALL_DEP_FILES := $(ALL_OBJ_FILES:%.o=%.d)\n -include $(ALL_DEP_FILES)\n-\n-help:\n-# Show the comments from this file as \"help\"\n-# pick everything between tags | remove first line | remove last line\n-# | remove extra (?) line | strip leading `#` from lines\n-\t$(Q)awk '/<help>/,/<\\/help>/' $(S)/Makefile.in | sed '1d' | sed '$$d' | sed 's/^# \\?//'"}, {"sha": "064b9cc35113e1fb6203a15a919c7ee66299e6cc", "filename": "mk/main.mk", "status": "added", "additions": 431, "deletions": 0, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/2852fea61e51752a0a7f6c2aeb8fe798a2890c4e/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2852fea61e51752a0a7f6c2aeb8fe798a2890c4e/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=2852fea61e51752a0a7f6c2aeb8fe798a2890c4e", "patch": "@@ -0,0 +1,431 @@\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# We track all of the object files we might build so that we can find\n+# and include all of the .d files in one fell swoop.\n+ALL_OBJ_FILES :=\n+\n+MKFILE_DEPS := config.stamp $(call rwildcard,$(CFG_SRC_DIR)mk/,*)\n+NON_BUILD_HOST = $(filter-out $(CFG_BUILD),$(CFG_HOST))\n+NON_BUILD_TARGET = $(filter-out $(CFG_BUILD),$(CFG_TARGET))\n+\n+ifneq ($(MAKE_RESTARTS),)\n+CFG_INFO := $(info cfg: make restarts: $(MAKE_RESTARTS))\n+endif\n+\n+CFG_INFO := $(info cfg: build triple $(CFG_BUILD))\n+CFG_INFO := $(info cfg: host triples $(CFG_HOST))\n+CFG_INFO := $(info cfg: target triples $(CFG_TARGET))\n+\n+ifneq ($(wildcard $(NON_BUILD_HOST)),)\n+CFG_INFO := $(info cfg: non-build host triples $(NON_BUILD_HOST))\n+endif\n+ifneq ($(wildcard $(NON_BUILD_TARGET)),)\n+CFG_INFO := $(info cfg: non-build target triples $(NON_BUILD_TARGET))\n+endif\n+\n+CFG_RUSTC_FLAGS := $(RUSTFLAGS)\n+CFG_GCCISH_CFLAGS :=\n+CFG_GCCISH_LINK_FLAGS :=\n+\n+ifdef CFG_DISABLE_OPTIMIZE\n+  $(info cfg: disabling rustc optimization (CFG_DISABLE_OPTIMIZE))\n+  CFG_RUSTC_FLAGS +=\n+else\n+  # The rtopt cfg turns off runtime sanity checks\n+  CFG_RUSTC_FLAGS += -O --cfg rtopt\n+endif\n+\n+ifdef CFG_DISABLE_DEBUG\n+  CFG_RUSTC_FLAGS += --cfg ndebug\n+  CFG_GCCISH_CFLAGS += -DRUST_NDEBUG\n+else\n+  $(info cfg: enabling more debugging (CFG_ENABLE_DEBUG))\n+  CFG_RUSTC_FLAGS += --cfg debug\n+  CFG_GCCISH_CFLAGS += -DRUST_DEBUG\n+endif\n+\n+ifdef SAVE_TEMPS\n+  CFG_RUSTC_FLAGS += --save-temps\n+endif\n+ifdef ASM_COMMENTS\n+  CFG_RUSTC_FLAGS += -Z asm-comments\n+endif\n+ifdef TIME_PASSES\n+  CFG_RUSTC_FLAGS += -Z time-passes\n+endif\n+ifdef TIME_LLVM_PASSES\n+  CFG_RUSTC_FLAGS += -Z time-llvm-passes\n+endif\n+ifdef TRACE\n+  CFG_RUSTC_FLAGS += -Z trace\n+endif\n+ifdef CFG_DISABLE_RPATH\n+CFG_RUSTC_FLAGS += -C no-rpath\n+endif\n+\n+# The executables crated during this compilation process have no need to include\n+# static copies of libstd and libextra. We also generate dynamic versions of all\n+# libraries, so in the interest of space, prefer dynamic linking throughout the\n+# compilation process.\n+#\n+# Note though that these flags are omitted for stage2+. This means that the\n+# snapshot will be generated with a statically linked rustc so we only have to\n+# worry about the distribution of one file (with its native dynamic\n+# dependencies)\n+RUSTFLAGS_STAGE0 += -C prefer-dynamic\n+RUSTFLAGS_STAGE1 += -C prefer-dynamic\n+\n+# platform-specific auto-configuration\n+include $(CFG_SRC_DIR)mk/platform.mk\n+\n+# Run the stage1/2 compilers under valgrind\n+ifdef VALGRIND_COMPILE\n+  CFG_VALGRIND_COMPILE :=$(CFG_VALGRIND)\n+else\n+  CFG_VALGRIND_COMPILE :=\n+endif\n+\n+# version-string calculation\n+CFG_GIT_DIR := $(CFG_SRC_DIR).git\n+CFG_RELEASE = 0.10-pre\n+CFG_VERSION = $(CFG_RELEASE)\n+# windows exe's need numeric versions - don't use anything but\n+# numbers and dots here\n+CFG_VERSION_WIN = 0.10\n+\n+# since $(CFG_GIT) may contain spaces (especially on Windows),\n+# we need to escape them. (\" \" to r\"\\ \")\n+# Note that $(subst ...) ignores space after `subst`,\n+# so we use a hack: define $(SPACE) which contains space character.\n+SPACE :=\n+SPACE +=\n+ifneq ($(wildcard $(subst $(SPACE),\\$(SPACE),$(CFG_GIT))),)\n+ifneq ($(wildcard $(subst $(SPACE),\\$(SPACE),$(CFG_GIT_DIR))),)\n+    CFG_VERSION += $(shell git --git-dir='$(CFG_GIT_DIR)' log -1 \\\n+                     --pretty=format:'(%h %ci)')\n+    CFG_VER_HASH = $(shell git --git-dir='$(CFG_GIT_DIR)' rev-parse HEAD)\n+endif\n+endif\n+\n+ifdef CFG_ENABLE_VALGRIND\n+  $(info cfg: enabling valgrind (CFG_ENABLE_VALGRIND))\n+else\n+  CFG_VALGRIND :=\n+endif\n+ifdef CFG_BAD_VALGRIND\n+  $(info cfg: disabling valgrind due to its unreliability on this platform)\n+  CFG_VALGRIND :=\n+endif\n+\n+\n+######################################################################\n+# Target-and-rule \"utility variables\"\n+######################################################################\n+\n+define DEF_X\n+X_$(1) := $(CFG_EXE_SUFFIX_$(1))\n+endef\n+$(foreach target,$(CFG_TARGET),\\\n+  $(eval $(call DEF_X,$(target))))\n+\n+# \"Source\" files we generate in builddir along the way.\n+GENERATED :=\n+\n+# Delete the built-in rules.\n+.SUFFIXES:\n+%:: %,v\n+%:: RCS/%,v\n+%:: RCS/%\n+%:: s.%\n+%:: SCCS/s.%\n+\n+\n+######################################################################\n+# Cleaning out old crates\n+######################################################################\n+\n+# $(1) is the path for directory to match against\n+# $(2) is the glob to use in the match\n+#\n+# Note that a common bug is to accidentally construct the glob denoted\n+# by $(2) with a space character prefix, which invalidates the\n+# construction $(1)$(2).\n+define CHECK_FOR_OLD_GLOB_MATCHES\n+  $(Q)MATCHES=\"$(wildcard $(1))\"; if [ -n \"$$MATCHES\" ] ; then echo \"warning: there are previous\" \\'$(notdir $(2))\\' \"libraries:\" $$MATCHES; fi\n+endef\n+\n+# Same interface as above, but deletes rather than just listing the files.\n+ifdef VERBOSE\n+define REMOVE_ALL_OLD_GLOB_MATCHES\n+  $(Q)MATCHES=\"$(wildcard $(1))\"; if [ -n \"$$MATCHES\" ] ; then echo \"warning: removing previous\" \\'$(notdir $(1))\\' \"libraries:\" $$MATCHES; rm $$MATCHES ; fi\n+endef\n+else\n+define REMOVE_ALL_OLD_GLOB_MATCHES\n+  $(Q)MATCHES=\"$(wildcard $(1))\"; if [ -n \"$$MATCHES\" ] ; then rm $$MATCHES ; fi\n+endef\n+endif\n+\n+# We use a different strategy for LIST_ALL_OLD_GLOB_MATCHES_EXCEPT\n+# than in the macros above because it needs the result of running the\n+# `ls` command after other rules in the command list have run; the\n+# macro-expander for $(wildcard ...) would deliver its results too\n+# soon. (This is in contrast to the macros above, which are meant to\n+# be run at the outset of a command list in a rule.)\n+ifdef VERBOSE\n+define LIST_ALL_OLD_GLOB_MATCHES\n+  @echo \"info: now are following matches for\" '$(notdir $(1))' \"libraries:\"\n+  @( ls $(1) 2>/dev/null || true )\n+endef\n+else\n+define LIST_ALL_OLD_GLOB_MATCHES\n+endef\n+endif\n+\n+######################################################################\n+# LLVM macros\n+######################################################################\n+\n+# FIXME: x86-ism\n+LLVM_COMPONENTS=x86 arm mips ipo bitreader bitwriter linker asmparser jit mcjit \\\n+                interpreter instrumentation\n+\n+# Only build these LLVM tools\n+LLVM_TOOLS=bugpoint llc llvm-ar llvm-as llvm-dis llvm-mc opt llvm-extract\n+\n+define DEF_LLVM_VARS\n+# The configure script defines these variables with the target triples\n+# separated by Z. This defines new ones with the expected format.\n+CFG_LLVM_BUILD_DIR_$(1):=$$(CFG_LLVM_BUILD_DIR_$(subst -,_,$(1)))\n+CFG_LLVM_INST_DIR_$(1):=$$(CFG_LLVM_INST_DIR_$(subst -,_,$(1)))\n+\n+# Any rules that depend on LLVM should depend on LLVM_CONFIG\n+LLVM_CONFIG_$(1):=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-config$$(X_$(1))\n+LLVM_MC_$(1):=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-mc$$(X_$(1))\n+LLVM_VERSION_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --version)\n+LLVM_BINDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --bindir)\n+LLVM_INCDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --includedir)\n+LLVM_LIBDIR_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --libdir)\n+LLVM_LIBS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --libs $$(LLVM_COMPONENTS))\n+LLVM_LDFLAGS_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --ldflags)\n+# On FreeBSD, it may search wrong headers (that are for pre-installed LLVM),\n+# so we replace -I with -iquote to ensure that it searches bundled LLVM first.\n+LLVM_CXXFLAGS_$(1)=$$(subst -I, -iquote , $$(shell \"$$(LLVM_CONFIG_$(1))\" --cxxflags))\n+LLVM_HOST_TRIPLE_$(1)=$$(shell \"$$(LLVM_CONFIG_$(1))\" --host-target)\n+\n+LLVM_AS_$(1)=$$(CFG_LLVM_INST_DIR_$(1))/bin/llvm-as$$(X_$(1))\n+LLC_$(1)=$$(CFG_LLVM_INST_DIR_$(1))/bin/llc$$(X_$(1))\n+\n+endef\n+\n+$(foreach host,$(CFG_HOST), \\\n+ $(eval $(call DEF_LLVM_VARS,$(host))))\n+\n+######################################################################\n+# Exports for sub-utilities\n+######################################################################\n+\n+# Note that any variable that re-configure should pick up needs to be\n+# exported\n+\n+export CFG_SRC_DIR\n+export CFG_BUILD_DIR\n+export CFG_VERSION\n+export CFG_VERSION_WIN\n+export CFG_RELEASE\n+export CFG_BUILD\n+export CFG_LLVM_ROOT\n+export CFG_ENABLE_MINGW_CROSS\n+export CFG_PREFIX\n+export CFG_LIBDIR\n+export CFG_RUSTLIBDIR\n+export CFG_LIBDIR_RELATIVE\n+export CFG_DISABLE_INJECT_STD_VERSION\n+\n+######################################################################\n+# Per-stage targets and runner\n+######################################################################\n+\n+STAGES = 0 1 2 3\n+\n+define SREQ\n+# $(1) is the stage number\n+# $(2) is the target triple\n+# $(3) is the host triple\n+\n+# Destinations of artifacts for the host compiler\n+HROOT$(1)_H_$(3) = $(3)/stage$(1)\n+HBIN$(1)_H_$(3) = $$(HROOT$(1)_H_$(3))/bin\n+HLIB$(1)_H_$(3) = $$(HROOT$(1)_H_$(3))/$$(CFG_LIBDIR_RELATIVE)\n+\n+# Destinations of artifacts for target architectures\n+TROOT$(1)_T_$(2)_H_$(3) = $$(HLIB$(1)_H_$(3))/$$(CFG_RUSTLIBDIR)/$(2)\n+TBIN$(1)_T_$(2)_H_$(3) = $$(TROOT$(1)_T_$(2)_H_$(3))/bin\n+TLIB$(1)_T_$(2)_H_$(3) = $$(TROOT$(1)_T_$(2)_H_$(3))/lib\n+\n+# Preqrequisites for using the stageN compiler\n+ifeq ($(1),0)\n+HSREQ$(1)_H_$(3) = $$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\n+else\n+HSREQ$(1)_H_$(3) = \\\n+\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3)) \\\n+\t$$(HLIB$(1)_H_$(3))/stamp.rustc \\\n+\t$$(foreach dep,$$(RUST_DEPS_rustc),$$(HLIB$(1)_H_$(3))/stamp.$$(dep)) \\\n+\t$$(MKFILE_DEPS)\n+endif\n+\n+# Prerequisites for using the stageN compiler to build target artifacts\n+TSREQ$(1)_T_$(2)_H_$(3) = \\\n+\t$$(HSREQ$(1)_H_$(3)) \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/libcompiler-rt.a\n+\n+# Prerequisites for a working stageN compiler and libraries, for a specific\n+# target\n+SREQ$(1)_T_$(2)_H_$(3) = \\\n+\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n+\t$$(foreach dep,$$(TARGET_CRATES),\\\n+\t    $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep))\n+\n+# Prerequisites for a working stageN compiler and complete set of target\n+# libraries\n+CSREQ$(1)_T_$(2)_H_$(3) = \\\n+\t$$(TSREQ$(1)_T_$(2)_H_$(3)) \\\n+\t$$(HBIN$(1)_H_$(3))/rustdoc$$(X_$(3)) \\\n+\t$$(foreach dep,$$(CRATES),$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(dep)) \\\n+\t$$(foreach dep,$$(HOST_CRATES),$$(HLIB$(1)_H_$(3))/stamp.$$(dep))\n+\n+ifeq ($(1),0)\n+# Don't run the the stage0 compiler under valgrind - that ship has sailed\n+CFG_VALGRIND_COMPILE$(1) =\n+else\n+CFG_VALGRIND_COMPILE$(1) = $$(CFG_VALGRIND_COMPILE)\n+endif\n+\n+# Add RUSTFLAGS_STAGEN values to the build command\n+EXTRAFLAGS_STAGE$(1) = $$(RUSTFLAGS_STAGE$(1))\n+\n+CFGFLAG$(1)_T_$(2)_H_$(3) = stage$(1)\n+\n+# Pass --cfg stage0 only for the build->host part of stage0;\n+# if you're building a cross config, the host->* parts are\n+# effectively stage1, since it uses the just-built stage0.\n+ifeq ($(1),0)\n+ifneq ($(strip $(CFG_BUILD)),$(strip $(3)))\n+CFGFLAG$(1)_T_$(2)_H_$(3) = stage1\n+endif\n+endif\n+\n+ifdef CFG_DISABLE_RPATH\n+ifeq ($$(OSTYPE_$(3)),apple-darwin)\n+  RPATH_VAR$(1)_T_$(2)_H_$(3) := \\\n+      DYLD_LIBRARY_PATH=\"$$$$DYLD_LIBRARY_PATH:$$(HLIB$(1)_H_$(3))\"\n+else\n+  RPATH_VAR$(1)_T_$(2)_H_$(3) := \\\n+      LD_LIBRARY_PATH=\"$$$$LD_LIBRARY_PATH:$$(HLIB$(1)_H_$(3))\"\n+endif\n+else\n+    RPATH_VAR$(1)_T_$(2)_H_$(3) :=\n+endif\n+\n+STAGE$(1)_T_$(2)_H_$(3) := \t\t\t\t\t\t\\\n+\t$$(Q)$$(RPATH_VAR$(1)_T_$(2)_H_$(3))                            \\\n+\t\t$$(call CFG_RUN_TARG_$(3),$(1),\t\t\t\t\\\n+\t\t$$(CFG_VALGRIND_COMPILE$(1))\t\t\t\t\\\n+\t\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\t\t\t\\\n+\t\t--cfg $$(CFGFLAG$(1)_T_$(2)_H_$(3))\t\t\t\\\n+\t\t$$(CFG_RUSTC_FLAGS) $$(EXTRAFLAGS_STAGE$(1)) --target=$(2)) \\\n+                $$(RUSTC_FLAGS_$(2))\n+\n+PERF_STAGE$(1)_T_$(2)_H_$(3) :=\t\t\t\t\t\t\\\n+\t$$(Q)$$(call CFG_RUN_TARG_$(3),$(1),\t\t\t\t\\\n+\t\t$$(CFG_PERF_TOOL) \t\t\t\t\t\\\n+\t\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3))\t\t\t\\\n+\t\t--cfg $$(CFGFLAG$(1)_T_$(2)_H_$(3))\t\t\t\\\n+\t\t$$(CFG_RUSTC_FLAGS) $$(EXTRAFLAGS_STAGE$(1)) --target=$(2)) \\\n+                $$(RUSTC_FLAGS_$(2))\n+\n+endef\n+\n+$(foreach build,$(CFG_HOST), \\\n+ $(eval $(foreach target,$(CFG_TARGET), \\\n+  $(eval $(foreach stage,$(STAGES), \\\n+   $(eval $(call SREQ,$(stage),$(target),$(build))))))))\n+\n+######################################################################\n+# rustc-H-targets\n+#\n+# Builds a functional Rustc for the given host.\n+######################################################################\n+\n+define DEF_RUSTC_STAGE_TARGET\n+# $(1) == architecture\n+# $(2) == stage\n+\n+rustc-stage$(2)-H-$(1):\t\t\t\t\t\t\t\\\n+\t$$(foreach target,$$(CFG_TARGET),$$(SREQ$(2)_T_$$(target)_H_$(1)))\n+\n+endef\n+\n+$(foreach host,$(CFG_HOST),\t\t\t\t\t\t\\\n+ $(eval $(foreach stage,1 2 3,\t\t\t\t\t\t\\\n+  $(eval $(call DEF_RUSTC_STAGE_TARGET,$(host),$(stage))))))\n+\n+rustc-stage1: rustc-stage1-H-$(CFG_BUILD)\n+rustc-stage2: rustc-stage2-H-$(CFG_BUILD)\n+rustc-stage3: rustc-stage3-H-$(CFG_BUILD)\n+\n+define DEF_RUSTC_TARGET\n+# $(1) == architecture\n+\n+rustc-H-$(1): rustc-stage2-H-$(1)\n+endef\n+\n+$(foreach host,$(CFG_TARGET),\t\t\t\\\n+ $(eval $(call DEF_RUSTC_TARGET,$(host))))\n+\n+rustc-stage1: rustc-stage1-H-$(CFG_BUILD)\n+rustc-stage2: rustc-stage2-H-$(CFG_BUILD)\n+rustc-stage3: rustc-stage3-H-$(CFG_BUILD)\n+rustc: rustc-H-$(CFG_BUILD)\n+\n+rustc-H-all: $(foreach host,$(CFG_HOST),rustc-H-$(host))\n+\n+######################################################################\n+# Entrypoint rule\n+######################################################################\n+\n+.DEFAULT_GOAL := all\n+\n+define ALL_TARGET_N\n+ifneq ($$(findstring $(1),$$(CFG_HOST)),)\n+# This is a host\n+all-target-$(1)-host-$(2): $$(CSREQ2_T_$(1)_H_$(2))\n+else\n+# This is a target only\n+all-target-$(1)-host-$(2): $$(SREQ2_T_$(1)_H_$(2))\n+endif\n+endef\n+\n+$(foreach target,$(CFG_TARGET), \\\n+ $(foreach host,$(CFG_HOST), \\\n+ $(eval $(call ALL_TARGET_N,$(target),$(host)))))\n+\n+ALL_TARGET_RULES = $(foreach target,$(CFG_TARGET), \\\n+\t$(foreach host,$(CFG_HOST), \\\n+ all-target-$(target)-host-$(host)))\n+\n+all: $(ALL_TARGET_RULES) $(GENERATED) docs\n+\n+help:\n+# Show the comments from Makefile.in as \"help\"\n+# pick everything between tags | remove first line | remove last line\n+# | remove extra (?) line | strip leading `#` from lines\n+\t$(Q)awk '/<help>/,/<\\/help>/' $(S)/Makefile.in | sed '1d' | sed '$$d' | sed 's/^# \\?//'"}, {"sha": "8b88fee0ad3d9a009478d5efe83be173195f8dd8", "filename": "mk/reconfig.mk", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2852fea61e51752a0a7f6c2aeb8fe798a2890c4e/mk%2Freconfig.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2852fea61e51752a0a7f6c2aeb8fe798a2890c4e/mk%2Freconfig.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Freconfig.mk?ref=2852fea61e51752a0a7f6c2aeb8fe798a2890c4e", "patch": "@@ -0,0 +1,33 @@\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# Recursive wildcard function\n+# http://blog.jgc.org/2011/07/gnu-make-recursive-wildcard-function.html\n+rwildcard=$(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2) \\\n+  $(filter $(subst *,%,$2),$d))\n+\n+ifndef CFG_DISABLE_MANAGE_SUBMODULES\n+# This is a pretty expensive operation but I don't see any way to avoid it\n+NEED_GIT_RECONFIG=$(shell cd \"$(CFG_SRC_DIR)\" && \"$(CFG_GIT)\" submodule status | grep -c '^\\(+\\|-\\)')\n+else\n+NEED_GIT_RECONFIG=0\n+endif\n+\n+ifeq ($(NEED_GIT_RECONFIG),0)\n+else\n+# If the submodules have changed then always execute config.mk\n+.PHONY: config.stamp\n+endif\n+\n+Makefile config.mk: config.stamp\n+\n+config.stamp: $(S)configure $(S)Makefile.in $(S)src/snapshots.txt\n+\t@$(call E, cfg: reconfiguring)\n+\t$(S)configure $(CFG_CONFIGURE_ARGS)"}, {"sha": "2f113f7622d34edc3c82f8400955cd58fad90aec", "filename": "mk/util.mk", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2852fea61e51752a0a7f6c2aeb8fe798a2890c4e/mk%2Futil.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2852fea61e51752a0a7f6c2aeb8fe798a2890c4e/mk%2Futil.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Futil.mk?ref=2852fea61e51752a0a7f6c2aeb8fe798a2890c4e", "patch": "@@ -0,0 +1,28 @@\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+ifdef VERBOSE\n+  Q :=\n+  E =\n+else\n+  Q := @\n+  E = echo $(1)\n+endif\n+\n+ifdef VERBOSE\n+  Q :=\n+  E =\n+else\n+  Q := @\n+  E = echo $(1)\n+endif\n+\n+S := $(CFG_SRC_DIR)\n+"}]}