{"sha": "171e6a16f74eceba5760791708a1382bfb1e6894", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3MWU2YTE2Zjc0ZWNlYmE1NzYwNzkxNzA4YTEzODJiZmIxZTY4OTQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-20T09:34:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-21T00:32:41Z"}, "message": "tutorial: Rewrite method section to deal with explicit self\n\nHas to be moved until after the pointer discussion.\n\n/cc: #4217", "tree": {"sha": "fae960ae6687e47d60fc518b285460731fe27b9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fae960ae6687e47d60fc518b285460731fe27b9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/171e6a16f74eceba5760791708a1382bfb1e6894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/171e6a16f74eceba5760791708a1382bfb1e6894", "html_url": "https://github.com/rust-lang/rust/commit/171e6a16f74eceba5760791708a1382bfb1e6894", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/171e6a16f74eceba5760791708a1382bfb1e6894/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d2c2dbf4b284ff898caea84e92dd313c6e2419a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d2c2dbf4b284ff898caea84e92dd313c6e2419a", "html_url": "https://github.com/rust-lang/rust/commit/7d2c2dbf4b284ff898caea84e92dd313c6e2419a"}], "stats": {"total": 157, "additions": 110, "deletions": 47}, "files": [{"sha": "c799f54acc76f765380ff89dc5ec565ff666063e", "filename": "doc/tutorial.md", "status": "modified", "additions": 110, "deletions": 47, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/171e6a16f74eceba5760791708a1382bfb1e6894/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/171e6a16f74eceba5760791708a1382bfb1e6894/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=171e6a16f74eceba5760791708a1382bfb1e6894", "patch": "@@ -918,7 +918,7 @@ match mytup {\n }\n ~~~~\n \n-# Functions and methods\n+# Functions\n \n We've already seen several function definitions. Like all other static\n declarations, such as `type`, functions can be declared both at the\n@@ -968,52 +968,6 @@ assert 8  == line(5, 3, 1);\n assert () == oops(5, 3, 1);\n ~~~~\n \n-Methods are like functions, except that they have an implicit argument\n-called `self`, which has the type that the method's receiver has. The\n-`self` argument is like 'this' in C++. An expression with dot\n-notation, as in `my_vec.len()`, denotes a method\n-call. Implementations, written with the `impl` keyword, can define\n-methods on most Rust types. As an example, let's define a `draw`\n-method on our `Shape` enum.\n-\n-~~~\n-# fn draw_circle(p: Point, f: float) { }\n-# fn draw_rectangle(p: Point, p: Point) { }\n-struct Point {\n-    x: float,\n-    y: float\n-}\n-\n-enum Shape {\n-    Circle(Point, float),\n-    Rectangle(Point, Point)\n-}\n-\n-impl Shape {\n-    fn draw() {\n-        match self {\n-            Circle(p, f) => draw_circle(p, f),\n-            Rectangle(p1, p2) => draw_rectangle(p1, p2)\n-        }\n-    }\n-}\n-\n-let s = Circle(Point { x: 1f, y: 2f }, 3f);\n-s.draw();\n-~~~\n-\n-This defines an _implementation_ for `Shape` containing a single\n-method, `draw`. In most respects the `draw` method is defined\n-like any other function, except for the name `self`. `self`\n-is a special value that is automatically in scope inside each method,\n-referring to the value being operated on. If we wanted we could add\n-additional methods to the same impl, or multiple impls for the same\n-type. We'll discuss methods more in the context of [traits and\n-generics](#generics).\n-\n-> ***Note:*** In the future, the method definition syntax will change to\n-> require declaring the `self` type explicitly, as the first argument.\n-\n # The Rust memory model\n \n At this junction, let's take a detour to explain the concepts involved\n@@ -1526,6 +1480,115 @@ if favorite_crayon_name.len() > 5 {\n }\n ~~~\n \n+# Methods\n+\n+Methods are like functions except that they always begin with a special argument,\n+called `self`,\n+which has the type of the method's receiver. The\n+`self` argument is like `this` in C++ and many other languages.\n+Methods are called with dot notation, as in `my_vec.len()`.\n+\n+_Implementations_, written with the `impl` keyword, can define\n+methods on most Rust types, including structs and enums.\n+As an example, let's define a `draw` method on our `Shape` enum.\n+\n+~~~\n+# fn draw_circle(p: Point, f: float) { }\n+# fn draw_rectangle(p: Point, p: Point) { }\n+struct Point {\n+    x: float,\n+    y: float\n+}\n+\n+enum Shape {\n+    Circle(Point, float),\n+    Rectangle(Point, Point)\n+}\n+\n+impl Shape {\n+    fn draw(&self) {\n+        match *self {\n+            Circle(p, f) => draw_circle(p, f),\n+            Rectangle(p1, p2) => draw_rectangle(p1, p2)\n+        }\n+    }\n+}\n+\n+let s = Circle(Point { x: 1f, y: 2f }, 3f);\n+s.draw();\n+~~~\n+\n+This defines an _implementation_ for `Shape` containing a single\n+method, `draw`. In most respects the `draw` method is defined\n+like any other function, except for the name `self`.\n+\n+The type of `self` is the type on which the method is implemented,\n+or a pointer thereof. As an argument it is written either `self`,\n+`&self`, `@self`, or `~self`.\n+A caller must in turn have a compatible pointer type to call the method.\n+\n+~~~\n+# fn draw_circle(p: Point, f: float) { }\n+# fn draw_rectangle(p: Point, p: Point) { }\n+# struct Point { x: float, y: float }\n+# enum Shape {\n+#     Circle(Point, float),\n+#     Rectangle(Point, Point)\n+# }\n+impl Shape {\n+    fn draw_borrowed(&self) { ... }\n+    fn draw_managed(@self) { ... }\n+    fn draw_owned(~self) { ... }\n+    fn draw_value(self) { ... }\n+}\n+\n+let s = Circle(Point { x: 1f, y: 2f }, 3f);\n+\n+(@s).draw_managed();\n+(~s).draw_owned();\n+(&s).draw_borrowed();\n+s.draw_value();\n+~~~\n+\n+Methods typically take a borrowed pointer self type,\n+so the compiler will go to great lengths to convert a callee\n+to a borrowed pointer.\n+\n+~~~\n+# fn draw_circle(p: Point, f: float) { }\n+# fn draw_rectangle(p: Point, p: Point) { }\n+# struct Point { x: float, y: float }\n+# enum Shape {\n+#     Circle(Point, float),\n+#     Rectangle(Point, Point)\n+# }\n+# impl Shape {\n+#    fn draw_borrowed(&self) { ... }\n+#    fn draw_managed(@self) { ... }\n+#    fn draw_owned(~self) { ... }\n+#    fn draw_value(self) { ... }\n+# }\n+# let s = Circle(Point { x: 1f, y: 2f }, 3f);\n+// As with typical function arguments, managed and unique pointers\n+// are automatically converted to borrowed pointers\n+\n+(@s).draw_borrowed();\n+(~s).draw_borrowed();\n+\n+// Unlike typical function arguments, the self value will\n+// automatically be referenced ...\n+s.draw_borrowed();\n+\n+// ... and dereferenced\n+(& &s).draw_borrowed();\n+\n+// ... and dereferenced, and borrowed, and\n+(&@~s).draw_borrowed();\n+~~~\n+\n+We'll discuss implementations more in the context of [traits and\n+generics](#generics).\n+\n # Closures\n \n Named functions, like those we've seen so far, may not refer to local"}]}