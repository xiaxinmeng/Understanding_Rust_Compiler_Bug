{"sha": "1e320b38c18165964916829a990bff1b663bf718", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMzIwYjM4YzE4MTY1OTY0OTE2ODI5YTk5MGJmZjFiNjYzYmY3MTg=", "commit": {"author": {"name": "Nathan Weston", "email": "nweston@fastmail.com", "date": "2015-09-04T13:26:58Z"}, "committer": {"name": "Nathan Weston", "email": "nweston@fastmail.com", "date": "2015-09-15T13:41:25Z"}, "message": "Add is_integer_literal utility function\n\nReplaces is_lit_zero and is_lit_one which were used in a couple of\nplaces.", "tree": {"sha": "a9970f7cf5d5fe5f6bbfbbc6b70f4e4ca77cf28a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9970f7cf5d5fe5f6bbfbbc6b70f4e4ca77cf28a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e320b38c18165964916829a990bff1b663bf718", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e320b38c18165964916829a990bff1b663bf718", "html_url": "https://github.com/rust-lang/rust/commit/1e320b38c18165964916829a990bff1b663bf718", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e320b38c18165964916829a990bff1b663bf718/comments", "author": {"login": "nweston", "id": 1608259, "node_id": "MDQ6VXNlcjE2MDgyNTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1608259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nweston", "html_url": "https://github.com/nweston", "followers_url": "https://api.github.com/users/nweston/followers", "following_url": "https://api.github.com/users/nweston/following{/other_user}", "gists_url": "https://api.github.com/users/nweston/gists{/gist_id}", "starred_url": "https://api.github.com/users/nweston/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nweston/subscriptions", "organizations_url": "https://api.github.com/users/nweston/orgs", "repos_url": "https://api.github.com/users/nweston/repos", "events_url": "https://api.github.com/users/nweston/events{/privacy}", "received_events_url": "https://api.github.com/users/nweston/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nweston", "id": 1608259, "node_id": "MDQ6VXNlcjE2MDgyNTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1608259?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nweston", "html_url": "https://github.com/nweston", "followers_url": "https://api.github.com/users/nweston/followers", "following_url": "https://api.github.com/users/nweston/following{/other_user}", "gists_url": "https://api.github.com/users/nweston/gists{/gist_id}", "starred_url": "https://api.github.com/users/nweston/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nweston/subscriptions", "organizations_url": "https://api.github.com/users/nweston/orgs", "repos_url": "https://api.github.com/users/nweston/repos", "events_url": "https://api.github.com/users/nweston/events{/privacy}", "received_events_url": "https://api.github.com/users/nweston/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f87dd31f30c2e5f731a2408b0da18f43fbc34c6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f", "html_url": "https://github.com/rust-lang/rust/commit/f87dd31f30c2e5f731a2408b0da18f43fbc34c6f"}], "stats": {"total": 66, "additions": 19, "deletions": 47}, "files": [{"sha": "ade4f46b4a0244ff7bea0d5ed21e515dac529422", "filename": "src/loops.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1e320b38c18165964916829a990bff1b663bf718/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e320b38c18165964916829a990bff1b663bf718/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=1e320b38c18165964916829a990bff1b663bf718", "patch": "@@ -9,7 +9,7 @@ use rustc::front::map::Node::{NodeBlock};\n use std::collections::{HashSet,HashMap};\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type,\n-            in_external_macro, expr_block, span_help_and_lint};\n+            in_external_macro, expr_block, span_help_and_lint, is_integer_literal};\n use utils::{VEC_PATH, LL_PATH};\n \n declare_lint!{ pub NEEDLESS_RANGE_LOOP, Warn,\n@@ -339,7 +339,7 @@ impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n                 match parent.node {\n                     ExprAssignOp(op, ref lhs, ref rhs) =>\n                         if lhs.id == expr.id {\n-                            if op.node == BiAdd && is_lit_one(rhs) {\n+                            if op.node == BiAdd && is_integer_literal(rhs, 1) {\n                                 *state = match *state {\n                                     VarState::Initial if self.depth == 0 => VarState::IncrOnce,\n                                     _ => VarState::DontWarn\n@@ -392,7 +392,7 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n                     self.name = Some(ident.node.name);\n \n                     self.state = if let Some(ref init) = local.init {\n-                        if is_lit_zero(init) {\n+                        if is_integer_literal(init, 0) {\n                             VarState::Warn\n                         } else {\n                             VarState::Declared\n@@ -425,7 +425,7 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n                         self.state = VarState::DontWarn;\n                     },\n                     ExprAssign(ref lhs, ref rhs) if lhs.id == expr.id => {\n-                        self.state = if is_lit_zero(rhs) && self.depth == 0 {\n+                        self.state = if is_integer_literal(rhs, 0) && self.depth == 0 {\n                             VarState::Warn\n                         } else {\n                             VarState::DontWarn\n@@ -473,23 +473,3 @@ fn is_conditional(expr: &Expr) -> bool {\n         _ => false\n     }\n }\n-\n-// FIXME: copy/paste from misc.rs\n-fn is_lit_one(expr: &Expr) -> bool {\n-    if let ExprLit(ref spanned) = expr.node {\n-        if let LitInt(1, _) = spanned.node {\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n-// FIXME: copy/paste from ranges.rs\n-fn is_lit_zero(expr: &Expr) -> bool {\n-    if let ExprLit(ref spanned) = expr.node {\n-        if let LitInt(0, _) = spanned.node {\n-            return true;\n-        }\n-    }\n-    false\n-}"}, {"sha": "63c2082abde0291bcf805cb6b34d916f859e34fc", "filename": "src/misc.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1e320b38c18165964916829a990bff1b663bf718/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e320b38c18165964916829a990bff1b663bf718/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=1e320b38c18165964916829a990bff1b663bf718", "patch": "@@ -7,7 +7,7 @@ use syntax::codemap::{Span, Spanned};\n use rustc_front::visit::FnKind;\n use rustc::middle::ty;\n \n-use utils::{get_item_name, match_path, snippet, span_lint, walk_ptrs_ty};\n+use utils::{get_item_name, match_path, snippet, span_lint, walk_ptrs_ty, is_integer_literal};\n use consts::constant;\n \n declare_lint!(pub TOPLEVEL_REF_ARG, Warn,\n@@ -183,23 +183,14 @@ impl LintPass for ModuloOne {\n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n         if let ExprBinary(ref cmp, _, ref right) = expr.node {\n             if let &Spanned {node: BinOp_::BiRem, ..} = cmp {\n-                if is_lit_one(right) {\n+                if is_integer_literal(right, 1) {\n                     cx.span_lint(MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n                 }\n             }\n         }\n     }\n }\n \n-fn is_lit_one(expr: &Expr) -> bool {\n-    if let ExprLit(ref spanned) = expr.node {\n-        if let LitInt(1, _) = spanned.node {\n-            return true;\n-        }\n-    }\n-    false\n-}\n-\n declare_lint!(pub REDUNDANT_PATTERN, Warn, \"using `name @ _` in a pattern\");\n \n #[derive(Copy,Clone)]"}, {"sha": "97f59a3aadde0ae07133b654c9e6898af9992dc1", "filename": "src/ranges.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1e320b38c18165964916829a990bff1b663bf718/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e320b38c18165964916829a990bff1b663bf718/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=1e320b38c18165964916829a990bff1b663bf718", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::{Context, LintArray, LintPass};\n use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n-use utils::match_type;\n+use utils::{match_type, is_integer_literal};\n \n declare_lint! {\n     pub RANGE_STEP_BY_ZERO, Warn,\n@@ -21,7 +21,7 @@ impl LintPass for StepByZero {\n                               ref args) = expr.node {\n             // Only warn on literal ranges.\n             if ident.name == \"step_by\" && args.len() == 2 &&\n-                is_range(cx, &args[0]) && is_lit_zero(&args[1]) {\n+                is_range(cx, &args[0]) && is_integer_literal(&args[1], 0) {\n                 cx.span_lint(RANGE_STEP_BY_ZERO, expr.span,\n                              \"Range::step_by(0) produces an infinite iterator. \\\n                               Consider using `std::iter::repeat()` instead\")\n@@ -37,13 +37,3 @@ fn is_range(cx: &Context, expr: &Expr) -> bool {\n     // Note: RangeTo and RangeFull don't have step_by\n     match_type(cx, ty, &[\"core\", \"ops\", \"Range\"]) || match_type(cx, ty, &[\"core\", \"ops\", \"RangeFrom\"])\n }\n-\n-fn is_lit_zero(expr: &Expr) -> bool {\n-    // FIXME: use constant folding\n-    if let ExprLit(ref spanned) = expr.node {\n-        if let LitInt(0, _) = spanned.node {\n-            return true;\n-        }\n-    }\n-    false\n-}"}, {"sha": "01c9adf866c6c2c834e8a37d5d4a83329891e10f", "filename": "src/utils.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e320b38c18165964916829a990bff1b663bf718/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e320b38c18165964916829a990bff1b663bf718/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=1e320b38c18165964916829a990bff1b663bf718", "patch": "@@ -244,6 +244,17 @@ pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n     inner(ty, 0)\n }\n \n+pub fn is_integer_literal(expr: &Expr, value: u64) -> bool\n+{\n+    // FIXME: use constant folding\n+    if let ExprLit(ref spanned) = expr.node {\n+        if let LitInt(v, _) = spanned.node {\n+            return v == value;\n+        }\n+    }\n+    false\n+}\n+\n /// Produce a nested chain of if-lets and ifs from the patterns:\n ///\n ///     if_let_chain! {"}]}