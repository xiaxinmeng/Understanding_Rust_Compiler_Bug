{"sha": "571afe71bada1f7d24294a6045f3eca0d0710edd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MWFmZTcxYmFkYTFmN2QyNDI5NGE2MDQ1ZjNlY2EwZDA3MTBlZGQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-13T19:54:32Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-13T20:00:13Z"}, "message": "Safeguard against using statement or item keywords as value ids\n\nThis prevents insane things like 'auto while = 2', which would parse\nin the previous revision, but then break when you tried to mutate it\nwith 'while = 10'.", "tree": {"sha": "5a989adb6895d53800494c5b72e46b85346e37b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a989adb6895d53800494c5b72e46b85346e37b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/571afe71bada1f7d24294a6045f3eca0d0710edd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/571afe71bada1f7d24294a6045f3eca0d0710edd", "html_url": "https://github.com/rust-lang/rust/commit/571afe71bada1f7d24294a6045f3eca0d0710edd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/571afe71bada1f7d24294a6045f3eca0d0710edd/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57ffa2a487ef12a4abf538efc2dd8192ca308271", "url": "https://api.github.com/repos/rust-lang/rust/commits/57ffa2a487ef12a4abf538efc2dd8192ca308271", "html_url": "https://github.com/rust-lang/rust/commit/57ffa2a487ef12a4abf538efc2dd8192ca308271"}], "stats": {"total": 90, "additions": 78, "deletions": 12}, "files": [{"sha": "520090a52c7977fd46f5b5f54c6ad046b28040ef", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 78, "deletions": 12, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/571afe71bada1f7d24294a6045f3eca0d0710edd/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/571afe71bada1f7d24294a6045f3eca0d0710edd/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=571afe71bada1f7d24294a6045f3eca0d0710edd", "patch": "@@ -42,6 +42,7 @@ state type parser =\n           fn get_str(token::str_num) -> str;\n           fn get_reader() -> lexer::reader;\n           fn get_filemap() -> codemap::filemap;\n+          fn get_bad_expr_words() -> std::map::hashmap[str, ()];\n           fn get_chpos() -> uint;\n           fn get_ann() -> ast::ann;\n           fn next_ann_num() -> uint;\n@@ -63,7 +64,8 @@ fn new_parser(session::session sess,\n                            ast::crate_num crate,\n                            lexer::reader rdr,\n                            vec[op_spec] precs,\n-                           mutable uint next_ann_var)\n+                           mutable uint next_ann_var,\n+                           std::map::hashmap[str, ()] bad_words)\n         {\n             fn peek() -> token::token {\n                 ret tok;\n@@ -132,6 +134,10 @@ fn new_parser(session::session sess,\n                 ret rdr.get_filemap();\n             }\n \n+            fn get_bad_expr_words() -> std::map::hashmap[str, ()] {\n+                ret bad_words;\n+            }\n+\n             fn get_chpos() -> uint {ret rdr.get_chpos();}\n \n             fn get_ann() -> ast::ann {\n@@ -156,7 +162,50 @@ fn new_parser(session::session sess,\n     auto npos = rdr.get_chpos();\n     ret stdio_parser(sess, env, ftype, lexer::next_token(rdr),\n                      npos, npos, npos, initial_def._1, UNRESTRICTED,\n-                     initial_def._0, rdr, prec_table(), next_ann);\n+                     initial_def._0, rdr, prec_table(), next_ann,\n+                     bad_expr_word_table());\n+}\n+\n+// These are the words that shouldn't be allowed as value identifiers,\n+// because, if used at the start of a line, they will cause the line to be\n+// interpreted as a specific kind of statement, which would be confusing.\n+fn bad_expr_word_table() -> std::map::hashmap[str, ()] {\n+    auto words = new_str_hash[()]();\n+    words.insert(\"mod\", ());\n+    words.insert(\"if\", ());\n+    words.insert(\"else\", ());\n+    words.insert(\"while\", ());\n+    words.insert(\"do\", ());\n+    words.insert(\"alt\", ());\n+    words.insert(\"for\", ());\n+    words.insert(\"break\", ());\n+    words.insert(\"cont\", ());\n+    words.insert(\"put\", ());\n+    words.insert(\"ret\", ());\n+    words.insert(\"be\", ());\n+    words.insert(\"fail\", ());\n+    words.insert(\"type\", ());\n+    words.insert(\"check\", ());\n+    words.insert(\"assert\", ());\n+    words.insert(\"claim\", ());\n+    words.insert(\"prove\", ());\n+    words.insert(\"state\", ());\n+    words.insert(\"gc\", ());\n+    words.insert(\"native\", ());\n+    words.insert(\"auto\", ());\n+    words.insert(\"fn\", ());\n+    words.insert(\"pred\", ());\n+    words.insert(\"iter\", ());\n+    words.insert(\"import\", ());\n+    words.insert(\"export\", ());\n+    words.insert(\"let\", ());\n+    words.insert(\"const\", ());\n+    words.insert(\"log\", ());\n+    words.insert(\"log_err\", ());\n+    words.insert(\"yield\", ());\n+    words.insert(\"tag\", ());\n+    words.insert(\"obj\", ());\n+    ret words;\n }\n \n fn unexpected(parser p, token::token t) {\n@@ -190,6 +239,10 @@ fn parse_ident(parser p) -> ast::ident {\n         }\n     }\n }\n+fn parse_value_ident(parser p) -> ast::ident {\n+    check_bad_word(p);\n+    ret parse_ident(p);\n+}\n \n \n /* FIXME: gross hack copied from rustboot to make certain configuration-based\n@@ -240,6 +293,17 @@ fn expect_word(&parser p, &str word) {\n               token::to_str(p.get_reader(), p.peek()));\n     }\n }\n+fn check_bad_word(&parser p) {\n+    alt (p.peek()) {\n+        case (token::IDENT(?sid)) {\n+            auto w = p.get_str(sid);\n+            if (p.get_bad_expr_words().contains_key(w)) {\n+                p.err(\"found \" + w + \" in expression position\");\n+            }\n+        }\n+        case (_) {}\n+    }\n+}\n \n fn parse_ty_fn(ast::proto proto, parser p, uint lo)\n     -> ast::ty_ {\n@@ -299,7 +363,7 @@ fn parse_ty_obj(parser p, &mutable uint hi) -> ast::ty_ {\n         auto flo = p.get_lo_pos();\n \n         let ast::proto proto = parse_proto(p);\n-        auto ident = parse_ident(p);\n+        auto ident = parse_value_ident(p);\n         auto f = parse_ty_fn(proto, p, flo);\n         expect(p, token::SEMI);\n         alt (f) {\n@@ -338,7 +402,7 @@ fn parse_constr_arg(parser p) -> @ast::constr_arg {\n     if (p.peek() == token::BINOP(token::STAR)) {\n         p.bump();\n     } else {\n-        carg = ast::carg_ident(parse_ident(p));\n+        carg = ast::carg_ident(parse_value_ident(p));\n     }\n     ret @rec(node=carg, span=sp);\n }\n@@ -504,7 +568,7 @@ fn parse_arg(parser p) -> ast::arg {\n         eat_word(p, \"mutable\");\n     }\n     let @ast::ty t = parse_ty(p);\n-    let ast::ident i = parse_ident(p);\n+    let ast::ident i = parse_value_ident(p);\n     ret rec(mode=m, ty=t, ident=i, id=p.next_def_id());\n }\n \n@@ -851,6 +915,7 @@ fn parse_bottom_expr(parser p) -> @ast::expr {\n         ex = ast::expr_call(f, es.node, p.get_ann());\n     } else if (is_ident(p.peek()) && !is_word(p, \"true\") &&\n                !is_word(p, \"false\")) {\n+        check_bad_word(p);\n         auto pth = parse_path(p);\n         hi = pth.span.hi;\n         ex = ast::expr_path(pth, p.get_ann());\n@@ -1376,7 +1441,7 @@ fn parse_pat(parser p) -> @ast::pat {\n \n fn parse_local_full(&option::t[@ast::ty] tyopt,\n                            parser p) -> @ast::local {\n-    auto ident = parse_ident(p);\n+    auto ident = parse_value_ident(p);\n     auto init = parse_initializer(p);\n     ret @rec(ty = tyopt,\n              infer = false,\n@@ -1622,7 +1687,7 @@ fn parse_fn(parser p, ast::proto proto, ast::purity purity) -> ast::_fn {\n \n fn parse_fn_header(parser p)\n     -> tup(ast::ident, vec[ast::ty_param]) {\n-    auto id = parse_ident(p);\n+    auto id = parse_value_ident(p);\n     auto ty_params = parse_ty_params(p);\n     ret tup(id, ty_params);\n }\n@@ -1641,14 +1706,14 @@ fn parse_item_fn_or_iter(parser p, ast::purity purity, ast::proto proto)\n fn parse_obj_field(parser p) -> ast::obj_field {\n     auto mut = parse_mutability(p); // TODO: store this, use it in typeck\n     auto ty = parse_ty(p);\n-    auto ident = parse_ident(p);\n+    auto ident = parse_value_ident(p);\n     ret rec(ty=ty, ident=ident, id=p.next_def_id(), ann=p.get_ann());\n }\n \n fn parse_method(parser p) -> @ast::method {\n     auto lo = p.get_lo_pos();\n     auto proto = parse_proto(p);\n-    auto ident = parse_ident(p);\n+    auto ident = parse_value_ident(p);\n     auto f = parse_fn(p, proto, ast::impure_fn);\n     auto meth = rec(ident=ident, meth=f,\n                     id=p.next_def_id(), ann=p.get_ann());\n@@ -1675,7 +1740,7 @@ fn parse_dtor(parser p) -> @ast::method {\n \n fn parse_item_obj(parser p, ast::layer lyr) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n-    auto ident = parse_ident(p);\n+    auto ident = parse_value_ident(p);\n     auto ty_params = parse_ty_params(p);\n     auto pf = parse_obj_field;\n     let util::common::spanned[vec[ast::obj_field]] fields =\n@@ -1722,7 +1787,7 @@ fn parse_mod_items(parser p, token::token term) -> ast::_mod {\n fn parse_item_const(parser p) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto ty = parse_ty(p);\n-    auto id = parse_ident(p);\n+    auto id = parse_value_ident(p);\n     expect(p, token::EQ);\n     auto e = parse_expr(p);\n     auto hi = p.get_hi_pos();\n@@ -1871,6 +1936,7 @@ fn parse_item_tag(parser p) -> @ast::item {\n         auto tok = p.peek();\n         alt (tok) {\n             case (token::IDENT(?name)) {\n+                check_bad_word(p);\n                 auto vlo = p.get_lo_pos();\n                 p.bump();\n \n@@ -2215,7 +2281,7 @@ fn parse_crate_directive(parser p) -> ast::crate_directive\n         }\n     } else if (eat_word(p, \"let\")) {\n         expect(p, token::LPAREN);\n-        auto id = parse_ident(p);\n+        auto id = parse_value_ident(p);\n         expect(p, token::EQ);\n         auto x = parse_expr(p);\n         expect(p, token::RPAREN);"}]}