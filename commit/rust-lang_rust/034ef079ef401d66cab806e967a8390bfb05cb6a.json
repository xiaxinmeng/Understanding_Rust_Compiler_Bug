{"sha": "034ef079ef401d66cab806e967a8390bfb05cb6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNGVmMDc5ZWY0MDFkNjZjYWI4MDZlOTY3YTgzOTBiZmIwNWNiNmE=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-27T15:04:44Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-27T15:04:44Z"}, "message": "doc: TreeSet methods and main example.", "tree": {"sha": "c12d791fe0052453c97718aed0b2f57b44338cf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c12d791fe0052453c97718aed0b2f57b44338cf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/034ef079ef401d66cab806e967a8390bfb05cb6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/034ef079ef401d66cab806e967a8390bfb05cb6a", "html_url": "https://github.com/rust-lang/rust/commit/034ef079ef401d66cab806e967a8390bfb05cb6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/034ef079ef401d66cab806e967a8390bfb05cb6a/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d114ddac030d6ed63b3076ccc0e7db081c0a9409", "url": "https://api.github.com/repos/rust-lang/rust/commits/d114ddac030d6ed63b3076ccc0e7db081c0a9409", "html_url": "https://github.com/rust-lang/rust/commit/d114ddac030d6ed63b3076ccc0e7db081c0a9409"}], "stats": {"total": 199, "additions": 183, "deletions": 16}, "files": [{"sha": "442a4ded733cb643365669f3b1f76dee2083a760", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 183, "deletions": 16, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/034ef079ef401d66cab806e967a8390bfb05cb6a/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/034ef079ef401d66cab806e967a8390bfb05cb6a/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=034ef079ef401d66cab806e967a8390bfb05cb6a", "patch": "@@ -138,7 +138,7 @@ impl<K: Ord, V> Default for TreeMap<K,V> {\n }\n \n impl<K: Ord, V> TreeMap<K, V> {\n-    /// Create an empty TreeMap\n+    /// Create an empty `TreeMap`.\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Get a lazy iterator over the keys in the map.\n@@ -232,6 +232,7 @@ impl<K, V> TreeMap<K, V> {\n     /// Return the value for which `f(key)` returns `Equal`. `f` is invoked\n     /// with current key and guides tree navigation. That means `f` should\n     /// be aware of natural ordering of the tree.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -633,15 +634,68 @@ impl<'a, T> Iterator<&'a T> for RevSetItems<'a, T> {\n /// ```{rust}\n /// use std::collections::TreeSet;\n ///\n-/// let mut tree_set = TreeSet::new();\n+/// let mut set = TreeSet::new();\n ///\n-/// tree_set.insert(2i);\n-/// tree_set.insert(1i);\n-/// tree_set.insert(3i);\n+/// set.insert(2i);\n+/// set.insert(1i);\n+/// set.insert(3i);\n ///\n-/// for i in tree_set.iter() {\n+/// for i in set.iter() {\n ///    println!(\"{}\", i) // prints 1, then 2, then 3\n /// }\n+///\n+/// set.remove(&3);\n+///\n+/// if !set.contains(&3) {\n+///     println!(\"set does not contain a 3 anymore\");\n+/// }\n+/// ```\n+///\n+/// The easiest way to use `TreeSet` with a custom type is to implement `Ord`.\n+/// We must also implement `PartialEq`, `Eq` and `PartialOrd`.\n+///\n+/// ```\n+/// use std::collections::TreeSet;\n+///\n+/// // We need `Eq` and `PartialEq`, these can be derived.\n+/// #[deriving(Eq, PartialEq)]\n+/// struct Troll<'a> {\n+///     name: &'a str,\n+///     level: uint,\n+/// }\n+///\n+/// // Implement `Ord` and sort trolls by level.\n+/// impl<'a> Ord for Troll<'a> {\n+///     fn cmp(&self, other: &Troll) -> Ordering {\n+///         // If we swap `self` and `other`, we get descended ordering.\n+///         self.level.cmp(&other.level)\n+///     }\n+/// }\n+///\n+/// // `PartialOrd` needs to be implemented as well.\n+/// impl<'a> PartialOrd for Troll<'a> {\n+///     fn partial_cmp(&self, other: &Troll) -> Option<Ordering> {\n+///         Some(self.cmp(other))\n+///     }\n+/// }\n+///\n+/// let mut trolls = TreeSet::new();\n+///\n+/// trolls.insert(Troll { name: \"Orgarr\", level: 2 });\n+/// trolls.insert(Troll { name: \"Blargarr\", level: 3 });\n+/// trolls.insert(Troll { name: \"Kron the Smelly One\", level: 4 });\n+/// trolls.insert(Troll { name: \"Wartilda\", level: 1 });\n+///\n+/// println!(\"You are facing {} trolls!\", trolls.len());\n+///\n+/// // Print the trolls, ordered by level with smallest level first\n+/// for x in trolls.iter() {\n+///     println!(\"level {}: {}!\", x.level, x.name);\n+/// }\n+///\n+/// // Kill all trolls\n+/// trolls.clear();\n+/// assert_eq!(trolls.len(), 0);\n /// ```\n #[deriving(Clone)]\n pub struct TreeSet<T> {\n@@ -732,25 +786,66 @@ impl<T: Ord> Default for TreeSet<T> {\n }\n \n impl<T: Ord> TreeSet<T> {\n-    /// Create an empty TreeSet\n+    /// Create an empty `TreeSet`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let mut set: TreeSet<int> = TreeSet::new();\n+    /// ```\n     #[inline]\n     pub fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n-    /// Get a lazy iterator over the values in the set.\n-    /// Requires that it be frozen (immutable).\n+    /// Get a lazy iterator over the values in the set, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n+    ///\n+    /// // Will print in ascending order.\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n         SetItems{iter: self.map.iter()}\n     }\n \n-    /// Get a lazy iterator over the values in the set.\n-    /// Requires that it be frozen (immutable).\n+    /// Get a lazy iterator over the values in the set, in descending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n+    ///\n+    /// // Will print in descending order.\n+    /// for x in set.rev_iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     #[inline]\n     pub fn rev_iter<'a>(&'a self) -> RevSetItems<'a, T> {\n         RevSetItems{iter: self.map.rev_iter()}\n     }\n \n-    /// Get a lazy iterator that consumes the set.\n+    /// Creates a consuming iterator, that is, one that moves each value out of the\n+    /// set in ascending order. The set cannot be used after calling this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [1i, 4, 3, 5, 2].iter().map(|&x| x).collect();\n+    ///\n+    /// // Not possible with a regular `.iter()`\n+    /// let v: Vec<int> = set.move_iter().collect();\n+    /// assert_eq!(v, vec![1, 2, 3, 4, 5]);\n+    /// ```\n     #[inline]\n     pub fn move_iter(self) -> MoveSetItems<T> {\n         self.map.move_iter().map(|(value, _)| value)\n@@ -770,24 +865,96 @@ impl<T: Ord> TreeSet<T> {\n         SetItems{iter: self.map.upper_bound(v)}\n     }\n \n-    /// Visit the values (in-order) representing the difference\n+    /// Visit the values representing the difference, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Can be seen as `a - b`.\n+    /// for x in a.difference(&b) {\n+    ///     println!(\"{}\", x); // Print 1 then 2\n+    /// }\n+    ///\n+    /// let diff: TreeSet<int> = a.difference(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1, 2].iter().map(|&x| x).collect());\n+    ///\n+    /// // Note that difference is not symmetric,\n+    /// // and `b - a` means something else:\n+    /// let diff: TreeSet<int> = b.difference(&a).map(|&x| x).collect();\n+    /// assert_eq!(diff, [4, 5].iter().map(|&x| x).collect());\n+    /// ```\n     pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> DifferenceItems<'a, T> {\n         DifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n-    /// Visit the values (in-order) representing the symmetric difference\n+    /// Visit the values representing the symmetric difference, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 4, 5 in ascending order.\n+    /// for x in a.symmetric_difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff1: TreeSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n+    /// let diff2: TreeSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(diff1, diff2);\n+    /// assert_eq!(diff1, [1, 2, 4, 5].iter().map(|&x| x).collect());\n+    /// ```\n     pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n         -> SymDifferenceItems<'a, T> {\n         SymDifferenceItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n-    /// Visit the values (in-order) representing the intersection\n+    /// Visit the values representing the intersection, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 2, 3 in ascending order.\n+    /// for x in a.intersection(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: TreeSet<int> = a.intersection(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n+    /// ```\n     pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n         -> IntersectionItems<'a, T> {\n         IntersectionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n-    /// Visit the values (in-order) representing the union\n+    /// Visit the values representing the union, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 3, 4, 5 in ascending order.\n+    /// for x in a.union(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n+    /// ```\n     pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> {\n         UnionItems{a: self.iter().peekable(), b: other.iter().peekable()}\n     }"}]}