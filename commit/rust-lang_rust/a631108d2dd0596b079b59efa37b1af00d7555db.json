{"sha": "a631108d2dd0596b079b59efa37b1af00d7555db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MzExMDhkMmRkMDU5NmIwNzliNTllZmEzN2IxYWYwMGQ3NTU1ZGI=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-20T13:02:52Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-20T20:33:54Z"}, "message": "Do not query item search by name eagerly", "tree": {"sha": "14492ac7c646f7ce786a4b62896a18dc6d718342", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14492ac7c646f7ce786a4b62896a18dc6d718342"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a631108d2dd0596b079b59efa37b1af00d7555db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a631108d2dd0596b079b59efa37b1af00d7555db", "html_url": "https://github.com/rust-lang/rust/commit/a631108d2dd0596b079b59efa37b1af00d7555db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a631108d2dd0596b079b59efa37b1af00d7555db/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81961dc035106dcfd29b894aae339261a0ba037b", "url": "https://api.github.com/repos/rust-lang/rust/commits/81961dc035106dcfd29b894aae339261a0ba037b", "html_url": "https://github.com/rust-lang/rust/commit/81961dc035106dcfd29b894aae339261a0ba037b"}], "stats": {"total": 422, "additions": 200, "deletions": 222}, "files": [{"sha": "1a98c51ceaa857b09fc0f03d57113d887eaf8e9f", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a631108d2dd0596b079b59efa37b1af00d7555db/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a631108d2dd0596b079b59efa37b1af00d7555db/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=a631108d2dd0596b079b59efa37b1af00d7555db", "patch": "@@ -1,5 +1,5 @@\n use hir::ModuleDef;\n-use ide_db::helpers::mod_path_to_ast;\n+use ide_db::helpers::{import_assets::NameToImport, mod_path_to_ast};\n use ide_db::items_locator;\n use itertools::Itertools;\n use syntax::{\n@@ -65,20 +65,25 @@ pub(crate) fn replace_derive_with_manual_impl(\n     let current_module = ctx.sema.scope(annotated_name.syntax()).module()?;\n     let current_crate = current_module.krate();\n \n-    let found_traits =\n-        items_locator::with_exact_name(&ctx.sema, current_crate, trait_token.text().to_string())\n-            .into_iter()\n-            .filter_map(|item| match ModuleDef::from(item.as_module_def_id()?) {\n-                ModuleDef::Trait(trait_) => Some(trait_),\n-                _ => None,\n-            })\n-            .flat_map(|trait_| {\n-                current_module\n-                    .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_))\n-                    .as_ref()\n-                    .map(mod_path_to_ast)\n-                    .zip(Some(trait_))\n-            });\n+    let found_traits = items_locator::locate_for_name(\n+        &ctx.sema,\n+        current_crate,\n+        NameToImport::Exact(trait_token.text().to_string()),\n+        items_locator::AssocItemSearch::Exclude,\n+        None,\n+    )\n+    .into_iter()\n+    .filter_map(|item| match ModuleDef::from(item.as_module_def_id()?) {\n+        ModuleDef::Trait(trait_) => Some(trait_),\n+        _ => None,\n+    })\n+    .flat_map(|trait_| {\n+        current_module\n+            .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_))\n+            .as_ref()\n+            .map(mod_path_to_ast)\n+            .zip(Some(trait_))\n+    });\n \n     let mut no_traits_found = true;\n     for (trait_path, trait_) in found_traits.inspect(|_| no_traits_found = false) {"}, {"sha": "c91c98871e56506c6e02c71651b5e362586ca559", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a631108d2dd0596b079b59efa37b1af00d7555db/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a631108d2dd0596b079b59efa37b1af00d7555db/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=a631108d2dd0596b079b59efa37b1af00d7555db", "patch": "@@ -14,7 +14,10 @@ mod completions;\n use completions::flyimport::position_for_import;\n use ide_db::{\n     base_db::FilePosition,\n-    helpers::{import_assets::LocatedImport, insert_use::ImportScope},\n+    helpers::{\n+        import_assets::{LocatedImport, NameToImport},\n+        insert_use::ImportScope,\n+    },\n     items_locator, RootDatabase,\n };\n use text_edit::TextEdit;\n@@ -149,15 +152,20 @@ pub fn resolve_completion_edits(\n     let current_module = ctx.sema.scope(position_for_import).module()?;\n     let current_crate = current_module.krate();\n \n-    let (import_path, item_to_import) =\n-        items_locator::with_exact_name(&ctx.sema, current_crate, imported_name)\n-            .into_iter()\n-            .filter_map(|candidate| {\n-                current_module\n-                    .find_use_path_prefixed(db, candidate, config.insert_use.prefix_kind)\n-                    .zip(Some(candidate))\n-            })\n-            .find(|(mod_path, _)| mod_path.to_string() == full_import_path)?;\n+    let (import_path, item_to_import) = items_locator::locate_for_name(\n+        &ctx.sema,\n+        current_crate,\n+        NameToImport::Exact(imported_name),\n+        items_locator::AssocItemSearch::Include,\n+        None,\n+    )\n+    .into_iter()\n+    .filter_map(|candidate| {\n+        current_module\n+            .find_use_path_prefixed(db, candidate, config.insert_use.prefix_kind)\n+            .zip(Some(candidate))\n+    })\n+    .find(|(mod_path, _)| mod_path.to_string() == full_import_path)?;\n     let import =\n         LocatedImport::new(import_path.clone(), item_to_import, item_to_import, Some(import_path));\n "}, {"sha": "ae234eddc5d7443a46200144c5bb2b9ba86c3d5b", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 89, "deletions": 121, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/a631108d2dd0596b079b59efa37b1af00d7555db/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a631108d2dd0596b079b59efa37b1af00d7555db/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=a631108d2dd0596b079b59efa37b1af00d7555db", "patch": "@@ -61,7 +61,7 @@ pub struct FirstSegmentUnresolved {\n }\n \n /// A name that will be used during item lookups.\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum NameToImport {\n     /// Requires items with names that exactly match the given string, case-sensitive.\n     Exact(String),\n@@ -201,131 +201,96 @@ impl ImportAssets {\n         sema: &Semantics<RootDatabase>,\n         prefixed: Option<PrefixKind>,\n     ) -> Vec<LocatedImport> {\n-        let items_with_candidate_name = match self.name_to_import() {\n-            NameToImport::Exact(exact_name) => items_locator::with_exact_name(\n-                sema,\n-                self.module_with_candidate.krate(),\n-                exact_name.clone(),\n-            ),\n-            // FIXME: ideally, we should avoid using `fst` for seacrhing trait imports for assoc items:\n-            // instead, we need to look up all trait impls for a certain struct and search through them only\n-            // see https://github.com/rust-analyzer/rust-analyzer/pull/7293#issuecomment-761585032\n-            // and https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Blanket.20trait.20impls.20lookup\n-            // for the details\n-            NameToImport::Fuzzy(fuzzy_name) => {\n-                let (assoc_item_search, limit) = if self.import_candidate.is_trait_candidate() {\n-                    (AssocItemSearch::AssocItemsOnly, None)\n-                } else {\n-                    (AssocItemSearch::Include, Some(DEFAULT_QUERY_SEARCH_LIMIT))\n-                };\n-\n-                items_locator::with_similar_name(\n-                    sema,\n-                    self.module_with_candidate.krate(),\n-                    fuzzy_name.clone(),\n-                    assoc_item_search,\n-                    limit,\n-                )\n-            }\n-        };\n+        let _p = profile::span(\"import_assets::search_for\");\n \n         let scope_definitions = self.scope_definitions(sema);\n-        self.applicable_defs(sema.db, prefixed, items_with_candidate_name)\n-            .into_iter()\n-            .filter(|import| import.import_path.len() > 1)\n-            .filter(|import| !scope_definitions.contains(&ScopeDef::from(import.item_to_import)))\n-            .sorted_by_key(|import| import.import_path.clone())\n-            .collect()\n-    }\n-\n-    fn scope_definitions(&self, sema: &Semantics<RootDatabase>) -> FxHashSet<ScopeDef> {\n-        let mut scope_definitions = FxHashSet::default();\n-        sema.scope(&self.candidate_node).process_all_names(&mut |_, scope_def| {\n-            scope_definitions.insert(scope_def);\n-        });\n-        scope_definitions\n-    }\n-\n-    fn name_to_import(&self) -> &NameToImport {\n-        match &self.import_candidate {\n-            ImportCandidate::Path(candidate) => &candidate.name,\n-            ImportCandidate::TraitAssocItem(candidate)\n-            | ImportCandidate::TraitMethod(candidate) => &candidate.assoc_item_name,\n-        }\n-    }\n-\n-    fn applicable_defs(\n-        &self,\n-        db: &RootDatabase,\n-        prefixed: Option<PrefixKind>,\n-        items_with_candidate_name: FxHashSet<ItemInNs>,\n-    ) -> FxHashSet<LocatedImport> {\n-        let _p = profile::span(\"import_assets::applicable_defs\");\n         let current_crate = self.module_with_candidate.krate();\n-\n         let mod_path = |item| {\n-            get_mod_path(db, item_for_path_search(db, item)?, &self.module_with_candidate, prefixed)\n+            get_mod_path(\n+                sema.db,\n+                item_for_path_search(sema.db, item)?,\n+                &self.module_with_candidate,\n+                prefixed,\n+            )\n         };\n \n         match &self.import_candidate {\n             ImportCandidate::Path(path_candidate) => {\n-                path_applicable_imports(db, path_candidate, mod_path, items_with_candidate_name)\n+                path_applicable_imports(sema, current_crate, path_candidate, mod_path)\n+            }\n+            ImportCandidate::TraitAssocItem(trait_candidate) => {\n+                trait_applicable_items(sema, current_crate, trait_candidate, true, mod_path)\n+            }\n+            ImportCandidate::TraitMethod(trait_candidate) => {\n+                trait_applicable_items(sema, current_crate, trait_candidate, false, mod_path)\n             }\n-            ImportCandidate::TraitAssocItem(trait_candidate) => trait_applicable_items(\n-                db,\n-                current_crate,\n-                trait_candidate,\n-                true,\n-                mod_path,\n-                items_with_candidate_name,\n-            ),\n-            ImportCandidate::TraitMethod(trait_candidate) => trait_applicable_items(\n-                db,\n-                current_crate,\n-                trait_candidate,\n-                false,\n-                mod_path,\n-                items_with_candidate_name,\n-            ),\n         }\n+        .into_iter()\n+        .filter(|import| import.import_path.len() > 1)\n+        .filter(|import| !scope_definitions.contains(&ScopeDef::from(import.item_to_import)))\n+        .sorted_by_key(|import| import.import_path.clone())\n+        .collect()\n+    }\n+\n+    fn scope_definitions(&self, sema: &Semantics<RootDatabase>) -> FxHashSet<ScopeDef> {\n+        let _p = profile::span(\"import_assets::scope_definitions\");\n+        let mut scope_definitions = FxHashSet::default();\n+        sema.scope(&self.candidate_node).process_all_names(&mut |_, scope_def| {\n+            scope_definitions.insert(scope_def);\n+        });\n+        scope_definitions\n     }\n }\n \n fn path_applicable_imports(\n-    db: &RootDatabase,\n+    sema: &Semantics<RootDatabase>,\n+    current_crate: Crate,\n     path_candidate: &PathImportCandidate,\n     mod_path: impl Fn(ItemInNs) -> Option<ModPath> + Copy,\n-    items_with_candidate_name: FxHashSet<ItemInNs>,\n ) -> FxHashSet<LocatedImport> {\n     let _p = profile::span(\"import_assets::path_applicable_imports\");\n \n-    let (unresolved_first_segment, unresolved_qualifier) = match &path_candidate.qualifier {\n+    match &path_candidate.qualifier {\n         None => {\n-            return items_with_candidate_name\n-                .into_iter()\n-                .filter_map(|item| {\n-                    if item_as_assoc(db, item).is_some() {\n-                        // unqualified assoc items are not valid syntax\n-                        return None;\n-                    }\n-\n-                    let mod_path = mod_path(item)?;\n-                    Some(LocatedImport::new(mod_path.clone(), item, item, Some(mod_path)))\n-                })\n-                .collect();\n+            items_locator::locate_for_name(\n+                sema,\n+                current_crate,\n+                path_candidate.name.clone(),\n+                // unqualified assoc items are not valid syntax\n+                AssocItemSearch::Exclude,\n+                Some(DEFAULT_QUERY_SEARCH_LIMIT),\n+            )\n+            .into_iter()\n+            .filter_map(|item| {\n+                let mod_path = mod_path(item)?;\n+                Some(LocatedImport::new(mod_path.clone(), item, item, Some(mod_path)))\n+            })\n+            .collect()\n         }\n-        Some(first_segment_unresolved) => (\n-            first_segment_unresolved.fist_segment.to_string(),\n-            path_to_string_stripping_turbo_fish(&first_segment_unresolved.full_qualifier),\n-        ),\n-    };\n-\n-    items_with_candidate_name\n-        .into_iter()\n-        .filter_map(|item| {\n-            import_for_item(db, mod_path, &unresolved_first_segment, &unresolved_qualifier, item)\n-        })\n-        .collect()\n+        Some(first_segment_unresolved) => {\n+            let unresolved_qualifier =\n+                path_to_string_stripping_turbo_fish(&first_segment_unresolved.full_qualifier);\n+            let unresolved_first_segment = first_segment_unresolved.fist_segment.text();\n+            items_locator::locate_for_name(\n+                sema,\n+                current_crate,\n+                path_candidate.name.clone(),\n+                AssocItemSearch::Include,\n+                Some(DEFAULT_QUERY_SEARCH_LIMIT),\n+            )\n+            .into_iter()\n+            .filter_map(|item| {\n+                import_for_item(\n+                    sema.db,\n+                    mod_path,\n+                    unresolved_first_segment,\n+                    &unresolved_qualifier,\n+                    item,\n+                )\n+            })\n+            .collect()\n+        }\n+    }\n }\n \n fn import_for_item(\n@@ -440,25 +405,32 @@ fn module_with_segment_name(\n }\n \n fn trait_applicable_items(\n-    db: &RootDatabase,\n+    sema: &Semantics<RootDatabase>,\n     current_crate: Crate,\n     trait_candidate: &TraitImportCandidate,\n     trait_assoc_item: bool,\n     mod_path: impl Fn(ItemInNs) -> Option<ModPath>,\n-    items_with_candidate_name: FxHashSet<ItemInNs>,\n ) -> FxHashSet<LocatedImport> {\n     let _p = profile::span(\"import_assets::trait_applicable_items\");\n-    let mut required_assoc_items = FxHashSet::default();\n \n-    let trait_candidates = items_with_candidate_name\n-        .into_iter()\n-        .filter_map(|input| item_as_assoc(db, input))\n-        .filter_map(|assoc| {\n-            let assoc_item_trait = assoc.containing_trait(db)?;\n-            required_assoc_items.insert(assoc);\n-            Some(assoc_item_trait.into())\n-        })\n-        .collect();\n+    let db = sema.db;\n+\n+    let mut required_assoc_items = FxHashSet::default();\n+    let trait_candidates = items_locator::locate_for_name(\n+        sema,\n+        current_crate,\n+        trait_candidate.assoc_item_name.clone(),\n+        AssocItemSearch::AssocItemsOnly,\n+        Some(DEFAULT_QUERY_SEARCH_LIMIT),\n+    )\n+    .into_iter()\n+    .filter_map(|input| item_as_assoc(db, input))\n+    .filter_map(|assoc| {\n+        let assoc_item_trait = assoc.containing_trait(db)?;\n+        required_assoc_items.insert(assoc);\n+        Some(assoc_item_trait.into())\n+    })\n+    .collect();\n \n     let mut located_imports = FxHashSet::default();\n \n@@ -567,10 +539,6 @@ impl ImportCandidate {\n     ) -> Option<Self> {\n         path_import_candidate(sema, qualifier, NameToImport::Fuzzy(fuzzy_name))\n     }\n-\n-    fn is_trait_candidate(&self) -> bool {\n-        matches!(self, ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_))\n-    }\n }\n \n fn path_import_candidate("}, {"sha": "088be72c493143416da56919eccfce9ebb8177e7", "filename": "crates/ide_db/src/items_locator.rs", "status": "modified", "additions": 73, "deletions": 76, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/a631108d2dd0596b079b59efa37b1af00d7555db/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a631108d2dd0596b079b59efa37b1af00d7555db/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fitems_locator.rs?ref=a631108d2dd0596b079b59efa37b1af00d7555db", "patch": "@@ -10,122 +10,113 @@ use syntax::{ast, AstNode, SyntaxKind::NAME};\n \n use crate::{\n     defs::{Definition, NameClass},\n+    helpers::import_assets::NameToImport,\n     symbol_index::{self, FileSymbol},\n     RootDatabase,\n };\n use rustc_hash::FxHashSet;\n \n pub(crate) const DEFAULT_QUERY_SEARCH_LIMIT: usize = 40;\n \n-pub fn with_exact_name(\n-    sema: &Semantics<'_, RootDatabase>,\n-    krate: Crate,\n-    exact_name: String,\n-) -> FxHashSet<ItemInNs> {\n-    let _p = profile::span(\"find_exact_imports\");\n-    find_items(\n-        sema,\n-        krate,\n-        {\n-            let mut local_query = symbol_index::Query::new(exact_name.clone());\n-            local_query.exact();\n-            local_query.limit(DEFAULT_QUERY_SEARCH_LIMIT);\n-            local_query\n-        },\n-        import_map::Query::new(exact_name)\n-            .limit(DEFAULT_QUERY_SEARCH_LIMIT)\n-            .name_only()\n-            .search_mode(import_map::SearchMode::Equals)\n-            .case_sensitive(),\n-    )\n-}\n-\n-#[derive(Debug)]\n+/// TODO kb docs here and around + update the module doc\n+#[derive(Debug, Clone, Copy)]\n pub enum AssocItemSearch {\n     Include,\n     Exclude,\n     AssocItemsOnly,\n }\n \n-pub fn with_similar_name(\n+pub fn locate_for_name(\n     sema: &Semantics<'_, RootDatabase>,\n     krate: Crate,\n-    fuzzy_search_string: String,\n+    name: NameToImport,\n     assoc_item_search: AssocItemSearch,\n     limit: Option<usize>,\n ) -> FxHashSet<ItemInNs> {\n-    let _p = profile::span(\"find_similar_imports\");\n+    let _p = profile::span(\"locate_for_name\").detail(|| {\n+        format!(\n+            \"Name: {} ({:?}), crate: {:?}, limit: {:?}\",\n+            name.text(),\n+            assoc_item_search,\n+            krate.display_name(sema.db).map(|name| name.to_string()),\n+            limit,\n+        )\n+    });\n+\n+    let (mut local_query, mut external_query) = match name {\n+        NameToImport::Exact(exact_name) => {\n+            let mut local_query = symbol_index::Query::new(exact_name.clone());\n+            local_query.exact();\n \n-    let mut external_query = import_map::Query::new(fuzzy_search_string.clone())\n-        .search_mode(import_map::SearchMode::Fuzzy)\n-        .name_only();\n+            let external_query = import_map::Query::new(exact_name)\n+                .name_only()\n+                .search_mode(import_map::SearchMode::Equals)\n+                .case_sensitive();\n \n-    match assoc_item_search {\n-        AssocItemSearch::Include => {}\n-        AssocItemSearch::Exclude => {\n-            external_query = external_query.exclude_import_kind(ImportKind::AssociatedItem);\n+            (local_query, external_query)\n         }\n-        AssocItemSearch::AssocItemsOnly => {\n-            external_query = external_query.assoc_items_only();\n+        NameToImport::Fuzzy(fuzzy_search_string) => {\n+            let mut external_query = import_map::Query::new(fuzzy_search_string.clone())\n+                .search_mode(import_map::SearchMode::Fuzzy)\n+                .name_only();\n+            match assoc_item_search {\n+                AssocItemSearch::Include => {}\n+                AssocItemSearch::Exclude => {\n+                    external_query = external_query.exclude_import_kind(ImportKind::AssociatedItem);\n+                }\n+                AssocItemSearch::AssocItemsOnly => {\n+                    external_query = external_query.assoc_items_only();\n+                }\n+            }\n+\n+            (symbol_index::Query::new(fuzzy_search_string), external_query)\n         }\n-    }\n-\n-    let mut local_query = symbol_index::Query::new(fuzzy_search_string);\n+    };\n \n     if let Some(limit) = limit {\n         external_query = external_query.limit(limit);\n         local_query.limit(limit);\n     }\n \n-    find_items(sema, krate, local_query, external_query)\n-        .into_iter()\n-        .filter(move |&item| match assoc_item_search {\n-            AssocItemSearch::Include => true,\n-            AssocItemSearch::Exclude => !is_assoc_item(item, sema.db),\n-            AssocItemSearch::AssocItemsOnly => is_assoc_item(item, sema.db),\n-        })\n-        .collect()\n-}\n-\n-fn is_assoc_item(item: ItemInNs, db: &RootDatabase) -> bool {\n-    item.as_module_def_id()\n-        .and_then(|module_def_id| ModuleDef::from(module_def_id).as_assoc_item(db))\n-        .is_some()\n+    find_items(sema, krate, assoc_item_search, local_query, external_query)\n }\n \n fn find_items(\n     sema: &Semantics<'_, RootDatabase>,\n     krate: Crate,\n+    assoc_item_search: AssocItemSearch,\n     local_query: symbol_index::Query,\n     external_query: import_map::Query,\n ) -> FxHashSet<ItemInNs> {\n-    let _p = profile::span(\"find_similar_imports\");\n+    let _p = profile::span(\"find_items\");\n     let db = sema.db;\n \n-    // Query dependencies first.\n-    let mut candidates = krate\n-        .query_external_importables(db, external_query)\n-        .map(|external_importable| match external_importable {\n-            Either::Left(module_def) => ItemInNs::from(module_def),\n-            Either::Right(macro_def) => ItemInNs::from(macro_def),\n-        })\n-        .collect::<FxHashSet<_>>();\n+    let external_importables =\n+        krate.query_external_importables(db, external_query).map(|external_importable| {\n+            match external_importable {\n+                Either::Left(module_def) => ItemInNs::from(module_def),\n+                Either::Right(macro_def) => ItemInNs::from(macro_def),\n+            }\n+        });\n \n     // Query the local crate using the symbol index.\n-    let local_results = symbol_index::crate_symbols(db, krate.into(), local_query);\n-\n-    candidates.extend(\n-        local_results\n-            .into_iter()\n-            .filter_map(|local_candidate| get_name_definition(sema, &local_candidate))\n-            .filter_map(|name_definition_to_import| match name_definition_to_import {\n-                Definition::ModuleDef(module_def) => Some(ItemInNs::from(module_def)),\n-                Definition::Macro(macro_def) => Some(ItemInNs::from(macro_def)),\n-                _ => None,\n-            }),\n-    );\n-\n-    candidates\n+    let local_results = symbol_index::crate_symbols(db, krate.into(), local_query)\n+        .into_iter()\n+        .filter_map(|local_candidate| get_name_definition(sema, &local_candidate))\n+        .filter_map(|name_definition_to_import| match name_definition_to_import {\n+            Definition::ModuleDef(module_def) => Some(ItemInNs::from(module_def)),\n+            Definition::Macro(macro_def) => Some(ItemInNs::from(macro_def)),\n+            _ => None,\n+        });\n+\n+    external_importables\n+        .chain(local_results)\n+        .filter(move |&item| match assoc_item_search {\n+            AssocItemSearch::Include => true,\n+            AssocItemSearch::Exclude => !is_assoc_item(item, sema.db),\n+            AssocItemSearch::AssocItemsOnly => is_assoc_item(item, sema.db),\n+        })\n+        .collect()\n }\n \n fn get_name_definition(\n@@ -144,3 +135,9 @@ fn get_name_definition(\n     let name = ast::Name::cast(candidate_name_node)?;\n     NameClass::classify(sema, &name)?.defined(sema.db)\n }\n+\n+fn is_assoc_item(item: ItemInNs, db: &RootDatabase) -> bool {\n+    item.as_module_def_id()\n+        .and_then(|module_def_id| ModuleDef::from(module_def_id).as_assoc_item(db))\n+        .is_some()\n+}"}]}