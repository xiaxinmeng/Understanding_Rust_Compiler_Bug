{"sha": "1e21c9a297a9fe668d62887a3a6a4add8e717b17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMjFjOWEyOTdhOWZlNjY4ZDYyODg3YTNhNmE0YWRkOGU3MTdiMTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-19T06:56:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-19T06:56:19Z"}, "message": "Auto merge of #53877 - withoutboats:compositional-pin, r=aturon\n\nUpdate to a new pinning API.\n\n~~Blocked on #53843 because of method resolution problems with new pin type.~~\n\n@r? @cramertj\n\ncc @RalfJung @pythonesque anyone interested in #49150", "tree": {"sha": "e027144fdbb18bb3d12fe5b63fff4a605e65c372", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e027144fdbb18bb3d12fe5b63fff4a605e65c372"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e21c9a297a9fe668d62887a3a6a4add8e717b17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e21c9a297a9fe668d62887a3a6a4add8e717b17", "html_url": "https://github.com/rust-lang/rust/commit/1e21c9a297a9fe668d62887a3a6a4add8e717b17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e21c9a297a9fe668d62887a3a6a4add8e717b17/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff6422d7a392acfc8af28994d65af2bbaecea4f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff6422d7a392acfc8af28994d65af2bbaecea4f6", "html_url": "https://github.com/rust-lang/rust/commit/ff6422d7a392acfc8af28994d65af2bbaecea4f6"}, {"sha": "574bca7262f0ddab9e1818253012dbff34755b98", "url": "https://api.github.com/repos/rust-lang/rust/commits/574bca7262f0ddab9e1818253012dbff34755b98", "html_url": "https://github.com/rust-lang/rust/commit/574bca7262f0ddab9e1818253012dbff34755b98"}], "stats": {"total": 830, "additions": 371, "deletions": 459}, "files": [{"sha": "11b91591593ee79747883f2dbd65ce5a019b7ffa", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -65,13 +65,12 @@ use core::hash::{Hash, Hasher};\n use core::iter::FusedIterator;\n use core::marker::{Unpin, Unsize};\n use core::mem;\n-use core::pin::PinMut;\n+use core::pin::Pin;\n use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n use core::ptr::{self, NonNull, Unique};\n use core::task::{Context, Poll, Spawn, SpawnErrorKind, SpawnObjError};\n \n use raw_vec::RawVec;\n-use pin::PinBox;\n use str::from_boxed_utf8_unchecked;\n \n /// A pointer type for heap allocation.\n@@ -97,6 +96,12 @@ impl<T> Box<T> {\n     pub fn new(x: T) -> Box<T> {\n         box x\n     }\n+\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[inline(always)]\n+    pub fn pinned(x: T) -> Pin<Box<T>> {\n+        (box x).into()\n+    }\n }\n \n impl<T: ?Sized> Box<T> {\n@@ -427,6 +432,16 @@ impl<T> From<T> for Box<T> {\n     }\n }\n \n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T> From<Box<T>> for Pin<Box<T>> {\n+    fn from(boxed: Box<T>) -> Self {\n+        // It's not possible to move or replace the insides of a `Pin<Box<T>>`\n+        // when `T: !Unpin`,  so it's safe to pin it directly without any\n+        // additional requirements.\n+        unsafe { Pin::new_unchecked(boxed) }\n+    }\n+}\n+\n #[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\n impl<'a, T: Copy> From<&'a [T]> for Box<[T]> {\n     fn from(slice: &'a [T]) -> Box<[T]> {\n@@ -789,8 +804,8 @@ impl<T> Generator for Box<T>\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;\n \n-    fn poll(mut self: PinMut<Self>, cx: &mut Context) -> Poll<Self::Output> {\n-        PinMut::new(&mut **self).poll(cx)\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut *self), cx)\n     }\n }\n \n@@ -804,8 +819,8 @@ unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for Box<F>\n \n     unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n         let ptr = ptr as *mut F;\n-        let pin: PinMut<F> = PinMut::new_unchecked(&mut *ptr);\n-        pin.poll(cx)\n+        let pin: Pin<&mut F> = Pin::new_unchecked(&mut *ptr);\n+        F::poll(pin, cx)\n     }\n \n     unsafe fn drop(ptr: *mut ()) {\n@@ -843,9 +858,16 @@ impl<'a, F: Future<Output = ()> + 'a> From<Box<F>> for LocalFutureObj<'a, ()> {\n     }\n }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: Unpin + ?Sized> From<PinBox<T>> for Box<T> {\n-    fn from(pinned: PinBox<T>) -> Box<T> {\n-        unsafe { PinBox::unpin(pinned) }\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<'a, F: Future<Output = ()> + Send + 'a> From<Pin<Box<F>>> for FutureObj<'a, ()> {\n+    fn from(boxed: Pin<Box<F>>) -> Self {\n+        FutureObj::new(boxed)\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<'a, F: Future<Output = ()> + 'a> From<Pin<Box<F>>> for LocalFutureObj<'a, ()> {\n+    fn from(boxed: Pin<Box<F>>) -> Self {\n+        LocalFutureObj::new(boxed)\n     }\n }"}, {"sha": "b2303a02cb2651bb4168a86bff7dbbdd1e8bacfb", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -160,7 +160,6 @@ pub mod collections;\n pub mod sync;\n pub mod rc;\n pub mod raw_vec;\n-pub mod pin;\n pub mod prelude;\n pub mod borrow;\n pub mod fmt;"}, {"sha": "17bbc9882d976d95c2992060f80cc08dede994ce", "filename": "src/liballoc/pin.rs", "status": "removed", "additions": 0, "deletions": 302, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/ff6422d7a392acfc8af28994d65af2bbaecea4f6/src%2Fliballoc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff6422d7a392acfc8af28994d65af2bbaecea4f6/src%2Fliballoc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fpin.rs?ref=ff6422d7a392acfc8af28994d65af2bbaecea4f6", "patch": "@@ -1,302 +0,0 @@\n-//! Types which pin data to its location in memory\n-//!\n-//! It is sometimes useful to have objects that are guaranteed to not move,\n-//! in the sense that their placement in memory does not change, and can thus be relied upon.\n-//!\n-//! A prime example of such a scenario would be building self-referencial structs,\n-//! since moving an object with pointers to itself will invalidate them,\n-//! which could cause undefined behavior.\n-//!\n-//! In order to prevent objects from moving, they must be *pinned*,\n-//! by wrapping the data in pinning pointer types, such as [`PinMut`] and [`PinBox`],\n-//! which are otherwise equivalent to `& mut` and [`Box`], respectively.\n-//!\n-//! First of all, these are pointer types because pinned data mustn't be passed around by value\n-//! (that would change its location in memory).\n-//! Secondly, since data can be moved out of `&mut` and [`Box`] with functions such as [`swap`],\n-//! which causes their contents to swap places in memory,\n-//! we need dedicated types that prohibit such operations.\n-//!\n-//! However, these restrictions are usually not necessary,\n-//! so most types implement the [`Unpin`] auto-trait,\n-//! which indicates that the type can be moved out safely.\n-//! Doing so removes the limitations of pinning types,\n-//! making them the same as their non-pinning counterparts.\n-//!\n-//! [`PinMut`]: struct.PinMut.html\n-//! [`PinBox`]: struct.PinBox.html\n-//! [`Unpin`]: trait.Unpin.html\n-//! [`swap`]: ../../std/mem/fn.swap.html\n-//! [`Box`]: ../boxed/struct.Box.html\n-//!\n-//! # Examples\n-//!\n-//! ```rust\n-//! #![feature(pin)]\n-//!\n-//! use std::pin::PinBox;\n-//! use std::marker::Pinned;\n-//! use std::ptr::NonNull;\n-//!\n-//! // This is a self referencial struct since the slice field points to the data field.\n-//! // We cannot inform the compiler about that with a normal reference,\n-//! // since this pattern cannot be described with the usual borrowing rules.\n-//! // Instead we use a raw pointer, though one which is known to not be null,\n-//! // since we know it's pointing at the string.\n-//! struct Unmovable {\n-//!     data: String,\n-//!     slice: NonNull<String>,\n-//!     _pin: Pinned,\n-//! }\n-//!\n-//! impl Unmovable {\n-//!     // To ensure the data doesn't move when the function returns,\n-//!     // we place it in the heap where it will stay for the lifetime of the object,\n-//!     // and the only way to access it would be through a pointer to it.\n-//!     fn new(data: String) -> PinBox<Self> {\n-//!         let res = Unmovable {\n-//!             data,\n-//!             // we only create the pointer once the data is in place\n-//!             // otherwise it will have already moved before we even started\n-//!             slice: NonNull::dangling(),\n-//!             _pin: Pinned,\n-//!         };\n-//!         let mut boxed = PinBox::new(res);\n-//!\n-//!         let slice = NonNull::from(&boxed.data);\n-//!         // we know this is safe because modifying a field doesn't move the whole struct\n-//!         unsafe { PinBox::get_mut(&mut boxed).slice = slice };\n-//!         boxed\n-//!     }\n-//! }\n-//!\n-//! let unmoved = Unmovable::new(\"hello\".to_string());\n-//! // The pointer should point to the correct location,\n-//! // so long as the struct hasn't moved.\n-//! // Meanwhile, we are free to move the pointer around.\n-//! # #[allow(unused_mut)]\n-//! let mut still_unmoved = unmoved;\n-//! assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n-//!\n-//! // Since our type doesn't implement Unpin, this will fail to compile:\n-//! // let new_unmoved = Unmovable::new(\"world\".to_string());\n-//! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n-//! ```\n-\n-#![unstable(feature = \"pin\", issue = \"49150\")]\n-\n-pub use core::pin::*;\n-pub use core::marker::Unpin;\n-\n-use core::convert::From;\n-use core::fmt;\n-use core::future::{Future, FutureObj, LocalFutureObj, UnsafeFutureObj};\n-use core::marker::Unsize;\n-use core::ops::{CoerceUnsized, Deref, DerefMut};\n-use core::task::{Context, Poll};\n-\n-use boxed::Box;\n-\n-/// A pinned, heap allocated reference.\n-///\n-/// This type is similar to [`Box`], except that it pins its value,\n-/// which prevents it from moving out of the reference, unless it implements [`Unpin`].\n-///\n-/// See the [module documentation] for furthur explaination on pinning.\n-///\n-/// [`Box`]: ../boxed/struct.Box.html\n-/// [`Unpin`]: ../../std/marker/trait.Unpin.html\n-/// [module documentation]: index.html\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-#[fundamental]\n-#[repr(transparent)]\n-pub struct PinBox<T: ?Sized> {\n-    inner: Box<T>,\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T> PinBox<T> {\n-    /// Allocate memory on the heap, move the data into it and pin it.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn new(data: T) -> PinBox<T> {\n-        PinBox { inner: Box::new(data) }\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> PinBox<T> {\n-    /// Get a pinned reference to the data in this PinBox.\n-    #[inline]\n-    pub fn as_pin_mut<'a>(&'a mut self) -> PinMut<'a, T> {\n-        unsafe { PinMut::new_unchecked(&mut *self.inner) }\n-    }\n-\n-    /// Constructs a `PinBox` from a raw pointer.\n-    ///\n-    /// After calling this function, the raw pointer is owned by the\n-    /// resulting `PinBox`. Specifically, the `PinBox` destructor will call\n-    /// the destructor of `T` and free the allocated memory. Since the\n-    /// way `PinBox` allocates and releases memory is unspecified, the\n-    /// only valid pointer to pass to this function is the one taken\n-    /// from another `PinBox` via the [`PinBox::into_raw`] function.\n-    ///\n-    /// This function is unsafe because improper use may lead to\n-    /// memory problems. For example, a double-free may occur if the\n-    /// function is called twice on the same raw pointer.\n-    ///\n-    /// [`PinBox::into_raw`]: struct.PinBox.html#method.into_raw\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(pin)]\n-    /// use std::pin::PinBox;\n-    /// let x = PinBox::new(5);\n-    /// let ptr = PinBox::into_raw(x);\n-    /// let x = unsafe { PinBox::from_raw(ptr) };\n-    /// ```\n-    #[inline]\n-    pub unsafe fn from_raw(raw: *mut T) -> Self {\n-        PinBox { inner: Box::from_raw(raw) }\n-    }\n-\n-    /// Consumes the `PinBox`, returning the wrapped raw pointer.\n-    ///\n-    /// After calling this function, the caller is responsible for the\n-    /// memory previously managed by the `PinBox`. In particular, the\n-    /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the raw pointer back into a\n-    /// `PinBox` with the [`PinBox::from_raw`] function.\n-    ///\n-    /// Note: this is an associated function, which means that you have\n-    /// to call it as `PinBox::into_raw(b)` instead of `b.into_raw()`. This\n-    /// is so that there is no conflict with a method on the inner type.\n-    ///\n-    /// [`PinBox::from_raw`]: struct.PinBox.html#method.from_raw\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(pin)]\n-    /// use std::pin::PinBox;\n-    /// let x = PinBox::new(5);\n-    /// let ptr = PinBox::into_raw(x);\n-    /// ```\n-    #[inline]\n-    pub fn into_raw(b: PinBox<T>) -> *mut T {\n-        Box::into_raw(b.inner)\n-    }\n-\n-    /// Get a mutable reference to the data inside this PinBox.\n-    ///\n-    /// This function is unsafe. Users must guarantee that the data is never\n-    /// moved out of this reference.\n-    #[inline]\n-    pub unsafe fn get_mut<'a>(this: &'a mut PinBox<T>) -> &'a mut T {\n-        &mut *this.inner\n-    }\n-\n-    /// Convert this PinBox into an unpinned Box.\n-    ///\n-    /// This function is unsafe. Users must guarantee that the data is never\n-    /// moved out of the box.\n-    #[inline]\n-    pub unsafe fn unpin(this: PinBox<T>) -> Box<T> {\n-        this.inner\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> From<Box<T>> for PinBox<T> {\n-    fn from(boxed: Box<T>) -> PinBox<T> {\n-        PinBox { inner: boxed }\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> Deref for PinBox<T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        &*self.inner\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: Unpin + ?Sized> DerefMut for PinBox<T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        &mut *self.inner\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: fmt::Display + ?Sized> fmt::Display for PinBox<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&*self.inner, f)\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: fmt::Debug + ?Sized> fmt::Debug for PinBox<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&*self.inner, f)\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> fmt::Pointer for PinBox<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // It's not possible to extract the inner Uniq directly from the Box,\n-        // instead we cast it to a *const which aliases the Unique\n-        let ptr: *const T = &*self.inner;\n-        fmt::Pointer::fmt(&ptr, f)\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PinBox<U>> for PinBox<T> {}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> Unpin for PinBox<T> {}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<F: ?Sized + Future> Future for PinBox<F> {\n-    type Output = F::Output;\n-\n-    fn poll(mut self: PinMut<Self>, cx: &mut Context) -> Poll<Self::Output> {\n-        self.as_pin_mut().poll(cx)\n-    }\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for PinBox<F>\n-    where F: Future<Output = T> + 'a\n-{\n-    fn into_raw(self) -> *mut () {\n-        PinBox::into_raw(self) as *mut ()\n-    }\n-\n-    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n-        let ptr = ptr as *mut F;\n-        let pin: PinMut<F> = PinMut::new_unchecked(&mut *ptr);\n-        pin.poll(cx)\n-    }\n-\n-    unsafe fn drop(ptr: *mut ()) {\n-        drop(PinBox::from_raw(ptr as *mut F))\n-    }\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<'a, F: Future<Output = ()> + Send + 'a> From<PinBox<F>> for FutureObj<'a, ()> {\n-    fn from(boxed: PinBox<F>) -> Self {\n-        FutureObj::new(boxed)\n-    }\n-}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<'a, F: Future<Output = ()> + 'a> From<PinBox<F>> for LocalFutureObj<'a, ()> {\n-    fn from(boxed: PinBox<F>) -> Self {\n-        LocalFutureObj::new(boxed)\n-    }\n-}"}, {"sha": "9d951691a34e76b4847498e18649ee5cb0746159", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -256,6 +256,7 @@ use core::marker::{Unpin, Unsize, PhantomData};\n use core::mem::{self, align_of_val, forget, size_of_val};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n+use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n use core::usize;\n@@ -321,6 +322,11 @@ impl<T> Rc<T> {\n         }\n     }\n \n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn pinned(value: T) -> Pin<Rc<T>> {\n+        unsafe { Pin::new_unchecked(Rc::new(value)) }\n+    }\n+\n     /// Returns the contained value, if the `Rc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Rc` that was"}, {"sha": "116393bdad195b54375dcba6e8266af802bc4386", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -26,6 +26,7 @@ use core::intrinsics::abort;\n use core::mem::{self, align_of_val, size_of_val};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n+use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::marker::{Unpin, Unsize, PhantomData};\n use core::hash::{Hash, Hasher};\n@@ -297,6 +298,11 @@ impl<T> Arc<T> {\n         Arc { ptr: Box::into_raw_non_null(x), phantom: PhantomData }\n     }\n \n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn pinned(data: T) -> Pin<Arc<T>> {\n+        unsafe { Pin::new_unchecked(Arc::new(data)) }\n+    }\n+\n     /// Returns the contained value, if the `Arc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was"}, {"sha": "f4b5cf95e37fb89cb2c240403bc1b3fa3b48854c", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -12,8 +12,9 @@\n             reason = \"futures in libcore are unstable\",\n             issue = \"50547\")]\n \n-use pin::PinMut;\n use marker::Unpin;\n+use ops;\n+use pin::Pin;\n use task::{self, Poll};\n \n /// A future represents an asychronous computation.\n@@ -92,21 +93,25 @@ pub trait Future {\n     /// [`Poll::Pending`]: ../task/enum.Poll.html#variant.Pending\n     /// [`Poll::Ready(val)`]: ../task/enum.Poll.html#variant.Ready\n     /// [`cx.waker()`]: ../task/struct.Context.html#method.waker\n-    fn poll(self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output>;\n+    fn poll(self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output>;\n }\n \n impl<'a, F: ?Sized + Future + Unpin> Future for &'a mut F {\n     type Output = F::Output;\n \n-    fn poll(mut self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n-        F::poll(PinMut::new(&mut **self), cx)\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut **self), cx)\n     }\n }\n \n-impl<'a, F: ?Sized + Future> Future for PinMut<'a, F> {\n-    type Output = F::Output;\n+impl<P> Future for Pin<P>\n+where\n+    P: ops::DerefMut,\n+    P::Target: Future,\n+{\n+    type Output = <<P as ops::Deref>::Target as Future>::Output;\n \n-    fn poll(mut self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n-        F::poll((*self).reborrow(), cx)\n+    fn poll(self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n+        Pin::get_mut(self).as_mut().poll(cx)\n     }\n }"}, {"sha": "b335cac6c1d8ca4ca832412a225ee3fd23bd8c08", "filename": "src/libcore/future/future_obj.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibcore%2Ffuture%2Ffuture_obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibcore%2Ffuture%2Ffuture_obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture_obj.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -15,7 +15,8 @@\n use fmt;\n use future::Future;\n use marker::{PhantomData, Unpin};\n-use pin::PinMut;\n+use ops;\n+use pin::Pin;\n use task::{Context, Poll};\n \n /// A custom trait object for polling futures, roughly akin to\n@@ -78,9 +79,9 @@ impl<'a, T> Future for LocalFutureObj<'a, T> {\n     type Output = T;\n \n     #[inline]\n-    fn poll(self: PinMut<Self>, cx: &mut Context) -> Poll<T> {\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<T> {\n         unsafe {\n-            (self.poll_fn)(self.ptr, cx)\n+            ((*self).poll_fn)((*self).ptr, cx)\n         }\n     }\n }\n@@ -128,9 +129,11 @@ impl<'a, T> Future for FutureObj<'a, T> {\n     type Output = T;\n \n     #[inline]\n-    fn poll(self: PinMut<Self>, cx: &mut Context) -> Poll<T> {\n-        let pinned_field = unsafe { PinMut::map_unchecked(self, |x| &mut x.0) };\n-        pinned_field.poll(cx)\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<T> {\n+        let pinned_field: Pin<&mut LocalFutureObj<'a, T>> = unsafe {\n+            Pin::map_unchecked_mut(self, |x| &mut x.0)\n+        };\n+        LocalFutureObj::poll(pinned_field, cx)\n     }\n }\n \n@@ -175,7 +178,25 @@ unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for &'a mut F\n     }\n \n     unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n-        PinMut::new_unchecked(&mut *(ptr as *mut F)).poll(cx)\n+        let p: Pin<&mut F> = Pin::new_unchecked(&mut *(ptr as *mut F));\n+        F::poll(p, cx)\n+    }\n+\n+    unsafe fn drop(_ptr: *mut ()) {}\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+unsafe impl<'a, T, P, F> UnsafeFutureObj<'a, T> for Pin<P> where\n+    P: ops::DerefMut<Target = F> + 'a,\n+    F: Future<Output = T> + 'a,\n+{\n+    fn into_raw(mut self) -> *mut () {\n+        unsafe { Pin::get_mut_unchecked(Pin::as_mut(&mut self)) as *mut F as *mut () }\n+    }\n+\n+    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n+        let future: Pin<&mut F> = Pin::new_unchecked(&mut *(ptr as *mut F));\n+        F::poll(future, cx)\n     }\n \n     unsafe fn drop(_ptr: *mut ()) {}"}, {"sha": "5572fe1512cbbaca498f2841d939e074c97053ae", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -609,7 +609,7 @@ unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n /// this trait cannot prevent types from moving by itself.\n ///\n /// Instead it can be used to prevent moves through the type system,\n-/// by controlling the behavior of special pointer types like [`PinMut`],\n+/// by controlling the behavior of pointers wrapped in the [`Pin`] wrapper,\n /// which \"pin\" the type in place by not allowing it to be moved out of them.\n /// See the [`pin module`] documentation for more information on pinning.\n ///\n@@ -621,10 +621,10 @@ unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n /// ```rust\n /// #![feature(pin)]\n /// use std::mem::replace;\n-/// use std::pin::PinMut;\n+/// use std::pin::Pin;\n ///\n /// let mut string = \"this\".to_string();\n-/// let mut pinned_string = PinMut::new(&mut string);\n+/// let mut pinned_string = Pin::new(&mut string);\n ///\n /// // dereferencing the pointer mutably is only possible because String implements Unpin\n /// replace(&mut *pinned_string, \"other\".to_string());\n@@ -633,7 +633,7 @@ unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n /// This trait is automatically implemented for almost every type.\n ///\n /// [`replace`]: ../../std/mem/fn.replace.html\n-/// [`PinMut`]: ../pin/struct.PinMut.html\n+/// [`Pin`]: ../pin/struct.Pin.html\n /// [`pin module`]: ../../std/pin/index.html\n #[unstable(feature = \"pin\", issue = \"49150\")]\n pub auto trait Unpin {}"}, {"sha": "58bf6be834d468e34936159be8293e2c4fd8d52b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -147,7 +147,7 @@\n \n use iter::{FromIterator, FusedIterator, TrustedLen};\n use {hint, mem, ops::{self, Deref}};\n-use pin::PinMut;\n+use pin::Pin;\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n // `Iterator`, which is one. The compiler assumes that the `next` method of\n@@ -270,12 +270,22 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Converts from `Option<T>` to `Option<PinMut<'_, T>>`\n+\n+    /// Converts from `Pin<&Option<T>>` to `Option<Pin<&T>>`\n+    #[inline]\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn as_pin_ref<'a>(self: Pin<&'a Option<T>>) -> Option<Pin<&'a T>> {\n+        unsafe {\n+            Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x))\n+        }\n+    }\n+\n+    /// Converts from `Pin<&mut Option<T>>` to `Option<Pin<&mut T>>`\n     #[inline]\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn as_pin_mut<'a>(self: PinMut<'a, Self>) -> Option<PinMut<'a, T>> {\n+    pub fn as_pin_mut<'a>(self: Pin<&'a mut Option<T>>) -> Option<Pin<&'a mut T>> {\n         unsafe {\n-            PinMut::get_mut_unchecked(self).as_mut().map(|x| PinMut::new_unchecked(x))\n+            Pin::get_mut_unchecked(self).as_mut().map(|x| Pin::new_unchecked(x))\n         }\n     }\n "}, {"sha": "d09a545aecfaf8a6072aedeada9e54f072d540c6", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 247, "deletions": 79, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -1,160 +1,328 @@\n //! Types which pin data to its location in memory\n //!\n-//! See the [standard library module] for more information.\n+//! It is sometimes useful to have objects that are guaranteed to not move,\n+//! in the sense that their placement in memory does not change, and can thus be relied upon.\n //!\n-//! [standard library module]: ../../std/pin/index.html\n+//! A prime example of such a scenario would be building self-referencial structs,\n+//! since moving an object with pointers to itself will invalidate them,\n+//! which could cause undefined behavior.\n+//!\n+//! In order to prevent objects from moving, they must be pinned\n+//! by wrapping a pointer to the data in the [`Pin`] type. A pointer wrapped\n+//! in a `Pin` is otherwise equivalent to its normal version, e.g. `Pin<Box<T>>`\n+//! and `Box<T>` work the same way except that the first is pinning the value\n+//! of `T` in place.\n+//!\n+//! First of all, these are pointer types because pinned data mustn't be passed around by value\n+//! (that would change its location in memory).\n+//! Secondly, since data can be moved out of `&mut` and `Box` with functions such as [`swap`],\n+//! which causes their contents to swap places in memory,\n+//! we need dedicated types that prohibit such operations.\n+//!\n+//! However, these restrictions are usually not necessary,\n+//! so most types implement the [`Unpin`] auto-trait,\n+//! which indicates that the type can be moved out safely.\n+//! Doing so removes the limitations of pinning types,\n+//! making them the same as their non-pinning counterparts.\n+//!\n+//! [`Pin`]: struct.Pin.html\n+//! [`Unpin`]: trait.Unpin.html\n+//! [`swap`]: ../../std/mem/fn.swap.html\n+//! [`Box`]: ../../std/boxed/struct.Box.html\n+//!\n+//! # Examples\n+//!\n+//! ```rust\n+//! #![feature(pin)]\n+//!\n+//! use std::pin::Pin;\n+//! use std::marker::Pinned;\n+//! use std::ptr::NonNull;\n+//!\n+//! // This is a self referencial struct since the slice field points to the data field.\n+//! // We cannot inform the compiler about that with a normal reference,\n+//! // since this pattern cannot be described with the usual borrowing rules.\n+//! // Instead we use a raw pointer, though one which is known to not be null,\n+//! // since we know it's pointing at the string.\n+//! struct Unmovable {\n+//!     data: String,\n+//!     slice: NonNull<String>,\n+//!     _pin: Pinned,\n+//! }\n+//!\n+//! impl Unmovable {\n+//!     // To ensure the data doesn't move when the function returns,\n+//!     // we place it in the heap where it will stay for the lifetime of the object,\n+//!     // and the only way to access it would be through a pointer to it.\n+//!     fn new(data: String) -> Pin<Box<Self>> {\n+//!         let res = Unmovable {\n+//!             data,\n+//!             // we only create the pointer once the data is in place\n+//!             // otherwise it will have already moved before we even started\n+//!             slice: NonNull::dangling(),\n+//!             _pin: Pinned,\n+//!         };\n+//!         let mut boxed = Box::pinned(res);\n+//!\n+//!         let slice = NonNull::from(&boxed.data);\n+//!         // we know this is safe because modifying a field doesn't move the whole struct\n+//!         unsafe {\n+//!             let mut_ref: Pin<&mut Self> = Pin::as_mut(&mut boxed);\n+//!             Pin::get_mut_unchecked(mut_ref).slice = slice;\n+//!         }\n+//!         boxed\n+//!     }\n+//! }\n+//!\n+//! let unmoved = Unmovable::new(\"hello\".to_string());\n+//! // The pointer should point to the correct location,\n+//! // so long as the struct hasn't moved.\n+//! // Meanwhile, we are free to move the pointer around.\n+//! # #[allow(unused_mut)]\n+//! let mut still_unmoved = unmoved;\n+//! assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n+//!\n+//! // Since our type doesn't implement Unpin, this will fail to compile:\n+//! // let new_unmoved = Unmovable::new(\"world\".to_string());\n+//! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n+//! ```\n \n #![unstable(feature = \"pin\", issue = \"49150\")]\n \n use fmt;\n-use future::{Future, UnsafeFutureObj};\n-use marker::{Sized, Unpin, Unsize};\n-use task::{Context, Poll};\n+use marker::Sized;\n use ops::{Deref, DerefMut, CoerceUnsized};\n \n-/// A pinned reference.\n+#[doc(inline)]\n+pub use marker::Unpin;\n+\n+/// A pinned pointer.\n ///\n-/// This type is similar to a mutable reference, except that it pins its value,\n-/// which prevents it from moving out of the reference, unless it implements [`Unpin`].\n+/// This is a wrapper around a kind of pointer which makes that pointer \"pin\" its\n+/// value in place, preventing the value referenced by that pointer from being moved\n+/// unless it implements [`Unpin`].\n ///\n /// See the [`pin` module] documentation for furthur explanation on pinning.\n ///\n /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n /// [`pin` module]: ../../std/pin/index.html\n+//\n+// Note: the derives below are allowed because they all only use `&P`, so they\n+// cannot move the value behind `pointer`.\n #[unstable(feature = \"pin\", issue = \"49150\")]\n #[fundamental]\n-pub struct PinMut<'a, T: ?Sized + 'a> {\n-    inner: &'a mut T,\n+#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]\n+pub struct Pin<P> {\n+    pointer: P,\n }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized + Unpin> PinMut<'a, T> {\n-    /// Construct a new `PinMut` around a reference to some data of a type that\n+impl<P: Deref> Pin<P>\n+where\n+    P::Target: Unpin,\n+{\n+    /// Construct a new `Pin` around a pointer to some data of a type that\n     /// implements `Unpin`.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn new(reference: &'a mut T) -> PinMut<'a, T> {\n-        PinMut { inner: reference }\n+    #[inline(always)]\n+    pub fn new(pointer: P) -> Pin<P> {\n+        // Safety: the value pointed to is `Unpin`, and so has no requirements\n+        // around pinning.\n+        unsafe { Pin::new_unchecked(pointer) }\n     }\n+}\n \n-    /// Get a mutable reference to the data inside of this `PinMut`.\n+impl<P: Deref> Pin<P> {\n+    /// Construct a new `Pin` around a reference to some data of a type that\n+    /// may or may not implement `Unpin`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This constructor is unsafe because we cannot guarantee that the data\n+    /// pointed to by `pointer` is pinned. If the constructed `Pin<P>` does\n+    /// not guarantee that the data `P` points to is pinned, constructing a\n+    /// `Pin<P>` is undefined behavior.\n+    ///\n+    /// If `pointer` dereferences to an `Unpin` type, `Pin::new` should be used\n+    /// instead.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[inline(always)]\n+    pub unsafe fn new_unchecked(pointer: P) -> Pin<P> {\n+        Pin { pointer }\n+    }\n+\n+    /// Get a pinned shared reference from this pinned pointer.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn get_mut(this: PinMut<'a, T>) -> &'a mut T {\n-        this.inner\n+    #[inline(always)]\n+    pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n+        unsafe { Pin::new_unchecked(&*self.pointer) }\n     }\n }\n \n+impl<P: DerefMut> Pin<P> {\n+    /// Get a pinned mutable reference from this pinned pointer.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[inline(always)]\n+    pub fn as_mut(self: &mut Pin<P>) -> Pin<&mut P::Target> {\n+        unsafe { Pin::new_unchecked(&mut *self.pointer) }\n+    }\n \n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> PinMut<'a, T> {\n-    /// Construct a new `PinMut` around a reference to some data of a type that\n-    /// may or may not implement `Unpin`.\n+    /// Assign a new value to the memory behind the pinned reference.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[inline(always)]\n+    pub fn set(mut self: Pin<P>, value: P::Target)\n+    where\n+        P::Target: Sized,\n+    {\n+        *self.pointer = value;\n+    }\n+}\n+\n+impl<'a, T: ?Sized> Pin<&'a T> {\n+    /// Construct a new pin by mapping the interior value.\n     ///\n-    /// This constructor is unsafe because we do not know what will happen with\n-    /// that data after the lifetime of the reference ends. If you cannot guarantee that the\n-    /// data will never move again, calling this constructor is invalid.\n+    /// For example, if you  wanted to get a `Pin` of a field of something,\n+    /// you could use this to get access to that field in one line of code.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe. You must guarantee that the data you return\n+    /// will not move so long as the argument value does not move (for example,\n+    /// because it is one of the fields of that value), and also that you do\n+    /// not move out of the argument you receive to the interior function.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub unsafe fn new_unchecked(reference: &'a mut T) -> PinMut<'a, T> {\n-        PinMut { inner: reference }\n+    pub unsafe fn map_unchecked<U, F>(this: Pin<&'a T>, func: F) -> Pin<&'a U> where\n+        F: FnOnce(&T) -> &U,\n+    {\n+        let pointer = &*this.pointer;\n+        let new_pointer = func(pointer);\n+        Pin::new_unchecked(new_pointer)\n     }\n \n-    /// Reborrow a `PinMut` for a shorter lifetime.\n+    /// Get a shared reference out of a pin.\n     ///\n-    /// For example, `PinMut::get_mut(x.reborrow())` (unsafely) returns a\n-    /// short-lived mutable reference reborrowing from `x`.\n+    /// Note: `Pin` also implements `Deref` to the target, which can be used\n+    /// to access the inner value. However, `Deref` only provides a reference\n+    /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n+    /// the `Pin` itself. This method allows turning the `Pin` into a reference\n+    /// with the same lifetime as the original `Pin`.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn reborrow<'b>(&'b mut self) -> PinMut<'b, T> {\n-        PinMut { inner: self.inner }\n+    #[inline(always)]\n+    pub fn get_ref(this: Pin<&'a T>) -> &'a T {\n+        this.pointer\n+    }\n+}\n+\n+impl<'a, T: ?Sized> Pin<&'a mut T> {\n+    /// Convert this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[inline(always)]\n+    pub fn into_ref(this: Pin<&'a mut T>) -> Pin<&'a T> {\n+        Pin { pointer: this.pointer }\n+    }\n+\n+    /// Get a mutable reference to the data inside of this `Pin`.\n+    ///\n+    /// This requires that the data inside this `Pin` is `Unpin`.\n+    ///\n+    /// Note: `Pin` also implements `DerefMut` to the data, which can be used\n+    /// to access the inner value. However, `DerefMut` only provides a reference\n+    /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n+    /// the `Pin` itself. This method allows turning the `Pin` into a reference\n+    /// with the same lifetime as the original `Pin`.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    #[inline(always)]\n+    pub fn get_mut(this: Pin<&'a mut T>) -> &'a mut T\n+        where T: Unpin,\n+    {\n+        this.pointer\n     }\n \n-    /// Get a mutable reference to the data inside of this `PinMut`.\n+    /// Get a mutable reference to the data inside of this `Pin`.\n+    ///\n+    /// # Safety\n     ///\n     /// This function is unsafe. You must guarantee that you will never move\n     /// the data out of the mutable reference you receive when you call this\n-    /// function.\n+    /// function, so that the invariants on the `Pin` type can be upheld.\n+    ///\n+    /// If the underlying data is `Unpin`, `Pin::get_mut` should be used\n+    /// instead.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub unsafe fn get_mut_unchecked(this: PinMut<'a, T>) -> &'a mut T {\n-        this.inner\n+    #[inline(always)]\n+    pub unsafe fn get_mut_unchecked(this: Pin<&'a mut T>) -> &'a mut T {\n+        this.pointer\n     }\n \n     /// Construct a new pin by mapping the interior value.\n     ///\n-    /// For example, if you  wanted to get a `PinMut` of a field of something,\n+    /// For example, if you  wanted to get a `Pin` of a field of something,\n     /// you could use this to get access to that field in one line of code.\n     ///\n+    /// # Safety\n+    ///\n     /// This function is unsafe. You must guarantee that the data you return\n     /// will not move so long as the argument value does not move (for example,\n     /// because it is one of the fields of that value), and also that you do\n     /// not move out of the argument you receive to the interior function.\n     #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub unsafe fn map_unchecked<U, F>(this: PinMut<'a, T>, f: F) -> PinMut<'a, U> where\n-        F: FnOnce(&mut T) -> &mut U\n+    pub unsafe fn map_unchecked_mut<U, F>(this: Pin<&'a mut T>, func: F) -> Pin<&'a mut U> where\n+        F: FnOnce(&mut T) -> &mut U,\n     {\n-        PinMut { inner: f(this.inner) }\n-    }\n-\n-    /// Assign a new value to the memory behind the pinned reference.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn set(this: PinMut<'a, T>, value: T)\n-        where T: Sized,\n-    {\n-        *this.inner = value;\n+        let pointer = Pin::get_mut_unchecked(this);\n+        let new_pointer = func(pointer);\n+        Pin::new_unchecked(new_pointer)\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> Deref for PinMut<'a, T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        &*self.inner\n+impl<P: Deref> Deref for Pin<P> {\n+    type Target = P::Target;\n+    fn deref(&self) -> &P::Target {\n+        Pin::get_ref(Pin::as_ref(self))\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized + Unpin> DerefMut for PinMut<'a, T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        self.inner\n+impl<P: DerefMut> DerefMut for Pin<P>\n+where\n+    P::Target: Unpin\n+{\n+    fn deref_mut(&mut self) -> &mut P::Target {\n+        Pin::get_mut(Pin::as_mut(self))\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: fmt::Debug + ?Sized> fmt::Debug for PinMut<'a, T> {\n+impl<'a, P: fmt::Debug> fmt::Debug for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&**self, f)\n+        fmt::Debug::fmt(&self.pointer, f)\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: fmt::Display + ?Sized> fmt::Display for PinMut<'a, T> {\n+impl<'a, P: fmt::Display> fmt::Display for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&**self, f)\n+        fmt::Display::fmt(&self.pointer, f)\n     }\n }\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> fmt::Pointer for PinMut<'a, T> {\n+impl<'a, P: fmt::Pointer> fmt::Pointer for Pin<P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&(&*self.inner as *const T), f)\n+        fmt::Pointer::fmt(&self.pointer, f)\n     }\n }\n \n+// Note: this means that any impl of `CoerceUnsized` that allows coercing from\n+// a type that impls `Deref<Target=impl !Unpin>` to a type that impls\n+// `Deref<Target=Unpin>` is unsound. Any such impl would probably be unsound\n+// for other reasons, though, so we just need to take care not to allow such\n+// impls to land in std.\n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PinMut<'a, U>> for PinMut<'a, T> {}\n+impl<'a, P, U> CoerceUnsized<Pin<U>> for Pin<P>\n+where\n+    P: CoerceUnsized<U>,\n+{}\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> Unpin for PinMut<'a, T> {}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for PinMut<'a, F>\n-    where F: Future<Output = T> + 'a\n-{\n-    fn into_raw(self) -> *mut () {\n-        unsafe { PinMut::get_mut_unchecked(self) as *mut F as *mut () }\n-    }\n-\n-    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n-        PinMut::new_unchecked(&mut *(ptr as *mut F)).poll(cx)\n-    }\n-\n-    unsafe fn drop(_ptr: *mut ()) {}\n-}\n+impl<'a, P> Unpin for Pin<P> {}"}, {"sha": "262646738cf06d10fe267ce9530a16137d0b830c", "filename": "src/libstd/future.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -12,7 +12,7 @@\n \n use core::cell::Cell;\n use core::marker::Unpin;\n-use core::pin::PinMut;\n+use core::pin::Pin;\n use core::option::Option;\n use core::ptr::NonNull;\n use core::task::{self, Poll};\n@@ -42,8 +42,8 @@ impl<T: Generator<Yield = ()>> !Unpin for GenFuture<T> {}\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n     type Output = T::Return;\n-    fn poll(self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n-        set_task_cx(cx, || match unsafe { PinMut::get_mut_unchecked(self).0.resume() } {\n+    fn poll(self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n+        set_task_cx(cx, || match unsafe { Pin::get_mut_unchecked(self).0.resume() } {\n             GeneratorState::Yielded(()) => Poll::Pending,\n             GeneratorState::Complete(x) => Poll::Ready(x),\n         })\n@@ -108,9 +108,9 @@ where\n \n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n /// Polls a future in the current thread-local task context.\n-pub fn poll_in_task_cx<F>(f: PinMut<F>) -> Poll<F::Output>\n+pub fn poll_in_task_cx<F>(f: Pin<&mut F>) -> Poll<F::Output>\n where\n     F: Future\n {\n-    get_task_cx(|cx| f.poll(cx))\n+    get_task_cx(|cx| F::poll(f, cx))\n }"}, {"sha": "1eb76d6c45ec47783b4619a8cb5b667ca85d4461", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -435,7 +435,7 @@ pub use alloc_crate::fmt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::format;\n #[unstable(feature = \"pin\", issue = \"49150\")]\n-pub use alloc_crate::pin;\n+pub use core::pin;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::slice;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "e60ef46e738b415eb82d63ed7a9c1a387e1b09c5", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -230,7 +230,7 @@ macro_rules! await {\n         loop {\n             if let $crate::task::Poll::Ready(x) =\n                 $crate::future::poll_in_task_cx(unsafe {\n-                    $crate::pin::PinMut::new_unchecked(&mut pinned)\n+                    $crate::pin::Pin::new_unchecked(&mut pinned)\n                 })\n             {\n                 break x;"}, {"sha": "bd7a92e9b3f0f904584aeeec58c619a21cfd6672", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -16,7 +16,7 @@ use any::Any;\n use cell::UnsafeCell;\n use fmt;\n use future::Future;\n-use pin::PinMut;\n+use pin::Pin;\n use ops::{Deref, DerefMut};\n use panicking;\n use ptr::{Unique, NonNull};\n@@ -327,9 +327,9 @@ impl<T: fmt::Debug> fmt::Debug for AssertUnwindSafe<T> {\n impl<'a, F: Future> Future for AssertUnwindSafe<F> {\n     type Output = F::Output;\n \n-    fn poll(self: PinMut<Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n-        let pinned_field = unsafe { PinMut::map_unchecked(self, |x| &mut x.0) };\n-        pinned_field.poll(cx)\n+    fn poll(self: Pin<&mut Self>, cx: &mut task::Context) -> Poll<Self::Output> {\n+        let pinned_field = unsafe { Pin::map_unchecked_mut(self, |x| &mut x.0) };\n+        F::poll(pinned_field, cx)\n     }\n }\n "}, {"sha": "3301e6a4637fef01dcb905ea143dcb6c8487f421", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -12,8 +12,7 @@\n \n #![feature(arbitrary_self_types, async_await, await_macro, futures_api, pin)]\n \n-use std::pin::PinBox;\n-use std::pin::PinMut;\n+use std::pin::Pin;\n use std::future::Future;\n use std::sync::{\n     Arc,\n@@ -49,7 +48,7 @@ fn wake_and_yield_once() -> WakeOnceThenComplete { WakeOnceThenComplete(false) }\n \n impl Future for WakeOnceThenComplete {\n     type Output = ();\n-    fn poll(mut self: PinMut<Self>, cx: &mut Context) -> Poll<()> {\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context) -> Poll<()> {\n         if self.0 {\n             Poll::Ready(())\n         } else {\n@@ -148,16 +147,16 @@ where\n     F: FnOnce(u8) -> Fut,\n     Fut: Future<Output = u8>,\n {\n-    let mut fut = PinBox::new(f(9));\n+    let mut fut = Box::pinned(f(9));\n     let counter = Arc::new(Counter { wakes: AtomicUsize::new(0) });\n     let waker = local_waker_from_nonlocal(counter.clone());\n     let spawner = &mut NoopSpawner;\n     let cx = &mut Context::new(&waker, spawner);\n \n     assert_eq!(0, counter.wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(Poll::Pending, fut.as_pin_mut().poll(cx));\n+    assert_eq!(Poll::Pending, fut.as_mut().poll(cx));\n     assert_eq!(1, counter.wakes.load(atomic::Ordering::SeqCst));\n-    assert_eq!(Poll::Ready(9), fut.as_pin_mut().poll(cx));\n+    assert_eq!(Poll::Ready(9), fut.as_mut().poll(cx));\n }\n \n fn main() {"}, {"sha": "6e757fb4f9a42f16ce74b5ceab74d996429b008c", "filename": "src/test/run-pass/futures-api.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -11,9 +11,8 @@\n #![feature(arbitrary_self_types, futures_api, pin)]\n #![allow(unused)]\n \n-use std::pin::PinBox;\n use std::future::Future;\n-use std::pin::PinMut;\n+use std::pin::Pin;\n use std::rc::Rc;\n use std::sync::{\n     Arc,\n@@ -54,12 +53,12 @@ struct MyFuture;\n \n impl Future for MyFuture {\n     type Output = ();\n-    fn poll(self: PinMut<Self>, cx: &mut Context) -> Poll<Self::Output> {\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n         // Ensure all the methods work appropriately\n         cx.waker().wake();\n         cx.waker().wake();\n         cx.local_waker().wake();\n-        cx.spawner().spawn_obj(PinBox::new(MyFuture).into()).unwrap();\n+        cx.spawner().spawn_obj(Box::pinned(MyFuture).into()).unwrap();\n         Poll::Ready(())\n     }\n }\n@@ -72,7 +71,7 @@ fn test_local_waker() {\n     let waker = unsafe { local_waker(counter.clone()) };\n     let spawner = &mut NoopSpawner;\n     let cx = &mut Context::new(&waker, spawner);\n-    assert_eq!(Poll::Ready(()), PinMut::new(&mut MyFuture).poll(cx));\n+    assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(cx));\n     assert_eq!(1, counter.local_wakes.load(atomic::Ordering::SeqCst));\n     assert_eq!(2, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n }\n@@ -85,7 +84,7 @@ fn test_local_as_nonlocal_waker() {\n     let waker: LocalWaker = local_waker_from_nonlocal(counter.clone());\n     let spawner = &mut NoopSpawner;\n     let cx = &mut Context::new(&waker, spawner);\n-    assert_eq!(Poll::Ready(()), PinMut::new(&mut MyFuture).poll(cx));\n+    assert_eq!(Poll::Ready(()), Pin::new(&mut MyFuture).poll(cx));\n     assert_eq!(0, counter.local_wakes.load(atomic::Ordering::SeqCst));\n     assert_eq!(3, counter.nonlocal_wakes.load(atomic::Ordering::SeqCst));\n }"}, {"sha": "55842dc8e45e66d36001e10298f724236b22be0a", "filename": "src/test/rustdoc-js/pinbox-new.js", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ff6422d7a392acfc8af28994d65af2bbaecea4f6/src%2Ftest%2Frustdoc-js%2Fpinbox-new.js", "raw_url": "https://github.com/rust-lang/rust/raw/ff6422d7a392acfc8af28994d65af2bbaecea4f6/src%2Ftest%2Frustdoc-js%2Fpinbox-new.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fpinbox-new.js?ref=ff6422d7a392acfc8af28994d65af2bbaecea4f6", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// exact-check\n-\n-const QUERY = 'pinbox::new';\n-\n-const EXPECTED = {\n-    'others': [\n-        { 'path': 'std::pin::PinBox', 'name': 'new' },\n-        { 'path': 'alloc::pin::PinBox', 'name': 'new' },\n-    ],\n-};"}, {"sha": "42951724648fddb9fec66af643d9f8c144421e54", "filename": "src/test/rustdoc-js/vec-new.js", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Ftest%2Frustdoc-js%2Fvec-new.js", "raw_url": "https://github.com/rust-lang/rust/raw/1e21c9a297a9fe668d62887a3a6a4add8e717b17/src%2Ftest%2Frustdoc-js%2Fvec-new.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fvec-new.js?ref=1e21c9a297a9fe668d62887a3a6a4add8e717b17", "patch": "@@ -14,6 +14,5 @@ const EXPECTED = {\n     'others': [\n         { 'path': 'std::vec::Vec', 'name': 'new' },\n         { 'path': 'std::vec::Vec', 'name': 'ne' },\n-        { 'path': 'std::pin::PinBox', 'name': 'new' },\n     ],\n };"}]}