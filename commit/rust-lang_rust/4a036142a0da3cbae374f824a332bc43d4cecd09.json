{"sha": "4a036142a0da3cbae374f824a332bc43d4cecd09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMDM2MTQyYTBkYTNjYmFlMzc0ZjgyNGEzMzJiYzQzZDRjZWNkMDk=", "commit": {"author": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2018-12-17T22:33:12Z"}, "committer": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2019-01-22T22:45:11Z"}, "message": "Move Sum, Product to own module", "tree": {"sha": "a1d8b92a1bd893d408e5f6aea8e484fae7395553", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1d8b92a1bd893d408e5f6aea8e484fae7395553"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a036142a0da3cbae374f824a332bc43d4cecd09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a036142a0da3cbae374f824a332bc43d4cecd09", "html_url": "https://github.com/rust-lang/rust/commit/4a036142a0da3cbae374f824a332bc43d4cecd09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a036142a0da3cbae374f824a332bc43d4cecd09/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ba9733d718768edd1d5a8f26d1f2940b0aea327", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba9733d718768edd1d5a8f26d1f2940b0aea327", "html_url": "https://github.com/rust-lang/rust/commit/3ba9733d718768edd1d5a8f26d1f2940b0aea327"}], "stats": {"total": 453, "additions": 227, "deletions": 226}, "files": [{"sha": "dfe1d2a1006d7b1ff8fa0352c1f507af1e9c7b50", "filename": "src/libcore/iter/traits/accum.rs", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/4a036142a0da3cbae374f824a332bc43d4cecd09/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a036142a0da3cbae374f824a332bc43d4cecd09/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=4a036142a0da3cbae374f824a332bc43d4cecd09", "patch": "@@ -0,0 +1,225 @@\n+use ops::{Mul, Add};\n+use num::Wrapping;\n+\n+/// Trait to represent types that can be created by summing up an iterator.\n+///\n+/// This trait is used to implement the [`sum`] method on iterators. Types which\n+/// implement the trait can be generated by the [`sum`] method. Like\n+/// [`FromIterator`] this trait should rarely be called directly and instead\n+/// interacted with through [`Iterator::sum`].\n+///\n+/// [`sum`]: ../../std/iter/trait.Sum.html#tymethod.sum\n+/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n+/// [`Iterator::sum`]: ../../std/iter/trait.Iterator.html#method.sum\n+#[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+pub trait Sum<A = Self>: Sized {\n+    /// Method which takes an iterator and generates `Self` from the elements by\n+    /// \"summing up\" the items.\n+    #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+    fn sum<I: Iterator<Item=A>>(iter: I) -> Self;\n+}\n+\n+/// Trait to represent types that can be created by multiplying elements of an\n+/// iterator.\n+///\n+/// This trait is used to implement the [`product`] method on iterators. Types\n+/// which implement the trait can be generated by the [`product`] method. Like\n+/// [`FromIterator`] this trait should rarely be called directly and instead\n+/// interacted with through [`Iterator::product`].\n+///\n+/// [`product`]: ../../std/iter/trait.Product.html#tymethod.product\n+/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n+/// [`Iterator::product`]: ../../std/iter/trait.Iterator.html#method.product\n+#[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+pub trait Product<A = Self>: Sized {\n+    /// Method which takes an iterator and generates `Self` from the elements by\n+    /// multiplying the items.\n+    #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+    fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n+}\n+\n+// N.B., explicitly use Add and Mul here to inherit overflow checks\n+macro_rules! integer_sum_product {\n+    (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n+        #[$attr]\n+        impl Sum for $a {\n+            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold($zero, Add::add)\n+            }\n+        }\n+\n+        #[$attr]\n+        impl Product for $a {\n+            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold($one, Mul::mul)\n+            }\n+        }\n+\n+        #[$attr]\n+        impl<'a> Sum<&'a $a> for $a {\n+            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold($zero, Add::add)\n+            }\n+        }\n+\n+        #[$attr]\n+        impl<'a> Product<&'a $a> for $a {\n+            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold($one, Mul::mul)\n+            }\n+        }\n+    )*);\n+    ($($a:ty)*) => (\n+        integer_sum_product!(@impls 0, 1,\n+                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n+                $($a)+);\n+        integer_sum_product!(@impls Wrapping(0), Wrapping(1),\n+                #[stable(feature = \"wrapping_iter_arith\", since = \"1.14.0\")],\n+                $(Wrapping<$a>)+);\n+    );\n+}\n+\n+macro_rules! float_sum_product {\n+    ($($a:ident)*) => ($(\n+        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+        impl Sum for $a {\n+            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold(0.0, |a, b| a + b)\n+            }\n+        }\n+\n+        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+        impl Product for $a {\n+            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n+                iter.fold(1.0, |a, b| a * b)\n+            }\n+        }\n+\n+        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+        impl<'a> Sum<&'a $a> for $a {\n+            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold(0.0, |a, b| a + *b)\n+            }\n+        }\n+\n+        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n+        impl<'a> Product<&'a $a> for $a {\n+            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n+                iter.fold(1.0, |a, b| a * *b)\n+            }\n+        }\n+    )*)\n+}\n+\n+integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n+float_sum_product! { f32 f64 }\n+\n+/// An iterator adapter that produces output as long as the underlying\n+/// iterator produces `Result::Ok` values.\n+///\n+/// If an error is encountered, the iterator stops and the error is\n+/// stored. The error may be recovered later via `reconstruct`.\n+struct ResultShunt<I, E> {\n+    iter: I,\n+    error: Option<E>,\n+}\n+\n+impl<I, T, E> ResultShunt<I, E>\n+    where I: Iterator<Item = Result<T, E>>\n+{\n+    /// Process the given iterator as if it yielded a `T` instead of a\n+    /// `Result<T, _>`. Any errors will stop the inner iterator and\n+    /// the overall result will be an error.\n+    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n+        where F: FnMut(&mut Self) -> U\n+    {\n+        let mut shunt = ResultShunt::new(iter);\n+        let value = f(shunt.by_ref());\n+        shunt.reconstruct(value)\n+    }\n+\n+    fn new(iter: I) -> Self {\n+        ResultShunt {\n+            iter,\n+            error: None,\n+        }\n+    }\n+\n+    /// Consume the adapter and rebuild a `Result` value. This should\n+    /// *always* be called, otherwise any potential error would be\n+    /// lost.\n+    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n+        match self.error {\n+            None => Ok(val),\n+            Some(e) => Err(e),\n+        }\n+    }\n+}\n+\n+impl<I, T, E> Iterator for ResultShunt<I, E>\n+    where I: Iterator<Item = Result<T, E>>\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.iter.next() {\n+            Some(Ok(v)) => Some(v),\n+            Some(Err(e)) => {\n+                self.error = Some(e);\n+                None\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.error.is_some() {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n+impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n+    where T: Sum<U>,\n+{\n+    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n+    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n+    /// the sum of all elements is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This sums up every integer in a vector, rejecting the sum if a negative\n+    /// element is encountered:\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2];\n+    /// let res: Result<i32, &'static str> = v.iter().map(|&x: &i32|\n+    ///     if x < 0 { Err(\"Negative element found\") }\n+    ///     else { Ok(x) }\n+    /// ).sum();\n+    /// assert_eq!(res, Ok(3));\n+    /// ```\n+    fn sum<I>(iter: I) -> Result<T, E>\n+        where I: Iterator<Item = Result<U, E>>,\n+    {\n+        ResultShunt::process(iter, |i| i.sum())\n+    }\n+}\n+\n+#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n+impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n+    where T: Product<U>,\n+{\n+    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n+    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n+    /// the product of all elements is returned.\n+    fn product<I>(iter: I) -> Result<T, E>\n+        where I: Iterator<Item = Result<U, E>>,\n+    {\n+        ResultShunt::process(iter, |i| i.product())\n+    }\n+}"}, {"sha": "25637ef9f4ede833a882a482e235e2ba81c5bebb", "filename": "src/libcore/iter/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 226, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/4a036142a0da3cbae374f824a332bc43d4cecd09/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a036142a0da3cbae374f824a332bc43d4cecd09/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs?ref=4a036142a0da3cbae374f824a332bc43d4cecd09", "patch": "@@ -1,238 +1,14 @@\n-use ops::{Mul, Add};\n-use num::Wrapping;\n-\n mod iterator;\n mod double_ended;\n mod exact_size;\n mod collect;\n+mod accum;\n \n pub use self::iterator::Iterator;\n pub use self::double_ended::DoubleEndedIterator;\n pub use self::exact_size::ExactSizeIterator;\n pub use self::collect::{FromIterator, IntoIterator, Extend};\n-\n-/// Trait to represent types that can be created by summing up an iterator.\n-///\n-/// This trait is used to implement the [`sum`] method on iterators. Types which\n-/// implement the trait can be generated by the [`sum`] method. Like\n-/// [`FromIterator`] this trait should rarely be called directly and instead\n-/// interacted with through [`Iterator::sum`].\n-///\n-/// [`sum`]: ../../std/iter/trait.Sum.html#tymethod.sum\n-/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n-/// [`Iterator::sum`]: ../../std/iter/trait.Iterator.html#method.sum\n-#[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-pub trait Sum<A = Self>: Sized {\n-    /// Method which takes an iterator and generates `Self` from the elements by\n-    /// \"summing up\" the items.\n-    #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-    fn sum<I: Iterator<Item=A>>(iter: I) -> Self;\n-}\n-\n-/// Trait to represent types that can be created by multiplying elements of an\n-/// iterator.\n-///\n-/// This trait is used to implement the [`product`] method on iterators. Types\n-/// which implement the trait can be generated by the [`product`] method. Like\n-/// [`FromIterator`] this trait should rarely be called directly and instead\n-/// interacted with through [`Iterator::product`].\n-///\n-/// [`product`]: ../../std/iter/trait.Product.html#tymethod.product\n-/// [`FromIterator`]: ../../std/iter/trait.FromIterator.html\n-/// [`Iterator::product`]: ../../std/iter/trait.Iterator.html#method.product\n-#[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-pub trait Product<A = Self>: Sized {\n-    /// Method which takes an iterator and generates `Self` from the elements by\n-    /// multiplying the items.\n-    #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-    fn product<I: Iterator<Item=A>>(iter: I) -> Self;\n-}\n-\n-// N.B., explicitly use Add and Mul here to inherit overflow checks\n-macro_rules! integer_sum_product {\n-    (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n-        #[$attr]\n-        impl Sum for $a {\n-            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold($zero, Add::add)\n-            }\n-        }\n-\n-        #[$attr]\n-        impl Product for $a {\n-            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold($one, Mul::mul)\n-            }\n-        }\n-\n-        #[$attr]\n-        impl<'a> Sum<&'a $a> for $a {\n-            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold($zero, Add::add)\n-            }\n-        }\n-\n-        #[$attr]\n-        impl<'a> Product<&'a $a> for $a {\n-            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold($one, Mul::mul)\n-            }\n-        }\n-    )*);\n-    ($($a:ty)*) => (\n-        integer_sum_product!(@impls 0, 1,\n-                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n-                $($a)+);\n-        integer_sum_product!(@impls Wrapping(0), Wrapping(1),\n-                #[stable(feature = \"wrapping_iter_arith\", since = \"1.14.0\")],\n-                $(Wrapping<$a>)+);\n-    );\n-}\n-\n-macro_rules! float_sum_product {\n-    ($($a:ident)*) => ($(\n-        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-        impl Sum for $a {\n-            fn sum<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(0.0, |a, b| a + b)\n-            }\n-        }\n-\n-        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-        impl Product for $a {\n-            fn product<I: Iterator<Item=$a>>(iter: I) -> $a {\n-                iter.fold(1.0, |a, b| a * b)\n-            }\n-        }\n-\n-        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-        impl<'a> Sum<&'a $a> for $a {\n-            fn sum<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(0.0, |a, b| a + *b)\n-            }\n-        }\n-\n-        #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")]\n-        impl<'a> Product<&'a $a> for $a {\n-            fn product<I: Iterator<Item=&'a $a>>(iter: I) -> $a {\n-                iter.fold(1.0, |a, b| a * *b)\n-            }\n-        }\n-    )*)\n-}\n-\n-integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n-float_sum_product! { f32 f64 }\n-\n-/// An iterator adapter that produces output as long as the underlying\n-/// iterator produces `Result::Ok` values.\n-///\n-/// If an error is encountered, the iterator stops and the error is\n-/// stored. The error may be recovered later via `reconstruct`.\n-struct ResultShunt<I, E> {\n-    iter: I,\n-    error: Option<E>,\n-}\n-\n-impl<I, T, E> ResultShunt<I, E>\n-    where I: Iterator<Item = Result<T, E>>\n-{\n-    /// Process the given iterator as if it yielded a `T` instead of a\n-    /// `Result<T, _>`. Any errors will stop the inner iterator and\n-    /// the overall result will be an error.\n-    pub fn process<F, U>(iter: I, mut f: F) -> Result<U, E>\n-        where F: FnMut(&mut Self) -> U\n-    {\n-        let mut shunt = ResultShunt::new(iter);\n-        let value = f(shunt.by_ref());\n-        shunt.reconstruct(value)\n-    }\n-\n-    fn new(iter: I) -> Self {\n-        ResultShunt {\n-            iter,\n-            error: None,\n-        }\n-    }\n-\n-    /// Consume the adapter and rebuild a `Result` value. This should\n-    /// *always* be called, otherwise any potential error would be\n-    /// lost.\n-    fn reconstruct<U>(self, val: U) -> Result<U, E> {\n-        match self.error {\n-            None => Ok(val),\n-            Some(e) => Err(e),\n-        }\n-    }\n-}\n-\n-impl<I, T, E> Iterator for ResultShunt<I, E>\n-    where I: Iterator<Item = Result<T, E>>\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.iter.next() {\n-            Some(Ok(v)) => Some(v),\n-            Some(Err(e)) => {\n-                self.error = Some(e);\n-                None\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.error.is_some() {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper)\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n-impl<T, U, E> Sum<Result<U, E>> for Result<T, E>\n-    where T: Sum<U>,\n-{\n-    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n-    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n-    /// the sum of all elements is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// This sums up every integer in a vector, rejecting the sum if a negative\n-    /// element is encountered:\n-    ///\n-    /// ```\n-    /// let v = vec![1, 2];\n-    /// let res: Result<i32, &'static str> = v.iter().map(|&x: &i32|\n-    ///     if x < 0 { Err(\"Negative element found\") }\n-    ///     else { Ok(x) }\n-    /// ).sum();\n-    /// assert_eq!(res, Ok(3));\n-    /// ```\n-    fn sum<I>(iter: I) -> Result<T, E>\n-        where I: Iterator<Item = Result<U, E>>,\n-    {\n-        ResultShunt::process(iter, |i| i.sum())\n-    }\n-}\n-\n-#[stable(feature = \"iter_arith_traits_result\", since=\"1.16.0\")]\n-impl<T, U, E> Product<Result<U, E>> for Result<T, E>\n-    where T: Product<U>,\n-{\n-    /// Takes each element in the `Iterator`: if it is an `Err`, no further\n-    /// elements are taken, and the `Err` is returned. Should no `Err` occur,\n-    /// the product of all elements is returned.\n-    fn product<I>(iter: I) -> Result<T, E>\n-        where I: Iterator<Item = Result<U, E>>,\n-    {\n-        ResultShunt::process(iter, |i| i.product())\n-    }\n-}\n+pub use self::accum::{Sum, Product};\n \n /// An iterator that always continues to yield `None` when exhausted.\n ///"}]}