{"sha": "92907216258e26d70cd49371f74e6bab511b5332", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyOTA3MjE2MjU4ZTI2ZDcwY2Q0OTM3MWY3NGU2YmFiNTExYjUzMzI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-14T14:29:40Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-15T02:09:19Z"}, "message": "Ported liveness.rs from oldvisit to <V:Visitor> trait API.", "tree": {"sha": "fe2bc99d85d28ceafd2468184aff59b37d764d02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe2bc99d85d28ceafd2468184aff59b37d764d02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92907216258e26d70cd49371f74e6bab511b5332", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92907216258e26d70cd49371f74e6bab511b5332", "html_url": "https://github.com/rust-lang/rust/commit/92907216258e26d70cd49371f74e6bab511b5332", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92907216258e26d70cd49371f74e6bab511b5332/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac5825057fed5aafe69d2eaed62d044e2faf6287", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac5825057fed5aafe69d2eaed62d044e2faf6287", "html_url": "https://github.com/rust-lang/rust/commit/ac5825057fed5aafe69d2eaed62d044e2faf6287"}], "stats": {"total": 120, "additions": 68, "deletions": 52}, "files": [{"sha": "edb805cfc40aeb37e3fc08992f25345028adad95", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 68, "deletions": 52, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/92907216258e26d70cd49371f74e6bab511b5332/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92907216258e26d70cd49371f74e6bab511b5332/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=92907216258e26d70cd49371f74e6bab511b5332", "patch": "@@ -119,9 +119,8 @@ use syntax::ast::*;\n use syntax::codemap::span;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::{expr_to_str, block_to_str};\n-use syntax::oldvisit::{fk_anon, fk_fn_block, fk_item_fn, fk_method};\n-use syntax::oldvisit::{vt};\n-use syntax::{oldvisit, ast_util};\n+use syntax::{visit, ast_util};\n+use syntax::visit::{Visitor,fn_kind};\n \n #[deriving(Eq)]\n struct Variable(uint);\n@@ -152,22 +151,27 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n     }\n }\n \n+struct LivenessVisitor;\n+\n+impl Visitor<@mut IrMaps> for LivenessVisitor {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, e:@mut IrMaps) {\n+        visit_fn(self, fk, fd, b, s, n, e);\n+    }\n+    fn visit_local(&mut self, l:@Local, e:@mut IrMaps) { visit_local(self, l, e); }\n+    fn visit_expr(&mut self, ex:@expr, e:@mut IrMaps) { visit_expr(self, ex, e); }\n+    fn visit_arm(&mut self, a:&arm, e:@mut IrMaps) { visit_arm(self, a, e); }\n+}\n+\n pub fn check_crate(tcx: ty::ctxt,\n                    method_map: typeck::method_map,\n                    capture_map: moves::CaptureMap,\n                    crate: &Crate) {\n-    let visitor = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_fn: visit_fn,\n-        visit_local: visit_local,\n-        visit_expr: visit_expr,\n-        visit_arm: visit_arm,\n-        .. *oldvisit::default_visitor()\n-    });\n+    let mut visitor = LivenessVisitor;\n \n     let initial_maps = @mut IrMaps(tcx,\n                                    method_map,\n                                    capture_map);\n-    oldvisit::visit_crate(crate, (initial_maps, visitor));\n+    visit::walk_crate(&mut visitor, crate, initial_maps);\n     tcx.sess.abort_if_errors();\n }\n \n@@ -341,13 +345,30 @@ impl IrMaps {\n     }\n }\n \n-fn visit_fn(fk: &oldvisit::fn_kind,\n+struct ErrorCheckVisitor;\n+\n+impl Visitor<@Liveness> for ErrorCheckVisitor {\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, e:@Liveness) {\n+        check_fn(self, fk, fd, b, s, n, e);\n+    }\n+    fn visit_local(&mut self, l:@Local, e:@Liveness) {\n+        check_local(self, l, e);\n+    }\n+    fn visit_expr(&mut self, ex:@expr, e:@Liveness) {\n+        check_expr(self, ex, e);\n+    }\n+    fn visit_arm(&mut self, a:&arm, e:@Liveness) {\n+        check_arm(self, a, e);\n+    }\n+}\n+\n+fn visit_fn(v: &mut LivenessVisitor,\n+            fk: &visit::fn_kind,\n             decl: &fn_decl,\n             body: &Block,\n             sp: span,\n             id: NodeId,\n-            (this, v): (@mut IrMaps,\n-                        vt<@mut IrMaps>)) {\n+            this: @mut IrMaps) {\n     debug!(\"visit_fn: id=%d\", id);\n     let _i = ::util::common::indenter();\n \n@@ -371,7 +392,7 @@ fn visit_fn(fk: &oldvisit::fn_kind,\n \n     // Add `this`, whether explicit or implicit.\n     match *fk {\n-        fk_method(_, _, method) => {\n+        visit::fk_method(_, _, method) => {\n             match method.explicit_self.node {\n                 sty_value | sty_region(*) | sty_box(_) | sty_uniq => {\n                     fn_maps.add_variable(Arg(method.self_id,\n@@ -380,12 +401,12 @@ fn visit_fn(fk: &oldvisit::fn_kind,\n                 sty_static => {}\n             }\n         }\n-        fk_item_fn(*) | fk_anon(*) | fk_fn_block(*) => {}\n+        visit::fk_item_fn(*) | visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n     }\n \n     // gather up the various local variables, significant expressions,\n     // and so forth:\n-    oldvisit::visit_fn(fk, decl, body, sp, id, (fn_maps, v));\n+    visit::walk_fn(v, fk, decl, body, sp, id, fn_maps);\n \n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or fail\n@@ -402,19 +423,13 @@ fn visit_fn(fk: &oldvisit::fn_kind,\n     let entry_ln = (*lsets).compute(decl, body);\n \n     // check for various error conditions\n-    let check_vt = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_fn: check_fn,\n-        visit_local: check_local,\n-        visit_expr: check_expr,\n-        visit_arm: check_arm,\n-        .. *oldvisit::default_visitor()\n-    });\n-    (check_vt.visit_block)(body, (lsets, check_vt));\n+    let mut check_vt = ErrorCheckVisitor;\n+    check_vt.visit_block(body, lsets);\n     lsets.check_ret(id, sp, fk, entry_ln);\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(local: @Local, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n+fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.pat) |_bm, p_id, sp, path| {\n         debug!(\"adding local variable %d\", p_id);\n@@ -431,10 +446,10 @@ fn visit_local(local: @Local, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n           kind: kind\n         }));\n     }\n-    oldvisit::visit_local(local, (this, vt));\n+    visit::walk_local(v, local, this);\n }\n \n-fn visit_arm(arm: &arm, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n+fn visit_arm(v: &mut LivenessVisitor, arm: &arm, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n     for pat in arm.pats.iter() {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n@@ -450,10 +465,10 @@ fn visit_arm(arm: &arm, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n             }));\n         }\n     }\n-    oldvisit::visit_arm(arm, (this, vt));\n+    visit::walk_arm(v, arm, this);\n }\n \n-fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n+fn visit_expr(v: &mut LivenessVisitor, expr: @expr, this: @mut IrMaps) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) | expr_self => {\n@@ -462,7 +477,7 @@ fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n         if moves::moved_variable_node_id_from_def(def).is_some() {\n             this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(v, expr, this);\n       }\n       expr_fn_block(*) => {\n         // Interesting control flow (for loops can contain labeled\n@@ -495,18 +510,18 @@ fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n         }\n         this.set_captures(expr.id, call_caps);\n \n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(v, expr, this);\n       }\n \n       // live nodes required for interesting control flow:\n       expr_if(*) | expr_match(*) | expr_while(*) | expr_loop(*) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(v, expr, this);\n       }\n       expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\"),\n       expr_binary(_, op, _, _) if ast_util::lazy_binop(op) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(v, expr, this);\n       }\n \n       // otherwise, live nodes are not required:\n@@ -518,7 +533,7 @@ fn visit_expr(expr: @expr, (this, vt): (@mut IrMaps, vt<@mut IrMaps>)) {\n       expr_assign(*) | expr_assign_op(*) | expr_mac(*) |\n       expr_struct(*) | expr_repeat(*) | expr_paren(*) |\n       expr_inline_asm(*) => {\n-          oldvisit::visit_expr(expr, (this, vt));\n+          visit::walk_expr(v, expr, this);\n       }\n     }\n }\n@@ -1408,7 +1423,7 @@ impl Liveness {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(local: @Local, (this, vt): (@Liveness, vt<@Liveness>)) {\n+fn check_local(vt: &mut ErrorCheckVisitor, local: @Local, this: @Liveness) {\n     match local.init {\n       Some(_) => {\n         this.warn_about_unused_or_dead_vars_in_pat(local.pat);\n@@ -1434,34 +1449,34 @@ fn check_local(local: @Local, (this, vt): (@Liveness, vt<@Liveness>)) {\n       }\n     }\n \n-    oldvisit::visit_local(local, (this, vt));\n+    visit::walk_local(vt, local, this);\n }\n \n-fn check_arm(arm: &arm, (this, vt): (@Liveness, vt<@Liveness>)) {\n+fn check_arm(vt: &mut ErrorCheckVisitor, arm: &arm, this: @Liveness) {\n     do this.arm_pats_bindings(arm.pats) |ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     }\n-    oldvisit::visit_arm(arm, (this, vt));\n+    visit::walk_arm(vt, arm, this);\n }\n \n-fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n+fn check_expr(vt: &mut ErrorCheckVisitor, expr: @expr, this: @Liveness) {\n     match expr.node {\n       expr_assign(l, r) => {\n         this.check_lvalue(l, vt);\n-        (vt.visit_expr)(r, (this, vt));\n+        vt.visit_expr(r, this);\n \n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(vt, expr, this);\n       }\n \n       expr_assign_op(_, _, l, _) => {\n         this.check_lvalue(l, vt);\n \n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(vt, expr, this);\n       }\n \n       expr_inline_asm(ref ia) => {\n         for &(_, input) in ia.inputs.iter() {\n-          (vt.visit_expr)(input, (this, vt));\n+          vt.visit_expr(input, this);\n         }\n \n         // Output operands must be lvalues\n@@ -1472,10 +1487,10 @@ fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n             }\n             _ => {}\n           }\n-          (vt.visit_expr)(out, (this, vt));\n+          vt.visit_expr(out, this);\n         }\n \n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(vt, expr, this);\n       }\n \n       // no correctness conditions related to liveness\n@@ -1487,18 +1502,19 @@ fn check_expr(expr: @expr, (this, vt): (@Liveness, vt<@Liveness>)) {\n       expr_again(*) | expr_lit(_) | expr_block(*) |\n       expr_mac(*) | expr_addr_of(*) | expr_struct(*) | expr_repeat(*) |\n       expr_paren(*) | expr_fn_block(*) | expr_path(*) | expr_self(*) => {\n-        oldvisit::visit_expr(expr, (this, vt));\n+        visit::walk_expr(vt, expr, this);\n       }\n       expr_for_loop(*) => fail!(\"non-desugared expr_for_loop\")\n     }\n }\n \n-fn check_fn(_fk: &oldvisit::fn_kind,\n+fn check_fn(_v: &mut ErrorCheckVisitor,\n+            _fk: &visit::fn_kind,\n             _decl: &fn_decl,\n             _body: &Block,\n             _sp: span,\n             _id: NodeId,\n-            (_self, _v): (@Liveness, vt<@Liveness>)) {\n+            _self: @Liveness) {\n     // do not check contents of nested fns\n }\n \n@@ -1513,7 +1529,7 @@ impl Liveness {\n     pub fn check_ret(&self,\n                      id: NodeId,\n                      sp: span,\n-                     _fk: &oldvisit::fn_kind,\n+                     _fk: &visit::fn_kind,\n                      entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n@@ -1533,7 +1549,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn check_lvalue(@self, expr: @expr, vt: vt<@Liveness>) {\n+    pub fn check_lvalue(@self, expr: @expr, vt: &mut ErrorCheckVisitor) {\n         match expr.node {\n           expr_path(_) => {\n             match self.tcx.def_map.get_copy(&expr.id) {\n@@ -1562,7 +1578,7 @@ impl Liveness {\n           _ => {\n             // For other kinds of lvalues, no checks are required,\n             // and any embedded expressions are actually rvalues\n-            oldvisit::visit_expr(expr, (self, vt));\n+            visit::walk_expr(vt, expr, self);\n           }\n        }\n     }"}]}