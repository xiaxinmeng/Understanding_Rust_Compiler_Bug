{"sha": "e0216fcc42d5f4961d07378a783c87814097015f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMjE2ZmNjNDJkNWY0OTYxZDA3Mzc4YTc4M2M4NzgxNDA5NzAxNWY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-12T00:48:14Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-12T00:48:14Z"}, "message": "Merge branch 'master' into", "tree": {"sha": "e5f503c129942a2b7c2815b1c8e4db85b5bbcf1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5f503c129942a2b7c2815b1c8e4db85b5bbcf1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0216fcc42d5f4961d07378a783c87814097015f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0216fcc42d5f4961d07378a783c87814097015f", "html_url": "https://github.com/rust-lang/rust/commit/e0216fcc42d5f4961d07378a783c87814097015f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0216fcc42d5f4961d07378a783c87814097015f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "html_url": "https://github.com/rust-lang/rust/commit/aa5ca282b20391c6df51fdfa94e0de5672ccfac1"}, {"sha": "750f2c63f2737305d33288303cdecb7a470a7922", "url": "https://api.github.com/repos/rust-lang/rust/commits/750f2c63f2737305d33288303cdecb7a470a7922", "html_url": "https://github.com/rust-lang/rust/commit/750f2c63f2737305d33288303cdecb7a470a7922"}], "stats": {"total": 14529, "additions": 11068, "deletions": 3461}, "files": [{"sha": "0f20e510adcd8e238da930846db8cb4cbdfaefd0", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -518,6 +518,7 @@ Luke Francl <look@recursion.org>\n Luke Metz <luke.metz@students.olin.edu>\n Luke Steensen <luke.steensen@gmail.com>\n Luqman Aden <me@luqman.ca>\n+\u0141ukasz Niemier <lukasz@niemier.pl>\n Magnus Auvinen <magnus.auvinen@gmail.com>\n Mahmut Bulut <mahmutbulut0@gmail.com>\n Makoto Nakashima <makoto.nksm+github@gmail.com>\n@@ -997,5 +998,4 @@ xales <xales@naveria.com>\n zofrex <zofrex@gmail.com>\n zslayton <zack.slayton@gmail.com>\n zzmp <zmp@umich.edu>\n-\u0141ukasz Niemier <lukasz@niemier.pl>\n \u514b\u96f7 <geekcraik@users.noreply.github.com>"}, {"sha": "9b9de9da06716d6084e4b3b2b1c252e72b8fc80a", "filename": "configure", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/configure", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -19,6 +19,11 @@ err() {\n     exit 1\n }\n \n+run() {\n+    msg \"$@\"\n+    \"$@\"\n+}\n+\n need_ok() {\n     if [ $? -ne 0 ]\n     then\n@@ -36,8 +41,7 @@ need_cmd() {\n make_dir() {\n     if [ ! -d $1 ]\n     then\n-        msg \"mkdir -p $1\"\n-        mkdir -p $1\n+        run mkdir -p $1\n     fi\n }\n \n@@ -46,8 +50,7 @@ copy_if_changed() {\n     then\n         msg \"leaving $2 unchanged\"\n     else\n-        msg \"cp $1 $2\"\n-        cp -f $1 $2\n+        run cp -f $1 $2\n         chmod u-w $2 # make copied artifact read-only\n     fi\n }\n@@ -57,8 +60,7 @@ move_if_changed() {\n     then\n         msg \"leaving $2 unchanged\"\n     else\n-        msg \"mv $1 $2\"\n-        mv -f $1 $2\n+        run mv -f $1 $2\n         chmod u-w $2 # make moved artifact read-only\n     fi\n }\n@@ -544,7 +546,7 @@ fi\n BOOL_OPTIONS=\"\"\n VAL_OPTIONS=\"\"\n \n-opt debug 0 \"debug mode\"\n+opt debug 0 \"debug mode; disables optimization unless \\`--enable-optimize\\` given\"\n opt valgrind 0 \"run tests with valgrind (memcheck by default)\"\n opt helgrind 0 \"run tests with helgrind instead of memcheck\"\n opt valgrind-rpass 1 \"run rpass-valgrind tests with valgrind\"\n@@ -733,6 +735,20 @@ then\n    probe CFG_JAVAC            javac\n fi\n \n+# the valgrind rpass tests will fail if you don't have a valgrind, but they're\n+# only disabled if you opt out.\n+if [ -z \"$CFG_VALGRIND\" ]\n+then\n+    # If the user has explicitly asked for valgrind tests, then fail\n+    if [ -n \"$CFG_ENABLE_VALGRIND\" ] && [ -n \"$CFG_ENABLE_VALGRIND_PROVIDED\" ]\n+    then\n+        err \"No valgrind present, but valgrind tests explicitly requested\"\n+    else\n+        CFG_DISABLE_VALGRIND_RPASS=1\n+        putvar CFG_DISABLE_VALGRIND_RPASS\n+    fi\n+fi\n+\n if [ ! -z \"$CFG_GDB\" ]\n then\n     # Store GDB's version\n@@ -844,7 +860,7 @@ then\n     CFG_OSX_GCC_VERSION=$(\"$CFG_GCC\" --version 2>&1 | grep \"Apple LLVM version\")\n     if [ $? -eq 0 ]\n     then\n-        step_msg \"on OS X 10.9, forcing use of clang\"\n+        step_msg \"on OS X >=10.9, forcing use of clang\"\n         CFG_ENABLE_CLANG=1\n     else\n         if [ $(\"$CFG_GCC\" --version 2>&1 | grep -c ' 4\\.[0-6]') -ne 0 ]; then"}, {"sha": "546b16c1b850b9619c39bfed16e22d5418b20b62", "filename": "mk/crates.mk", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -58,7 +58,7 @@ RUSTC_CRATES := rustc rustc_typeck rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_data_structures\n HOST_CRATES := syntax $(RUSTC_CRATES) rustdoc fmt_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n-TOOLS := compiletest rustdoc rustc rustbook\n+TOOLS := compiletest rustdoc rustc rustbook error-index-generator\n \n DEPS_core :=\n DEPS_libc := core\n@@ -107,10 +107,12 @@ TOOL_DEPS_compiletest := test getopts\n TOOL_DEPS_rustdoc := rustdoc\n TOOL_DEPS_rustc := rustc_driver\n TOOL_DEPS_rustbook := std rustdoc\n+TOOL_DEPS_error-index-generator := rustdoc syntax serialize\n TOOL_SOURCE_compiletest := $(S)src/compiletest/compiletest.rs\n TOOL_SOURCE_rustdoc := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustc := $(S)src/driver/driver.rs\n TOOL_SOURCE_rustbook := $(S)src/rustbook/main.rs\n+TOOL_SOURCE_error-index-generator := $(S)src/error-index-generator/main.rs\n \n ONLY_RLIB_core := 1\n ONLY_RLIB_libc := 1"}, {"sha": "75c6219c5f04f17ed9fa72b4ac2f01fe991acaff", "filename": "mk/dist.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -52,6 +52,7 @@ PKG_FILES := \\\n       doc                                      \\\n       driver                                   \\\n       etc                                      \\\n+      error-index-generator                    \\\n       $(foreach crate,$(CRATES),lib$(crate))   \\\n       libcollectionstest                       \\\n       libcoretest                              \\"}, {"sha": "39eb30a5b8dd56afbc57ab468ba7455958dccb65", "filename": "mk/docs.mk", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -71,9 +71,13 @@ RUSTBOOK_EXE = $(HBIN2_H_$(CFG_BUILD))/rustbook$(X_$(CFG_BUILD))\n # ./configure\n RUSTBOOK = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(RUSTBOOK_EXE)\n \n+# The error-index-generator executable...\n+ERR_IDX_GEN_EXE = $(HBIN2_H_$(CFG_BUILD))/error-index-generator$(X_$(CFG_BUILD))\n+ERR_IDX_GEN = $(RPATH_VAR2_T_$(CFG_BUILD)_H_$(CFG_BUILD)) $(ERR_IDX_GEN_EXE)\n+\n D := $(S)src/doc\n \n-DOC_TARGETS := trpl style\n+DOC_TARGETS := trpl style error-index\n COMPILER_DOC_TARGETS :=\n DOC_L10N_TARGETS :=\n \n@@ -288,3 +292,9 @@ doc/style/index.html: $(RUSTBOOK_EXE) $(wildcard $(S)/src/doc/style/*.md) | doc/\n \t@$(call E, rustbook: $@)\n \t$(Q)rm -rf doc/style\n \t$(Q)$(RUSTBOOK) build $(S)src/doc/style doc/style\n+\n+error-index: doc/error-index.html\n+\n+doc/error-index.html: $(ERR_IDX_GEN_EXE) | doc/\n+\t$(Q)$(call E, error-index-generator: $@)\n+\t$(Q)$(ERR_IDX_GEN)"}, {"sha": "738580cb5b5e0b3d6bf36749e78e73281b48cdcf", "filename": "mk/main.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -195,6 +195,7 @@ ifndef CFG_DISABLE_VALGRIND_RPASS\n   $(info cfg: valgrind-rpass command set to $(CFG_VALGRIND))\n   CFG_VALGRIND_RPASS :=$(CFG_VALGRIND)\n else\n+  $(info cfg: disabling valgrind run-pass tests)\n   CFG_VALGRIND_RPASS :=\n endif\n "}, {"sha": "1ae6a61c95a8c250e8cf397738f6a4052a370bfe", "filename": "mk/prepare.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/mk%2Fprepare.mk", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/mk%2Fprepare.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fprepare.mk?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -70,7 +70,7 @@ define PREPARE_MAN\n \t$(Q)$(PREPARE_MAN_CMD) $(PREPARE_SOURCE_MAN_DIR)/$(1) $(PREPARE_DEST_MAN_DIR)/$(1)\n endef\n \n-PREPARE_TOOLS = $(filter-out compiletest rustbook, $(TOOLS))\n+PREPARE_TOOLS = $(filter-out compiletest rustbook error-index-generator, $(TOOLS))\n \n \n # $(1) is tool"}, {"sha": "3ff7f3cc70adae0e3d01f7479c81cd1b9c58dd94", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -226,15 +226,15 @@ pub fn run_tests(config: &Config) {\n         }\n \n         // android debug-info test uses remote debugger\n-        // so, we test 1 task at once.\n+        // so, we test 1 thread at once.\n         // also trying to isolate problems with adb_run_wrapper.sh ilooping\n         env::set_var(\"RUST_TEST_THREADS\",\"1\");\n     }\n \n     match config.mode {\n         DebugInfoLldb => {\n             // Some older versions of LLDB seem to have problems with multiple\n-            // instances running in parallel, so only run one test task at a\n+            // instances running in parallel, so only run one test thread at a\n             // time.\n             env::set_var(\"RUST_TEST_THREADS\", \"1\");\n         }\n@@ -269,7 +269,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         run_ignored: config.run_ignored,\n         logfile: config.logfile.clone(),\n         run_tests: true,\n-        run_benchmarks: true,\n+        bench_benchmarks: true,\n         nocapture: env::var(\"RUST_TEST_NOCAPTURE\").is_ok(),\n         color: test::AutoColor,\n     }"}, {"sha": "fb157c65d957b2cd4ee727ec28dcd2b666a7e91f", "filename": "src/doc/complement-design-faq.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fcomplement-design-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fcomplement-design-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-design-faq.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -39,7 +39,7 @@ representation as a primitive. This allows using Rust `enum`s in FFI where C\n `enum`s are also used, for most use cases. The attribute can also be applied\n to `struct`s to get the same layout as a C struct would.\n \n-[repr]: reference.html#miscellaneous-attributes\n+[repr]: reference.html#ffi-attributes\n \n ## There is no GC\n \n@@ -96,7 +96,7 @@ code should need to run is a stack.\n possibility is covered by the `match`, adding further variants to the `enum`\n in the future will prompt a compilation failure, rather than runtime panic.\n Second, it makes cost explicit. In general, the only safe way to have a\n-non-exhaustive match would be to panic the task if nothing is matched, though\n+non-exhaustive match would be to panic the thread if nothing is matched, though\n it could fall through if the type of the `match` expression is `()`. This sort\n of hidden cost and special casing is against the language's philosophy. It's\n easy to ignore certain cases by using the `_` wildcard:"}, {"sha": "e51e7d414a89161c63bb8b0046c216a477df3c3a", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -62,15 +62,15 @@ Data values in the language can only be constructed through a fixed set of initi\n * There is no global inter-crate namespace; all name management occurs within a crate.\n  * Using another crate binds the root of _its_ namespace into the user's namespace.\n \n-## Why is panic unwinding non-recoverable within a task? Why not try to \"catch exceptions\"?\n+## Why is panic unwinding non-recoverable within a thread? Why not try to \"catch exceptions\"?\n \n-In short, because too few guarantees could be made about the dynamic environment of the catch block, as well as invariants holding in the unwound heap, to be able to safely resume; we believe that other methods of signalling and logging errors are more appropriate, with tasks playing the role of a \"hard\" isolation boundary between separate heaps.\n+In short, because too few guarantees could be made about the dynamic environment of the catch block, as well as invariants holding in the unwound heap, to be able to safely resume; we believe that other methods of signalling and logging errors are more appropriate, with threads playing the role of a \"hard\" isolation boundary between separate heaps.\n \n Rust provides, instead, three predictable and well-defined options for handling any combination of the three main categories of \"catch\" logic:\n \n * Failure _logging_ is done by the integrated logging subsystem.\n-* _Recovery_ after a panic is done by trapping a task panic from _outside_\n-  the task, where other tasks are known to be unaffected.\n+* _Recovery_ after a panic is done by trapping a thread panic from _outside_\n+  the thread, where other threads are known to be unaffected.\n * _Cleanup_ of resources is done by RAII-style objects with destructors.\n \n Cleanup through RAII-style destructors is more likely to work than in catch blocks anyways, since it will be better tested (part of the non-error control paths, so executed all the time).\n@@ -91,8 +91,8 @@ We don't know if there's an obvious, easy, efficient, stock-textbook way of supp\n \n There's a lot of debate on this topic; it's easy to find a proponent of default-sync or default-async communication, and there are good reasons for either. Our choice rests on the following arguments:\n \n-* Part of the point of isolating tasks is to decouple tasks from one another, such that assumptions in one task do not cause undue constraints (or bugs, if violated!) in another. Temporal coupling is as real as any other kind; async-by-default relaxes the default case to only _causal_ coupling.\n-* Default-async supports buffering and batching communication, reducing the frequency and severity of task-switching and inter-task / inter-domain synchronization.\n+* Part of the point of isolating threads is to decouple threads from one another, such that assumptions in one thread do not cause undue constraints (or bugs, if violated!) in another. Temporal coupling is as real as any other kind; async-by-default relaxes the default case to only _causal_ coupling.\n+* Default-async supports buffering and batching communication, reducing the frequency and severity of thread-switching and inter-thread / inter-domain synchronization.\n * Default-async with transmittable channels is the lowest-level building block on which more-complex synchronization topologies and strategies can be built; it is not clear to us that the majority of cases fit the 2-party full-synchronization pattern rather than some more complex multi-party or multi-stage scenario. We did not want to force all programs to pay for wiring the former assumption into all communications.\n \n ## Why are channels half-duplex (one-way)?\n@@ -109,7 +109,7 @@ This does mean that indexed access to a Unicode codepoint inside a `str` value i\n * Most \"character oriented\" operations on text only work under very restricted language assumptions sets such as \"ASCII-range codepoints only\". Outside ASCII-range, you tend to have to use a complex (non-constant-time) algorithm for determining linguistic-unit (glyph, word, paragraph) boundaries anyways. We recommend using an \"honest\" linguistically-aware, Unicode-approved algorithm.\n * The `char` type is UCS4. If you honestly need to do a codepoint-at-a-time algorithm, it's trivial to write a `type wstr = [char]`, and unpack a `str` into it in a single pass, then work with the `wstr`. In other words: the fact that the language is not \"decoding to UCS4 by default\" shouldn't stop you from decoding (or re-encoding any other way) if you need to work with that encoding.\n \n-## Why are strings, vectors etc. built-in types rather than (say) special kinds of trait/impl?\n+## Why are `str`s, slices, arrays etc. built-in types rather than (say) special kinds of trait/impl?\n \n In each case there is one or more operator, literal constructor, overloaded use or integration with a built-in control structure that makes us think it would be awkward to phrase the type in terms of more-general type constructors. Same as, say, with numbers! But this is partly an aesthetic call, and we'd be willing to look at a worked-out proposal for eliminating or rephrasing these special cases.\n "}, {"sha": "4897b27dec35d0237dced6a348330747432715de", "filename": "src/doc/grammar.md", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -176,9 +176,15 @@ excluded from the `ident` rule.\n \n ```antlr\n lit_suffix : ident;\n-literal : [ string_lit | char_lit | byte_string_lit | byte_lit | num_lit ] lit_suffix ?;\n+literal : [ string_lit | char_lit | byte_string_lit | byte_lit | num_lit | bool_lit ] lit_suffix ?;\n ```\n \n+The optional `lit_suffix` production is only used for certain numeric literals,\n+but is reserved for future extension. That is, the above gives the lexical\n+grammar, but a Rust parser will reject everything but the 12 special cases\n+mentioned in [Number literals](reference.html#number-literals) in the\n+reference.\n+\n #### Character and string literals\n \n ```antlr\n@@ -238,7 +244,9 @@ dec_lit : [ dec_digit | '_' ] + ;\n \n #### Boolean literals\n \n-**FIXME:** write grammar\n+```antlr\n+bool_lit : [ \"true\" | \"false\" ] ;\n+```\n \n The two values of the boolean type are written `true` and `false`.\n \n@@ -297,7 +305,7 @@ transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n \n ```antlr\n item : mod_item | fn_item | type_item | struct_item | enum_item\n-     | static_item | trait_item | impl_item | extern_block ;\n+     | const_item | static_item | trait_item | impl_item | extern_block ;\n ```\n \n ### Type Parameters\n@@ -321,7 +329,7 @@ view_item : extern_crate_decl | use_decl ;\n \n ```antlr\n extern_crate_decl : \"extern\" \"crate\" crate_name\n-crate_name: ident | ( string_lit as ident )\n+crate_name: ident | ( ident \"as\" ident )\n ```\n \n ##### Use declarations\n@@ -369,6 +377,10 @@ path_item : ident | \"mod\" ;\n \n **FIXME:** grammar?\n \n+### Enumerations\n+\n+**FIXME:** grammar?\n+\n ### Constant items\n \n ```antlr\n@@ -777,8 +789,8 @@ bound := path | lifetime\n \n ### Boxes\n \n-## Tasks\n+## Threads\n \n-### Communication between tasks\n+### Communication between threads\n \n-### Task lifecycle\n+### Thread lifecycle"}, {"sha": "16fdcfa301392532ddf1444044adf1f8f7417bb8", "filename": "src/doc/reference.md", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -130,11 +130,6 @@ of tokens, that immediately and directly denotes the value it evaluates to,\n rather than referring to it by name or some other evaluation rule. A literal is\n a form of constant expression, so is evaluated (primarily) at compile time.\n \n-The optional suffix is only used for certain numeric literals, but is\n-reserved for future extension, that is, the above gives the lexical\n-grammar, but a Rust parser will reject everything but the 12 special\n-cases mentioned in [Number literals](#number-literals) below.\n-\n #### Examples\n \n ##### Characters and strings\n@@ -757,11 +752,10 @@ provided in the `extern_crate_decl`.\n The external crate is resolved to a specific `soname` at compile time, and a\n runtime linkage requirement to that `soname` is passed to the linker for\n loading at runtime. The `soname` is resolved at compile time by scanning the\n-compiler's library path and matching the optional `crateid` provided as a\n-string literal against the `crateid` attributes that were declared on the\n-external crate when it was compiled. If no `crateid` is provided, a default\n-`name` attribute is assumed, equal to the `ident` given in the\n-`extern_crate_decl`.\n+compiler's library path and matching the optional `crateid` provided against\n+the `crateid` attributes that were declared on the external crate when it was\n+compiled. If no `crateid` is provided, a default `name` attribute is assumed,\n+equal to the `ident` given in the `extern_crate_decl`.\n \n Three examples of `extern crate` declarations:\n \n@@ -1562,8 +1556,7 @@ warnings are generated, or otherwise \"you used a private item of another module\n and weren't allowed to.\"\n \n By default, everything in Rust is *private*, with one exception. Enum variants\n-in a `pub` enum are also public by default. You are allowed to alter this\n-default visibility with the `priv` keyword. When an item is declared as `pub`,\n+in a `pub` enum are also public by default. When an item is declared as `pub`,\n it can be thought of as being accessible to the outside world. For example:\n \n ```\n@@ -1873,13 +1866,12 @@ macro scope.\n   lower to the target's SIMD instructions, if any; the `simd` feature gate\n   is necessary to use this attribute.\n - `static_assert` - on statics whose type is `bool`, terminates compilation\n-  with an error if it is not initialized to `true`.\n-- `unsafe_destructor` - allow implementations of the \"drop\" language item\n-  where the type it is implemented for does not implement the \"send\" language\n-  item; the `unsafe_destructor` feature gate is needed to use this attribute\n+  with an error if it is not initialized to `true`. To use this, the `static_assert`\n+  feature gate must be enabled.\n - `unsafe_no_drop_flag` - on structs, remove the flag that prevents\n   destructors from being run twice. Destructors might be run multiple times on\n-  the same object with this attribute.\n+  the same object with this attribute. To use this, the `unsafe_no_drop_flag` feature\n+  gate must be enabled.\n - `doc` - Doc comments such as `/// foo` are equivalent to `#[doc = \"foo\"]`.\n - `rustc_on_unimplemented` - Write a custom note to be shown along with the error\n    when the trait is found to be unimplemented on a type.\n@@ -2036,7 +2028,7 @@ makes it possible to declare these operations. For example, the `str` module\n in the Rust standard library defines the string equality function:\n \n ```{.ignore}\n-#[lang=\"str_eq\"]\n+#[lang = \"str_eq\"]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n     // details elided\n }\n@@ -2050,21 +2042,21 @@ A complete list of the built-in language items will be added in the future.\n \n ### Inline attributes\n \n-The inline attribute is used to suggest to the compiler to perform an inline\n-expansion and place a copy of the function or static in the caller rather than\n-generating code to call the function or access the static where it is defined.\n+The inline attribute suggests that the compiler should place a copy of\n+the function or static in the caller, rather than generating code to\n+call the function or access the static where it is defined.\n \n The compiler automatically inlines functions based on internal heuristics.\n-Incorrectly inlining functions can actually making the program slower, so it\n+Incorrectly inlining functions can actually make the program slower, so it\n should be used with care.\n \n Immutable statics are always considered inlineable unless marked with\n `#[inline(never)]`. It is undefined whether two different inlineable statics\n have the same memory address. In other words, the compiler is free to collapse\n duplicate inlineable statics together.\n \n-`#[inline]` and `#[inline(always)]` always causes the function to be serialized\n-into crate metadata to allow cross-crate inlining.\n+`#[inline]` and `#[inline(always)]` always cause the function to be serialized\n+into the crate metadata to allow cross-crate inlining.\n \n There are three different types of inline attributes:\n \n@@ -2431,11 +2423,18 @@ Tuples are written by enclosing zero or more comma-separated expressions in\n parentheses. They are used to create [tuple-typed](#tuple-types) values.\n \n ```{.tuple}\n-(0,);\n (0.0, 4.5);\n (\"a\", 4usize, true);\n ```\n \n+You can disambiguate a single-element tuple from a value in parentheses with a\n+comma:\n+\n+```\n+(0,); // single-element tuple\n+(0); // zero in parentheses\n+```\n+\n ### Unit expressions\n \n The expression `()` denotes the _unit value_, the only value of the type with\n@@ -3636,7 +3635,7 @@ that have since been removed):\n * ML Kit, Cyclone: region based memory management\n * Haskell (GHC): typeclasses, type families\n * Newsqueak, Alef, Limbo: channels, concurrency\n-* Erlang: message passing, task failure, ~~linked task failure~~,\n+* Erlang: message passing, thread failure, ~~linked thread failure~~,\n   ~~lightweight concurrency~~\n * Swift: optional bindings\n * Scheme: hygienic macros"}, {"sha": "9b8a00d73665b6f4fd0f983a1e56763fef80fa23", "filename": "src/doc/style/errors/handling.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fhandling.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -1,7 +1,7 @@\n % Handling errors\n \n-### Use task isolation to cope with failure. [FIXME]\n+### Use thread isolation to cope with failure. [FIXME]\n \n-> **[FIXME]** Explain how to isolate tasks and detect task failure for recovery.\n+> **[FIXME]** Explain how to isolate threads and detect thread failure for recovery.\n \n ### Consuming `Result` [FIXME]"}, {"sha": "24cd5957f8aac079c27a3e408305c63ca73f2f2b", "filename": "src/doc/style/errors/signaling.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ferrors%2Fsignaling.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -11,13 +11,13 @@ Errors fall into one of three categories:\n The basic principle of the convention is that:\n \n * Catastrophic errors and programming errors (bugs) can and should only be\n-recovered at a *coarse grain*, i.e. a task boundary.\n+recovered at a *coarse grain*, i.e. a thread boundary.\n * Obstructions preventing an operation should be reported at a maximally *fine\n grain* -- to the immediate invoker of the operation.\n \n ## Catastrophic errors\n \n-An error is _catastrophic_ if there is no meaningful way for the current task to\n+An error is _catastrophic_ if there is no meaningful way for the current thread to\n continue after the error occurs.\n \n Catastrophic errors are _extremely_ rare, especially outside of `libstd`.\n@@ -28,7 +28,7 @@ Catastrophic errors are _extremely_ rare, especially outside of `libstd`.\n \n For errors like stack overflow, Rust currently aborts the process, but\n could in principle panic, which (in the best case) would allow\n-reporting and recovery from a supervisory task.\n+reporting and recovery from a supervisory thread.\n \n ## Contract violations\n \n@@ -44,7 +44,7 @@ existing borrows have been relinquished.\n \n A contract violation is always a bug, and for bugs we follow the Erlang\n philosophy of \"let it crash\": we assume that software *will* have bugs, and we\n-design coarse-grained task boundaries to report, and perhaps recover, from these\n+design coarse-grained thread boundaries to report, and perhaps recover, from these\n bugs.\n \n ### Contract design"}, {"sha": "8f721a9767672fa5439a9668dfb619ab36f470ac", "filename": "src/doc/style/ownership/builders.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fbuilders.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -23,7 +23,7 @@ If `T` is such a data structure, consider introducing a `T` _builder_:\n 4. The builder should provide one or more \"_terminal_\" methods for actually building a `T`.\n \n The builder pattern is especially appropriate when building a `T` involves side\n-effects, such as spawning a task or launching a process.\n+effects, such as spawning a thread or launching a process.\n \n In Rust, there are two variants of the builder pattern, differing in the\n treatment of ownership, as described below.\n@@ -115,24 +115,24 @@ Sometimes builders must transfer ownership when constructing the final type\n `T`, meaning that the terminal methods must take `self` rather than `&self`:\n \n ```rust\n-// A simplified excerpt from std::task::TaskBuilder\n+// A simplified excerpt from std::thread::Builder\n \n-impl TaskBuilder {\n-    /// Name the task-to-be. Currently the name is used for identification\n+impl ThreadBuilder {\n+    /// Name the thread-to-be. Currently the name is used for identification\n     /// only in failure messages.\n-    pub fn named(mut self, name: String) -> TaskBuilder {\n+    pub fn named(mut self, name: String) -> ThreadBuilder {\n         self.name = Some(name);\n         self\n     }\n \n-    /// Redirect task-local stdout.\n-    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder {\n+    /// Redirect thread-local stdout.\n+    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> ThreadBuilder {\n         self.stdout = Some(stdout);\n         //   ^~~~~~ this is owned and cannot be cloned/re-used\n         self\n     }\n \n-    /// Creates and executes a new child task.\n+    /// Creates and executes a new child thread.\n     pub fn spawn(self, f: proc():Send) {\n         // consume self\n         ...\n@@ -141,7 +141,7 @@ impl TaskBuilder {\n ```\n \n Here, the `stdout` configuration involves passing ownership of a `Writer`,\n-which must be transferred to the task upon construction (in `spawn`).\n+which must be transferred to the thread upon construction (in `spawn`).\n \n When the terminal methods of the builder require ownership, there is a basic tradeoff:\n \n@@ -158,17 +158,17 @@ builder methods for a consuming builder should take and returned an owned\n \n ```rust\n // One-liners\n-TaskBuilder::new().named(\"my_task\").spawn(proc() { ... });\n+ThreadBuilder::new().named(\"my_thread\").spawn(proc() { ... });\n \n // Complex configuration\n-let mut task = TaskBuilder::new();\n-task = task.named(\"my_task_2\"); // must re-assign to retain ownership\n+let mut thread = ThreadBuilder::new();\n+thread = thread.named(\"my_thread_2\"); // must re-assign to retain ownership\n \n if reroute {\n-    task = task.stdout(mywriter);\n+    thread = thread.stdout(mywriter);\n }\n \n-task.spawn(proc() { ... });\n+thread.spawn(proc() { ... });\n ```\n \n One-liners work as before, because ownership is threaded through each of the"}, {"sha": "1cfcd78d20da8346f052351ae285714e6fcf0e9f", "filename": "src/doc/style/ownership/destructors.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fownership%2Fdestructors.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -8,7 +8,7 @@ go out of scope.\n \n ### Destructors should not fail. [FIXME: needs RFC]\n \n-Destructors are executed on task failure, and in that context a failing\n+Destructors are executed on thread failure, and in that context a failing\n destructor causes the program to abort.\n \n Instead of failing in a destructor, provide a separate method for checking for"}, {"sha": "b2d2d9ab6b4d68e1a776797112ea3988b38b435e", "filename": "src/doc/style/style/comments.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fcomments.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -5,15 +5,15 @@\n Use line comments:\n \n ``` rust\n-// Wait for the main task to return, and set the process error code\n+// Wait for the main thread to return, and set the process error code\n // appropriately.\n ```\n \n Instead of:\n \n ``` rust\n /*\n- * Wait for the main task to return, and set the process error code\n+ * Wait for the main thread to return, and set the process error code\n  * appropriately.\n  */\n ```\n@@ -55,7 +55,7 @@ For example:\n /// Sets up a default runtime configuration, given compiler-supplied arguments.\n ///\n /// This function will block until the entire pool of M:N schedulers has\n-/// exited. This function also requires a local task to be available.\n+/// exited. This function also requires a local thread to be available.\n ///\n /// # Arguments\n ///\n@@ -64,7 +64,7 @@ For example:\n /// * `main` - The initial procedure to run inside of the M:N scheduling pool.\n ///            Once this procedure exits, the scheduling pool will begin to shut\n ///            down. The entire pool (and this function) will only return once\n-///            all child tasks have finished executing.\n+///            all child threads have finished executing.\n ///\n /// # Return value\n ///"}, {"sha": "dfed4f9f75a58906c78068566077aba180f30cd3", "filename": "src/doc/style/style/naming/containers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Fstyle%2Fnaming%2Fcontainers.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -5,7 +5,7 @@ they enclose.  Accessor methods often have variants to access the data\n by value, by reference, and by mutable reference.\n \n In general, the `get` family of methods is used to access contained\n-data without any risk of task failure; they return `Option` as\n+data without any risk of thread failure; they return `Option` as\n appropriate. This name is chosen rather than names like `find` or\n `lookup` because it is appropriate for a wider range of container types.\n "}, {"sha": "89f0db8dc56f343f2f05d5c3018a7f09397921e4", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -40,6 +40,11 @@ want to dive in with a project, or \u2018Syntax and Semantics\u2019 if you prefer to\n start small, and learn a single concept thoroughly before moving onto the next.\n Copious cross-linking connects these parts together.\n \n+### Contributing\n+\n+The source files from which this book is generated can be found on Github:\n+[github.com/rust-lang/rust/tree/master/src/doc/trpl](https://github.com/rust-lang/rust/tree/master/src/doc/trpl)\n+\n ## A brief introduction to Rust\n \n Is Rust a language you might be interested in? Let\u2019s examine a few small code\n@@ -190,5 +195,5 @@ fn main() {\n We created an inner scope with an additional set of curly braces. `y` will go out of\n scope before we call `push()`, and so we\u2019re all good.\n \n-This concept of ownership isn\u2019t just good for preventing danging pointers, but an\n+This concept of ownership isn\u2019t just good for preventing dangling pointers, but an\n entire set of related problems, like iterator invalidation, concurrency, and more."}, {"sha": "de7ded76280f6f103350a2105f2492d86eec7700", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -5,6 +5,7 @@\n     * [Hello, world!](hello-world.md)\n     * [Hello, Cargo!](hello-cargo.md)\n * [Learn Rust](learn-rust.md)\n+    * [Guessing Game](guessing-game.md)\n * [Effective Rust](effective-rust.md)\n     * [The Stack and the Heap](the-stack-and-the-heap.md)\n     * [Testing](testing.md)\n@@ -26,7 +27,6 @@\n     * [References and Borrowing](references-and-borrowing.md)\n     * [Lifetimes](lifetimes.md)\n     * [Mutability](mutability.md)\n-    * [Move semantics](move-semantics.md)\n     * [Enums](enums.md)\n     * [Match](match.md)\n     * [Structs](structs.md)\n@@ -64,5 +64,6 @@\n     * [Benchmark Tests](benchmark-tests.md)\n     * [Box Syntax and Patterns](box-syntax-and-patterns.md)\n     * [Slice Patterns](slice-patterns.md)\n+    * [Associated Constants](associated-constants.md)\n * [Glossary](glossary.md)\n * [Academic Research](academic-research.md)"}, {"sha": "1c097be6d68a682ea7da94a06ad2f2e28274de37", "filename": "src/doc/trpl/associated-constants.md", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fassociated-constants.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fassociated-constants.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fassociated-constants.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,79 @@\n+% Associated Constants\n+\n+With the `associated_consts` feature, you can define constants like this:\n+\n+```rust\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const ID: i32;\n+}\n+\n+impl Foo for i32 {\n+    const ID: i32 = 1;\n+}\n+\n+fn main() {\n+    assert_eq!(1, i32::ID);\n+}\n+```\n+\n+Any implementor of `Foo` will have to define `ID`. Without the definition:\n+\n+```rust,ignore\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const ID: i32;\n+}\n+\n+impl Foo for i32 {\n+}\n+```\n+\n+gives\n+\n+```text\n+error: not all trait items implemented, missing: `ID` [E0046]\n+     impl Foo for i32 {\n+     }\n+```\n+\n+A default value can be implemented as well:\n+\n+```rust\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const ID: i32 = 1;\n+}\n+\n+impl Foo for i32 {\n+}\n+\n+impl Foo for i64 {\n+    const ID: i32 = 5;\n+}\n+\n+fn main() {\n+    assert_eq!(1, i32::ID);\n+    assert_eq!(5, i64::ID);\n+}\n+```\n+\n+As you can see, when implementing `Foo`, you can leave it unimplemented, as\n+with `i32`. It will then use the default value. But, as in `i64`, we can also\n+add our own definition.\n+\n+Associated constants don\u2019t have to be associated with a trait. An `impl` block\n+for a `struct` works fine too:\n+\n+```rust\n+#![feature(associated_consts)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    pub const FOO: u32 = 3;\n+}\n+```"}, {"sha": "63496471b5a0141b2b900fe79e4ffa038d6488bb", "filename": "src/doc/trpl/attributes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fattributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fattributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fattributes.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -67,4 +67,4 @@ Rust attributes are used for a number of different things. There is a full list\n of attributes [in the reference][reference]. Currently, you are not allowed to\n create your own attributes, the Rust compiler defines them.\n \n-[reference]: reference.html#attributes\n+[reference]: ../reference.html#attributes"}, {"sha": "dbacd405065d421ab090c3214f1e9aca8dcb613b", "filename": "src/doc/trpl/casting-between-types.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcasting-between-types.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -43,7 +43,7 @@ what it does is very simple, but very scary. It tells Rust to treat a value of\n one type as though it were another type. It does this regardless of the\n typechecking system, and just completely trusts you.\n \n-[intrinsic]: intrinsics.html\n+[intrinsics]: intrinsics.html\n \n In our previous example, we know that an array of four `u8`s represents a `u32`\n properly, and so we want to do the cast. Using `transmute` instead of `as`,"}, {"sha": "d6590e956a8416a69e29ca9eefc3b77f0414432b", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -6,7 +6,7 @@ and more cores, yet many programmers aren't prepared to fully utilize them.\n \n Rust's memory safety features also apply to its concurrency story too. Even\n concurrent Rust programs must be memory safe, having no data races. Rust's type\n-system is up to the task, and gives you powerful ways to reason about\n+system is up to the thread, and gives you powerful ways to reason about\n concurrent code at compile time.\n \n Before we talk about the concurrency features that come with Rust, it's important\n@@ -116,7 +116,7 @@ use std::thread;\n fn main() {\n     let mut data = vec![1u32, 2, 3];\n \n-    for i in 0..2 {\n+    for i in 0..3 {\n         thread::spawn(move || {\n             data[i] += 1;\n         });\n@@ -154,7 +154,7 @@ use std::sync::Mutex;\n fn main() {\n     let mut data = Mutex::new(vec![1u32, 2, 3]);\n \n-    for i in 0..2 {\n+    for i in 0..3 {\n         let data = data.lock().unwrap();\n         thread::spawn(move || {\n             data[i] += 1;\n@@ -196,7 +196,7 @@ use std::thread;\n fn main() {\n     let data = Arc::new(Mutex::new(vec![1u32, 2, 3]));\n \n-    for i in 0..2 {\n+    for i in 0..3 {\n         let data = data.clone();\n         thread::spawn(move || {\n             let mut data = data.lock().unwrap();\n@@ -217,7 +217,7 @@ thread more closely:\n # use std::thread;\n # fn main() {\n #     let data = Arc::new(Mutex::new(vec![1u32, 2, 3]));\n-#     for i in 0..2 {\n+#     for i in 0..3 {\n #         let data = data.clone();\n thread::spawn(move || {\n     let mut data = data.lock().unwrap();"}, {"sha": "be0c87319b37cb22c2cbac081bbcdeff2a90095f", "filename": "src/doc/trpl/const-and-static.md", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fconst-and-static.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fconst-and-static.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconst-and-static.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -19,18 +19,16 @@ this reason.\n # `static`\n \n Rust provides a \u2018global variable\u2019 sort of facility in static items. They\u2019re\n-similar to [constants][const], but static items aren\u2019t inlined upon use. This\n-means that there is only one instance for each value, and it\u2019s at a fixed\n-location in memory.\n+similar to constants, but static items aren\u2019t inlined upon use. This means that\n+there is only one instance for each value, and it\u2019s at a fixed location in\n+memory.\n \n Here\u2019s an example:\n \n ```rust\n static N: i32 = 5;\n ```\n \n-[const]: const.html\n-\n Unlike [`let`][let] bindings, you must annotate the type of a `static`.\n \n [let]: variable-bindings.html"}, {"sha": "95b39a660636ad39b55d7d40d0b57c2b15d7103e", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -214,7 +214,7 @@ we can use the `unwrap()` method:\n io::stdin().read_line(&mut buffer).unwrap();\n ```\n \n-`unwrap()` will `panic!` if the `Option` is `None`. This basically says \"Give\n+`unwrap()` will `panic!` if the `Result` is `Err`. This basically says \"Give\n me the value, and if something goes wrong, just crash.\" This is less reliable\n than matching the error and attempting to recover, but is also significantly\n shorter. Sometimes, just crashing is appropriate.\n@@ -252,7 +252,7 @@ struct Info {\n }\n \n fn write_info(info: &Info) -> io::Result<()> {\n-    let mut file = File::open(\"my_best_friends.txt\").unwrap();\n+    let mut file = File::create(\"my_best_friends.txt\").unwrap();\n \n     if let Err(e) = writeln!(&mut file, \"name: {}\", info.name) {\n         return Err(e)\n@@ -282,7 +282,7 @@ struct Info {\n }\n \n fn write_info(info: &Info) -> io::Result<()> {\n-    let mut file = try!(File::open(\"my_best_friends.txt\"));\n+    let mut file = try!(File::create(\"my_best_friends.txt\"));\n \n     try!(writeln!(&mut file, \"name: {}\", info.name));\n     try!(writeln!(&mut file, \"age: {}\", info.age));"}, {"sha": "50767b603c46c3d0ff6b1af8b2e11e481604ef06", "filename": "src/doc/trpl/guessing-game.md", "status": "added", "additions": 1003, "deletions": 0, "changes": 1003, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,1003 @@\n+% Guessing Game\n+\n+For our first project, we\u2019ll implement a classic beginner programming problem:\n+the guessing game. Here\u2019s how it works: Our program will generate a random\n+integer between one and a hundred. It will then prompt us to enter a guess.\n+Upon entering our guess, it will tell us if we\u2019re too low or too high. Once we\n+guess correctly, it will congratulate us. Sounds good?\n+\n+# Set up\n+\n+Let\u2019s set up a new project. Go to your projects directory. Remember how we had\n+to create our directory structure and a `Cargo.toml` for `hello_world`? Cargo\n+has a command that does that for us. Let\u2019s give it a shot:\n+\n+```bash\n+$ cd ~/projects\n+$ cargo new guessing_game --bin\n+$ cd guessing_game\n+```\n+\n+We pass the name of our project to `cargo new`, and then the `--bin` flag,\n+since we\u2019re making a binary, rather than a library.\n+\n+Check out the generated `Cargo.toml`:\n+\n+```toml\n+[package]\n+\n+name = \"guessing_game\"\n+version = \"0.0.1\"\n+authors = [\"Your Name <you@example.com>\"]\n+```\n+\n+Cargo gets this information from your environment. If it\u2019s not correct, go ahead\n+and fix that.\n+\n+Finally, Cargo generated a \u2018Hello, world!\u2019 for us. Check out `src/main.rs`:\n+\n+```rust\n+fn main() {\n+    println!(\"Hello, world!\")\n+}\n+```\n+\n+Let\u2019s try compiling what Cargo gave us:\n+\n+```{bash}\n+$ cargo build\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+```\n+\n+Excellent! Open up your `src/main.rs` again. We\u2019ll be writing all of\n+our code in this file.\n+\n+Before we move on, let me show you one more Cargo command: `run`. `cargo run`\n+is kind of like `cargo build`, but it also then runs the produced executable.\n+Try it out:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/debug/guessing_game`\n+Hello, world!\n+```\n+\n+Great! The `run` command comes in handy when you need to rapidly iterate on a\n+project. Our game is just such a project, we need to quickly test each\n+iteration before moving on to the next one.\n+\n+# Processing a Guess\n+\n+Let\u2019s get to it! The first thing we need to do for our guessing game is\n+allow our player to input a guess. Put this in your `src/main.rs`:\n+\n+```rust,no_run\n+use std::io;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    println!(\"Please input your guess.\");\n+\n+    let mut guess = String::new();\n+\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"Failed to read line\");\n+\n+    println!(\"You guessed: {}\", guess);\n+}\n+```\n+\n+There\u2019s a lot here! Let\u2019s go over it, bit by bit.\n+\n+```rust,ignore\n+use std::io;\n+```\n+\n+We\u2019ll need to take user input, and then print the result as output. As such, we\n+need the `io` library from the standard library. Rust only imports a few things\n+into every program, [the \u2018prelude\u2019][prelude]. If it\u2019s not in the prelude,\n+you\u2019ll have to `use` it directly.\n+\n+[prelude]: ../std/prelude/index.html\n+\n+```rust,ignore\n+fn main() {\n+```\n+\n+As you\u2019ve seen before, the `main()` function is the entry point into your\n+program. The `fn` syntax declares a new function, the `()`s indicate that\n+there are no arguments, and `{` starts the body of the function. Because\n+we didn\u2019t include a return type, it\u2019s assumed to be `()`, an empty\n+[tuple][tuples].\n+\n+[tuples]: primitive-types.html#tuples\n+\n+```rust,ignore\n+    println!(\"Guess the number!\");\n+\n+    println!(\"Please input your guess.\");\n+```\n+\n+We previously learned that `println!()` is a [macro][macros] that\n+prints a [string][strings] to the screen.\n+\n+[macros]: macros.html\n+[strings]: strings.html\n+\n+```rust,ignore\n+    let mut guess = String::new();\n+```\n+\n+Now we\u2019re getting interesting! There\u2019s a lot going on in this little line.\n+The first thing to notice is that this is a [let statement][let], which is\n+used to create \u2018variable bindings\u2019. They take this form:\n+\n+```rust,ignore\n+let foo = bar;\n+```\n+\n+[let]: variable-bindings.html\n+\n+This will create a new binding named `foo`, and bind it to the value `bar`. In\n+many languages, this is called a \u2018variable\u2019, but Rust\u2019s variable bindings have\n+a few tricks up their sleeves.\n+\n+For example, they\u2019re [immutable][immutable] by default. That\u2019s why our example\n+uses `mut`: it makes a binding mutable, rather than immutable. `let` doesn\u2019t\n+take a name on the left hand side, it actually accepts a\n+\u2018[pattern][patterns]\u2019. We\u2019ll use patterns more later. It\u2019s easy enough\n+to use for now:\n+\n+```\n+let foo = 5; // immutable.\n+let mut bar = 5; // mutable\n+```\n+\n+[immutable]: mutability.html\n+[patterns]: patterns.html\n+\n+Oh, and `//` will start a comment, until the end of the line. Rust ignores\n+everything in [comments][comments].\n+\n+[comments]: comments.html\n+\n+So now we know that `let mut guess` will introduce a mutable binding named\n+`guess`, but we have to look at the other side of the `=` for what it\u2019s\n+bound to: `String::new()`.\n+\n+`String` is a string type, provided by the standard library. A\n+[`String`][string] is a growable, UTF-8 encoded bit of text.\n+\n+[string]: ../std/string/struct.String.html\n+\n+The `::new()` syntax uses `::` because this is an \u2018associated function\u2019 of\n+a particular type. That is to say, it\u2019s associated with `String` itself,\n+rather than a particular instance of a `String`. Some languages call this a\n+\u2018static method\u2019.\n+\n+This function is named `new()`, because it creates a new, empty `String`.\n+You\u2019ll find a `new()` function on many types, as it\u2019s a common name for making\n+a new value of some kind.\n+\n+Let\u2019s move forward:\n+\n+```rust,ignore\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"Failed to read line\");\n+```\n+\n+That\u2019s a lot more! Let\u2019s go bit-by-bit. The first line has two parts. Here\u2019s\n+the first:\n+\n+```rust,ignore\n+io::stdin()\n+```\n+\n+Remember how we `use`d `std::io` on the first line of the program? We\u2019re now\n+calling an associated function on it. If we didn\u2019t `use std::io`, we could\n+have written this line as `std::io::stdin()`.\n+\n+This particular function returns a handle to the standard input for your\n+terminal. More specifically, a [std::io::Stdin][iostdin].\n+\n+[iostdin]: ../std/io/struct.Stdin.html\n+\n+The next part will use this handle to get input from the user:\n+\n+```rust,ignore\n+.read_line(&mut guess)\n+```\n+\n+Here, we call the [`read_line()`][read_line] method on our handle.\n+[Method][method]s are like associated functions, but are only available on a\n+particular instance of a type, rather than the type itself. We\u2019re also passing\n+one argument to `read_line()`: `&mut guess`.\n+\n+[read_line]: ../std/io/struct.Stdin.html#method.read_line\n+[method]: methods.html\n+\n+Remember how we bound `guess` above? We said it was mutable. However,\n+`read_line` doesn\u2019t take a `String` as an argument: it takes a `&mut String`.\n+Rust has a feature called \u2018[references][references]\u2019, which allows you to have\n+multiple references to one piece of data, which can reduce copying. References\n+are a complex feature, as one of Rust\u2019s major selling points is how safe and\n+easy it is to use references. We don\u2019t need to know a lot of those details to\n+finish our program right now, though. For now, all we need to know is that\n+like `let` bindings, references are immutable by default. Hence, we need to\n+write `&mut guess`, rather than `&guess`.\n+\n+Why does `read_line()` take a mutable reference to a string? Its job is\n+to take what the user types into standard input, and place that into a\n+string. So it takes that string as an argument, and in order to add\n+the input, it needs to be mutable.\n+\n+[references]: references-and-borrowing.html\n+\n+But we\u2019re not quite done with this line of code, though. While it\u2019s\n+a single line of text, it\u2019s only the first part of the single logical line of\n+code:\n+\n+```rust,ignore\n+        .ok()\n+        .expect(\"Failed to read line\");\n+```\n+\n+When you call a method with the `.foo()` syntax, you may introduce a newline\n+and other whitespace. This helps you split up long lines. We _could_ have\n+done:\n+\n+```rust,ignore\n+    io::stdin().read_line(&mut guess).ok().expect(\"failed to read line\");\n+```\n+\n+But that gets hard to read. So we\u2019ve split it up, three lines for three\n+method calls. We already talked about `read_line()`, but what about `ok()`\n+and `expect()`? Well, we already mentioned that `read_line()` puts what\n+the user types into the `&mut String` we pass it. But it also returns\n+a value: in this case, an [`io::Result`][ioresult]. Rust has a number of\n+types named `Result` in its standard library: a generic [`Result`][result],\n+and then specific versions for sub-libraries, like `io::Result`.\n+\n+[ioresult]: ../std/io/type.Result.html\n+[result]: ../std/result/enum.Result.html\n+\n+The purpose of these `Result` types is to encode error handling information.\n+Values of the `Result` type, like any type, have methods defined on them. In\n+this case, `io::Result` has an `ok()` method, which says \u2018we want to assume\n+this value is a successful one. If not, just throw away the error\n+information\u2019. Why throw it away? Well, for a basic program, we just want to\n+print a generic error, as basically any issue means we can\u2019t continue. The\n+[`ok()` method][ok] returns a value which has another method defined on it:\n+`expect()`. The [`expect()` method][expect] takes a value it\u2019s called on, and\n+if it isn\u2019t a successful one, [`panic!`][panic]s with a message you passed you\n+passed it. A `panic!` like this will cause our program to crash, displaying\n+the message.\n+\n+[ok]: ../std/result/enum.Result.html#method.ok\n+[expect]: ../std/option/enum.Option.html#method.expect\n+[panic]: error-handling.html\n+\n+If we leave off calling these two methods, our program will compile, but\n+we\u2019ll get a warning:\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+src/main.rs:10:5: 10:39 warning: unused result which must be used,\n+#[warn(unused_must_use)] on by default\n+src/main.rs:10     io::stdin().read_line(&mut guess);\n+                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+```\n+\n+Rust warns us that we haven\u2019t used the `Result` value. This warning comes from\n+a special annotation that `io::Result` has. Rust is trying to tell you that\n+you haven\u2019t handled a possible error. The right way to suppress the error is\n+to actually write error handling. Luckily, if we just want to crash if there\u2019s\n+a problem, we can use these two little methods. If we can recover from the\n+error somehow, we\u2019d do something else, but we\u2019ll save that for a future\n+project.\n+\n+There\u2019s just one line of this first example left:\n+\n+```rust,ignore\n+    println!(\"You guessed: {}\", guess);\n+}\n+```\n+\n+This prints out the string we saved our input in. The `{}`s are a placeholder,\n+and so we pass it `guess` as an argument. If we had multiple `{}`s, we would\n+pass multiple arguments:\n+\n+```rust\n+let x = 5;\n+let y = 10;\n+\n+println!(\"x and y: {} and {}\", x, y);\n+```\n+\n+Easy.\n+\n+Anyway, that\u2019s the tour. We can run what we have with `cargo run`:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+     Running `target/debug/guessing_game`\n+Guess the number!\n+Please input your guess.\n+6\n+You guessed: 6\n+```\n+\n+All right! Our first part is done: we can get input from the keyboard,\n+and then print it back out.\n+\n+# Generating a secret number\n+\n+Next, we need to generate a secret number. Rust does not yet include random\n+number functionality in its standard library. The Rust team does, however,\n+provide a [`rand` crate][randcrate]. A \u2018crate\u2019 is a package of Rust code.\n+We\u2019ve been building a \u2018binary crate\u2019, which is an executable. `rand` is a\n+\u2018library crate\u2019, which contains code that\u2019s intended to be used with other\n+programs.\n+\n+[randcrate]: https://crates.io/crates/rand\n+\n+Using external crates is where Cargo really shines. Before we can write\n+the code using `rand`, we need to modify our `Cargo.toml`. Open it up, and\n+add these few lines at the bottom:\n+\n+```toml\n+[dependencies]\n+\n+rand=\"0.3.0\"\n+```\n+\n+The `[dependencies]` section of `Cargo.toml` is like the `[package]` section:\n+everything that follows it is part of it, until the next section starts.\n+Cargo uses the dependencies section to know what dependencies on external\n+crates you have, and what versions you require. In this case, we\u2019ve used version `0.3.0`.\n+Cargo understands [Semantic Versioning][semver], which is a standard for writing version\n+numbers. If we wanted to use the latest version we could use `*` or we could use a range \n+of versions. [Cargo\u2019s documentation][cargodoc] contains more details.\n+\n+[semver]: http://semver.org\n+[cargodoc]: http://doc.crates.io/crates-io.html\n+\n+Now, without changing any of our code, let\u2019s build our project:\n+\n+```bash\n+$ cargo build\n+    Updating registry `https://github.com/rust-lang/crates.io-index`\n+ Downloading rand v0.3.8\n+ Downloading libc v0.1.6\n+   Compiling libc v0.1.6\n+   Compiling rand v0.3.8\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+```\n+\n+(You may see different versions, of course.)\n+\n+Lots of new output! Now that we have an external dependency, Cargo fetches the\n+latest versions of everything from the registry, which is a copy of data from\n+[Crates.io][cratesio]. Crates.io is where people in the Rust ecosystem\n+post their open source Rust projects for others to use.\n+\n+[cratesio]: https://crates.io\n+\n+After updating the registry, Cargo checks our `[dependencies]` and downloads\n+any we don\u2019t have yet. In this case, while we only said we wanted to depend on\n+`rand`, we\u2019ve also grabbed a copy of `libc`. This is because `rand` depends on\n+`libc` to work. After downloading them, it compiles them, and then compiles\n+our project.\n+\n+If we run `cargo build` again, we\u2019ll get different output:\n+\n+```bash\n+$ cargo build\n+```\n+\n+That\u2019s right, no output! Cargo knows that our project has been built, and that\n+all of its dependencies are built, and so there\u2019s no reason to do all that\n+stuff. With nothing to do, it simply exits. If we open up `src/main.rs` again,\n+make a trivial change, and then save it again, we\u2019ll just see one line:\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+```\n+\n+So, we told Cargo we wanted any `0.3.x` version of `rand`, and so it fetched the latest\n+version at the time this was written, `v0.3.8`. But what happens when next\n+week, version `v0.3.9` comes out, with an important bugfix? While getting\n+bugfixes is important, what if `0.3.9` contains a regression that breaks our\n+code?\n+\n+The answer to this problem is the `Cargo.lock` file you\u2019ll now find in your\n+project directory. When you build your project for the first time, Cargo\n+figures out all of the versions that fit your criteria, and then writes them\n+to the `Cargo.lock` file. When you build your project in the future, Cargo\n+will see that the `Cargo.lock` file exists, and then use that specific version\n+rather than do all the work of figuring out versions again. This lets you\n+have a repeatable build automatically. In other words, we\u2019ll stay at `0.3.8`\n+until we explicitly upgrade, and so will anyone who we share our code with,\n+thanks to the lock file.\n+\n+What about when we _do_ want to use `v0.3.9`? Cargo has another command,\n+`update`, which says \u2018ignore the lock, figure out all the latest versions that\n+fit what we\u2019ve specified. If that works, write those versions out to the lock\n+file\u2019. But, by default, Cargo will only look for versions larger than `0.3.0`\n+and smaller than `0.4.0`. If we want to move to `0.4.x`, we\u2019d have to update\n+the `Cargo.toml` directly. When we do, the next time we `cargo build`, Cargo\n+will update the index and re-evaluate our `rand` requirements.\n+\n+There\u2019s a lot more to say about [Cargo][doccargo] and [its\n+ecosystem][doccratesio], but for now, that\u2019s all we need to know. Cargo makes\n+it really easy to re-use libraries, and so Rustaceans tend to write smaller\n+projects which are assembled out of a number of sub-packages.\n+\n+[doccargo]: http://doc.crates.io\n+[doccratesio]: http://doc.crates.io/crates-io.html\n+\n+Let\u2019s get on to actually _using_ `rand`. Here\u2019s our next step:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let mut guess = String::new();\n+\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"failed to read line\");\n+\n+    println!(\"You guessed: {}\", guess);\n+}\n+```\n+\n+The first thing we\u2019ve done is change the first line. It now says\n+`extern crate rand`. Because we declared `rand` in our `[dependencies]`, we\n+can use `extern crate` to let Rust know we\u2019ll be making use of it. This also\n+does the equivalent of a `use rand;` as well, so we can make use of anything\n+in the `rand` crate by prefixing it with `rand::`.\n+\n+Next, we added another `use` line: `use rand::Rng`. We\u2019re going to use a\n+method in a moment, and it requires that `Rng` be in scope to work. The basic\n+idea is this: methods are defined on something called \u2018traits\u2019, and for the\n+method to work, it needs the trait to be in scope. For more about the\n+details, read the [traits][traits] section.\n+\n+[traits]: traits.html\n+\n+There are two other lines we added, in the middle:\n+\n+```rust,ignore\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+```\n+\n+We use the `rand::thread_rng()` function to get a copy of the random number\n+generator, which is local to the particular [thread][concurrency] of execution\n+we\u2019re in. Because we `use rand::Rng`\u2019d above, it has a `gen_range()` method\n+available. This method takes two arguments, and generates a number between\n+them. It\u2019s inclusive on the lower bound, but exclusive on the upper bound,\n+so we need `1` and `101` to get a number between one and a hundred.\n+\n+[concurrency]: concurrency.html\n+\n+The second line just prints out the secret number. This is useful while\n+we\u2019re developing our program, so we can easily test it out. But we\u2019ll be\n+deleting it for the final version. It\u2019s not much of a game if it prints out\n+the answer when you start it up!\n+\n+Try running our new program a few times:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+     Running `target/debug/guessing_game`\n+Guess the number!\n+The secret number is: 7\n+Please input your guess.\n+4\n+You guessed: 4\n+$ cargo run\n+     Running `target/debug/guessing_game`\n+Guess the number!\n+The secret number is: 83\n+Please input your guess.\n+5\n+You guessed: 5\n+```\n+\n+Great! Next up: let\u2019s compare our guess to the secret guess.\n+\n+# Comparing guesses\n+\n+Now that we\u2019ve got user input, let\u2019s compare our guess to the random guess.\n+Here\u2019s our next step, though it doesn\u2019t quite work yet:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let mut guess = String::new();\n+\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"failed to read line\");\n+\n+    println!(\"You guessed: {}\", guess);\n+\n+    match guess.cmp(&secret_number) {\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n+    }\n+}\n+```\n+\n+A few new bits here. The first is another `use`. We bring a type called\n+`std::cmp::Ordering` into scope. Then, five new lines at the bottom that use\n+it:\n+\n+```rust,ignore\n+match guess.cmp(&secret_number) {\n+    Ordering::Less    => println!(\"Too small!\"),\n+    Ordering::Greater => println!(\"Too big!\"),\n+    Ordering::Equal   => println!(\"You win!\"),\n+}\n+```\n+\n+The `cmp()` method can be called on anything that can be compared, and it\n+takes a reference to the thing you want to compare it to. It returns the\n+`Ordering` type we `use`d earlier. We use a [`match`][match] statement to\n+determine exactly what kind of `Ordering` it is. `Ordering` is an\n+[`enum`][enum], short for \u2018enumeration\u2019, which looks like this:\n+\n+```rust\n+enum Foo {\n+    Bar,\n+    Baz,\n+}\n+```\n+\n+[match]: match.html\n+[enum]: enums.html\n+\n+With this definition, anything of type `Foo` can be either a\n+`Foo::Bar` or a `Foo::Baz`. We use the `::` to indicate the\n+namespace for a particular `enum` variant.\n+\n+The [`Ordering`][ordering] enum has three possible variants: `Less`, `Equal`,\n+and `Greater`. The `match` statement takes a value of a type, and lets you\n+create an \u2018arm\u2019 for each possible value. Since we have three types of\n+`Ordering`, we have three arms:\n+\n+```rust,ignore\n+match guess.cmp(&secret_number) {\n+    Ordering::Less    => println!(\"Too small!\"),\n+    Ordering::Greater => println!(\"Too big!\"),\n+    Ordering::Equal   => println!(\"You win!\"),\n+}\n+```\n+\n+[ordering]: ../std/cmp/enum.Ordering.html\n+\n+If it\u2019s `Less`, we print `Too small!`, if it\u2019s `Greater`, `Too big!`, and if\n+`Equal`, `You win!`. `match` is really useful, and is used often in Rust.\n+\n+I did mention that this won\u2019t quite work yet, though. Let\u2019s try it:\n+\n+```bash\n+$ cargo build\n+   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)\n+src/main.rs:28:21: 28:35 error: mismatched types:\n+ expected `&collections::string::String`,\n+    found `&_`\n+(expected struct `collections::string::String`,\n+    found integral variable) [E0308]\n+src/main.rs:28     match guess.cmp(&secret_number) {\n+                                   ^~~~~~~~~~~~~~\n+error: aborting due to previous error\n+Could not compile `guessing_game`.\n+```\n+\n+Whew! This is a big error. The core of it is that we have \u2018mismatched types\u2019.\n+Rust has a strong, static type system. However, it also has type inference.\n+When we wrote `let guess = String::new()`, Rust was able to infer that `guess`\n+should be a `String`, and so it doesn\u2019t make us write out the type. And with\n+our `secret_number`, there are a number of types which can have a value\n+between one and a hundred: `i32`, a thirty-two-bit number, or `u32`, an\n+unsigned thirty-two-bit number, or `i64`, a sixty-four-bit number. Or others.\n+So far, that hasn\u2019t mattered, and so Rust defaults to an `i32`. However, here,\n+Rust doesn\u2019t know how to compare the `guess` and the `secret_number`. They\n+need to be the same type. Ultimately, we want to convert the `String` we\n+read as input into a real number type, for comparison. We can do that\n+with three more lines. Here\u2019s our new program:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    println!(\"Please input your guess.\");\n+\n+    let mut guess = String::new();\n+\n+    io::stdin().read_line(&mut guess)\n+        .ok()\n+        .expect(\"failed to read line\");\n+\n+    let guess: u32 = guess.trim().parse()\n+        .ok()\n+        .expect(\"Please type a number!\");\n+\n+    println!(\"You guessed: {}\", guess);\n+\n+    match guess.cmp(&secret_number) {\n+        Ordering::Less    => println!(\"Too small!\"),\n+        Ordering::Greater => println!(\"Too big!\"),\n+        Ordering::Equal   => println!(\"You win!\"),\n+    }\n+}\n+```\n+\n+The new three lines:\n+\n+```rust,ignore\n+    let guess: u32 = guess.trim().parse()\n+        .ok()\n+        .expect(\"Please type a number!\");\n+```\n+\n+Wait a minute, I thought we already had a `guess`? We do, but Rust allows us\n+to \u2018shadow\u2019 the previous `guess` with a new one. This is often used in this\n+exact situation, where `guess` starts as a `String`, but we want to convert it\n+to an `u32`. Shadowing lets us re-use the `guess` name, rather than forcing us\n+to come up with two unique names like `guess_str` and `guess`, or something\n+else.\n+\n+We bind `guess` to an expression that looks like something we wrote earlier:\n+\n+```rust,ignore\n+guess.trim().parse()\n+```\n+\n+Followed by an `ok().expect()` invocation. Here, `guess` refers to the old\n+`guess`, the one that was a `String` with our input in it. The `trim()`\n+method on `String`s will eliminate any white space at the beginning and end of\n+our string. This is important, as we had to press the \u2018return\u2019 key to satisfy\n+`read_line()`. This means that if we type `5` and hit return, `guess` looks\n+like this: `5\\n`. The `\\n` represents \u2018newline\u2019, the enter key. `trim()` gets\n+rid of this, leaving our string with just the `5`. The [`parse()` method on\n+strings][parse] parses a string into some kind of number. Since it can parse a\n+variety of numbers, we need to give Rust a hint as to the exact type of number\n+we want. Hence, `let guess: u32`. The colon (`:`) after `guess` tells Rust\n+we\u2019re going to annotate its type. `u32` is an unsigned, thirty-two bit\n+integer. Rust has [a number of built-in number types][number], but we\u2019ve\n+chosen `u32`. It\u2019s a good default choice for a small positive numer.\n+\n+[parse]: ../std/primitive.str.html#method.parse\n+[number]: primitive-types.html#numeric-types\n+\n+Just like `read_line()`, our call to `parse()` could cause an error. What if\n+our string contained `A\ud83d\udc4d%`? There\u2019d be no way to convert that to a number. As\n+such, we\u2019ll do the same thing we did with `read_line()`: use the `ok()` and\n+`expect()` methods to crash if there\u2019s an error.\n+\n+Let\u2019s try our program out!\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 58\n+Please input your guess.\n+  76\n+You guessed: 76\n+Too big!\n+```\n+\n+Nice! You can see I even added spaces before my guess, and it still figured\n+out that I guessed 76. Run the program a few times, and verify that guessing\n+the number works, as well as guessing a number too small.\n+\n+Now we\u2019ve got most of the game working, but we can only make one guess. Let\u2019s\n+change that by adding loops!\n+\n+# Looping\n+\n+The `loop` keyword gives us an infinite loop. Let\u2019s add that in:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+        println!(\"Please input your guess.\");\n+\n+        let mut guess = String::new();\n+\n+        io::stdin().read_line(&mut guess)\n+            .ok()\n+            .expect(\"failed to read line\");\n+\n+        let guess: u32 = guess.trim().parse()\n+            .ok()\n+            .expect(\"Please type a number!\");\n+\n+        println!(\"You guessed: {}\", guess);\n+\n+        match guess.cmp(&secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => println!(\"You win!\"),\n+        }\n+    }\n+}\n+```\n+\n+And try it out. But wait, didn\u2019t we just add an infinite loop? Yup. Remember\n+our discussion about `parse()`? If we give a non-number answer, we\u2019ll `return`\n+and quit. Observe:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 59\n+Please input your guess.\n+45\n+You guessed: 45\n+Too small!\n+Please input your guess.\n+60\n+You guessed: 60\n+Too big!\n+Please input your guess.\n+59\n+You guessed: 59\n+You win!\n+Please input your guess.\n+quit\n+thread '<main>' panicked at 'Please type a number!'\n+```\n+\n+Ha! `quit` actually quits. As does any other non-number input. Well, this is\n+suboptimal to say the least. First, let\u2019s actually quit when you win the game:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+        println!(\"Please input your guess.\");\n+\n+        let mut guess = String::new();\n+\n+        io::stdin().read_line(&mut guess)\n+            .ok()\n+            .expect(\"failed to read line\");\n+\n+        let guess: u32 = guess.trim().parse()\n+            .ok()\n+            .expect(\"Please type a number!\");\n+\n+        println!(\"You guessed: {}\", guess);\n+\n+        match guess.cmp(&secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n+                println!(\"You win!\");\n+                break;\n+            }\n+        }\n+    }\n+}\n+```\n+\n+By adding the `break` line after the `You win!`, we\u2019ll exit the loop when we\n+win. Exiting the loop also means exiting the program, since it\u2019s the last\n+thing in `main()`. We have just one more tweak to make: when someone inputs a\n+non-number, we don\u2019t want to quit, we just want to ignore it. We can do that\n+like this:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    println!(\"The secret number is: {}\", secret_number);\n+\n+    loop {\n+        println!(\"Please input your guess.\");\n+\n+        let mut guess = String::new();\n+\n+        io::stdin().read_line(&mut guess)\n+            .ok()\n+            .expect(\"failed to read line\");\n+\n+        let guess: u32 = match guess.trim().parse() {\n+            Ok(num) => num,\n+            Err(_) => continue,\n+        };\n+\n+        println!(\"You guessed: {}\", guess);\n+\n+        match guess.cmp(&secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n+                println!(\"You win!\");\n+                break;\n+            }\n+        }\n+    }\n+}\n+```\n+\n+These are the lines that changed:\n+\n+```rust,ignore\n+let guess: u32 = match guess.trim().parse() {\n+    Ok(num) => num,\n+    Err(_) => continue,\n+};\n+```\n+\n+This is how you generally move from \u2018crash on error\u2019 to \u2018actually handle the\n+error\u2019, by switching from `ok().expect()` to a `match` statement. The `Result`\n+returned by `parse()` is an enum just like `Ordering`, but in this case, each\n+variant has some data associated with it: `Ok` is a success, and `Err` is a\n+failure. Each contains more information: the successful parsed integer, or an\n+error type. In this case, we `match` on `Ok(num)`, which sets the inner value\n+of the `Ok` to the name `num`, and then we just return it on the right-hand\n+side. In the `Err` case, we don\u2019t care what kind of error it is, so we just\n+use `_` intead of a name. This ignores the error, and `continue` causes us\n+to go to the next iteration of the `loop`.\n+\n+Now we should be good! Let\u2019s try:\n+\n+```bash\n+$ cargo run\n+   Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n+     Running `target/guessing_game`\n+Guess the number!\n+The secret number is: 61\n+Please input your guess.\n+10\n+You guessed: 10\n+Too small!\n+Please input your guess.\n+99\n+You guessed: 99\n+Too big!\n+Please input your guess.\n+foo\n+Please input your guess.\n+61\n+You guessed: 61\n+You win!\n+```\n+\n+Awesome! With one tiny last tweak, we have finished the guessing game. Can you\n+think of what it is? That\u2019s right, we don\u2019t want to print out the secret\n+number. It was good for testing, but it kind of ruins the game. Here\u2019s our\n+final source:\n+\n+```rust,ignore\n+extern crate rand;\n+\n+use std::io;\n+use std::cmp::Ordering;\n+use rand::Rng;\n+\n+fn main() {\n+    println!(\"Guess the number!\");\n+\n+    let secret_number = rand::thread_rng().gen_range(1, 101);\n+\n+    loop {\n+        println!(\"Please input your guess.\");\n+\n+        let mut guess = String::new();\n+\n+        io::stdin().read_line(&mut guess)\n+            .ok()\n+            .expect(\"failed to read line\");\n+\n+        let guess: u32 = match guess.trim().parse() {\n+            Ok(num) => num,\n+            Err(_) => continue,\n+        };\n+\n+        println!(\"You guessed: {}\", guess);\n+\n+        match guess.cmp(&secret_number) {\n+            Ordering::Less    => println!(\"Too small!\"),\n+            Ordering::Greater => println!(\"Too big!\"),\n+            Ordering::Equal   => {\n+                println!(\"You win!\");\n+                break;\n+            }\n+        }\n+    }\n+}\n+```\n+\n+# Complete!\n+\n+At this point, you have successfully built the Guessing Game! Congratulations!\n+\n+This first project showed you a lot: `let`, `match`, methods, associated\n+functions, using external crates, and more. Our next project will show off\n+even more."}, {"sha": "cc8747d1fa7c17d6a7751dd9c6538abc60ded88d", "filename": "src/doc/trpl/hello-cargo.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fhello-cargo.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fhello-cargo.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -5,7 +5,7 @@ projects. Cargo is currently in a pre-1.0 state, and so it is still a work in\n progress. However, it is already good enough to use for many Rust projects, and\n so it is assumed that Rust projects will use Cargo from the beginning.\n \n-[cratesio]: https://doc.crates.io\n+[cratesio]: http://doc.crates.io\n \n Cargo manages three things: building your code, downloading the dependencies\n your code needs, and building those dependencies. At first, your"}, {"sha": "4872ed6a773472a8412e115fd4c1302dd2f7e5e8", "filename": "src/doc/trpl/if-let.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fif-let.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fif-let.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif-let.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -65,7 +65,7 @@ loop as long as a value matches a certain pattern. It turns code like this:\n loop {\n     match option {\n         Some(x) => println!(\"{}\", x),\n-\t_ => break,\n+        _ => break,\n     }\n }\n ```"}, {"sha": "58c2a982dd3097443c88eb98e614e4a05690869b", "filename": "src/doc/trpl/inline-assembly.md", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finline-assembly.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -58,7 +58,7 @@ but you must add the right number of `:` if you skip them:\n asm!(\"xor %eax, %eax\"\n     :\n     :\n-    : \"eax\"\n+    : \"{eax}\"\n    );\n # } }\n ```\n@@ -69,21 +69,21 @@ Whitespace also doesn't matter:\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # fn main() { unsafe {\n-asm!(\"xor %eax, %eax\" ::: \"eax\");\n+asm!(\"xor %eax, %eax\" ::: \"{eax}\");\n # } }\n ```\n \n ## Operands\n \n Input and output operands follow the same format: `:\n \"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n-expressions must be mutable lvalues:\n+expressions must be mutable lvalues, or not yet assigned:\n \n ```\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n fn add(a: i32, b: i32) -> i32 {\n-    let mut c = 0;\n+    let c: i32;\n     unsafe {\n         asm!(\"add $2, $0\"\n              : \"=r\"(c)\n@@ -100,6 +100,22 @@ fn main() {\n }\n ```\n \n+If you would like to use real operands in this position, however,\n+you are required to put curly braces `{}` around the register that\n+you want, and you are required to put the specific size of the\n+operand. This is useful for very low level programming, where \n+which register you use is important:\n+\n+```\n+# #![feature(asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# unsafe fn read_byte_in(port: u16) -> u8 {\n+let result: u8;\n+asm!(\"in %dx, %al\" : \"={al}\"(result) : \"{dx}\"(port));\n+result\n+# }\n+```\n+\n ## Clobbers\n \n Some instructions modify registers which might otherwise have held\n@@ -112,7 +128,7 @@ stay valid.\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # fn main() { unsafe {\n // Put the value 0x200 in eax\n-asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n+asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"{eax}\");\n # } }\n ```\n \n@@ -139,3 +155,14 @@ Current valid options are:\n    the compiler to insert its usual stack alignment code\n 3. *intel* - use intel syntax instead of the default AT&T.\n \n+```\n+# #![feature(asm)]\n+# #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+# fn main() {\n+let result: i32;\n+unsafe {\n+   asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")\n+}\n+println!(\"eax is currently {}\", result);\n+# }\n+```"}, {"sha": "b8230f060e073f51105e7919c4ca0371c2a51657", "filename": "src/doc/trpl/installing-rust.md", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Finstalling-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finstalling-rust.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -6,16 +6,16 @@ or a Mac, all you need to do is this (note that you don't need to type in the\n `$`s, they just indicate the start of each command):\n \n ```bash\n-$ curl -sf -L https://static.rust-lang.org/rustup.sh | sudo sh\n+$ curl -sf -L https://static.rust-lang.org/rustup.sh | sh\n ```\n \n If you're concerned about the [potential insecurity][insecurity] of using `curl\n-| sudo sh`, please keep reading and see our disclaimer below. And feel free to\n+| sh`, please keep reading and see our disclaimer below. And feel free to\n use a two-step version of the installation and examine our installation script:\n \n ```bash\n $ curl -f -L https://static.rust-lang.org/rustup.sh -O\n-$ sudo sh rustup.sh\n+$ sh rustup.sh\n ```\n \n [insecurity]: http://curlpipesh.tumblr.com\n@@ -40,13 +40,11 @@ If you used the Windows installer, just re-run the `.msi` and it will give you\n an uninstall option.\n \n Some people, and somewhat rightfully so, get very upset when we tell you to\n-`curl | sudo sh`. Basically, when you do this, you are trusting that the good\n+`curl | sh`. Basically, when you do this, you are trusting that the good\n people who maintain Rust aren't going to hack your computer and do bad things.\n That's a good instinct! If you're one of those people, please check out the\n documentation on [building Rust from Source][from source], or [the official\n-binary downloads][install page]. And we promise that this method will not be\n-the way to install Rust forever: it's just the easiest way to keep people\n-updated while Rust is in its alpha state.\n+binary downloads][install page].\n \n [from source]: https://github.com/rust-lang/rust#building-from-source\n [install page]: http://www.rust-lang.org/install.html"}, {"sha": "abb14a60205242720abd0fd1be6c2bb80dd1d6ea", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -42,7 +42,7 @@ loop is just a handy way to write this `loop`/`match`/`break` construct.\n `for` loops aren't the only thing that uses iterators, however. Writing your\n own iterator involves implementing the `Iterator` trait. While doing that is\n outside of the scope of this guide, Rust provides a number of useful iterators\n-to accomplish various tasks. Before we talk about those, we should talk about a\n+to accomplish various threads. Before we talk about those, we should talk about a\n Rust anti-pattern. And that's using ranges like this.\n \n Yes, we just talked about how ranges are cool. But ranges are also very\n@@ -235,26 +235,15 @@ Ranges are one of two basic iterators that you'll see. The other is `iter()`.\n in turn:\n \n ```rust\n-let nums = [1, 2, 3];\n+let nums = vec![1, 2, 3];\n \n for num in nums.iter() {\n    println!(\"{}\", num);\n }\n ```\n \n These two basic iterators should serve you well. There are some more\n-advanced iterators, including ones that are infinite. Like using range syntax\n-and `step_by`:\n-\n-```rust\n-# #![feature(step_by)]\n-(1..).step_by(5);\n-```\n-\n-This iterator counts up from one, adding five each time. It will give\n-you a new integer every time, forever (well, technically, until it reaches the\n-maximum number representable by an `i32`). But since iterators are lazy,\n-that's okay! You probably don't want to use `collect()` on it, though...\n+advanced iterators, including ones that are infinite.\n \n That's enough about iterators. Iterator adapters are the last concept\n we need to talk about with regards to iterators. Let's get to it!"}, {"sha": "4808ad6ff1febb22e55291320747f7a6c10f1b15", "filename": "src/doc/trpl/lang-items.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flang-items.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -7,7 +7,7 @@\n The `rustc` compiler has certain pluggable operations, that is,\n functionality that isn't hard-coded into the language, but is\n implemented in libraries, with a special marker to tell the compiler\n-it exists. The marker is the attribute `#[lang=\"...\"]` and there are\n+it exists. The marker is the attribute `#[lang = \"...\"]` and there are\n various different values of `...`, i.e. various different 'lang\n items'.\n \n@@ -28,7 +28,7 @@ extern {\n #[lang = \"owned_box\"]\n pub struct Box<T>(*mut T);\n \n-#[lang=\"exchange_malloc\"]\n+#[lang = \"exchange_malloc\"]\n unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n     let p = libc::malloc(size as libc::size_t) as *mut u8;\n \n@@ -39,7 +39,7 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n \n     p\n }\n-#[lang=\"exchange_free\"]\n+#[lang = \"exchange_free\"]\n unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n     libc::free(ptr as *mut libc::c_void)\n }"}, {"sha": "1a02bc95e9d9c84247ff01c674415697457a0b04", "filename": "src/doc/trpl/learn-rust.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Flearn-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Flearn-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flearn-rust.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -1,4 +1,9 @@\n % Learn Rust\n \n-This section is coming soon! It will eventually have a few tutorials with\n-building real Rust projects, but they are under development.\n+Welcome! This section has a few tutorials that teach you Rust through building\n+projects. You\u2019ll get a high-level overview, but we\u2019ll skim over the details.\n+\n+If you\u2019d prefer a more \u2018from the ground up\u2019-style experience, check\n+out [Syntax and Semantics][ss].\n+\n+[ss]: syntax-and-semantics.html"}, {"sha": "86164a08a430f87d8245cc5603f8e5d9674d28c9", "filename": "src/doc/trpl/lifetimes.md", "status": "modified", "additions": 295, "deletions": 1, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -1,3 +1,297 @@\n % Lifetimes\n \n-Coming Soon! Until then, check out the [ownership](ownership.html) chapter.\n+This guide is one of three presenting Rust\u2019s ownership system. This is one of\n+Rust\u2019s most unique and compelling features, with which Rust developers should\n+become quite acquainted. Ownership is how Rust achieves its largest goal,\n+memory safety. There are a few distinct concepts, each with its own chapter:\n+\n+* [ownership][ownership], ownership, the key concept\n+* [borrowing][borrowing], and their associated feature \u2018references\u2019\n+* lifetimes, which you\u2019re reading now\n+\n+These three chapters are related, and in order. You\u2019ll need all three to fully\n+understand the ownership system.\n+\n+[ownership]: ownership.html\n+[borrowing]: references-and-borrowing.html\n+\n+# Meta\n+\n+Before we get to the details, two important notes about the ownership system.\n+\n+Rust has a focus on safety and speed. It accomplishes these goals through many\n+\u2018zero-cost abstractions\u2019, which means that in Rust, abstractions cost as little\n+as possible in order to make them work. The ownership system is a prime example\n+of a zero-cost abstraction. All of the analysis we\u2019ll talk about in this guide\n+is _done at compile time_. You do not pay any run-time cost for any of these\n+features.\n+\n+However, this system does have a certain cost: learning curve. Many new users\n+to Rust experience something we like to call \u2018fighting with the borrow\n+checker\u2019, where the Rust compiler refuses to compile a program that the author\n+thinks is valid. This often happens because the programmer\u2019s mental model of\n+how ownership should work doesn\u2019t match the actual rules that Rust implements.\n+You probably will experience similar things at first. There is good news,\n+however: more experienced Rust developers report that once they work with the\n+rules of the ownership system for a period of time, they fight the borrow\n+checker less and less.\n+\n+With that in mind, let\u2019s learn about lifetimes.\n+\n+# Lifetimes\n+\n+Lending out a reference to a resource that someone else owns can be\n+complicated, however. For example, imagine this set of operations:\n+\n+- I acquire a handle to some kind of resource.\n+- I lend you a reference to the resource.\n+- I decide I\u2019m done with the resource, and deallocate it, while you still have\n+  your reference.\n+- You decide to use the resource.\n+\n+Uh oh! Your reference is pointing to an invalid resource. This is called a\n+dangling pointer or \u2018use after free\u2019, when the resource is memory.\n+\n+To fix this, we have to make sure that step four never happens after step\n+three. The ownership system in Rust does this through a concept called\n+lifetimes, which describe the scope that a reference is valid for.\n+\n+When we have a function that takes a reference by argument, we can be implicit\n+or explicit about the lifetime of the reference:\n+\n+```rust\n+// implicit\n+fn foo(x: &i32) {\n+}\n+\n+// explicit\n+fn bar<'a>(x: &'a i32) {\n+}\n+```\n+\n+The `'a` reads \u2018the lifetime a\u2019. Technically, every reference has some lifetime\n+associated with it, but the compiler lets you elide them in common cases.\n+Before we get to that, though, let\u2019s break the explicit example down:\n+\n+```rust,ignore\n+fn bar<'a>(...)\n+```\n+\n+This part declares our lifetimes. This says that `bar` has one lifetime, `'a`.\n+If we had two reference parameters, it would look like this:\n+\n+```rust,ignore\n+fn bar<'a, 'b>(...)\n+```\n+\n+Then in our parameter list, we use the lifetimes we\u2019ve named:\n+\n+```rust,ignore\n+...(x: &'a i32)\n+```\n+\n+If we wanted an `&mut` reference, we\u2019d do this:\n+\n+```rust,ignore\n+...(x: &'a mut i32)\n+```\n+\n+If you compare `&mut i32` to `&'a mut i32`, they\u2019re the same, it\u2019s just that\n+the lifetime `'a` has snuck in between the `&` and the `mut i32`. We read `&mut\n+i32` as \u2018a mutable reference to an i32\u2019 and `&'a mut i32` as \u2018a mutable\n+reference to an `i32` with the lifetime `'a`\u2019.\n+\n+You\u2019ll also need explicit lifetimes when working with [`struct`][structs]s:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a i32,\n+}\n+\n+fn main() {\n+    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n+    let f = Foo { x: y };\n+\n+    println!(\"{}\", f.x);\n+}\n+```\n+\n+[structs]: structs.html\n+\n+As you can see, `struct`s can also have lifetimes. In a similar way to functions,\n+\n+```rust\n+struct Foo<'a> {\n+# x: &'a i32,\n+# }\n+```\n+\n+declares a lifetime, and\n+\n+```rust\n+# struct Foo<'a> {\n+x: &'a i32,\n+# }\n+```\n+\n+uses it. So why do we need a lifetime here? We need to ensure that any reference\n+to a `Foo` cannot outlive the reference to an `i32` it contains.\n+\n+## Thinking in scopes\n+\n+A way to think about lifetimes is to visualize the scope that a reference is\n+valid for. For example:\n+\n+```rust\n+fn main() {\n+    let y = &5;     // -+ y goes into scope\n+                    //  |\n+    // stuff        //  |\n+                    //  |\n+}                   // -+ y goes out of scope\n+```\n+\n+Adding in our `Foo`:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a i32,\n+}\n+\n+fn main() {\n+    let y = &5;           // -+ y goes into scope\n+    let f = Foo { x: y }; // -+ f goes into scope\n+    // stuff              //  |\n+                          //  |\n+}                         // -+ f and y go out of scope\n+```\n+\n+Our `f` lives within the scope of `y`, so everything works. What if it didn\u2019t?\n+This code won\u2019t work:\n+\n+```rust,ignore\n+struct Foo<'a> {\n+    x: &'a i32,\n+}\n+\n+fn main() {\n+    let x;                    // -+ x goes into scope\n+                              //  |\n+    {                         //  |\n+        let y = &5;           // ---+ y goes into scope\n+        let f = Foo { x: y }; // ---+ f goes into scope\n+        x = &f.x;             //  | | error here\n+    }                         // ---+ f and y go out of scope\n+                              //  |\n+    println!(\"{}\", x);        //  |\n+}                             // -+ x goes out of scope\n+```\n+\n+Whew! As you can see here, the scopes of `f` and `y` are smaller than the scope\n+of `x`. But when we do `x = &f.x`, we make `x` a reference to something that\u2019s\n+about to go out of scope.\n+\n+Named lifetimes are a way of giving these scopes a name. Giving something a\n+name is the first step towards being able to talk about it.\n+\n+## 'static\n+\n+The lifetime named \u2018static\u2019 is a special lifetime. It signals that something\n+has the lifetime of the entire program. Most Rust programmers first come across\n+`'static` when dealing with strings:\n+\n+```rust\n+let x: &'static str = \"Hello, world.\";\n+```\n+\n+String literals have the type `&'static str` because the reference is always\n+alive: they are baked into the data segment of the final binary. Another\n+example are globals:\n+\n+```rust\n+static FOO: i32 = 5;\n+let x: &'static i32 = &FOO;\n+```\n+\n+This adds an `i32` to the data segment of the binary, and `x` is a reference\n+to it.\n+\n+## Lifetime Elision\n+\n+Rust supports powerful local type inference in function bodies, but it\u2019s\n+forbidden in item signatures to allow reasoning about the types just based in\n+the item signature alone. However, for ergonomic reasons a very restricted\n+secondary inference algorithm called \u201clifetime elision\u201d applies in function\n+signatures. It infers only based on the signature components themselves and not\n+based on the body of the function, only infers lifetime parameters, and does\n+this with only three easily memorizable and unambiguous rules. This makes\n+lifetime elision a shorthand for writing an item signature, while not hiding\n+away the actual types involved as full local inference would if applied to it.\n+\n+When talking about lifetime elision, we use the term *input lifetime* and\n+*output lifetime*. An *input lifetime* is a lifetime associated with a parameter\n+of a function, and an *output lifetime* is a lifetime associated with the return\n+value of a function. For example, this function has an input lifetime:\n+\n+```rust,ignore\n+fn foo<'a>(bar: &'a str)\n+```\n+\n+This one has an output lifetime:\n+\n+```rust,ignore\n+fn foo<'a>() -> &'a str\n+```\n+\n+This one has a lifetime in both positions:\n+\n+```rust,ignore\n+fn foo<'a>(bar: &'a str) -> &'a str\n+```\n+\n+Here are the three rules:\n+\n+* Each elided lifetime in a function\u2019s arguments becomes a distinct lifetime\n+  parameter.\n+\n+* If there is exactly one input lifetime, elided or not, that lifetime is\n+  assigned to all elided lifetimes in the return values of that function.\n+\n+* If there are multiple input lifetimes, but one of them is `&self` or `&mut\n+  self`, the lifetime of `self` is assigned to all elided output lifetimes.\n+\n+Otherwise, it is an error to elide an output lifetime.\n+\n+### Examples\n+\n+Here are some examples of functions with elided lifetimes.  We\u2019ve paired each\n+example of an elided lifetime with its expanded form.\n+\n+```rust,ignore\n+fn print(s: &str); // elided\n+fn print<'a>(s: &'a str); // expanded\n+\n+fn debug(lvl: u32, s: &str); // elided\n+fn debug<'a>(lvl: u32, s: &'a str); // expanded\n+\n+// In the preceding example, `lvl` doesn\u2019t need a lifetime because it\u2019s not a\n+// reference (`&`). Only things relating to references (such as a `struct`\n+// which contains a reference) need lifetimes.\n+\n+fn substr(s: &str, until: u32) -> &str; // elided\n+fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n+\n+fn get_str() -> &str; // ILLEGAL, no inputs\n+\n+fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs\n+fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is unclear\n+\n+fn get_mut(&mut self) -> &mut T; // elided\n+fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded\n+\n+fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command // elided\n+fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n+\n+fn new(buf: &mut [u8]) -> BufWriter; // elided\n+fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> // expanded\n+```"}, {"sha": "c5dd25516f3196087a7e0b8406ead3fb920b8944", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -129,7 +129,7 @@ circle to any arbitrary size.\n \n # Static methods\n \n-You can also define methods that do not take a `self` parameter. Here\u2019s a\n+You can also define static methods that do not take a `self` parameter. Here\u2019s a\n pattern that\u2019s very common in Rust code:\n \n ```\n@@ -154,9 +154,10 @@ fn main() {\n }\n ```\n \n-This \u2018static method\u2019 builds a new `Circle` for us. Note that static methods\n-are called with the `Struct::method()` syntax, rather than the `ref.method()`\n-syntax.\n+This \u2018associated function\u2019 builds a new `Circle` for us. Note that associated\n+functions are called with the `Struct::function()` syntax, rather than the\n+`ref.method()` syntax. Some other langauges call associated functions \u2018static\n+methods\u2019.\n \n # Builder Pattern\n \n@@ -187,7 +188,7 @@ struct CircleBuilder {\n \n impl CircleBuilder {\n     fn new() -> CircleBuilder {\n-        CircleBuilder { x: 0.0, y: 0.0, radius: 0.0, }\n+        CircleBuilder { x: 0.0, y: 0.0, radius: 1.0, }\n     }\n \n     fn x(&mut self, coordinate: f64) -> &mut CircleBuilder {"}, {"sha": "b5bd53e1d75a14bc6ad23ddc81756403916a1fa1", "filename": "src/doc/trpl/move-semantics.md", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmove-semantics.md?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -1,105 +0,0 @@\n-% Move Semantics\n-\n-An important aspect of [ownership][ownership] is \u2018move semantics\u2019. Move\n-semantics control how and when ownership is transferred between bindings.\n-\n-[ownership]: ownership.html\n-\n-For example, consider a type like `Vec<T>`, which owns its contents:\n-\n-```rust\n-let v = vec![1, 2, 3];\n-```\n-\n-I can assign this vector to another binding:\n-\n-```rust\n-let v = vec![1, 2, 3];\n-\n-let v2 = v;\n-```\n-\n-But, if we try to use `v` afterwards, we get an error:\n-\n-```rust,ignore\n-let v = vec![1, 2, 3];\n-\n-let v2 = v;\n-\n-println!(\"v[0] is: {}\", v[0]);\n-```\n-\n-It looks like this:\n-\n-```text\n-error: use of moved value: `v`\n-println!(\"v[0] is: {}\", v[0]);\n-                        ^\n-```\n-\n-A similar thing happens if we define a function which takes ownership, and\n-try to use something after we\u2019ve passed it as an argument:\n-\n-```rust,ignore\n-fn take(v: Vec<i32>) {\n-    // what happens here isn\u2019t important.\n-}\n-\n-let v = vec![1, 2, 3];\n-\n-take(v);\n-\n-println!(\"v[0] is: {}\", v[0]);\n-```\n-\n-Same error: \u201cuse of moved value.\u201d When we transfer ownership to something else,\n-we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need some sort of\n-special annotation here, it\u2019s the default thing that Rust does.\n-\n-# The details\n-\n-The reason that we cannot use a binding after we\u2019ve moved it is subtle, but\n-important. When we write code like this:\n-\n-```rust\n-let v = vec![1, 2, 3];\n-\n-let v2 = v;\n-```\n-\n-The first line creates some data for the vector on the stack, `v`. The vector\u2019s\n-data, however, is stored on the heap, and so it contains a pointer to that\n-data. When we move `v` to `v2`, it creates a copy of that data, for `v2`. Which\n-would mean two pointers to the contents of the vector on the heap. That would\n-be a problem: it would violate Rust\u2019s safety guarantees by introducing a data\n-race. Therefore, Rust forbids using `v` after we\u2019ve done the move.\n-\n-It\u2019s also important to note that optimizations may remove the actual copy of\n-the bytes, depending on circumstances. So it may not be as inefficient as it\n-initially seems.\n-\n-# `Copy` types\n-\n-We\u2019ve established that when ownership is transferred to another binding, you\n-cannot use the original binding. However, there\u2019s a [trait][traits] that changes this\n-behavior, and it\u2019s called `Copy`. We haven\u2019t discussed traits yet, but for now,\n-you can think of them as an annotation to a particular type that adds extra\n-behavior. For example:\n-\n-```rust\n-let v = 1;\n-\n-let v2 = v;\n-\n-println!(\"v is: {}\", v);\n-```\n-\n-In this case, `v` is an `i32`, which implements the `Copy` trait. This means\n-that, just like a move, when we assign `v` to `v2`, a copy of the data is made.\n-But, unlike a move, we can still use `v` afterward. This is because an `i32`\n-has no pointers to data somewhere else, copying it is a full copy.\n-\n-We will discuss how to make your own types `Copy` in the [traits][traits]\n-section.\n-\n-[traits]: traits.html"}, {"sha": "435407a8a967d36d6dc2b7389ad43ecfca64f50b", "filename": "src/doc/trpl/mutability.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmutability.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -85,7 +85,7 @@ safety, and the mechanism by which Rust guarantees it, the\n > You may have one or the other of these two kinds of borrows, but not both at\n > the same time:\n > \n-> * 0 to N references (`&T`) to a resource.\n+> * one or more references (`&T`) to a resource.\n > * exactly one mutable reference (`&mut T`)\n \n [ownership]: ownership.html"}, {"sha": "2f3055deb04e063dbdc1e12ae97222e90bf2853d", "filename": "src/doc/trpl/nightly-rust.md", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fnightly-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fnightly-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fnightly-rust.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -9,16 +9,16 @@ process, see \u2018[Stability as a deliverable][stability]\u2019.\n To install nightly Rust, you can use `rustup.sh`:\n \n ```bash\n-$ curl -s https://static.rust-lang.org/rustup.sh | sudo sh -s -- --channel=nightly\n+$ curl -s https://static.rust-lang.org/rustup.sh | sh -s -- --channel=nightly\n ```\n \n If you're concerned about the [potential insecurity][insecurity] of using `curl\n-| sudo sh`, please keep reading and see our disclaimer below. And feel free to\n+| sh`, please keep reading and see our disclaimer below. And feel free to\n use a two-step version of the installation and examine our installation script:\n \n ```bash\n $ curl -f -L https://static.rust-lang.org/rustup.sh -O\n-$ sudo sh rustup.sh --channel=nightly\n+$ sh rustup.sh --channel=nightly\n ```\n \n [insecurity]: http://curlpipesh.tumblr.com\n@@ -43,13 +43,11 @@ If you used the Windows installer, just re-run the `.msi` and it will give you\n an uninstall option.\n \n Some people, and somewhat rightfully so, get very upset when we tell you to\n-`curl | sudo sh`. Basically, when you do this, you are trusting that the good\n+`curl | sh`. Basically, when you do this, you are trusting that the good\n people who maintain Rust aren't going to hack your computer and do bad things.\n That's a good instinct! If you're one of those people, please check out the\n documentation on [building Rust from Source][from source], or [the official\n-binary downloads][install page]. And we promise that this method will not be\n-the way to install Rust forever: it's just the easiest way to keep people\n-updated while Rust is in its alpha state.\n+binary downloads][install page].\n \n [from source]: https://github.com/rust-lang/rust#building-from-source\n [install page]: http://www.rust-lang.org/install.html\n@@ -93,8 +91,7 @@ If not, there are a number of places where you can get help. The easiest is\n [the #rust IRC channel on irc.mozilla.org][irc], which you can access through\n [Mibbit][mibbit]. Click that link, and you'll be chatting with other Rustaceans\n (a silly nickname we call ourselves), and we can help you out. Other great\n-resources include [the user\u2019s forum][users], and [Stack Overflow][stack\n-overflow].\n+resources include [the user\u2019s forum][users], and [Stack Overflow][stack overflow].\n \n [irc]: irc://irc.mozilla.org/#rust\n [mibbit]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust"}, {"sha": "fba5226ca2ed9a45590b6e817da5fc51b0f70933", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 112, "deletions": 459, "changes": 571, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -1,555 +1,208 @@\n % Ownership\n \n-This guide presents Rust's ownership system. This is one of Rust's most unique\n-and compelling features, with which Rust developers should become quite\n-acquainted. Ownership is how Rust achieves its largest goal, memory safety.\n-The ownership system has a few distinct concepts: *ownership*, *borrowing*,\n-and *lifetimes*. We'll talk about each one in turn.\n+This guide is one of three presenting Rust\u2019s ownership system. This is one of\n+Rust\u2019s most unique and compelling features, with which Rust developers should\n+become quite acquainted. Ownership is how Rust achieves its largest goal,\n+memory safety. There are a few distinct concepts, each with its own\n+chapter:\n+\n+* ownership, which you\u2019re reading now.\n+* [borrowing][borrowing], and their associated feature \u2018references\u2019\n+* [lifetimes][lifetimes], an advanced concept of borrowing\n+\n+These three chapters are related, and in order. You\u2019ll need all three to fully\n+understand the ownership system.\n+\n+[borrowing]: references-and-borrowing.html\n+[lifetimes]: lifetimes.html\n \n # Meta\n \n Before we get to the details, two important notes about the ownership system.\n \n Rust has a focus on safety and speed. It accomplishes these goals through many\n-*zero-cost abstractions*, which means that in Rust, abstractions cost as little\n+\u2018zero-cost abstractions\u2019, which means that in Rust, abstractions cost as little\n as possible in order to make them work. The ownership system is a prime example\n-of a zero cost abstraction. All of the analysis we'll talk about in this guide\n+of a zero cost abstraction. All of the analysis we\u2019ll talk about in this guide\n is _done at compile time_. You do not pay any run-time cost for any of these\n features.\n \n However, this system does have a certain cost: learning curve. Many new users\n-to Rust experience something we like to call \"fighting with the borrow\n-checker,\" where the Rust compiler refuses to compile a program that the author\n-thinks is valid. This often happens because the programmer's mental model of\n-how ownership should work doesn't match the actual rules that Rust implements.\n+to Rust experience something we like to call \u2018fighting with the borrow\n+checker\u2019, where the Rust compiler refuses to compile a program that the author\n+thinks is valid. This often happens because the programmer\u2019s mental model of\n+how ownership should work doesn\u2019t match the actual rules that Rust implements.\n You probably will experience similar things at first. There is good news,\n however: more experienced Rust developers report that once they work with the\n rules of the ownership system for a period of time, they fight the borrow\n checker less and less.\n \n-With that in mind, let's learn about ownership.\n+With that in mind, let\u2019s learn about ownership.\n \n # Ownership\n \n-At its core, ownership is about *resources*. For the purposes of the vast\n-majority of this guide, we will talk about a specific resource: memory. The\n-concept generalizes to any kind of resource, like a file handle, but to make it\n-more concrete, we'll focus on memory.\n-\n-When your program allocates some memory, it needs some way to deallocate that\n-memory. Imagine a function `foo` that allocates four bytes of memory, and then\n-never deallocates that memory. We call this problem *leaking* memory, because\n-each time we call `foo`, we're allocating another four bytes. Eventually, with\n-enough calls to `foo`, we will run our system out of memory. That's no good. So\n-we need some way for `foo` to deallocate those four bytes. It's also important\n-that we don't deallocate too many times, either. Without getting into the\n-details, attempting to deallocate memory multiple times can lead to problems.\n-In other words, any time some memory is allocated, we need to make sure that we\n-deallocate that memory once and only once. Too many times is bad, not enough\n-times is bad. The counts must match.\n-\n-There's one other important detail with regards to allocating memory. Whenever\n-we request some amount of memory, what we are given is a handle to that memory.\n-This handle (often called a *pointer*, when we're referring to memory) is how\n-we interact with the allocated memory. As long as we have that handle, we can\n-do something with the memory. Once we're done with the handle, we're also done\n-with the memory, as we can't do anything useful without a handle to it.\n-\n-Historically, systems programming languages require you to track these\n-allocations, deallocations, and handles yourself. For example, if we want some\n-memory from the heap in a language like C, we do this:\n-\n-```c\n-{\n-    int *x = malloc(sizeof(int));\n-\n-    // we can now do stuff with our handle x\n-    *x = 5;\n-\n-    free(x);\n-}\n-```\n-\n-The call to `malloc` allocates some memory. The call to `free` deallocates the\n-memory. There's also bookkeeping about allocating the correct amount of memory.\n-\n-Rust combines these two aspects of allocating memory (and other resources) into\n-a concept called *ownership*. Whenever we request some memory, that handle we\n-receive is called the *owning handle*. Whenever that handle goes out of scope,\n-Rust knows that you cannot do anything with the memory anymore, and so\n-therefore deallocates the memory for you. Here's the equivalent example in\n-Rust:\n+[`Variable bindings`][bindings] have a property in Rust: they \u2018have ownership\u2019\n+of what they\u2019re bound to. This means that when a binding goes out of scope, the\n+resource that they\u2019re bound to are freed. For example:\n \n ```rust\n-{\n-    let x = Box::new(5);\n-}\n-```\n-\n-The `Box::new` function creates a `Box<T>` (specifically `Box<i32>` in this\n-case) by allocating a small segment of memory on the heap with enough space to\n-fit an `i32`. But where in the code is the box deallocated? We said before that\n-we must have a deallocation for each allocation. Rust handles this for you. It\n-knows that our handle, `x`, is the owning reference to our box. Rust knows that\n-`x` will go out of scope at the end of the block, and so it inserts a call to\n-deallocate the memory at the end of the scope. Because the compiler does this\n-for us, it's impossible to forget. We always have exactly one deallocation\n-  paired with each of our allocations.\n-\n-This is pretty straightforward, but what happens when we want to pass our box\n-to a function? Let's look at some code:\n-\n-```rust\n-fn main() {\n-    let x = Box::new(5);\n-\n-    add_one(x);\n-}\n-\n-fn add_one(mut num: Box<i32>) {\n-    *num += 1;\n+fn foo() {\n+    let v = vec![1, 2, 3];\n }\n ```\n \n-This code works, but it's not ideal. For example, let's add one more line of\n-code, where we print out the value of `x`:\n-\n-```{rust,ignore}\n-fn main() {\n-    let x = Box::new(5);\n+When `v` comes into scope, a new [`Vec<T>`][vect] is created. In this case, the\n+vector also allocates space on [the heap][heap], for the three elements. When\n+`v` goes out of scope at the end of `foo()`, Rust will clean up everything\n+related to the vector, even the heap-allocated memory. This happens\n+deterministically, at the end of the scope.\n \n-    add_one(x);\n-\n-    println!(\"{}\", x);\n-}\n+[vect]: ../std/vec/struct.Vec.html\n+[heap]: the-stack-and-the-heap.html\n+[bindings]: variable-bindings.html\n \n-fn add_one(mut num: Box<i32>) {\n-    *num += 1;\n-}\n-```\n+# Move semantics\n \n-This does not compile, and gives us an error:\n-\n-```text\n-error: use of moved value: `x`\n-   println!(\"{}\", x);\n-                  ^\n-```\n-\n-Remember, we need one deallocation for every allocation. When we try to pass\n-our box to `add_one`, we would have two handles to the memory: `x` in `main`,\n-and `num` in `add_one`. If we deallocated the memory when each handle went out\n-of scope, we would have two deallocations and one allocation, and that's wrong.\n-So when we call `add_one`, Rust defines `num` as the owner of the handle. And\n-so, now that we've given ownership to `num`, `x` is invalid. `x`'s value has\n-\"moved\" from `x` to `num`. Hence the error: use of moved value `x`.\n-\n-To fix this, we can have `add_one` give ownership back when it's done with the\n-box:\n+There\u2019s some more subtlety here, though: Rust ensures that there is _exactly\n+one_ binding to any given resource. For example, if we have a vector, we can\n+assign it to another binding:\n \n ```rust\n-fn main() {\n-    let x = Box::new(5);\n-\n-    let y = add_one(x);\n-\n-    println!(\"{}\", y);\n-}\n-\n-fn add_one(mut num: Box<i32>) -> Box<i32> {\n-    *num += 1;\n+let v = vec![1, 2, 3];\n \n-    num\n-}\n+let v2 = v;\n ```\n \n-This code will compile and run just fine. Now, we return a `box`, and so the\n-ownership is transferred back to `y` in `main`. We only have ownership for the\n-duration of our function before giving it back. This pattern is very common,\n-and so Rust introduces a concept to describe a handle which temporarily refers\n-to something another handle owns. It's called *borrowing*, and it's done with\n-*references*, designated by the `&` symbol.\n-\n-# Borrowing\n+But, if we try to use `v` afterwards, we get an error:\n \n-Here's the current state of our `add_one` function:\n+```rust,ignore\n+let v = vec![1, 2, 3];\n \n-```rust\n-fn add_one(mut num: Box<i32>) -> Box<i32> {\n-    *num += 1;\n+let v2 = v;\n \n-    num\n-}\n+println!(\"v[0] is: {}\", v[0]);\n ```\n \n-This function takes ownership, because it takes a `Box`, which owns its\n-contents. But then we give ownership right back.\n-\n-In the physical world, you can give one of your possessions to someone for a\n-short period of time. You still own your possession, you're just letting someone\n-else use it for a while. We call that *lending* something to someone, and that\n-person is said to be *borrowing* that something from you.\n-\n-Rust's ownership system also allows an owner to lend out a handle for a limited\n-period. This is also called *borrowing*. Here's a version of `add_one` which\n-borrows its argument rather than taking ownership:\n-\n-```rust\n-fn add_one(num: &mut i32) {\n-    *num += 1;\n-}\n-```\n-\n-This function borrows an `i32` from its caller, and then increments it. When\n-the function is over, and `num` goes out of scope, the borrow is over.\n-\n-We have to change our `main` a bit too:\n-\n-```rust\n-fn main() {\n-    let mut x = 5;\n-\n-    add_one(&mut x);\n+It looks like this:\n \n-    println!(\"{}\", x);\n-}\n-\n-fn add_one(num: &mut i32) {\n-    *num += 1;\n-}\n-```\n-\n-We don't need to assign the result of `add_one()` anymore, because it doesn't\n-return anything anymore. This is because we're not passing ownership back,\n-since we just borrow, not take ownership.\n-\n-# Lifetimes\n-\n-Lending out a reference to a resource that someone else owns can be\n-complicated, however. For example, imagine this set of operations:\n-\n-1. I acquire a handle to some kind of resource.\n-2. I lend you a reference to the resource.\n-3. I decide I'm done with the resource, and deallocate it, while you still have\n-   your reference.\n-4. You decide to use the resource.\n-\n-Uh oh! Your reference is pointing to an invalid resource. This is called a\n-*dangling pointer* or \"use after free,\" when the resource is memory.\n-\n-To fix this, we have to make sure that step four never happens after step\n-three. The ownership system in Rust does this through a concept called\n-*lifetimes*, which describe the scope that a reference is valid for.\n-\n-Remember the function that borrowed an `i32`? Let's look at it again.\n-\n-```rust\n-fn add_one(num: &mut i32) {\n-    *num += 1;\n-}\n+```text\n+error: use of moved value: `v`\n+println!(\"v[0] is: {}\", v[0]);\n+                        ^\n ```\n \n-Rust has a feature called *lifetime elision*, which allows you to not write\n-lifetime annotations in certain circumstances. This is one of them. We will\n-cover the others later. Without eliding the lifetimes, `add_one` looks like\n-this:\n+A similar thing happens if we define a function which takes ownership, and\n+try to use something after we\u2019ve passed it as an argument:\n \n-```rust\n-fn add_one<'a>(num: &'a mut i32) {\n-    *num += 1;\n+```rust,ignore\n+fn take(v: Vec<i32>) {\n+    // what happens here isn\u2019t important.\n }\n-```\n-\n-The `'a` is called a *lifetime*. Most lifetimes are used in places where\n-short names like `'a`, `'b` and `'c` are clearest, but it's often useful to\n-have more descriptive names. Let's dig into the syntax in a bit more detail:\n \n-```{rust,ignore}\n-fn add_one<'a>(...)\n-```\n+let v = vec![1, 2, 3];\n \n-This part _declares_ our lifetimes. This says that `add_one` has one lifetime,\n-`'a`. If we had two, it would look like this:\n+take(v);\n \n-```{rust,ignore}\n-fn add_two<'a, 'b>(...)\n+println!(\"v[0] is: {}\", v[0]);\n ```\n \n-Then in our parameter list, we use the lifetimes we've named:\n-\n-```{rust,ignore}\n-...(num: &'a mut i32)\n-```\n+Same error: \u201cuse of moved value.\u201d When we transfer ownership to something else,\n+we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need some sort of\n+special annotation here, it\u2019s the default thing that Rust does.\n \n-If you compare `&mut i32` to `&'a mut i32`, they're the same, it's just that the\n-lifetime `'a` has snuck in between the `&` and the `mut i32`. We read `&mut i32` as \"a\n-mutable reference to an i32\" and `&'a mut i32` as \"a mutable reference to an i32 with the lifetime 'a.'\"\n+## The details\n \n-Why do lifetimes matter? Well, for example, here's some code:\n+The reason that we cannot use a binding after we\u2019ve moved it is subtle, but\n+important. When we write code like this:\n \n ```rust\n-struct Foo<'a> {\n-    x: &'a i32,\n-}\n+let v = vec![1, 2, 3];\n \n-fn main() {\n-    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n-    let f = Foo { x: y };\n-\n-    println!(\"{}\", f.x);\n-}\n+let v2 = v;\n ```\n \n-As you can see, `struct`s can also have lifetimes. In a similar way to functions,\n-\n-```{rust}\n-struct Foo<'a> {\n-# x: &'a i32,\n-# }\n-```\n+The first line creates some data for the vector on the [stack][sh], `v`. The\n+vector\u2019s data, however, is stored on the [heap][sh], and so it contains a\n+pointer to that data. When we move `v` to `v2`, it creates a copy of that pointer,\n+for `v2`. Which would mean two pointers to the contents of the vector on the\n+heap. That would be a problem: it would violate Rust\u2019s safety guarantees by\n+introducing a data race. Therefore, Rust forbids using `v` after we\u2019ve done the\n+move.\n \n-declares a lifetime, and\n-\n-```rust\n-# struct Foo<'a> {\n-x: &'a i32,\n-# }\n-```\n+[sh]: the-stack-and-the-heap.html\n \n-uses it. So why do we need a lifetime here? We need to ensure that any reference\n-to a `Foo` cannot outlive the reference to an `i32` it contains.\n+It\u2019s also important to note that optimizations may remove the actual copy of\n+the bytes, depending on circumstances. So it may not be as inefficient as it\n+initially seems.\n \n-## Thinking in scopes\n+## `Copy` types\n \n-A way to think about lifetimes is to visualize the scope that a reference is\n-valid for. For example:\n+We\u2019ve established that when ownership is transferred to another binding, you\n+cannot use the original binding. However, there\u2019s a [trait][traits] that changes this\n+behavior, and it\u2019s called `Copy`. We haven\u2019t discussed traits yet, but for now,\n+you can think of them as an annotation to a particular type that adds extra\n+behavior. For example:\n \n ```rust\n-fn main() {\n-    let y = &5;     // -+ y goes into scope\n-                    //  |\n-    // stuff        //  |\n-                    //  |\n-}                   // -+ y goes out of scope\n-```\n-\n-Adding in our `Foo`:\n-\n-```rust\n-struct Foo<'a> {\n-    x: &'a i32,\n-}\n-\n-fn main() {\n-    let y = &5;           // -+ y goes into scope\n-    let f = Foo { x: y }; // -+ f goes into scope\n-    // stuff              //  |\n-                          //  |\n-}                         // -+ f and y go out of scope\n-```\n+let v = 1;\n \n-Our `f` lives within the scope of `y`, so everything works. What if it didn't?\n-This code won't work:\n+let v2 = v;\n \n-```{rust,ignore}\n-struct Foo<'a> {\n-    x: &'a i32,\n-}\n-\n-fn main() {\n-    let x;                    // -+ x goes into scope\n-                              //  |\n-    {                         //  |\n-        let y = &5;           // ---+ y goes into scope\n-        let f = Foo { x: y }; // ---+ f goes into scope\n-        x = &f.x;             //  | | error here\n-    }                         // ---+ f and y go out of scope\n-                              //  |\n-    println!(\"{}\", x);        //  |\n-}                             // -+ x goes out of scope\n+println!(\"v is: {}\", v);\n ```\n \n-Whew! As you can see here, the scopes of `f` and `y` are smaller than the scope\n-of `x`. But when we do `x = &f.x`, we make `x` a reference to something that's\n-about to go out of scope.\n+In this case, `v` is an `i32`, which implements the `Copy` trait. This means\n+that, just like a move, when we assign `v` to `v2`, a copy of the data is made.\n+But, unlike a move, we can still use `v` afterward. This is because an `i32`\n+has no pointers to data somewhere else, copying it is a full copy.\n \n-Named lifetimes are a way of giving these scopes a name. Giving something a\n-name is the first step towards being able to talk about it.\n+We will discuss how to make your own types `Copy` in the [traits][traits]\n+section.\n \n-## 'static\n+[traits]: traits.html\n \n-The lifetime named *static* is a special lifetime. It signals that something\n-has the lifetime of the entire program. Most Rust programmers first come across\n-`'static` when dealing with strings:\n+# More than ownership\n \n-```rust\n-let x: &'static str = \"Hello, world.\";\n-```\n-\n-String literals have the type `&'static str` because the reference is always\n-alive: they are baked into the data segment of the final binary. Another\n-example are globals:\n+Of course, if we had to hand ownership back with every function we wrote:\n \n ```rust\n-static FOO: i32 = 5;\n-let x: &'static i32 = &FOO;\n-```\n-\n-This adds an `i32` to the data segment of the binary, and `x` is a reference\n-to it.\n+fn foo(v: Vec<i32>) -> Vec<i32> {\n+    // do stuff with v\n \n-# Shared Ownership\n-\n-In all the examples we've considered so far, we've assumed that each handle has\n-a singular owner. But sometimes, this doesn't work. Consider a car. Cars have\n-four wheels. We would want a wheel to know which car it was attached to. But\n-this won't work:\n-\n-```{rust,ignore}\n-struct Car {\n-    name: String,\n-}\n-\n-struct Wheel {\n-    size: i32,\n-    owner: Car,\n-}\n-\n-fn main() {\n-    let car = Car { name: \"DeLorean\".to_string() };\n-\n-    for _ in 0..4 {\n-        Wheel { size: 360, owner: car };\n-    }\n+    // hand back ownership\n+    v\n }\n ```\n \n-We try to make four `Wheel`s, each with a `Car` that it's attached to. But the\n-compiler knows that on the second iteration of the loop, there's a problem:\n-\n-```text\n-error: use of moved value: `car`\n-    Wheel { size: 360, owner: car };\n-                              ^~~\n-note: `car` moved here because it has type `Car`, which is non-copyable\n-    Wheel { size: 360, owner: car };\n-                              ^~~\n-```\n-\n-We need our `Car` to be pointed to by multiple `Wheel`s. We can't do that with\n-`Box<T>`, because it has a single owner. We can do it with `Rc<T>` instead:\n+This would get very tedius. It gets worse the more things we want to take ownership of:\n \n ```rust\n-use std::rc::Rc;\n+fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n+    // do stuff with v1 and v2\n \n-struct Car {\n-    name: String,\n+    // hand back ownership, and the result of our function\n+    (v1, v2, 42)\n }\n \n-struct Wheel {\n-    size: i32,\n-    owner: Rc<Car>,\n-}\n+let v1 = vec![1, 2, 3];\n+let v2 = vec![1, 2, 3];\n \n-fn main() {\n-    let car = Car { name: \"DeLorean\".to_string() };\n-\n-    let car_owner = Rc::new(car);\n-\n-    for _ in 0..4 {\n-        Wheel { size: 360, owner: car_owner.clone() };\n-    }\n-}\n+let (v1, v2, answer) = foo(v1, v2);\n ```\n \n-We wrap our `Car` in an `Rc<T>`, getting an `Rc<Car>`, and then use the\n-`clone()` method to make new references. We've also changed our `Wheel` to have\n-an `Rc<Car>` rather than just a `Car`.\n-\n-This is the simplest kind of multiple ownership possible. For example, there's\n-also `Arc<T>`, which uses more expensive atomic instructions to be the\n-thread-safe counterpart of `Rc<T>`.\n-\n-## Lifetime Elision\n-\n-Rust supports powerful local type inference in function bodies, but it\u2019s\n-forbidden in item signatures to allow reasoning about the types just based in\n-the item signature alone. However, for ergonomic reasons a very restricted\n-secondary inference algorithm called \u201clifetime elision\u201d applies in function\n-signatures. It infers only based on the signature components themselves and not\n-based on the body of the function, only infers lifetime parameters, and does\n-this with only three easily memorizable and unambiguous rules. This makes\n-lifetime elision a shorthand for writing an item signature, while not hiding\n-away the actual types involved as full local inference would if applied to it.\n-\n-When talking about lifetime elision, we use the term *input lifetime* and\n-*output lifetime*. An *input lifetime* is a lifetime associated with a parameter\n-of a function, and an *output lifetime* is a lifetime associated with the return\n-value of a function. For example, this function has an input lifetime:\n-\n-```{rust,ignore}\n-fn foo<'a>(bar: &'a str)\n-```\n-\n-This one has an output lifetime:\n-\n-```{rust,ignore}\n-fn foo<'a>() -> &'a str\n-```\n-\n-This one has a lifetime in both positions:\n-\n-```{rust,ignore}\n-fn foo<'a>(bar: &'a str) -> &'a str\n-```\n+Ugh! The return type, return line, and calling the function gets way more\n+complicated.\n \n-Here are the three rules:\n+Luckily, Rust offers a feature, borrowing, which helps us solve this problem.\n+It\u2019s the topic of the next section!\n \n-* Each elided lifetime in a function's arguments becomes a distinct lifetime\n-  parameter.\n \n-* If there is exactly one input lifetime, elided or not, that lifetime is\n-  assigned to all elided lifetimes in the return values of that function.\n \n-* If there are multiple input lifetimes, but one of them is `&self` or `&mut\n-  self`, the lifetime of `self` is assigned to all elided output lifetimes.\n \n-Otherwise, it is an error to elide an output lifetime.\n \n-### Examples\n \n-Here are some examples of functions with elided lifetimes.  We've paired each\n-example of an elided lifetime with its expanded form.\n \n-```{rust,ignore}\n-fn print(s: &str); // elided\n-fn print<'a>(s: &'a str); // expanded\n \n-fn debug(lvl: u32, s: &str); // elided\n-fn debug<'a>(lvl: u32, s: &'a str); // expanded\n \n-// In the preceding example, `lvl` doesn't need a lifetime because it's not a\n-// reference (`&`). Only things relating to references (such as a `struct`\n-// which contains a reference) need lifetimes.\n-\n-fn substr(s: &str, until: u32) -> &str; // elided\n-fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded\n-\n-fn get_str() -> &str; // ILLEGAL, no inputs\n-\n-fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs\n-fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is unclear\n-\n-fn get_mut(&mut self) -> &mut T; // elided\n-fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded\n-\n-fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command // elided\n-fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded\n-\n-fn new(buf: &mut [u8]) -> BufWriter; // elided\n-fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> // expanded\n-```\n \n-# Related Resources\n \n-Coming Soon."}, {"sha": "266c1cafdee57035e9920785e79f1b54107a9cd7", "filename": "src/doc/trpl/patterns.md", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpatterns.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -70,8 +70,7 @@ This prints `something else`\n \n # Bindings\n \n-If you\u2019re matching multiple things, via a `|` or a `...`, you can bind\n-the value to a name with `@`:\n+You can bind values to names with `@`:\n \n ```rust\n let x = 1;\n@@ -82,7 +81,36 @@ match x {\n }\n ```\n \n-This prints `got a range element 1`.\n+This prints `got a range element 1`. This is useful when you want to\n+do a complicated match of part of a data structure:\n+\n+```rust\n+#[derive(Debug)]\n+struct Person {\n+    name: Option<String>,\n+}\n+\n+let name = \"Steve\".to_string();\n+let mut x: Option<Person> = Some(Person { name: Some(name) });\n+match x {\n+    Some(Person { name: ref a @ Some(_), .. }) => println!(\"{:?}\", a),\n+    _ => {}\n+}\n+```\n+\n+This prints `Some(\"Steve\")`: We\u2019ve bound the inner `name` to `a`.\n+\n+If you use `@` with `|`, you need to make sure the name is bound in each part\n+of the pattern:\n+\n+```rust\n+let x = 5;\n+\n+match x {\n+    e @ 1 ... 5 | e @ 8 ... 10 => println!(\"got a range element {}\", e),\n+    _ => println!(\"anything\"),\n+}\n+```\n \n # Ignoring variants\n "}, {"sha": "e017e222c74177b6f80a7b529220405e8ac136fe", "filename": "src/doc/trpl/primitive-types.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fprimitive-types.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -248,6 +248,14 @@ or \u201cbreaks up\u201d the tuple, and assigns the bits to three bindings.\n \n This pattern is very powerful, and we\u2019ll see it repeated more later.\n \n+You can disambiguate a single-element tuple from a value in parentheses with a\n+comma:\n+\n+```\n+(0,); // single-element tuple\n+(0); // zero in parentheses\n+```\n+\n ## Tuple Indexing\n \n You can also access fields of a tuple with indexing syntax:"}, {"sha": "4a37af3c227827f779157a1d2f44dcb54df03126", "filename": "src/doc/trpl/raw-pointers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fraw-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fraw-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fraw-pointers.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -80,7 +80,7 @@ Raw pointers are useful for FFI: Rust\u2019s `*const T` and `*mut T` are similar to\n C\u2019s `const T*` and `T*`, respectfully. For more about this use, consult the\n [FFI chapter][ffi].\n \n-[ffi]: ffi.md\n+[ffi]: ffi.html\n \n # References and raw pointers\n "}, {"sha": "8bb3f94760bc9049b64b99edb406347cfa296d59", "filename": "src/doc/trpl/references-and-borrowing.md", "status": "modified", "additions": 334, "deletions": 1, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -1,3 +1,336 @@\n % References and Borrowing\n \n-Coming Soon! Until then, check out the [ownership](ownership.html) chapter.\n+This guide is one of three presenting Rust\u2019s ownership system. This is one of\n+Rust\u2019s most unique and compelling features, with which Rust developers should\n+become quite acquainted. Ownership is how Rust achieves its largest goal,\n+memory safety. There are a few distinct concepts, each with its own\n+chapter:\n+\n+* [ownership][ownership], ownership, the key concept\n+* borrowing, which you\u2019re reading now\n+* [lifetimes][lifetimes], an advanced concept of borrowing\n+\n+These three chapters are related, and in order. You\u2019ll need all three to fully\n+understand the ownership system.\n+\n+[ownership]: ownership.html\n+[lifetimes]: lifetimes.html\n+\n+# Meta\n+\n+Before we get to the details, two important notes about the ownership system.\n+\n+Rust has a focus on safety and speed. It accomplishes these goals through many\n+\u2018zero-cost abstractions\u2019, which means that in Rust, abstractions cost as little\n+as possible in order to make them work. The ownership system is a prime example\n+of a zero cost abstraction. All of the analysis we\u2019ll talk about in this guide\n+is _done at compile time_. You do not pay any run-time cost for any of these\n+features.\n+\n+However, this system does have a certain cost: learning curve. Many new users\n+to Rust experience something we like to call \u2018fighting with the borrow\n+checker\u2019, where the Rust compiler refuses to compile a program that the author\n+thinks is valid. This often happens because the programmer\u2019s mental model of\n+how ownership should work doesn\u2019t match the actual rules that Rust implements.\n+You probably will experience similar things at first. There is good news,\n+however: more experienced Rust developers report that once they work with the\n+rules of the ownership system for a period of time, they fight the borrow\n+checker less and less.\n+\n+With that in mind, let\u2019s learn about borrowing.\n+\n+# Borrowing\n+\n+At the end of the [ownership][ownership] section, we had a nasty function that looked\n+like this:\n+\n+```rust\n+fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n+    // do stuff with v1 and v2\n+\n+    // hand back ownership, and the result of our function\n+    (v1, v2, 42)\n+}\n+\n+let v1 = vec![1, 2, 3];\n+let v2 = vec![1, 2, 3];\n+\n+let (v1, v2, answer) = foo(v1, v2);\n+```\n+\n+This is not idiomatic Rust, however, as it doesn\u2019t take advantage of borrowing. Here\u2019s\n+the first step:\n+\n+```rust\n+fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n+    // do stuff with v1 and v2\n+\n+    // return the answer\n+    42\n+}\n+\n+let v1 = vec![1, 2, 3];\n+let v2 = vec![1, 2, 3];\n+\n+let answer = foo(&v1, &v2);\n+\n+// we can use v1 and v2 here!\n+```\n+\n+Instead of taking `Vec<i32>`s as our arguments, we take a reference:\n+`&Vec<i32>`. And instead of passing `v1` and `v2` directly, we pass `&v1` and\n+`&v2`. We call the `&T` type a \u2018reference\u2019, and rather than owning the resource,\n+it borrows ownership. A binding that borrows something does not deallocate the\n+resource when it goes out of scope. This means that after the call to `foo()`,\n+we can use our original bindings again.\n+\n+References are immutable, just like bindings. This means that inside of `foo()`,\n+the vectors can\u2019t be changed at all:\n+\n+```rust,ignore\n+fn foo(v: &Vec<i32>) {\n+     v.push(5);\n+}\n+\n+let v = vec![];\n+\n+foo(&v);\n+```\n+\n+errors with:\n+\n+```text\n+error: cannot borrow immutable borrowed content `*v` as mutable\n+v.push(5);\n+^\n+```\n+\n+Pushing a value mutates the vector, and so we aren\u2019t allowed to do it.\n+\n+# &mut references\n+\n+There\u2019s a second kind of reference: `&mut T`. A \u2018mutable reference\u2019 allows you\n+to mutate the resource you\u2019re borrowing. For example:\n+\n+```rust\n+let mut x = 5;\n+{\n+    let y = &mut x;\n+    *y += 1;\n+}\n+println!(\"{}\", x);\n+```\n+\n+This will print `6`. We make `y` a mutable reference to `x`, then add one to\n+the thing `y` points at. You\u2019ll notice that `x` had to be marked `mut` as well,\n+if it wasn\u2019t, we couldn\u2019t take a mutable borrow to an immutable value.\n+\n+Otherwise, `&mut` references are just like references. There _is_ a large\n+difference between the two, and how they interact, though. You can tell\n+something is fishy in the above example, because we need that extra scope, with\n+the `{` and `}`. If we remove them, we get an error:\n+\n+```text\n+error: cannot borrow `x` as immutable because it is also borrowed as mutable\n+    println!(\"{}\", x);\n+                   ^\n+note: previous borrow of `x` occurs here; the mutable borrow prevents\n+subsequent moves, borrows, or modification of `x` until the borrow ends\n+        let y = &mut x;\n+                     ^\n+note: previous borrow ends here\n+fn main() {\n+\n+}\n+^\n+```\n+\n+As it turns out, there are rules.\n+\n+# The Rules\n+\n+Here\u2019s the rules about borrowing in Rust:\n+\n+First, any borrow must last for a smaller scope than the owner. Second, you may\n+have one or the other of these two kinds of borrows, but not both at the same\n+time:\n+\n+* 0 to N references (`&T`) to a resource.\n+* exactly one mutable reference (`&mut T`)\n+\n+\n+You may notice that this is very similar, though not exactly the same as,\n+to the definition of a data race:\n+\n+> There is a \u2018data race\u2019 when two or more pointers access the same memory\n+> location at the same time, where at least one of them is writing, and the\n+> operations are not synchronized.\n+\n+With references, you may have as many as you\u2019d like, since none of them are\n+writing. If you are writing, you need two or more pointers to the same memory,\n+and you can only have one `&mut` at a time. This is how Rust prevents data\n+races at compile time: we\u2019ll get errors if we break the rules.\n+\n+With this in mind, let\u2019s consider our example again.\n+\n+## Thinking in scopes\n+\n+Here\u2019s the code:\n+\n+```rust,ignore\n+let mut x = 5;\n+let y = &mut x;\n+\n+*y += 1;\n+\n+println!(\"{}\", x);\n+```\n+\n+This code gives us this error:\n+\n+```text\n+error: cannot borrow `x` as immutable because it is also borrowed as mutable\n+    println!(\"{}\", x);\n+                   ^\n+```\n+\n+This is because we\u2019ve violated the rules: we have a `&mut T` pointing to `x`,\n+and so we aren\u2019t allowed to create any `&T`s. One or the other. The note\n+hints at how to think about this problem:\n+\n+```text\n+note: previous borrow ends here\n+fn main() {\n+\n+}\n+^\n+```\n+\n+In other words, the mutable borow is held through the rest of our example. What\n+we want is for the mutable borrow to end _before_ we try to call `println!` and\n+make an immutable borrow. In Rust, borrowing is tied to the scope that the\n+borrow is valid for. And our scopes look like this:\n+\n+```rust,ignore\n+let mut x = 5;\n+\n+let y = &mut x;    // -+ &mut borrow of x starts here\n+                   //  |\n+*y += 1;           //  |\n+                   //  |\n+println!(\"{}\", x); // -+ - try to borrow x here\n+                   // -+ &mut borrow of x ends here\n+```\n+\n+The scopes conflict: we can\u2019t make an `&x` while `y` is in scope.\n+\n+So when we add the curly braces:\n+\n+```rust\n+let mut x = 5;\n+\n+{                   \n+    let y = &mut x; // -+ &mut borrow starts here\n+    *y += 1;        //  |\n+}                   // -+ ... and ends here\n+\n+println!(\"{}\", x);  // <- try to borrow x here\n+```\n+\n+There\u2019s no problem. Our mutable borrow goes out of scope before we create an\n+immutable one. But scope is the key to seeing how long a borrow lasts for.\n+\n+## Issues borrowing prevents\n+\n+Why have these restrictive rules? Well, as we noted, these rules prevent data\n+races. What kinds of issues do data races cause? Here\u2019s a few.\n+\n+### Iterator invalidation\n+\n+One example is \u2018iterator invalidation\u2019, which happens when you try to mutate a\n+collection that you\u2019re iterating over. Rust\u2019s borrow checker prevents this from\n+happening:\n+\n+```rust\n+let mut v = vec![1, 2, 3];\n+\n+for i in &v {\n+    println!(\"{}\", i);\n+}\n+```\n+\n+This prints out one through three. As we iterate through the vectors, we\u2019re\n+only given references to the elements. And `v` is itself borrowed as immutable,\n+which means we can\u2019t change it while we\u2019re iterating:\n+\n+```rust,ignore\n+let mut v = vec![1, 2, 3];\n+\n+for i in &v {\n+    println!(\"{}\", i);\n+    v.push(34);\n+}\n+```\n+\n+Here\u2019s the error:\n+\n+```text\n+error: cannot borrow `v` as mutable because it is also borrowed as immutable\n+    v.push(34);\n+    ^\n+note: previous borrow of `v` occurs here; the immutable borrow prevents\n+subsequent moves or mutable borrows of `v` until the borrow ends\n+for i in &v {\n+          ^\n+note: previous borrow ends here\n+for i in &v {\n+    println!(\u201c{}\u201d, i);\n+    v.push(34);\n+}\n+^\n+```\n+\n+We can\u2019t modify `v` because it\u2019s borrowed by the loop.\n+\n+### use after free\n+\n+References must live as long as the resource they refer to. Rust will check the\n+scopes of your references to ensure that this is true.\n+\n+If Rust didn\u2019t check that this property, we could accidentally use a reference\n+which was invalid. For example:\n+\n+```rust,ignore\n+let y: &i32;\n+{ \n+    let x = 5;\n+    y = &x;\n+}\n+\n+println!(\"{}\", y);\n+```\n+\n+We get this error:\n+\n+error: `x` does not live long enough\n+    y = &x;\n+         ^\n+note: reference must be valid for the block suffix following statement 0 at\n+2:16...\n+let y: &i32;\n+{ \n+    let x = 5;\n+    y = &x;\n+}\n+\n+note: ...but borrowed value is only valid for the block suffix following\n+statement 0 at 4:18\n+    let x = 5;\n+    y = &x;\n+}\n+```\n+\n+In other words, `y` is only valid for the scope where `x` exists. As soon as\n+`x` goes away, it becomes invalid to refer to it. As such, the error says that\n+the borrow \u2018doesn\u2019t live long enough\u2019 because it\u2019s not valid for the right\n+amount of time."}, {"sha": "61a6ec3eb3f4d2e3f770dc53a7638a0c2b62b2b1", "filename": "src/doc/trpl/strings.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstrings.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -73,13 +73,13 @@ individual bytes, or as codepoints:\n let hachiko = \"\u5fe0\u72ac\u30cf\u30c1\u516c\";\n \n for b in hachiko.as_bytes() {\n-print!(\"{}, \", b);\n+    print!(\"{}, \", b);\n }\n \n println!(\"\");\n \n for c in hachiko.chars() {\n-print!(\"{}, \", c);\n+    print!(\"{}, \", c);\n }\n \n println!(\"\");"}, {"sha": "51ee4bf0cdc2833f1285d89bb4f118f3d7c0b751", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -192,7 +192,7 @@ Here\u2019s the error:\n ```text\n error: type `std::fs::File` does not implement any method in scope named `write`\n \n-let result = f.write(b\u201dwhatever\u201d);\n+let result = f.write(b\"whatever\");\n                ^~~~~~~~~~~~~~~~~~\n ```\n "}, {"sha": "fdb9c33a2b0b5d7676c967eb4bf19c324b953f9b", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -101,7 +101,7 @@ Rust has a feature called \u2018`static mut`\u2019 which allows for mutable global sta\n Doing so can cause a data race, and as such is inherently not safe. For more\n details, see the [static][static] section of the book.\n \n-[static]: static.html\n+[static]: const-and-static.html#static\n \n ## Dereference a raw pointer\n "}, {"sha": "b1a2bb5d4172f16ef56e7279ac7ed8dba2d46b3d", "filename": "src/doc/trpl/unsized-types.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Funsized-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fdoc%2Ftrpl%2Funsized-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsized-types.md?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -38,9 +38,11 @@ impl Foo for &str {\n ```\n \n Meaning, this implementation would only work for [references][ref], and not\n-other types of pointers. With this `impl`, all pointers, including (at some\n-point, there are some bugs to fix first) user-defined custom smart pointers,\n-can use this `impl`.\n+other types of pointers. With the `impl for str`, all pointers, including (at\n+some point, there are some bugs to fix first) user-defined custom smart\n+pointers, can use this `impl`.\n+\n+[ref]: references-and-borrowing.html\n \n # ?Sized\n "}, {"sha": "855d89bc8a35eb42771d73cd8ee000fc23c6d285", "filename": "src/error-index-generator/main.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ferror-index-generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ferror-index-generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror-index-generator%2Fmain.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_private, rustdoc)]\n+\n+extern crate syntax;\n+extern crate rustdoc;\n+extern crate serialize as rustc_serialize;\n+\n+use std::collections::BTreeMap;\n+use std::fs::{read_dir, File};\n+use std::io::{Read, Write};\n+use std::path::Path;\n+use std::error::Error;\n+\n+use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap};\n+\n+use rustdoc::html::markdown::Markdown;\n+use rustc_serialize::json;\n+\n+/// Load all the metadata files from `metadata_dir` into an in-memory map.\n+fn load_all_errors(metadata_dir: &Path) -> Result<ErrorMetadataMap, Box<Error>> {\n+    let mut all_errors = BTreeMap::new();\n+\n+    for entry in try!(read_dir(metadata_dir)) {\n+        let path = try!(entry).path();\n+\n+        let mut metadata_str = String::new();\n+        try!(\n+            File::open(&path).and_then(|mut f|\n+            f.read_to_string(&mut metadata_str))\n+        );\n+\n+        let some_errors: ErrorMetadataMap = try!(json::decode(&metadata_str));\n+\n+        for (err_code, info) in some_errors {\n+            all_errors.insert(err_code, info);\n+        }\n+    }\n+\n+    Ok(all_errors)\n+}\n+\n+/// Output an HTML page for the errors in `err_map` to `output_path`.\n+fn render_error_page(err_map: &ErrorMetadataMap, output_path: &Path) -> Result<(), Box<Error>> {\n+    let mut output_file = try!(File::create(output_path));\n+\n+    try!(write!(&mut output_file,\n+r##\"<!DOCTYPE html>\n+<html>\n+<head>\n+<title>Rust Compiler Error Index</title>\n+<meta charset=\"utf-8\">\n+<!-- Include rust.css after main.css so its rules take priority. -->\n+<link rel=\"stylesheet\" type=\"text/css\" href=\"main.css\"/>\n+<link rel=\"stylesheet\" type=\"text/css\" href=\"rust.css\"/>\n+<style>\n+.error-undescribed {{\n+    display: none;\n+}}\n+</style>\n+</head>\n+<body>\n+\"##\n+    ));\n+\n+    try!(write!(&mut output_file, \"<h1>Rust Compiler Error Index</h1>\\n\"));\n+\n+    for (err_code, info) in err_map.iter() {\n+        // Enclose each error in a div so they can be shown/hidden en masse.\n+        let desc_desc = match info.description {\n+            Some(_) => \"error-described\",\n+            None => \"error-undescribed\"\n+        };\n+        let use_desc = match info.use_site {\n+            Some(_) => \"error-used\",\n+            None => \"error-unused\"\n+        };\n+        try!(write!(&mut output_file, \"<div class=\\\"{} {}\\\">\", desc_desc, use_desc));\n+\n+        // Error title (with self-link).\n+        try!(write!(&mut output_file,\n+            \"<h2 id=\\\"{0}\\\" class=\\\"section-header\\\"><a href=\\\"#{0}\\\">{0}</a></h2>\\n\",\n+            err_code\n+        ));\n+\n+        // Description rendered as markdown.\n+        match info.description {\n+            Some(ref desc) => try!(write!(&mut output_file, \"{}\", Markdown(desc))),\n+            None => try!(write!(&mut output_file, \"<p>No description.</p>\\n\"))\n+        }\n+\n+        try!(write!(&mut output_file, \"</div>\\n\"));\n+    }\n+\n+    try!(write!(&mut output_file, \"</body>\\n</html>\"));\n+\n+    Ok(())\n+}\n+\n+fn main_with_result() -> Result<(), Box<Error>> {\n+    let metadata_dir = get_metadata_dir();\n+    let err_map = try!(load_all_errors(&metadata_dir));\n+    try!(render_error_page(&err_map, Path::new(\"doc/error-index.html\")));\n+    Ok(())\n+}\n+\n+fn main() {\n+    if let Err(e) = main_with_result() {\n+        panic!(\"{}\", e.description());\n+    }\n+}"}, {"sha": "a12c3298cb35b93b057ed019f97ea208d4665f9d", "filename": "src/etc/extract_grammar.py", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Fetc%2Fextract_grammar.py", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Fetc%2Fextract_grammar.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fextract_grammar.py?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -1,156 +0,0 @@\n-#!/usr/bin/env python\n-#\n-# Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-# This script is for extracting the grammar from the rust docs.\n-\n-import fileinput\n-\n-collections = {\"gram\": [],\n-               \"keyword\": [],\n-               \"reserved\": [],\n-               \"binop\": [],\n-               \"unop\": []}\n-\n-\n-in_coll = False\n-coll = \"\"\n-\n-for line in fileinput.input(openhook=fileinput.hook_encoded(\"utf-8\")):\n-    if in_coll:\n-        if line.startswith(\"~~~~\"):\n-            in_coll = False\n-        else:\n-            if coll in [\"keyword\", \"reserved\", \"binop\", \"unop\"]:\n-                for word in line.split():\n-                    if word not in collections[coll]:\n-                        collections[coll].append(word)\n-            else:\n-                collections[coll].append(line)\n-\n-    else:\n-        if line.startswith(\"~~~~\"):\n-            for cname in collections:\n-                if (\".\" + cname) in line:\n-                    coll = cname\n-                    in_coll = True\n-                    break\n-\n-# Define operator symbol-names here\n-\n-tokens = [\"non_star\", \"non_slash\", \"non_eol\",\n-          \"non_single_quote\", \"non_double_quote\", \"ident\"]\n-\n-symnames = {\n-    \".\": \"dot\",\n-    \"+\": \"plus\",\n-    \"-\": \"minus\",\n-    \"/\": \"slash\",\n-    \"*\": \"star\",\n-    \"%\": \"percent\",\n-\n-    \"~\": \"tilde\",\n-    \"@\": \"at\",\n-\n-    \"!\": \"not\",\n-    \"&\": \"and\",\n-    \"|\": \"or\",\n-    \"^\": \"xor\",\n-\n-    \"<<\": \"lsl\",\n-    \">>\": \"lsr\",\n-    \">>>\": \"asr\",\n-\n-    \"&&\": \"andand\",\n-    \"||\": \"oror\",\n-\n-    \"<\": \"lt\",\n-    \"<=\": \"le\",\n-    \"==\": \"eqeq\",\n-    \">=\": \"ge\",\n-    \">\": \"gt\",\n-\n-    \"=\": \"eq\",\n-\n-    \"+=\": \"plusequal\",\n-    \"-=\": \"minusequal\",\n-    \"/=\": \"divequal\",\n-    \"*=\": \"starequal\",\n-    \"%=\": \"percentequal\",\n-\n-    \"&=\": \"andequal\",\n-    \"|=\": \"orequal\",\n-    \"^=\": \"xorequal\",\n-\n-    \">>=\": \"lsrequal\",\n-    \">>>=\": \"asrequal\",\n-    \"<<=\": \"lslequal\",\n-\n-    \"::\": \"coloncolon\",\n-\n-    \"->\": \"rightarrow\",\n-    \"<-\": \"leftarrow\",\n-    \"<->\": \"swaparrow\",\n-\n-    \"//\": \"linecomment\",\n-    \"/*\": \"openblockcomment\",\n-    \"*/\": \"closeblockcomment\",\n-    \"macro_rules\": \"macro_rules\",\n-    \"=>\": \"eg\",\n-    \"..\": \"dotdot\",\n-    \",\": \"comma\"\n-}\n-\n-lines = []\n-\n-for line in collections[\"gram\"]:\n-    line2 = \"\"\n-    for word in line.split():\n-        # replace strings with keyword-names or symbol-names from table\n-        if word.startswith(\"\\\"\"):\n-            word = word[1:-1]\n-            if word in symnames:\n-                word = symnames[word]\n-            else:\n-                for ch in word:\n-                    if not ch.isalpha():\n-                        raise Exception(\"non-alpha apparent keyword: \"\n-                                        + word)\n-                if word not in tokens:\n-                    if (word in collections[\"keyword\"] or\n-                            word in collections[\"reserved\"]):\n-                        tokens.append(word)\n-                    else:\n-                        raise Exception(\"unknown keyword/reserved word: \"\n-                                        + word)\n-\n-        line2 += \" \" + word\n-    lines.append(line2)\n-\n-\n-for word in collections[\"keyword\"] + collections[\"reserved\"]:\n-    if word not in tokens:\n-        tokens.append(word)\n-\n-for sym in collections[\"unop\"] + collections[\"binop\"] + symnames.keys():\n-    word = symnames[sym]\n-    if word not in tokens:\n-        tokens.append(word)\n-\n-\n-print(\"%start parser, token;\")\n-print(\"%%token %s ;\" % (\"\\n\\t, \".join(tokens)))\n-for coll in [\"keyword\", \"reserved\"]:\n-    print(\"%s: %s ; \" % (coll, \"\\n\\t| \".join(collections[coll])))\n-for coll in [\"binop\", \"unop\"]:\n-    print(\"%s: %s ; \" % (coll, \"\\n\\t| \".join([symnames[x]\n-                                              for x in collections[coll]])))\n-print(\"\\n\".join(lines))"}, {"sha": "f062d33f25e25514423e15c72e7f68148f59adf4", "filename": "src/grammar/RustLexer.g4", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fgrammar%2FRustLexer.g4", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fgrammar%2FRustLexer.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FRustLexer.g4?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -8,14 +8,14 @@ lexer grammar RustLexer;\n \n \n tokens {\n-    EQ, LT, LE, EQEQ, NE, GE, GT, ANDAND, OROR, NOT, TILDE, PLUT,\n+    EQ, LT, LE, EQEQ, NE, GE, GT, ANDAND, OROR, NOT, TILDE, PLUS,\n     MINUS, STAR, SLASH, PERCENT, CARET, AND, OR, SHL, SHR, BINOP,\n     BINOPEQ, AT, DOT, DOTDOT, DOTDOTDOT, COMMA, SEMI, COLON,\n     MOD_SEP, RARROW, FAT_ARROW, LPAREN, RPAREN, LBRACKET, RBRACKET,\n-    LBRACE, RBRACE, POUND, DOLLAR, UNDERSCORE, LIT_CHAR,\n+    LBRACE, RBRACE, POUND, DOLLAR, UNDERSCORE, LIT_CHAR, LIT_BYTE,\n     LIT_INTEGER, LIT_FLOAT, LIT_STR, LIT_STR_RAW, LIT_BINARY,\n-    LIT_BINARY_RAW, IDENT, LIFETIME, WHITESPACE, DOC_COMMENT,\n-    COMMENT, SHEBANG\n+    LIT_BINARY_RAW, QUESTION, IDENT, LIFETIME, WHITESPACE, DOC_COMMENT,\n+    COMMENT, SHEBANG, UTF8_BOM\n }\n \n import xidstart , xidcontinue;"}, {"sha": "10b8abfc78606ddf844d9be66560d9d3737cfd3d", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -111,7 +111,7 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"LIT_BINARY_RAW\"    => token::Literal(token::BinaryRaw(Name(0), 0), None),\n             \"QUESTION\"          => token::Question,\n             \"SHEBANG\"           => token::Shebang(Name(0)),\n-            _                   => continue,\n+            _                   => panic!(\"Bad token str `{}`\", val),\n         };\n \n         res.insert(num.to_string(), tok);"}, {"sha": "8c3c21a89023dc62322d1b0f8e21167225ba2a61", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -31,7 +31,7 @@\n //!\n //! # Examples\n //!\n-//! Sharing some immutable data between tasks:\n+//! Sharing some immutable data between threads:\n //!\n //! ```no_run\n //! use std::sync::Arc;\n@@ -48,7 +48,7 @@\n //! }\n //! ```\n //!\n-//! Sharing mutable data safely between tasks with a `Mutex`:\n+//! Sharing mutable data safely between threads with a `Mutex`:\n //!\n //! ```no_run\n //! use std::sync::{Arc, Mutex};\n@@ -89,9 +89,9 @@ use heap::deallocate;\n ///\n /// # Examples\n ///\n-/// In this example, a large vector of floats is shared between several tasks.\n+/// In this example, a large vector of floats is shared between several threads.\n /// With simple pipes, without `Arc`, a copy would have to be made for each\n-/// task.\n+/// thread.\n ///\n /// When you clone an `Arc<T>`, it will create another pointer to the data and\n /// increase the reference counter."}, {"sha": "a0d60be300059ed73efdd11e5b815598025dd97e", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -37,7 +37,7 @@\n //! }\n //! ```\n //!\n-//! This will print `Cons(1, Box(Cons(2, Box(Nil))))`.\n+//! This will print `Cons(1, Cons(2, Nil))`.\n //!\n //! Recursive structures must be boxed, because if the definition of `Cons` looked like this:\n //!\n@@ -240,6 +240,7 @@ impl<T: ?Sized + Hash> Hash for Box<T> {\n impl Box<Any> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    /// Attempt to downcast the box to a concrete type.\n     pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n         if self.is::<T>() {\n             unsafe {\n@@ -257,11 +258,15 @@ impl Box<Any> {\n     }\n }\n \n-impl Box<Any+Send> {\n+impl Box<Any + Send> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n-        <Box<Any>>::downcast(self)\n+    /// Attempt to downcast the box to a concrete type.\n+    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any + Send>> {\n+        <Box<Any>>::downcast(self).map_err(|s| unsafe {\n+            // reapply the Send marker\n+            mem::transmute::<Box<Any>, Box<Any + Send>>(s)\n+        })\n     }\n }\n "}, {"sha": "83795a24c816066f17ed1997c7ca77e6aad03706", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -95,7 +95,7 @@ pub const EMPTY: *mut () = 0x1 as *mut ();\n \n /// The allocator for unique pointers.\n #[cfg(not(test))]\n-#[lang=\"exchange_malloc\"]\n+#[lang = \"exchange_malloc\"]\n #[inline]\n unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     if size == 0 {\n@@ -108,7 +108,7 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n }\n \n #[cfg(not(test))]\n-#[lang=\"exchange_free\"]\n+#[lang = \"exchange_free\"]\n #[inline]\n unsafe fn exchange_free(ptr: *mut u8, old_size: usize, align: usize) {\n     deallocate(ptr, old_size, align);"}, {"sha": "473429b813c50bc6d093a61cb60338de324520d9", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -26,14 +26,14 @@\n //! There can only be one owner of a `Box`, and the owner can decide to mutate\n //! the contents, which live on the heap.\n //!\n-//! This type can be sent among tasks efficiently as the size of a `Box` value\n+//! This type can be sent among threads efficiently as the size of a `Box` value\n //! is the same as that of a pointer. Tree-like data structures are often built\n //! with boxes because each node often has only one owner, the parent.\n //!\n //! ## Reference counted pointers\n //!\n //! The [`Rc`](rc/index.html) type is a non-threadsafe reference-counted pointer\n-//! type intended for sharing memory within a task. An `Rc` pointer wraps a\n+//! type intended for sharing memory within a thread. An `Rc` pointer wraps a\n //! type, `T`, and only allows access to `&T`, a shared reference.\n //!\n //! This type is useful when inherited mutability (such as using `Box`) is too"}, {"sha": "17e937c5af2574755203d789cdde0106ca371c91", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 109, "deletions": 6, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -89,6 +89,7 @@ use core::hash;\n use core::iter::RandomAccessIterator;\n use core::iter::{Chain, Enumerate, Repeat, Skip, Take, repeat, Cloned};\n use core::iter::{self, FromIterator};\n+use core::mem::swap;\n use core::ops::Index;\n use core::slice;\n use core::{u8, u32, usize};\n@@ -210,15 +211,13 @@ impl BitVec {\n         assert_eq!(self.len(), other.len());\n         // This could theoretically be a `debug_assert!`.\n         assert_eq!(self.storage.len(), other.storage.len());\n-        let mut changed = false;\n+        let mut changed_bits = 0;\n         for (a, b) in self.blocks_mut().zip(other.blocks()) {\n             let w = op(*a, b);\n-            if *a != w {\n-                changed = true;\n-                *a = w;\n-            }\n+            changed_bits |= *a ^ w;\n+            *a = w;\n         }\n-        changed\n+        changed_bits != 0\n     }\n \n     /// Iterator over mutable refs to  the underlying blocks of data.\n@@ -604,6 +603,110 @@ impl BitVec {\n         Iter { bit_vec: self, next_idx: 0, end_idx: self.nbits }\n     }\n \n+    /// Moves all bits from `other` into `Self`, leaving `other` empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections, bit_vec_append_split_off)]\n+    /// use std::collections::BitVec;\n+    ///\n+    /// let mut a = BitVec::from_bytes(&[0b10000000]);\n+    /// let mut b = BitVec::from_bytes(&[0b01100001]);\n+    ///\n+    /// a.append(&mut b);\n+    ///\n+    /// assert_eq!(a.len(), 16);\n+    /// assert_eq!(b.len(), 0);\n+    /// assert!(a.eq_vec(&[true, false, false, false, false, false, false, false,\n+    ///                    false, true, true, false, false, false, false, true]));\n+    /// ```\n+    #[unstable(feature = \"bit_vec_append_split_off\",\n+               reason = \"recently added as part of collections reform 2\")]\n+    pub fn append(&mut self, other: &mut Self) {\n+        let b = self.len() % u32::BITS;\n+\n+        self.nbits += other.len();\n+        other.nbits = 0;\n+\n+        if b == 0 {\n+            self.storage.append(&mut other.storage);\n+        } else {\n+            self.storage.reserve(other.storage.len());\n+\n+            for block in other.storage.drain(..) {\n+                *(self.storage.last_mut().unwrap()) |= block << b;\n+                self.storage.push(block >> (u32::BITS - b));\n+            }\n+        }\n+    }\n+\n+    /// Splits the `BitVec` into two at the given bit,\n+    /// retaining the first half in-place and returning the second one.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `at` is out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections, bit_vec_append_split_off)]\n+    /// use std::collections::BitVec;\n+    /// let mut a = BitVec::new();\n+    /// a.push(true);\n+    /// a.push(false);\n+    /// a.push(false);\n+    /// a.push(true);\n+    ///\n+    /// let b = a.split_off(2);\n+    ///\n+    /// assert_eq!(a.len(), 2);\n+    /// assert_eq!(b.len(), 2);\n+    /// assert!(a.eq_vec(&[true, false]));\n+    /// assert!(b.eq_vec(&[false, true]));\n+    /// ```\n+    #[unstable(feature = \"bit_vec_append_split_off\",\n+               reason = \"recently added as part of collections reform 2\")]\n+    pub fn split_off(&mut self, at: usize) -> Self {\n+        assert!(at <= self.len(), \"`at` out of bounds\");\n+\n+        let mut other = BitVec::new();\n+\n+        if at == 0 {\n+            swap(self, &mut other);\n+            return other;\n+        } else if at == self.len() {\n+            return other;\n+        }\n+\n+        let w = at / u32::BITS;\n+        let b = at % u32::BITS;\n+        other.nbits = self.nbits - at;\n+        self.nbits = at;\n+        if b == 0 {\n+            // Split at block boundary\n+            other.storage = self.storage.split_off(w);\n+        } else {\n+            other.storage.reserve(self.storage.len() - w);\n+\n+            {\n+                let mut iter = self.storage[w..].iter();\n+                let mut last = *iter.next().unwrap();\n+                for &cur in iter {\n+                    other.storage.push((last >> b) | (cur << (u32::BITS - b)));\n+                    last = cur;\n+                }\n+                other.storage.push(last >> b);\n+            }\n+\n+            self.storage.truncate(w+1);\n+            self.fix_last_block();\n+        }\n+\n+        other\n+    }\n+\n     /// Returns `true` if all bits are 0.\n     ///\n     /// # Examples"}, {"sha": "80fa6d397c82911852f24658c2ae572cbc80cb6f", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -398,7 +398,7 @@\n //! longer than this width, then it is truncated down to this many characters and only those are\n //! emitted.\n //!\n-//! For integral types, this has no meaning currently.\n+//! For integral types, this is ignored.\n //!\n //! For floating-point types, this indicates how many digits after the decimal point should be\n //! printed."}, {"sha": "b9e9800f7a0e78fcb1cd730c5bce0a441cb4c69b", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -80,7 +80,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use alloc::boxed::Box;\n-use core::convert::AsRef;\n use core::clone::Clone;\n use core::cmp::Ordering::{self, Greater, Less};\n use core::cmp::{self, Ord, PartialEq};\n@@ -996,55 +995,53 @@ impl<T> [T] {\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n-#[unstable(feature = \"collections\", reason = \"U should be an associated type\")]\n+#[unstable(feature = \"collections\", reason = \"recently changed\")]\n /// An extension trait for concatenating slices\n-pub trait SliceConcatExt<T: ?Sized, U> {\n+pub trait SliceConcatExt<T: ?Sized> {\n+    #[unstable(feature = \"collections\", reason = \"recently changed\")]\n+    /// The resulting type after concatenation\n+    type Output;\n+\n     /// Flattens a slice of `T` into a single value `U`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v = vec![\"hello\", \"world\"];\n-    ///\n-    /// let s: String = v.concat();\n-    ///\n-    /// println!(\"{}\", s); // prints \"helloworld\"\n+    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn concat(&self) -> U;\n+    fn concat(&self) -> Self::Output;\n \n     /// Flattens a slice of `T` into a single value `U`, placing a given separator between each.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let v = vec![\"hello\", \"world\"];\n-    ///\n-    /// let s: String = v.connect(\" \");\n-    ///\n-    /// println!(\"{}\", s); // prints \"hello world\"\n+    /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn connect(&self, sep: &T) -> U;\n+    fn connect(&self, sep: &T) -> Self::Output;\n }\n \n-impl<T: Clone, V: AsRef<[T]>> SliceConcatExt<T, Vec<T>> for [V] {\n+impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n+    type Output = Vec<T>;\n+\n     fn concat(&self) -> Vec<T> {\n-        let size = self.iter().fold(0, |acc, v| acc + v.as_ref().len());\n+        let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n         let mut result = Vec::with_capacity(size);\n         for v in self {\n-            result.push_all(v.as_ref())\n+            result.push_all(v.borrow())\n         }\n         result\n     }\n \n     fn connect(&self, sep: &T) -> Vec<T> {\n-        let size = self.iter().fold(0, |acc, v| acc + v.as_ref().len());\n+        let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n         let mut result = Vec::with_capacity(size + self.len());\n         let mut first = true;\n         for v in self {\n             if first { first = false } else { result.push(sep.clone()) }\n-            result.push_all(v.as_ref())\n+            result.push_all(v.borrow())\n         }\n         result\n     }"}, {"sha": "baef6ba6f01f368b2e9ec466c748d61cba1cbb44", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -59,7 +59,6 @@ use core::str::pattern::Pattern;\n use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use rustc_unicode::str::{UnicodeStr, Utf16Encoder};\n \n-use core::convert::AsRef;\n use vec_deque::VecDeque;\n use borrow::{Borrow, ToOwned};\n use string::String;\n@@ -83,18 +82,20 @@ pub use core::str::pattern;\n Section: Creating a string\n */\n \n-impl<S: AsRef<str>> SliceConcatExt<str, String> for [S] {\n+impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n+    type Output = String;\n+\n     fn concat(&self) -> String {\n         if self.is_empty() {\n             return String::new();\n         }\n \n         // `len` calculation may overflow but push_str will check boundaries\n-        let len = self.iter().map(|s| s.as_ref().len()).sum();\n+        let len = self.iter().map(|s| s.borrow().len()).sum();\n         let mut result = String::with_capacity(len);\n \n         for s in self {\n-            result.push_str(s.as_ref())\n+            result.push_str(s.borrow())\n         }\n \n         result\n@@ -113,7 +114,7 @@ impl<S: AsRef<str>> SliceConcatExt<str, String> for [S] {\n         // this is wrong without the guarantee that `self` is non-empty\n         // `len` calculation may overflow but push_str but will check boundaries\n         let len = sep.len() * (self.len() - 1)\n-            + self.iter().map(|s| s.as_ref().len()).sum::<usize>();\n+            + self.iter().map(|s| s.borrow().len()).sum::<usize>();\n         let mut result = String::with_capacity(len);\n         let mut first = true;\n \n@@ -123,7 +124,7 @@ impl<S: AsRef<str>> SliceConcatExt<str, String> for [S] {\n             } else {\n                 result.push_str(sep);\n             }\n-            result.push_str(s.as_ref());\n+            result.push_str(s.borrow());\n         }\n         result\n     }\n@@ -713,7 +714,7 @@ impl str {\n     /// is skipped if empty.\n     ///\n     /// This method can be used for string data that is _terminated_,\n-    /// rather than _seperated_ by a pattern.\n+    /// rather than _separated_ by a pattern.\n     ///\n     /// # Iterator behavior\n     ///\n@@ -760,7 +761,7 @@ impl str {\n     /// skipped if empty.\n     ///\n     /// This method can be used for string data that is _terminated_,\n-    /// rather than _seperated_ by a pattern.\n+    /// rather than _separated_ by a pattern.\n     ///\n     /// # Iterator behavior\n     ///"}, {"sha": "52d72501b4a9bafa465c65a40bb49fdf6a6874ab", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 128, "deletions": 11, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -26,7 +26,8 @@ use rustc_unicode::str as unicode_str;\n use rustc_unicode::str::Utf16Item;\n \n use borrow::{Cow, IntoCow};\n-use str::{self, FromStr, Utf8Error};\n+use range::RangeArgument;\n+use str::{self, FromStr, Utf8Error, Chars};\n use vec::{DerefVec, Vec, as_vec};\n \n /// A growable string stored as a UTF-8 encoded buffer.\n@@ -695,6 +696,59 @@ impl String {\n     pub fn clear(&mut self) {\n         self.vec.clear()\n     }\n+\n+    /// Create a draining iterator that removes the specified range in the string\n+    /// and yields the removed chars from start to end. The element range is\n+    /// removed even if the iterator is not consumed until the end.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the starting point or end point are not on character boundaries,\n+    /// or if they are out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections_drain)]\n+    ///\n+    /// let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n+    /// let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n+    ///\n+    /// // Remove the range up until the \u03b2 from the string\n+    /// let t: String = s.drain(..beta_offset).collect();\n+    /// assert_eq!(t, \"\u03b1 is alpha, \");\n+    /// assert_eq!(s, \"\u03b2 is beta\");\n+    ///\n+    /// // A full range clears the string\n+    /// s.drain(..);\n+    /// assert_eq!(s, \"\");\n+    /// ```\n+    #[unstable(feature = \"collections_drain\",\n+               reason = \"recently added, matches RFC\")]\n+    pub fn drain<R>(&mut self, range: R) -> Drain where R: RangeArgument<usize> {\n+        // Memory safety\n+        //\n+        // The String version of Drain does not have the memory safety issues\n+        // of the vector version. The data is just plain bytes.\n+        // Because the range removal happens in Drop, if the Drain iterator is leaked,\n+        // the removal will not happen.\n+        let len = self.len();\n+        let start = *range.start().unwrap_or(&0);\n+        let end = *range.end().unwrap_or(&len);\n+\n+        // Take out two simultaneous borrows. The &mut String won't be accessed\n+        // until iteration is over, in Drop.\n+        let self_ptr = self as *mut _;\n+        // slicing does the appropriate bounds checks\n+        let chars_iter = self[start..end].chars();\n+\n+        Drain {\n+            start: start,\n+            end: end,\n+            iter: chars_iter,\n+            string: self_ptr,\n+        }\n+    }\n }\n \n impl FromUtf8Error {\n@@ -703,7 +757,7 @@ impl FromUtf8Error {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_bytes(self) -> Vec<u8> { self.bytes }\n \n-    /// Accesss the underlying UTF8-error that was the cause of this error.\n+    /// Access the underlying UTF8-error that was the cause of this error.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn utf8_error(&self) -> Utf8Error { self.error }\n }\n@@ -740,8 +794,7 @@ impl<'a> FromIterator<&'a str> for String {\n     }\n }\n \n-#[unstable(feature = \"collections\",\n-           reason = \"waiting on Extend stabilization\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Extend<char> for String {\n     fn extend<I: IntoIterator<Item=char>>(&mut self, iterable: I) {\n         let iterator = iterable.into_iter();\n@@ -753,8 +806,7 @@ impl Extend<char> for String {\n     }\n }\n \n-#[unstable(feature = \"collections\",\n-           reason = \"waiting on Extend stabilization\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Extend<&'a str> for String {\n     fn extend<I: IntoIterator<Item=&'a str>>(&mut self, iterable: I) {\n         let iterator = iterable.into_iter();\n@@ -869,8 +921,7 @@ impl hash::Hash for String {\n     }\n }\n \n-#[unstable(feature = \"collections\",\n-           reason = \"recent addition, needs more experience\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Add<&'a str> for String {\n     type Output = String;\n \n@@ -964,11 +1015,17 @@ pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }\n \n-#[unstable(feature = \"collections\", reason = \"associated error type may change\")]\n+/// Error returned from `String::from_str`\n+#[unstable(feature = \"str_parse_error\", reason = \"may want to be replaced with \\\n+                                                  Void if it ever exists\")]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+pub struct ParseError(());\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for String {\n-    type Err = ();\n+    type Err = ParseError;\n     #[inline]\n-    fn from_str(s: &str) -> Result<String, ()> {\n+    fn from_str(s: &str) -> Result<String, ParseError> {\n         Ok(String::from_str(s))\n     }\n }\n@@ -1000,6 +1057,14 @@ impl AsRef<str> for String {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<[u8]> for String {\n+    #[inline]\n+    fn as_ref(&self) -> &[u8] {\n+        self.as_bytes()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> From<&'a str> for String {\n     #[cfg(not(test))]\n@@ -1072,3 +1137,55 @@ impl fmt::Write for String {\n         Ok(())\n     }\n }\n+\n+/// A draining iterator for `String`.\n+#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+pub struct Drain<'a> {\n+    /// Will be used as &'a mut String in the destructor\n+    string: *mut String,\n+    /// Start of part to remove\n+    start: usize,\n+    /// End of part to remove\n+    end: usize,\n+    /// Current remaining range to remove\n+    iter: Chars<'a>,\n+}\n+\n+unsafe impl<'a> Sync for Drain<'a> {}\n+unsafe impl<'a> Send for Drain<'a> {}\n+\n+#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+impl<'a> Drop for Drain<'a> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            // Use Vec::drain. \"Reaffirm\" the bounds checks to avoid\n+            // panic code being inserted again.\n+            let self_vec = (*self.string).as_mut_vec();\n+            if self.start <= self.end && self.end <= self_vec.len() {\n+                self_vec.drain(self.start..self.end);\n+            }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+impl<'a> Iterator for Drain<'a> {\n+    type Item = char;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<char> {\n+        self.iter.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"collections_drain\", reason = \"recently added\")]\n+impl<'a> DoubleEndedIterator for Drain<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<char> {\n+        self.iter.next_back()\n+    }\n+}"}, {"sha": "66bb84205e21ce72f2c48e3b60437b87e09265c9", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -15,35 +15,43 @@\n //!\n //! # Examples\n //!\n-//! Explicitly creating a `Vec<T>` with `new()`:\n+//! You can explicitly create a `Vec<T>` with `new()`:\n //!\n //! ```\n //! let xs: Vec<i32> = Vec::new();\n //! ```\n //!\n-//! Using the `vec!` macro:\n+//! ...or by using the `vec!` macro:\n //!\n //! ```\n //! let ys: Vec<i32> = vec![];\n //!\n //! let zs = vec![1i32, 2, 3, 4, 5];\n //! ```\n //!\n-//! Push:\n+//! You can `push` values onto the end of a vector (which will grow the vector as needed):\n //!\n //! ```\n //! let mut xs = vec![1i32, 2];\n //!\n //! xs.push(3);\n //! ```\n //!\n-//! And pop:\n+//! Popping values works in much the same way:\n //!\n //! ```\n //! let mut xs = vec![1i32, 2];\n //!\n //! let two = xs.pop();\n //! ```\n+//!\n+//! Vectors also support indexing (through the `Index` and `IndexMut` traits):\n+//!\n+//! ```\n+//! let mut xs = vec![1i32, 2, 3];\n+//! let three = xs[2];\n+//! xs[1] = xs[1] + 5;\n+//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -59,7 +67,7 @@ use core::intrinsics::assume;\n use core::iter::{repeat, FromIterator};\n use core::marker::PhantomData;\n use core::mem;\n-use core::ops::{Index, IndexMut, Deref, Add};\n+use core::ops::{Index, IndexMut, Deref};\n use core::ops;\n use core::ptr;\n use core::ptr::Unique;\n@@ -639,7 +647,7 @@ impl<T> Vec<T> {\n             // zero-size types consume no memory, so we can't rely on the\n             // address space running out\n             self.len = self.len.checked_add(1).expect(\"length overflow\");\n-            unsafe { mem::forget(value); }\n+            mem::forget(value);\n             return\n         }\n \n@@ -986,7 +994,7 @@ impl<T> Vec<T> {\n                 num_u: 0,\n                 marker: PhantomData,\n             };\n-            unsafe { mem::forget(vec); }\n+            mem::forget(vec);\n \n             while pv.num_t != 0 {\n                 unsafe {\n@@ -1299,7 +1307,7 @@ pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"collections\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T:Clone> Clone for Vec<T> {\n     #[cfg(not(test))]\n     fn clone(&self) -> Vec<T> { <[T]>::to_vec(&**self) }\n@@ -1554,7 +1562,7 @@ impl<'a, T> IntoIterator for &'a mut Vec<T> {\n     }\n }\n \n-#[unstable(feature = \"collections\", reason = \"waiting on Extend stability\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n     fn extend<I: IntoIterator<Item=T>>(&mut self, iterable: I) {\n@@ -1614,18 +1622,6 @@ impl<T: Ord> Ord for Vec<T> {\n     }\n }\n \n-#[unstable(feature = \"collections\",\n-           reason = \"recent addition, needs more experience\")]\n-impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n-    type Output = Vec<T>;\n-\n-    #[inline]\n-    fn add(mut self, rhs: &[T]) -> Vec<T> {\n-        self.push_all(rhs);\n-        self\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n@@ -1694,7 +1690,7 @@ impl<'a> From<&'a str> for Vec<u8> {\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"collections\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n     fn from_iter<I: IntoIterator<Item=T>>(it: I) -> Cow<'a, [T]> {\n         Cow::Owned(FromIterator::from_iter(it))\n@@ -1778,6 +1774,11 @@ impl<T> Iterator for IntoIter<T> {\n         let exact = diff / (if size == 0 {1} else {size});\n         (exact, Some(exact))\n     }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.size_hint().0\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "f70906f84b8692b4e36f2d1145e197ba053d15f8", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -1395,6 +1395,42 @@ impl<T> VecDeque<T> {\n         // naive impl\n         self.extend(other.drain());\n     }\n+\n+    /// Retains only the elements specified by the predicate.\n+    ///\n+    /// In other words, remove all elements `e` such that `f(&e)` returns false.\n+    /// This method operates in place and preserves the order of the retained\n+    /// elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(vec_deque_retain)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    /// buf.extend(1..5);\n+    /// buf.retain(|&x| x%2 == 0);\n+    ///\n+    /// let v: Vec<_> = buf.into_iter().collect();\n+    /// assert_eq!(&v[..], &[2, 4]);\n+    /// ```\n+    #[unstable(feature = \"vec_deque_retain\",\n+               reason = \"new API, waiting for dust to settle\")]\n+    pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n+        let len = self.len();\n+        let mut del = 0;\n+        for i in 0..len {\n+            if !f(&self[i]) {\n+                del += 1;\n+            } else if del > 0 {\n+                self.swap(i-del, i);\n+            }\n+        }\n+        if del > 0 {\n+            self.truncate(len - del);\n+        }\n+    }\n }\n \n impl<T: Clone> VecDeque<T> {"}, {"sha": "a1d2eed0a8b5f13089c7923193a2fbdd2ca4d272", "filename": "src/libcollectionstest/bit/vec.rs", "status": "modified", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fvec.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -630,6 +630,141 @@ fn test_bit_vec_extend() {\n                                  0b01001001, 0b10010010, 0b10111101]));\n }\n \n+#[test]\n+fn test_bit_vec_append() {\n+    // Append to BitVec that holds a multiple of u32::BITS bits\n+    let mut a = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011]);\n+    let mut b = BitVec::new();\n+    b.push(false);\n+    b.push(true);\n+    b.push(true);\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.len(), 35);\n+    assert_eq!(b.len(), 0);\n+    assert!(b.capacity() >= 3);\n+\n+    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n+                       false, false, false, true, false, false, true, false,\n+                       true, false, false, true, false, false, true, false,\n+                       false, false, true, true, false, false, true, true,\n+                       false, true, true]));\n+\n+    // Append to arbitrary BitVec\n+    let mut a = BitVec::new();\n+    a.push(true);\n+    a.push(false);\n+\n+    let mut b = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011, 0b10010101]);\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.len(), 42);\n+    assert_eq!(b.len(), 0);\n+    assert!(b.capacity() >= 40);\n+\n+    assert!(a.eq_vec(&[true, false, true, false, true, false, false, false,\n+                       false, false, false, false, false, true, false, false,\n+                       true, false, true, false, false, true, false, false,\n+                       true, false, false, false, true, true, false, false,\n+                       true, true, true, false, false, true, false, true,\n+                       false, true]));\n+\n+    // Append to empty BitVec\n+    let mut a = BitVec::new();\n+    let mut b = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011, 0b10010101]);\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.len(), 40);\n+    assert_eq!(b.len(), 0);\n+    assert!(b.capacity() >= 40);\n+\n+    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n+                       false, false, false, true, false, false, true, false,\n+                       true, false, false, true, false, false, true, false,\n+                       false, false, true, true, false, false, true, true,\n+                       true, false, false, true, false, true, false, true]));\n+\n+    // Append empty BitVec\n+    let mut a = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011, 0b10010101]);\n+    let mut b = BitVec::new();\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.len(), 40);\n+    assert_eq!(b.len(), 0);\n+\n+    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n+                       false, false, false, true, false, false, true, false,\n+                       true, false, false, true, false, false, true, false,\n+                       false, false, true, true, false, false, true, true,\n+                       true, false, false, true, false, true, false, true]));\n+}\n+\n+#[test]\n+fn test_bit_vec_split_off() {\n+    // Split at 0\n+    let mut a = BitVec::new();\n+    a.push(true);\n+    a.push(false);\n+    a.push(false);\n+    a.push(true);\n+\n+    let b = a.split_off(0);\n+\n+    assert_eq!(a.len(), 0);\n+    assert_eq!(b.len(), 4);\n+\n+    assert!(b.eq_vec(&[true, false, false, true]));\n+\n+    // Split at last bit\n+    a.truncate(0);\n+    a.push(true);\n+    a.push(false);\n+    a.push(false);\n+    a.push(true);\n+\n+    let b = a.split_off(4);\n+\n+    assert_eq!(a.len(), 4);\n+    assert_eq!(b.len(), 0);\n+\n+    assert!(a.eq_vec(&[true, false, false, true]));\n+\n+    // Split at block boundary\n+    let mut a = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011, 0b11110011]);\n+\n+    let b = a.split_off(32);\n+\n+    assert_eq!(a.len(), 32);\n+    assert_eq!(b.len(), 8);\n+\n+    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n+                       false, false, false, true, false, false, true, false,\n+                       true, false, false, true, false, false, true, false,\n+                       false, false, true, true, false, false, true, true]));\n+    assert!(b.eq_vec(&[true, true, true, true, false, false, true, true]));\n+\n+    // Don't split at block boundary\n+    let mut a = BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010, 0b00110011,\n+                                     0b01101011, 0b10101101]);\n+\n+    let b = a.split_off(13);\n+\n+    assert_eq!(a.len(), 13);\n+    assert_eq!(b.len(), 35);\n+\n+    assert!(a.eq_vec(&[true, false, true, false, false, false, false, false,\n+                       false, false, false, true, false]));\n+    assert!(b.eq_vec(&[false, true, false, true, false, false, true, false,\n+                       false, true, false, false, false, true, true, false,\n+                       false, true, true, false, true, true, false, true,\n+                       false, true, true,  true, false, true, false, true,\n+                       true, false, true]));\n+}\n+\n mod bench {\n     use std::collections::BitVec;\n     use std::u32;"}, {"sha": "154bdd56c5a68ca76f987d1dc831e5fc2bc0af41", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(bit_vec_append_split_off)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(collections_drain)]\n@@ -21,6 +22,7 @@\n #![feature(into_cow)]\n #![feature(step_by)]\n #![cfg_attr(test, feature(str_char))]\n+#![cfg_attr(test, feature(vec_deque_retain))]\n \n #[macro_use] extern crate log;\n "}, {"sha": "d4e2ebf4fd137e31a49fb1caa967bae1347f1d8c", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -348,6 +348,23 @@ fn test_from_iterator() {\n     assert_eq!(s, d);\n }\n \n+#[test]\n+fn test_drain() {\n+    let mut s = String::from(\"\u03b1\u03b2\u03b3\");\n+    assert_eq!(s.drain(2..4).collect::<String>(), \"\u03b2\");\n+    assert_eq!(s, \"\u03b1\u03b3\");\n+\n+    let mut t = String::from(\"abcd\");\n+    t.drain(..0);\n+    assert_eq!(t, \"abcd\");\n+    t.drain(..1);\n+    assert_eq!(t, \"bcd\");\n+    t.drain(3..);\n+    assert_eq!(t, \"bcd\");\n+    t.drain(..);\n+    assert_eq!(t, \"\");\n+}\n+\n #[bench]\n fn bench_with_capacity(b: &mut Bencher) {\n     b.iter(|| {"}, {"sha": "ac9cf198d6732b53c1488f9432a56576013f561f", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -542,6 +542,11 @@ fn test_split_off() {\n     assert_eq!(vec2, [5, 6]);\n }\n \n+#[test]\n+fn test_into_iter_count() {\n+    assert_eq!(vec![1, 2, 3].into_iter().count(), 3);\n+}\n+\n #[bench]\n fn bench_new(b: &mut Bencher) {\n     b.iter(|| {"}, {"sha": "7870447281bc1335fc48b1c9e3c3b255f5488753", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -885,3 +885,12 @@ fn test_append() {\n     assert_eq!(b.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n     assert_eq!(a.iter().cloned().collect::<Vec<_>>(), []);\n }\n+\n+#[test]\n+fn test_retain() {\n+    let mut buf = VecDeque::new();\n+    buf.extend(1..5);\n+    buf.retain(|&x| x % 2 == 0);\n+    let v: Vec<_> = buf.into_iter().collect();\n+    assert_eq!(&v[..], &[2, 4]);\n+}"}, {"sha": "a65394f52682ced3504e38f380fba4906654b166", "filename": "src/libcore/any.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -97,9 +97,7 @@ pub trait Any: Reflect + 'static {\n     fn get_type_id(&self) -> TypeId;\n }\n \n-impl<T> Any for T\n-    where T: Reflect + 'static\n-{\n+impl<T: Reflect + 'static> Any for T {\n     fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }\n }\n \n@@ -222,7 +220,7 @@ impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been\n     /// instantiated with\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn of<T: ?Sized + Any>() -> TypeId {\n+    pub fn of<T: ?Sized + Reflect + 'static>() -> TypeId {\n         TypeId {\n             t: unsafe { intrinsics::type_id::<T>() },\n         }"}, {"sha": "ec693f366912dd53ca871e5c305002590fdafc72", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -52,20 +52,20 @@\n //!         spinlock_clone.store(0, Ordering::SeqCst);\n //!     });\n //!\n-//!     // Wait for the other task to release the lock\n+//!     // Wait for the other thread to release the lock\n //!     while spinlock.load(Ordering::SeqCst) != 0 {}\n //! }\n //! ```\n //!\n-//! Keep a global count of live tasks:\n+//! Keep a global count of live threads:\n //!\n //! ```\n //! use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n //!\n-//! static GLOBAL_TASK_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n+//! static GLOBAL_THREAD_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n //!\n-//! let old_task_count = GLOBAL_TASK_COUNT.fetch_add(1, Ordering::SeqCst);\n-//! println!(\"live tasks: {}\", old_task_count + 1);\n+//! let old_thread_count = GLOBAL_THREAD_COUNT.fetch_add(1, Ordering::SeqCst);\n+//! println!(\"live threads: {}\", old_thread_count + 1);\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "bf5fdb973eb768a84672f87f7b18bda1dfcca26e", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -24,7 +24,8 @@\n //! claim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are\n //! tracked 'at runtime', unlike Rust's native reference types which are entirely tracked\n //! statically, at compile time. Because `RefCell<T>` borrows are dynamic it is possible to attempt\n-//! to borrow a value that is already mutably borrowed; when this happens it results in task panic.\n+//! to borrow a value that is already mutably borrowed; when this happens it results in thread\n+//! panic.\n //!\n //! # When to choose interior mutability\n //!\n@@ -100,7 +101,7 @@\n //!         // Recursive call to return the just-cached value.\n //!         // Note that if we had not let the previous borrow\n //!         // of the cache fall out of scope then the subsequent\n-//!         // recursive borrow would cause a dynamic task panic.\n+//!         // recursive borrow would cause a dynamic thread panic.\n //!         // This is the major hazard of using `RefCell`.\n //!         self.minimum_spanning_tree()\n //!     }\n@@ -144,7 +145,7 @@\n use clone::Clone;\n use cmp::PartialEq;\n use default::Default;\n-use marker::{Copy, Send, Sync};\n+use marker::{Copy, Send, Sync, Sized};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{None, Some};\n@@ -266,9 +267,9 @@ impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n ///\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RefCell<T> {\n-    value: UnsafeCell<T>,\n+pub struct RefCell<T: ?Sized> {\n     borrow: Cell<BorrowFlag>,\n+    value: UnsafeCell<T>,\n }\n \n /// An enumeration of values returned from the `state` method on a `RefCell<T>`.\n@@ -328,7 +329,9 @@ impl<T> RefCell<T> {\n         debug_assert!(self.borrow.get() == UNUSED);\n         unsafe { self.value.into_inner() }\n     }\n+}\n \n+impl<T: ?Sized> RefCell<T> {\n     /// Query the current state of this `RefCell`\n     ///\n     /// The returned value can be dispatched on to determine if a call to\n@@ -449,7 +452,7 @@ impl<T> RefCell<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T> Send for RefCell<T> where T: Send {}\n+unsafe impl<T: ?Sized> Send for RefCell<T> where T: Send {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RefCell<T> {\n@@ -469,7 +472,7 @@ impl<T:Default> Default for RefCell<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialEq> PartialEq for RefCell<T> {\n+impl<T: ?Sized + PartialEq> PartialEq for RefCell<T> {\n     #[inline]\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()\n@@ -519,15 +522,15 @@ impl<'b> Clone for BorrowRef<'b> {\n ///\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Ref<'b, T:'b> {\n+pub struct Ref<'b, T: ?Sized + 'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _value: &'b T,\n     _borrow: BorrowRef<'b>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, T> Deref for Ref<'b, T> {\n+impl<'b, T: ?Sized> Deref for Ref<'b, T> {\n     type Target = T;\n \n     #[inline]\n@@ -582,15 +585,15 @@ impl<'b> BorrowRefMut<'b> {\n ///\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RefMut<'b, T:'b> {\n+pub struct RefMut<'b, T: ?Sized + 'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _value: &'b mut T,\n     _borrow: BorrowRefMut<'b>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, T> Deref for RefMut<'b, T> {\n+impl<'b, T: ?Sized> Deref for RefMut<'b, T> {\n     type Target = T;\n \n     #[inline]\n@@ -600,7 +603,7 @@ impl<'b, T> Deref for RefMut<'b, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, T> DerefMut for RefMut<'b, T> {\n+impl<'b, T: ?Sized> DerefMut for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         self._value\n@@ -631,9 +634,9 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n ///\n /// **NOTE:** `UnsafeCell<T>`'s fields are public to allow static initializers. It is not\n /// recommended to access its fields directly, `get` should be used instead.\n-#[lang=\"unsafe_cell\"]\n+#[lang = \"unsafe_cell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct UnsafeCell<T> {\n+pub struct UnsafeCell<T: ?Sized> {\n     /// Wrapped value\n     ///\n     /// This field should not be accessed directly, it is made public for static\n@@ -642,7 +645,7 @@ pub struct UnsafeCell<T> {\n     pub value: T,\n }\n \n-impl<T> !Sync for UnsafeCell<T> {}\n+impl<T: ?Sized> !Sync for UnsafeCell<T> {}\n \n impl<T> UnsafeCell<T> {\n     /// Constructs a new instance of `UnsafeCell` which will wrap the specified\n@@ -664,7 +667,12 @@ impl<T> UnsafeCell<T> {\n         UnsafeCell { value: value }\n     }\n \n-    /// Gets a mutable pointer to the wrapped value.\n+    /// Unwraps the value.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because there is no guarantee that this or other threads are\n+    /// currently inspecting the inner value.\n     ///\n     /// # Examples\n     ///\n@@ -673,22 +681,15 @@ impl<T> UnsafeCell<T> {\n     ///\n     /// let uc = UnsafeCell::new(5);\n     ///\n-    /// let five = uc.get();\n+    /// let five = unsafe { uc.into_inner() };\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> *mut T {\n-        // FIXME(#23542) Replace with type ascription.\n-        #![allow(trivial_casts)]\n-        &self.value as *const T as *mut T\n-    }\n+    pub unsafe fn into_inner(self) -> T { self.value }\n+}\n \n-    /// Unwraps the value.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe because there is no guarantee that this or other threads are\n-    /// currently inspecting the inner value.\n+impl<T: ?Sized> UnsafeCell<T> {\n+    /// Gets a mutable pointer to the wrapped value.\n     ///\n     /// # Examples\n     ///\n@@ -697,9 +698,14 @@ impl<T> UnsafeCell<T> {\n     ///\n     /// let uc = UnsafeCell::new(5);\n     ///\n-    /// let five = unsafe { uc.into_inner() };\n+    /// let five = uc.get();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn into_inner(self) -> T { self.value }\n+    pub fn get(&self) -> *mut T {\n+        // FIXME(#23542) Replace with type ascription.\n+        #![allow(trivial_casts)]\n+        &self.value as *const T as *mut T\n+    }\n+\n }"}, {"sha": "dab549f784cf82bf68a175fa0d67b7423729b8c8", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -41,7 +41,7 @@ use option::Option::{self, Some, None};\n /// PartialEq only requires the `eq` method to be implemented; `ne` is defined in terms of it by\n /// default. Any manual implementation of `ne` *must* respect the rule that `eq` is a strict\n /// inverse of `ne`; that is, `!(a == b)` if and only if `a != b`.\n-#[lang=\"eq\"]\n+#[lang = \"eq\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n     /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n@@ -222,7 +222,7 @@ impl PartialOrd for Ordering {\n /// However it remains possible to implement the others separately for types which do not have a\n /// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n /// false` (cf. IEEE 754-2008 section 5.11).\n-#[lang=\"ord\"]\n+#[lang = \"ord\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     /// This method returns an ordering between `self` and `other` values if one exists."}, {"sha": "4b75bd5f67e3d94fd7d07b23a19c4567e0ade186", "filename": "src/libcore/fmt/float.rs", "status": "removed", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -1,289 +0,0 @@\n-// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub use self::ExponentFormat::*;\n-pub use self::SignificantDigits::*;\n-\n-use prelude::*;\n-\n-use char;\n-use fmt;\n-use num::Float;\n-use num::FpCategory as Fp;\n-use ops::{Div, Rem, Mul};\n-use slice;\n-use str;\n-\n-/// A flag that specifies whether to use exponential (scientific) notation.\n-pub enum ExponentFormat {\n-    /// Do not use exponential notation.\n-    ExpNone,\n-    /// Use exponential notation with the exponent having a base of 10 and the\n-    /// exponent sign being `e` or `E`. For example, 1000 would be printed\n-    /// 1e3.\n-    ExpDec\n-}\n-\n-/// The number of digits used for emitting the fractional part of a number, if\n-/// any.\n-pub enum SignificantDigits {\n-    /// At most the given number of digits will be printed, truncating any\n-    /// trailing zeroes.\n-    DigMax(usize),\n-\n-    /// Precisely the given number of digits will be printed.\n-    DigExact(usize)\n-}\n-\n-#[doc(hidden)]\n-pub trait MyFloat: Float + PartialEq + PartialOrd + Div<Output=Self> +\n-                   Mul<Output=Self> + Rem<Output=Self> + Copy {\n-    fn from_u32(u: u32) -> Self;\n-    fn to_i32(&self) -> i32;\n-}\n-\n-macro_rules! doit {\n-    ($($t:ident)*) => ($(impl MyFloat for $t {\n-        fn from_u32(u: u32) -> $t { u as $t }\n-        fn to_i32(&self) -> i32 { *self as i32 }\n-    })*)\n-}\n-doit! { f32 f64 }\n-\n-/// Converts a float number to its string representation.\n-/// This is meant to be a common base implementation for various formatting styles.\n-/// The number is assumed to be non-negative, callers use `Formatter::pad_integral`\n-/// to add the right sign, if any.\n-///\n-/// # Arguments\n-///\n-/// - `num`           - The number to convert (non-negative). Accepts any number that\n-///                     implements the numeric traits.\n-/// - `digits`        - The amount of digits to use for emitting the fractional\n-///                     part, if any. See `SignificantDigits`.\n-/// - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n-///                    See `ExponentFormat`.\n-/// - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n-///                     exponential notation is desired.\n-/// - `f`             - A closure to invoke with the string representing the\n-///                     float.\n-///\n-/// # Panics\n-///\n-/// - Panics if `num` is negative.\n-pub fn float_to_str_bytes_common<T: MyFloat, U, F>(\n-    num: T,\n-    digits: SignificantDigits,\n-    exp_format: ExponentFormat,\n-    exp_upper: bool,\n-    f: F\n-) -> U where\n-    F: FnOnce(&str) -> U,\n-{\n-    let _0: T = T::zero();\n-    let _1: T = T::one();\n-    let radix: u32 = 10;\n-    let radix_f = T::from_u32(radix);\n-\n-    assert!(num.is_nan() || num >= _0, \"float_to_str_bytes_common: number is negative\");\n-\n-    match num.classify() {\n-        Fp::Nan => return f(\"NaN\"),\n-        Fp::Infinite if num > _0 => {\n-            return f(\"inf\");\n-        }\n-        Fp::Infinite if num < _0 => {\n-            return f(\"-inf\");\n-        }\n-        _ => {}\n-    }\n-\n-    // For an f64 the (decimal) exponent is roughly in the range of [-307, 308], so\n-    // we may have up to that many digits. We err on the side of caution and\n-    // add 50% extra wiggle room.\n-    let mut buf = [0; 462];\n-    let mut end = 0;\n-\n-    let (num, exp) = match exp_format {\n-        ExpDec if num != _0 => {\n-            let exp = num.log10().floor();\n-            (num / radix_f.powf(exp), exp.to_i32())\n-        }\n-        _ => (num, 0)\n-    };\n-\n-    // First emit the non-fractional part, looping at least once to make\n-    // sure at least a `0` gets emitted.\n-    let mut deccum = num.trunc();\n-    loop {\n-        let current_digit = deccum % radix_f;\n-\n-        // Decrease the deccumulator one digit at a time\n-        deccum = deccum / radix_f;\n-        deccum = deccum.trunc();\n-\n-        let c = char::from_digit(current_digit.to_i32() as u32, radix);\n-        buf[end] = c.unwrap() as u8;\n-        end += 1;\n-\n-        // No more digits to calculate for the non-fractional part -> break\n-        if deccum == _0 { break; }\n-    }\n-\n-    // If limited digits, calculate one digit more for rounding.\n-    let (limit_digits, digit_count, exact) = match digits {\n-        DigMax(count)   => (true, count + 1, false),\n-        DigExact(count) => (true, count + 1, true)\n-    };\n-\n-    buf[..end].reverse();\n-\n-    // Remember start of the fractional digits.\n-    // Points one beyond end of buf if none get generated,\n-    // or at the '.' otherwise.\n-    let start_fractional_digits = end;\n-\n-    // Now emit the fractional part, if any\n-    deccum = num.fract();\n-    if deccum != _0 || (limit_digits && exact && digit_count > 0) {\n-        buf[end] = b'.';\n-        end += 1;\n-        let mut dig = 0;\n-\n-        // calculate new digits while\n-        // - there is no limit and there are digits left\n-        // - or there is a limit, it's not reached yet and\n-        //   - it's exact\n-        //   - or it's a maximum, and there are still digits left\n-        while (!limit_digits && deccum != _0)\n-           || (limit_digits && dig < digit_count && (\n-                   exact\n-                || (!exact && deccum != _0)\n-              )\n-        ) {\n-            // Shift first fractional digit into the integer part\n-            deccum = deccum * radix_f;\n-\n-            let current_digit = deccum.trunc();\n-\n-            let c = char::from_digit(current_digit.to_i32() as u32, radix);\n-            buf[end] = c.unwrap() as u8;\n-            end += 1;\n-\n-            // Decrease the deccumulator one fractional digit at a time\n-            deccum = deccum.fract();\n-            dig += 1;\n-        }\n-\n-        // If digits are limited, and that limit has been reached,\n-        // cut off the one extra digit, and depending on its value\n-        // round the remaining ones.\n-        if limit_digits && dig == digit_count {\n-            let ascii2value = |chr: u8| {\n-                (chr as char).to_digit(radix).unwrap()\n-            };\n-            let value2ascii = |val: u32| {\n-                char::from_digit(val, radix).unwrap() as u8\n-            };\n-\n-            let extra_digit = ascii2value(buf[end - 1]);\n-            end -= 1;\n-            if extra_digit >= radix / 2 { // -> need to round\n-                let mut i: isize = end as isize - 1;\n-                loop {\n-                    // If reached left end of number, have to\n-                    // insert additional digit:\n-                    if i < 0\n-                    || buf[i as usize] == b'-'\n-                    || buf[i as usize] == b'+' {\n-                        for j in ((i + 1) as usize..end).rev() {\n-                            buf[j + 1] = buf[j];\n-                        }\n-                        buf[(i + 1) as usize] = value2ascii(1);\n-                        end += 1;\n-                        break;\n-                    }\n-\n-                    // Skip the '.'\n-                    if buf[i as usize] == b'.' { i -= 1; continue; }\n-\n-                    // Either increment the digit,\n-                    // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as usize]);\n-                    if current_digit < (radix - 1) {\n-                        buf[i as usize] = value2ascii(current_digit+1);\n-                        break;\n-                    } else {\n-                        buf[i as usize] = value2ascii(0);\n-                        i -= 1;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    // if number of digits is not exact, remove all trailing '0's up to\n-    // and including the '.'\n-    if !exact {\n-        let buf_max_i = end - 1;\n-\n-        // index to truncate from\n-        let mut i = buf_max_i;\n-\n-        // discover trailing zeros of fractional part\n-        while i > start_fractional_digits && buf[i] == b'0' {\n-            i -= 1;\n-        }\n-\n-        // Only attempt to truncate digits if buf has fractional digits\n-        if i >= start_fractional_digits {\n-            // If buf ends with '.', cut that too.\n-            if buf[i] == b'.' { i -= 1 }\n-\n-            // only resize buf if we actually remove digits\n-            if i < buf_max_i {\n-                end = i + 1;\n-            }\n-        }\n-    } // If exact and trailing '.', just cut that\n-    else {\n-        let max_i = end - 1;\n-        if buf[max_i] == b'.' {\n-            end = max_i;\n-        }\n-    }\n-\n-    match exp_format {\n-        ExpNone => {},\n-        ExpDec => {\n-            buf[end] = if exp_upper { b'E' } else { b'e' };\n-            end += 1;\n-\n-            struct Filler<'a> {\n-                buf: &'a mut [u8],\n-                end: &'a mut usize,\n-            }\n-\n-            impl<'a> fmt::Write for Filler<'a> {\n-                fn write_str(&mut self, s: &str) -> fmt::Result {\n-                    slice::bytes::copy_memory(s.as_bytes(),\n-                                              &mut self.buf[(*self.end)..]);\n-                    *self.end += s.len();\n-                    Ok(())\n-                }\n-            }\n-\n-            let mut filler = Filler { buf: &mut buf, end: &mut end };\n-            let _ = fmt::write(&mut filler, format_args!(\"{:-}\", exp));\n-        }\n-    }\n-\n-    f(unsafe { str::from_utf8_unchecked(&buf[..end]) })\n-}"}, {"sha": "a87f6619fe8772e7e36127d9b06f705856e0e8ac", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 128, "deletions": 46, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -17,9 +17,9 @@ use prelude::*;\n use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n use marker::PhantomData;\n use mem;\n+use num::flt2dec;\n use ops::Deref;\n use result;\n-use num::Float;\n use slice;\n use str;\n use self::rt::v1::Alignment;\n@@ -31,7 +31,6 @@ pub use self::num::RadixFmt;\n pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap};\n \n mod num;\n-mod float;\n mod builders;\n \n #[unstable(feature = \"core\", reason = \"internal to format_args!\")]\n@@ -604,6 +603,83 @@ impl<'a> Formatter<'a> {\n         Ok(())\n     }\n \n+    /// Takes the formatted parts and applies the padding.\n+    /// Assumes that the caller already has rendered the parts with required precision,\n+    /// so that `self.precision` can be ignored.\n+    fn pad_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result {\n+        if let Some(mut width) = self.width {\n+            // for the sign-aware zero padding, we render the sign first and\n+            // behave as if we had no sign from the beginning.\n+            let mut formatted = formatted.clone();\n+            let mut align = self.align;\n+            let old_fill = self.fill;\n+            if self.flags & (1 << (FlagV1::SignAwareZeroPad as u32)) != 0 {\n+                // a sign always goes first\n+                let sign = unsafe { str::from_utf8_unchecked(formatted.sign) };\n+                try!(self.buf.write_str(sign));\n+\n+                // remove the sign from the formatted parts\n+                formatted.sign = b\"\";\n+                width = if width < sign.len() { 0 } else { width - sign.len() };\n+                align = Alignment::Right;\n+                self.fill = '0';\n+            }\n+\n+            // remaining parts go through the ordinary padding process.\n+            let len = formatted.len();\n+            let ret = if width <= len { // no padding\n+                self.write_formatted_parts(&formatted)\n+            } else {\n+                self.with_padding(width - len, align, |f| {\n+                    f.write_formatted_parts(&formatted)\n+                })\n+            };\n+            self.fill = old_fill;\n+            ret\n+        } else {\n+            // this is the common case and we take a shortcut\n+            self.write_formatted_parts(formatted)\n+        }\n+    }\n+\n+    fn write_formatted_parts(&mut self, formatted: &flt2dec::Formatted) -> Result {\n+        fn write_bytes(buf: &mut Write, s: &[u8]) -> Result {\n+            buf.write_str(unsafe { str::from_utf8_unchecked(s) })\n+        }\n+\n+        if !formatted.sign.is_empty() {\n+            try!(write_bytes(self.buf, formatted.sign));\n+        }\n+        for part in formatted.parts {\n+            match *part {\n+                flt2dec::Part::Zero(mut nzeroes) => {\n+                    const ZEROES: &'static str = // 64 zeroes\n+                        \"0000000000000000000000000000000000000000000000000000000000000000\";\n+                    while nzeroes > ZEROES.len() {\n+                        try!(self.buf.write_str(ZEROES));\n+                        nzeroes -= ZEROES.len();\n+                    }\n+                    if nzeroes > 0 {\n+                        try!(self.buf.write_str(&ZEROES[..nzeroes]));\n+                    }\n+                }\n+                flt2dec::Part::Num(mut v) => {\n+                    let mut s = [0; 5];\n+                    let len = part.len();\n+                    for c in s[..len].iter_mut().rev() {\n+                        *c = b'0' + (v % 10) as u8;\n+                        v /= 10;\n+                    }\n+                    try!(write_bytes(self.buf, &s[..len]));\n+                }\n+                flt2dec::Part::Copy(buf) => {\n+                    try!(write_bytes(self.buf, buf));\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     /// Writes some data to the underlying buffer contained within this\n     /// formatter.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -918,73 +994,79 @@ impl<'a, T> Pointer for &'a mut T {\n }\n \n // Common code of floating point Debug and Display.\n-fn float_to_str_common<T: float::MyFloat, F>(num: &T, precision: Option<usize>,\n-                                             post: F) -> Result\n-        where F : FnOnce(&str) -> Result {\n-    let digits = match precision {\n-        Some(i) => float::DigExact(i),\n-        None => float::DigMax(6),\n+fn float_to_decimal_common<T>(fmt: &mut Formatter, num: &T, negative_zero: bool) -> Result\n+    where T: flt2dec::DecodableFloat\n+{\n+    let force_sign = fmt.flags & (1 << (FlagV1::SignPlus as u32)) != 0;\n+    let sign = match (force_sign, negative_zero) {\n+        (false, false) => flt2dec::Sign::Minus,\n+        (false, true)  => flt2dec::Sign::MinusRaw,\n+        (true,  false) => flt2dec::Sign::MinusPlus,\n+        (true,  true)  => flt2dec::Sign::MinusPlusRaw,\n+    };\n+\n+    let mut buf = [0; 1024]; // enough for f32 and f64\n+    let mut parts = [flt2dec::Part::Zero(0); 16];\n+    let formatted = if let Some(precision) = fmt.precision {\n+        flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact, *num, sign,\n+                                    precision, false, &mut buf, &mut parts)\n+    } else {\n+        flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num, sign,\n+                                 0, false, &mut buf, &mut parts)\n+    };\n+    fmt.pad_formatted_parts(&formatted)\n+}\n+\n+// Common code of floating point LowerExp and UpperExp.\n+fn float_to_exponential_common<T>(fmt: &mut Formatter, num: &T, upper: bool) -> Result\n+    where T: flt2dec::DecodableFloat\n+{\n+    let force_sign = fmt.flags & (1 << (FlagV1::SignPlus as u32)) != 0;\n+    let sign = match force_sign {\n+        false => flt2dec::Sign::Minus,\n+        true  => flt2dec::Sign::MinusPlus,\n     };\n-    float::float_to_str_bytes_common(num.abs(),\n-                                     digits,\n-                                     float::ExpNone,\n-                                     false,\n-                                     post)\n+\n+    let mut buf = [0; 1024]; // enough for f32 and f64\n+    let mut parts = [flt2dec::Part::Zero(0); 16];\n+    let formatted = if let Some(precision) = fmt.precision {\n+        // 1 integral digit + `precision` fractional digits = `precision + 1` total digits\n+        flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact, *num, sign,\n+                                  precision + 1, upper, &mut buf, &mut parts)\n+    } else {\n+        flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest, *num, sign,\n+                                     (0, 0), upper, &mut buf, &mut parts)\n+    };\n+    fmt.pad_formatted_parts(&formatted)\n }\n \n macro_rules! floating { ($ty:ident) => {\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Debug for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            float_to_str_common(self, fmt.precision, |absolute| {\n-                // is_positive() counts -0.0 as negative\n-                fmt.pad_integral(self.is_nan() || self.is_positive(), \"\", absolute)\n-            })\n+            float_to_decimal_common(fmt, self, true)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Display for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            float_to_str_common(self, fmt.precision, |absolute| {\n-                // simple comparison counts -0.0 as positive\n-                fmt.pad_integral(self.is_nan() || *self >= 0.0, \"\", absolute)\n-            })\n+            float_to_decimal_common(fmt, self, false)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl LowerExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            let digits = match fmt.precision {\n-                Some(i) => float::DigExact(i),\n-                None => float::DigMax(6),\n-            };\n-            float::float_to_str_bytes_common(self.abs(),\n-                                             digits,\n-                                             float::ExpDec,\n-                                             false,\n-                                             |bytes| {\n-                fmt.pad_integral(self.is_nan() || *self >= 0.0, \"\", bytes)\n-            })\n+            float_to_exponential_common(fmt, self, false)\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl UpperExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            let digits = match fmt.precision {\n-                Some(i) => float::DigExact(i),\n-                None => float::DigMax(6),\n-            };\n-            float::float_to_str_bytes_common(self.abs(),\n-                                             digits,\n-                                             float::ExpDec,\n-                                             true,\n-                                             |bytes| {\n-                fmt.pad_integral(self.is_nan() || *self >= 0.0, \"\", bytes)\n-            })\n+            float_to_exponential_common(fmt, self, true)\n         }\n     }\n } }\n@@ -1062,7 +1144,7 @@ impl<T: Copy + Debug> Debug for Cell<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Debug> Debug for RefCell<T> {\n+impl<T: ?Sized + Debug> Debug for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match self.borrow_state() {\n             BorrowState::Unused | BorrowState::Reading => {\n@@ -1074,14 +1156,14 @@ impl<T: Debug> Debug for RefCell<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, T: Debug> Debug for Ref<'b, T> {\n+impl<'b, T: ?Sized + Debug> Debug for Ref<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Debug::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, T: Debug> Debug for RefMut<'b, T> {\n+impl<'b, T: ?Sized + Debug> Debug for RefMut<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Debug::fmt(&*(self.deref()), f)\n     }"}, {"sha": "a92b72e0f00faa542598e1ccd7650277c9526902", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -111,6 +111,7 @@ impl SipHasher {\n         state\n     }\n \n+    #[inline]\n     fn reset(&mut self) {\n         self.length = 0;\n         self.v0 = self.k0 ^ 0x736f6d6570736575;\n@@ -120,6 +121,7 @@ impl SipHasher {\n         self.ntail = 0;\n     }\n \n+    #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n         self.length += length;\n@@ -173,6 +175,7 @@ impl Hasher for SipHasher {\n         self.write(msg)\n     }\n \n+    #[inline]\n     fn finish(&self) -> u64 {\n         let mut v0 = self.v0;\n         let mut v1 = self.v1;"}, {"sha": "100b7e70591f9c10d749fe53eed7ceefcfb842b1", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -232,10 +232,6 @@ extern \"rust-intrinsic\" {\n     pub fn uninit<T>() -> T;\n \n     /// Moves a value out of scope without running drop glue.\n-    ///\n-    /// `forget` is unsafe because the caller is responsible for\n-    /// ensuring the argument is deallocated already.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn forget<T>(_: T) -> ();\n \n     /// Unsafely transforms a value of one type into a value of another type.\n@@ -267,9 +263,6 @@ extern \"rust-intrinsic\" {\n     /// `Copy`, then may return `true` or `false`.\n     pub fn needs_drop<T>() -> bool;\n \n-    /// Returns `true` if a type is managed (will be allocated on the local heap)\n-    pub fn owns_managed<T>() -> bool;\n-\n     /// Calculates the offset from a pointer.\n     ///\n     /// This is implemented as an intrinsic to avoid converting to and from an"}, {"sha": "e4d2ab198630a4fd5ed8875e82333d72739d0fe0", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 266, "deletions": 64, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -82,7 +82,7 @@ fn _assert_is_object_safe(_: &Iterator<Item=()>) {}\n /// is returned. A concrete Iterator implementation may choose to behave however\n /// it wishes, either by returning `None` infinitely, or by doing something\n /// else.\n-#[lang=\"iterator\"]\n+#[lang = \"iterator\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"`{Self}` is not an iterator; maybe try calling \\\n                             `.iter()` or a similar method\"]\n@@ -106,6 +106,18 @@ pub trait Iterator {\n \n     /// Counts the number of elements in this iterator.\n     ///\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so counting elements of\n+    /// an iterator with more than `usize::MAX` elements either produces the\n+    /// wrong result or panics. If debug assertions are enabled, a panic is\n+    /// guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This functions might panic if the iterator has more than `usize::MAX`\n+    /// elements.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -115,7 +127,8 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn count(self) -> usize where Self: Sized {\n-        self.fold(0, |cnt, _x| cnt + 1)\n+        // Might overflow.\n+        self.fold(0, |cnt, _| cnt + 1)\n     }\n \n     /// Loops through the entire iterator, returning the last element.\n@@ -124,7 +137,7 @@ pub trait Iterator {\n     ///\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n-    /// assert!(a.iter().last().unwrap() == &5);\n+    /// assert_eq!(a.iter().last().unwrap(), &5);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -142,8 +155,8 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n-    /// assert!(it.nth(2).unwrap() == &3);\n-    /// assert!(it.nth(2) == None);\n+    /// assert_eq!(it.nth(2).unwrap(), &3);\n+    /// assert_eq!(it.nth(2), None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -281,6 +294,17 @@ pub trait Iterator {\n     /// different sized integer, the `zip` function provides similar\n     /// functionality.\n     ///\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so enumerating more than\n+    /// `usize::MAX` elements either produces the wrong result or panics. If\n+    /// debug assertions are enabled, a panic is guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// The returned iterator might panic if the to-be-returned index would\n+    /// overflow a `usize`.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -293,7 +317,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn enumerate(self) -> Enumerate<Self> where Self: Sized {\n-        Enumerate{iter: self, count: 0}\n+        Enumerate { iter: self, count: 0 }\n     }\n \n     /// Creates an iterator that has a `.peek()` method\n@@ -521,8 +545,8 @@ pub trait Iterator {\n     /// let mut it = 0..10;\n     /// // sum the first five values\n     /// let partial_sum = it.by_ref().take(5).fold(0, |a, b| a + b);\n-    /// assert!(partial_sum == 10);\n-    /// assert!(it.next() == Some(5));\n+    /// assert_eq!(partial_sum, 10);\n+    /// assert_eq!(it.next(), Some(5));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n@@ -578,11 +602,13 @@ pub trait Iterator {\n     /// Performs a fold operation over the entire iterator, returning the\n     /// eventual state at the end of the iteration.\n     ///\n+    /// This operation is sometimes called 'reduce' or 'inject'.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n-    /// assert!(a.iter().fold(0, |acc, &item| acc + item) == 15);\n+    /// assert_eq!(a.iter().fold(0, |acc, &item| acc + item), 15);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -626,12 +652,10 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.any(|x| *x == 3));\n-    /// assert_eq!(&it[..], [4, 5]);\n-    ///\n+    /// assert_eq!(it.collect::<Vec<_>>(), [&4, &5]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -654,11 +678,10 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert_eq!(it.find(|&x| *x == 3).unwrap(), &3);\n-    /// assert_eq!(&it[..], [4, 5]);\n+    /// assert_eq!(it.collect::<Vec<_>>(), [&4, &5]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item> where\n@@ -675,26 +698,36 @@ pub trait Iterator {\n     ///\n     /// Does not consume the iterator past the first found element.\n     ///\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so if there are more\n+    /// than `usize::MAX` non-matching elements, it either produces the wrong\n+    /// result or panics. If debug assertions are enabled, a panic is\n+    /// guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This functions might panic if the iterator has more than `usize::MAX`\n+    /// non-matching elements.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert_eq!(it.position(|x| *x == 3).unwrap(), 2);\n-    /// assert_eq!(&it[..], [4, 5]);\n+    /// assert_eq!(it.collect::<Vec<_>>(), [&4, &5]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n         Self: Sized,\n         P: FnMut(Self::Item) -> bool,\n     {\n-        let mut i = 0;\n-        for x in self.by_ref() {\n+        // `enumerate` might overflow.\n+        for (i, x) in self.by_ref().enumerate() {\n             if predicate(x) {\n                 return Some(i);\n             }\n-            i += 1;\n         }\n         None\n     }\n@@ -708,11 +741,10 @@ pub trait Iterator {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(core)]\n     /// let a = [1, 2, 2, 4, 5];\n     /// let mut it = a.iter();\n     /// assert_eq!(it.rposition(|x| *x == 2).unwrap(), 2);\n-    /// assert_eq!(&it[..], [1, 2]);\n+    /// assert_eq!(it.collect::<Vec<_>>(), [&1, &2]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n@@ -725,6 +757,8 @@ pub trait Iterator {\n             if predicate(v) {\n                 return Some(i - 1);\n             }\n+            // No need for an overflow check here, because `ExactSizeIterator`\n+            // implies that the number of elements fits into a `usize`.\n             i -= 1;\n         }\n         None\n@@ -739,7 +773,7 @@ pub trait Iterator {\n     ///\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n-    /// assert!(a.iter().max().unwrap() == &5);\n+    /// assert_eq!(a.iter().max().unwrap(), &5);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -762,7 +796,7 @@ pub trait Iterator {\n     ///\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n-    /// assert!(a.iter().min().unwrap() == &1);\n+    /// assert_eq!(a.iter().min().unwrap(), &1);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -800,13 +834,13 @@ pub trait Iterator {\n     /// assert_eq!(a.iter().min_max(), NoElements);\n     ///\n     /// let a = [1];\n-    /// assert!(a.iter().min_max() == OneElement(&1));\n+    /// assert_eq!(a.iter().min_max(), OneElement(&1));\n     ///\n     /// let a = [1, 2, 3, 4, 5];\n-    /// assert!(a.iter().min_max() == MinMax(&1, &5));\n+    /// assert_eq!(a.iter().min_max(), MinMax(&1, &5));\n     ///\n     /// let a = [1, 1, 1, 1];\n-    /// assert!(a.iter().min_max() == MinMax(&1, &1));\n+    /// assert_eq!(a.iter().min_max(), MinMax(&1, &1));\n     /// ```\n     #[unstable(feature = \"core\", reason = \"return type may change\")]\n     fn min_max(mut self) -> MinMaxResult<Self::Item> where Self: Sized, Self::Item: Ord\n@@ -1024,7 +1058,7 @@ pub trait Iterator {\n     ///\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().cloned();\n-    /// assert!(it.sum::<i32>() == 15);\n+    /// assert_eq!(it.sum::<i32>(), 15);\n     /// ```\n     #[unstable(feature=\"core\")]\n     fn sum<S=<Self as Iterator>::Item>(self) -> S where\n@@ -1044,9 +1078,9 @@ pub trait Iterator {\n     /// fn factorial(n: u32) -> u32 {\n     ///     (1..).take_while(|&i| i <= n).product()\n     /// }\n-    /// assert!(factorial(0) == 1);\n-    /// assert!(factorial(1) == 1);\n-    /// assert!(factorial(5) == 120);\n+    /// assert_eq!(factorial(0), 1);\n+    /// assert_eq!(factorial(1), 1);\n+    /// assert_eq!(factorial(5), 120);\n     /// ```\n     #[unstable(feature=\"core\")]\n     fn product<P=<Self as Iterator>::Item>(self) -> P where\n@@ -1477,6 +1511,32 @@ impl<A, B> Iterator for Chain<A, B> where\n         }\n     }\n \n+    #[inline]\n+    fn count(self) -> usize {\n+        (if !self.flag { self.a.count() } else { 0 }) + self.b.count()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n+        if !self.flag {\n+            for x in self.a.by_ref() {\n+                if n == 0 {\n+                    return Some(x)\n+                }\n+                n -= 1;\n+            }\n+            self.flag = true;\n+        }\n+        self.b.nth(n)\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<A::Item> {\n+        let a_last = if self.flag { None } else { self.a.last() };\n+        let b_last = self.b.last();\n+        b_last.or(a_last)\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (a_lower, a_upper) = self.a.size_hint();\n@@ -1762,17 +1822,27 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Enumerate<I> {\n     iter: I,\n-    count: usize\n+    count: usize,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> Iterator for Enumerate<I> where I: Iterator {\n     type Item = (usize, <I as Iterator>::Item);\n \n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so enumerating more than\n+    /// `usize::MAX` elements either produces the wrong result or panics. If\n+    /// debug assertions are enabled, a panic is guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Might panic if the index of the element overflows a `usize`.\n     #[inline]\n     fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n         self.iter.next().map(|a| {\n             let ret = (self.count, a);\n+            // Possible undefined overflow.\n             self.count += 1;\n             ret\n         })\n@@ -1782,6 +1852,20 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n+        self.iter.nth(n).map(|a| {\n+            let i = self.count + n;\n+            self.count = i + 1;\n+            (i, a)\n+        })\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1792,6 +1876,8 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n     fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n         self.iter.next_back().map(|a| {\n             let len = self.iter.len();\n+            // Can safely add, `ExactSizeIterator` promises that the number of\n+            // elements fits into a `usize`.\n             (self.count + len, a)\n         })\n     }\n@@ -1806,6 +1892,9 @@ impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n \n     #[inline]\n     fn idx(&mut self, index: usize) -> Option<(usize, <I as Iterator>::Item)> {\n+        // Can safely add, `ExactSizeIterator` (ancestor of\n+        // `RandomAccessIterator`) promises that the number of elements fits\n+        // into a `usize`.\n         self.iter.idx(index).map(|a| (self.count + index, a))\n     }\n }\n@@ -1839,6 +1928,28 @@ impl<I: Iterator> Iterator for Peekable<I> {\n         }\n     }\n \n+    #[inline]\n+    fn count(self) -> usize {\n+        (if self.peeked.is_some() { 1 } else { 0 }) + self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        match self.peeked {\n+            Some(_) if n == 0 => self.peeked.take(),\n+            Some(_) => {\n+                self.peeked = None;\n+                self.iter.nth(n-1)\n+            },\n+            None => self.iter.nth(n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<I::Item> {\n+        self.iter.last().or(self.peeked)\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lo, hi) = self.iter.size_hint();\n@@ -1965,27 +2076,49 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n     #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        let mut next = self.iter.next();\n+    fn next(&mut self) -> Option<I::Item> {\n         if self.n == 0 {\n-            next\n+            self.iter.next()\n         } else {\n-            let mut n = self.n;\n-            while n > 0 {\n-                n -= 1;\n-                match next {\n-                    Some(_) => {\n-                        next = self.iter.next();\n-                        continue\n-                    }\n-                    None => {\n-                        self.n = 0;\n-                        return None\n-                    }\n-                }\n-            }\n+            let old_n = self.n;\n             self.n = 0;\n-            next\n+            self.iter.nth(old_n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        // Can't just add n + self.n due to overflow.\n+        if self.n == 0 {\n+            self.iter.nth(n)\n+        } else {\n+            let to_skip = self.n;\n+            self.n = 0;\n+            // nth(n) skips n+1\n+            if self.iter.nth(to_skip-1).is_none() {\n+                return None;\n+            }\n+            self.iter.nth(n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count().saturating_sub(self.n)\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.last()\n+        } else {\n+            let next = self.next();\n+            if next.is_some() {\n+                // recurse. n should be 0.\n+                self.last().or(next)\n+            } else {\n+                None\n+            }\n         }\n     }\n \n@@ -2043,6 +2176,20 @@ impl<I> Iterator for Take<I> where I: Iterator{\n         }\n     }\n \n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.n > n {\n+            self.n -= n + 1;\n+            self.iter.nth(n)\n+        } else {\n+            if self.n > 0 {\n+                self.iter.nth(self.n - 1);\n+                self.n = 0;\n+            }\n+            None\n+        }\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, upper) = self.iter.size_hint();\n@@ -2204,6 +2351,35 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n         }\n     }\n \n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            let nth = self.iter.nth(n);\n+            self.done = nth.is_none();\n+            nth\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<I::Item> {\n+        if self.done {\n+            None\n+        } else {\n+            self.iter.last()\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        if self.done {\n+            0\n+        } else {\n+            self.iter.count()\n+        }\n+    }\n+\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.done {\n@@ -2402,14 +2578,10 @@ pub trait Step: PartialOrd {\n     /// Steps `self` if possible.\n     fn step(&self, by: &Self) -> Option<Self>;\n \n-    /// Returns the number of steps between two step objects.\n-    ///\n-    /// `start` should always be less than `end`, so the result should never\n-    /// be negative.\n+    /// Returns the number of steps between two step objects. The count is\n+    /// inclusive of `start` and exclusive of `end`.\n     ///\n-    /// `by` must be > 0.\n-    ///\n-    /// Returns `None` if it is not possible to calculate steps_between\n+    /// Returns `None` if it is not possible to calculate `steps_between`\n     /// without overflow.\n     fn steps_between(start: &Self, end: &Self, by: &Self) -> Option<usize>;\n }\n@@ -2424,9 +2596,16 @@ macro_rules! step_impl_unsigned {\n             #[inline]\n             #[allow(trivial_numeric_casts)]\n             fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n-                if *start <= *end {\n+                if *by == 0 { return None; }\n+                if *start < *end {\n                     // Note: We assume $t <= usize here\n-                    Some((*end - *start) as usize / (*by as usize))\n+                    let diff = (*end - *start) as usize;\n+                    let by = *by as usize;\n+                    if diff % by > 0 {\n+                        Some(diff / by + 1)\n+                    } else {\n+                        Some(diff / by)\n+                    }\n                 } else {\n                     Some(0)\n                 }\n@@ -2444,16 +2623,29 @@ macro_rules! step_impl_signed {\n             #[inline]\n             #[allow(trivial_numeric_casts)]\n             fn steps_between(start: &$t, end: &$t, by: &$t) -> Option<usize> {\n-                if *start <= *end {\n+                if *by == 0 { return None; }\n+                let mut diff: usize;\n+                let mut by_u: usize;\n+                if *by > 0 {\n+                    if *start >= *end {\n+                        return Some(0);\n+                    }\n                     // Note: We assume $t <= isize here\n                     // Use .wrapping_sub and cast to usize to compute the\n                     // difference that may not fit inside the range of isize.\n-                    Some(\n-                        ((*end as isize).wrapping_sub(*start as isize) as usize\n-                        / (*by as usize))\n-                    )\n+                    diff = (*end as isize).wrapping_sub(*start as isize) as usize;\n+                    by_u = *by as usize;\n                 } else {\n-                    Some(0)\n+                    if *start <= *end {\n+                        return Some(0);\n+                    }\n+                    diff = (*start as isize).wrapping_sub(*end as isize) as usize;\n+                    by_u = (*by as isize).wrapping_mul(-1) as usize;\n+                }\n+                if diff % by_u > 0 {\n+                    Some(diff / by_u + 1)\n+                } else {\n+                    Some(diff / by_u)\n                 }\n             }\n         }\n@@ -2675,6 +2867,16 @@ impl<A: Step + Zero + Clone> Iterator for StepBy<A, ops::Range<A>> {\n             None\n         }\n     }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match Step::steps_between(&self.range.start,\n+                                  &self.range.end,\n+                                  &self.step_by) {\n+            Some(hint) => (hint, Some(hint)),\n+            None       => (0, None)\n+        }\n+    }\n }\n \n macro_rules! range_exact_iter_impl {"}, {"sha": "54877c070cbe48f7368eb1f24aa68e1b246f0c04", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// Entry point of task panic, for details, see std::macros\n+/// Entry point of thread panic, for details, see std::macros\n #[macro_export]\n macro_rules! panic {\n     () => ("}, {"sha": "3aaedaeb813e38a1186848dddb09932ddfa59564", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -33,7 +33,7 @@ use hash::Hasher;\n \n /// Types able to be transferred across thread boundaries.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[lang=\"send\"]\n+#[lang = \"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n pub unsafe trait Send {\n     // empty.\n@@ -43,11 +43,10 @@ unsafe impl Send for .. { }\n \n impl<T> !Send for *const T { }\n impl<T> !Send for *mut T { }\n-impl !Send for Managed { }\n \n /// Types with a constant size known at compile-time.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[lang=\"sized\"]\n+#[lang = \"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n #[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n pub trait Sized {\n@@ -155,7 +154,7 @@ pub trait Sized {\n /// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n /// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[lang=\"copy\"]\n+#[lang = \"copy\"]\n pub trait Copy : Clone {\n     // Empty.\n }\n@@ -202,7 +201,7 @@ pub trait Copy : Clone {\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[lang=\"sync\"]\n+#[lang = \"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n pub unsafe trait Sync {\n     // Empty\n@@ -212,25 +211,16 @@ unsafe impl Sync for .. { }\n \n impl<T> !Sync for *const T { }\n impl<T> !Sync for *mut T { }\n-impl !Sync for Managed { }\n \n /// A type which is considered \"not POD\", meaning that it is not\n /// implicitly copyable. This is typically embedded in other types to\n /// ensure that they are never copied, even if they lack a destructor.\n #[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n-#[lang=\"no_copy_bound\"]\n+#[lang = \"no_copy_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n pub struct NoCopy;\n \n-/// A type which is considered managed by the GC. This is typically\n-/// embedded in other types.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to change with new variance strategy\")]\n-#[lang=\"managed_bound\"]\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct Managed;\n-\n macro_rules! impls{\n     ($t: ident) => (\n         impl<T:?Sized> Hash for $t<T> {\n@@ -323,7 +313,7 @@ macro_rules! impls{\n /// mismatches by enforcing types in the method implementations:\n ///\n /// ```\n-/// # trait ResType { fn foo(&self); };\n+/// # trait ResType { fn foo(&self); }\n /// # struct ParamType;\n /// # mod foreign_lib {\n /// # pub fn new(_: usize) -> *mut () { 42 as *mut () }\n@@ -369,7 +359,7 @@ macro_rules! impls{\n /// better to use a reference type, like `PhantomData<&'a T>`\n /// (ideally) or `PhantomData<*const T>` (if no lifetime applies), so\n /// as not to indicate ownership.\n-#[lang=\"phantom_data\"]\n+#[lang = \"phantom_data\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T:?Sized>;\n \n@@ -416,6 +406,8 @@ mod impls {\n #[rustc_reflect_like]\n #[unstable(feature = \"core\", reason = \"requires RFC and more experience\")]\n #[allow(deprecated)]\n+#[rustc_on_unimplemented = \"`{Self}` does not implement `Any`; \\\n+                            ensure all type parameters are bounded by `Any`\"]\n pub trait Reflect {}\n \n impl Reflect for .. { }"}, {"sha": "a149af3a44063c44afa1376f589af192ced14c47", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -22,15 +22,54 @@ use ptr;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::transmute;\n \n-/// Moves a thing into the void.\n+/// Leaks a value into the void, consuming ownership and never running its\n+/// destructor.\n ///\n-/// The forget function will take ownership of the provided value but neglect\n-/// to run any required cleanup or memory management operations on it.\n+/// This function will take ownership of its argument, but is distinct from the\n+/// `mem::drop` function in that it **does not run the destructor**, leaking the\n+/// value and any resources that it owns.\n ///\n-/// This function is the unsafe version of the `drop` function because it does\n-/// not run any destructors.\n+/// # Safety\n+///\n+/// This function is not marked as `unsafe` as Rust does not guarantee that the\n+/// `Drop` implementation for a value will always run. Note, however, that\n+/// leaking resources such as memory or I/O objects is likely not desired, so\n+/// this function is only recommended for specialized use cases.\n+///\n+/// The safety of this function implies that when writing `unsafe` code\n+/// yourself care must be taken when leveraging a destructor that is required to\n+/// run to preserve memory safety. There are known situations where the\n+/// destructor may not run (such as if ownership of the object with the\n+/// destructor is returned) which must be taken into account.\n+///\n+/// # Other forms of Leakage\n+///\n+/// It's important to point out that this function is not the only method by\n+/// which a value can be leaked in safe Rust code. Other known sources of\n+/// leakage are:\n+///\n+/// * `Rc` and `Arc` cycles\n+/// * `mpsc::{Sender, Receiver}` cycles (they use `Arc` internally)\n+/// * Panicking destructors are likely to leak local resources\n+///\n+/// # Example\n+///\n+/// ```rust,no_run\n+/// use std::mem;\n+/// use std::fs::File;\n+///\n+/// // Leak some heap memory by never deallocating it\n+/// let heap_memory = Box::new(3);\n+/// mem::forget(heap_memory);\n+///\n+/// // Leak an I/O object, never closing the file\n+/// let file = File::open(\"foo.txt\").unwrap();\n+/// mem::forget(file);\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use intrinsics::forget;\n+pub fn forget<T>(t: T) {\n+    unsafe { intrinsics::forget(t) }\n+}\n \n /// Returns the size of a type in bytes.\n ///"}, {"sha": "13b6468105dcf9d88a0c8c3db50bd33cdc6b1221", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -31,7 +31,7 @@ unsafe impl Zeroable for u64 {}\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations.\n-#[lang=\"non_zero\"]\n+#[lang = \"non_zero\"]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\n #[unstable(feature = \"core\")]\n pub struct NonZero<T: Zeroable>(T);"}, {"sha": "e3fa7047ec88c71be6253723e6509d2e48c9376a", "filename": "src/libcore/num/float_macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -35,8 +35,8 @@ macro_rules! from_str_radix_float_impl {\n             }\n \n             let (is_positive, src) =  match src.slice_shift_char() {\n-                None             => return Err(PFE { kind: Empty }),\n-                Some(('-', \"\"))  => return Err(PFE { kind: Empty }),\n+                None             => return Err(PFE { __kind: Empty }),\n+                Some(('-', \"\"))  => return Err(PFE { __kind: Empty }),\n                 Some(('-', src)) => (false, src),\n                 Some((_, _))     => (true,  src),\n             };\n@@ -88,7 +88,7 @@ macro_rules! from_str_radix_float_impl {\n                             break;  // start of fractional part\n                         },\n                         _ => {\n-                            return Err(PFE { kind: Invalid });\n+                            return Err(PFE { __kind: Invalid });\n                         },\n                     },\n                 }\n@@ -122,7 +122,7 @@ macro_rules! from_str_radix_float_impl {\n                                 break; // start of exponent\n                             },\n                             _ => {\n-                                return Err(PFE { kind: Invalid });\n+                                return Err(PFE { __kind: Invalid });\n                             },\n                         },\n                     }\n@@ -135,7 +135,7 @@ macro_rules! from_str_radix_float_impl {\n                     let base = match c {\n                         'E' | 'e' if radix == 10 => 10.0,\n                         'P' | 'p' if radix == 16 => 2.0,\n-                        _ => return Err(PFE { kind: Invalid }),\n+                        _ => return Err(PFE { __kind: Invalid }),\n                     };\n \n                     // Parse the exponent as decimal integer\n@@ -144,13 +144,13 @@ macro_rules! from_str_radix_float_impl {\n                         Some(('-', src)) => (false, src.parse::<usize>()),\n                         Some(('+', src)) => (true,  src.parse::<usize>()),\n                         Some((_, _))     => (true,  src.parse::<usize>()),\n-                        None             => return Err(PFE { kind: Invalid }),\n+                        None             => return Err(PFE { __kind: Invalid }),\n                     };\n \n                     match (is_positive, exp) {\n                         (true,  Ok(exp)) => base.powi(exp as i32),\n                         (false, Ok(exp)) => 1.0 / base.powi(exp as i32),\n-                        (_, Err(_))      => return Err(PFE { kind: Invalid }),\n+                        (_, Err(_))      => return Err(PFE { __kind: Invalid }),\n                     }\n                 },\n                 None => 1.0, // no exponent"}, {"sha": "d6a5e44a1fb00372681874471c27fe5abc034d15", "filename": "src/libcore/num/flt2dec/bignum.rs", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fbignum.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,357 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Custom arbitrary-precision number (bignum) implementation.\n+//!\n+//! This is designed to avoid the heap allocation at expense of stack memory.\n+//! The most used bignum type, `Big32x36`, is limited by 32 \u00d7 36 = 1,152 bits\n+//! and will take at most 152 bytes of stack memory. This is (barely) enough\n+//! for handling all possible finite `f64` values.\n+//!\n+//! In principle it is possible to have multiple bignum types for different\n+//! inputs, but we don't do so to avoid the code bloat. Each bignum is still\n+//! tracked for the actual usages, so it normally doesn't matter.\n+\n+#![macro_use]\n+\n+use prelude::*;\n+use mem;\n+use intrinsics;\n+\n+/// Arithmetic operations required by bignums.\n+pub trait FullOps {\n+    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`,\n+    /// where `W` is the number of bits in `Self`.\n+    fn full_add(self, other: Self, carry: bool) -> (bool /*carry*/, Self);\n+\n+    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + carry`,\n+    /// where `W` is the number of bits in `Self`.\n+    fn full_mul(self, other: Self, carry: Self) -> (Self /*carry*/, Self);\n+\n+    /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + other2 + carry`,\n+    /// where `W` is the number of bits in `Self`.\n+    fn full_mul_add(self, other: Self, other2: Self, carry: Self) -> (Self /*carry*/, Self);\n+\n+    /// Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem`\n+    /// and `0 <= rem < other`, where `W` is the number of bits in `Self`.\n+    fn full_div_rem(self, other: Self, borrow: Self) -> (Self /*quotient*/, Self /*remainder*/);\n+}\n+\n+macro_rules! impl_full_ops {\n+    ($($ty:ty: add($addfn:path), mul/div($bigty:ident);)*) => (\n+        $(\n+            impl FullOps for $ty {\n+                fn full_add(self, other: $ty, carry: bool) -> (bool, $ty) {\n+                    // this cannot overflow, the output is between 0 and 2*2^nbits - 1\n+                    // FIXME will LLVM optimize this into ADC or similar???\n+                    let (v, carry1) = unsafe { $addfn(self, other) };\n+                    let (v, carry2) = unsafe { $addfn(v, if carry {1} else {0}) };\n+                    (carry1 || carry2, v)\n+                }\n+\n+                fn full_mul(self, other: $ty, carry: $ty) -> ($ty, $ty) {\n+                    // this cannot overflow, the output is between 0 and 2^nbits * (2^nbits - 1)\n+                    let nbits = mem::size_of::<$ty>() * 8;\n+                    let v = (self as $bigty) * (other as $bigty) + (carry as $bigty);\n+                    ((v >> nbits) as $ty, v as $ty)\n+                }\n+\n+                fn full_mul_add(self, other: $ty, other2: $ty, carry: $ty) -> ($ty, $ty) {\n+                    // this cannot overflow, the output is between 0 and 2^(2*nbits) - 1\n+                    let nbits = mem::size_of::<$ty>() * 8;\n+                    let v = (self as $bigty) * (other as $bigty) + (other2 as $bigty) +\n+                            (carry as $bigty);\n+                    ((v >> nbits) as $ty, v as $ty)\n+                }\n+\n+                fn full_div_rem(self, other: $ty, borrow: $ty) -> ($ty, $ty) {\n+                    debug_assert!(borrow < other);\n+                    // this cannot overflow, the dividend is between 0 and other * 2^nbits - 1\n+                    let nbits = mem::size_of::<$ty>() * 8;\n+                    let lhs = ((borrow as $bigty) << nbits) | (self as $bigty);\n+                    let rhs = other as $bigty;\n+                    ((lhs / rhs) as $ty, (lhs % rhs) as $ty)\n+                }\n+            }\n+        )*\n+    )\n+}\n+\n+impl_full_ops! {\n+    u8:  add(intrinsics::u8_add_with_overflow),  mul/div(u16);\n+    u16: add(intrinsics::u16_add_with_overflow), mul/div(u32);\n+    u32: add(intrinsics::u32_add_with_overflow), mul/div(u64);\n+//  u64: add(intrinsics::u64_add_with_overflow), mul/div(u128); // see RFC #521 for enabling this.\n+}\n+\n+macro_rules! define_bignum {\n+    ($name:ident: type=$ty:ty, n=$n:expr) => (\n+        /// Stack-allocated arbitrary-precision (up to certain limit) integer.\n+        ///\n+        /// This is backed by an fixed-size array of given type (\"digit\").\n+        /// While the array is not very large (normally some hundred bytes),\n+        /// copying it recklessly may result in the performance hit.\n+        /// Thus this is intentionally not `Copy`.\n+        ///\n+        /// All operations available to bignums panic in the case of over/underflows.\n+        /// The caller is responsible to use large enough bignum types.\n+        pub struct $name {\n+            /// One plus the offset to the maximum \"digit\" in use.\n+            /// This does not decrease, so be aware of the computation order.\n+            /// `base[size..]` should be zero.\n+            size: usize,\n+            /// Digits. `[a, b, c, ...]` represents `a + b*2^W + c*2^(2W) + ...`\n+            /// where `W` is the number of bits in the digit type.\n+            base: [$ty; $n]\n+        }\n+\n+        impl $name {\n+            /// Makes a bignum from one digit.\n+            pub fn from_small(v: $ty) -> $name {\n+                let mut base = [0; $n];\n+                base[0] = v;\n+                $name { size: 1, base: base }\n+            }\n+\n+            /// Makes a bignum from `u64` value.\n+            pub fn from_u64(mut v: u64) -> $name {\n+                use mem;\n+\n+                let mut base = [0; $n];\n+                let mut sz = 0;\n+                while v > 0 {\n+                    base[sz] = v as $ty;\n+                    v >>= mem::size_of::<$ty>() * 8;\n+                    sz += 1;\n+                }\n+                $name { size: sz, base: base }\n+            }\n+\n+            /// Returns true if the bignum is zero.\n+            pub fn is_zero(&self) -> bool {\n+                self.base[..self.size].iter().all(|&v| v == 0)\n+            }\n+\n+            /// Adds `other` to itself and returns its own mutable reference.\n+            pub fn add<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n+                use cmp;\n+                use num::flt2dec::bignum::FullOps;\n+\n+                let mut sz = cmp::max(self.size, other.size);\n+                let mut carry = false;\n+                for (a, b) in self.base[..sz].iter_mut().zip(other.base[..sz].iter()) {\n+                    let (c, v) = (*a).full_add(*b, carry);\n+                    *a = v;\n+                    carry = c;\n+                }\n+                if carry {\n+                    self.base[sz] = 1;\n+                    sz += 1;\n+                }\n+                self.size = sz;\n+                self\n+            }\n+\n+            /// Subtracts `other` from itself and returns its own mutable reference.\n+            pub fn sub<'a>(&'a mut self, other: &$name) -> &'a mut $name {\n+                use cmp;\n+                use num::flt2dec::bignum::FullOps;\n+\n+                let sz = cmp::max(self.size, other.size);\n+                let mut noborrow = true;\n+                for (a, b) in self.base[..sz].iter_mut().zip(other.base[..sz].iter()) {\n+                    let (c, v) = (*a).full_add(!*b, noborrow);\n+                    *a = v;\n+                    noborrow = c;\n+                }\n+                assert!(noborrow);\n+                self.size = sz;\n+                self\n+            }\n+\n+            /// Multiplies itself by a digit-sized `other` and returns its own\n+            /// mutable reference.\n+            pub fn mul_small<'a>(&'a mut self, other: $ty) -> &'a mut $name {\n+                use num::flt2dec::bignum::FullOps;\n+\n+                let mut sz = self.size;\n+                let mut carry = 0;\n+                for a in self.base[..sz].iter_mut() {\n+                    let (c, v) = (*a).full_mul(other, carry);\n+                    *a = v;\n+                    carry = c;\n+                }\n+                if carry > 0 {\n+                    self.base[sz] = carry;\n+                    sz += 1;\n+                }\n+                self.size = sz;\n+                self\n+            }\n+\n+            /// Multiplies itself by `2^bits` and returns its own mutable reference.\n+            pub fn mul_pow2<'a>(&'a mut self, bits: usize) -> &'a mut $name {\n+                use mem;\n+\n+                let digitbits = mem::size_of::<$ty>() * 8;\n+                let digits = bits / digitbits;\n+                let bits = bits % digitbits;\n+\n+                assert!(digits < $n);\n+                debug_assert!(self.base[$n-digits..].iter().all(|&v| v == 0));\n+                debug_assert!(bits == 0 || (self.base[$n-digits-1] >> (digitbits - bits)) == 0);\n+\n+                // shift by `digits * digitbits` bits\n+                for i in (0..self.size).rev() {\n+                    self.base[i+digits] = self.base[i];\n+                }\n+                for i in 0..digits {\n+                    self.base[i] = 0;\n+                }\n+\n+                // shift by `bits` bits\n+                let mut sz = self.size + digits;\n+                if bits > 0 {\n+                    let last = sz;\n+                    let overflow = self.base[last-1] >> (digitbits - bits);\n+                    if overflow > 0 {\n+                        self.base[last] = overflow;\n+                        sz += 1;\n+                    }\n+                    for i in (digits+1..last).rev() {\n+                        self.base[i] = (self.base[i] << bits) |\n+                                       (self.base[i-1] >> (digitbits - bits));\n+                    }\n+                    self.base[digits] <<= bits;\n+                    // self.base[..digits] is zero, no need to shift\n+                }\n+\n+                self.size = sz;\n+                self\n+            }\n+\n+            /// Multiplies itself by a number described by `other[0] + other[1] * 2^W +\n+            /// other[2] * 2^(2W) + ...` (where `W` is the number of bits in the digit type)\n+            /// and returns its own mutable reference.\n+            pub fn mul_digits<'a>(&'a mut self, other: &[$ty]) -> &'a mut $name {\n+                // the internal routine. works best when aa.len() <= bb.len().\n+                fn mul_inner(ret: &mut [$ty; $n], aa: &[$ty], bb: &[$ty]) -> usize {\n+                    use num::flt2dec::bignum::FullOps;\n+\n+                    let mut retsz = 0;\n+                    for (i, &a) in aa.iter().enumerate() {\n+                        if a == 0 { continue; }\n+                        let mut sz = bb.len();\n+                        let mut carry = 0;\n+                        for (j, &b) in bb.iter().enumerate() {\n+                            let (c, v) = a.full_mul_add(b, ret[i + j], carry);\n+                            ret[i + j] = v;\n+                            carry = c;\n+                        }\n+                        if carry > 0 {\n+                            ret[i + sz] = carry;\n+                            sz += 1;\n+                        }\n+                        if retsz < i + sz {\n+                            retsz = i + sz;\n+                        }\n+                    }\n+                    retsz\n+                }\n+\n+                let mut ret = [0; $n];\n+                let retsz = if self.size < other.len() {\n+                    mul_inner(&mut ret, &self.base[..self.size], other)\n+                } else {\n+                    mul_inner(&mut ret, other, &self.base[..self.size])\n+                };\n+                self.base = ret;\n+                self.size = retsz;\n+                self\n+            }\n+\n+            /// Divides itself by a digit-sized `other` and returns its own\n+            /// mutable reference *and* the remainder.\n+            pub fn div_rem_small<'a>(&'a mut self, other: $ty) -> (&'a mut $name, $ty) {\n+                use num::flt2dec::bignum::FullOps;\n+\n+                assert!(other > 0);\n+\n+                let sz = self.size;\n+                let mut borrow = 0;\n+                for a in self.base[..sz].iter_mut().rev() {\n+                    let (q, r) = (*a).full_div_rem(other, borrow);\n+                    *a = q;\n+                    borrow = r;\n+                }\n+                (self, borrow)\n+            }\n+        }\n+\n+        impl ::cmp::PartialEq for $name {\n+            fn eq(&self, other: &$name) -> bool { self.base[..] == other.base[..] }\n+        }\n+\n+        impl ::cmp::Eq for $name {\n+        }\n+\n+        impl ::cmp::PartialOrd for $name {\n+            fn partial_cmp(&self, other: &$name) -> ::option::Option<::cmp::Ordering> {\n+                ::option::Option::Some(self.cmp(other))\n+            }\n+        }\n+\n+        impl ::cmp::Ord for $name {\n+            fn cmp(&self, other: &$name) -> ::cmp::Ordering {\n+                use cmp::max;\n+                use iter::order;\n+\n+                let sz = max(self.size, other.size);\n+                let lhs = self.base[..sz].iter().cloned().rev();\n+                let rhs = other.base[..sz].iter().cloned().rev();\n+                order::cmp(lhs, rhs)\n+            }\n+        }\n+\n+        impl ::clone::Clone for $name {\n+            fn clone(&self) -> $name {\n+                $name { size: self.size, base: self.base }\n+            }\n+        }\n+\n+        impl ::fmt::Debug for $name {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                use mem;\n+\n+                let sz = if self.size < 1 {1} else {self.size};\n+                let digitlen = mem::size_of::<$ty>() * 2;\n+\n+                try!(write!(f, \"{:#x}\", self.base[sz-1]));\n+                for &v in self.base[..sz-1].iter().rev() {\n+                    try!(write!(f, \"_{:01$x}\", v, digitlen));\n+                }\n+                ::result::Result::Ok(())\n+            }\n+        }\n+    )\n+}\n+\n+/// The digit type for `Big32x36`.\n+pub type Digit32 = u32;\n+\n+define_bignum!(Big32x36: type=Digit32, n=36);\n+\n+// this one is used for testing only.\n+#[doc(hidden)]\n+pub mod tests {\n+    use prelude::*;\n+    define_bignum!(Big8x3: type=u8, n=3);\n+}\n+"}, {"sha": "f98bc11a315f0dab50c4e580262652f7e144a9b9", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Decodes a floating-point value into individual parts and error ranges.\n+\n+use prelude::*;\n+\n+use {f32, f64};\n+use num::{Float, FpCategory};\n+\n+/// Decoded unsigned finite value, such that:\n+///\n+/// - The original value equals to `mant * 2^exp`.\n+///\n+/// - Any number from `(mant - minus) * 2^exp` to `(mant + plus) * 2^exp` will\n+///   round to the original value. The range is inclusive only when\n+///   `inclusive` is true.\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub struct Decoded {\n+    /// The scaled mantissa.\n+    pub mant: u64,\n+    /// The lower error range.\n+    pub minus: u64,\n+    /// The upper error range.\n+    pub plus: u64,\n+    /// The shared exponent in base 2.\n+    pub exp: i16,\n+    /// True when the error range is inclusive.\n+    ///\n+    /// In IEEE 754, this is true when the original mantissa was even.\n+    pub inclusive: bool,\n+}\n+\n+/// Decoded unsigned value.\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum FullDecoded {\n+    /// Not-a-number.\n+    Nan,\n+    /// Infinities, either positive or negative.\n+    Infinite,\n+    /// Zero, either positive or negative.\n+    Zero,\n+    /// Finite numbers with further decoded fields.\n+    Finite(Decoded),\n+}\n+\n+/// A floating point type which can be `decode`d.\n+pub trait DecodableFloat: Float + Copy {\n+    /// Returns `x * 2^exp`. Almost same to `std::{f32,f64}::ldexp`.\n+    /// This is used for testing.\n+    fn ldexpi(f: i64, exp: isize) -> Self;\n+    /// The minimum positive normalized value.\n+    fn min_pos_norm_value() -> Self;\n+}\n+\n+impl DecodableFloat for f32 {\n+    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n+    fn min_pos_norm_value() -> Self { f32::MIN_POSITIVE }\n+}\n+\n+impl DecodableFloat for f64 {\n+    fn ldexpi(f: i64, exp: isize) -> Self { f as Self * (exp as Self).exp2() }\n+    fn min_pos_norm_value() -> Self { f64::MIN_POSITIVE }\n+}\n+\n+/// Returns a sign (true when negative) and `FullDecoded` value\n+/// from given floating point number.\n+pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n+    let (mant, exp, sign) = v.integer_decode();\n+    let even = (mant & 1) == 0;\n+    let decoded = match v.classify() {\n+        FpCategory::Nan => FullDecoded::Nan,\n+        FpCategory::Infinite => FullDecoded::Infinite,\n+        FpCategory::Zero => FullDecoded::Zero,\n+        FpCategory::Subnormal => {\n+            // neighbors: (mant - 2, exp) -- (mant, exp) -- (mant + 2, exp)\n+            // Float::integer_decode always preserves the exponent,\n+            // so the mantissa is scaled for subnormals.\n+            FullDecoded::Finite(Decoded { mant: mant, minus: 1, plus: 1,\n+                                          exp: exp, inclusive: even })\n+        }\n+        FpCategory::Normal => {\n+            let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();\n+            if mant == minnorm.0 {\n+                // neighbors: (maxmant, exp - 1) -- (minnormmant, exp) -- (minnormmant + 1, exp)\n+                // where maxmant = minnormmant * 2 - 1\n+                FullDecoded::Finite(Decoded { mant: mant << 2, minus: 1, plus: 2,\n+                                              exp: exp - 2, inclusive: even })\n+            } else {\n+                // neighbors: (mant - 1, exp) -- (mant, exp) -- (mant + 1, exp)\n+                FullDecoded::Finite(Decoded { mant: mant << 1, minus: 1, plus: 1,\n+                                              exp: exp - 1, inclusive: even })\n+            }\n+        }\n+    };\n+    (sign < 0, decoded)\n+}\n+"}, {"sha": "d42e05a91f140f2f150c297914a93faf147f4fb9", "filename": "src/libcore/num/flt2dec/estimator.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Festimator.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The exponent estimator.\n+\n+/// Finds `k_0` such that `10^(k_0-1) < mant * 2^exp <= 10^(k_0+1)`.\n+///\n+/// This is used to approximate `k = ceil(log_10 (mant * 2^exp))`;\n+/// the true `k` is either `k_0` or `k_0+1`.\n+#[doc(hidden)]\n+pub fn estimate_scaling_factor(mant: u64, exp: i16) -> i16 {\n+    // 2^(nbits-1) < mant <= 2^nbits if mant > 0\n+    let nbits = 64 - (mant - 1).leading_zeros() as i64;\n+    // 1292913986 = floor(2^32 * log_10 2)\n+    // therefore this always underestimates (or is exact), but not much.\n+    (((nbits + exp as i64) * 1292913986) >> 32) as i16\n+}\n+"}, {"sha": "f51dcf54a19590a812637ca1bc21531f841be32f", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "added", "additions": 661, "deletions": 0, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,661 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Floating-point number to decimal conversion routines.\n+\n+# Problem statement\n+\n+We are given the floating-point number `v = f * 2^e` with an integer `f`,\n+and its bounds `minus` and `plus` such that any number between `v - minus` and\n+`v + plus` will be rounded to `v`. For the simplicity we assume that\n+this range is exclusive. Then we would like to get the unique decimal\n+representation `V = 0.d[0..n-1] * 10^k` such that:\n+\n+- `d[0]` is non-zero.\n+\n+- It's correctly rounded when parsed back: `v - minus < V < v + plus`.\n+  Furthermore it is shortest such one, i.e. there is no representation\n+  with less than `n` digits that is correctly rounded.\n+\n+- It's closest to the original value: `abs(V - v) <= 10^(k-n) / 2`. Note that\n+  there might be two representations satisfying this uniqueness requirement,\n+  in which case some tie-breaking mechanism is used.\n+\n+We will call this mode of operation as to the *shortest* mode. This mode is used\n+when there is no additional constraint, and can be thought as a \"natural\" mode\n+as it matches the ordinary intuition (it at least prints `0.1f32` as \"0.1\").\n+\n+We have two more modes of operation closely related to each other. In these modes\n+we are given either the number of significant digits `n` or the last-digit\n+limitation `limit` (which determines the actual `n`), and we would like to get\n+the representation `V = 0.d[0..n-1] * 10^k` such that:\n+\n+- `d[0]` is non-zero, unless `n` was zero in which case only `k` is returned.\n+\n+- It's closest to the original value: `abs(V - v) <= 10^(k-n) / 2`. Again,\n+  there might be some tie-breaking mechanism.\n+\n+When `limit` is given but not `n`, we set `n` such that `k - n = limit`\n+so that the last digit `d[n-1]` is scaled by `10^(k-n) = 10^limit`.\n+If such `n` is negative, we clip it to zero so that we will only get `k`.\n+We are also limited by the supplied buffer. This limitation is used to print\n+the number up to given number of fractional digits without knowing\n+the correct `k` beforehand.\n+\n+We will call the mode of operation requiring `n` as to the *exact* mode,\n+and one requiring `limit` as to the *fixed* mode. The exact mode is a subset of\n+the fixed mode: the sufficiently large last-digit limitation will eventually fill\n+the supplied buffer and let the algorithm to return.\n+\n+# Implementation overview\n+\n+It is easy to get the floating point printing correct but slow (Russ Cox has\n+[demonstrated](http://research.swtch.com/ftoa) how it's easy), or incorrect but\n+fast (na\u00efve division and modulo). But it is surprisingly hard to print\n+floating point numbers correctly *and* efficiently.\n+\n+There are two classes of algorithms widely known to be correct.\n+\n+- The \"Dragon\" family of algorithm is first described by Guy L. Steele Jr. and\n+  Jon L. White. They rely on the fixed-size big integer for their correctness.\n+  A slight improvement was found later, which is posthumously described by\n+  Robert G. Burger and R. Kent Dybvig. David Gay's `dtoa.c` routine is\n+  a popular implementation of this strategy.\n+\n+- The \"Grisu\" family of algorithm is first described by Florian Loitsch.\n+  They use very cheap integer-only procedure to determine the close-to-correct\n+  representation which is at least guaranteed to be shortest. The variant,\n+  Grisu3, actively detects if the resulting representation is incorrect.\n+\n+We implement both algorithms with necessary tweaks to suit our requirements.\n+In particular, published literatures are short of the actual implementation\n+difficulties like how to avoid arithmetic overflows. Each implementation,\n+available in `strategy::dragon` and `strategy::grisu` respectively,\n+extensively describes all necessary justifications and many proofs for them.\n+(It is still difficult to follow though. You have been warned.)\n+\n+Both implementations expose two public functions:\n+\n+- `format_shortest(decoded, buf)`, which always needs at least\n+  `MAX_SIG_DIGITS` digits of buffer. Implements the shortest mode.\n+\n+- `format_exact(decoded, buf, limit)`, which accepts as small as\n+  one digit of buffer. Implements exact and fixed modes.\n+\n+They try to fill the `u8` buffer with digits and returns the number of digits\n+written and the exponent `k`. They are total for all finite `f32` and `f64`\n+inputs (Grisu internally falls back to Dragon if necessary).\n+\n+The rendered digits are formatted into the actual string form with\n+four functions:\n+\n+- `to_shortest_str` prints the shortest representation, which can be padded by\n+  zeroes to make *at least* given number of fractional digits.\n+\n+- `to_shortest_exp_str` prints the shortest representation, which can be\n+  padded by zeroes when its exponent is in the specified ranges,\n+  or can be printed in the exponential form such as `1.23e45`.\n+\n+- `to_exact_exp_str` prints the exact representation with given number of\n+  digits in the exponential form.\n+\n+- `to_exact_fixed_str` prints the fixed representation with *exactly*\n+  given number of fractional digits.\n+\n+They all return a slice of preallocated `Part` array, which corresponds to\n+the individual part of strings: a fixed string, a part of rendered digits,\n+a number of zeroes or a small (`u16`) number. The caller is expected to\n+provide a large enough buffer and `Part` array, and to assemble the final\n+string from resulting `Part`s itself.\n+\n+All algorithms and formatting functions are accompanied by extensive tests\n+in `coretest::num::flt2dec` module. It also shows how to use individual\n+functions.\n+\n+*/\n+\n+// while this is extensively documented, this is in principle private which is\n+// only made public for testing. do not expose us.\n+#![doc(hidden)]\n+\n+use prelude::*;\n+use i16;\n+use num::Float;\n+use slice::bytes;\n+pub use self::decoder::{decode, DecodableFloat, FullDecoded, Decoded};\n+\n+pub mod estimator;\n+pub mod bignum;\n+pub mod decoder;\n+\n+/// Digit-generation algorithms.\n+pub mod strategy {\n+    pub mod dragon;\n+    pub mod grisu;\n+}\n+\n+/// The minimum size of buffer necessary for the shortest mode.\n+///\n+/// It is a bit non-trivial to derive, but this is one plus the maximal number of\n+/// significant decimal digits from formatting algorithms with the shortest result.\n+/// The exact formula is `ceil(# bits in mantissa * log_10 2 + 1)`.\n+pub const MAX_SIG_DIGITS: usize = 17;\n+\n+/// When `d[..n]` contains decimal digits, increase the last digit and propagate carry.\n+/// Returns a next digit when it causes the length change.\n+#[doc(hidden)]\n+pub fn round_up(d: &mut [u8], n: usize) -> Option<u8> {\n+    match d[..n].iter().rposition(|&c| c != b'9') {\n+        Some(i) => { // d[i+1..n] is all nines\n+            d[i] += 1;\n+            for j in i+1..n { d[j] = b'0'; }\n+            None\n+        }\n+        None if n > 0 => { // 999..999 rounds to 1000..000 with an increased exponent\n+            d[0] = b'1';\n+            for j in 1..n { d[j] = b'0'; }\n+            Some(b'0')\n+        }\n+        None => { // an empty buffer rounds up (a bit strange but reasonable)\n+            Some(b'1')\n+        }\n+    }\n+}\n+\n+/// Formatted parts.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Part<'a> {\n+    /// Given number of zero digits.\n+    Zero(usize),\n+    /// A literal number up to 5 digits.\n+    Num(u16),\n+    /// A verbatim copy of given bytes.\n+    Copy(&'a [u8]),\n+}\n+\n+impl<'a> Part<'a> {\n+    /// Returns the exact byte length of given part.\n+    pub fn len(&self) -> usize {\n+        match *self {\n+            Part::Zero(nzeroes) => nzeroes,\n+            Part::Num(v) => if v < 1_000 { if v < 10 { 1 } else if v < 100 { 2 } else { 3 } }\n+                            else { if v < 10_000 { 4 } else { 5 } },\n+            Part::Copy(buf) => buf.len(),\n+        }\n+    }\n+\n+    /// Writes a part into the supplied buffer.\n+    /// Returns the number of written bytes, or `None` if the buffer is not enough.\n+    /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n+    pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n+        let len = self.len();\n+        if out.len() >= len {\n+            match *self {\n+                Part::Zero(nzeroes) => {\n+                    for c in &mut out[..nzeroes] { *c = b'0'; }\n+                }\n+                Part::Num(mut v) => {\n+                    for c in out[..len].iter_mut().rev() {\n+                        *c = b'0' + (v % 10) as u8;\n+                        v /= 10;\n+                    }\n+                }\n+                Part::Copy(buf) => {\n+                    bytes::copy_memory(buf, out);\n+                }\n+            }\n+            Some(len)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Formatted result containing one or more parts.\n+/// This can be written to the byte buffer or converted to the allocated string.\n+#[derive(Clone)]\n+pub struct Formatted<'a> {\n+    /// A byte slice representing a sign, either `\"\"`, `\"-\"` or `\"+\"`.\n+    pub sign: &'static [u8],\n+    /// Formatted parts to be rendered after a sign and optional zero padding.\n+    pub parts: &'a [Part<'a>],\n+}\n+\n+impl<'a> Formatted<'a> {\n+    /// Returns the exact byte length of combined formatted result.\n+    pub fn len(&self) -> usize {\n+        let mut len = self.sign.len();\n+        for part in self.parts {\n+            len += part.len();\n+        }\n+        len\n+    }\n+\n+    /// Writes all formatted parts into the supplied buffer.\n+    /// Returns the number of written bytes, or `None` if the buffer is not enough.\n+    /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n+    pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n+        if out.len() < self.sign.len() { return None; }\n+        bytes::copy_memory(self.sign, out);\n+\n+        let mut written = self.sign.len();\n+        for part in self.parts {\n+            match part.write(&mut out[written..]) {\n+                Some(len) => { written += len; }\n+                None => { return None; }\n+            }\n+        }\n+        Some(written)\n+    }\n+}\n+\n+/// Formats given decimal digits `0.<...buf...> * 10^exp` into the decimal form\n+/// with at least given number of fractional digits. The result is stored to\n+/// the supplied parts array and a slice of written parts is returned.\n+///\n+/// `frac_digits` can be less than the number of actual fractional digits in `buf`;\n+/// it will be ignored and full digits will be printed. It is only used to print\n+/// additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n+/// it will only print given digits and nothing else.\n+fn digits_to_dec_str<'a>(buf: &'a [u8], exp: i16, frac_digits: usize,\n+                         parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n+    assert!(!buf.is_empty());\n+    assert!(buf[0] > b'0');\n+    assert!(parts.len() >= 4);\n+\n+    // if there is the restriction on the last digit position, `buf` is assumed to be\n+    // left-padded with the virtual zeroes. the number of virtual zeroes, `nzeroes`,\n+    // equals to `max(0, exp + frac_digits - buf.len())`, so that the position of\n+    // the last digit `exp - buf.len() - nzeroes` is no more than `-frac_digits`:\n+    //\n+    //                       |<-virtual->|\n+    //       |<---- buf ---->|  zeroes   |     exp\n+    //    0. 1 2 3 4 5 6 7 8 9 _ _ _ _ _ _ x 10\n+    //    |                  |           |\n+    // 10^exp    10^(exp-buf.len())   10^(exp-buf.len()-nzeroes)\n+    //\n+    // `nzeroes` is individually calculated for each case in order to avoid overflow.\n+\n+    if exp <= 0 {\n+        // the decimal point is before rendered digits: [0.][000...000][1234][____]\n+        let minus_exp = -(exp as i32) as usize;\n+        parts[0] = Part::Copy(b\"0.\");\n+        parts[1] = Part::Zero(minus_exp);\n+        parts[2] = Part::Copy(buf);\n+        if frac_digits > buf.len() && frac_digits - buf.len() > minus_exp {\n+            parts[3] = Part::Zero((frac_digits - buf.len()) - minus_exp);\n+            &parts[..4]\n+        } else {\n+            &parts[..3]\n+        }\n+    } else {\n+        let exp = exp as usize;\n+        if exp < buf.len() {\n+            // the decimal point is inside rendered digits: [12][.][34][____]\n+            parts[0] = Part::Copy(&buf[..exp]);\n+            parts[1] = Part::Copy(b\".\");\n+            parts[2] = Part::Copy(&buf[exp..]);\n+            if frac_digits > buf.len() - exp {\n+                parts[3] = Part::Zero(frac_digits - (buf.len() - exp));\n+                &parts[..4]\n+            } else {\n+                &parts[..3]\n+            }\n+        } else {\n+            // the decimal point is after rendered digits: [1234][____0000] or [1234][__][.][__].\n+            parts[0] = Part::Copy(buf);\n+            parts[1] = Part::Zero(exp - buf.len());\n+            if frac_digits > 0 {\n+                parts[2] = Part::Copy(b\".\");\n+                parts[3] = Part::Zero(frac_digits);\n+                &parts[..4]\n+            } else {\n+                &parts[..2]\n+            }\n+        }\n+    }\n+}\n+\n+/// Formats given decimal digits `0.<...buf...> * 10^exp` into the exponential form\n+/// with at least given number of significant digits. When `upper` is true,\n+/// the exponent will be prefixed by `E`; otherwise that's `e`. The result is\n+/// stored to the supplied parts array and a slice of written parts is returned.\n+///\n+/// `min_digits` can be less than the number of actual significant digits in `buf`;\n+/// it will be ignored and full digits will be printed. It is only used to print\n+/// additional zeroes after rendered digits. Thus `min_digits` of 0 means that\n+/// it will only print given digits and nothing else.\n+fn digits_to_exp_str<'a>(buf: &'a [u8], exp: i16, min_ndigits: usize, upper: bool,\n+                         parts: &'a mut [Part<'a>]) -> &'a [Part<'a>] {\n+    assert!(!buf.is_empty());\n+    assert!(buf[0] > b'0');\n+    assert!(parts.len() >= 6);\n+\n+    let mut n = 0;\n+\n+    parts[n] = Part::Copy(&buf[..1]);\n+    n += 1;\n+\n+    if buf.len() > 1 || min_ndigits > 1 {\n+        parts[n] = Part::Copy(b\".\");\n+        parts[n + 1] = Part::Copy(&buf[1..]);\n+        n += 2;\n+        if min_ndigits > buf.len() {\n+            parts[n] = Part::Zero(min_ndigits - buf.len());\n+            n += 1;\n+        }\n+    }\n+\n+    // 0.1234 x 10^exp = 1.234 x 10^(exp-1)\n+    let exp = exp as i32 - 1; // avoid underflow when exp is i16::MIN\n+    if exp < 0 {\n+        parts[n] = Part::Copy(if upper { b\"E-\" } else { b\"e-\" });\n+        parts[n + 1] = Part::Num(-exp as u16);\n+    } else {\n+        parts[n] = Part::Copy(if upper { b\"E\" } else { b\"e\" });\n+        parts[n + 1] = Part::Num(exp as u16);\n+    }\n+    &parts[..n + 2]\n+}\n+\n+/// Sign formatting options.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Sign {\n+    /// Prints `-` only for the negative non-zero values.\n+    Minus,        // -inf -1  0  0  1  inf nan\n+    /// Prints `-` only for any negative values (including the negative zero).\n+    MinusRaw,     // -inf -1 -0  0  1  inf nan\n+    /// Prints `-` for the negative non-zero values, or `+` otherwise.\n+    MinusPlus,    // -inf -1 +0 +0 +1 +inf nan\n+    /// Prints `-` for any negative values (including the negative zero), or `+` otherwise.\n+    MinusPlusRaw, // -inf -1 -0 +0 +1 +inf nan\n+}\n+\n+/// Returns the static byte string corresponding to the sign to be formatted.\n+/// It can be either `b\"\"`, `b\"+\"` or `b\"-\"`.\n+fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static [u8] {\n+    match (*decoded, sign) {\n+        (FullDecoded::Nan, _) => b\"\",\n+        (FullDecoded::Zero, Sign::Minus) => b\"\",\n+        (FullDecoded::Zero, Sign::MinusRaw) => if negative { b\"-\" } else { b\"\" },\n+        (FullDecoded::Zero, Sign::MinusPlus) => b\"+\",\n+        (FullDecoded::Zero, Sign::MinusPlusRaw) => if negative { b\"-\" } else { b\"+\" },\n+        (_, Sign::Minus) | (_, Sign::MinusRaw) => if negative { b\"-\" } else { b\"\" },\n+        (_, Sign::MinusPlus) | (_, Sign::MinusPlusRaw) => if negative { b\"-\" } else { b\"+\" },\n+    }\n+}\n+\n+/// Formats given floating point number into the decimal form with at least\n+/// given number of fractional digits. The result is stored to the supplied parts\n+/// array while utilizing given byte buffer as a scratch. `upper` is currently\n+/// unused but left for the future decision to change the case of non-finite values,\n+/// i.e. `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n+/// (which can be an empty string if no sign is rendered).\n+///\n+/// `format_shortest` should be the underlying digit-generation function.\n+/// You probably would want `strategy::grisu::format_shortest` for this.\n+///\n+/// `frac_digits` can be less than the number of actual fractional digits in `v`;\n+/// it will be ignored and full digits will be printed. It is only used to print\n+/// additional zeroes after rendered digits. Thus `frac_digits` of 0 means that\n+/// it will only print given digits and nothing else.\n+///\n+/// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n+/// There should be at least 5 parts available, due to the worst case like\n+/// `[+][0.][0000][45][0000]` with `frac_digits = 10`.\n+pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n+                                 sign: Sign, frac_digits: usize, _upper: bool,\n+                                 buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n+        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    assert!(parts.len() >= 4);\n+    assert!(buf.len() >= MAX_SIG_DIGITS);\n+\n+    let (negative, full_decoded) = decode(v);\n+    let sign = determine_sign(sign, &full_decoded, negative);\n+    match full_decoded {\n+        FullDecoded::Nan => {\n+            parts[0] = Part::Copy(b\"NaN\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Infinite => {\n+            parts[0] = Part::Copy(b\"inf\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Zero => {\n+            if frac_digits > 0 { // [0.][0000]\n+                parts[0] = Part::Copy(b\"0.\");\n+                parts[1] = Part::Zero(frac_digits);\n+                Formatted { sign: sign, parts: &parts[..2] }\n+            } else {\n+                parts[0] = Part::Copy(b\"0\");\n+                Formatted { sign: sign, parts: &parts[..1] }\n+            }\n+        }\n+        FullDecoded::Finite(ref decoded) => {\n+            let (len, exp) = format_shortest(decoded, buf);\n+            Formatted { sign: sign,\n+                        parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n+        }\n+    }\n+}\n+\n+/// Formats given floating point number into the decimal form or\n+/// the exponential form, depending on the resulting exponent. The result is\n+/// stored to the supplied parts array while utilizing given byte buffer\n+/// as a scratch. `upper` is used to determine the case of non-finite values\n+/// (`inf` and `nan`) or the case of the exponent prefix (`e` or `E`).\n+/// The first part to be rendered is always a `Part::Sign` (which can be\n+/// an empty string if no sign is rendered).\n+///\n+/// `format_shortest` should be the underlying digit-generation function.\n+/// You probably would want `strategy::grisu::format_shortest` for this.\n+///\n+/// The `dec_bounds` is a tuple `(lo, hi)` such that the number is formatted\n+/// as decimal only when `10^lo <= V < 10^hi`. Note that this is the *apparant* `V`\n+/// instead of the actual `v`! Thus any printed exponent in the exponential form\n+/// cannot be in this range, avoiding any confusion.\n+///\n+/// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n+/// There should be at least 7 parts available, due to the worst case like\n+/// `[+][1][.][2345][e][-][67]`.\n+pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n+                                     sign: Sign, dec_bounds: (i16, i16), upper: bool,\n+                                     buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n+        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    assert!(parts.len() >= 6);\n+    assert!(buf.len() >= MAX_SIG_DIGITS);\n+    assert!(dec_bounds.0 <= dec_bounds.1);\n+\n+    let (negative, full_decoded) = decode(v);\n+    let sign = determine_sign(sign, &full_decoded, negative);\n+    match full_decoded {\n+        FullDecoded::Nan => {\n+            parts[0] = Part::Copy(b\"NaN\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Infinite => {\n+            parts[0] = Part::Copy(b\"inf\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Zero => {\n+            parts[0] = if dec_bounds.0 <= 0 && 0 < dec_bounds.1 {\n+                Part::Copy(b\"0\")\n+            } else {\n+                Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" })\n+            };\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Finite(ref decoded) => {\n+            let (len, exp) = format_shortest(decoded, buf);\n+            let vis_exp = exp as i32 - 1;\n+            let parts = if dec_bounds.0 as i32 <= vis_exp && vis_exp < dec_bounds.1 as i32 {\n+                digits_to_dec_str(&buf[..len], exp, 0, parts)\n+            } else {\n+                digits_to_exp_str(&buf[..len], exp, 0, upper, parts)\n+            };\n+            Formatted { sign: sign, parts: parts }\n+        }\n+    }\n+}\n+\n+/// Returns rather crude approximation (upper bound) for the maximum buffer size\n+/// calculated from the given decoded exponent.\n+///\n+/// The exact limit is:\n+///\n+/// - when `exp < 0`, the maximum length is `ceil(log_10 (5^-exp * (2^64 - 1)))`.\n+/// - when `exp >= 0`, the maximum length is `ceil(log_10 (2^exp * (2^64 - 1)))`.\n+///\n+/// `ceil(log_10 (x^exp * (2^64 - 1)))` is less than `ceil(log_10 (2^64 - 1)) +\n+/// ceil(exp * log_10 x)`, which is in turn less than `20 + (1 + exp * log_10 x)`.\n+/// We use the facts that `log_10 2 < 5/16` and `log_10 5 < 12/16`, which is\n+/// enough for our purposes.\n+///\n+/// Why do we need this? `format_exact` functions will fill the entire buffer\n+/// unless limited by the last digit restriction, but it is possible that\n+/// the number of digits requested is ridiculously large (say, 30,000 digits).\n+/// The vast majority of buffer will be filled with zeroes, so we don't want to\n+/// allocate all the buffer beforehand. Consequently, for any given arguments,\n+/// 826 bytes of buffer should be sufficient for `f64`. Compare this with\n+/// the actual number for the worst case: 770 bytes (when `exp = -1074`).\n+fn estimate_max_buf_len(exp: i16) -> usize {\n+    21 + ((if exp < 0 { -12 } else { 5 } * exp as i32) as usize >> 4)\n+}\n+\n+/// Formats given floating point number into the exponential form with\n+/// exactly given number of significant digits. The result is stored to\n+/// the supplied parts array while utilizing given byte buffer as a scratch.\n+/// `upper` is used to determine the case of the exponent prefix (`e` or `E`).\n+/// The first part to be rendered is always a `Part::Sign` (which can be\n+/// an empty string if no sign is rendered).\n+///\n+/// `format_exact` should be the underlying digit-generation function.\n+/// You probably would want `strategy::grisu::format_exact` for this.\n+///\n+/// The byte buffer should be at least `ndigits` bytes long unless `ndigits` is\n+/// so large that only the fixed number of digits will be ever written.\n+/// (The tipping point for `f64` is about 800, so 1000 bytes should be enough.)\n+/// There should be at least 7 parts available, due to the worst case like\n+/// `[+][1][.][2345][e][-][67]`.\n+pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n+                                  sign: Sign, ndigits: usize, upper: bool,\n+                                  buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n+        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    assert!(parts.len() >= 6);\n+    assert!(ndigits > 0);\n+\n+    let (negative, full_decoded) = decode(v);\n+    let sign = determine_sign(sign, &full_decoded, negative);\n+    match full_decoded {\n+        FullDecoded::Nan => {\n+            parts[0] = Part::Copy(b\"NaN\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Infinite => {\n+            parts[0] = Part::Copy(b\"inf\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Zero => {\n+            if ndigits > 1 { // [0.][0000][e0]\n+                parts[0] = Part::Copy(b\"0.\");\n+                parts[1] = Part::Zero(ndigits - 1);\n+                parts[2] = Part::Copy(if upper { b\"E0\" } else { b\"e0\" });\n+                Formatted { sign: sign, parts: &parts[..3] }\n+            } else {\n+                parts[0] = Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" });\n+                Formatted { sign: sign, parts: &parts[..1] }\n+            }\n+        }\n+        FullDecoded::Finite(ref decoded) => {\n+            let maxlen = estimate_max_buf_len(decoded.exp);\n+            assert!(buf.len() >= ndigits || buf.len() >= maxlen);\n+\n+            let trunc = if ndigits < maxlen { ndigits } else { maxlen };\n+            let (len, exp) = format_exact(decoded, &mut buf[..trunc], i16::MIN);\n+            Formatted { sign: sign,\n+                        parts: digits_to_exp_str(&buf[..len], exp, ndigits, upper, parts) }\n+        }\n+    }\n+}\n+\n+/// Formats given floating point number into the decimal form with exactly\n+/// given number of fractional digits. The result is stored to the supplied parts\n+/// array while utilizing given byte buffer as a scratch. `upper` is currently\n+/// unused but left for the future decision to change the case of non-finite values,\n+/// i.e. `inf` and `nan`. The first part to be rendered is always a `Part::Sign`\n+/// (which can be an empty string if no sign is rendered).\n+///\n+/// `format_exact` should be the underlying digit-generation function.\n+/// You probably would want `strategy::grisu::format_exact` for this.\n+///\n+/// The byte buffer should be enough for the output unless `frac_digits` is\n+/// so large that only the fixed number of digits will be ever written.\n+/// (The tipping point for `f64` is about 800, and 1000 bytes should be enough.)\n+/// There should be at least 5 parts available, due to the worst case like\n+/// `[+][0.][0000][45][0000]` with `frac_digits = 10`.\n+pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n+                                    sign: Sign, frac_digits: usize, _upper: bool,\n+                                    buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n+        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    assert!(parts.len() >= 4);\n+\n+    let (negative, full_decoded) = decode(v);\n+    let sign = determine_sign(sign, &full_decoded, negative);\n+    match full_decoded {\n+        FullDecoded::Nan => {\n+            parts[0] = Part::Copy(b\"NaN\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Infinite => {\n+            parts[0] = Part::Copy(b\"inf\");\n+            Formatted { sign: sign, parts: &parts[..1] }\n+        }\n+        FullDecoded::Zero => {\n+            if frac_digits > 0 { // [0.][0000]\n+                parts[0] = Part::Copy(b\"0.\");\n+                parts[1] = Part::Zero(frac_digits);\n+                Formatted { sign: sign, parts: &parts[..2] }\n+            } else {\n+                parts[0] = Part::Copy(b\"0\");\n+                Formatted { sign: sign, parts: &parts[..1] }\n+            }\n+        }\n+        FullDecoded::Finite(ref decoded) => {\n+            let maxlen = estimate_max_buf_len(decoded.exp);\n+            assert!(buf.len() >= maxlen);\n+\n+            // it *is* possible that `frac_digits` is ridiculously large.\n+            // `format_exact` will end rendering digits much earlier in this case,\n+            // because we are strictly limited by `maxlen`.\n+            let limit = if frac_digits < 0x8000 { -(frac_digits as i16) } else { i16::MIN };\n+            let (len, exp) = format_exact(decoded, &mut buf[..maxlen], limit);\n+            if exp <= limit {\n+                // the restriction couldn't been met, so this should render like zero no matter\n+                // `exp` was. this does not include the case that the restriction has been met\n+                // only after the final rounding-up; it's a regular case with `exp = limit + 1`.\n+                debug_assert_eq!(len, 0);\n+                if frac_digits > 0 { // [0.][0000]\n+                    parts[0] = Part::Copy(b\"0.\");\n+                    parts[1] = Part::Zero(frac_digits);\n+                    Formatted { sign: sign, parts: &parts[..2] }\n+                } else {\n+                    parts[0] = Part::Copy(b\"0\");\n+                    Formatted { sign: sign, parts: &parts[..1] }\n+                }\n+            } else {\n+                Formatted { sign: sign,\n+                            parts: digits_to_dec_str(&buf[..len], exp, frac_digits, parts) }\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "a819932525bd14259559a5c8fb407fbfa9d1bb42", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "added", "additions": 331, "deletions": 0, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,331 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+Almost direct (but slightly optimized) Rust translation of Figure 3 of [1].\n+\n+[1] Burger, R. G. and Dybvig, R. K. 1996. Printing floating-point numbers\n+    quickly and accurately. SIGPLAN Not. 31, 5 (May. 1996), 108-116.\n+*/\n+\n+use prelude::*;\n+use num::Float;\n+use cmp::Ordering;\n+\n+use num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};\n+use num::flt2dec::estimator::estimate_scaling_factor;\n+use num::flt2dec::bignum::Digit32 as Digit;\n+use num::flt2dec::bignum::Big32x36 as Big;\n+\n+// FIXME(#22540) const ref to static array seems to ICE\n+static POW10: [Digit; 10] = [1, 10, 100, 1000, 10000, 100000,\n+                             1000000, 10000000, 100000000, 1000000000];\n+static TWOPOW10: [Digit; 10] = [2, 20, 200, 2000, 20000, 200000,\n+                                2000000, 20000000, 200000000, 2000000000];\n+\n+// precalculated arrays of `Digit`s for 10^(2^n)\n+static POW10TO16: [Digit; 2] = [0x6fc10000, 0x2386f2];\n+static POW10TO32: [Digit; 4] = [0, 0x85acef81, 0x2d6d415b, 0x4ee];\n+static POW10TO64: [Digit; 7] = [0, 0, 0xbf6a1f01, 0x6e38ed64, 0xdaa797ed, 0xe93ff9f4, 0x184f03];\n+static POW10TO128: [Digit; 14] =\n+    [0, 0, 0, 0, 0x2e953e01, 0x3df9909, 0xf1538fd, 0x2374e42f, 0xd3cff5ec, 0xc404dc08,\n+     0xbccdb0da, 0xa6337f19, 0xe91f2603, 0x24e];\n+static POW10TO256: [Digit; 27] =\n+    [0, 0, 0, 0, 0, 0, 0, 0, 0x982e7c01, 0xbed3875b, 0xd8d99f72, 0x12152f87, 0x6bde50c6,\n+     0xcf4a6e70, 0xd595d80f, 0x26b2716e, 0xadc666b0, 0x1d153624, 0x3c42d35a, 0x63ff540e,\n+     0xcc5573c0, 0x65f9ef17, 0x55bc28f2, 0x80dcc7f7, 0xf46eeddc, 0x5fdcefce, 0x553f7];\n+\n+#[doc(hidden)]\n+pub fn mul_pow10<'a>(x: &'a mut Big, n: usize) -> &'a mut Big {\n+    debug_assert!(n < 512);\n+    if n &   7 != 0 { x.mul_small(POW10[n & 7]); }\n+    if n &   8 != 0 { x.mul_small(POW10[8]); }\n+    if n &  16 != 0 { x.mul_digits(&POW10TO16); }\n+    if n &  32 != 0 { x.mul_digits(&POW10TO32); }\n+    if n &  64 != 0 { x.mul_digits(&POW10TO64); }\n+    if n & 128 != 0 { x.mul_digits(&POW10TO128); }\n+    if n & 256 != 0 { x.mul_digits(&POW10TO256); }\n+    x\n+}\n+\n+fn div_2pow10<'a>(x: &'a mut Big, mut n: usize) -> &'a mut Big {\n+    let largest = POW10.len() - 1;\n+    while n > largest {\n+        x.div_rem_small(POW10[largest]);\n+        n -= largest;\n+    }\n+    x.div_rem_small(TWOPOW10[n]);\n+    x\n+}\n+\n+// only usable when `x < 16 * scale`; `scaleN` should be `scale.mul_small(N)`\n+fn div_rem_upto_16<'a>(x: &'a mut Big, scale: &Big,\n+                       scale2: &Big, scale4: &Big, scale8: &Big) -> (u8, &'a mut Big) {\n+    let mut d = 0;\n+    if *x >= *scale8 { x.sub(scale8); d += 8; }\n+    if *x >= *scale4 { x.sub(scale4); d += 4; }\n+    if *x >= *scale2 { x.sub(scale2); d += 2; }\n+    if *x >= *scale  { x.sub(scale);  d += 1; }\n+    debug_assert!(*x < *scale);\n+    (d, x)\n+}\n+\n+/// The shortest mode implementation for Dragon.\n+pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp*/ i16) {\n+    // the number `v` to format is known to be:\n+    // - equal to `mant * 2^exp`;\n+    // - preceded by `(mant - 2 * minus) * 2^exp` in the original type; and\n+    // - followed by `(mant + 2 * plus) * 2^exp` in the original type.\n+    //\n+    // obviously, `minus` and `plus` cannot be zero. (for infinities, we use out-of-range values.)\n+    // also we assume that at least one digit is generated, i.e. `mant` cannot be zero too.\n+    //\n+    // this also means that any number between `low = (mant - minus) * 2^exp` and\n+    // `high = (mant + plus) * 2^exp` will map to this exact floating point number,\n+    // with bounds included when the original mantissa was even (i.e. `!mant_was_odd`).\n+\n+    assert!(d.mant > 0);\n+    assert!(d.minus > 0);\n+    assert!(d.plus > 0);\n+    assert!(d.mant.checked_add(d.plus).is_some());\n+    assert!(d.mant.checked_sub(d.minus).is_some());\n+    assert!(buf.len() >= MAX_SIG_DIGITS);\n+\n+    // `a.cmp(&b) < rounding` is `if d.inclusive {a <= b} else {a < b}`\n+    let rounding = if d.inclusive {Ordering::Greater} else {Ordering::Equal};\n+\n+    // estimate `k_0` from original inputs satisfying `10^(k_0-1) < high <= 10^(k_0+1)`.\n+    // the tight bound `k` satisfying `10^(k-1) < high <= 10^k` is calculated later.\n+    let mut k = estimate_scaling_factor(d.mant + d.plus, d.exp);\n+\n+    // convert `{mant, plus, minus} * 2^exp` into the fractional form so that:\n+    // - `v = mant / scale`\n+    // - `low = (mant - minus) / scale`\n+    // - `high = (mant + plus) / scale`\n+    let mut mant = Big::from_u64(d.mant);\n+    let mut minus = Big::from_u64(d.minus);\n+    let mut plus = Big::from_u64(d.plus);\n+    let mut scale = Big::from_small(1);\n+    if d.exp < 0 {\n+        scale.mul_pow2(-d.exp as usize);\n+    } else {\n+        mant.mul_pow2(d.exp as usize);\n+        minus.mul_pow2(d.exp as usize);\n+        plus.mul_pow2(d.exp as usize);\n+    }\n+\n+    // divide `mant` by `10^k`. now `scale / 10 < mant + plus <= scale * 10`.\n+    if k >= 0 {\n+        mul_pow10(&mut scale, k as usize);\n+    } else {\n+        mul_pow10(&mut mant, -k as usize);\n+        mul_pow10(&mut minus, -k as usize);\n+        mul_pow10(&mut plus, -k as usize);\n+    }\n+\n+    // fixup when `mant + plus > scale` (or `>=`).\n+    // we are not actually modifying `scale`, since we can skip the initial multiplication instead.\n+    // now `scale < mant + plus <= scale * 10` and we are ready to generate digits.\n+    //\n+    // note that `d[0]` *can* be zero, when `scale - plus < mant < scale`.\n+    // in this case rounding-up condition (`up` below) will be triggered immediately.\n+    if scale.cmp(mant.clone().add(&plus)) < rounding {\n+        // equivalent to scaling `scale` by 10\n+        k += 1;\n+    } else {\n+        mant.mul_small(10);\n+        minus.mul_small(10);\n+        plus.mul_small(10);\n+    }\n+\n+    // cache `(2, 4, 8) * scale` for digit generation.\n+    let mut scale2 = scale.clone(); scale2.mul_pow2(1);\n+    let mut scale4 = scale.clone(); scale4.mul_pow2(2);\n+    let mut scale8 = scale.clone(); scale8.mul_pow2(3);\n+\n+    let mut down;\n+    let mut up;\n+    let mut i = 0;\n+    loop {\n+        // invariants, where `d[0..n-1]` are digits generated so far:\n+        // - `v = mant / scale * 10^(k-n-1) + d[0..n-1] * 10^(k-n)`\n+        // - `v - low = minus / scale * 10^(k-n-1)`\n+        // - `high - v = plus / scale * 10^(k-n-1)`\n+        // - `(mant + plus) / scale <= 10` (thus `mant / scale < 10`)\n+        // where `d[i..j]` is a shorthand for `d[i] * 10^(j-i) + ... + d[j-1] * 10 + d[j]`.\n+\n+        // generate one digit: `d[n] = floor(mant / scale) < 10`.\n+        let (d, _) = div_rem_upto_16(&mut mant, &scale, &scale2, &scale4, &scale8);\n+        debug_assert!(d < 10);\n+        buf[i] = b'0' + d;\n+        i += 1;\n+\n+        // this is a simplified description of the modified Dragon algorithm.\n+        // many intermediate derivations and completeness arguments are omitted for convenience.\n+        //\n+        // start with modified invariants, as we've updated `n`:\n+        // - `v = mant / scale * 10^(k-n) + d[0..n-1] * 10^(k-n)`\n+        // - `v - low = minus / scale * 10^(k-n)`\n+        // - `high - v = plus / scale * 10^(k-n)`\n+        //\n+        // assume that `d[0..n-1]` is the shortest representation between `low` and `high`,\n+        // i.e. `d[0..n-1]` satisfies both of the following but `d[0..n-2]` doesn't:\n+        // - `low < d[0..n-1] * 10^(k-n) < high` (bijectivity: digits round to `v`); and\n+        // - `abs(v / 10^(k-n) - d[0..n-1]) <= 1/2` (the last digit is correct).\n+        //\n+        // the second condition simplifies to `2 * mant <= scale`.\n+        // solving invariants in terms of `mant`, `low` and `high` yields\n+        // a simpler version of the first condition: `-plus < mant < minus`.\n+        // since `-plus < 0 <= mant`, we have the correct shortest representation\n+        // when `mant < minus` and `2 * mant <= scale`.\n+        // (the former becomes `mant <= minus` when the original mantissa is even.)\n+        //\n+        // when the second doesn't hold (`2 * mant > scale`), we need to increase the last digit.\n+        // this is enough for restoring that condition: we already know that\n+        // the digit generation guarantees `0 <= v / 10^(k-n) - d[0..n-1] < 1`.\n+        // in this case, the first condition becomes `-plus < mant - scale < minus`.\n+        // since `mant < scale` after the generation, we have `scale < mant + plus`.\n+        // (again, this becomes `scale <= mant + plus` when the original mantissa is even.)\n+        //\n+        // in short:\n+        // - stop and round `down` (keep digits as is) when `mant < minus` (or `<=`).\n+        // - stop and round `up` (increase the last digit) when `scale < mant + plus` (or `<=`).\n+        // - keep generating otherwise.\n+        down = mant.cmp(&minus) < rounding;\n+        up = scale.cmp(mant.clone().add(&plus)) < rounding;\n+        if down || up { break; } // we have the shortest representation, proceed to the rounding\n+\n+        // restore the invariants.\n+        // this makes the algorithm always terminating: `minus` and `plus` always increases,\n+        // but `mant` is clipped modulo `scale` and `scale` is fixed.\n+        mant.mul_small(10);\n+        minus.mul_small(10);\n+        plus.mul_small(10);\n+    }\n+\n+    // rounding up happens when\n+    // i) only the rounding-up condition was triggered, or\n+    // ii) both conditions were triggered and tie breaking prefers rounding up.\n+    if up && (!down || *mant.mul_pow2(1) >= scale) {\n+        // if rounding up changes the length, the exponent should also change.\n+        // it seems that this condition is very hard to satisfy (possibly impossible),\n+        // but we are just being safe and consistent here.\n+        if let Some(c) = round_up(buf, i) {\n+            buf[i] = c;\n+            i += 1;\n+            k += 1;\n+        }\n+    }\n+\n+    (i, k)\n+}\n+\n+/// The exact and fixed mode implementation for Dragon.\n+pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usize, /*exp*/ i16) {\n+    assert!(d.mant > 0);\n+    assert!(d.minus > 0);\n+    assert!(d.plus > 0);\n+    assert!(d.mant.checked_add(d.plus).is_some());\n+    assert!(d.mant.checked_sub(d.minus).is_some());\n+\n+    // estimate `k_0` from original inputs satisfying `10^(k_0-1) < v <= 10^(k_0+1)`.\n+    let mut k = estimate_scaling_factor(d.mant, d.exp);\n+\n+    // `v = mant / scale`.\n+    let mut mant = Big::from_u64(d.mant);\n+    let mut scale = Big::from_small(1);\n+    if d.exp < 0 {\n+        scale.mul_pow2(-d.exp as usize);\n+    } else {\n+        mant.mul_pow2(d.exp as usize);\n+    }\n+\n+    // divide `mant` by `10^k`. now `scale / 10 < mant <= scale * 10`.\n+    if k >= 0 {\n+        mul_pow10(&mut scale, k as usize);\n+    } else {\n+        mul_pow10(&mut mant, -k as usize);\n+    }\n+\n+    // fixup when `mant + plus >= scale`, where `plus / scale = 10^-buf.len() / 2`.\n+    // in order to keep the fixed-size bignum, we actually use `mant + floor(plus) >= scale`.\n+    // we are not actually modifying `scale`, since we can skip the initial multiplication instead.\n+    // again with the shortest algorithm, `d[0]` can be zero but will be eventually rounded up.\n+    if *div_2pow10(&mut scale.clone(), buf.len()).add(&mant) >= scale {\n+        // equivalent to scaling `scale` by 10\n+        k += 1;\n+    } else {\n+        mant.mul_small(10);\n+    }\n+\n+    // if we are working with the last-digit limitation, we need to shorten the buffer\n+    // before the actual rendering in order to avoid double rounding.\n+    // note that we have to enlarge the buffer again when rounding up happens!\n+    let mut len = if k < limit {\n+        // oops, we cannot even produce *one* digit.\n+        // this is possible when, say, we've got something like 9.5 and it's being rounded to 10.\n+        // we return an empty buffer, with an exception of the later rounding-up case\n+        // which occurs when `k == limit` and has to produce exactly one digit.\n+        0\n+    } else if ((k as i32 - limit as i32) as usize) < buf.len() {\n+        (k - limit) as usize\n+    } else {\n+        buf.len()\n+    };\n+\n+    if len > 0 {\n+        // cache `(2, 4, 8) * scale` for digit generation.\n+        // (this can be expensive, so do not calculate them when the buffer is empty.)\n+        let mut scale2 = scale.clone(); scale2.mul_pow2(1);\n+        let mut scale4 = scale.clone(); scale4.mul_pow2(2);\n+        let mut scale8 = scale.clone(); scale8.mul_pow2(3);\n+\n+        for i in 0..len {\n+            if mant.is_zero() { // following digits are all zeroes, we stop here\n+                // do *not* try to perform rounding! rather, fill remaining digits.\n+                for c in &mut buf[i..len] { *c = b'0'; }\n+                return (len, k);\n+            }\n+\n+            let mut d = 0;\n+            if mant >= scale8 { mant.sub(&scale8); d += 8; }\n+            if mant >= scale4 { mant.sub(&scale4); d += 4; }\n+            if mant >= scale2 { mant.sub(&scale2); d += 2; }\n+            if mant >= scale  { mant.sub(&scale);  d += 1; }\n+            debug_assert!(mant < scale);\n+            debug_assert!(d < 10);\n+            buf[i] = b'0' + d;\n+            mant.mul_small(10);\n+        }\n+    }\n+\n+    // rounding up if we stop in the middle of digits\n+    // if the following digits are exactly 5000..., check the prior digit and try to\n+    // round to even (i.e. avoid rounding up when the prior digit is even).\n+    let order = mant.cmp(scale.mul_small(5));\n+    if order == Ordering::Greater || (order == Ordering::Equal &&\n+                                      (len == 0 || buf[len-1] & 1 == 1)) {\n+        // if rounding up changes the length, the exponent should also change.\n+        // but we've been requested a fixed number of digits, so do not alter the buffer...\n+        if let Some(c) = round_up(buf, len) {\n+            // ...unless we've been requested the fixed precision instead.\n+            // we also need to check that, if the original buffer was empty,\n+            // the additional digit can only be added when `k == limit` (edge case).\n+            k += 1;\n+            if k > limit && len < buf.len() {\n+                buf[len] = c;\n+                len += 1;\n+            }\n+        }\n+    }\n+\n+    (len, k)\n+}\n+"}, {"sha": "220811e9985c33c8843e3ed78e41c450538ef04f", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "added", "additions": 749, "deletions": 0, "changes": 749, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,749 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+Rust adaptation of Grisu3 algorithm described in [1]. It uses about\n+1KB of precomputed table, and in turn, it's very quick for most inputs.\n+\n+[1] Florian Loitsch. 2010. Printing floating-point numbers quickly and\n+    accurately with integers. SIGPLAN Not. 45, 6 (June 2010), 233-243.\n+*/\n+\n+use prelude::*;\n+use num::Float;\n+\n+use num::flt2dec::{Decoded, MAX_SIG_DIGITS, round_up};\n+\n+/// A custom 64-bit floating point type, representing `f * 2^e`.\n+#[derive(Copy, Clone, Debug)]\n+#[doc(hidden)]\n+pub struct Fp {\n+    /// The integer mantissa.\n+    pub f: u64,\n+    /// The exponent in base 2.\n+    pub e: i16,\n+}\n+\n+impl Fp {\n+    /// Returns a correctly rounded product of itself and `other`.\n+    fn mul(&self, other: &Fp) -> Fp {\n+        const MASK: u64 = 0xffffffff;\n+        let a = self.f >> 32;\n+        let b = self.f & MASK;\n+        let c = other.f >> 32;\n+        let d = other.f & MASK;\n+        let ac = a * c;\n+        let bc = b * c;\n+        let ad = a * d;\n+        let bd = b * d;\n+        let tmp = (bd >> 32) + (ad & MASK) + (bc & MASK) + (1 << 31) /* round */;\n+        let f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);\n+        let e = self.e + other.e + 64;\n+        Fp { f: f, e: e }\n+    }\n+\n+    /// Normalizes itself so that the resulting mantissa is at least `2^63`.\n+    fn normalize(&self) -> Fp {\n+        let mut f = self.f;\n+        let mut e = self.e;\n+        if f >> (64 - 32) == 0 { f <<= 32; e -= 32; }\n+        if f >> (64 - 16) == 0 { f <<= 16; e -= 16; }\n+        if f >> (64 -  8) == 0 { f <<=  8; e -=  8; }\n+        if f >> (64 -  4) == 0 { f <<=  4; e -=  4; }\n+        if f >> (64 -  2) == 0 { f <<=  2; e -=  2; }\n+        if f >> (64 -  1) == 0 { f <<=  1; e -=  1; }\n+        debug_assert!(f >= (1 >> 63));\n+        Fp { f: f, e: e }\n+    }\n+\n+    /// Normalizes itself to have the shared exponent.\n+    /// It can only decrease the exponent (and thus increase the mantissa).\n+    fn normalize_to(&self, e: i16) -> Fp {\n+        let edelta = self.e - e;\n+        assert!(edelta >= 0);\n+        let edelta = edelta as usize;\n+        assert_eq!(self.f << edelta >> edelta, self.f);\n+        Fp { f: self.f << edelta, e: e }\n+    }\n+}\n+\n+// see the comments in `format_shortest_opt` for the rationale.\n+#[doc(hidden)] pub const ALPHA: i16 = -60;\n+#[doc(hidden)] pub const GAMMA: i16 = -32;\n+\n+/*\n+# the following Python code generates this table:\n+for i in xrange(-308, 333, 8):\n+    if i >= 0: f = 10**i; e = 0\n+    else: f = 2**(80-4*i) // 10**-i; e = 4 * i - 80\n+    l = f.bit_length()\n+    f = ((f << 64 >> (l-1)) + 1) >> 1; e += l - 64\n+    print '    (%#018x, %5d, %4d),' % (f, e, i)\n+*/\n+// FIXME(#22540) const ref to static array seems to ICE\n+#[doc(hidden)]\n+pub static CACHED_POW10: [(u64, i16, i16); 81] = [ // (f, e, k)\n+    (0xe61acf033d1a45df, -1087, -308),\n+    (0xab70fe17c79ac6ca, -1060, -300),\n+    (0xff77b1fcbebcdc4f, -1034, -292),\n+    (0xbe5691ef416bd60c, -1007, -284),\n+    (0x8dd01fad907ffc3c,  -980, -276),\n+    (0xd3515c2831559a83,  -954, -268),\n+    (0x9d71ac8fada6c9b5,  -927, -260),\n+    (0xea9c227723ee8bcb,  -901, -252),\n+    (0xaecc49914078536d,  -874, -244),\n+    (0x823c12795db6ce57,  -847, -236),\n+    (0xc21094364dfb5637,  -821, -228),\n+    (0x9096ea6f3848984f,  -794, -220),\n+    (0xd77485cb25823ac7,  -768, -212),\n+    (0xa086cfcd97bf97f4,  -741, -204),\n+    (0xef340a98172aace5,  -715, -196),\n+    (0xb23867fb2a35b28e,  -688, -188),\n+    (0x84c8d4dfd2c63f3b,  -661, -180),\n+    (0xc5dd44271ad3cdba,  -635, -172),\n+    (0x936b9fcebb25c996,  -608, -164),\n+    (0xdbac6c247d62a584,  -582, -156),\n+    (0xa3ab66580d5fdaf6,  -555, -148),\n+    (0xf3e2f893dec3f126,  -529, -140),\n+    (0xb5b5ada8aaff80b8,  -502, -132),\n+    (0x87625f056c7c4a8b,  -475, -124),\n+    (0xc9bcff6034c13053,  -449, -116),\n+    (0x964e858c91ba2655,  -422, -108),\n+    (0xdff9772470297ebd,  -396, -100),\n+    (0xa6dfbd9fb8e5b88f,  -369,  -92),\n+    (0xf8a95fcf88747d94,  -343,  -84),\n+    (0xb94470938fa89bcf,  -316,  -76),\n+    (0x8a08f0f8bf0f156b,  -289,  -68),\n+    (0xcdb02555653131b6,  -263,  -60),\n+    (0x993fe2c6d07b7fac,  -236,  -52),\n+    (0xe45c10c42a2b3b06,  -210,  -44),\n+    (0xaa242499697392d3,  -183,  -36),\n+    (0xfd87b5f28300ca0e,  -157,  -28),\n+    (0xbce5086492111aeb,  -130,  -20),\n+    (0x8cbccc096f5088cc,  -103,  -12),\n+    (0xd1b71758e219652c,   -77,   -4),\n+    (0x9c40000000000000,   -50,    4),\n+    (0xe8d4a51000000000,   -24,   12),\n+    (0xad78ebc5ac620000,     3,   20),\n+    (0x813f3978f8940984,    30,   28),\n+    (0xc097ce7bc90715b3,    56,   36),\n+    (0x8f7e32ce7bea5c70,    83,   44),\n+    (0xd5d238a4abe98068,   109,   52),\n+    (0x9f4f2726179a2245,   136,   60),\n+    (0xed63a231d4c4fb27,   162,   68),\n+    (0xb0de65388cc8ada8,   189,   76),\n+    (0x83c7088e1aab65db,   216,   84),\n+    (0xc45d1df942711d9a,   242,   92),\n+    (0x924d692ca61be758,   269,  100),\n+    (0xda01ee641a708dea,   295,  108),\n+    (0xa26da3999aef774a,   322,  116),\n+    (0xf209787bb47d6b85,   348,  124),\n+    (0xb454e4a179dd1877,   375,  132),\n+    (0x865b86925b9bc5c2,   402,  140),\n+    (0xc83553c5c8965d3d,   428,  148),\n+    (0x952ab45cfa97a0b3,   455,  156),\n+    (0xde469fbd99a05fe3,   481,  164),\n+    (0xa59bc234db398c25,   508,  172),\n+    (0xf6c69a72a3989f5c,   534,  180),\n+    (0xb7dcbf5354e9bece,   561,  188),\n+    (0x88fcf317f22241e2,   588,  196),\n+    (0xcc20ce9bd35c78a5,   614,  204),\n+    (0x98165af37b2153df,   641,  212),\n+    (0xe2a0b5dc971f303a,   667,  220),\n+    (0xa8d9d1535ce3b396,   694,  228),\n+    (0xfb9b7cd9a4a7443c,   720,  236),\n+    (0xbb764c4ca7a44410,   747,  244),\n+    (0x8bab8eefb6409c1a,   774,  252),\n+    (0xd01fef10a657842c,   800,  260),\n+    (0x9b10a4e5e9913129,   827,  268),\n+    (0xe7109bfba19c0c9d,   853,  276),\n+    (0xac2820d9623bf429,   880,  284),\n+    (0x80444b5e7aa7cf85,   907,  292),\n+    (0xbf21e44003acdd2d,   933,  300),\n+    (0x8e679c2f5e44ff8f,   960,  308),\n+    (0xd433179d9c8cb841,   986,  316),\n+    (0x9e19db92b4e31ba9,  1013,  324),\n+    (0xeb96bf6ebadf77d9,  1039,  332),\n+];\n+\n+#[doc(hidden)] pub const CACHED_POW10_FIRST_E: i16 = -1087;\n+#[doc(hidden)] pub const CACHED_POW10_LAST_E: i16 = 1039;\n+\n+#[doc(hidden)]\n+pub fn cached_power(alpha: i16, gamma: i16) -> (i16, Fp) {\n+    let offset = CACHED_POW10_FIRST_E as i32;\n+    let range = (CACHED_POW10.len() as i32) - 1;\n+    let domain = (CACHED_POW10_LAST_E - CACHED_POW10_FIRST_E) as i32;\n+    let idx = ((gamma as i32) - offset) * range / domain;\n+    let (f, e, k) = CACHED_POW10[idx as usize];\n+    debug_assert!(alpha <= e && e <= gamma);\n+    (k, Fp { f: f, e: e })\n+}\n+\n+/// Given `x > 0`, returns `(k, 10^k)` such that `10^k <= x < 10^(k+1)`.\n+#[doc(hidden)]\n+pub fn max_pow10_no_more_than(x: u32) -> (u8, u32) {\n+    debug_assert!(x > 0);\n+\n+    const X9: u32 = 10_0000_0000;\n+    const X8: u32 =  1_0000_0000;\n+    const X7: u32 =    1000_0000;\n+    const X6: u32 =     100_0000;\n+    const X5: u32 =      10_0000;\n+    const X4: u32 =       1_0000;\n+    const X3: u32 =         1000;\n+    const X2: u32 =          100;\n+    const X1: u32 =           10;\n+\n+    if x < X4 {\n+        if x < X2 { if x < X1 {(0,  1)} else {(1, X1)} }\n+        else      { if x < X3 {(2, X2)} else {(3, X3)} }\n+    } else {\n+        if x < X6      { if x < X5 {(4, X4)} else {(5, X5)} }\n+        else if x < X8 { if x < X7 {(6, X6)} else {(7, X7)} }\n+        else           { if x < X9 {(8, X8)} else {(9, X9)} }\n+    }\n+}\n+\n+/// The shortest mode implementation for Grisu.\n+///\n+/// It returns `None` when it would return an inexact representation otherwise.\n+pub fn format_shortest_opt(d: &Decoded,\n+                           buf: &mut [u8]) -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n+    assert!(d.mant > 0);\n+    assert!(d.minus > 0);\n+    assert!(d.plus > 0);\n+    assert!(d.mant.checked_add(d.plus).is_some());\n+    assert!(d.mant.checked_sub(d.minus).is_some());\n+    assert!(buf.len() >= MAX_SIG_DIGITS);\n+    assert!(d.mant + d.plus < (1 << 61)); // we need at least three bits of additional precision\n+\n+    // start with the normalized values with the shared exponent\n+    let plus = Fp { f: d.mant + d.plus, e: d.exp }.normalize();\n+    let minus = Fp { f: d.mant - d.minus, e: d.exp }.normalize_to(plus.e);\n+    let v = Fp { f: d.mant, e: d.exp }.normalize_to(plus.e);\n+\n+    // find any `cached = 10^minusk` such that `ALPHA <= minusk + plus.e + 64 <= GAMMA`.\n+    // since `plus` is normalized, this means `2^(62 + ALPHA) <= plus * cached < 2^(64 + GAMMA)`;\n+    // given our choices of `ALPHA` and `GAMMA`, this puts `plus * cached` into `[4, 2^32)`.\n+    //\n+    // it is obviously desirable to maximize `GAMMA - ALPHA`,\n+    // so that we don't need many cached powers of 10, but there are some considerations:\n+    //\n+    // 1. we want to keep `floor(plus * cached)` within `u32` since it needs a costly division.\n+    //    (this is not really avoidable, remainder is required for accuracy estimation.)\n+    // 2. the remainder of `floor(plus * cached)` repeatedly gets multiplied by 10,\n+    //    and it should not overflow.\n+    //\n+    // the first gives `64 + GAMMA <= 32`, while the second gives `10 * 2^-ALPHA <= 2^64`;\n+    // -60 and -32 is the maximal range with this constraint, and V8 also uses them.\n+    let (minusk, cached) = cached_power(ALPHA - plus.e - 64, GAMMA - plus.e - 64);\n+\n+    // scale fps. this gives the maximal error of 1 ulp (proved from Theorem 5.1).\n+    let plus = plus.mul(&cached);\n+    let minus = minus.mul(&cached);\n+    let v = v.mul(&cached);\n+    debug_assert_eq!(plus.e, minus.e);\n+    debug_assert_eq!(plus.e, v.e);\n+\n+    //         +- actual range of minus\n+    //   | <---|---------------------- unsafe region --------------------------> |\n+    //   |     |                                                                 |\n+    //   |  |<--->|  | <--------------- safe region ---------------> |           |\n+    //   |  |     |  |                                               |           |\n+    //   |1 ulp|1 ulp|                 |1 ulp|1 ulp|                 |1 ulp|1 ulp|\n+    //   |<--->|<--->|                 |<--->|<--->|                 |<--->|<--->|\n+    //   |-----|-----|-------...-------|-----|-----|-------...-------|-----|-----|\n+    //   |   minus   |                 |     v     |                 |   plus    |\n+    // minus1     minus0           v - 1 ulp   v + 1 ulp           plus0       plus1\n+    //\n+    // above `minus`, `v` and `plus` are *quantized* approximations (error < 1 ulp).\n+    // as we don't know the error is positive or negative, we use two approximations spaced equally\n+    // and have the maximal error of 2 ulps.\n+    //\n+    // the \"unsafe region\" is a liberal interval which we initially generate.\n+    // the \"safe region\" is a conservative interval which we only accept.\n+    // we start with the correct repr within the unsafe region, and try to find the closest repr\n+    // to `v` which is also within the safe region. if we can't, we give up.\n+    let plus1 = plus.f + 1;\n+//  let plus0 = plus.f - 1; // only for explanation\n+//  let minus0 = minus.f + 1; // only for explanation\n+    let minus1 = minus.f - 1;\n+    let e = -plus.e as usize; // shared exponent\n+\n+    // divide `plus1` into integral and fractional parts.\n+    // integral parts are guaranteed to fit in u32, since cached power guarantees `plus < 2^32`\n+    // and normalized `plus.f` is always less than `2^64 - 2^4` due to the precision requirement.\n+    let plus1int = (plus1 >> e) as u32;\n+    let plus1frac = plus1 & ((1 << e) - 1);\n+\n+    // calculate the largest `10^max_kappa` no more than `plus1` (thus `plus1 < 10^(max_kappa+1)`).\n+    // this is an upper bound of `kappa` below.\n+    let (max_kappa, max_ten_kappa) = max_pow10_no_more_than(plus1int);\n+\n+    let mut i = 0;\n+    let exp = max_kappa as i16 - minusk + 1;\n+\n+    // Theorem 6.2: if `k` is the greatest integer s.t. `0 <= y mod 10^k <= y - x`,\n+    //              then `V = floor(y / 10^k) * 10^k` is in `[x, y]` and one of the shortest\n+    //              representations (with the minimal number of significant digits) in that range.\n+    //\n+    // find the digit length `kappa` between `(minus1, plus1)` as per Theorem 6.2.\n+    // Theorem 6.2 can be adopted to exclude `x` by requiring `y mod 10^k < y - x` instead.\n+    // (e.g. `x` = 32000, `y` = 32777; `kappa` = 2 since `y mod 10^3 = 777 < y - x = 777`.)\n+    // the algorithm relies on the later verification phase to exclude `y`.\n+    let delta1 = plus1 - minus1;\n+//  let delta1int = (delta1 >> e) as usize; // only for explanation\n+    let delta1frac = delta1 & ((1 << e) - 1);\n+\n+    // render integral parts, while checking for the accuracy at each step.\n+    let mut kappa = max_kappa as i16;\n+    let mut ten_kappa = max_ten_kappa; // 10^kappa\n+    let mut remainder = plus1int; // digits yet to be rendered\n+    loop { // we always have at least one digit to render, as `plus1 >= 10^kappa`\n+        // invariants:\n+        // - `delta1int <= remainder < 10^(kappa+1)`\n+        // - `plus1int = d[0..n-1] * 10^(kappa+1) + remainder`\n+        //   (it follows that `remainder = plus1int % 10^(kappa+1)`)\n+\n+        // divide `remainder` by `10^kappa`. both are scaled by `2^-e`.\n+        let q = remainder / ten_kappa;\n+        let r = remainder % ten_kappa;\n+        debug_assert!(q < 10);\n+        buf[i] = b'0' + q as u8;\n+        i += 1;\n+\n+        let plus1rem = ((r as u64) << e) + plus1frac; // == (plus1 % 10^kappa) * 2^e\n+        if plus1rem < delta1 {\n+            // `plus1 % 10^kappa < delta1 = plus1 - minus1`; we've found the correct `kappa`.\n+            let ten_kappa = (ten_kappa as u64) << e; // scale 10^kappa back to the shared exponent\n+            return round_and_weed(&mut buf[..i], exp, plus1rem, delta1, plus1 - v.f, ten_kappa, 1);\n+        }\n+\n+        // break the loop when we have rendered all integral digits.\n+        // the exact number of digits is `max_kappa + 1` as `plus1 < 10^(max_kappa+1)`.\n+        if i > max_kappa as usize {\n+            debug_assert_eq!(ten_kappa, 1);\n+            debug_assert_eq!(kappa, 0);\n+            break;\n+        }\n+\n+        // restore invariants\n+        kappa -= 1;\n+        ten_kappa /= 10;\n+        remainder = r;\n+    }\n+\n+    // render fractional parts, while checking for the accuracy at each step.\n+    // this time we rely on repeated multiplications, as division will lose the precision.\n+    let mut remainder = plus1frac;\n+    let mut threshold = delta1frac;\n+    let mut ulp = 1;\n+    loop { // the next digit should be significant as we've tested that before breaking out\n+        // invariants, where `m = max_kappa + 1` (# of digits in the integral part):\n+        // - `remainder < 2^e`\n+        // - `plus1frac * 10^(n-m) = d[m..n-1] * 2^e + remainder`\n+\n+        remainder *= 10; // won't overflow, `2^e * 10 < 2^64`\n+        threshold *= 10;\n+        ulp *= 10;\n+\n+        // divide `remainder` by `10^kappa`.\n+        // both are scaled by `2^e / 10^kappa`, so the latter is implicit here.\n+        let q = remainder >> e;\n+        let r = remainder & ((1 << e) - 1);\n+        debug_assert!(q < 10);\n+        buf[i] = b'0' + q as u8;\n+        i += 1;\n+\n+        if r < threshold {\n+            let ten_kappa = 1 << e; // implicit divisor\n+            return round_and_weed(&mut buf[..i], exp, r, threshold,\n+                                  (plus1 - v.f) * ulp, ten_kappa, ulp);\n+        }\n+\n+        // restore invariants\n+        kappa -= 1;\n+        remainder = r;\n+    }\n+\n+    // we've generated all significant digits of `plus1`, but not sure if it's the optimal one.\n+    // for example, if `minus1` is 3.14153... and `plus1` is 3.14158..., there are 5 different\n+    // shortest representation from 3.14154 to 3.14158 but we only have the greatest one.\n+    // we have to successively decrease the last digit and check if this is the optimal repr.\n+    // there are at most 9 candidates (..1 to ..9), so this is fairly quick. (\"rounding\" phase)\n+    //\n+    // the function checks if this \"optimal\" repr is actually within the ulp ranges,\n+    // and also, it is possible that the \"second-to-optimal\" repr can actually be optimal\n+    // due to the rounding error. in either cases this returns `None`. (\"weeding\" phase)\n+    //\n+    // all arguments here are scaled by the common (but implicit) value `k`, so that:\n+    // - `remainder = (plus1 % 10^kappa) * k`\n+    // - `threshold = (plus1 - minus1) * k` (and also, `remainder < threshold`)\n+    // - `plus1v = (plus1 - v) * k` (and also, `threshold > plus1v` from prior invariants)\n+    // - `ten_kappa = 10^kappa * k`\n+    // - `ulp = 2^-e * k`\n+    fn round_and_weed(buf: &mut [u8], exp: i16, remainder: u64, threshold: u64, plus1v: u64,\n+                      ten_kappa: u64, ulp: u64) -> Option<(usize, i16)> {\n+        assert!(!buf.is_empty());\n+\n+        // produce two approximations to `v` (actually `plus1 - v`) within 1.5 ulps.\n+        // the resulting representation should be the closest representation to both.\n+        //\n+        // here `plus1 - v` is used since calculations are done with respect to `plus1`\n+        // in order to avoid overflow/underflow (hence the seemingly swapped names).\n+        let plus1v_down = plus1v + ulp; // plus1 - (v - 1 ulp)\n+        let plus1v_up = plus1v - ulp; // plus1 - (v + 1 ulp)\n+\n+        // decrease the last digit and stop at the closest representation to `v + 1 ulp`.\n+        let mut plus1w = remainder; // plus1w(n) = plus1 - w(n)\n+        {\n+            let last = buf.last_mut().unwrap();\n+\n+            // we work with the approximated digits `w(n)`, which is initially equal to `plus1 -\n+            // plus1 % 10^kappa`. after running the loop body `n` times, `w(n) = plus1 -\n+            // plus1 % 10^kappa - n * 10^kappa`. we set `plus1w(n) = plus1 - w(n) =\n+            // plus1 % 10^kappa + n * 10^kappa` (thus `remainder = plus1w(0)`) to simplify checks.\n+            // note that `plus1w(n)` is always increasing.\n+            //\n+            // we have three conditions to terminate. any of them will make the loop unable to\n+            // proceed, but we then have at least one valid representation known to be closest to\n+            // `v + 1 ulp` anyway. we will denote them as TC1 through TC3 for brevity.\n+            //\n+            // TC1: `w(n) <= v + 1 ulp`, i.e. this is the last repr that can be the closest one.\n+            // this is equivalent to `plus1 - w(n) = plus1w(n) >= plus1 - (v + 1 ulp) = plus1v_up`.\n+            // combined with TC2 (which checks if `w(n+1)` is valid), this prevents the possible\n+            // overflow on the calculation of `plus1w(n)`.\n+            //\n+            // TC2: `w(n+1) < minus1`, i.e. the next repr definitely does not round to `v`.\n+            // this is equivalent to `plus1 - w(n) + 10^kappa = plus1w(n) + 10^kappa >\n+            // plus1 - minus1 = threshold`. the left hand side can overflow, but we know\n+            // `threshold > plus1v`, so if TC1 is false, `threshold - plus1w(n) >\n+            // threshold - (plus1v - 1 ulp) > 1 ulp` and we can safely test if\n+            // `threshold - plus1w(n) < 10^kappa` instead.\n+            //\n+            // TC3: `abs(w(n) - (v + 1 ulp)) <= abs(w(n+1) - (v + 1 ulp))`, i.e. the next repr is\n+            // no closer to `v + 1 ulp` than the current repr. given `z(n) = plus1v_up - plus1w(n)`,\n+            // this becomes `abs(z(n)) <= abs(z(n+1))`. again assuming that TC1 is false, we have\n+            // `z(n) > 0`. we have two cases to consider:\n+            //\n+            // - when `z(n+1) >= 0`: TC3 becomes `z(n) <= z(n+1)`. as `plus1w(n)` is increasing,\n+            //   `z(n)` should be decreasing and this is clearly false.\n+            // - when `z(n+1) < 0`:\n+            //   - TC3a: the precondition is `plus1v_up < plus1w(n) + 10^kappa`. assuming TC2 is\n+            //     false, `threshold >= plus1w(n) + 10^kappa` so it cannot overflow.\n+            //   - TC3b: TC3 becomes `z(n) <= -z(n+1)`, i.e. `plus1v_up - plus1w(n) >=\n+            //     plus1w(n+1) - plus1v_up = plus1w(n) + 10^kappa - plus1v_up`. the negated TC1\n+            //     gives `plus1v_up > plus1w(n)`, so it cannot overflow or underflow when\n+            //     combined with TC3a.\n+            //\n+            // consequently, we should stop when `TC1 || TC2 || (TC3a && TC3b)`. the following is\n+            // equal to its inverse, `!TC1 && !TC2 && (!TC3a || !TC3b)`.\n+            while plus1w < plus1v_up &&\n+                  threshold - plus1w >= ten_kappa &&\n+                  (plus1w + ten_kappa < plus1v_up ||\n+                   plus1v_up - plus1w >= plus1w + ten_kappa - plus1v_up) {\n+                *last -= 1;\n+                debug_assert!(*last > b'0'); // the shortest repr cannot end with `0`\n+                plus1w += ten_kappa;\n+            }\n+        }\n+\n+        // check if this representation is also the closest representation to `v - 1 ulp`.\n+        //\n+        // this is simply same to the terminating conditions for `v + 1 ulp`, with all `plus1v_up`\n+        // replaced by `plus1v_down` instead. overflow analysis equally holds.\n+        if plus1w < plus1v_down &&\n+           threshold - plus1w >= ten_kappa &&\n+           (plus1w + ten_kappa < plus1v_down ||\n+            plus1v_down - plus1w >= plus1w + ten_kappa - plus1v_down) {\n+            return None;\n+        }\n+\n+        // now we have the closest representation to `v` between `plus1` and `minus1`.\n+        // this is too liberal, though, so we reject any `w(n)` not between `plus0` and `minus0`,\n+        // i.e. `plus1 - plus1w(n) <= minus0` or `plus1 - plus1w(n) >= plus0`. we utilize the facts\n+        // that `threshold = plus1 - minus1` and `plus1 - plus0 = minus0 - minus1 = 2 ulp`.\n+        if 2 * ulp <= plus1w && plus1w <= threshold - 4 * ulp {\n+            Some((buf.len(), exp))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// The shortest mode implementation for Grisu with Dragon fallback.\n+///\n+/// This should be used for most cases.\n+pub fn format_shortest(d: &Decoded, buf: &mut [u8]) -> (/*#digits*/ usize, /*exp*/ i16) {\n+    use num::flt2dec::strategy::dragon::format_shortest as fallback;\n+    match format_shortest_opt(d, buf) {\n+        Some(ret) => ret,\n+        None => fallback(d, buf),\n+    }\n+}\n+\n+/// The exact and fixed mode implementation for Grisu.\n+///\n+/// It returns `None` when it would return an inexact representation otherwise.\n+pub fn format_exact_opt(d: &Decoded, buf: &mut [u8], limit: i16)\n+                                -> Option<(/*#digits*/ usize, /*exp*/ i16)> {\n+    assert!(d.mant > 0);\n+    assert!(d.mant < (1 << 61)); // we need at least three bits of additional precision\n+    assert!(!buf.is_empty());\n+\n+    // normalize and scale `v`.\n+    let v = Fp { f: d.mant, e: d.exp }.normalize();\n+    let (minusk, cached) = cached_power(ALPHA - v.e - 64, GAMMA - v.e - 64);\n+    let v = v.mul(&cached);\n+\n+    // divide `v` into integral and fractional parts.\n+    let e = -v.e as usize;\n+    let vint = (v.f >> e) as u32;\n+    let vfrac = v.f & ((1 << e) - 1);\n+\n+    // both old `v` and new `v` (scaled by `10^-k`) has an error of < 1 ulp (Theorem 5.1).\n+    // as we don't know the error is positive or negative, we use two approximations\n+    // spaced equally and have the maximal error of 2 ulps (same to the shortest case).\n+    //\n+    // the goal is to find the exactly rounded series of digits that are common to\n+    // both `v - 1 ulp` and `v + 1 ulp`, so that we are maximally confident.\n+    // if this is not possible, we don't know which one is the correct output for `v`,\n+    // so we give up and fall back.\n+    //\n+    // `err` is defined as `1 ulp * 2^e` here (same to the ulp in `vfrac`),\n+    // and we will scale it whenever `v` gets scaled.\n+    let mut err = 1;\n+\n+    // calculate the largest `10^max_kappa` no more than `v` (thus `v < 10^(max_kappa+1)`).\n+    // this is an upper bound of `kappa` below.\n+    let (max_kappa, max_ten_kappa) = max_pow10_no_more_than(vint);\n+\n+    let mut i = 0;\n+    let exp = max_kappa as i16 - minusk + 1;\n+\n+    // if we are working with the last-digit limitation, we need to shorten the buffer\n+    // before the actual rendering in order to avoid double rounding.\n+    // note that we have to enlarge the buffer again when rounding up happens!\n+    let len = if exp <= limit {\n+        // oops, we cannot even produce *one* digit.\n+        // this is possible when, say, we've got something like 9.5 and it's being rounded to 10.\n+        //\n+        // in principle we can immediately call `possibly_round` with an empty buffer,\n+        // but scaling `max_ten_kappa << e` by 10 can result in overflow.\n+        // thus we are being sloppy here and widen the error range by a factor of 10.\n+        // this will increase the false negative rate, but only very, *very* slightly;\n+        // it can only matter noticably when the mantissa is bigger than 60 bits.\n+        return possibly_round(buf, 0, exp, limit, v.f / 10, (max_ten_kappa as u64) << e, err << e);\n+    } else if ((exp as i32 - limit as i32) as usize) < buf.len() {\n+        (exp - limit) as usize\n+    } else {\n+        buf.len()\n+    };\n+    debug_assert!(len > 0);\n+\n+    // render integral parts.\n+    // the error is entirely fractional, so we don't need to check it in this part.\n+    let mut kappa = max_kappa as i16;\n+    let mut ten_kappa = max_ten_kappa; // 10^kappa\n+    let mut remainder = vint; // digits yet to be rendered\n+    loop { // we always have at least one digit to render\n+        // invariants:\n+        // - `remainder < 10^(kappa+1)`\n+        // - `vint = d[0..n-1] * 10^(kappa+1) + remainder`\n+        //   (it follows that `remainder = vint % 10^(kappa+1)`)\n+\n+        // divide `remainder` by `10^kappa`. both are scaled by `2^-e`.\n+        let q = remainder / ten_kappa;\n+        let r = remainder % ten_kappa;\n+        debug_assert!(q < 10);\n+        buf[i] = b'0' + q as u8;\n+        i += 1;\n+\n+        // is the buffer full? run the rounding pass with the remainder.\n+        if i == len {\n+            let vrem = ((r as u64) << e) + vfrac; // == (v % 10^kappa) * 2^e\n+            return possibly_round(buf, len, exp, limit, vrem, (ten_kappa as u64) << e, err << e);\n+        }\n+\n+        // break the loop when we have rendered all integral digits.\n+        // the exact number of digits is `max_kappa + 1` as `plus1 < 10^(max_kappa+1)`.\n+        if i > max_kappa as usize {\n+            debug_assert_eq!(ten_kappa, 1);\n+            debug_assert_eq!(kappa, 0);\n+            break;\n+        }\n+\n+        // restore invariants\n+        kappa -= 1;\n+        ten_kappa /= 10;\n+        remainder = r;\n+    }\n+\n+    // render fractional parts.\n+    //\n+    // in principle we can continue to the last available digit and check for the accuracy.\n+    // unfortunately we are working with the finite-sized integers, so we need some criterion\n+    // to detect the overflow. V8 uses `remainder > err`, which becomes false when\n+    // the first `i` significant digits of `v - 1 ulp` and `v` differ. however this rejects\n+    // too many otherwise valid input.\n+    //\n+    // since the later phase has a correct overflow detection, we instead use tighter criterion:\n+    // we continue til `err` exceeds `10^kappa / 2`, so that the range between `v - 1 ulp` and\n+    // `v + 1 ulp` definitely contains two or more rounded representations. this is same to\n+    // the first two comparisons from `possibly_round`, for the reference.\n+    let mut remainder = vfrac;\n+    let maxerr = 1 << (e - 1);\n+    while err < maxerr {\n+        // invariants, where `m = max_kappa + 1` (# of digits in the integral part):\n+        // - `remainder < 2^e`\n+        // - `vfrac * 10^(n-m) = d[m..n-1] * 2^e + remainder`\n+        // - `err = 10^(n-m)`\n+\n+        remainder *= 10; // won't overflow, `2^e * 10 < 2^64`\n+        err *= 10; // won't overflow, `err * 10 < 2^e * 5 < 2^64`\n+\n+        // divide `remainder` by `10^kappa`.\n+        // both are scaled by `2^e / 10^kappa`, so the latter is implicit here.\n+        let q = remainder >> e;\n+        let r = remainder & ((1 << e) - 1);\n+        debug_assert!(q < 10);\n+        buf[i] = b'0' + q as u8;\n+        i += 1;\n+\n+        // is the buffer full? run the rounding pass with the remainder.\n+        if i == len {\n+            return possibly_round(buf, len, exp, limit, r, 1 << e, err);\n+        }\n+\n+        // restore invariants\n+        remainder = r;\n+    }\n+\n+    // further calculation is useless (`possibly_round` definitely fails), so we give up.\n+    return None;\n+\n+    // we've generated all requested digits of `v`, which should be also same to corresponding\n+    // digits of `v - 1 ulp`. now we check if there is a unique representation shared by\n+    // both `v - 1 ulp` and `v + 1 ulp`; this can be either same to generated digits, or\n+    // to the rounded-up version of those digits. if the range contains multiple representations\n+    // of the same length, we cannot be sure and should return `None` instead.\n+    //\n+    // all arguments here are scaled by the common (but implicit) value `k`, so that:\n+    // - `remainder = (v % 10^kappa) * k`\n+    // - `ten_kappa = 10^kappa * k`\n+    // - `ulp = 2^-e * k`\n+    fn possibly_round(buf: &mut [u8], mut len: usize, mut exp: i16, limit: i16,\n+                      remainder: u64, ten_kappa: u64, ulp: u64) -> Option<(usize, i16)> {\n+        debug_assert!(remainder < ten_kappa);\n+\n+        //           10^kappa\n+        //    :   :   :<->:   :\n+        //    :   :   :   :   :\n+        //    :|1 ulp|1 ulp|  :\n+        //    :|<--->|<--->|  :\n+        // ----|-----|-----|----\n+        //     |     v     |\n+        // v - 1 ulp   v + 1 ulp\n+        //\n+        // (for the reference, the dotted line indicates the exact value for\n+        // possible representations in given number of digits.)\n+        //\n+        // error is too large that there are at least three possible representations\n+        // between `v - 1 ulp` and `v + 1 ulp`. we cannot determine which one is correct.\n+        if ulp >= ten_kappa { return None; }\n+\n+        //    10^kappa\n+        //   :<------->:\n+        //   :         :\n+        //   : |1 ulp|1 ulp|\n+        //   : |<--->|<--->|\n+        // ----|-----|-----|----\n+        //     |     v     |\n+        // v - 1 ulp   v + 1 ulp\n+        //\n+        // in fact, 1/2 ulp is enough to introduce two possible representations.\n+        // (remember that we need a unique representation for both `v - 1 ulp` and `v + 1 ulp`.)\n+        // this won't overflow, as `ulp < ten_kappa` from the first check.\n+        if ten_kappa - ulp <= ulp { return None; }\n+\n+        //     remainder\n+        //       :<->|                           :\n+        //       :   |                           :\n+        //       :<--------- 10^kappa ---------->:\n+        //     | :   |                           :\n+        //     |1 ulp|1 ulp|                     :\n+        //     |<--->|<--->|                     :\n+        // ----|-----|-----|------------------------\n+        //     |     v     |\n+        // v - 1 ulp   v + 1 ulp\n+        //\n+        // if `v + 1 ulp` is closer to the rounded-down representation (which is already in `buf`),\n+        // then we can safely return. note that `v - 1 ulp` *can* be less than the current\n+        // representation, but as `1 ulp < 10^kappa / 2`, this condition is enough:\n+        // the distance between `v - 1 ulp` and the current representation\n+        // cannot exceed `10^kappa / 2`.\n+        //\n+        // the condition equals to `remainder + ulp < 10^kappa / 2`.\n+        // since this can easily overflow, first check if `remainder < 10^kappa / 2`.\n+        // we've already verified that `ulp < 10^kappa / 2`, so as long as\n+        // `10^kappa` did not overflow after all, the second check is fine.\n+        if ten_kappa - remainder > remainder && ten_kappa - 2 * remainder >= 2 * ulp {\n+            return Some((len, exp));\n+        }\n+\n+        //   :<------- remainder ------>|   :\n+        //   :                          |   :\n+        //   :<--------- 10^kappa --------->:\n+        //   :                    |     |   : |\n+        //   :                    |1 ulp|1 ulp|\n+        //   :                    |<--->|<--->|\n+        // -----------------------|-----|-----|-----\n+        //                        |     v     |\n+        //                    v - 1 ulp   v + 1 ulp\n+        //\n+        // on the other hands, if `v - 1 ulp` is closer to the rounded-up representation,\n+        // we should round up and return. for the same reason we don't need to check `v + 1 ulp`.\n+        //\n+        // the condition equals to `remainder - ulp >= 10^kappa / 2`.\n+        // again we first check if `remainder > ulp` (note that this is not `remainder >= ulp`,\n+        // as `10^kappa` is never zero). also note that `remainder - ulp <= 10^kappa`,\n+        // so the second check does not overflow.\n+        if remainder > ulp && ten_kappa - (remainder - ulp) <= remainder - ulp {\n+            if let Some(c) = round_up(buf, len) {\n+                // only add an additional digit when we've been requested the fixed precision.\n+                // we also need to check that, if the original buffer was empty,\n+                // the additional digit can only be added when `exp == limit` (edge case).\n+                exp += 1;\n+                if exp > limit && len < buf.len() {\n+                    buf[len] = c;\n+                    len += 1;\n+                }\n+            }\n+            return Some((len, exp));\n+        }\n+\n+        // otherwise we are doomed (i.e. some values between `v - 1 ulp` and `v + 1 ulp` are\n+        // rounding down and others are rounding up) and give up.\n+        None\n+    }\n+}\n+\n+/// The exact and fixed mode implementation for Grisu with Dragon fallback.\n+///\n+/// This should be used for most cases.\n+pub fn format_exact(d: &Decoded, buf: &mut [u8], limit: i16) -> (/*#digits*/ usize, /*exp*/ i16) {\n+    use num::flt2dec::strategy::dragon::format_exact as fallback;\n+    match format_exact_opt(d, buf, limit) {\n+        Some(ret) => ret,\n+        None => fallback(d, buf, limit),\n+    }\n+}\n+"}, {"sha": "011830ddb7882d65da98c0c14b481cf6700e32ac", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -44,6 +44,9 @@ pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n #[unstable(feature = \"core\", reason = \"may be removed or relocated\")]\n pub mod wrapping;\n \n+#[unstable(feature = \"core\", reason = \"internal routines only exposed for testing\")]\n+pub mod flt2dec;\n+\n /// Types that have a \"zero\" value.\n ///\n /// This trait is intended for use in conjunction with `Add`, as an identity:\n@@ -113,12 +116,14 @@ macro_rules! int_impl {\n      $mul_with_overflow:path) => {\n         /// Returns the smallest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n         pub fn min_value() -> $T {\n             (-1 as $T) << ($BITS - 1)\n         }\n \n         /// Returns the largest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n         pub fn max_value() -> $T {\n             let min = $T::min_value(); !min\n         }\n@@ -1522,7 +1527,11 @@ impl fmt::Display for ParseIntError {\n \n /// An error which can be returned when parsing a float.\n #[derive(Debug, Clone, PartialEq)]\n-pub struct ParseFloatError { pub kind: FloatErrorKind }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct ParseFloatError {\n+    #[doc(hidden)]\n+    pub __kind: FloatErrorKind\n+}\n \n #[derive(Debug, Clone, PartialEq)]\n pub enum FloatErrorKind {\n@@ -1531,9 +1540,9 @@ pub enum FloatErrorKind {\n }\n \n impl ParseFloatError {\n-    #[unstable(feature = \"core\", reason = \"available through Error trait\")]\n-    pub fn description(&self) -> &str {\n-        match self.kind {\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        match self.__kind {\n             FloatErrorKind::Empty => \"cannot parse float from empty string\",\n             FloatErrorKind::Invalid => \"invalid float literal\",\n         }\n@@ -1543,6 +1552,6 @@ impl ParseFloatError {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for ParseFloatError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.description().fmt(f)\n+        self.__description().fmt(f)\n     }\n }"}, {"sha": "69c2222949032212c33ad9a506debed9a5161d76", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -123,6 +123,7 @@ macro_rules! wrapping_impl {\n         impl Not for Wrapping<$t> {\n             type Output = Wrapping<$t>;\n \n+            #[inline(always)]\n             fn not(self) -> Wrapping<$t> {\n                 Wrapping(!self.0)\n             }"}, {"sha": "55c4264b10c7063cd343c9bed2b37daf73cf2abb", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -91,7 +91,7 @@ use fmt;\n ///     let _x = HasDrop;\n /// }\n /// ```\n-#[lang=\"drop\"]\n+#[lang = \"drop\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Drop {\n     /// The `drop` method, called when the value goes out of scope.\n@@ -181,7 +181,7 @@ macro_rules! forward_ref_binop {\n ///     Foo + Foo;\n /// }\n /// ```\n-#[lang=\"add\"]\n+#[lang = \"add\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Add<RHS=Self> {\n     /// The resulting type after applying the `+` operator\n@@ -235,7 +235,7 @@ add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n ///     Foo - Foo;\n /// }\n /// ```\n-#[lang=\"sub\"]\n+#[lang = \"sub\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Sub<RHS=Self> {\n     /// The resulting type after applying the `-` operator\n@@ -289,7 +289,7 @@ sub_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n ///     Foo * Foo;\n /// }\n /// ```\n-#[lang=\"mul\"]\n+#[lang = \"mul\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Mul<RHS=Self> {\n     /// The resulting type after applying the `*` operator\n@@ -343,7 +343,7 @@ mul_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n ///     Foo / Foo;\n /// }\n /// ```\n-#[lang=\"div\"]\n+#[lang = \"div\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Div<RHS=Self> {\n     /// The resulting type after applying the `/` operator\n@@ -397,7 +397,7 @@ div_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n ///     Foo % Foo;\n /// }\n /// ```\n-#[lang=\"rem\"]\n+#[lang = \"rem\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Rem<RHS=Self> {\n     /// The resulting type after applying the `%` operator\n@@ -470,7 +470,7 @@ rem_float_impl! { f64, fmod }\n ///     -Foo;\n /// }\n /// ```\n-#[lang=\"neg\"]\n+#[lang = \"neg\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Neg {\n     /// The resulting type after applying the `-` operator\n@@ -541,7 +541,7 @@ neg_impl_numeric! { isize i8 i16 i32 i64 f32 f64 }\n ///     !Foo;\n /// }\n /// ```\n-#[lang=\"not\"]\n+#[lang = \"not\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Not {\n     /// The resulting type after applying the `!` operator\n@@ -595,7 +595,7 @@ not_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n ///     Foo & Foo;\n /// }\n /// ```\n-#[lang=\"bitand\"]\n+#[lang = \"bitand\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitAnd<RHS=Self> {\n     /// The resulting type after applying the `&` operator\n@@ -649,7 +649,7 @@ bitand_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n ///     Foo | Foo;\n /// }\n /// ```\n-#[lang=\"bitor\"]\n+#[lang = \"bitor\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitOr<RHS=Self> {\n     /// The resulting type after applying the `|` operator\n@@ -703,7 +703,7 @@ bitor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n ///     Foo ^ Foo;\n /// }\n /// ```\n-#[lang=\"bitxor\"]\n+#[lang = \"bitxor\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BitXor<RHS=Self> {\n     /// The resulting type after applying the `^` operator\n@@ -757,7 +757,7 @@ bitxor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n ///     Foo << Foo;\n /// }\n /// ```\n-#[lang=\"shl\"]\n+#[lang = \"shl\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Shl<RHS> {\n     /// The resulting type after applying the `<<` operator\n@@ -829,7 +829,7 @@ shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n ///     Foo >> Foo;\n /// }\n /// ```\n-#[lang=\"shr\"]\n+#[lang = \"shr\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Shr<RHS> {\n     /// The resulting type after applying the `>>` operator\n@@ -902,7 +902,7 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n ///     Foo[Bar];\n /// }\n /// ```\n-#[lang=\"index\"]\n+#[lang = \"index\"]\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Index<Idx: ?Sized> {\n@@ -949,7 +949,7 @@ pub trait Index<Idx: ?Sized> {\n ///     &mut Foo[Bar];\n /// }\n /// ```\n-#[lang=\"index_mut\"]\n+#[lang = \"index_mut\"]\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n@@ -960,7 +960,7 @@ pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n \n /// An unbounded range.\n #[derive(Copy, Clone, PartialEq, Eq)]\n-#[lang=\"range_full\"]\n+#[lang = \"range_full\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFull;\n \n@@ -973,7 +973,7 @@ impl fmt::Debug for RangeFull {\n \n /// A (half-open) range which is bounded at both ends.\n #[derive(Clone, PartialEq, Eq)]\n-#[lang=\"range\"]\n+#[lang = \"range\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -993,7 +993,7 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n \n /// A range which is only bounded below.\n #[derive(Clone, PartialEq, Eq)]\n-#[lang=\"range_from\"]\n+#[lang = \"range_from\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n@@ -1010,7 +1010,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n \n /// A range which is only bounded above.\n #[derive(Copy, Clone, PartialEq, Eq)]\n-#[lang=\"range_to\"]\n+#[lang = \"range_to\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n@@ -1053,7 +1053,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n ///     assert_eq!('a', *x);\n /// }\n /// ```\n-#[lang=\"deref\"]\n+#[lang = \"deref\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Deref {\n     /// The resulting type after dereferencing\n@@ -1114,7 +1114,7 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n ///     assert_eq!('b', *x);\n /// }\n /// ```\n-#[lang=\"deref_mut\"]\n+#[lang = \"deref_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DerefMut: Deref {\n     /// The method called to mutably dereference a value\n@@ -1128,7 +1128,7 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n }\n \n /// A version of the call operator that takes an immutable receiver.\n-#[lang=\"fn\"]\n+#[lang = \"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n@@ -1138,7 +1138,7 @@ pub trait Fn<Args> : FnMut<Args> {\n }\n \n /// A version of the call operator that takes a mutable receiver.\n-#[lang=\"fn_mut\"]\n+#[lang = \"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n@@ -1148,7 +1148,7 @@ pub trait FnMut<Args> : FnOnce<Args> {\n }\n \n /// A version of the call operator that takes a by-value receiver.\n-#[lang=\"fn_once\"]\n+#[lang = \"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n #[fundamental] // so that regex can rely that `&str: !FnMut`"}, {"sha": "8da28094be3aed3c007bd1469f45949cd80a05c7", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -161,7 +161,7 @@ use slice;\n // `Iterator` is an enumeration with one type parameter and two variants,\n // which basically means it must be `Option`.\n \n-/// The `Option` type. See [the module level documentation](../index.html) for more.\n+/// The `Option` type. See [the module level documentation](index.html) for more.\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {"}, {"sha": "635150c088688f3c98b5a17aea9c1f6694787e92", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -33,7 +33,7 @@\n use fmt;\n \n #[cold] #[inline(never)] // this is the slow path, always\n-#[lang=\"panic\"]\n+#[lang = \"panic\"]\n pub fn panic(expr_file_line: &(&'static str, &'static str, u32)) -> ! {\n     // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n     // reduce size overhead. The format_args! macro uses str's Display trait to\n@@ -46,7 +46,7 @@ pub fn panic(expr_file_line: &(&'static str, &'static str, u32)) -> ! {\n }\n \n #[cold] #[inline(never)]\n-#[lang=\"panic_bounds_check\"]\n+#[lang = \"panic_bounds_check\"]\n fn panic_bounds_check(file_line: &(&'static str, u32),\n                      index: usize, len: usize) -> ! {\n     panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\","}, {"sha": "56dee3034870c426b735a18435c40555b995bed1", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 24, "deletions": 116, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -631,8 +631,14 @@ fn size_from_ptr<T>(_: *const T) -> usize {\n }\n \n \n-// Use macro to be generic over const/mut\n-macro_rules! slice_offset {\n+// Use macros to be generic over const/mut\n+//\n+// They require non-negative `$by` because otherwise the expression\n+// `(ptr as usize + $by)` would interpret `-1` as `usize::MAX` (and\n+// thus trigger a panic when overflow checks are on).\n+\n+// Use this to do `$ptr + $by`, where `$by` is non-negative.\n+macro_rules! slice_add_offset {\n     ($ptr:expr, $by:expr) => {{\n         let ptr = $ptr;\n         if size_from_ptr(ptr) == 0 {\n@@ -643,6 +649,18 @@ macro_rules! slice_offset {\n     }};\n }\n \n+// Use this to do `$ptr - $by`, where `$by` is non-negative.\n+macro_rules! slice_sub_offset {\n+    ($ptr:expr, $by:expr) => {{\n+        let ptr = $ptr;\n+        if size_from_ptr(ptr) == 0 {\n+            transmute(ptr as usize - $by)\n+        } else {\n+            ptr.offset(-$by)\n+        }\n+    }};\n+}\n+\n macro_rules! slice_ref {\n     ($ptr:expr) => {{\n         let ptr = $ptr;\n@@ -672,7 +690,7 @@ macro_rules! iterator {\n                         None\n                     } else {\n                         let old = self.ptr;\n-                        self.ptr = slice_offset!(self.ptr, 1);\n+                        self.ptr = slice_add_offset!(self.ptr, 1);\n                         Some(slice_ref!(old))\n                     }\n                 }\n@@ -714,7 +732,7 @@ macro_rules! iterator {\n                     if self.end == self.ptr {\n                         None\n                     } else {\n-                        self.end = slice_offset!(self.end, -1);\n+                        self.end = slice_sub_offset!(self.end, 1);\n                         Some(slice_ref!(self.end))\n                     }\n                 }\n@@ -762,46 +780,6 @@ pub struct Iter<'a, T: 'a> {\n unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}\n unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}\n \n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::Range<usize>> for Iter<'a, T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, index: ops::Range<usize>) -> &[T] {\n-        self.as_slice().index(index)\n-    }\n-}\n-\n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::RangeTo<usize>> for Iter<'a, T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n-        self.as_slice().index(index)\n-    }\n-}\n-\n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::RangeFrom<usize>> for Iter<'a, T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n-        self.as_slice().index(index)\n-    }\n-}\n-\n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<RangeFull> for Iter<'a, T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, _index: RangeFull) -> &[T] {\n-        self.as_slice()\n-    }\n-}\n-\n impl<'a, T> Iter<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///\n@@ -816,7 +794,7 @@ impl<'a, T> Iter<'a, T> {\n     fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n         match self.as_slice().get(n) {\n             Some(elem_ref) => unsafe {\n-                self.ptr = slice_offset!(elem_ref as *const _, 1);\n+                self.ptr = slice_add_offset!(elem_ref as *const _, 1);\n                 Some(slice_ref!(elem_ref))\n             },\n             None => {\n@@ -873,76 +851,6 @@ pub struct IterMut<'a, T: 'a> {\n unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}\n unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}\n \n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::Range<usize>> for IterMut<'a, T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, index: ops::Range<usize>) -> &[T] {\n-        self.index(RangeFull).index(index)\n-    }\n-}\n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::RangeTo<usize>> for IterMut<'a, T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n-        self.index(RangeFull).index(index)\n-    }\n-}\n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::RangeFrom<usize>> for IterMut<'a, T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n-        self.index(RangeFull).index(index)\n-    }\n-}\n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<RangeFull> for IterMut<'a, T> {\n-    type Output = [T];\n-\n-    #[inline]\n-    fn index(&self, _index: RangeFull) -> &[T] {\n-        make_slice!(T => &[T]: self.ptr, self.end)\n-    }\n-}\n-\n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::IndexMut<ops::Range<usize>> for IterMut<'a, T> {\n-    #[inline]\n-    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n-        self.index_mut(RangeFull).index_mut(index)\n-    }\n-}\n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::IndexMut<ops::RangeTo<usize>> for IterMut<'a, T> {\n-\n-    #[inline]\n-    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n-        self.index_mut(RangeFull).index_mut(index)\n-    }\n-}\n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::IndexMut<ops::RangeFrom<usize>> for IterMut<'a, T> {\n-\n-    #[inline]\n-    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n-        self.index_mut(RangeFull).index_mut(index)\n-    }\n-}\n-#[unstable(feature = \"core\")]\n-impl<'a, T> ops::IndexMut<RangeFull> for IterMut<'a, T> {\n-\n-    #[inline]\n-    fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n-        make_mut_slice!(T => &mut [T]: self.ptr, self.end)\n-    }\n-}\n-\n-\n impl<'a, T> IterMut<'a, T> {\n     /// View the underlying data as a subslice of the original data.\n     ///\n@@ -959,7 +867,7 @@ impl<'a, T> IterMut<'a, T> {\n     fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n         match make_mut_slice!(T => &'a mut [T]: self.ptr, self.end).get_mut(n) {\n             Some(elem_ref) => unsafe {\n-                self.ptr = slice_offset!(elem_ref as *mut _, 1);\n+                self.ptr = slice_add_offset!(elem_ref as *mut _, 1);\n                 Some(slice_ref!(elem_ref))\n             },\n             None => {"}, {"sha": "4d39607b16e92a140e3000b942f2a9c18c45f74a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -21,6 +21,7 @@ use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use char::CharExt;\n use clone::Clone;\n use cmp::{self, Eq};\n+use convert::AsRef;\n use default::Default;\n use fmt;\n use iter::ExactSizeIterator;\n@@ -136,6 +137,7 @@ pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n \n /// Converts a slice of bytes to a string slice without checking\n /// that the string contains valid UTF-8.\n+#[inline(always)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n     mem::transmute(v)\n@@ -420,7 +422,7 @@ macro_rules! derive_pattern_clone {\n /// wrapping an private internal one that makes use of the `Pattern` API.\n ///\n /// For all patterns `P: Pattern<'a>` the following items will be\n-/// generated (generics ommitted):\n+/// generated (generics omitted):\n ///\n /// struct $forward_iterator($internal_iterator);\n /// struct $reverse_iterator($internal_iterator);\n@@ -1183,7 +1185,7 @@ fn eq_slice_(a: &str, b: &str) -> bool {\n /// Bytewise slice equality\n /// NOTE: This function is (ab)used in rustc::middle::trans::_match\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n-#[lang=\"str_eq\"]\n+#[lang = \"str_eq\"]\n #[inline]\n fn eq_slice(a: &str, b: &str) -> bool {\n     eq_slice_(a, b)\n@@ -1841,6 +1843,14 @@ impl StrExt for str {\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err> { FromStr::from_str(self) }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRef<[u8]> for str {\n+    #[inline]\n+    fn as_ref(&self) -> &[u8] {\n+        self.as_bytes()\n+    }\n+}\n+\n /// Pluck a code point out of a UTF-8-like byte slice and return the\n /// index of the next code point.\n #[inline]"}, {"sha": "0bd0b66318f1b12ecc17e6d532a1246d786fe9bb", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -159,3 +159,27 @@ fn refcell_default() {\n     let cell: RefCell<u64> = Default::default();\n     assert_eq!(0, *cell.borrow());\n }\n+\n+#[test]\n+fn unsafe_cell_unsized() {\n+    let cell: &UnsafeCell<[i32]> = &UnsafeCell::new([1, 2, 3]);\n+    {\n+        let val: &mut [i32] = unsafe { &mut *cell.get() };\n+        val[0] = 4;\n+        val[2] = 5;\n+    }\n+    let comp: &mut [i32] = &mut [4, 2, 5];\n+    assert_eq!(unsafe { &mut *cell.get() }, comp);\n+}\n+\n+#[test]\n+fn refcell_unsized() {\n+    let cell: &RefCell<[i32]> = &RefCell::new([1, 2, 3]);\n+    {\n+        let b = &mut *cell.borrow_mut();\n+        b[0] = 4;\n+        b[2] = 5;\n+    }\n+    let comp: &mut [i32] = &mut [4, 2, 5];\n+    assert_eq!(&*cell.borrow(), comp);\n+}"}, {"sha": "0415c75aa5204cb6eaa43dd6f37296f5dd0a63de", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 228, "deletions": 1, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -11,7 +11,7 @@\n use core::iter::*;\n use core::iter::order::*;\n use core::iter::MinMaxResult::*;\n-use core::isize;\n+use core::{i8, i16, isize};\n use core::usize;\n use core::cmp;\n \n@@ -100,6 +100,42 @@ fn test_iterator_chain() {\n     assert_eq!(i, expected.len());\n }\n \n+#[test]\n+fn test_iterator_chain_nth() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let zs = [];\n+    let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n+    for (i, x) in expected.iter().enumerate() {\n+        assert_eq!(Some(x), xs.iter().chain(ys.iter()).nth(i));\n+    }\n+    assert_eq!(zs.iter().chain(xs.iter()).nth(0), Some(&0));\n+\n+    let mut it = xs.iter().chain(zs.iter());\n+    assert_eq!(it.nth(5), Some(&5));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_iterator_chain_last() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let zs = [];\n+    assert_eq!(xs.iter().chain(ys.iter()).last(), Some(&60));\n+    assert_eq!(zs.iter().chain(ys.iter()).last(), Some(&60));\n+    assert_eq!(ys.iter().chain(zs.iter()).last(), Some(&60));\n+    assert_eq!(zs.iter().chain(zs.iter()).last(), None);\n+}\n+\n+#[test]\n+fn test_iterator_chain_count() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [30, 40, 50, 60];\n+    let zs = [];\n+    assert_eq!(xs.iter().chain(ys.iter()).count(), 10);\n+    assert_eq!(zs.iter().chain(ys.iter()).count(), 4);\n+}\n+\n #[test]\n fn test_filter_map() {\n     let it = (0..).step_by(1).take(10)\n@@ -116,6 +152,34 @@ fn test_iterator_enumerate() {\n     }\n }\n \n+#[test]\n+fn test_iterator_enumerate_nth() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    for (i, &x) in xs.iter().enumerate() {\n+        assert_eq!(i, x);\n+    }\n+\n+    let mut it = xs.iter().enumerate();\n+    while let Some((i, &x)) = it.nth(0) {\n+        assert_eq!(i, x);\n+    }\n+\n+    let mut it = xs.iter().enumerate();\n+    while let Some((i, &x)) = it.nth(1) {\n+        assert_eq!(i, x);\n+    }\n+\n+    let (i, &x) = xs.iter().enumerate().nth(3).unwrap();\n+    assert_eq!(i, x);\n+    assert_eq!(i, 3);\n+}\n+\n+#[test]\n+fn test_iterator_enumerate_count() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    assert_eq!(xs.iter().count(), 6);\n+}\n+\n #[test]\n fn test_iterator_peekable() {\n     let xs = vec![0, 1, 2, 3, 4, 5];\n@@ -148,6 +212,59 @@ fn test_iterator_peekable() {\n     assert_eq!(it.len(), 0);\n }\n \n+#[test]\n+fn test_iterator_peekable_count() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [10];\n+    let zs: [i32; 0] = [];\n+\n+    assert_eq!(xs.iter().peekable().count(), 6);\n+\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    assert_eq!(it.count(), 6);\n+\n+    assert_eq!(ys.iter().peekable().count(), 1);\n+\n+    let mut it = ys.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&10));\n+    assert_eq!(it.count(), 1);\n+\n+    assert_eq!(zs.iter().peekable().count(), 0);\n+\n+    let mut it = zs.iter().peekable();\n+    assert_eq!(it.peek(), None);\n+\n+}\n+\n+#[test]\n+fn test_iterator_peekable_nth() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().peekable();\n+\n+    assert_eq!(it.peek(), Some(&&0));\n+    assert_eq!(it.nth(0), Some(&0));\n+    assert_eq!(it.peek(), Some(&&1));\n+    assert_eq!(it.nth(1), Some(&2));\n+    assert_eq!(it.peek(), Some(&&3));\n+    assert_eq!(it.nth(2), Some(&5));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+fn test_iterator_peekable_last() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let ys = [0];\n+\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    assert_eq!(it.last(), Some(&5));\n+\n+    let mut it = ys.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    assert_eq!(it.last(), Some(&0));\n+}\n+\n #[test]\n fn test_iterator_take_while() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n@@ -189,6 +306,49 @@ fn test_iterator_skip() {\n     assert_eq!(it.len(), 0);\n }\n \n+#[test]\n+fn test_iterator_skip_nth() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+\n+    let mut it = xs.iter().skip(0);\n+    assert_eq!(it.nth(0), Some(&0));\n+    assert_eq!(it.nth(1), Some(&2));\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.nth(0), Some(&13));\n+    assert_eq!(it.nth(1), Some(&16));\n+\n+    let mut it = xs.iter().skip(12);\n+    assert_eq!(it.nth(0), None);\n+\n+}\n+\n+#[test]\n+fn test_iterator_skip_count() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+\n+    assert_eq!(xs.iter().skip(0).count(), 12);\n+    assert_eq!(xs.iter().skip(1).count(), 11);\n+    assert_eq!(xs.iter().skip(11).count(), 1);\n+    assert_eq!(xs.iter().skip(12).count(), 0);\n+    assert_eq!(xs.iter().skip(13).count(), 0);\n+}\n+\n+#[test]\n+fn test_iterator_skip_last() {\n+    let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19, 20, 30];\n+\n+    assert_eq!(xs.iter().skip(0).last(), Some(&30));\n+    assert_eq!(xs.iter().skip(1).last(), Some(&30));\n+    assert_eq!(xs.iter().skip(11).last(), Some(&30));\n+    assert_eq!(xs.iter().skip(12).last(), None);\n+    assert_eq!(xs.iter().skip(13).last(), None);\n+\n+    let mut it = xs.iter().skip(5);\n+    assert_eq!(it.next(), Some(&13));\n+    assert_eq!(it.last(), Some(&30));\n+}\n+\n #[test]\n fn test_iterator_take() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n@@ -205,6 +365,30 @@ fn test_iterator_take() {\n     assert_eq!(it.len(), 0);\n }\n \n+#[test]\n+fn test_iterator_take_nth() {\n+    let xs = [0, 1, 2, 4, 5];\n+    let mut it = xs.iter();\n+    {\n+        let mut take = it.by_ref().take(3);\n+        let mut i = 0;\n+        while let Some(&x) = take.nth(0) {\n+            assert_eq!(x, i);\n+            i += 1;\n+        }\n+    }\n+    assert_eq!(it.nth(1), Some(&5));\n+    assert_eq!(it.nth(0), None);\n+\n+    let xs = [0, 1, 2, 3, 4];\n+    let mut it = xs.iter().take(7);\n+    let mut i = 1;\n+    while let Some(&x) = it.nth(1) {\n+        assert_eq!(x, i);\n+        i += 2;\n+    }\n+}\n+\n #[test]\n fn test_iterator_take_short() {\n     let xs = [0, 1, 2, 3];\n@@ -786,6 +970,18 @@ fn test_range_step() {\n     assert_eq!((200..255).step_by(50).collect::<Vec<u8>>(), [200, 250]);\n     assert_eq!((200..-5).step_by(1).collect::<Vec<isize>>(), []);\n     assert_eq!((200..200).step_by(1).collect::<Vec<isize>>(), []);\n+\n+    assert_eq!((0..20).step_by(1).size_hint(), (20, Some(20)));\n+    assert_eq!((0..20).step_by(21).size_hint(), (1, Some(1)));\n+    assert_eq!((0..20).step_by(5).size_hint(), (4, Some(4)));\n+    assert_eq!((20..0).step_by(-5).size_hint(), (4, Some(4)));\n+    assert_eq!((20..0).step_by(-6).size_hint(), (4, Some(4)));\n+    assert_eq!((20..-5).step_by(1).size_hint(), (0, Some(0)));\n+    assert_eq!((20..20).step_by(1).size_hint(), (0, Some(0)));\n+    assert_eq!((0..1).step_by(0).size_hint(), (0, None));\n+    assert_eq!((i8::MAX..i8::MIN).step_by(i8::MIN).size_hint(), (2, Some(2)));\n+    assert_eq!((i16::MIN..i16::MAX).step_by(i16::MAX).size_hint(), (3, Some(3)));\n+    assert_eq!((isize::MIN..isize::MAX).step_by(1).size_hint(), (usize::MAX, Some(usize::MAX)));\n }\n \n #[test]\n@@ -869,6 +1065,37 @@ fn test_fuse() {\n     assert_eq!(it.len(), 0);\n }\n \n+#[test]\n+fn test_fuse_nth() {\n+    let xs = [0, 1, 2];\n+    let mut it = xs.iter();\n+\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.nth(2), Some(&2));\n+    assert_eq!(it.len(), 0);\n+    assert_eq!(it.nth(2), None);\n+    assert_eq!(it.len(), 0);\n+}\n+\n+#[test]\n+fn test_fuse_last() {\n+    let xs = [0, 1, 2];\n+    let it = xs.iter();\n+\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.last(), Some(&2));\n+}\n+\n+#[test]\n+fn test_fuse_count() {\n+    let xs = [0, 1, 2];\n+    let it = xs.iter();\n+\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.count(), 3);\n+    // Can't check len now because count consumes.\n+}\n+\n #[bench]\n fn bench_rposition(b: &mut Bencher) {\n     let it: Vec<usize> = (0..300).collect();"}, {"sha": "90c1e8b132e42be16975d4d66eb6996bd1ec2598", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -30,6 +30,7 @@ extern crate core;\n extern crate test;\n extern crate libc;\n extern crate rustc_unicode;\n+extern crate rand;\n \n mod any;\n mod atomic;"}, {"sha": "09a1ed41dadd17c7f0dcbc244096fd00b62b0e1d", "filename": "src/libcoretest/num/flt2dec/bignum.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fbignum.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,160 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::prelude::v1::*;\n+use core::num::flt2dec::bignum::tests::Big8x3 as Big;\n+\n+#[test]\n+#[should_panic]\n+fn test_from_u64_overflow() {\n+    Big::from_u64(0x1000000);\n+}\n+\n+#[test]\n+fn test_add() {\n+    assert_eq!(*Big::from_small(3).add(&Big::from_small(4)), Big::from_small(7));\n+    assert_eq!(*Big::from_small(3).add(&Big::from_small(0)), Big::from_small(3));\n+    assert_eq!(*Big::from_small(0).add(&Big::from_small(3)), Big::from_small(3));\n+    assert_eq!(*Big::from_small(3).add(&Big::from_u64(0xfffe)), Big::from_u64(0x10001));\n+    assert_eq!(*Big::from_u64(0xfedc).add(&Big::from_u64(0x789)), Big::from_u64(0x10665));\n+    assert_eq!(*Big::from_u64(0x789).add(&Big::from_u64(0xfedc)), Big::from_u64(0x10665));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_add_overflow_1() {\n+    Big::from_small(1).add(&Big::from_u64(0xffffff));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_add_overflow_2() {\n+    Big::from_u64(0xffffff).add(&Big::from_small(1));\n+}\n+\n+#[test]\n+fn test_sub() {\n+    assert_eq!(*Big::from_small(7).sub(&Big::from_small(4)), Big::from_small(3));\n+    assert_eq!(*Big::from_u64(0x10665).sub(&Big::from_u64(0x789)), Big::from_u64(0xfedc));\n+    assert_eq!(*Big::from_u64(0x10665).sub(&Big::from_u64(0xfedc)), Big::from_u64(0x789));\n+    assert_eq!(*Big::from_u64(0x10665).sub(&Big::from_u64(0x10664)), Big::from_small(1));\n+    assert_eq!(*Big::from_u64(0x10665).sub(&Big::from_u64(0x10665)), Big::from_small(0));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_sub_underflow_1() {\n+    Big::from_u64(0x10665).sub(&Big::from_u64(0x10666));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_sub_underflow_2() {\n+    Big::from_small(0).sub(&Big::from_u64(0x123456));\n+}\n+\n+#[test]\n+fn test_mul_small() {\n+    assert_eq!(*Big::from_small(7).mul_small(5), Big::from_small(35));\n+    assert_eq!(*Big::from_small(0xff).mul_small(0xff), Big::from_u64(0xfe01));\n+    assert_eq!(*Big::from_u64(0xffffff/13).mul_small(13), Big::from_u64(0xffffff));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mul_small_overflow() {\n+    Big::from_u64(0x800000).mul_small(2);\n+}\n+\n+#[test]\n+fn test_mul_pow2() {\n+    assert_eq!(*Big::from_small(0x7).mul_pow2(4), Big::from_small(0x70));\n+    assert_eq!(*Big::from_small(0xff).mul_pow2(1), Big::from_u64(0x1fe));\n+    assert_eq!(*Big::from_small(0xff).mul_pow2(12), Big::from_u64(0xff000));\n+    assert_eq!(*Big::from_small(0x1).mul_pow2(23), Big::from_u64(0x800000));\n+    assert_eq!(*Big::from_u64(0x123).mul_pow2(0), Big::from_u64(0x123));\n+    assert_eq!(*Big::from_u64(0x123).mul_pow2(7), Big::from_u64(0x9180));\n+    assert_eq!(*Big::from_u64(0x123).mul_pow2(15), Big::from_u64(0x918000));\n+    assert_eq!(*Big::from_small(0).mul_pow2(23), Big::from_small(0));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mul_pow2_overflow_1() {\n+    Big::from_u64(0x1).mul_pow2(24);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mul_pow2_overflow_2() {\n+    Big::from_u64(0x123).mul_pow2(16);\n+}\n+\n+#[test]\n+fn test_mul_digits() {\n+    assert_eq!(*Big::from_small(3).mul_digits(&[5]), Big::from_small(15));\n+    assert_eq!(*Big::from_small(0xff).mul_digits(&[0xff]), Big::from_u64(0xfe01));\n+    assert_eq!(*Big::from_u64(0x123).mul_digits(&[0x56, 0x4]), Big::from_u64(0x4edc2));\n+    assert_eq!(*Big::from_u64(0x12345).mul_digits(&[0x67]), Big::from_u64(0x7530c3));\n+    assert_eq!(*Big::from_small(0x12).mul_digits(&[0x67, 0x45, 0x3]), Big::from_u64(0x3ae13e));\n+    assert_eq!(*Big::from_u64(0xffffff/13).mul_digits(&[13]), Big::from_u64(0xffffff));\n+    assert_eq!(*Big::from_small(13).mul_digits(&[0x3b, 0xb1, 0x13]), Big::from_u64(0xffffff));\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mul_digits_overflow_1() {\n+    Big::from_u64(0x800000).mul_digits(&[2]);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_mul_digits_overflow_2() {\n+    Big::from_u64(0x1000).mul_digits(&[0, 0x10]);\n+}\n+\n+#[test]\n+fn test_div_rem_small() {\n+    let as_val = |(q, r): (&mut Big, u8)| (q.clone(), r);\n+    assert_eq!(as_val(Big::from_small(0xff).div_rem_small(15)), (Big::from_small(17), 0));\n+    assert_eq!(as_val(Big::from_small(0xff).div_rem_small(16)), (Big::from_small(15), 15));\n+    assert_eq!(as_val(Big::from_small(3).div_rem_small(40)), (Big::from_small(0), 3));\n+    assert_eq!(as_val(Big::from_u64(0xffffff).div_rem_small(123)),\n+               (Big::from_u64(0xffffff / 123), (0xffffffu64 % 123) as u8));\n+    assert_eq!(as_val(Big::from_u64(0x10000).div_rem_small(123)),\n+               (Big::from_u64(0x10000 / 123), (0x10000u64 % 123) as u8));\n+}\n+\n+#[test]\n+fn test_is_zero() {\n+    assert!(Big::from_small(0).is_zero());\n+    assert!(!Big::from_small(3).is_zero());\n+    assert!(!Big::from_u64(0x123).is_zero());\n+    assert!(!Big::from_u64(0xffffff).sub(&Big::from_u64(0xfffffe)).is_zero());\n+    assert!(Big::from_u64(0xffffff).sub(&Big::from_u64(0xffffff)).is_zero());\n+}\n+\n+#[test]\n+fn test_ord() {\n+    assert!(Big::from_u64(0) < Big::from_u64(0xffffff));\n+    assert!(Big::from_u64(0x102) < Big::from_u64(0x201));\n+}\n+\n+#[test]\n+fn test_fmt() {\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0)), \"0x0\");\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0x1)), \"0x1\");\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0x12)), \"0x12\");\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0x123)), \"0x1_23\");\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0x1234)), \"0x12_34\");\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0x12345)), \"0x1_23_45\");\n+    assert_eq!(format!(\"{:?}\", Big::from_u64(0x123456)), \"0x12_34_56\");\n+}\n+"}, {"sha": "21260c520f6235e26f0129dd141dec9a07f58146", "filename": "src/libcoretest/num/flt2dec/estimator.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::f64;\n+use core::num::flt2dec::estimator::*;\n+\n+#[test]\n+fn test_estimate_scaling_factor() {\n+    macro_rules! assert_almost_eq {\n+        ($actual:expr, $expected:expr) => ({\n+            let actual = $actual;\n+            let expected = $expected;\n+            println!(\"{} - {} = {} - {} = {}\", stringify!($expected), stringify!($actual),\n+                     expected, actual, expected - actual);\n+            assert!(expected == actual || expected == actual + 1,\n+                    \"expected {}, actual {}\", expected, actual);\n+        })\n+    }\n+\n+    assert_almost_eq!(estimate_scaling_factor(1, 0), 0);\n+    assert_almost_eq!(estimate_scaling_factor(2, 0), 1);\n+    assert_almost_eq!(estimate_scaling_factor(10, 0), 1);\n+    assert_almost_eq!(estimate_scaling_factor(11, 0), 2);\n+    assert_almost_eq!(estimate_scaling_factor(100, 0), 2);\n+    assert_almost_eq!(estimate_scaling_factor(101, 0), 3);\n+    assert_almost_eq!(estimate_scaling_factor(10000000000000000000, 0), 19);\n+    assert_almost_eq!(estimate_scaling_factor(10000000000000000001, 0), 20);\n+\n+    // 1/2^20 = 0.00000095367...\n+    assert_almost_eq!(estimate_scaling_factor(1 * 1048576 / 1000000, -20), -6);\n+    assert_almost_eq!(estimate_scaling_factor(1 * 1048576 / 1000000 + 1, -20), -5);\n+    assert_almost_eq!(estimate_scaling_factor(10 * 1048576 / 1000000, -20), -5);\n+    assert_almost_eq!(estimate_scaling_factor(10 * 1048576 / 1000000 + 1, -20), -4);\n+    assert_almost_eq!(estimate_scaling_factor(100 * 1048576 / 1000000, -20), -4);\n+    assert_almost_eq!(estimate_scaling_factor(100 * 1048576 / 1000000 + 1, -20), -3);\n+    assert_almost_eq!(estimate_scaling_factor(1048575, -20), 0);\n+    assert_almost_eq!(estimate_scaling_factor(1048576, -20), 0);\n+    assert_almost_eq!(estimate_scaling_factor(1048577, -20), 1);\n+    assert_almost_eq!(estimate_scaling_factor(10485759999999999999, -20), 13);\n+    assert_almost_eq!(estimate_scaling_factor(10485760000000000000, -20), 13);\n+    assert_almost_eq!(estimate_scaling_factor(10485760000000000001, -20), 14);\n+\n+    // extreme values:\n+    // 2^-1074 = 4.94065... * 10^-324\n+    // (2^53-1) * 2^971 = 1.79763... * 10^308\n+    assert_almost_eq!(estimate_scaling_factor(1, -1074), -323);\n+    assert_almost_eq!(estimate_scaling_factor(0x1fffffffffffff, 971), 309);\n+\n+    for i in -1074..972 {\n+        let expected = f64::ldexp(1.0, i).log10().ceil();\n+        assert_almost_eq!(estimate_scaling_factor(1, i as i16), expected as i16);\n+    }\n+}\n+"}, {"sha": "488cd3a779ca30e30f94d5f8f7bbf6d3bb1eaa1c", "filename": "src/libcoretest/num/flt2dec/mod.rs", "status": "added", "additions": 1178, "deletions": 0, "changes": 1178, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,1178 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::prelude::v1::*;\n+use std::{str, mem, i16, f32, f64, fmt};\n+use std::slice::bytes;\n+use std::__rand as rand;\n+use rand::{Rand, XorShiftRng};\n+use rand::distributions::{IndependentSample, Range};\n+\n+use core::num::flt2dec::{decode, DecodableFloat, FullDecoded, Decoded};\n+use core::num::flt2dec::{MAX_SIG_DIGITS, round_up, Part, Formatted, Sign};\n+use core::num::flt2dec::{to_shortest_str, to_shortest_exp_str,\n+                         to_exact_exp_str, to_exact_fixed_str};\n+\n+pub use test::Bencher;\n+\n+mod estimator;\n+mod bignum;\n+mod strategy {\n+    mod dragon;\n+    mod grisu;\n+}\n+\n+pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n+    match decode(v).1 {\n+        FullDecoded::Finite(decoded) => decoded,\n+        full_decoded => panic!(\"expected finite, got {:?} instead\", full_decoded)\n+    }\n+}\n+\n+macro_rules! check_shortest {\n+    ($f:ident($v:expr) => $buf:expr, $exp:expr) => (\n+        check_shortest!($f($v) => $buf, $exp;\n+                        \"shortest mismatch for v={v}: actual {actual:?}, expected {expected:?}\",\n+                        v = stringify!($v))\n+    );\n+\n+    ($f:ident{$($k:ident: $v:expr),+} => $buf:expr, $exp:expr) => (\n+        check_shortest!($f{$($k: $v),+} => $buf, $exp;\n+                        \"shortest mismatch for {v:?}: actual {actual:?}, expected {expected:?}\",\n+                        v = Decoded { $($k: $v),+ })\n+    );\n+\n+    ($f:ident($v:expr) => $buf:expr, $exp:expr; $fmt:expr, $($key:ident = $val:expr),*) => ({\n+        let mut buf = [b'_'; MAX_SIG_DIGITS];\n+        let (len, k) = $f(&decode_finite($v), &mut buf);\n+        assert!((&buf[..len], k) == ($buf, $exp),\n+                $fmt, actual = (str::from_utf8(&buf[..len]).unwrap(), k),\n+                      expected = (str::from_utf8($buf).unwrap(), $exp),\n+                      $($key = $val),*);\n+    });\n+\n+    ($f:ident{$($k:ident: $v:expr),+} => $buf:expr, $exp:expr;\n+                                         $fmt:expr, $($key:ident = $val:expr),*) => ({\n+        let mut buf = [b'_'; MAX_SIG_DIGITS];\n+        let (len, k) = $f(&Decoded { $($k: $v),+ }, &mut buf);\n+        assert!((&buf[..len], k) == ($buf, $exp),\n+                $fmt, actual = (str::from_utf8(&buf[..len]).unwrap(), k),\n+                      expected = (str::from_utf8($buf).unwrap(), $exp),\n+                      $($key = $val),*);\n+    })\n+}\n+\n+macro_rules! try_exact {\n+    ($f:ident($decoded:expr) => $buf:expr, $expected:expr, $expectedk:expr;\n+                                $fmt:expr, $($key:ident = $val:expr),*) => ({\n+        let (len, k) = $f($decoded, &mut $buf[..$expected.len()], i16::MIN);\n+        assert!((&$buf[..len], k) == ($expected, $expectedk),\n+                $fmt, actual = (str::from_utf8(&$buf[..len]).unwrap(), k),\n+                      expected = (str::from_utf8($expected).unwrap(), $expectedk),\n+                      $($key = $val),*);\n+    })\n+}\n+\n+macro_rules! try_fixed {\n+    ($f:ident($decoded:expr) => $buf:expr, $request:expr, $expected:expr, $expectedk:expr;\n+                                $fmt:expr, $($key:ident = $val:expr),*) => ({\n+        let (len, k) = $f($decoded, &mut $buf[..], $request);\n+        assert!((&$buf[..len], k) == ($expected, $expectedk),\n+                $fmt, actual = (str::from_utf8(&$buf[..len]).unwrap(), k),\n+                      expected = (str::from_utf8($expected).unwrap(), $expectedk),\n+                      $($key = $val),*);\n+    })\n+}\n+\n+fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16)\n+        where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    // use a large enough buffer\n+    let mut buf = [b'_'; 1024];\n+    let mut expected_ = [b'_'; 1024];\n+\n+    let decoded = decode_finite(v);\n+    let cut = expected.iter().position(|&c| c == b' ');\n+\n+    // check significant digits\n+    for i in 1..cut.unwrap_or(expected.len() - 1) {\n+        bytes::copy_memory(&expected[..i], &mut expected_);\n+        let mut expectedk_ = expectedk;\n+        if expected[i] >= b'5' {\n+            // check if this is a rounding-to-even case.\n+            // we avoid rounding ...x5000... (with infinite zeroes) to ...(x+1) when x is even.\n+            if !(i+1 < expected.len() && expected[i-1] & 1 == 0 &&\n+                                         expected[i] == b'5' &&\n+                                         expected[i+1] == b' ') {\n+                // if this returns true, expected_[..i] is all `9`s and being rounded up.\n+                // we should always return `100..00` (`i` digits) instead, since that's\n+                // what we can came up with `i` digits anyway. `round_up` assumes that\n+                // the adjustment to the length is done by caller, which we simply ignore.\n+                if let Some(_) = round_up(&mut expected_, i) { expectedk_ += 1; }\n+            }\n+        }\n+\n+        try_exact!(f(&decoded) => &mut buf, &expected_[..i], expectedk_;\n+                   \"exact sigdigit mismatch for v={v}, i={i}: \\\n+                    actual {actual:?}, expected {expected:?}\",\n+                   v = vstr, i = i);\n+        try_fixed!(f(&decoded) => &mut buf, expectedk_ - i as i16, &expected_[..i], expectedk_;\n+                   \"fixed sigdigit mismatch for v={v}, i={i}: \\\n+                    actual {actual:?}, expected {expected:?}\",\n+                   v = vstr, i = i);\n+    }\n+\n+    // check exact rounding for zero- and negative-width cases\n+    let start;\n+    if expected[0] >= b'5' {\n+        try_fixed!(f(&decoded) => &mut buf, expectedk, b\"1\", expectedk + 1;\n+                   \"zero-width rounding-up mismatch for v={v}: \\\n+                    actual {actual:?}, expected {expected:?}\",\n+                   v = vstr);\n+        start = 1;\n+    } else {\n+        start = 0;\n+    }\n+    for i in start..-10 {\n+        try_fixed!(f(&decoded) => &mut buf, expectedk - i, b\"\", expectedk;\n+                   \"rounding-down mismatch for v={v}, i={i}: \\\n+                    actual {actual:?}, expected {expected:?}\",\n+                   v = vstr, i = -i);\n+    }\n+\n+    // check infinite zero digits\n+    if let Some(cut) = cut {\n+        for i in cut..expected.len()-1 {\n+            bytes::copy_memory(&expected[..cut], &mut expected_);\n+            for c in &mut expected_[cut..i] { *c = b'0'; }\n+\n+            try_exact!(f(&decoded) => &mut buf, &expected_[..i], expectedk;\n+                       \"exact infzero mismatch for v={v}, i={i}: \\\n+                        actual {actual:?}, expected {expected:?}\",\n+                       v = vstr, i = i);\n+            try_fixed!(f(&decoded) => &mut buf, expectedk - i as i16, &expected_[..i], expectedk;\n+                       \"fixed infzero mismatch for v={v}, i={i}: \\\n+                        actual {actual:?}, expected {expected:?}\",\n+                       v = vstr, i = i);\n+        }\n+    }\n+}\n+\n+fn check_exact_one<F, T>(mut f: F, x: i64, e: isize, tstr: &str, expected: &[u8], expectedk: i16)\n+        where T: DecodableFloat + fmt::Display,\n+              F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    // use a large enough buffer\n+    let mut buf = [b'_'; 1024];\n+    let v: T = DecodableFloat::ldexpi(x, e);\n+    let decoded = decode_finite(v);\n+\n+    try_exact!(f(&decoded) => &mut buf, &expected, expectedk;\n+               \"exact mismatch for v={x}p{e}{t}: actual {actual:?}, expected {expected:?}\",\n+               x = x, e = e, t = tstr);\n+    try_fixed!(f(&decoded) => &mut buf, expectedk - expected.len() as i16, &expected, expectedk;\n+               \"fixed mismatch for v={x}p{e}{t}: actual {actual:?}, expected {expected:?}\",\n+               x = x, e = e, t = tstr);\n+}\n+\n+macro_rules! check_exact {\n+    ($f:ident($v:expr) => $buf:expr, $exp:expr) => (\n+        check_exact(|d,b,k| $f(d,b,k), $v, stringify!($v), $buf, $exp)\n+    )\n+}\n+\n+macro_rules! check_exact_one {\n+    ($f:ident($x:expr, $e:expr; $t:ty) => $buf:expr, $exp:expr) => (\n+        check_exact_one::<_, $t>(|d,b,k| $f(d,b,k), $x, $e, stringify!($t), $buf, $exp)\n+    )\n+}\n+\n+// in the following comments, three numbers are spaced by 1 ulp apart,\n+// and the second one is being formatted.\n+//\n+// some tests are derived from [1].\n+//\n+// [1] Vern Paxson, A Program for Testing IEEE Decimal-Binary Conversion\n+//     ftp://ftp.ee.lbl.gov/testbase-report.ps.Z\n+\n+pub fn f32_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    // 0.0999999940395355224609375\n+    // 0.100000001490116119384765625\n+    // 0.10000000894069671630859375\n+    check_shortest!(f(0.1f32) => b\"1\", 0);\n+\n+    // 0.333333313465118408203125\n+    // 0.3333333432674407958984375 (1/3 in the default rounding)\n+    // 0.33333337306976318359375\n+    check_shortest!(f(1.0f32/3.0) => b\"33333334\", 0);\n+\n+    // 10^1 * 0.31415917873382568359375\n+    // 10^1 * 0.31415920257568359375\n+    // 10^1 * 0.31415922641754150390625\n+    check_shortest!(f(3.141592f32) => b\"3141592\", 1);\n+\n+    // 10^18 * 0.31415916243714048\n+    // 10^18 * 0.314159196796878848\n+    // 10^18 * 0.314159231156617216\n+    check_shortest!(f(3.141592e17f32) => b\"3141592\", 18);\n+\n+    // regression test for decoders\n+    // 10^8 * 0.3355443\n+    // 10^8 * 0.33554432\n+    // 10^8 * 0.33554436\n+    check_shortest!(f(f32::ldexp(1.0, 25)) => b\"33554432\", 8);\n+\n+    // 10^39 * 0.340282326356119256160033759537265639424\n+    // 10^39 * 0.34028234663852885981170418348451692544\n+    // 10^39 * 0.340282366920938463463374607431768211456\n+    check_shortest!(f(f32::MAX) => b\"34028235\", 39);\n+\n+    // 10^-37 * 0.1175494210692441075487029444849287348827...\n+    // 10^-37 * 0.1175494350822287507968736537222245677818...\n+    // 10^-37 * 0.1175494490952133940450443629595204006810...\n+    check_shortest!(f(f32::MIN_POSITIVE) => b\"11754944\", -37);\n+\n+    // 10^-44 * 0\n+    // 10^-44 * 0.1401298464324817070923729583289916131280...\n+    // 10^-44 * 0.2802596928649634141847459166579832262560...\n+    let minf32 = f32::ldexp(1.0, -149);\n+    check_shortest!(f(minf32) => b\"1\", -44);\n+}\n+\n+pub fn f32_exact_sanity_test<F>(mut f: F)\n+        where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    let minf32 = f32::ldexp(1.0, -149);\n+\n+    check_exact!(f(0.1f32)            => b\"100000001490116119384765625             \", 0);\n+    check_exact!(f(0.5f32)            => b\"5                                       \", 0);\n+    check_exact!(f(1.0f32/3.0)        => b\"3333333432674407958984375               \", 0);\n+    check_exact!(f(3.141592f32)       => b\"31415920257568359375                    \", 1);\n+    check_exact!(f(3.141592e17f32)    => b\"314159196796878848                      \", 18);\n+    check_exact!(f(f32::MAX)          => b\"34028234663852885981170418348451692544  \", 39);\n+    check_exact!(f(f32::MIN_POSITIVE) => b\"1175494350822287507968736537222245677818\", -37);\n+    check_exact!(f(minf32)            => b\"1401298464324817070923729583289916131280\", -44);\n+\n+    // [1], Table 16: Stress Inputs for Converting 24-bit Binary to Decimal, < 1/2 ULP\n+    check_exact_one!(f(12676506, -102; f32) => b\"2\",            -23);\n+    check_exact_one!(f(12676506, -103; f32) => b\"12\",           -23);\n+    check_exact_one!(f(15445013,   86; f32) => b\"119\",           34);\n+    check_exact_one!(f(13734123, -138; f32) => b\"3941\",         -34);\n+    check_exact_one!(f(12428269, -130; f32) => b\"91308\",        -32);\n+    check_exact_one!(f(15334037, -146; f32) => b\"171900\",       -36);\n+    check_exact_one!(f(11518287,  -41; f32) => b\"5237910\",       -5);\n+    check_exact_one!(f(12584953, -145; f32) => b\"28216440\",     -36);\n+    check_exact_one!(f(15961084, -125; f32) => b\"375243281\",    -30);\n+    check_exact_one!(f(14915817, -146; f32) => b\"1672120916\",   -36);\n+    check_exact_one!(f(10845484, -102; f32) => b\"21388945814\",  -23);\n+    check_exact_one!(f(16431059,  -61; f32) => b\"712583594561\", -11);\n+\n+    // [1], Table 17: Stress Inputs for Converting 24-bit Binary to Decimal, > 1/2 ULP\n+    check_exact_one!(f(16093626,   69; f32) => b\"1\",             29);\n+    check_exact_one!(f( 9983778,   25; f32) => b\"34\",            15);\n+    check_exact_one!(f(12745034,  104; f32) => b\"259\",           39);\n+    check_exact_one!(f(12706553,   72; f32) => b\"6001\",          29);\n+    check_exact_one!(f(11005028,   45; f32) => b\"38721\",         21);\n+    check_exact_one!(f(15059547,   71; f32) => b\"355584\",        29);\n+    check_exact_one!(f(16015691,  -99; f32) => b\"2526831\",      -22);\n+    check_exact_one!(f( 8667859,   56; f32) => b\"62458507\",      24);\n+    check_exact_one!(f(14855922,  -82; f32) => b\"307213267\",    -17);\n+    check_exact_one!(f(14855922,  -83; f32) => b\"1536066333\",   -17);\n+    check_exact_one!(f(10144164, -110; f32) => b\"78147796834\",  -26);\n+    check_exact_one!(f(13248074,   95; f32) => b\"524810279937\",  36);\n+}\n+\n+pub fn f64_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    // 0.0999999999999999777955395074968691915273...\n+    // 0.1000000000000000055511151231257827021181...\n+    // 0.1000000000000000333066907387546962127089...\n+    check_shortest!(f(0.1f64) => b\"1\", 0);\n+\n+    // this example is explicitly mentioned in the paper.\n+    // 10^3 * 0.0999999999999999857891452847979962825775...\n+    // 10^3 * 0.1 (exact)\n+    // 10^3 * 0.1000000000000000142108547152020037174224...\n+    check_shortest!(f(100.0f64) => b\"1\", 3);\n+\n+    // 0.3333333333333332593184650249895639717578...\n+    // 0.3333333333333333148296162562473909929394... (1/3 in the default rounding)\n+    // 0.3333333333333333703407674875052180141210...\n+    check_shortest!(f(1.0f64/3.0) => b\"3333333333333333\", 0);\n+\n+    // explicit test case for equally closest representations.\n+    // Dragon has its own tie-breaking rule; Grisu should fall back.\n+    // 10^1 * 0.1000007629394531027955395074968691915273...\n+    // 10^1 * 0.100000762939453125 (exact)\n+    // 10^1 * 0.1000007629394531472044604925031308084726...\n+    check_shortest!(f(1.00000762939453125f64) => b\"10000076293945313\", 1);\n+\n+    // 10^1 * 0.3141591999999999718085064159822650253772...\n+    // 10^1 * 0.3141592000000000162174274009885266423225...\n+    // 10^1 * 0.3141592000000000606263483859947882592678...\n+    check_shortest!(f(3.141592f64) => b\"3141592\", 1);\n+\n+    // 10^18 * 0.314159199999999936\n+    // 10^18 * 0.3141592 (exact)\n+    // 10^18 * 0.314159200000000064\n+    check_shortest!(f(3.141592e17f64) => b\"3141592\", 18);\n+\n+    // regression test for decoders\n+    // 10^20 * 0.18446744073709549568\n+    // 10^20 * 0.18446744073709551616\n+    // 10^20 * 0.18446744073709555712\n+    check_shortest!(f(f64::ldexp(1.0, 64)) => b\"18446744073709552\", 20);\n+\n+    // pathological case: high = 10^23 (exact). tie breaking should always prefer that.\n+    // 10^24 * 0.099999999999999974834176\n+    // 10^24 * 0.099999999999999991611392\n+    // 10^24 * 0.100000000000000008388608\n+    check_shortest!(f(1.0e23f64) => b\"1\", 24);\n+\n+    // 10^309 * 0.1797693134862315508561243283845062402343...\n+    // 10^309 * 0.1797693134862315708145274237317043567980...\n+    // 10^309 * 0.1797693134862315907729305190789024733617...\n+    check_shortest!(f(f64::MAX) => b\"17976931348623157\", 309);\n+\n+    // 10^-307 * 0.2225073858507200889024586876085859887650...\n+    // 10^-307 * 0.2225073858507201383090232717332404064219...\n+    // 10^-307 * 0.2225073858507201877155878558578948240788...\n+    check_shortest!(f(f64::MIN_POSITIVE) => b\"22250738585072014\", -307);\n+\n+    // 10^-323 * 0\n+    // 10^-323 * 0.4940656458412465441765687928682213723650...\n+    // 10^-323 * 0.9881312916824930883531375857364427447301...\n+    let minf64 = f64::ldexp(1.0, -1074);\n+    check_shortest!(f(minf64) => b\"5\", -323);\n+}\n+\n+pub fn f64_exact_sanity_test<F>(mut f: F)\n+        where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    let minf64 = f64::ldexp(1.0, -1074);\n+\n+    check_exact!(f(0.1f64)            => b\"1000000000000000055511151231257827021181\", 0);\n+    check_exact!(f(0.45f64)           => b\"4500000000000000111022302462515654042363\", 0);\n+    check_exact!(f(0.5f64)            => b\"5                                       \", 0);\n+    check_exact!(f(0.95f64)           => b\"9499999999999999555910790149937383830547\", 0);\n+    check_exact!(f(100.0f64)          => b\"1                                       \", 3);\n+    check_exact!(f(999.5f64)          => b\"9995000000000000000000000000000000000000\", 3);\n+    check_exact!(f(1.0f64/3.0)        => b\"3333333333333333148296162562473909929394\", 0);\n+    check_exact!(f(3.141592f64)       => b\"3141592000000000162174274009885266423225\", 1);\n+    check_exact!(f(3.141592e17f64)    => b\"3141592                                 \", 18);\n+    check_exact!(f(1.0e23f64)         => b\"99999999999999991611392                 \", 23);\n+    check_exact!(f(f64::MAX)          => b\"1797693134862315708145274237317043567980\", 309);\n+    check_exact!(f(f64::MIN_POSITIVE) => b\"2225073858507201383090232717332404064219\", -307);\n+    check_exact!(f(minf64)            => b\"4940656458412465441765687928682213723650\\\n+                                           5980261432476442558568250067550727020875\\\n+                                           1865299836361635992379796564695445717730\\\n+                                           9266567103559397963987747960107818781263\\\n+                                           0071319031140452784581716784898210368871\\\n+                                           8636056998730723050006387409153564984387\\\n+                                           3124733972731696151400317153853980741262\\\n+                                           3856559117102665855668676818703956031062\\\n+                                           4931945271591492455329305456544401127480\\\n+                                           1297099995419319894090804165633245247571\\\n+                                           4786901472678015935523861155013480352649\\\n+                                           3472019379026810710749170333222684475333\\\n+                                           5720832431936092382893458368060106011506\\\n+                                           1698097530783422773183292479049825247307\\\n+                                           7637592724787465608477820373446969953364\\\n+                                           7017972677717585125660551199131504891101\\\n+                                           4510378627381672509558373897335989936648\\\n+                                           0994116420570263709027924276754456522908\\\n+                                           7538682506419718265533447265625         \", -323);\n+\n+    // [1], Table 3: Stress Inputs for Converting 53-bit Binary to Decimal, < 1/2 ULP\n+    check_exact_one!(f(8511030020275656,  -342; f64) => b\"9\",                       -87);\n+    check_exact_one!(f(5201988407066741,  -824; f64) => b\"46\",                     -232);\n+    check_exact_one!(f(6406892948269899,   237; f64) => b\"141\",                      88);\n+    check_exact_one!(f(8431154198732492,    72; f64) => b\"3981\",                     38);\n+    check_exact_one!(f(6475049196144587,    99; f64) => b\"41040\",                    46);\n+    check_exact_one!(f(8274307542972842,   726; f64) => b\"292084\",                  235);\n+    check_exact_one!(f(5381065484265332,  -456; f64) => b\"2891946\",                -121);\n+    check_exact_one!(f(6761728585499734, -1057; f64) => b\"43787718\",               -302);\n+    check_exact_one!(f(7976538478610756,   376; f64) => b\"122770163\",               130);\n+    check_exact_one!(f(5982403858958067,   377; f64) => b\"1841552452\",              130);\n+    check_exact_one!(f(5536995190630837,    93; f64) => b\"54835744350\",              44);\n+    check_exact_one!(f(7225450889282194,   710; f64) => b\"389190181146\",            230);\n+    check_exact_one!(f(7225450889282194,   709; f64) => b\"1945950905732\",           230);\n+    check_exact_one!(f(8703372741147379,   117; f64) => b\"14460958381605\",           52);\n+    check_exact_one!(f(8944262675275217, -1001; f64) => b\"417367747458531\",        -285);\n+    check_exact_one!(f(7459803696087692,  -707; f64) => b\"1107950772878888\",       -196);\n+    check_exact_one!(f(6080469016670379,  -381; f64) => b\"12345501366327440\",       -98);\n+    check_exact_one!(f(8385515147034757,   721; f64) => b\"925031711960365024\",      233);\n+    check_exact_one!(f(7514216811389786,  -828; f64) => b\"4198047150284889840\",    -233);\n+    check_exact_one!(f(8397297803260511,  -345; f64) => b\"11716315319786511046\",    -87);\n+    check_exact_one!(f(6733459239310543,   202; f64) => b\"432810072844612493629\",    77);\n+    check_exact_one!(f(8091450587292794,  -473; f64) => b\"3317710118160031081518\", -126);\n+\n+    // [1], Table 4: Stress Inputs for Converting 53-bit Binary to Decimal, > 1/2 ULP\n+    check_exact_one!(f(6567258882077402,   952; f64) => b\"3\",                       303);\n+    check_exact_one!(f(6712731423444934,   535; f64) => b\"76\",                      177);\n+    check_exact_one!(f(6712731423444934,   534; f64) => b\"378\",                     177);\n+    check_exact_one!(f(5298405411573037,  -957; f64) => b\"4350\",                   -272);\n+    check_exact_one!(f(5137311167659507,  -144; f64) => b\"23037\",                   -27);\n+    check_exact_one!(f(6722280709661868,   363; f64) => b\"126301\",                  126);\n+    check_exact_one!(f(5344436398034927,  -169; f64) => b\"7142211\",                 -35);\n+    check_exact_one!(f(8369123604277281,  -853; f64) => b\"13934574\",               -240);\n+    check_exact_one!(f(8995822108487663,  -780; f64) => b\"141463449\",              -218);\n+    check_exact_one!(f(8942832835564782,  -383; f64) => b\"4539277920\",              -99);\n+    check_exact_one!(f(8942832835564782,  -384; f64) => b\"22696389598\",             -99);\n+    check_exact_one!(f(8942832835564782,  -385; f64) => b\"113481947988\",            -99);\n+    check_exact_one!(f(6965949469487146,  -249; f64) => b\"7700366561890\",           -59);\n+    check_exact_one!(f(6965949469487146,  -250; f64) => b\"38501832809448\",          -59);\n+    check_exact_one!(f(6965949469487146,  -251; f64) => b\"192509164047238\",         -59);\n+    check_exact_one!(f(7487252720986826,   548; f64) => b\"6898586531774201\",        181);\n+    check_exact_one!(f(5592117679628511,   164; f64) => b\"13076622631878654\",        66);\n+    check_exact_one!(f(8887055249355788,   665; f64) => b\"136052020756121240\",      217);\n+    check_exact_one!(f(6994187472632449,   690; f64) => b\"3592810217475959676\",     224);\n+    check_exact_one!(f(8797576579012143,   588; f64) => b\"89125197712484551899\",    193);\n+    check_exact_one!(f(7363326733505337,   272; f64) => b\"558769757362301140950\",    98);\n+    check_exact_one!(f(8549497411294502,  -448; f64) => b\"1176257830728540379990\", -118);\n+}\n+\n+pub fn more_shortest_sanity_test<F>(mut f: F) where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    check_shortest!(f{mant: 99_999_999_999_999_999, minus: 1, plus: 1,\n+                      exp: 0, inclusive: true} => b\"1\", 18);\n+    check_shortest!(f{mant: 99_999_999_999_999_999, minus: 1, plus: 1,\n+                      exp: 0, inclusive: false} => b\"99999999999999999\", 17);\n+}\n+\n+fn iterate<F, G, V>(func: &str, k: usize, n: usize, mut f: F, mut g: G, mut v: V) -> (usize, usize)\n+        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16),\n+              V: FnMut(usize) -> Decoded {\n+    assert!(k <= 1024);\n+\n+    let mut npassed = 0; // f(x) = Some(g(x))\n+    let mut nignored = 0; // f(x) = None\n+\n+    for i in 0..n {\n+        if (i & 0xfffff) == 0 {\n+            println!(\"in progress, {:x}/{:x} (ignored={} passed={} failed={})\",\n+                     i, n, nignored, npassed, i - nignored - npassed);\n+        }\n+\n+        let decoded = v(i);\n+        let mut buf1 = [0; 1024];\n+        if let Some((len1, e1)) = f(&decoded, &mut buf1[..k]) {\n+            let mut buf2 = [0; 1024];\n+            let (len2, e2) = g(&decoded, &mut buf2[..k]);\n+            if e1 == e2 && &buf1[..len1] == &buf2[..len2] {\n+                npassed += 1;\n+            } else {\n+                println!(\"equivalence test failed, {:x}/{:x}: {:?} f(i)={}e{} g(i)={}e{}\",\n+                         i, n, decoded, str::from_utf8(&buf1[..len1]).unwrap(), e1,\n+                                        str::from_utf8(&buf2[..len2]).unwrap(), e2);\n+            }\n+        } else {\n+            nignored += 1;\n+        }\n+    }\n+    println!(\"{}({}): done, ignored={} passed={} failed={}\",\n+             func, k, nignored, npassed, n - nignored - npassed);\n+    assert!(nignored + npassed == n,\n+            \"{}({}): {} out of {} values returns an incorrect value!\",\n+            func, k, n - nignored - npassed, n);\n+    (npassed, nignored)\n+}\n+\n+pub fn f32_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n+        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    let mut rng: XorShiftRng = Rand::rand(&mut rand::thread_rng());\n+    let f32_range = Range::new(0x0000_0001u32, 0x7f80_0000);\n+    iterate(\"f32_random_equivalence_test\", k, n, f, g, |_| {\n+        let i: u32 = f32_range.ind_sample(&mut rng);\n+        let x: f32 = unsafe {mem::transmute(i)};\n+        decode_finite(x)\n+    });\n+}\n+\n+pub fn f64_random_equivalence_test<F, G>(f: F, g: G, k: usize, n: usize)\n+        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    let mut rng: XorShiftRng = Rand::rand(&mut rand::thread_rng());\n+    let f64_range = Range::new(0x0000_0000_0000_0001u64, 0x7ff0_0000_0000_0000);\n+    iterate(\"f64_random_equivalence_test\", k, n, f, g, |_| {\n+        let i: u64 = f64_range.ind_sample(&mut rng);\n+        let x: f64 = unsafe {mem::transmute(i)};\n+        decode_finite(x)\n+    });\n+}\n+\n+pub fn f32_exhaustive_equivalence_test<F, G>(f: F, g: G, k: usize)\n+        where F: FnMut(&Decoded, &mut [u8]) -> Option<(usize, i16)>,\n+              G: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    // we have only 2^23 * (2^8 - 1) - 1 = 2,139,095,039 positive finite f32 values,\n+    // so why not simply testing all of them?\n+    //\n+    // this is of course very stressful (and thus should be behind an `#[ignore]` attribute),\n+    // but with `-C opt-level=3 -C lto` this only takes about an hour or so.\n+\n+    // iterate from 0x0000_0001 to 0x7f7f_ffff, i.e. all finite ranges\n+    let (npassed, nignored) = iterate(\"f32_exhaustive_equivalence_test\",\n+                                      k, 0x7f7f_ffff, f, g, |i: usize| {\n+        let x: f32 = unsafe {mem::transmute(i as u32 + 1)};\n+        decode_finite(x)\n+    });\n+    assert_eq!((npassed, nignored), (2121451881, 17643158));\n+}\n+\n+fn to_string_with_parts<F>(mut f: F) -> String\n+        where F: for<'a> FnMut(&'a mut [u8], &'a mut [Part<'a>]) -> Formatted<'a> {\n+    let mut buf = [0; 1024];\n+    let mut parts = [Part::Zero(0); 16];\n+    let formatted = f(&mut buf, &mut parts);\n+    let mut ret = vec![0; formatted.len()];\n+    assert_eq!(formatted.write(&mut ret), Some(ret.len()));\n+    String::from_utf8(ret).unwrap()\n+}\n+\n+pub fn to_shortest_str_test<F>(mut f_: F)\n+        where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    use core::num::flt2dec::Sign::*;\n+\n+    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize, upper: bool) -> String\n+            where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+        to_string_with_parts(|buf, parts| to_shortest_str(|d,b| f(d,b), v, sign,\n+                                                          frac_digits, upper, buf, parts))\n+    }\n+\n+    let f = &mut f_;\n+\n+    assert_eq!(to_string(f,  0.0, Minus,        0, false), \"0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     0, false), \"0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    0, false), \"+0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, 0, false), \"+0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        0, false), \"0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     0, false), \"-0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    0, false), \"+0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 0, false), \"-0\");\n+    assert_eq!(to_string(f,  0.0, Minus,        1,  true), \"0.0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     1,  true), \"0.0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    1,  true), \"+0.0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, 1,  true), \"+0.0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        8,  true), \"0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     8,  true), \"-0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    8,  true), \"+0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8,  true), \"-0.00000000\");\n+\n+    assert_eq!(to_string(f,  1.0/0.0, Minus,         0, false), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,      0,  true), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlus,     0, false), \"+inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw,  0,  true), \"+inf\");\n+    assert_eq!(to_string(f,  0.0/0.0, Minus,         0, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,      1,  true), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,     8, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw, 64,  true), \"NaN\");\n+    assert_eq!(to_string(f, -1.0/0.0, Minus,         0, false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,      1,  true), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlus,     8, false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, 64,  true), \"-inf\");\n+\n+    assert_eq!(to_string(f,  3.14, Minus,        0, false), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     0, false), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    0, false), \"+3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, 0, false), \"+3.14\");\n+    assert_eq!(to_string(f, -3.14, Minus,        0, false), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     0, false), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    0, false), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 0, false), \"-3.14\");\n+    assert_eq!(to_string(f,  3.14, Minus,        1,  true), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     2,  true), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    3,  true), \"+3.140\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, 4,  true), \"+3.1400\");\n+    assert_eq!(to_string(f, -3.14, Minus,        8,  true), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     8,  true), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    8,  true), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 8,  true), \"-3.14000000\");\n+\n+    assert_eq!(to_string(f, 7.5e-11, Minus,  0, false), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus,  3, false), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 12, false), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 13, false), \"0.0000000000750\");\n+\n+    assert_eq!(to_string(f, 1.9971e20, Minus, 0, false), \"199710000000000000000\");\n+    assert_eq!(to_string(f, 1.9971e20, Minus, 1, false), \"199710000000000000000.0\");\n+    assert_eq!(to_string(f, 1.9971e20, Minus, 8, false), \"199710000000000000000.00000000\");\n+\n+    assert_eq!(to_string(f, f32::MAX, Minus, 0, false), format!(\"34028235{:0>31}\", \"\"));\n+    assert_eq!(to_string(f, f32::MAX, Minus, 1, false), format!(\"34028235{:0>31}.0\", \"\"));\n+    assert_eq!(to_string(f, f32::MAX, Minus, 8, false), format!(\"34028235{:0>31}.00000000\", \"\"));\n+\n+    let minf32 = f32::ldexp(1.0, -149);\n+    assert_eq!(to_string(f, minf32, Minus,  0, false), format!(\"0.{:0>44}1\", \"\"));\n+    assert_eq!(to_string(f, minf32, Minus, 45, false), format!(\"0.{:0>44}1\", \"\"));\n+    assert_eq!(to_string(f, minf32, Minus, 46, false), format!(\"0.{:0>44}10\", \"\"));\n+\n+    assert_eq!(to_string(f, f64::MAX, Minus, 0, false),\n+               format!(\"17976931348623157{:0>292}\", \"\"));\n+    assert_eq!(to_string(f, f64::MAX, Minus, 1, false),\n+               format!(\"17976931348623157{:0>292}.0\", \"\"));\n+    assert_eq!(to_string(f, f64::MAX, Minus, 8, false),\n+               format!(\"17976931348623157{:0>292}.00000000\", \"\"));\n+\n+    let minf64 = f64::ldexp(1.0, -1074);\n+    assert_eq!(to_string(f, minf64, Minus,   0, false), format!(\"0.{:0>323}5\", \"\"));\n+    assert_eq!(to_string(f, minf64, Minus, 324, false), format!(\"0.{:0>323}5\", \"\"));\n+    assert_eq!(to_string(f, minf64, Minus, 325, false), format!(\"0.{:0>323}50\", \"\"));\n+\n+    // very large output\n+    assert_eq!(to_string(f, 1.1, Minus, 80000, false), format!(\"1.1{:0>79999}\", \"\"));\n+}\n+\n+pub fn to_shortest_exp_str_test<F>(mut f_: F)\n+        where F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+    use core::num::flt2dec::Sign::*;\n+\n+    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, exp_bounds: (i16, i16), upper: bool) -> String\n+            where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8]) -> (usize, i16) {\n+        to_string_with_parts(|buf, parts| to_shortest_exp_str(|d,b| f(d,b), v, sign,\n+                                                              exp_bounds, upper, buf, parts))\n+    }\n+\n+    let f = &mut f_;\n+\n+    assert_eq!(to_string(f,  0.0, Minus,        (-4, 16), false), \"0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     (-4, 16), false), \"0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    (-4, 16), false), \"+0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, (-4, 16), false), \"+0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        (-4, 16), false), \"0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     (-4, 16), false), \"-0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    (-4, 16), false), \"+0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, (-4, 16), false), \"-0\");\n+    assert_eq!(to_string(f,  0.0, Minus,        ( 0,  0),  true), \"0E0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     ( 0,  0), false), \"0e0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    (-9, -5),  true), \"+0E0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, ( 5,  9), false), \"+0e0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        ( 0,  0),  true), \"0E0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     ( 0,  0), false), \"-0e0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    (-9, -5),  true), \"+0E0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, ( 5,  9), false), \"-0e0\");\n+\n+    assert_eq!(to_string(f,  1.0/0.0, Minus,        (-4, 16), false), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,     (-4, 16),  true), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlus,    (-4, 16), false), \"+inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw, (-4, 16),  true), \"+inf\");\n+    assert_eq!(to_string(f,  0.0/0.0, Minus,        ( 0,  0), false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,     ( 0,  0),  true), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,    (-9, -5), false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw, ( 5,  9),  true), \"NaN\");\n+    assert_eq!(to_string(f, -1.0/0.0, Minus,        ( 0,  0), false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,     ( 0,  0),  true), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlus,    (-9, -5), false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, ( 5,  9),  true), \"-inf\");\n+\n+    assert_eq!(to_string(f,  3.14, Minus,        (-4, 16), false), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     (-4, 16), false), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    (-4, 16), false), \"+3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, (-4, 16), false), \"+3.14\");\n+    assert_eq!(to_string(f, -3.14, Minus,        (-4, 16), false), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     (-4, 16), false), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    (-4, 16), false), \"-3.14\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, (-4, 16), false), \"-3.14\");\n+    assert_eq!(to_string(f,  3.14, Minus,        ( 0,  0),  true), \"3.14E0\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     ( 0,  0), false), \"3.14e0\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    (-9, -5),  true), \"+3.14E0\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, ( 5,  9), false), \"+3.14e0\");\n+    assert_eq!(to_string(f, -3.14, Minus,        ( 0,  0),  true), \"-3.14E0\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     ( 0,  0), false), \"-3.14e0\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    (-9, -5),  true), \"-3.14E0\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, ( 5,  9), false), \"-3.14e0\");\n+\n+    assert_eq!(to_string(f,  0.1, Minus,        (-4, 16), false), \"0.1\");\n+    assert_eq!(to_string(f,  0.1, MinusRaw,     (-4, 16), false), \"0.1\");\n+    assert_eq!(to_string(f,  0.1, MinusPlus,    (-4, 16), false), \"+0.1\");\n+    assert_eq!(to_string(f,  0.1, MinusPlusRaw, (-4, 16), false), \"+0.1\");\n+    assert_eq!(to_string(f, -0.1, Minus,        (-4, 16), false), \"-0.1\");\n+    assert_eq!(to_string(f, -0.1, MinusRaw,     (-4, 16), false), \"-0.1\");\n+    assert_eq!(to_string(f, -0.1, MinusPlus,    (-4, 16), false), \"-0.1\");\n+    assert_eq!(to_string(f, -0.1, MinusPlusRaw, (-4, 16), false), \"-0.1\");\n+    assert_eq!(to_string(f,  0.1, Minus,        ( 0,  0),  true), \"1E-1\");\n+    assert_eq!(to_string(f,  0.1, MinusRaw,     ( 0,  0), false), \"1e-1\");\n+    assert_eq!(to_string(f,  0.1, MinusPlus,    (-9, -5),  true), \"+1E-1\");\n+    assert_eq!(to_string(f,  0.1, MinusPlusRaw, ( 5,  9), false), \"+1e-1\");\n+    assert_eq!(to_string(f, -0.1, Minus,        ( 0,  0),  true), \"-1E-1\");\n+    assert_eq!(to_string(f, -0.1, MinusRaw,     ( 0,  0), false), \"-1e-1\");\n+    assert_eq!(to_string(f, -0.1, MinusPlus,    (-9, -5),  true), \"-1E-1\");\n+    assert_eq!(to_string(f, -0.1, MinusPlusRaw, ( 5,  9), false), \"-1e-1\");\n+\n+    assert_eq!(to_string(f, 7.5e-11, Minus, ( -4, 16), false), \"7.5e-11\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, (-11, 10), false), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, (-10, 11), false), \"7.5e-11\");\n+\n+    assert_eq!(to_string(f, 1.9971e20, Minus, ( -4, 16), false), \"1.9971e20\");\n+    assert_eq!(to_string(f, 1.9971e20, Minus, (-20, 21), false), \"199710000000000000000\");\n+    assert_eq!(to_string(f, 1.9971e20, Minus, (-21, 20), false), \"1.9971e20\");\n+\n+    // the true value of 1.0e23f64 is less than 10^23, but that shouldn't matter here\n+    assert_eq!(to_string(f, 1.0e23, Minus, (22, 23), false), \"1e23\");\n+    assert_eq!(to_string(f, 1.0e23, Minus, (23, 24), false), \"100000000000000000000000\");\n+    assert_eq!(to_string(f, 1.0e23, Minus, (24, 25), false), \"1e23\");\n+\n+    assert_eq!(to_string(f, f32::MAX, Minus, ( -4, 16), false), \"3.4028235e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, (-39, 38), false), \"3.4028235e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, (-38, 39), false), format!(\"34028235{:0>31}\", \"\"));\n+\n+    let minf32 = f32::ldexp(1.0, -149);\n+    assert_eq!(to_string(f, minf32, Minus, ( -4, 16), false), \"1e-45\");\n+    assert_eq!(to_string(f, minf32, Minus, (-44, 45), false), \"1e-45\");\n+    assert_eq!(to_string(f, minf32, Minus, (-45, 44), false), format!(\"0.{:0>44}1\", \"\"));\n+\n+    assert_eq!(to_string(f, f64::MAX, Minus, (  -4,  16), false),\n+               \"1.7976931348623157e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus, (-308, 309), false),\n+               format!(\"17976931348623157{:0>292}\", \"\"));\n+    assert_eq!(to_string(f, f64::MAX, Minus, (-309, 308), false),\n+               \"1.7976931348623157e308\");\n+\n+    let minf64 = f64::ldexp(1.0, -1074);\n+    assert_eq!(to_string(f, minf64, Minus, (  -4,  16), false), \"5e-324\");\n+    assert_eq!(to_string(f, minf64, Minus, (-324, 323), false), format!(\"0.{:0>323}5\", \"\"));\n+    assert_eq!(to_string(f, minf64, Minus, (-323, 324), false), \"5e-324\");\n+\n+    assert_eq!(to_string(f, 1.1, Minus, (i16::MIN, i16::MAX), false), \"1.1\");\n+}\n+\n+pub fn to_exact_exp_str_test<F>(mut f_: F)\n+        where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    use core::num::flt2dec::Sign::*;\n+\n+    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, ndigits: usize, upper: bool) -> String\n+            where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+        to_string_with_parts(|buf, parts| to_exact_exp_str(|d,b,l| f(d,b,l), v, sign,\n+                                                           ndigits, upper, buf, parts))\n+    }\n+\n+    let f = &mut f_;\n+\n+    assert_eq!(to_string(f,  0.0, Minus,        1,  true), \"0E0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     1, false), \"0e0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    1,  true), \"+0E0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, 1, false), \"+0e0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        1,  true), \"0E0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     1, false), \"-0e0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    1,  true), \"+0E0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 1, false), \"-0e0\");\n+    assert_eq!(to_string(f,  0.0, Minus,        2,  true), \"0.0E0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     2, false), \"0.0e0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    2,  true), \"+0.0E0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, 2, false), \"+0.0e0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        8,  true), \"0.0000000E0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     8, false), \"-0.0000000e0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    8,  true), \"+0.0000000E0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8, false), \"-0.0000000e0\");\n+\n+    assert_eq!(to_string(f,  1.0/0.0, Minus,         1, false), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,      1,  true), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlus,     1, false), \"+inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw,  1,  true), \"+inf\");\n+    assert_eq!(to_string(f,  0.0/0.0, Minus,         8, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,      8,  true), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,     8, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw,  8,  true), \"NaN\");\n+    assert_eq!(to_string(f, -1.0/0.0, Minus,        64, false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,     64,  true), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlus,    64, false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, 64,  true), \"-inf\");\n+\n+    assert_eq!(to_string(f,  3.14, Minus,        1,  true), \"3E0\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     1, false), \"3e0\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    1,  true), \"+3E0\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, 1, false), \"+3e0\");\n+    assert_eq!(to_string(f, -3.14, Minus,        2,  true), \"-3.1E0\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     2, false), \"-3.1e0\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    2,  true), \"-3.1E0\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 2, false), \"-3.1e0\");\n+    assert_eq!(to_string(f,  3.14, Minus,        3,  true), \"3.14E0\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     3, false), \"3.14e0\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    3,  true), \"+3.14E0\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, 3, false), \"+3.14e0\");\n+    assert_eq!(to_string(f, -3.14, Minus,        4,  true), \"-3.140E0\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     4, false), \"-3.140e0\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    4,  true), \"-3.140E0\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 4, false), \"-3.140e0\");\n+\n+    assert_eq!(to_string(f,  0.195, Minus,        1, false), \"2e-1\");\n+    assert_eq!(to_string(f,  0.195, MinusRaw,     1,  true), \"2E-1\");\n+    assert_eq!(to_string(f,  0.195, MinusPlus,    1, false), \"+2e-1\");\n+    assert_eq!(to_string(f,  0.195, MinusPlusRaw, 1,  true), \"+2E-1\");\n+    assert_eq!(to_string(f, -0.195, Minus,        2, false), \"-2.0e-1\");\n+    assert_eq!(to_string(f, -0.195, MinusRaw,     2,  true), \"-2.0E-1\");\n+    assert_eq!(to_string(f, -0.195, MinusPlus,    2, false), \"-2.0e-1\");\n+    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 2,  true), \"-2.0E-1\");\n+    assert_eq!(to_string(f,  0.195, Minus,        3, false), \"1.95e-1\");\n+    assert_eq!(to_string(f,  0.195, MinusRaw,     3,  true), \"1.95E-1\");\n+    assert_eq!(to_string(f,  0.195, MinusPlus,    3, false), \"+1.95e-1\");\n+    assert_eq!(to_string(f,  0.195, MinusPlusRaw, 3,  true), \"+1.95E-1\");\n+    assert_eq!(to_string(f, -0.195, Minus,        4, false), \"-1.950e-1\");\n+    assert_eq!(to_string(f, -0.195, MinusRaw,     4,  true), \"-1.950E-1\");\n+    assert_eq!(to_string(f, -0.195, MinusPlus,    4, false), \"-1.950e-1\");\n+    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 4,  true), \"-1.950E-1\");\n+\n+    assert_eq!(to_string(f, 9.5, Minus,  1, false), \"1e1\");\n+    assert_eq!(to_string(f, 9.5, Minus,  2, false), \"9.5e0\");\n+    assert_eq!(to_string(f, 9.5, Minus,  3, false), \"9.50e0\");\n+    assert_eq!(to_string(f, 9.5, Minus, 30, false), \"9.50000000000000000000000000000e0\");\n+\n+    assert_eq!(to_string(f, 1.0e25, Minus,  1, false), \"1e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus,  2, false), \"1.0e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 15, false), \"1.00000000000000e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 16, false), \"1.000000000000000e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 17, false), \"1.0000000000000001e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 18, false), \"1.00000000000000009e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 19, false), \"1.000000000000000091e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 20, false), \"1.0000000000000000906e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 21, false), \"1.00000000000000009060e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 22, false), \"1.000000000000000090597e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 23, false), \"1.0000000000000000905970e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 24, false), \"1.00000000000000009059697e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 25, false), \"1.000000000000000090596966e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 26, false), \"1.0000000000000000905969664e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 27, false), \"1.00000000000000009059696640e25\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 30, false), \"1.00000000000000009059696640000e25\");\n+\n+    assert_eq!(to_string(f, 1.0e-6, Minus,  1, false), \"1e-6\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus,  2, false), \"1.0e-6\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 16, false), \"1.000000000000000e-6\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 17, false), \"9.9999999999999995e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 18, false), \"9.99999999999999955e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 19, false), \"9.999999999999999547e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 20, false), \"9.9999999999999995475e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 30, false), \"9.99999999999999954748111825886e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 40, false),\n+               \"9.999999999999999547481118258862586856139e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 50, false),\n+               \"9.9999999999999995474811182588625868561393872369081e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 60, false),\n+               \"9.99999999999999954748111825886258685613938723690807819366455e-7\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 70, false),\n+               \"9.999999999999999547481118258862586856139387236908078193664550781250000e-7\");\n+\n+    assert_eq!(to_string(f, f32::MAX, Minus,  1, false), \"3e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus,  2, false), \"3.4e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus,  4, false), \"3.403e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus,  8, false), \"3.4028235e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 16, false), \"3.402823466385289e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 32, false), \"3.4028234663852885981170418348452e38\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 64, false),\n+               \"3.402823466385288598117041834845169254400000000000000000000000000e38\");\n+\n+    let minf32 = f32::ldexp(1.0, -149);\n+    assert_eq!(to_string(f, minf32, Minus,   1, false), \"1e-45\");\n+    assert_eq!(to_string(f, minf32, Minus,   2, false), \"1.4e-45\");\n+    assert_eq!(to_string(f, minf32, Minus,   4, false), \"1.401e-45\");\n+    assert_eq!(to_string(f, minf32, Minus,   8, false), \"1.4012985e-45\");\n+    assert_eq!(to_string(f, minf32, Minus,  16, false), \"1.401298464324817e-45\");\n+    assert_eq!(to_string(f, minf32, Minus,  32, false), \"1.4012984643248170709237295832899e-45\");\n+    assert_eq!(to_string(f, minf32, Minus,  64, false),\n+               \"1.401298464324817070923729583289916131280261941876515771757068284e-45\");\n+    assert_eq!(to_string(f, minf32, Minus, 128, false),\n+               \"1.401298464324817070923729583289916131280261941876515771757068283\\\n+                 8897910826858606014866381883621215820312500000000000000000000000e-45\");\n+\n+    assert_eq!(to_string(f, f64::MAX, Minus,   1, false), \"2e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus,   2, false), \"1.8e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus,   4, false), \"1.798e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus,   8, false), \"1.7976931e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus,  16, false), \"1.797693134862316e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus,  32, false), \"1.7976931348623157081452742373170e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus,  64, false),\n+               \"1.797693134862315708145274237317043567980705675258449965989174768e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus, 128, false),\n+               \"1.797693134862315708145274237317043567980705675258449965989174768\\\n+                 0315726078002853876058955863276687817154045895351438246423432133e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus, 256, false),\n+               \"1.797693134862315708145274237317043567980705675258449965989174768\\\n+                 0315726078002853876058955863276687817154045895351438246423432132\\\n+                 6889464182768467546703537516986049910576551282076245490090389328\\\n+                 9440758685084551339423045832369032229481658085593321233482747978e308\");\n+    assert_eq!(to_string(f, f64::MAX, Minus, 512, false),\n+               \"1.797693134862315708145274237317043567980705675258449965989174768\\\n+                 0315726078002853876058955863276687817154045895351438246423432132\\\n+                 6889464182768467546703537516986049910576551282076245490090389328\\\n+                 9440758685084551339423045832369032229481658085593321233482747978\\\n+                 2620414472316873817718091929988125040402618412485836800000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000e308\");\n+\n+    // okay, this is becoming tough. fortunately for us, this is almost the worst case.\n+    let minf64 = f64::ldexp(1.0, -1074);\n+    assert_eq!(to_string(f, minf64, Minus,    1, false), \"5e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,    2, false), \"4.9e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,    4, false), \"4.941e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,    8, false), \"4.9406565e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,   16, false), \"4.940656458412465e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,   32, false), \"4.9406564584124654417656879286822e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,   64, false),\n+               \"4.940656458412465441765687928682213723650598026143247644255856825e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,  128, false),\n+               \"4.940656458412465441765687928682213723650598026143247644255856825\\\n+                 0067550727020875186529983636163599237979656469544571773092665671e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,  256, false),\n+               \"4.940656458412465441765687928682213723650598026143247644255856825\\\n+                 0067550727020875186529983636163599237979656469544571773092665671\\\n+                 0355939796398774796010781878126300713190311404527845817167848982\\\n+                 1036887186360569987307230500063874091535649843873124733972731696e-324\");\n+    assert_eq!(to_string(f, minf64, Minus,  512, false),\n+               \"4.940656458412465441765687928682213723650598026143247644255856825\\\n+                 0067550727020875186529983636163599237979656469544571773092665671\\\n+                 0355939796398774796010781878126300713190311404527845817167848982\\\n+                 1036887186360569987307230500063874091535649843873124733972731696\\\n+                 1514003171538539807412623856559117102665855668676818703956031062\\\n+                 4931945271591492455329305456544401127480129709999541931989409080\\\n+                 4165633245247571478690147267801593552386115501348035264934720193\\\n+                 7902681071074917033322268447533357208324319360923828934583680601e-324\");\n+    assert_eq!(to_string(f, minf64, Minus, 1024, false),\n+               \"4.940656458412465441765687928682213723650598026143247644255856825\\\n+                 0067550727020875186529983636163599237979656469544571773092665671\\\n+                 0355939796398774796010781878126300713190311404527845817167848982\\\n+                 1036887186360569987307230500063874091535649843873124733972731696\\\n+                 1514003171538539807412623856559117102665855668676818703956031062\\\n+                 4931945271591492455329305456544401127480129709999541931989409080\\\n+                 4165633245247571478690147267801593552386115501348035264934720193\\\n+                 7902681071074917033322268447533357208324319360923828934583680601\\\n+                 0601150616980975307834227731832924790498252473077637592724787465\\\n+                 6084778203734469699533647017972677717585125660551199131504891101\\\n+                 4510378627381672509558373897335989936648099411642057026370902792\\\n+                 4276754456522908753868250641971826553344726562500000000000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000\\\n+                 0000000000000000000000000000000000000000000000000000000000000000e-324\");\n+\n+    // very large output\n+    assert_eq!(to_string(f, 0.0,     Minus, 80000, false), format!(\"0.{:0>79999}e0\", \"\"));\n+    assert_eq!(to_string(f, 1.0e1,   Minus, 80000, false), format!(\"1.{:0>79999}e1\", \"\"));\n+    assert_eq!(to_string(f, 1.0e0,   Minus, 80000, false), format!(\"1.{:0>79999}e0\", \"\"));\n+    assert_eq!(to_string(f, 1.0e-1,  Minus, 80000, false),\n+               format!(\"1.000000000000000055511151231257827021181583404541015625{:0>79945}\\\n+                        e-1\", \"\"));\n+    assert_eq!(to_string(f, 1.0e-20, Minus, 80000, false),\n+               format!(\"9.999999999999999451532714542095716517295037027873924471077157760\\\n+                         66783064379706047475337982177734375{:0>79901}e-21\", \"\"));\n+}\n+\n+pub fn to_exact_fixed_str_test<F>(mut f_: F)\n+        where F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+    use core::num::flt2dec::Sign::*;\n+\n+    fn to_string<T, F>(f: &mut F, v: T, sign: Sign, frac_digits: usize, upper: bool) -> String\n+            where T: DecodableFloat, F: FnMut(&Decoded, &mut [u8], i16) -> (usize, i16) {\n+        to_string_with_parts(|buf, parts| to_exact_fixed_str(|d,b,l| f(d,b,l), v, sign,\n+                                                             frac_digits, upper, buf, parts))\n+    }\n+\n+    let f = &mut f_;\n+\n+    assert_eq!(to_string(f,  0.0, Minus,        0, false), \"0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     0, false), \"0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    0, false), \"+0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, 0, false), \"+0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        0, false), \"0\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     0, false), \"-0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    0, false), \"+0\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 0, false), \"-0\");\n+    assert_eq!(to_string(f,  0.0, Minus,        1,  true), \"0.0\");\n+    assert_eq!(to_string(f,  0.0, MinusRaw,     1,  true), \"0.0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlus,    1,  true), \"+0.0\");\n+    assert_eq!(to_string(f,  0.0, MinusPlusRaw, 1,  true), \"+0.0\");\n+    assert_eq!(to_string(f, -0.0, Minus,        8,  true), \"0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusRaw,     8,  true), \"-0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlus,    8,  true), \"+0.00000000\");\n+    assert_eq!(to_string(f, -0.0, MinusPlusRaw, 8,  true), \"-0.00000000\");\n+\n+    assert_eq!(to_string(f,  1.0/0.0, Minus,         0, false), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusRaw,      1,  true), \"inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlus,     8, false), \"+inf\");\n+    assert_eq!(to_string(f,  1.0/0.0, MinusPlusRaw, 64,  true), \"+inf\");\n+    assert_eq!(to_string(f,  0.0/0.0, Minus,         0, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusRaw,      1,  true), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlus,     8, false), \"NaN\");\n+    assert_eq!(to_string(f,  0.0/0.0, MinusPlusRaw, 64,  true), \"NaN\");\n+    assert_eq!(to_string(f, -1.0/0.0, Minus,         0, false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusRaw,      1,  true), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlus,     8, false), \"-inf\");\n+    assert_eq!(to_string(f, -1.0/0.0, MinusPlusRaw, 64,  true), \"-inf\");\n+\n+    assert_eq!(to_string(f,  3.14, Minus,        0, false), \"3\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     0, false), \"3\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    0, false), \"+3\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, 0, false), \"+3\");\n+    assert_eq!(to_string(f, -3.14, Minus,        0, false), \"-3\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     0, false), \"-3\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    0, false), \"-3\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 0, false), \"-3\");\n+    assert_eq!(to_string(f,  3.14, Minus,        1,  true), \"3.1\");\n+    assert_eq!(to_string(f,  3.14, MinusRaw,     2,  true), \"3.14\");\n+    assert_eq!(to_string(f,  3.14, MinusPlus,    3,  true), \"+3.140\");\n+    assert_eq!(to_string(f,  3.14, MinusPlusRaw, 4,  true), \"+3.1400\");\n+    assert_eq!(to_string(f, -3.14, Minus,        8,  true), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusRaw,     8,  true), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlus,    8,  true), \"-3.14000000\");\n+    assert_eq!(to_string(f, -3.14, MinusPlusRaw, 8,  true), \"-3.14000000\");\n+\n+    assert_eq!(to_string(f,  0.195, Minus,        0, false), \"0\");\n+    assert_eq!(to_string(f,  0.195, MinusRaw,     0, false), \"0\");\n+    assert_eq!(to_string(f,  0.195, MinusPlus,    0, false), \"+0\");\n+    assert_eq!(to_string(f,  0.195, MinusPlusRaw, 0, false), \"+0\");\n+    assert_eq!(to_string(f, -0.195, Minus,        0, false), \"-0\");\n+    assert_eq!(to_string(f, -0.195, MinusRaw,     0, false), \"-0\");\n+    assert_eq!(to_string(f, -0.195, MinusPlus,    0, false), \"-0\");\n+    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 0, false), \"-0\");\n+    assert_eq!(to_string(f,  0.195, Minus,        1,  true), \"0.2\");\n+    assert_eq!(to_string(f,  0.195, MinusRaw,     2,  true), \"0.20\");\n+    assert_eq!(to_string(f,  0.195, MinusPlus,    3,  true), \"+0.195\");\n+    assert_eq!(to_string(f,  0.195, MinusPlusRaw, 4,  true), \"+0.1950\");\n+    assert_eq!(to_string(f, -0.195, Minus,        5,  true), \"-0.19500\");\n+    assert_eq!(to_string(f, -0.195, MinusRaw,     6,  true), \"-0.195000\");\n+    assert_eq!(to_string(f, -0.195, MinusPlus,    7,  true), \"-0.1950000\");\n+    assert_eq!(to_string(f, -0.195, MinusPlusRaw, 8,  true), \"-0.19500000\");\n+\n+    assert_eq!(to_string(f, 999.5, Minus,  0, false), \"1000\");\n+    assert_eq!(to_string(f, 999.5, Minus,  1, false), \"999.5\");\n+    assert_eq!(to_string(f, 999.5, Minus,  2, false), \"999.50\");\n+    assert_eq!(to_string(f, 999.5, Minus,  3, false), \"999.500\");\n+    assert_eq!(to_string(f, 999.5, Minus, 30, false), \"999.500000000000000000000000000000\");\n+\n+    assert_eq!(to_string(f, 0.5, Minus, 0, false), \"1\");\n+    assert_eq!(to_string(f, 0.5, Minus, 1, false), \"0.5\");\n+    assert_eq!(to_string(f, 0.5, Minus, 2, false), \"0.50\");\n+    assert_eq!(to_string(f, 0.5, Minus, 3, false), \"0.500\");\n+\n+    assert_eq!(to_string(f, 0.95, Minus,  0, false), \"1\");\n+    assert_eq!(to_string(f, 0.95, Minus,  1, false), \"0.9\"); // because it really is less than 0.95\n+    assert_eq!(to_string(f, 0.95, Minus,  2, false), \"0.95\");\n+    assert_eq!(to_string(f, 0.95, Minus,  3, false), \"0.950\");\n+    assert_eq!(to_string(f, 0.95, Minus, 10, false), \"0.9500000000\");\n+    assert_eq!(to_string(f, 0.95, Minus, 30, false), \"0.949999999999999955591079014994\");\n+\n+    assert_eq!(to_string(f, 0.095, Minus,  0, false), \"0\");\n+    assert_eq!(to_string(f, 0.095, Minus,  1, false), \"0.1\");\n+    assert_eq!(to_string(f, 0.095, Minus,  2, false), \"0.10\");\n+    assert_eq!(to_string(f, 0.095, Minus,  3, false), \"0.095\");\n+    assert_eq!(to_string(f, 0.095, Minus,  4, false), \"0.0950\");\n+    assert_eq!(to_string(f, 0.095, Minus, 10, false), \"0.0950000000\");\n+    assert_eq!(to_string(f, 0.095, Minus, 30, false), \"0.095000000000000001110223024625\");\n+\n+    assert_eq!(to_string(f, 0.0095, Minus,  0, false), \"0\");\n+    assert_eq!(to_string(f, 0.0095, Minus,  1, false), \"0.0\");\n+    assert_eq!(to_string(f, 0.0095, Minus,  2, false), \"0.01\");\n+    assert_eq!(to_string(f, 0.0095, Minus,  3, false), \"0.009\"); // really is less than 0.0095\n+    assert_eq!(to_string(f, 0.0095, Minus,  4, false), \"0.0095\");\n+    assert_eq!(to_string(f, 0.0095, Minus,  5, false), \"0.00950\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 10, false), \"0.0095000000\");\n+    assert_eq!(to_string(f, 0.0095, Minus, 30, false), \"0.009499999999999999764077607267\");\n+\n+    assert_eq!(to_string(f, 7.5e-11, Minus,  0, false), \"0\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus,  3, false), \"0.000\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 10, false), \"0.0000000001\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 11, false), \"0.00000000007\"); // ditto\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 12, false), \"0.000000000075\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 13, false), \"0.0000000000750\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 20, false), \"0.00000000007500000000\");\n+    assert_eq!(to_string(f, 7.5e-11, Minus, 30, false), \"0.000000000074999999999999999501\");\n+\n+    assert_eq!(to_string(f, 1.0e25, Minus, 0, false), \"10000000000000000905969664\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 1, false), \"10000000000000000905969664.0\");\n+    assert_eq!(to_string(f, 1.0e25, Minus, 3, false), \"10000000000000000905969664.000\");\n+\n+    assert_eq!(to_string(f, 1.0e-6, Minus,  0, false), \"0\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus,  3, false), \"0.000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus,  6, false), \"0.000001\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus,  9, false), \"0.000001000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 12, false), \"0.000001000000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 22, false), \"0.0000010000000000000000\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 23, false), \"0.00000099999999999999995\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 24, false), \"0.000000999999999999999955\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 25, false), \"0.0000009999999999999999547\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 35, false), \"0.00000099999999999999995474811182589\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 45, false),\n+               \"0.000000999999999999999954748111825886258685614\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 55, false),\n+               \"0.0000009999999999999999547481118258862586856139387236908\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 65, false),\n+               \"0.00000099999999999999995474811182588625868561393872369080781936646\");\n+    assert_eq!(to_string(f, 1.0e-6, Minus, 75, false),\n+               \"0.000000999999999999999954748111825886258685613938723690807819366455078125000\");\n+\n+    assert_eq!(to_string(f, f32::MAX, Minus, 0, false),\n+               \"340282346638528859811704183484516925440\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 1, false),\n+               \"340282346638528859811704183484516925440.0\");\n+    assert_eq!(to_string(f, f32::MAX, Minus, 2, false),\n+               \"340282346638528859811704183484516925440.00\");\n+\n+    let minf32 = f32::ldexp(1.0, -149);\n+    assert_eq!(to_string(f, minf32, Minus,   0, false), \"0\");\n+    assert_eq!(to_string(f, minf32, Minus,   1, false), \"0.0\");\n+    assert_eq!(to_string(f, minf32, Minus,   2, false), \"0.00\");\n+    assert_eq!(to_string(f, minf32, Minus,   4, false), \"0.0000\");\n+    assert_eq!(to_string(f, minf32, Minus,   8, false), \"0.00000000\");\n+    assert_eq!(to_string(f, minf32, Minus,  16, false), \"0.0000000000000000\");\n+    assert_eq!(to_string(f, minf32, Minus,  32, false), \"0.00000000000000000000000000000000\");\n+    assert_eq!(to_string(f, minf32, Minus,  64, false),\n+               \"0.0000000000000000000000000000000000000000000014012984643248170709\");\n+    assert_eq!(to_string(f, minf32, Minus, 128, false),\n+               \"0.0000000000000000000000000000000000000000000014012984643248170709\\\n+                  2372958328991613128026194187651577175706828388979108268586060149\");\n+    assert_eq!(to_string(f, minf32, Minus, 256, false),\n+               \"0.0000000000000000000000000000000000000000000014012984643248170709\\\n+                  2372958328991613128026194187651577175706828388979108268586060148\\\n+                  6638188362121582031250000000000000000000000000000000000000000000\\\n+                  0000000000000000000000000000000000000000000000000000000000000000\");\n+\n+    assert_eq!(to_string(f, f64::MAX, Minus, 0, false),\n+               \"1797693134862315708145274237317043567980705675258449965989174768\\\n+                0315726078002853876058955863276687817154045895351438246423432132\\\n+                6889464182768467546703537516986049910576551282076245490090389328\\\n+                9440758685084551339423045832369032229481658085593321233482747978\\\n+                26204144723168738177180919299881250404026184124858368\");\n+    assert_eq!(to_string(f, f64::MAX, Minus, 10, false),\n+               \"1797693134862315708145274237317043567980705675258449965989174768\\\n+                0315726078002853876058955863276687817154045895351438246423432132\\\n+                6889464182768467546703537516986049910576551282076245490090389328\\\n+                9440758685084551339423045832369032229481658085593321233482747978\\\n+                26204144723168738177180919299881250404026184124858368.0000000000\");\n+\n+    let minf64 = f64::ldexp(1.0, -1074);\n+    assert_eq!(to_string(f, minf64, Minus, 0, false), \"0\");\n+    assert_eq!(to_string(f, minf64, Minus, 1, false), \"0.0\");\n+    assert_eq!(to_string(f, minf64, Minus, 10, false), \"0.0000000000\");\n+    assert_eq!(to_string(f, minf64, Minus, 100, false),\n+               \"0.0000000000000000000000000000000000000000000000000000000000000000\\\n+                  000000000000000000000000000000000000\");\n+    assert_eq!(to_string(f, minf64, Minus, 1000, false),\n+               \"0.0000000000000000000000000000000000000000000000000000000000000000\\\n+                  0000000000000000000000000000000000000000000000000000000000000000\\\n+                  0000000000000000000000000000000000000000000000000000000000000000\\\n+                  0000000000000000000000000000000000000000000000000000000000000000\\\n+                  0000000000000000000000000000000000000000000000000000000000000000\\\n+                  0004940656458412465441765687928682213723650598026143247644255856\\\n+                  8250067550727020875186529983636163599237979656469544571773092665\\\n+                  6710355939796398774796010781878126300713190311404527845817167848\\\n+                  9821036887186360569987307230500063874091535649843873124733972731\\\n+                  6961514003171538539807412623856559117102665855668676818703956031\\\n+                  0624931945271591492455329305456544401127480129709999541931989409\\\n+                  0804165633245247571478690147267801593552386115501348035264934720\\\n+                  1937902681071074917033322268447533357208324319360923828934583680\\\n+                  6010601150616980975307834227731832924790498252473077637592724787\\\n+                  4656084778203734469699533647017972677717585125660551199131504891\\\n+                  1014510378627381672509558373897335989937\");\n+\n+    // very large output\n+    assert_eq!(to_string(f, 0.0,     Minus, 80000, false), format!(\"0.{:0>80000}\", \"\"));\n+    assert_eq!(to_string(f, 1.0e1,   Minus, 80000, false), format!(\"10.{:0>80000}\", \"\"));\n+    assert_eq!(to_string(f, 1.0e0,   Minus, 80000, false), format!(\"1.{:0>80000}\", \"\"));\n+    assert_eq!(to_string(f, 1.0e-1,  Minus, 80000, false),\n+               format!(\"0.1000000000000000055511151231257827021181583404541015625{:0>79945}\", \"\"));\n+    assert_eq!(to_string(f, 1.0e-20, Minus, 80000, false),\n+               format!(\"0.0000000000000000000099999999999999994515327145420957165172950370\\\n+                          2787392447107715776066783064379706047475337982177734375{:0>79881}\", \"\"));\n+}\n+"}, {"sha": "f2397f6b48037e0311bfb5a257db741b7f1087d9", "filename": "src/libcoretest/num/flt2dec/strategy/dragon.rs", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::prelude::v1::*;\n+use std::{i16, f64};\n+use super::super::*;\n+use core::num::flt2dec::*;\n+use core::num::flt2dec::bignum::Big32x36 as Big;\n+use core::num::flt2dec::strategy::dragon::*;\n+\n+#[test]\n+fn test_mul_pow10() {\n+    let mut prevpow10 = Big::from_small(1);\n+    for i in 1..340 {\n+        let mut curpow10 = Big::from_small(1);\n+        mul_pow10(&mut curpow10, i);\n+        assert_eq!(curpow10, *prevpow10.clone().mul_small(10));\n+        prevpow10 = curpow10;\n+    }\n+}\n+\n+#[test]\n+fn shortest_sanity_test() {\n+    f64_shortest_sanity_test(format_shortest);\n+    f32_shortest_sanity_test(format_shortest);\n+    more_shortest_sanity_test(format_shortest);\n+}\n+\n+#[test]\n+fn exact_sanity_test() {\n+    f64_exact_sanity_test(format_exact);\n+    f32_exact_sanity_test(format_exact);\n+}\n+\n+#[bench]\n+fn bench_small_shortest(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; MAX_SIG_DIGITS];\n+    b.iter(|| format_shortest(&decoded, &mut buf));\n+}\n+\n+#[bench]\n+fn bench_big_shortest(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; MAX_SIG_DIGITS];\n+    b.iter(|| format_shortest(&decoded, &mut buf));\n+}\n+\n+#[bench]\n+fn bench_small_exact_3(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 3];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_3(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 3];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_small_exact_12(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 12];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_12(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 12];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_small_exact_inf(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 1024];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_inf(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 1024];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[test]\n+fn test_to_shortest_str() {\n+    to_shortest_str_test(format_shortest);\n+}\n+\n+#[test]\n+fn test_to_shortest_exp_str() {\n+    to_shortest_exp_str_test(format_shortest);\n+}\n+\n+#[test]\n+fn test_to_exact_exp_str() {\n+    to_exact_exp_str_test(format_exact);\n+}\n+\n+#[test]\n+fn test_to_exact_fixed_str() {\n+    to_exact_fixed_str_test(format_exact);\n+}\n+"}, {"sha": "e5b8a9dcc38fcc9e8b085821dd2ba87d56e55323", "filename": "src/libcoretest/num/flt2dec/strategy/grisu.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{i16, f64};\n+use super::super::*;\n+use core::num::flt2dec::*;\n+use core::num::flt2dec::strategy::grisu::*;\n+\n+#[test]\n+fn test_cached_power() {\n+    assert_eq!(CACHED_POW10.first().unwrap().1, CACHED_POW10_FIRST_E);\n+    assert_eq!(CACHED_POW10.last().unwrap().1, CACHED_POW10_LAST_E);\n+\n+    for e in -1137..961 { // full range for f64\n+        let low = ALPHA - e - 64;\n+        let high = GAMMA - e - 64;\n+        let (_k, cached) = cached_power(low, high);\n+        assert!(low <= cached.e && cached.e <= high,\n+                \"cached_power({}, {}) = {:?} is incorrect\", low, high, cached);\n+    }\n+}\n+\n+#[test]\n+fn test_max_pow10_no_more_than() {\n+    let mut prevtenk = 1;\n+    for k in 1..10 {\n+        let tenk = prevtenk * 10;\n+        assert_eq!(max_pow10_no_more_than(tenk - 1), (k - 1, prevtenk));\n+        assert_eq!(max_pow10_no_more_than(tenk), (k, tenk));\n+        prevtenk = tenk;\n+    }\n+}\n+\n+\n+#[test]\n+fn shortest_sanity_test() {\n+    f64_shortest_sanity_test(format_shortest);\n+    f32_shortest_sanity_test(format_shortest);\n+    more_shortest_sanity_test(format_shortest);\n+}\n+\n+#[test]\n+fn shortest_random_equivalence_test() {\n+    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n+    f64_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 10_000);\n+    f32_random_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS, 10_000);\n+}\n+\n+#[test] #[ignore] // it is too expensive\n+fn shortest_f32_exhaustive_equivalence_test() {\n+    // it is hard to directly test the optimality of the output, but we can at least test if\n+    // two different algorithms agree to each other.\n+    //\n+    // this reports the progress and the number of f32 values returned `None`.\n+    // with `--nocapture` (and plenty of time and appropriate rustc flags), this should print:\n+    // `done, ignored=17643158 passed=2121451881 failed=0`.\n+\n+    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n+    f32_exhaustive_equivalence_test(format_shortest_opt, fallback, MAX_SIG_DIGITS);\n+}\n+\n+#[test] #[ignore] // it is too expensive\n+fn shortest_f64_hard_random_equivalence_test() {\n+    // this again probably has to use appropriate rustc flags.\n+\n+    use core::num::flt2dec::strategy::dragon::format_shortest as fallback;\n+    f64_random_equivalence_test(format_shortest_opt, fallback,\n+                                         MAX_SIG_DIGITS, 100_000_000);\n+}\n+\n+#[test]\n+fn exact_sanity_test() {\n+    f64_exact_sanity_test(format_exact);\n+    f32_exact_sanity_test(format_exact);\n+}\n+\n+#[test]\n+fn exact_f32_random_equivalence_test() {\n+    use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n+    for k in 1..21 {\n+        f32_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n+                                             |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n+    }\n+}\n+\n+#[test]\n+fn exact_f64_random_equivalence_test() {\n+    use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n+    for k in 1..21 {\n+        f64_random_equivalence_test(|d, buf| format_exact_opt(d, buf, i16::MIN),\n+                                             |d, buf| fallback(d, buf, i16::MIN), k, 1_000);\n+    }\n+}\n+\n+#[bench]\n+fn bench_small_shortest(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; MAX_SIG_DIGITS];\n+    b.iter(|| format_shortest(&decoded, &mut buf));\n+}\n+\n+#[bench]\n+fn bench_big_shortest(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; MAX_SIG_DIGITS];\n+    b.iter(|| format_shortest(&decoded, &mut buf));\n+}\n+\n+#[bench]\n+fn bench_small_exact_3(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 3];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_3(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 3];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_small_exact_12(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 12];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_12(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 12];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_small_exact_inf(b: &mut Bencher) {\n+    let decoded = decode_finite(3.141592f64);\n+    let mut buf = [0; 1024];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[bench]\n+fn bench_big_exact_inf(b: &mut Bencher) {\n+    let decoded = decode_finite(f64::MAX);\n+    let mut buf = [0; 1024];\n+    b.iter(|| format_exact(&decoded, &mut buf, i16::MIN));\n+}\n+\n+#[test]\n+fn test_to_shortest_str() {\n+    to_shortest_str_test(format_shortest);\n+}\n+\n+#[test]\n+fn test_to_shortest_exp_str() {\n+    to_shortest_exp_str_test(format_shortest);\n+}\n+\n+#[test]\n+fn test_to_exact_exp_str() {\n+    to_exact_exp_str_test(format_exact);\n+}\n+\n+#[test]\n+fn test_to_exact_fixed_str() {\n+    to_exact_fixed_str_test(format_exact);\n+}\n+"}, {"sha": "998f4b21ece7f8f8345ccac81ffcfe8e4fadbba2", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -29,6 +29,8 @@ mod u16;\n mod u32;\n mod u64;\n \n+mod flt2dec;\n+\n /// Helper function for testing numeric operations\n pub fn test_num<T>(ten: T, two: T) where\n     T: PartialEq"}, {"sha": "5a1166aeb5085e99debd69982c1af9ce4980e5f9", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -34,55 +34,6 @@ fn binary_search_not_found() {\n     assert!(b.binary_search_by(|v| v.cmp(&9)) == Err(6));\n }\n \n-#[test]\n-fn iterator_to_slice() {\n-    macro_rules! test {\n-        ($data: expr) => {{\n-            let data: &mut [_] = &mut $data;\n-            let other_data: &mut [_] = &mut $data;\n-\n-            {\n-                let mut iter = data.iter();\n-                assert_eq!(&iter[..], &other_data[..]);\n-\n-                iter.next();\n-                assert_eq!(&iter[..], &other_data[1..]);\n-\n-                iter.next_back();\n-                assert_eq!(&iter[..], &other_data[1..2]);\n-\n-                let s = iter.as_slice();\n-                iter.next();\n-                assert_eq!(s, &other_data[1..2]);\n-            }\n-            {\n-                let mut iter = data.iter_mut();\n-                assert_eq!(&iter[..], &other_data[..]);\n-                // mutability:\n-                assert!(&mut iter[..] == other_data);\n-\n-                iter.next();\n-                assert_eq!(&iter[..], &other_data[1..]);\n-                assert!(&mut iter[..] == &mut other_data[1..]);\n-\n-                iter.next_back();\n-\n-                assert_eq!(&iter[..], &other_data[1..2]);\n-                assert!(&mut iter[..] == &mut other_data[1..2]);\n-\n-                let s = iter.into_slice();\n-                assert!(s == &mut other_data[1..2]);\n-            }\n-        }}\n-    }\n-\n-    // try types of a variety of sizes\n-    test!([(1u64, 1u64, 1u8), (2, 2, 2), (3, 3, 3)]);\n-    test!([1u64,2,3]);\n-    test!([1u8,2,3]);\n-    test!([(),(),()]);\n-}\n-\n #[test]\n fn test_iterator_nth() {\n     let v: &[_] = &[0, 1, 2, 3, 4];"}, {"sha": "55934da00a37cde66ef6327a241b688ac9a6017d", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 70, "deletions": 134, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -12,7 +12,8 @@\n #![cfg_attr(stage0, feature(custom_attribute))]\n #![crate_name = \"libc\"]\n #![crate_type = \"rlib\"]\n-#![cfg_attr(not(feature = \"cargo-build\"), unstable(feature = \"libc\"))]\n+#![cfg_attr(not(feature = \"cargo-build\"), unstable(feature = \"libc\",\n+                                                   reason = \"use `libc` from crates.io\"))]\n #![cfg_attr(not(feature = \"cargo-build\"), feature(staged_api, core, no_std))]\n #![cfg_attr(not(feature = \"cargo-build\"), staged_api)]\n #![cfg_attr(not(feature = \"cargo-build\"), no_std)]\n@@ -3624,6 +3625,30 @@ pub mod consts {\n             pub const IPV6_DROP_MEMBERSHIP: c_int = 21;\n \n             pub const TCP_NODELAY: c_int = 1;\n+            pub const TCP_MAXSEG: c_int = 2;\n+            pub const TCP_CORK: c_int = 3;\n+            pub const TCP_KEEPIDLE: c_int = 4;\n+            pub const TCP_KEEPINTVL: c_int = 5;\n+            pub const TCP_KEEPCNT: c_int = 6;\n+            pub const TCP_SYNCNT: c_int = 7;\n+            pub const TCP_LINGER2: c_int = 8;\n+            pub const TCP_DEFER_ACCEPT: c_int = 9;\n+            pub const TCP_WINDOW_CLAMP: c_int = 10;\n+            pub const TCP_INFO: c_int = 11;\n+            pub const TCP_QUICKACK: c_int = 12;\n+            pub const TCP_CONGESTION: c_int = 13;\n+            pub const TCP_MD5SIG: c_int = 14;\n+            pub const TCP_COOKIE_TRANSACTIONS: c_int = 15;\n+            pub const TCP_THIN_LINEAR_TIMEOUTS: c_int = 16;\n+            pub const TCP_THIN_DUPACK: c_int = 17;\n+            pub const TCP_USER_TIMEOUT: c_int = 18;\n+            pub const TCP_REPAIR: c_int = 19;\n+            pub const TCP_REPAIR_QUEUE: c_int = 20;\n+            pub const TCP_QUEUE_SEQ: c_int = 21;\n+            pub const TCP_REPAIR_OPTIONS: c_int = 22;\n+            pub const TCP_FASTOPEN: c_int = 23;\n+            pub const TCP_TIMESTAMP: c_int = 24;\n+\n             pub const SOL_SOCKET: c_int = 65535;\n \n             pub const SO_DEBUG: c_int = 0x0001;\n@@ -3779,139 +3804,6 @@ pub mod consts {\n             pub static _SC_PAGESIZE : c_int = 2;\n         }\n \n-        #[cfg(target_os = \"macos\")]\n-        pub mod sysconf {\n-            use types::os::arch::c95::c_int;\n-            pub static _SC_ARG_MAX : c_int = 1;\n-            pub static _SC_CHILD_MAX : c_int = 2;\n-            pub static _SC_CLK_TCK : c_int = 3;\n-            pub static _SC_NGROUPS_MAX : c_int = 4;\n-            pub static _SC_OPEN_MAX : c_int = 5;\n-            pub static _SC_JOB_CONTROL : c_int = 6;\n-            pub static _SC_SAVED_IDS : c_int = 7;\n-            pub static _SC_VERSION : c_int = 8;\n-            pub static _SC_BC_BASE_MAX : c_int = 9;\n-            pub static _SC_BC_DIM_MAX : c_int = 10;\n-            pub static _SC_BC_SCALE_MAX : c_int = 11;\n-            pub static _SC_BC_STRING_MAX : c_int = 12;\n-            pub static _SC_COLL_WEIGHTS_MAX : c_int = 13;\n-            pub static _SC_EXPR_NEST_MAX : c_int = 14;\n-            pub static _SC_LINE_MAX : c_int = 15;\n-            pub static _SC_RE_DUP_MAX : c_int = 16;\n-            pub static _SC_2_VERSION : c_int = 17;\n-            pub static _SC_2_C_BIND : c_int = 18;\n-            pub static _SC_2_C_DEV : c_int = 19;\n-            pub static _SC_2_CHAR_TERM : c_int = 20;\n-            pub static _SC_2_FORT_DEV : c_int = 21;\n-            pub static _SC_2_FORT_RUN : c_int = 22;\n-            pub static _SC_2_LOCALEDEF : c_int = 23;\n-            pub static _SC_2_SW_DEV : c_int = 24;\n-            pub static _SC_2_UPE : c_int = 25;\n-            pub static _SC_STREAM_MAX : c_int = 26;\n-            pub static _SC_TZNAME_MAX : c_int = 27;\n-            pub static _SC_ASYNCHRONOUS_IO : c_int = 28;\n-            pub static _SC_PAGESIZE : c_int = 29;\n-            pub static _SC_MEMLOCK : c_int = 30;\n-            pub static _SC_MEMLOCK_RANGE : c_int = 31;\n-            pub static _SC_MEMORY_PROTECTION : c_int = 32;\n-            pub static _SC_MESSAGE_PASSING : c_int = 33;\n-            pub static _SC_PRIORITIZED_IO : c_int = 34;\n-            pub static _SC_PRIORITY_SCHEDULING : c_int = 35;\n-            pub static _SC_REALTIME_SIGNALS : c_int = 36;\n-            pub static _SC_SEMAPHORES : c_int = 37;\n-            pub static _SC_FSYNC : c_int = 38;\n-            pub static _SC_SHARED_MEMORY_OBJECTS : c_int = 39;\n-            pub static _SC_SYNCHRONIZED_IO : c_int = 40;\n-            pub static _SC_TIMERS : c_int = 41;\n-            pub static _SC_AIO_LISTIO_MAX : c_int = 42;\n-            pub static _SC_AIO_MAX : c_int = 43;\n-            pub static _SC_AIO_PRIO_DELTA_MAX : c_int = 44;\n-            pub static _SC_DELAYTIMER_MAX : c_int = 45;\n-            pub static _SC_MQ_OPEN_MAX : c_int = 46;\n-            pub static _SC_MAPPED_FILES : c_int = 47;\n-            pub static _SC_RTSIG_MAX : c_int = 48;\n-            pub static _SC_SEM_NSEMS_MAX : c_int = 49;\n-            pub static _SC_SEM_VALUE_MAX : c_int =50;\n-            pub static _SC_SIGQUEUE_MAX : c_int = 51;\n-            pub static _SC_TIMER_MAX : c_int = 52;\n-            pub static _SC_NPROCESSORS_CONF : c_int = 57;\n-            pub static _SC_NPROCESSORS_ONLN : c_int = 58;\n-            pub static _SC_2_PBS : c_int = 59;\n-            pub static _SC_2_PBS_ACCOUNTING : c_int = 60;\n-            pub static _SC_2_PBS_CHECKPOINT : c_int = 61;\n-            pub static _SC_2_PBS_LOCATE : c_int = 62;\n-            pub static _SC_2_PBS_MESSAGE : c_int = 63;\n-            pub static _SC_2_PBS_TRACK : c_int = 64;\n-            pub static _SC_ADVISORY_INFO : c_int = 65;\n-            pub static _SC_BARRIERS : c_int = 66;\n-            pub static _SC_CLOCK_SELECTION : c_int = 67;\n-            pub static _SC_CPUTIME : c_int = 68;\n-            pub static _SC_FILE_LOCKING : c_int = 69;\n-            pub static _SC_GETGR_R_SIZE_MAX : c_int = 70;\n-            pub static _SC_GETPW_R_SIZE_MAX : c_int = 71;\n-            pub static _SC_HOST_NAME_MAX : c_int = 72;\n-            pub static _SC_LOGIN_NAME_MAX : c_int = 73;\n-            pub static _SC_MONOTONIC_CLOCK : c_int = 74;\n-            pub static _SC_MQ_PRIO_MAX : c_int = 75;\n-            pub static _SC_READER_WRITER_LOCKS : c_int = 76;\n-            pub static _SC_REGEXP : c_int = 77;\n-            pub static _SC_SHELL : c_int = 78;\n-            pub static _SC_SPAWN : c_int = 79;\n-            pub static _SC_SPIN_LOCKS : c_int = 80;\n-            pub static _SC_SPORADIC_SERVER : c_int = 81;\n-            pub static _SC_THREAD_ATTR_STACKADDR : c_int = 82;\n-            pub static _SC_THREAD_ATTR_STACKSIZE : c_int = 83;\n-            pub static _SC_THREAD_CPUTIME : c_int = 84;\n-            pub static _SC_THREAD_DESTRUCTOR_ITERATIONS : c_int = 85;\n-            pub static _SC_THREAD_KEYS_MAX : c_int = 86;\n-            pub static _SC_THREAD_PRIO_INHERIT : c_int = 87;\n-            pub static _SC_THREAD_PRIO_PROTECT : c_int = 88;\n-            pub static _SC_THREAD_PRIORITY_SCHEDULING : c_int = 89;\n-            pub static _SC_THREAD_PROCESS_SHARED : c_int = 90;\n-            pub static _SC_THREAD_SAFE_FUNCTIONS : c_int = 91;\n-            pub static _SC_THREAD_SPORADIC_SERVER : c_int = 92;\n-            pub static _SC_THREAD_STACK_MIN : c_int = 93;\n-            pub static _SC_THREAD_THREADS_MAX : c_int = 94;\n-            pub static _SC_TIMEOUTS : c_int = 95;\n-            pub static _SC_THREADS : c_int = 96;\n-            pub static _SC_TRACE : c_int = 97;\n-            pub static _SC_TRACE_EVENT_FILTER: c_int = 98;\n-            pub static _SC_TRACE_INHERIT: c_int = 99;\n-            pub static _SC_TRACE_LOG: c_int = 100;\n-            pub static _SC_TTY_NAME_MAX: c_int = 101;\n-            pub static _SC_TYPED_MEMORY_OBJECTS: c_int = 102;\n-            pub static _SC_V6_ILP32_OFF32: c_int = 103;\n-            pub static _SC_V6_ILP32_OFFBIG: c_int = 104;\n-            pub static _SC_V6_LP64_OFF64: c_int = 105;\n-            pub static _SC_V6_LPBIG_OFFBIG: c_int = 106;\n-            pub static _SC_IPV6: c_int = 118;\n-            pub static _SC_RAW_SOCKETS: c_int = 119;\n-            pub static _SC_SYMLOOP_MAX: c_int = 120;\n-            pub static _SC_ATEXIT_MAX: c_int = 107;\n-            pub static _SC_IOV_MAX: c_int = 56;\n-            pub static _SC_PAGE_SIZE: cint = _SC_PAGESIZE;\n-            pub static _SC_XOPEN_CRYPT: c_int = 108;\n-            pub static _SC_XOPEN_ENH_I18N: c_int = 109;\n-            pub static _SC_XOPEN_LEGACY: c_int = 110;\n-            pub static _SC_XOPEN_REALTIME: c_int = 111;\n-            pub static _SC_XOPEN_REALTIME_THREADS: c_int = 112;\n-            pub static _SC_XOPEN_SHM: c_int = 113;\n-            pub static _SC_XOPEN_STREAMS: c_int = 114;\n-            pub static _SC_XOPEN_UNIX: c_int = 115;\n-            pub static _SC_XOPEN_VERSION: c_int = 116;\n-            pub static _SC_XOPEN_XCU_VERSION: c_int = 121;\n-            pub static _SC_XBS5_ILP32_OFF32: c_int = 122;\n-            pub static _SC_XBS5_ILP32_OFFBIG: c_int = 123;\n-            pub static _SC_XBS5_LP64_OFF64: c_int = 124;\n-            pub static _SC_XBS5_LPBIG_OFFBIG: c_int = 125;\n-            pub static _SC_SS_REPL_MAX: c_int = 126;\n-            pub static _SC_TRACE_EVENT_NAME_MAX: c_int = 127;\n-            pub static _SC_TRACE_NAME_MAX: c_int = 128;\n-            pub static _SC_TRACE_SYS_MAX: c_int = 129;\n-            pub static _SC_TRACE_USER_EVENT_MAX: c_int = 130;\n-            pub static _SC_PASS_MAX: c_int = 131;\n-        }\n-\n         #[cfg(target_os = \"android\")]\n         pub mod sysconf {\n             use types::os::arch::c95::c_int;\n@@ -5272,10 +5164,54 @@ pub mod consts {\n             pub const _SC_SEM_VALUE_MAX : c_int = 50;\n             pub const _SC_SIGQUEUE_MAX : c_int = 51;\n             pub const _SC_TIMER_MAX : c_int = 52;\n+            pub const _SC_NPROCESSORS_CONF : c_int = 57;\n+            pub const _SC_NPROCESSORS_ONLN : c_int = 58;\n+            pub const _SC_2_PBS : c_int = 59;\n+            pub const _SC_2_PBS_ACCOUNTING : c_int = 60;\n+            pub const _SC_2_PBS_CHECKPOINT : c_int = 61;\n+            pub const _SC_2_PBS_LOCATE : c_int = 62;\n+            pub const _SC_2_PBS_MESSAGE : c_int = 63;\n+            pub const _SC_2_PBS_TRACK : c_int = 64;\n+            pub const _SC_ADVISORY_INFO : c_int = 65;\n+            pub const _SC_BARRIERS : c_int = 66;\n+            pub const _SC_CLOCK_SELECTION : c_int = 67;\n+            pub const _SC_CPUTIME : c_int = 68;\n+            pub const _SC_FILE_LOCKING : c_int = 69;\n+            pub const _SC_HOST_NAME_MAX : c_int = 72;\n+            pub const _SC_MONOTONIC_CLOCK : c_int = 74;\n+            pub const _SC_READER_WRITER_LOCKS : c_int = 76;\n+            pub const _SC_REGEXP : c_int = 77;\n+            pub const _SC_SHELL : c_int = 78;\n+            pub const _SC_SPAWN : c_int = 79;\n+            pub const _SC_SPIN_LOCKS : c_int = 80;\n+            pub const _SC_SPORADIC_SERVER : c_int = 81;\n+            pub const _SC_THREAD_CPUTIME : c_int = 84;\n+            pub const _SC_THREAD_SPORADIC_SERVER : c_int = 92;\n+            pub const _SC_TIMEOUTS : c_int = 95;\n+            pub const _SC_TRACE : c_int = 97;\n+            pub const _SC_TRACE_EVENT_FILTER : c_int = 98;\n+            pub const _SC_TRACE_INHERIT : c_int = 99;\n+            pub const _SC_TRACE_LOG : c_int = 100;\n+            pub const _SC_TYPED_MEMORY_OBJECTS : c_int = 102;\n+            pub const _SC_V6_ILP32_OFF32 : c_int = 103;\n+            pub const _SC_V6_ILP32_OFFBIG : c_int = 104;\n+            pub const _SC_V6_LP64_OFF64 : c_int = 105;\n+            pub const _SC_V6_LPBIG_OFFBIG : c_int = 106;\n+            pub const _SC_IPV6 : c_int = 118;\n+            pub const _SC_RAW_SOCKETS : c_int = 119;\n+            pub const _SC_SYMLOOP_MAX : c_int = 120;\n+            pub const _SC_PAGE_SIZE : c_int = _SC_PAGESIZE;\n+            pub const _SC_XOPEN_STREAMS : c_int = 114;\n             pub const _SC_XBS5_ILP32_OFF32 : c_int = 122;\n             pub const _SC_XBS5_ILP32_OFFBIG : c_int = 123;\n             pub const _SC_XBS5_LP64_OFF64 : c_int = 124;\n             pub const _SC_XBS5_LPBIG_OFFBIG : c_int = 125;\n+            pub const _SC_SS_REPL_MAX : c_int = 126;\n+            pub const _SC_TRACE_EVENT_NAME_MAX : c_int = 127;\n+            pub const _SC_TRACE_NAME_MAX : c_int = 128;\n+            pub const _SC_TRACE_SYS_MAX : c_int = 129;\n+            pub const _SC_TRACE_USER_EVENT_MAX : c_int = 130;\n+            pub const _SC_PASS_MAX : c_int = 131;\n         }\n     }\n }"}, {"sha": "4280a88f724a29eb8d91ace42dd889def74750c3", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -228,7 +228,7 @@ thread_local! {\n     }\n }\n \n-/// A trait used to represent an interface to a task-local logger. Each task\n+/// A trait used to represent an interface to a thread-local logger. Each thread\n /// can have its own custom logger which can respond to logging messages\n /// however it likes.\n pub trait Logger {\n@@ -324,7 +324,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n #[inline(always)]\n pub fn log_level() -> u32 { unsafe { LOG_LEVEL } }\n \n-/// Replaces the task-local logger with the specified logger, returning the old\n+/// Replaces the thread-local logger with the specified logger, returning the old\n /// logger.\n pub fn set_logger(logger: Box<Logger + Send>) -> Option<Box<Logger + Send>> {\n     let mut l = Some(logger);"}, {"sha": "c9a3e39c42351ddbf7f5053cd35cb875319ebcad", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -136,7 +136,7 @@ macro_rules! info {\n }\n \n /// A convenience macro for logging at the debug log level. This macro can also\n-/// be omitted at compile time by passing `--cfg ndebug` to the compiler. If\n+/// be omitted at compile time by passing `-C debug-assertions` to the compiler. If\n /// this option is not passed, then debug statements will be compiled.\n ///\n /// # Examples"}, {"sha": "1359894b4dd72fd6410190b86e4aad67abd0a7f8", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -26,7 +26,8 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![no_std]\n #![staged_api]\n-#![unstable(feature = \"rand\")]\n+#![unstable(feature = \"rand\",\n+            reason = \"use `rand` from crates.io\")]\n #![feature(core)]\n #![feature(no_std)]\n #![feature(staged_api)]"}, {"sha": "aaf615ee404095c07d84aae94d46fecd6299b65a", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 322, "deletions": 31, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -37,7 +37,7 @@ An example of an empty type is `enum Empty { }`.\n E0003: r##\"\n Not-a-Number (NaN) values cannot be compared for equality and hence can never\n match the input to a match expression. To match against NaN values, you should\n-instead use the `is_nan` method in a guard, as in: x if x.is_nan() => ...\n+instead use the `is_nan` method in a guard, as in: `x if x.is_nan() => ...`\n \"##,\n \n E0004: r##\"\n@@ -71,7 +71,7 @@ failure.\n E0007: r##\"\n This error indicates that the bindings in a match arm would require a value to\n be moved into more than one location, thus violating unique ownership. Code like\n-the following is invalid as it requires the entire Option<String> to be moved\n+the following is invalid as it requires the entire `Option<String>` to be moved\n into a variable called `op_string` while simultaneously requiring the inner\n String to be moved into a variable called `s`.\n \n@@ -99,10 +99,10 @@ match Some(\"hi\".to_string()) {\n }\n ```\n \n-The variable `s` has type String, and its use in the guard is as a variable of\n-type String. The guard code effectively executes in a separate scope to the body\n-of the arm, so the value would be moved into this anonymous scope and therefore\n-become unavailable in the body of the arm. Although this example seems\n+The variable `s` has type `String`, and its use in the guard is as a variable of\n+type `String`. The guard code effectively executes in a separate scope to the\n+body of the arm, so the value would be moved into this anonymous scope and\n+therefore become unavailable in the body of the arm. Although this example seems\n innocuous, the problem is most clear when considering functions that take their\n argument by value.\n \n@@ -140,7 +140,8 @@ match x {\n ```\n \n You have two solutions:\n-1. Bind the pattern's values the same way:\n+\n+Solution #1: Bind the pattern's values the same way.\n \n ```\n struct X { x: (), }\n@@ -153,8 +154,9 @@ match x {\n }\n ```\n \n-2. Implement the `Copy` trait for the X structure (however, please\n-keep in mind that the first solution should be preferred!):\n+Solution #2: Implement the `Copy` trait for the `X` structure.\n+\n+However, please keep in mind that the first solution should be preferred.\n \n ```\n #[derive(Clone, Copy)]\n@@ -168,6 +170,12 @@ match x {\n ```\n \"##,\n \n+E0010: r##\"\n+The value of statics and constants must be known at compile time, and they live\n+for the entire lifetime of a program. Creating a boxed value allocates memory on\n+the heap at runtime, and therefore cannot be done at compile time.\n+\"##,\n+\n E0013: r##\"\n Static and const variables can refer to other const variables. But a const\n variable cannot refer to a static variable. For example, `Y` cannot refer to `X`\n@@ -221,21 +229,54 @@ This error indicates that an attempt was made to divide by zero (or take the\n remainder of a zero divisor) in a static or constant expression.\n \"##,\n \n+E0079: r##\"\n+Enum variants which contain no data can be given a custom integer\n+representation. This error indicates that the value provided is not an\n+integer literal and is therefore invalid.\n+\"##,\n+\n+E0080: r##\"\n+This error indicates that the compiler was unable to sensibly evaluate an\n+integer expression provided as an enum discriminant. Attempting to divide by 0\n+or causing integer overflow are two ways to induce this error. For example:\n+\n+```\n+enum Enum {\n+    X = (1 << 500),\n+    Y = (1 / 0)\n+}\n+```\n+\n+Ensure that the expressions given can be evaluated as the desired integer type.\n+See the FFI section of the Reference for more information about using a custom\n+integer type:\n+\n+http://doc.rust-lang.org/reference.html#ffi-attributes\n+\"##,\n+\n E0133: r##\"\n Using unsafe functionality, such as dereferencing raw pointers and calling\n functions via FFI or marked as unsafe, is potentially dangerous and disallowed\n by safety checks. As such, those safety checks can be temporarily relaxed by\n wrapping the unsafe instructions inside an `unsafe` block. For instance:\n \n+```\n unsafe fn f() { return; }\n \n fn main() {\n     unsafe { f(); }\n }\n+```\n \n See also http://doc.rust-lang.org/book/unsafe.html\n \"##,\n \n+E0137: r##\"\n+This error indicates that the compiler found multiple functions with the\n+#[main] attribute. This is an error because there must be a unique entry point\n+into a Rust program.\n+\"##,\n+\n E0152: r##\"\n Lang items are already implemented in the standard library. Unless you are\n writing a free-standing application (e.g. a kernel), you do not need to provide\n@@ -282,8 +323,8 @@ it around as usual.\n \n E0162: r##\"\n An if-let pattern attempts to match the pattern, and enters the body if the\n-match was succesful. If the match is irrefutable (when it cannot fail to match),\n-use a regular `let`-binding instead. For instance:\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding instead. For instance:\n \n ```\n struct Irrefutable(i32);\n@@ -303,8 +344,8 @@ foo(x);\n \n E0165: r##\"\n A while-let pattern attempts to match the pattern, and enters the body if the\n-match was succesful. If the match is irrefutable (when it cannot fail to match),\n-use a regular `let`-binding inside a `loop` instead. For instance:\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding inside a `loop` instead. For instance:\n \n ```\n struct Irrefutable(i32);\n@@ -343,7 +384,7 @@ match m {\n ```\n \n If you don't qualify the names, the code will bind new variables named \"GET\" and\n-\"POST\" instead. This behavior is likely not what you want, so rustc warns when\n+\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\n that happens.\n \n Qualified names are good practice, and most code works well with them. But if\n@@ -372,16 +413,220 @@ const Y: u32 = X;\n \"##,\n \n E0267: r##\"\n-This error indicates the use of loop keyword (break or continue) inside a\n-closure but outside of any loop. Break and continue can be used as normal\n-inside closures as long as they are also contained within a loop. To halt the\n-execution of a closure you should instead use a return statement.\n+This error indicates the use of a loop keyword (`break` or `continue`) inside a\n+closure but outside of any loop. Break and continue can be used as normal inside\n+closures as long as they are also contained within a loop. To halt the execution\n+of a closure you should instead use a return statement.\n \"##,\n \n E0268: r##\"\n-This error indicates the use of loop keyword (break or continue) outside of a\n-loop. Without a loop to break out of or continue in, no sensible action can be\n-taken.\n+This error indicates the use of a loop keyword (`break` or `continue`) outside\n+of a loop. Without a loop to break out of or continue in, no sensible action can\n+be taken.\n+\"##,\n+\n+E0271: r##\"\n+This is because of a type mismatch between the associated type of some\n+trait (e.g. T::Bar, where T implements trait Quux { type Bar; })\n+and another type U that is required to be equal to T::Bar, but is not.\n+Examples follow.\n+\n+Here is a basic example:\n+\n+```\n+trait Trait { type AssociatedType; }\n+fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n+    println!(\"in foo\");\n+}\n+impl Trait for i8 { type AssociatedType = &'static str; }\n+foo(3_i8);\n+```\n+\n+Here is that same example again, with some explanatory comments:\n+\n+```\n+trait Trait { type AssociatedType; }\n+\n+fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n+//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n+//                        |            |\n+//         This says `foo` can         |\n+//           only be used with         |\n+//              some type that         |\n+//         implements `Trait`.         |\n+//                                     |\n+//                             This says not only must\n+//                             `T` be an impl of `Trait`\n+//                             but also that the impl\n+//                             must assign the type `u32`\n+//                             to the associated type.\n+    println!(\"in foo\");\n+}\n+\n+impl Trait for i8 { type AssociatedType = &'static str; }\n+~~~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+//      |                             |\n+// `i8` does have                     |\n+// implementation                     |\n+// of `Trait`...                      |\n+//                     ... but it is an implementation\n+//                     that assigns `&'static str` to\n+//                     the associated type.\n+\n+foo(3_i8);\n+// Here, we invoke `foo` with an `i8`, which does not satisfy\n+// the constraint `<i8 as Trait>::AssociatedType=32`, and\n+// therefore the type-checker complains with this error code.\n+```\n+\n+Here is a more subtle instance of the same problem, that can\n+arise with for-loops in Rust:\n+\n+```\n+let vs: Vec<i32> = vec![1, 2, 3, 4];\n+for v in &vs {\n+    match v {\n+        1 => {}\n+        _ => {}\n+    }\n+}\n+```\n+\n+The above fails because of an analogous type mismatch,\n+though may be harder to see. Again, here are some\n+explanatory comments for the same example:\n+\n+```\n+{\n+    let vs = vec![1, 2, 3, 4];\n+\n+    // `for`-loops use a protocol based on the `Iterator`\n+    // trait. Each item yielded in a `for` loop has the\n+    // type `Iterator::Item` -- that is,I `Item` is the\n+    // associated type of the concrete iterator impl.\n+    for v in &vs {\n+//      ~    ~~~\n+//      |     |\n+//      |    We borrow `vs`, iterating over a sequence of\n+//      |    *references* of type `&Elem` (where `Elem` is\n+//      |    vector's element type). Thus, the associated\n+//      |    type `Item` must be a reference `&`-type ...\n+//      |\n+//  ... and `v` has the type `Iterator::Item`, as dictated by\n+//  the `for`-loop protocol ...\n+\n+        match v {\n+            1 => {}\n+//          ~\n+//          |\n+// ... but *here*, `v` is forced to have some integral type;\n+// only types like `u8`,`i8`,`u16`,`i16`, et cetera can\n+// match the pattern `1` ...\n+\n+            _ => {}\n+        }\n+\n+// ... therefore, the compiler complains, because it sees\n+// an attempt to solve the equations\n+// `some integral-type` = type-of-`v`\n+//                      = `Iterator::Item`\n+//                      = `&Elem` (i.e. `some reference type`)\n+//\n+// which cannot possibly all be true.\n+\n+    }\n+}\n+```\n+\n+To avoid those issues, you have to make the types match correctly.\n+So we can fix the previous examples like this:\n+\n+```\n+// Basic Example:\n+trait Trait { type AssociatedType; }\n+fn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n+    println!(\"in foo\");\n+}\n+impl Trait for i8 { type AssociatedType = &'static str; }\n+foo(3_i8);\n+\n+// For-Loop Example:\n+let vs = vec![1, 2, 3, 4];\n+for v in &vs {\n+    match v {\n+        &1 => {}\n+        _ => {}\n+    }\n+}\n+```\n+\"##,\n+\n+E0282: r##\"\n+This error indicates that type inference did not result in one unique possible\n+type, and extra information is required. In most cases this can be provided\n+by adding a type annotation. Sometimes you need to specify a generic type\n+parameter manually.\n+\n+A common example is the `collect` method on `Iterator`. It has a generic type\n+parameter with a `FromIterator` bound, which for a `char` iterator is\n+implemented by `Vec` and `String` among others. Consider the following snippet\n+that reverses the characters of a string:\n+\n+```\n+let x = \"hello\".chars().rev().collect();\n+```\n+\n+In this case, the compiler cannot infer what the type of `x` should be:\n+`Vec<char>` and `String` are both suitable candidates. To specify which type to\n+use, you can use a type annotation on `x`:\n+\n+```\n+let x: Vec<char> = \"hello\".chars().rev().collect();\n+```\n+\n+It is not necessary to annotate the full type. Once the ambiguity is resolved,\n+the compiler can infer the rest:\n+\n+```\n+let x: Vec<_> = \"hello\".chars().rev().collect();\n+```\n+\n+Another way to provide the compiler with enough information, is to specify the\n+generic type parameter:\n+\n+```\n+let x = \"hello\".chars().rev().collect::<Vec<char>>();\n+```\n+\n+Again, you need not specify the full type if the compiler can infer it:\n+\n+```\n+let x = \"hello\".chars().rev().collect::<Vec<_>>();\n+```\n+\n+Apart from a method or function with a generic type parameter, this error can\n+occur when a type parameter of a struct or trait cannot be inferred. In that\n+case it is not always possible to use a type annotation, because all candidates\n+have the same return type. For instance:\n+\n+```\n+struct Foo<T> {\n+    // Some fields omitted.\n+}\n+\n+impl<T> Foo<T> {\n+    fn bar() -> i32 {\n+        0\n+    }\n+\n+    fn baz() {\n+        let number = Foo::bar();\n+    }\n+}\n+```\n+\n+This will fail because the compiler does not know which instance of `Foo` to\n+call `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n \"##,\n \n E0296: r##\"\n@@ -476,7 +721,7 @@ match Some(\"hi\".to_string()) {\n }\n ```\n \n-The `op_string_ref` binding has type &Option<&String> in both cases.\n+The `op_string_ref` binding has type `&Option<&String>` in both cases.\n \n See also https://github.com/rust-lang/rust/issues/14587\n \"##,\n@@ -489,27 +734,78 @@ number cannot be negative.\n E0307: r##\"\n The length of an array is part of its type. For this reason, this length must be\n a compile-time constant.\n+\"##,\n+\n+E0308: r##\"\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. This error can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+let x: i32 = \"I am not a number!\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+\"##,\n+\n+E0309: r##\"\n+Types in type definitions have lifetimes associated with them that represent\n+how long the data stored within them is guaranteed to be live. This lifetime\n+must be as long as the data needs to be alive, and missing the constraint that\n+denotes this will cause this error.\n+\n+// This won't compile because T is not constrained, meaning the data\n+// stored in it is not guaranteed to last as long as the reference\n+struct Foo<'a, T> {\n+    foo: &'a T\n+}\n+\n+// This will compile, because it has the constraint on the type parameter\n+struct Foo<'a, T: 'a> {\n+    foo: &'a T\n+}\n+\"##,\n+\n+E0310: r##\"\n+Types in type definitions have lifetimes associated with them that represent\n+how long the data stored within them is guaranteed to be live. This lifetime\n+must be as long as the data needs to be alive, and missing the constraint that\n+denotes this will cause this error.\n+\n+// This won't compile because T is not constrained to the static lifetime\n+// the reference needs\n+struct Foo<T> {\n+    foo: &'static T\n+}\n+\n+// This will compile, because it has the constraint on the type parameter\n+struct Foo<T: 'static> {\n+    foo: &'static T\n+}\n \"##\n \n }\n \n+\n register_diagnostics! {\n-    E0010,\n     E0011,\n     E0012,\n     E0014,\n     E0016,\n     E0017,\n     E0019,\n     E0022,\n-    E0079, // enum variant: expected signed integer constant\n-    E0080, // enum variant: constant evaluation error\n     E0109,\n     E0110,\n     E0134,\n     E0135,\n     E0136,\n-    E0137,\n     E0138,\n     E0139,\n     E0261, // use of undeclared lifetime name\n@@ -519,7 +815,6 @@ register_diagnostics! {\n     E0266, // expected item\n     E0269, // not all control paths return a value\n     E0270, // computation may converge in a function marked as diverging\n-    E0271, // type mismatch resolving\n     E0272, // rustc_on_unimplemented attribute refers to non-existent type parameter\n     E0273, // rustc_on_unimplemented must have named format arguments\n     E0274, // rustc_on_unimplemented must have a value\n@@ -530,7 +825,6 @@ register_diagnostics! {\n     E0279, // requirement is not satisfied\n     E0280, // requirement is not satisfied\n     E0281, // type implements trait but other trait is required\n-    E0282, // unable to infer enough type information about\n     E0283, // cannot resolve type\n     E0284, // cannot resolve type\n     E0285, // overflow evaluation builtin bounds\n@@ -539,9 +833,6 @@ register_diagnostics! {\n     E0300, // unexpanded macro\n     E0304, // expected signed integer constant\n     E0305, // expected constant\n-    E0308,\n-    E0309, // thing may not live long enough\n-    E0310, // thing may not live long enough\n     E0311, // thing may not live long enough\n     E0312, // lifetime of reference outlives lifetime of borrowed content\n     E0313, // lifetime of borrowed pointer outlives lifetime of captured variable"}, {"sha": "35abbc77c12b16cf3342401542ac1536fa5ee591", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -147,6 +147,7 @@ pub mod util {\n     pub mod nodemap;\n     pub mod lev_distance;\n     pub mod num;\n+    pub mod fs;\n }\n \n pub mod lib {"}, {"sha": "7132ac4895aa1d60055871301ba4c5cc8c94041e", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -283,7 +283,7 @@ pub fn get_impl_polarity<'tcx>(tcx: &ty::ctxt<'tcx>,\n // if there is one.\n pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             def: ast::DefId)\n-                            -> Option<Rc<ty::TraitRef<'tcx>>> {\n+                            -> Option<ty::TraitRef<'tcx>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_trait(&*cdata, def.node, tcx)"}, {"sha": "00fc42341c38996225823b22e1df9d67bc5ccb2d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -30,7 +30,9 @@ use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty::{self, Ty};\n use middle::astencode::vtable_decoder_helpers;\n+use util::nodemap::FnvHashMap;\n \n+use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::hash::{self, Hash, SipHasher};\n use std::io::prelude::*;\n@@ -247,13 +249,13 @@ pub fn item_type<'tcx>(_item_id: ast::DefId, item: rbml::Doc,\n }\n \n fn doc_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n-                       -> Rc<ty::TraitRef<'tcx>> {\n+                       -> ty::TraitRef<'tcx> {\n     parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n-                        -> Rc<ty::TraitRef<'tcx>> {\n+                        -> ty::TraitRef<'tcx> {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n }\n@@ -420,6 +422,9 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n         generics: generics,\n         trait_ref: item_trait_ref(item_doc, tcx, cdata),\n         associated_type_names: associated_type_names,\n+        nonblanket_impls: RefCell::new(FnvHashMap()),\n+        blanket_impls: RefCell::new(vec![]),\n+        flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n     }\n }\n \n@@ -490,7 +495,7 @@ pub fn get_impl_polarity<'tcx>(cdata: Cmd,\n pub fn get_impl_trait<'tcx>(cdata: Cmd,\n                             id: ast::NodeId,\n                             tcx: &ty::ctxt<'tcx>)\n-                            -> Option<Rc<ty::TraitRef<'tcx>>>\n+                            -> Option<ty::TraitRef<'tcx>>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     let fam = item_family(item_doc);"}, {"sha": "90dd452e06b5bf7cc3f5c8504dbe63981c7c5ccc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -103,7 +103,7 @@ struct entry<T> {\n \n fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a, 'tcx>,\n-                              trait_ref: &ty::TraitRef<'tcx>,\n+                              trait_ref: ty::TraitRef<'tcx>,\n                               tag: usize) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n@@ -191,7 +191,7 @@ pub fn write_trait_ref<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n-    tyencode::enc_trait_ref(rbml_w, ty_str_ctxt, trait_ref);\n+    tyencode::enc_trait_ref(rbml_w, ty_str_ctxt, *trait_ref);\n }\n \n pub fn write_region(ecx: &EncodeContext,\n@@ -974,16 +974,14 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n fn encode_extension_implementations(ecx: &EncodeContext,\n                                     rbml_w: &mut Encoder,\n                                     trait_def_id: DefId) {\n-    match ecx.tcx.trait_impls.borrow().get(&trait_def_id) {\n-        None => {}\n-        Some(implementations) => {\n-            for &impl_def_id in &*implementations.borrow() {\n-                rbml_w.start_tag(tag_items_data_item_extension_impl);\n-                encode_def_id(rbml_w, impl_def_id);\n-                rbml_w.end_tag();\n-            }\n-        }\n-    }\n+    assert!(ast_util::is_local(trait_def_id));\n+    let def = ty::lookup_trait_def(ecx.tcx, trait_def_id);\n+\n+    def.for_each_impl(ecx.tcx, |impl_def_id| {\n+        rbml_w.start_tag(tag_items_data_item_extension_impl);\n+        encode_def_id(rbml_w, impl_def_id);\n+        rbml_w.end_tag();\n+    });\n }\n \n fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<attr::Stability>) {\n@@ -1201,7 +1199,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           encode_unsafety(rbml_w, unsafety);\n \n           let trait_ref = ty::impl_id_to_trait_ref(tcx, item.id);\n-          encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n+          encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n       ast::ItemImpl(unsafety, polarity, _, ref opt_trait, ref ty, ref ast_items) => {\n@@ -1246,7 +1244,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         if opt_trait.is_some() {\n             let trait_ref = ty::impl_id_to_trait_ref(tcx, item.id);\n-            encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n+            encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n@@ -1314,7 +1312,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         tag_item_generics);\n         encode_predicates(rbml_w, ecx, &ty::lookup_super_predicates(tcx, def_id),\n                           tag_item_super_predicates);\n-        encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n+        encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_visibility(rbml_w, vis);"}, {"sha": "311ab1cbd0ce02269a5aea17ee01880dab254cb5", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -19,6 +19,7 @@ use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n \n use session::search_paths::{SearchPaths, PathKind};\n+use util::fs as rustcfs;\n \n #[derive(Copy, Clone)]\n pub enum FileMatch {\n@@ -191,7 +192,10 @@ pub fn get_or_default_sysroot() -> PathBuf {\n     fn canonicalize(path: Option<PathBuf>) -> Option<PathBuf> {\n         path.and_then(|path| {\n             match fs::canonicalize(&path) {\n-                Ok(canon) => Some(canon),\n+                // See comments on this target function, but the gist is that\n+                // gcc chokes on verbatim paths which fs::canonicalize generates\n+                // so we try to avoid those kinds of paths.\n+                Ok(canon) => Some(rustcfs::fix_windows_verbatim_for_gcc(&canon)),\n                 Err(e) => panic!(\"failed to get realpath: {}\", e),\n             }\n         })"}, {"sha": "223a5eef614c1acc4aacf62e4369be359f7e36cc", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -23,7 +23,6 @@ use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{self, AsPredicate, Ty};\n \n-use std::rc::Rc;\n use std::str;\n use syntax::abi;\n use syntax::ast;\n@@ -182,7 +181,7 @@ pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos\n \n pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n                                      tcx: &ty::ctxt<'tcx>, conv: F)\n-                                     -> Rc<ty::TraitRef<'tcx>> where\n+                                     -> ty::TraitRef<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     debug!(\"parse_trait_ref_data {}\", data_log_string(data, pos));\n@@ -434,19 +433,19 @@ fn parse_str(st: &mut PState, term: char) -> String {\n }\n \n fn parse_trait_ref<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F)\n-                                -> Rc<ty::TraitRef<'tcx>> where\n+                                -> ty::TraitRef<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     parse_trait_ref_(st, &mut conv)\n }\n \n fn parse_trait_ref_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n-                              -> Rc<ty::TraitRef<'tcx>> where\n+                              -> ty::TraitRef<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     let def = parse_def_(st, NominalType, conv);\n     let substs = st.tcx.mk_substs(parse_substs_(st, conv));\n-    Rc::new(ty::TraitRef {def_id: def, substs: substs})\n+    ty::TraitRef {def_id: def, substs: substs}\n }\n \n fn parse_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F) -> Ty<'tcx> where"}, {"sha": "f5f520720c62bc1ca5d421bbd91b9fed2cfac57b", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -94,7 +94,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n         ty::ty_trait(box ty::TyTrait { ref principal,\n                                        ref bounds }) => {\n             mywrite!(w, \"x[\");\n-            enc_trait_ref(w, cx, &*principal.0);\n+            enc_trait_ref(w, cx, principal.0);\n             enc_existential_bounds(w, cx, bounds);\n             mywrite!(w, \"]\");\n         }\n@@ -149,7 +149,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n         }\n         ty::ty_projection(ref data) => {\n             mywrite!(w, \"P[\");\n-            enc_trait_ref(w, cx, &*data.trait_ref);\n+            enc_trait_ref(w, cx, data.trait_ref);\n             mywrite!(w, \"{}]\", token::get_name(data.item_name));\n         }\n         ty::ty_err => {\n@@ -309,7 +309,7 @@ fn enc_bound_region(w: &mut Encoder, cx: &ctxt, br: ty::BoundRegion) {\n }\n \n pub fn enc_trait_ref<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n-                               s: &ty::TraitRef<'tcx>) {\n+                               s: ty::TraitRef<'tcx>) {\n     mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, s.substs);\n }\n@@ -394,7 +394,7 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n \n     for tp in &bs.trait_bounds {\n         mywrite!(w, \"I\");\n-        enc_trait_ref(w, cx, &*tp.0);\n+        enc_trait_ref(w, cx, tp.0);\n     }\n \n     for tp in &bs.projection_bounds {\n@@ -446,7 +446,7 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut Encoder,\n     match *p {\n         ty::Predicate::Trait(ref trait_ref) => {\n             mywrite!(w, \"t\");\n-            enc_trait_ref(w, cx, &*trait_ref.0.trait_ref);\n+            enc_trait_ref(w, cx, trait_ref.0.trait_ref);\n         }\n         ty::Predicate::Equate(ty::Binder(ty::EquatePredicate(a, b))) => {\n             mywrite!(w, \"e\");\n@@ -473,7 +473,7 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut Encoder,\n fn enc_projection_predicate<'a, 'tcx>(w: &mut Encoder,\n                                       cx: &ctxt<'a, 'tcx>,\n                                       data: &ty::ProjectionPredicate<'tcx>) {\n-    enc_trait_ref(w, cx, &*data.projection_ty.trait_ref);\n+    enc_trait_ref(w, cx, data.projection_ty.trait_ref);\n     mywrite!(w, \"{}|\", token::get_name(data.projection_ty.item_name));\n     enc_ty(w, cx, data.ty);\n }"}, {"sha": "4bfc4c5b850fd43f8dfe3ffe834cad4aa66662c6", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -41,7 +41,6 @@ use syntax;\n use std::cell::Cell;\n use std::io::SeekFrom;\n use std::io::prelude::*;\n-use std::rc::Rc;\n use std::fmt::Debug;\n \n use rbml::reader;\n@@ -890,7 +889,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"MethodTypeParam\", 2, 1, |this| {\n                         this.emit_struct(\"MethodParam\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &*p.trait_ref))\n+                                Ok(this.emit_trait_ref(ecx, &p.trait_ref))\n                             }));\n                             try!(this.emit_struct_field(\"method_num\", 0, |this| {\n                                 this.emit_uint(p.method_num)\n@@ -914,7 +913,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"MethodTraitObject\", 3, 1, |this| {\n                         this.emit_struct(\"MethodObject\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &*o.trait_ref))\n+                                Ok(this.emit_trait_ref(ecx, &o.trait_ref))\n                             }));\n                             try!(this.emit_struct_field(\"object_trait_id\", 0, |this| {\n                                 Ok(this.emit_def_id(o.object_trait_id))\n@@ -1208,7 +1207,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     if let Some(trait_ref) = tcx.object_cast_map.borrow().get(&id) {\n         rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n-            rbml_w.emit_trait_ref(ecx, &*trait_ref.0);\n+            rbml_w.emit_trait_ref(ecx, &trait_ref.0);\n         })\n     }\n \n@@ -1275,7 +1274,7 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n     fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                              -> Rc<ty::TraitRef<'tcx>>;\n+                              -> ty::TraitRef<'tcx>;\n     fn read_poly_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::PolyTraitRef<'tcx>;\n     fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1469,7 +1468,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     }\n \n     fn read_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                              -> Rc<ty::TraitRef<'tcx>> {\n+                              -> ty::TraitRef<'tcx> {\n         self.read_opaque(|this, doc| {\n             let ty = tydecode::parse_trait_ref_data(\n                 doc.data,"}, {"sha": "8bb83c54da8a3681d92ff8b8410ea0951f4832ce", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -45,8 +45,6 @@ use std::collections::hash_map::Entry;\n bitflags! {\n     #[derive(RustcEncodable, RustcDecodable)]\n     flags ConstQualif: u8 {\n-        // Const rvalue which can be placed behind a reference.\n-        const PURE_CONST         = 0,\n         // Inner mutability (can not be placed behind a reference) or behind\n         // &mut in a non-global expression. Can be copied from static memory.\n         const MUTABLE_MEM        = 1 << 0,\n@@ -104,7 +102,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     {\n         let (old_mode, old_qualif) = (self.mode, self.qualif);\n         self.mode = mode;\n-        self.qualif = ConstQualif::PURE_CONST;\n+        self.qualif = ConstQualif::empty();\n         let r = f(self);\n         self.mode = old_mode;\n         self.qualif = old_qualif;\n@@ -128,7 +126,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             Entry::Occupied(entry) => return *entry.get(),\n             Entry::Vacant(entry) => {\n                 // Prevent infinite recursion on re-entry.\n-                entry.insert(ConstQualif::PURE_CONST);\n+                entry.insert(ConstQualif::empty());\n             }\n         }\n         self.with_mode(mode, |this| {\n@@ -273,7 +271,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, ex: &ast::Expr) {\n         let mut outer = self.qualif;\n-        self.qualif = ConstQualif::PURE_CONST;\n+        self.qualif = ConstQualif::empty();\n \n         let node_ty = ty::node_id_to_type(self.tcx, ex.id);\n         check_expr(self, ex, node_ty);"}, {"sha": "091092e3b607992adc637a8fd0ffc0ac80e8c484", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -942,8 +942,8 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n     let trait_substs = tcx.mk_substs(trait_substs);\n     debug!(\"resolve_trait_associated_const: trait_substs={}\",\n            trait_substs.repr(tcx));\n-    let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: trait_id,\n-                                                      substs: trait_substs }));\n+    let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n+                                              substs: trait_substs });\n \n     ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);"}, {"sha": "86deca0c1449d5eac1773c7fa62979bcf3ab4aa4", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -16,7 +16,6 @@ use middle::traits;\n use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty_fold::{TypeFoldable, TypeFolder};\n \n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n \n@@ -324,7 +323,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     }\n \n     fn accumulate_from_assoc_types(&mut self,\n-                                   trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                                   trait_ref: ty::TraitRef<'tcx>)\n     {\n         debug!(\"accumulate_from_assoc_types({})\",\n                trait_ref.repr(self.tcx()));\n@@ -442,7 +441,7 @@ pub fn object_region_bounds<'tcx>(\n     // Note that we preserve the overall binding levels here.\n     assert!(!open_ty.has_escaping_regions());\n     let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n-    let trait_refs = vec!(ty::Binder(Rc::new(ty::TraitRef::new(principal.0.def_id, substs))));\n+    let trait_refs = vec!(ty::Binder(ty::TraitRef::new(principal.0.def_id, substs)));\n \n     let param_bounds = ty::ParamBounds {\n         region_bounds: Vec::new(),"}, {"sha": "8aca64484bf4506d43b9d4bbcff305477fbe7edf", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -79,7 +79,6 @@ use middle::ty::{self, Ty};\n use middle::ty::{Region, ReFree};\n use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n-use std::rc::Rc;\n use std::string::String;\n use syntax::ast;\n use syntax::ast_map;\n@@ -1680,13 +1679,13 @@ impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx> Resolvable<'tcx> for Rc<ty::TraitRef<'tcx>> {\n+impl<'tcx> Resolvable<'tcx> for ty::TraitRef<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n-                   -> Rc<ty::TraitRef<'tcx>> {\n-        Rc::new(infcx.resolve_type_vars_if_possible(&**self))\n+                   -> ty::TraitRef<'tcx> {\n+        infcx.resolve_type_vars_if_possible(self)\n     }\n     fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(&**self)\n+        ty::trait_ref_contains_error(self)\n     }\n }\n \n@@ -1699,7 +1698,7 @@ impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n     }\n \n     fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(&*self.0)\n+        ty::trait_ref_contains_error(&self.0)\n     }\n }\n "}, {"sha": "b0940aa7ec0ac823afccc51d440547dacd80c898", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -461,7 +461,7 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n \n /// Constructs and returns a substitution that, for a given type\n /// scheme parameterized by `generics`, will replace every generic\n-/// parmeter in the type with a skolemized type/region (which one can\n+/// parameter in the type with a skolemized type/region (which one can\n /// think of as a \"fresh constant\", except at the type/region level of\n /// reasoning).\n ///"}, {"sha": "b802f46e28594184eeb8c51853e5d880902dead1", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -33,7 +33,6 @@ use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{RefCell};\n use std::fmt;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n@@ -155,7 +154,7 @@ impl fmt::Display for TypeOrigin {\n #[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n     Types(ty::expected_found<Ty<'tcx>>),\n-    TraitRefs(ty::expected_found<Rc<ty::TraitRef<'tcx>>>),\n+    TraitRefs(ty::expected_found<ty::TraitRef<'tcx>>),\n     PolyTraitRefs(ty::expected_found<ty::PolyTraitRef<'tcx>>),\n }\n \n@@ -663,8 +662,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn sub_trait_refs(&self,\n                           a_is_expected: bool,\n                           origin: TypeOrigin,\n-                          a: Rc<ty::TraitRef<'tcx>>,\n-                          b: Rc<ty::TraitRef<'tcx>>)\n+                          a: ty::TraitRef<'tcx>,\n+                          b: ty::TraitRef<'tcx>)\n                           -> UnitResult<'tcx>\n     {\n         debug!(\"sub_trait_refs({} <: {})\",\n@@ -675,7 +674,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).relate(&*a, &*b).map(|_| ())\n+            self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n         })\n     }\n \n@@ -873,8 +872,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         format!(\"({})\", tstrs.connect(\", \"))\n     }\n \n-    pub fn trait_ref_to_string(&self, t: &Rc<ty::TraitRef<'tcx>>) -> String {\n-        let t = self.resolve_type_vars_if_possible(&**t);\n+    pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n+        let t = self.resolve_type_vars_if_possible(t);\n         t.user_string(self.tcx)\n     }\n "}, {"sha": "c2865e338496706e415393c8568535bf4ca41180", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -334,7 +334,6 @@ lets_do_this! {\n     InvariantLifetimeItem,           \"invariant_lifetime\",      invariant_lifetime;\n \n     NoCopyItem,                      \"no_copy_bound\",           no_copy_bound;\n-    ManagedItem,                     \"managed_bound\",           managed_bound;\n \n     NonZeroItem,                     \"non_zero\",                non_zero;\n "}, {"sha": "3fff15049930b6d6b80cbd56c7e8cccb548af858", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -850,9 +850,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // Compute maximum lifetime of this rvalue. This is 'static if\n         // we can promote to a constant, otherwise equal to enclosing temp\n         // lifetime.\n-        let re = match qualif & check_const::ConstQualif::NON_STATIC_BORROWS {\n-            check_const::ConstQualif::PURE_CONST => ty::ReStatic,\n-            _ => self.temporary_scope(id),\n+        let re = if qualif.intersects(check_const::ConstQualif::NON_STATIC_BORROWS) {\n+            self.temporary_scope(id)\n+        } else {\n+            ty::ReStatic\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {}\", ret.repr(self.tcx()));"}, {"sha": "e7a03a9b7e17439ea4a1557ea9e1c026897d88b4", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -374,7 +374,7 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v ast::Block) {\n         fn visit_expr(&mut self, ex: &'v ast::Expr) {\n             if let Some(label) = expression_label(ex) {\n                 for &(prior, prior_span) in &self.labels_in_fn[..] {\n-                    // FIXME (#24278): non-hygienic comparision\n+                    // FIXME (#24278): non-hygienic comparison\n                     if label.name == prior.name {\n                         signal_shadowing_problem(self.sess,\n                                                  label.name,\n@@ -420,7 +420,7 @@ fn extract_labels<'v, 'a>(ctxt: &mut LifetimeContext<'a>, b: &'v ast::Block) {\n                 EarlyScope(_, lifetimes, s) |\n                 LateScope(lifetimes, s) => {\n                     for lifetime_def in lifetimes {\n-                        // FIXME (#24278): non-hygienic comparision\n+                        // FIXME (#24278): non-hygienic comparison\n                         if label.name == lifetime_def.lifetime.name {\n                             signal_shadowing_problem(\n                                 sess,\n@@ -677,7 +677,7 @@ impl<'a> LifetimeContext<'a> {\n                                         lifetime: &ast::Lifetime)\n     {\n         for &(label, label_span) in &self.labels_in_fn {\n-            // FIXME (#24278): non-hygienic comparision\n+            // FIXME (#24278): non-hygienic comparison\n             if lifetime.name == label.name {\n                 signal_shadowing_problem(self.sess,\n                                          lifetime.name,"}, {"sha": "500255db330c5c62df937621f324f8e1b7a9e3c0", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -273,7 +273,6 @@ impl<T> VecPerParamSpace<T> {\n \n     /// `t` is the type space.\n     /// `s` is the self space.\n-    /// `a` is the assoc space.\n     /// `f` is the fn space.\n     pub fn new(t: Vec<T>, s: Vec<T>, f: Vec<T>) -> VecPerParamSpace<T> {\n         let type_limit = t.len();"}, {"sha": "d9f8a88fddca3694b28d94d6159f1f7745447a37", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -20,7 +20,6 @@ use super::util;\n use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use middle::infer::{self, InferCtxt};\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{DUMMY_SP, Span};\n use util::ppaux::Repr;\n@@ -139,7 +138,7 @@ type SubstsFn = for<'a,'tcx> fn(infcx: &InferCtxt<'a, 'tcx>,\n fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                      impl_def_id: ast::DefId,\n                                      substs_fn: SubstsFn)\n-                                     -> (Rc<ty::TraitRef<'tcx>>,\n+                                     -> (ty::TraitRef<'tcx>,\n                                          Vec<PredicateObligation<'tcx>>)\n {\n     let impl_substs =\n@@ -341,5 +340,3 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n     }\n }\n-\n-"}, {"sha": "79d08cd825d8842e8bc17e6d12d93af45f18a2bd", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -56,7 +56,12 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n {\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-    if !predicate.references_error() {\n+    // The ty_err created by normalize_to_error can end up being unified\n+    // into all obligations: for example, if our obligation is something\n+    // like `$X = <() as Foo<$X>>::Out` and () does not implement Foo<_>,\n+    // then $X will be unified with ty_err, but the error still needs to be\n+    // reported.\n+    if !infcx.tcx.sess.has_errors() || !predicate.references_error() {\n         span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n                 \"type mismatch resolving `{}`: {}\",\n                 predicate.user_string(infcx.tcx),\n@@ -183,15 +188,16 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             let trait_predicate =\n                                 infcx.resolve_type_vars_if_possible(trait_predicate);\n \n-                            if !trait_predicate.references_error() {\n+                            if !infcx.tcx.sess.has_errors() ||\n+                               !trait_predicate.references_error() {\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n                                 span_err!(infcx.tcx.sess, obligation.cause.span, E0277,\n                                         \"the trait `{}` is not implemented for the type `{}`\",\n                                         trait_ref.user_string(infcx.tcx),\n                                         trait_ref.self_ty().user_string(infcx.tcx));\n                                 // Check if it has a custom \"#[rustc_on_unimplemented]\"\n                                 // error message, report with that message if it does\n-                                let custom_note = report_on_unimplemented(infcx, &*trait_ref.0,\n+                                let custom_note = report_on_unimplemented(infcx, &trait_ref.0,\n                                                                           obligation.cause.span);\n                                 if let Some(s) = custom_note {\n                                     infcx.tcx.sess.span_note(obligation.cause.span,\n@@ -290,7 +296,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     {\n                         span_err!(infcx.tcx.sess, obligation.cause.span, E0282,\n                                 \"unable to infer enough type information about `{}`; \\\n-                                 type annotations required\",\n+                                 type annotations or generic parameter binding required\",\n                                 self_ty.user_string(infcx.tcx));\n                     } else {\n                         span_err!(infcx.tcx.sess, obligation.cause.span, E0283,"}, {"sha": "ac3c9dfbb463b3a1d0fba2d88e6aaed6431d8cbc", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -57,20 +57,18 @@ pub fn is_object_safe<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             -> bool\n {\n     // Because we query yes/no results frequently, we keep a cache:\n-    let cached_result =\n-        tcx.object_safety_cache.borrow().get(&trait_def_id).cloned();\n+    let def = ty::lookup_trait_def(tcx, trait_def_id);\n \n-    let result =\n-        cached_result.unwrap_or_else(|| {\n-            let result = object_safety_violations(tcx, trait_def_id).is_empty();\n+    let result = def.object_safety().unwrap_or_else(|| {\n+        let result = object_safety_violations(tcx, trait_def_id).is_empty();\n \n-            // Record just a yes/no result in the cache; this is what is\n-            // queried most frequently. Note that this may overwrite a\n-            // previous result, but always with the same thing.\n-            tcx.object_safety_cache.borrow_mut().insert(trait_def_id, result);\n+        // Record just a yes/no result in the cache; this is what is\n+        // queried most frequently. Note that this may overwrite a\n+        // previous result, but always with the same thing.\n+        def.set_object_safety(result);\n \n-            result\n-        });\n+        result\n+    });\n \n     debug!(\"is_object_safe({}) = {}\", trait_def_id.repr(tcx), result);\n "}, {"sha": "f6bde80e29875ce2b6df67793adcaaca9ef08a64", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -25,7 +25,6 @@ use middle::subst::{Subst, Substs};\n use middle::ty::{self, AsPredicate, ReferencesError, RegionEscape,\n                  HasProjectionTypes, ToPolyTraitRef, Ty};\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::parse::token;\n use util::common::FN_OUTPUT_NAME;\n@@ -409,7 +408,10 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n }\n \n /// in various error cases, we just set ty_err and return an obligation\n-/// that, when fulfilled, will lead to an error\n+/// that, when fulfilled, will lead to an error.\n+///\n+/// FIXME: the ty_err created here can enter the obligation we create,\n+/// leading to error messages involving ty_err.\n fn normalize_to_error<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                projection_ty: ty::ProjectionTy<'tcx>,\n                                cause: ObligationCause<'tcx>,\n@@ -525,7 +527,7 @@ fn project_type<'cx,'tcx>(\n fn assemble_candidates_from_param_env<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n     let env_predicates = selcx.param_env().caller_bounds.clone();\n@@ -546,7 +548,7 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n fn assemble_candidates_from_trait_def<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n     // Check whether the self-type is itself a projection.\n@@ -571,7 +573,7 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n fn assemble_candidates_from_predicates<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     env_predicates: Vec<ty::Predicate<'tcx>>)\n {\n@@ -614,7 +616,7 @@ fn assemble_candidates_from_predicates<'cx,'tcx>(\n fn assemble_candidates_from_object_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n     object_ty: Ty<'tcx>)\n {\n@@ -641,7 +643,7 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n fn assemble_candidates_from_impls<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n     -> Result<(), SelectionError<'tcx>>\n {"}, {"sha": "49371eae2652d78c00c0860daa73f53b3d56109a", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -89,7 +89,7 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n \n #[derive(Clone)]\n pub struct SelectionCache<'tcx> {\n-    hashmap: RefCell<FnvHashMap<Rc<ty::TraitRef<'tcx>>,\n+    hashmap: RefCell<FnvHashMap<ty::TraitRef<'tcx>,\n                                 SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n }\n \n@@ -988,7 +988,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn match_projection(&mut self,\n                         obligation: &TraitObligation<'tcx>,\n                         trait_bound: ty::PolyTraitRef<'tcx>,\n-                        skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                        skol_trait_ref: ty::TraitRef<'tcx>,\n                         skol_map: &infer::SkolemizationMap,\n                         snapshot: &infer::CombinedSnapshot)\n                         -> bool\n@@ -1153,18 +1153,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         debug!(\"assemble_candidates_from_impls(obligation={})\", obligation.repr(self.tcx()));\n \n-        let def_id = obligation.predicate.def_id();\n-        let all_impls = self.all_impls(def_id);\n-        for &impl_def_id in &all_impls {\n-            self.infcx.probe(|snapshot| {\n-                match self.match_impl(impl_def_id, obligation, snapshot) {\n-                    Ok(_) => {\n+        let def = ty::lookup_trait_def(self.tcx(), obligation.predicate.def_id());\n+\n+        def.for_each_relevant_impl(\n+            self.tcx(),\n+            obligation.predicate.0.trait_ref.self_ty(),\n+            |impl_def_id| {\n+                self.infcx.probe(|snapshot| {\n+                    if let Ok(_) = self.match_impl(impl_def_id, obligation, snapshot) {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n                     }\n-                    Err(()) => { }\n-                }\n-            });\n-        }\n+                });\n+            }\n+        );\n \n         Ok(())\n     }\n@@ -2324,7 +2325,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Before we create the substitutions and everything, first\n         // consider a \"quick reject\". This avoids creating more types\n         // and so forth that we need to.\n-        if self.fast_reject_trait_refs(obligation, &*impl_trait_ref) {\n+        if self.fast_reject_trait_refs(obligation, &impl_trait_ref) {\n             return Err(());\n         }\n \n@@ -2529,16 +2530,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    /// Returns set of all impls for a given trait.\n-    fn all_impls(&self, trait_def_id: ast::DefId) -> Vec<ast::DefId> {\n-        ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_def_id);\n-\n-        match self.tcx().trait_impls.borrow().get(&trait_def_id) {\n-            None => Vec::new(),\n-            Some(impls) => impls.borrow().clone(),\n-        }\n-    }\n-\n     fn closure_trait_ref(&self,\n                          obligation: &TraitObligation<'tcx>,\n                          closure_def_id: ast::DefId,"}, {"sha": "a6b2359c2b877b88625661f5ee4a3eaad612af3b", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -12,7 +12,6 @@ use middle::subst::{Substs, VecPerParamSpace};\n use middle::infer::InferCtxt;\n use middle::ty::{self, Ty, AsPredicate, ToPolyTraitRef};\n use std::fmt;\n-use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::Span;\n use util::common::ErrorReported;\n@@ -336,14 +335,14 @@ pub fn trait_ref_for_builtin_bound<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     param_ty: Ty<'tcx>)\n-    -> Result<Rc<ty::TraitRef<'tcx>>, ErrorReported>\n+    -> Result<ty::TraitRef<'tcx>, ErrorReported>\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n-            Ok(Rc::new(ty::TraitRef {\n+            Ok(ty::TraitRef {\n                 def_id: def_id,\n                 substs: tcx.mk_substs(Substs::empty().with_self_ty(param_ty))\n-            }))\n+            })\n         }\n         Err(e) => {\n             tcx.sess.err(&e);\n@@ -355,7 +354,7 @@ pub fn trait_ref_for_builtin_bound<'tcx>(\n \n pub fn predicate_for_trait_ref<'tcx>(\n     cause: ObligationCause<'tcx>,\n-    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    trait_ref: ty::TraitRef<'tcx>,\n     recursion_depth: usize)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n@@ -374,10 +373,10 @@ pub fn predicate_for_trait_def<'tcx>(\n     param_ty: Ty<'tcx>)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n-    let trait_ref = Rc::new(ty::TraitRef {\n+    let trait_ref = ty::TraitRef {\n         def_id: trait_def_id,\n         substs: tcx.mk_substs(Substs::empty().with_self_ty(param_ty))\n-    });\n+    };\n     predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n }\n \n@@ -466,17 +465,17 @@ pub fn closure_trait_ref_and_return_type<'tcx>(\n     self_ty: Ty<'tcx>,\n     sig: &ty::PolyFnSig<'tcx>,\n     tuple_arguments: TupleArgumentsFlag)\n-    -> ty::Binder<(Rc<ty::TraitRef<'tcx>>, Ty<'tcx>)>\n+    -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)>\n {\n     let arguments_tuple = match tuple_arguments {\n         TupleArgumentsFlag::No => sig.0.inputs[0],\n         TupleArgumentsFlag::Yes => ty::mk_tup(tcx, sig.0.inputs.to_vec()),\n     };\n     let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n-    let trait_ref = Rc::new(ty::TraitRef {\n+    let trait_ref = ty::TraitRef {\n         def_id: fn_trait_def_id,\n         substs: tcx.mk_substs(trait_substs),\n-    });\n+    };\n     ty::Binder((trait_ref, sig.0.output.unwrap_or(ty::mk_nil(tcx))))\n }\n "}, {"sha": "cb069acdfd2f0c6aa04afb12330a821477c0ea6c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 189, "deletions": 111, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -45,6 +45,7 @@ use middle::check_const;\n use middle::const_eval;\n use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n+use middle::fast_reject;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::mem_categorization as mc;\n@@ -433,7 +434,7 @@ pub struct MethodParam<'tcx> {\n     // be a supertrait of what the user actually typed. Note that it\n     // never contains bound regions; those regions should have been\n     // instantiated with fresh variables at this point.\n-    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    pub trait_ref: ty::TraitRef<'tcx>,\n \n     // index of usize in the list of trait items. Note that this is NOT\n     // the index into the vtable, because the list of trait items\n@@ -451,7 +452,7 @@ pub struct MethodParam<'tcx> {\n #[derive(Clone, Debug)]\n pub struct MethodObject<'tcx> {\n     // the (super)trait containing the method to be invoked\n-    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    pub trait_ref: TraitRef<'tcx>,\n \n     // the actual base trait id of the object\n     pub object_trait_id: ast::DefId,\n@@ -588,10 +589,14 @@ pub struct TransmuteRestriction<'tcx> {\n \n /// Internal storage\n pub struct CtxtArenas<'tcx> {\n+    // internings\n     type_: TypedArena<TyS<'tcx>>,\n     substs: TypedArena<Substs<'tcx>>,\n     bare_fn: TypedArena<BareFnTy<'tcx>>,\n     region: TypedArena<Region>,\n+\n+    // references\n+    trait_defs: TypedArena<TraitDef<'tcx>>\n }\n \n impl<'tcx> CtxtArenas<'tcx> {\n@@ -601,6 +606,8 @@ impl<'tcx> CtxtArenas<'tcx> {\n             substs: TypedArena::new(),\n             bare_fn: TypedArena::new(),\n             region: TypedArena::new(),\n+\n+            trait_defs: TypedArena::new()\n         }\n     }\n }\n@@ -678,10 +685,10 @@ pub struct ctxt<'tcx> {\n     /// A cache for the trait_items() routine\n     pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ImplOrTraitItem<'tcx>>>>>,\n \n-    pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::TraitRef<'tcx>>>>>,\n+    pub impl_trait_cache: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n \n-    pub impl_trait_refs: RefCell<NodeMap<Rc<TraitRef<'tcx>>>>,\n-    pub trait_defs: RefCell<DefIdMap<Rc<TraitDef<'tcx>>>>,\n+    pub impl_trait_refs: RefCell<NodeMap<TraitRef<'tcx>>>,\n+    pub trait_defs: RefCell<DefIdMap<&'tcx TraitDef<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated predicates.\n@@ -731,12 +738,6 @@ pub struct ctxt<'tcx> {\n     /// A method will be in this list if and only if it is a destructor.\n     pub destructors: RefCell<DefIdSet>,\n \n-    /// Maps a trait onto a list of impls of that trait.\n-    pub trait_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n-\n-    /// A set of traits that have a default impl\n-    traits_with_default_impls: RefCell<DefIdMap<()>>,\n-\n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n@@ -760,12 +761,8 @@ pub struct ctxt<'tcx> {\n     /// The set of external nominal types whose implementations have been read.\n     /// This is used for lazy resolution of methods.\n     pub populated_external_types: RefCell<DefIdSet>,\n-\n-    /// The set of external traits whose implementations have been read. This\n-    /// is used for lazy resolution of traits.\n-    pub populated_external_traits: RefCell<DefIdSet>,\n-\n-    /// The set of external primitive inherent implementations that have been read.\n+    /// The set of external primitive types whose implementations have been read.\n+    /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n \n     /// Borrows\n@@ -819,9 +816,6 @@ pub struct ctxt<'tcx> {\n     /// results are dependent on the parameter environment.\n     pub type_impls_sized_cache: RefCell<HashMap<Ty<'tcx>,bool>>,\n \n-    /// Caches whether traits are object safe\n-    pub object_safety_cache: RefCell<DefIdMap<bool>>,\n-\n     /// Maps Expr NodeId's to their constant qualification.\n     pub const_qualif_map: RefCell<NodeMap<check_const::ConstQualif>>,\n }\n@@ -832,6 +826,13 @@ impl<'tcx> ctxt<'tcx> {\n         self.node_types.borrow_mut().insert(id, ty);\n     }\n \n+    pub fn intern_trait_def(&self, def: TraitDef<'tcx>) -> &'tcx TraitDef<'tcx> {\n+        let did = def.trait_ref.def_id;\n+        let interned = self.arenas.trait_defs.alloc(def);\n+        self.trait_defs.borrow_mut().insert(did, interned);\n+        interned\n+    }\n+\n     pub fn store_free_region_map(&self, id: NodeId, map: FreeRegionMap) {\n         self.free_region_maps.borrow_mut()\n                              .insert(id, map);\n@@ -848,7 +849,6 @@ impl<'tcx> ctxt<'tcx> {\n // recursing over the type itself.\n bitflags! {\n     flags TypeFlags: u32 {\n-        const NO_TYPE_FLAGS     = 0,\n         const HAS_PARAMS        = 1 << 0,\n         const HAS_SELF          = 1 << 1,\n         const HAS_TY_INFER      = 1 << 2,\n@@ -953,6 +953,7 @@ impl fmt::Debug for TypeFlags {\n }\n \n impl<'tcx> PartialEq for TyS<'tcx> {\n+    #[inline]\n     fn eq(&self, other: &TyS<'tcx>) -> bool {\n         // (self as *const _) == (other as *const _)\n         (self as *const TyS<'tcx>) == (other as *const TyS<'tcx>)\n@@ -1414,10 +1415,10 @@ impl<'tcx> TyTrait<'tcx> {\n         // otherwise the escaping regions would be captured by the binder\n         assert!(!self_ty.has_escaping_regions());\n \n-        ty::Binder(Rc::new(ty::TraitRef {\n+        ty::Binder(TraitRef {\n             def_id: self.principal.0.def_id,\n             substs: tcx.mk_substs(self.principal.0.substs.with_self_ty(self_ty)),\n-        }))\n+        })\n     }\n \n     pub fn projection_bounds_with_self_ty(&self,\n@@ -1432,9 +1433,8 @@ impl<'tcx> TyTrait<'tcx> {\n             .map(|in_poly_projection_predicate| {\n                 let in_projection_ty = &in_poly_projection_predicate.0.projection_ty;\n                 let substs = tcx.mk_substs(in_projection_ty.trait_ref.substs.with_self_ty(self_ty));\n-                let trait_ref =\n-                    Rc::new(ty::TraitRef::new(in_projection_ty.trait_ref.def_id,\n-                                              substs));\n+                let trait_ref = ty::TraitRef::new(in_projection_ty.trait_ref.def_id,\n+                                              substs);\n                 let projection_ty = ty::ProjectionTy {\n                     trait_ref: trait_ref,\n                     item_name: in_projection_ty.item_name\n@@ -1463,13 +1463,13 @@ impl<'tcx> TyTrait<'tcx> {\n /// Note that a `TraitRef` introduces a level of region binding, to\n /// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n /// U>` or higher-ranked object types.\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n }\n \n-pub type PolyTraitRef<'tcx> = Binder<Rc<TraitRef<'tcx>>>;\n+pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n \n impl<'tcx> PolyTraitRef<'tcx> {\n     pub fn self_ty(&self) -> Ty<'tcx> {\n@@ -1907,7 +1907,7 @@ pub enum Predicate<'tcx> {\n }\n \n impl<'tcx> Predicate<'tcx> {\n-    /// Performs a substituion suitable for going from a\n+    /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n     /// poly-trait-ref holds. This is slightly different from a normal\n     /// substitution in terms of what happens with bound regions.  See\n@@ -1995,7 +1995,7 @@ impl<'tcx> Predicate<'tcx> {\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TraitPredicate<'tcx> {\n-    pub trait_ref: Rc<TraitRef<'tcx>>\n+    pub trait_ref: TraitRef<'tcx>\n }\n pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n \n@@ -2064,7 +2064,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ProjectionTy<'tcx> {\n     /// The trait reference `T as Trait<..>`.\n-    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    pub trait_ref: ty::TraitRef<'tcx>,\n \n     /// The name `N` of the associated type.\n     pub item_name: ast::Name,\n@@ -2080,7 +2080,7 @@ pub trait ToPolyTraitRef<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx>;\n }\n \n-impl<'tcx> ToPolyTraitRef<'tcx> for Rc<TraitRef<'tcx>> {\n+impl<'tcx> ToPolyTraitRef<'tcx> for TraitRef<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx> {\n         assert!(!self.has_escaping_regions());\n         ty::Binder(self.clone())\n@@ -2108,7 +2108,7 @@ pub trait AsPredicate<'tcx> {\n     fn as_predicate(&self) -> Predicate<'tcx>;\n }\n \n-impl<'tcx> AsPredicate<'tcx> for Rc<TraitRef<'tcx>> {\n+impl<'tcx> AsPredicate<'tcx> for TraitRef<'tcx> {\n     fn as_predicate(&self) -> Predicate<'tcx> {\n         // we're about to add a binder, so let's check that we don't\n         // accidentally capture anything, or else that might be some\n@@ -2488,6 +2488,16 @@ pub struct TypeScheme<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n+bitflags! {\n+    flags TraitFlags: u32 {\n+        const NO_TRAIT_FLAGS        = 0,\n+        const HAS_DEFAULT_IMPL      = 1 << 0,\n+        const IS_OBJECT_SAFE        = 1 << 1,\n+        const OBJECT_SAFETY_VALID   = 1 << 2,\n+        const IMPLS_VALID           = 1 << 3,\n+    }\n+}\n+\n /// As `TypeScheme` but for a trait ref.\n pub struct TraitDef<'tcx> {\n     pub unsafety: ast::Unsafety,\n@@ -2505,11 +2515,117 @@ pub struct TraitDef<'tcx> {\n     /// implements the trait.\n     pub generics: Generics<'tcx>,\n \n-    pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    pub trait_ref: TraitRef<'tcx>,\n \n     /// A list of the associated types defined in this trait. Useful\n     /// for resolving `X::Foo` type markers.\n     pub associated_type_names: Vec<ast::Name>,\n+\n+    // Impls of this trait. To allow for quicker lookup, the impls are indexed\n+    // by a simplified version of their Self type: impls with a simplifiable\n+    // Self are stored in nonblanket_impls keyed by it, while all other impls\n+    // are stored in blanket_impls.\n+\n+    /// Impls of the trait.\n+    pub nonblanket_impls: RefCell<\n+        FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n+    >,\n+\n+    /// Blanket impls associated with the trait.\n+    pub blanket_impls: RefCell<Vec<DefId>>,\n+\n+    /// Various flags\n+    pub flags: Cell<TraitFlags>\n+}\n+\n+impl<'tcx> TraitDef<'tcx> {\n+    // returns None if not yet calculated\n+    pub fn object_safety(&self) -> Option<bool> {\n+        if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n+            Some(self.flags.get().intersects(TraitFlags::IS_OBJECT_SAFE))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn set_object_safety(&self, is_safe: bool) {\n+        assert!(self.object_safety().map(|cs| cs == is_safe).unwrap_or(true));\n+        self.flags.set(\n+            self.flags.get() | if is_safe {\n+                TraitFlags::OBJECT_SAFETY_VALID | TraitFlags::IS_OBJECT_SAFE\n+            } else {\n+                TraitFlags::OBJECT_SAFETY_VALID\n+            }\n+        );\n+    }\n+\n+    /// Records a trait-to-implementation mapping.\n+    pub fn record_impl(&self,\n+                       tcx: &ctxt<'tcx>,\n+                       impl_def_id: DefId,\n+                       impl_trait_ref: TraitRef<'tcx>) {\n+        // We don't want to borrow_mut after we already populated all impls,\n+        // so check if an impl is present with an immutable borrow first.\n+\n+        if let Some(sty) = fast_reject::simplify_type(tcx,\n+                                                      impl_trait_ref.self_ty(), false) {\n+            if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n+                if is.contains(&impl_def_id) {\n+                    return // duplicate - skip\n+                }\n+            }\n+\n+            self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n+        } else {\n+            if self.blanket_impls.borrow().contains(&impl_def_id) {\n+                return // duplicate - skip\n+            }\n+            self.blanket_impls.borrow_mut().push(impl_def_id)\n+        }\n+    }\n+\n+\n+    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &ctxt<'tcx>, mut f: F)  {\n+        ty::populate_implementations_for_trait_if_necessary(tcx, self.trait_ref.def_id);\n+\n+        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+            f(impl_def_id);\n+        }\n+\n+        for v in self.nonblanket_impls.borrow().values() {\n+            for &impl_def_id in v {\n+                f(impl_def_id);\n+            }\n+        }\n+    }\n+\n+    pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n+                                                   tcx: &ctxt<'tcx>,\n+                                                   self_ty: Ty<'tcx>,\n+                                                   mut f: F)\n+    {\n+        ty::populate_implementations_for_trait_if_necessary(tcx, self.trait_ref.def_id);\n+\n+        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+            f(impl_def_id);\n+        }\n+\n+        if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, false) {\n+            if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n+                for &impl_def_id in impls {\n+                    f(impl_def_id);\n+                }\n+                return; // we don't need to process the other non-blanket impls\n+            }\n+        }\n+\n+        for v in self.nonblanket_impls.borrow().values() {\n+            for &impl_def_id in v {\n+                f(impl_def_id);\n+            }\n+        }\n+    }\n+\n }\n \n /// Records the substitutions used to translate the polytype for an\n@@ -2669,14 +2785,11 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         struct_fields: RefCell::new(DefIdMap()),\n         destructor_for_type: RefCell::new(DefIdMap()),\n         destructors: RefCell::new(DefIdSet()),\n-        trait_impls: RefCell::new(DefIdMap()),\n-        traits_with_default_impls: RefCell::new(DefIdMap()),\n         inherent_impls: RefCell::new(DefIdMap()),\n         impl_items: RefCell::new(DefIdMap()),\n         used_unsafe: RefCell::new(NodeSet()),\n         used_mut_nodes: RefCell::new(NodeSet()),\n         populated_external_types: RefCell::new(DefIdSet()),\n-        populated_external_traits: RefCell::new(DefIdSet()),\n         populated_external_primitive_impls: RefCell::new(DefIdSet()),\n         upvar_capture_map: RefCell::new(FnvHashMap()),\n         extern_const_statics: RefCell::new(DefIdMap()),\n@@ -2693,7 +2806,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         repr_hint_cache: RefCell::new(DefIdMap()),\n         type_impls_copy_cache: RefCell::new(HashMap::new()),\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n-        object_safety_cache: RefCell::new(DefIdMap()),\n         const_qualif_map: RefCell::new(NodeMap()),\n    }\n }\n@@ -2812,7 +2924,7 @@ struct FlagComputation {\n \n impl FlagComputation {\n     fn new() -> FlagComputation {\n-        FlagComputation { flags: TypeFlags::NO_TYPE_FLAGS, depth: 0 }\n+        FlagComputation { flags: TypeFlags::empty(), depth: 0 }\n     }\n \n     fn for_sty(st: &sty) -> FlagComputation {\n@@ -3132,7 +3244,7 @@ pub fn sort_bounds_list(bounds: &mut [ty::PolyProjectionPredicate]) {\n }\n \n pub fn mk_projection<'tcx>(cx: &ctxt<'tcx>,\n-                           trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                           trait_ref: TraitRef<'tcx>,\n                            item_name: ast::Name)\n                            -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n@@ -3490,12 +3602,10 @@ def_type_content_sets! {\n         // Things that are owned by the value (second and third nibbles):\n         OwnsOwned                           = 0b0000_0000__0000_0001__0000,\n         OwnsDtor                            = 0b0000_0000__0000_0010__0000,\n-        OwnsManaged /* see [1] below */     = 0b0000_0000__0000_0100__0000,\n         OwnsAll                             = 0b0000_0000__1111_1111__0000,\n \n         // Things that are reachable by the value in any way (fourth nibble):\n         ReachesBorrowed                     = 0b0000_0010__0000_0000__0000,\n-        // ReachesManaged /* see [1] below */  = 0b0000_0100__0000_0000__0000,\n         ReachesMutable                      = 0b0000_1000__0000_0000__0000,\n         ReachesFfiUnsafe                    = 0b0010_0000__0000_0000__0000,\n         ReachesAll                          = 0b0011_1111__0000_0000__0000,\n@@ -3506,13 +3616,6 @@ def_type_content_sets! {\n         // Things that prevent values from being considered sized\n         Nonsized                            = 0b0000_0000__0000_0000__0001,\n \n-        // Bits to set when a managed value is encountered\n-        //\n-        // [1] Do not set the bits TC::OwnsManaged or\n-        //     TC::ReachesManaged directly, instead reference\n-        //     TC::Managed to set them both at once.\n-        Managed                             = 0b0000_0100__0000_0100__0000,\n-\n         // All bits\n         All                                 = 0b1111_1111__1111_1111__1111\n     }\n@@ -3527,10 +3630,6 @@ impl TypeContents {\n         (self.bits & tc.bits) != 0\n     }\n \n-    pub fn owns_managed(&self) -> bool {\n-        self.intersects(TC::OwnsManaged)\n-    }\n-\n     pub fn owns_owned(&self) -> bool {\n         self.intersects(TC::OwnsOwned)\n     }\n@@ -3567,12 +3666,6 @@ impl TypeContents {\n             *self & TC::ReachesAll)\n     }\n \n-    /// Includes only those bits that still apply when indirected through a managed pointer (`@`)\n-    pub fn managed_pointer(&self) -> TypeContents {\n-        TC::Managed | (\n-            *self & TC::ReachesAll)\n-    }\n-\n     /// Includes only those bits that still apply when indirected through an unsafe pointer (`*`)\n     pub fn unsafe_pointer(&self) -> TypeContents {\n         *self & TC::ReachesAll\n@@ -3817,9 +3910,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n \n     fn apply_lang_items(cx: &ctxt, did: ast::DefId, tc: TypeContents)\n                         -> TypeContents {\n-        if Some(did) == cx.lang_items.managed_bound() {\n-            tc | TC::Managed\n-        } else if Some(did) == cx.lang_items.unsafe_cell_type() {\n+        if Some(did) == cx.lang_items.unsafe_cell_type() {\n             tc | TC::InteriorUnsafe\n         } else {\n             tc\n@@ -4398,9 +4489,9 @@ pub fn named_element_ty<'tcx>(cx: &ctxt<'tcx>,\n }\n \n pub fn impl_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n-                                  -> Rc<ty::TraitRef<'tcx>> {\n+                                  -> ty::TraitRef<'tcx> {\n     match cx.impl_trait_refs.borrow().get(&id) {\n-        Some(ty) => ty.clone(),\n+        Some(ty) => *ty,\n         None => cx.sess.bug(\n             &format!(\"impl_id_to_trait_ref: no trait ref for impl `{}`\",\n                     cx.map.node_to_string(id)))\n@@ -4539,7 +4630,7 @@ pub fn expr_ty_opt<'tcx>(cx: &ctxt<'tcx>, expr: &ast::Expr) -> Option<Ty<'tcx>>\n /// require serializing and deserializing the type and, although that's not\n /// hard to do, I just hate that code so much I didn't want to touch it\n /// unless it was to fix it properly, which seemed a distraction from the\n-/// task at hand! -nmatsakis\n+/// thread at hand! -nmatsakis\n pub fn expr_ty_adjusted<'tcx>(cx: &ctxt<'tcx>, expr: &ast::Expr) -> Ty<'tcx> {\n     adjust_ty(cx, expr.span, expr.id, expr_ty(cx, expr),\n               cx.adjustments.borrow().get(&expr.id),\n@@ -5313,7 +5404,7 @@ pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n }\n \n pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n-                            -> Option<Rc<TraitRef<'tcx>>> {\n+                            -> Option<TraitRef<'tcx>> {\n     memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n             debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n@@ -5732,8 +5823,10 @@ fn compute_enum_variants<'tcx>(cx: &ctxt<'tcx>,\n                     Ok(const_eval::const_int(val)) => current_disr_val = val as Disr,\n                     Ok(const_eval::const_uint(val)) => current_disr_val = val as Disr,\n                     Ok(_) => {\n+                        let sign_desc = if repr_type.is_signed() { \"signed\" } else { \"unsigned\" };\n                         span_err!(cx.sess, e.span, E0079,\n-                                  \"expected signed integer constant\");\n+                                  \"expected {} integer constant\",\n+                                  sign_desc);\n                         current_disr_val = attempt_fresh_value();\n                     }\n                     Err(ref err) => {\n@@ -5819,10 +5912,10 @@ pub fn lookup_item_type<'tcx>(cx: &ctxt<'tcx>,\n \n /// Given the did of a trait, returns its canonical trait ref.\n pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n-                              -> Rc<TraitDef<'tcx>> {\n+                              -> &'tcx TraitDef<'tcx> {\n     memoized(&cx.trait_defs, did, |did: DefId| {\n         assert!(did.krate != ast::LOCAL_CRATE);\n-        Rc::new(csearch::get_trait_def(cx, did))\n+        cx.arenas.trait_defs.alloc(csearch::get_trait_def(cx, did))\n     })\n }\n \n@@ -6211,50 +6304,36 @@ pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n \n pub fn trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) -> bool {\n     populate_implementations_for_trait_if_necessary(tcx, trait_def_id);\n-    tcx.traits_with_default_impls.borrow().contains_key(&trait_def_id)\n-}\n \n-/// Records a trait-to-implementation mapping.\n-pub fn record_trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) {\n-    // We're using the latest implementation found as the reference one.\n-    // Duplicated implementations are caught and reported in the coherence\n-    // step.\n-    tcx.traits_with_default_impls.borrow_mut().insert(trait_def_id, ());\n+    let def = lookup_trait_def(tcx, trait_def_id);\n+    def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n }\n \n /// Records a trait-to-implementation mapping.\n-pub fn record_trait_implementation(tcx: &ctxt,\n-                                   trait_def_id: DefId,\n-                                   impl_def_id: DefId) {\n-\n-    match tcx.trait_impls.borrow().get(&trait_def_id) {\n-        Some(impls_for_trait) => {\n-            impls_for_trait.borrow_mut().push(impl_def_id);\n-            return;\n-        }\n-        None => {}\n-    }\n-\n-    tcx.trait_impls.borrow_mut().insert(trait_def_id, Rc::new(RefCell::new(vec!(impl_def_id))));\n+pub fn record_trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) {\n+    let def = lookup_trait_def(tcx, trait_def_id);\n+    def.flags.set(def.flags.get() | TraitFlags::HAS_DEFAULT_IMPL)\n }\n \n /// Load primitive inherent implementations if necessary\n-pub fn populate_implementations_for_primitive_if_necessary(tcx: &ctxt, lang_def_id: ast::DefId) {\n-    if lang_def_id.krate == LOCAL_CRATE {\n+pub fn populate_implementations_for_primitive_if_necessary(tcx: &ctxt,\n+                                                           primitive_def_id: ast::DefId) {\n+    if primitive_def_id.krate == LOCAL_CRATE {\n         return\n     }\n-    if tcx.populated_external_primitive_impls.borrow().contains(&lang_def_id) {\n+\n+    if tcx.populated_external_primitive_impls.borrow().contains(&primitive_def_id) {\n         return\n     }\n \n-    debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\", lang_def_id);\n+    debug!(\"populate_implementations_for_primitive_if_necessary: searching for {:?}\",\n+           primitive_def_id);\n \n-    let impl_items = csearch::get_impl_items(&tcx.sess.cstore, lang_def_id);\n+    let impl_items = csearch::get_impl_items(&tcx.sess.cstore, primitive_def_id);\n \n     // Store the implementation info.\n-    tcx.impl_items.borrow_mut().insert(lang_def_id, impl_items);\n-\n-    tcx.populated_external_primitive_impls.borrow_mut().insert(lang_def_id);\n+    tcx.impl_items.borrow_mut().insert(primitive_def_id, impl_items);\n+    tcx.populated_external_primitive_impls.borrow_mut().insert(primitive_def_id);\n }\n \n /// Populates the type context with all the implementations for the given type\n@@ -6264,6 +6343,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n     if type_id.krate == LOCAL_CRATE {\n         return\n     }\n+\n     if tcx.populated_external_types.borrow().contains(&type_id) {\n         return\n     }\n@@ -6274,10 +6354,12 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n     csearch::each_implementation_for_type(&tcx.sess.cstore, type_id, |impl_def_id| {\n         let impl_items = csearch::get_impl_items(&tcx.sess.cstore, impl_def_id);\n \n-        // Record the trait->implementation mappings, if applicable.\n-        let associated_traits = csearch::get_impl_trait(tcx, impl_def_id);\n-        if let Some(ref trait_ref) = associated_traits {\n-            record_trait_implementation(tcx, trait_ref.def_id, impl_def_id);\n+        // Record the implementation, if needed\n+        if let Some(trait_ref) = csearch::get_impl_trait(tcx, impl_def_id) {\n+            let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n+            trait_def.record_impl(tcx, impl_def_id, trait_ref);\n+        } else {\n+            inherent_impls.push(impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n@@ -6298,11 +6380,6 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n \n         // Store the implementation info.\n         tcx.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n-\n-        // If this is an inherent implementation, record it.\n-        if associated_traits.is_none() {\n-            inherent_impls.push(impl_def_id);\n-        }\n     });\n \n     tcx.inherent_impls.borrow_mut().insert(type_id, Rc::new(inherent_impls));\n@@ -6318,7 +6395,8 @@ pub fn populate_implementations_for_trait_if_necessary(\n         return\n     }\n \n-    if tcx.populated_external_traits.borrow().contains(&trait_id) {\n+    let def = lookup_trait_def(tcx, trait_id);\n+    if def.flags.get().intersects(TraitFlags::IMPLS_VALID) {\n         return\n     }\n \n@@ -6328,9 +6406,9 @@ pub fn populate_implementations_for_trait_if_necessary(\n \n     csearch::each_implementation_for_trait(&tcx.sess.cstore, trait_id, |implementation_def_id| {\n         let impl_items = csearch::get_impl_items(&tcx.sess.cstore, implementation_def_id);\n-\n+        let trait_ref = impl_trait_ref(tcx, implementation_def_id).unwrap();\n         // Record the trait->implementation mapping.\n-        record_trait_implementation(tcx, trait_id, implementation_def_id);\n+        def.record_impl(tcx, implementation_def_id, trait_ref);\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate.\n@@ -6352,7 +6430,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n         tcx.impl_items.borrow_mut().insert(implementation_def_id, impl_items);\n     });\n \n-    tcx.populated_external_traits.borrow_mut().insert(trait_id);\n+    def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n }\n \n /// Given the def_id of an impl, return the def_id of the trait it implements."}, {"sha": "0ef7b5be1fbd805377471a6ed68d90be58bff8d0", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -321,8 +321,8 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionTy<'tcx> {\n             Err(ty::terr_projection_name_mismatched(\n                 expected_found(relation, &a.item_name, &b.item_name)))\n         } else {\n-            let trait_ref = try!(relation.relate(&*a.trait_ref, &*b.trait_ref));\n-            Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n+            let trait_ref = try!(relation.relate(&a.trait_ref, &b.trait_ref));\n+            Ok(ty::ProjectionTy { trait_ref: trait_ref, item_name: a.item_name })\n         }\n     }\n }\n@@ -652,4 +652,3 @@ pub fn expected_found_bool<T>(a_is_expected: bool,\n         ty::expected_found {expected: b, found: a}\n     }\n }\n-"}, {"sha": "4ea331f68987e96210c216cefca6680213d57e2d", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -131,7 +131,7 @@ impl<'a> PluginLoader<'a> {\n \n             // Intentionally leak the dynamic library. We can't ever unload it\n             // since the library can make things that will live arbitrarily long\n-            // (e.g. an @-box cycle or a task).\n+            // (e.g. an @-box cycle or a thread).\n             mem::forget(lib);\n \n             registrar"}, {"sha": "7a8ce1bf48e47d283e7e285315987658c5073d4e", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -46,8 +46,9 @@ pub struct Session {\n     pub entry_type: Cell<Option<config::EntryFnType>>,\n     pub plugin_registrar_fn: Cell<Option<ast::NodeId>>,\n     pub default_sysroot: Option<PathBuf>,\n-    // The name of the root source file of the crate, in the local file system. The path is always\n-    // expected to be absolute. `None` means that there is no source file.\n+    // The name of the root source file of the crate, in the local file system.\n+    // The path is always expected to be absolute. `None` means that there is no\n+    // source file.\n     pub local_crate_source_file: Option<PathBuf>,\n     pub working_dir: PathBuf,\n     pub lint_store: RefCell<lint::LintStore>,"}, {"sha": "3ae78fa7c19048157619e40d683735edc823ce42", "filename": "src/librustc/util/fs.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Futil%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Futil%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Ffs.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::path::{self, Path, PathBuf};\n+use std::ffi::OsString;\n+\n+// Unfortunately, on windows, gcc cannot accept paths of the form `\\\\?\\C:\\...`\n+// (a verbatim path). This form of path is generally pretty rare, but the\n+// implementation of `fs::canonicalize` currently generates paths of this form,\n+// meaning that we're going to be passing quite a few of these down to gcc.\n+//\n+// For now we just strip the \"verbatim prefix\" of `\\\\?\\` from the path. This\n+// will probably lose information in some cases, but there's not a whole lot\n+// more we can do with a buggy gcc...\n+pub fn fix_windows_verbatim_for_gcc(p: &Path) -> PathBuf {\n+    if !cfg!(windows) {\n+        return p.to_path_buf()\n+    }\n+    let mut components = p.components();\n+    let prefix = match components.next() {\n+        Some(path::Component::Prefix(p)) => p,\n+        _ => return p.to_path_buf(),\n+    };\n+    let disk = match prefix.kind() {\n+        path::Prefix::VerbatimDisk(disk) => disk,\n+        _ => return p.to_path_buf(),\n+    };\n+    let mut base = OsString::from(format!(\"{}:\", disk as char));\n+    base.push(components.as_path());\n+    PathBuf::from(base)\n+}"}, {"sha": "aa89c1943a2e3855feb1f772995bf35ca77665f4", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -671,7 +671,7 @@ impl<'tcx> Repr<'tcx> for def::Def {\n /// projection bounds, so we just stuff them altogether. But in\n /// reality we should eventually sort things out better.\n type TraitAndProjections<'tcx> =\n-    (Rc<ty::TraitRef<'tcx>>, Vec<ty::ProjectionPredicate<'tcx>>);\n+    (ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n \n impl<'tcx> UserString<'tcx> for TraitAndProjections<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {"}, {"sha": "0073c0b061039806ff2503071d7eb167b18b8108", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -479,7 +479,8 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             let mut _old_path = OsString::new();\n             if cfg!(windows) {\n                 _old_path = env::var_os(\"PATH\").unwrap_or(_old_path);\n-                let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n+                let mut new_path = sess.host_filesearch(PathKind::All)\n+                                       .get_dylib_search_paths();\n                 new_path.extend(env::split_paths(&_old_path));\n                 env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n             }\n@@ -871,11 +872,8 @@ pub fn collect_crate_types(session: &Session,\n                     None\n                 }\n                 _ => {\n-                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPES,\n-                                     ast::CRATE_NODE_ID,\n-                                     a.span,\n-                                     \"`crate_type` requires a \\\n-                                      value\".to_string());\n+                    session.span_err(a.span, \"`crate_type` requires a value\");\n+                    session.note(\"for example: `#![crate_type=\\\"lib\\\"]`\");\n                     None\n                 }\n             }"}, {"sha": "a618f4b6ef675fe3f193cff07e48a41012e0597f", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -852,11 +852,11 @@ pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n     use syntax::diagnostics::registry::Registry;\n \n-    let all_errors = Vec::new() +\n-        &rustc::DIAGNOSTICS[..] +\n-        &rustc_typeck::DIAGNOSTICS[..] +\n-        &rustc_borrowck::DIAGNOSTICS[..] +\n-        &rustc_resolve::DIAGNOSTICS[..];\n+    let mut all_errors = Vec::new();\n+    all_errors.push_all(&rustc::DIAGNOSTICS);\n+    all_errors.push_all(&rustc_typeck::DIAGNOSTICS);\n+    all_errors.push_all(&rustc_borrowck::DIAGNOSTICS);\n+    all_errors.push_all(&rustc_resolve::DIAGNOSTICS);\n \n     Registry::new(&*all_errors)\n }"}, {"sha": "8d555240e707b31751facd1d4c5f8fbca1e010eb", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 75, "deletions": 10, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -1745,17 +1745,16 @@ impl LintPass for MissingDebugImplementations {\n         };\n \n         if self.impling_types.is_none() {\n-            let impls = cx.tcx.trait_impls.borrow();\n-            let impls = match impls.get(&debug) {\n-                Some(impls) => {\n-                    impls.borrow().iter()\n-                         .filter(|d| d.krate == ast::LOCAL_CRATE)\n-                         .filter_map(|d| ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)))\n-                         .map(|d| d.node)\n-                         .collect()\n+            let debug_def = ty::lookup_trait_def(cx.tcx, debug);\n+            let mut impls = NodeSet();\n+            debug_def.for_each_impl(cx.tcx, |d| {\n+                if d.krate == ast::LOCAL_CRATE {\n+                    if let Some(ty_def) = ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)) {\n+                        impls.insert(ty_def.node);\n+                    }\n                 }\n-                None => NodeSet(),\n-            };\n+            });\n+\n             self.impling_types = Some(impls);\n             debug!(\"{:?}\", self.impling_types);\n         }\n@@ -2122,6 +2121,72 @@ impl LintPass for InvalidNoMangleItems {\n     }\n }\n \n+#[derive(Clone, Copy)]\n+pub struct MutableTransmutes;\n+\n+declare_lint! {\n+    MUTABLE_TRANSMUTES,\n+    Deny,\n+    \"mutating transmuted &mut T from &T may cause undefined behavior\"\n+}\n+\n+impl LintPass for MutableTransmutes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(MUTABLE_TRANSMUTES)\n+    }\n+\n+    fn check_expr(&mut self, cx: &Context, expr: &ast::Expr) {\n+        use syntax::ast::DefId;\n+        use syntax::abi::RustIntrinsic;\n+        let msg = \"mutating transmuted &mut T from &T may cause undefined behavior,\\\n+                   consider instead using an UnsafeCell\";\n+        match get_transmute_from_to(cx, expr) {\n+            Some((&ty::ty_rptr(_, from_mt), &ty::ty_rptr(_, to_mt))) => {\n+                if to_mt.mutbl == ast::Mutability::MutMutable\n+                    && from_mt.mutbl == ast::Mutability::MutImmutable {\n+                    cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n+                }\n+            }\n+            _ => ()\n+        }\n+\n+        fn get_transmute_from_to<'a, 'tcx>(cx: &Context<'a, 'tcx>, expr: &ast::Expr)\n+            -> Option<(&'tcx ty::sty<'tcx>, &'tcx ty::sty<'tcx>)> {\n+            match expr.node {\n+                ast::ExprPath(..) => (),\n+                _ => return None\n+            }\n+            if let DefFn(did, _) = ty::resolve_expr(cx.tcx, expr) {\n+                if !def_id_is_transmute(cx, did) {\n+                    return None;\n+                }\n+                let typ = ty::node_id_to_type(cx.tcx, expr.id);\n+                match typ.sty {\n+                    ty::ty_bare_fn(_, ref bare_fn) if bare_fn.abi == RustIntrinsic => {\n+                        if let ty::FnConverging(to) = bare_fn.sig.0.output {\n+                            let from = bare_fn.sig.0.inputs[0];\n+                            return Some((&from.sty, &to.sty));\n+                        }\n+                    },\n+                    _ => ()\n+                }\n+            }\n+            None\n+        }\n+\n+        fn def_id_is_transmute(cx: &Context, def_id: DefId) -> bool {\n+            match ty::lookup_item_type(cx.tcx, def_id).ty.sty {\n+                ty::ty_bare_fn(_, ref bfty) if bfty.abi == RustIntrinsic => (),\n+                _ => return false\n+            }\n+            ty::with_path(cx.tcx, def_id, |path| match path.last() {\n+                Some(ref last) => last.name().as_str() == \"transmute\",\n+                _ => false\n+            })\n+        }\n+    }\n+}\n+\n /// Forbids using the `#[feature(...)]` attribute\n #[derive(Copy, Clone)]\n pub struct UnstableFeatures;"}, {"sha": "df834c36e5b225262d13ccd18d3b941cb7f336a0", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -109,6 +109,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  InvalidNoMangleItems,\n                  PluginAsLibrary,\n                  DropWithReprExtern,\n+                 MutableTransmutes,\n                  );\n \n     add_builtin_with_new!(sess,"}, {"sha": "2a2aa2bf4cf93dcfc530e7e0504a4703ef050a4a", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -125,32 +125,32 @@ pub enum DiagnosticSeverity {\n \n bitflags! {\n     flags Attribute : u32 {\n-        const ZExtAttribute            = 1 << 0,\n-        const SExtAttribute            = 1 << 1,\n-        const NoReturnAttribute        = 1 << 2,\n-        const InRegAttribute           = 1 << 3,\n-        const StructRetAttribute       = 1 << 4,\n-        const NoUnwindAttribute        = 1 << 5,\n-        const NoAliasAttribute         = 1 << 6,\n-        const ByValAttribute           = 1 << 7,\n-        const NestAttribute            = 1 << 8,\n-        const ReadNoneAttribute        = 1 << 9,\n-        const ReadOnlyAttribute        = 1 << 10,\n-        const NoInlineAttribute        = 1 << 11,\n-        const AlwaysInlineAttribute    = 1 << 12,\n-        const OptimizeForSizeAttribute = 1 << 13,\n-        const StackProtectAttribute    = 1 << 14,\n-        const StackProtectReqAttribute = 1 << 15,\n-        const AlignmentAttribute       = 1 << 16,\n-        const NoCaptureAttribute       = 1 << 21,\n-        const NoRedZoneAttribute       = 1 << 22,\n-        const NoImplicitFloatAttribute = 1 << 23,\n-        const NakedAttribute           = 1 << 24,\n-        const InlineHintAttribute      = 1 << 25,\n-        const StackAttribute           = 7 << 26,\n-        const ReturnsTwiceAttribute    = 1 << 29,\n-        const UWTableAttribute         = 1 << 30,\n-        const NonLazyBindAttribute     = 1 << 31,\n+        const ZExt            = 1 << 0,\n+        const SExt            = 1 << 1,\n+        const NoReturn        = 1 << 2,\n+        const InReg           = 1 << 3,\n+        const StructRet       = 1 << 4,\n+        const NoUnwind        = 1 << 5,\n+        const NoAlias         = 1 << 6,\n+        const ByVal           = 1 << 7,\n+        const Nest            = 1 << 8,\n+        const ReadNone        = 1 << 9,\n+        const ReadOnly        = 1 << 10,\n+        const NoInline        = 1 << 11,\n+        const AlwaysInline    = 1 << 12,\n+        const OptimizeForSize = 1 << 13,\n+        const StackProtect    = 1 << 14,\n+        const StackProtectReq = 1 << 15,\n+        const Alignment       = 1 << 16,\n+        const NoCapture       = 1 << 21,\n+        const NoRedZone       = 1 << 22,\n+        const NoImplicitFloat = 1 << 23,\n+        const Naked           = 1 << 24,\n+        const InlineHint      = 1 << 25,\n+        const Stack           = 7 << 26,\n+        const ReturnsTwice    = 1 << 29,\n+        const UWTable         = 1 << 30,\n+        const NonLazyBind     = 1 << 31,\n     }\n }\n "}, {"sha": "a11b0f69faadfda251ed502393d2d58d142474f8", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -26,13 +26,14 @@ use middle::ty::{self, Ty};\n use util::common::time;\n use util::ppaux;\n use util::sha2::{Digest, Sha256};\n+use util::fs::fix_windows_verbatim_for_gcc;\n use rustc_back::tempdir::TempDir;\n \n use std::ffi::OsString;\n use std::fs::{self, PathExt};\n use std::io::{self, Read, Write};\n use std::mem;\n-use std::path::{self, Path, PathBuf};\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::str;\n use flate;\n@@ -1078,7 +1079,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n     sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, k| {\n         match k {\n             PathKind::Framework => { cmd.arg(\"-F\").arg(path); }\n-            _ => { cmd.arg(\"-L\").arg(path); }\n+            _ => { cmd.arg(\"-L\").arg(&fix_windows_verbatim_for_gcc(path)); }\n         }\n         FileDoesntMatch\n     });\n@@ -1333,29 +1334,3 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n         }\n     }\n }\n-\n-// Unfortunately, on windows, gcc cannot accept paths of the form `\\\\?\\C:\\...`\n-// (a verbatim path). This form of path is generally pretty rare, but the\n-// implementation of `fs::canonicalize` currently generates paths of this form,\n-// meaning that we're going to be passing quite a few of these down to gcc.\n-//\n-// For now we just strip the \"verbatim prefix\" of `\\\\?\\` from the path. This\n-// will probably lose information in some cases, but there's not a whole lot\n-// more we can do with a buggy gcc...\n-fn fix_windows_verbatim_for_gcc(p: &Path) -> PathBuf {\n-    if !cfg!(windows) {\n-        return p.to_path_buf()\n-    }\n-    let mut components = p.components();\n-    let prefix = match components.next() {\n-        Some(path::Component::Prefix(p)) => p,\n-        _ => return p.to_path_buf(),\n-    };\n-    let disk = match prefix.kind() {\n-        path::Prefix::VerbatimDisk(disk) => disk,\n-        _ => return p.to_path_buf(),\n-    };\n-    let mut base = OsString::from(format!(\"{}:\", disk as char));\n-    base.push(components.as_path());\n-    PathBuf::from(base)\n-}"}, {"sha": "a10ff71a8f689d400f4b565109ac3649ab9fac01", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -86,8 +86,8 @@ struct Diagnostic {\n }\n \n // We use an Arc instead of just returning a list of diagnostics from the\n-// child task because we need to make sure that the messages are seen even\n-// if the child task panics (for example, when `fatal` is called).\n+// child thread because we need to make sure that the messages are seen even\n+// if the child thread panics (for example, when `fatal` is called).\n #[derive(Clone)]\n struct SharedEmitter {\n     buffer: Arc<Mutex<Vec<Diagnostic>>>,\n@@ -637,7 +637,7 @@ pub fn run_passes(sess: &Session,\n     metadata_config.set_flags(sess, trans);\n \n \n-    // Populate a buffer with a list of codegen tasks.  Items are processed in\n+    // Populate a buffer with a list of codegen threads.  Items are processed in\n     // LIFO order, just because it's a tiny bit simpler that way.  (The order\n     // doesn't actually matter.)\n     let mut work_items = Vec::with_capacity(1 + trans.modules.len());"}, {"sha": "84d464e8f07814d4f72d12ec6f7d5a55625c0ac0", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -210,6 +210,7 @@ use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::expr::{self, Dest};\n+use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n use middle::ty::{self, Ty};\n@@ -1076,9 +1077,39 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let adt_vals = if any_irrefutable_adt_pat(bcx.tcx(), m, col) {\n         let repr = adt::represent_type(bcx.ccx(), left_ty);\n         let arg_count = adt::num_args(&*repr, 0);\n-        let field_vals: Vec<ValueRef> = (0..arg_count).map(|ix|\n-            adt::trans_field_ptr(bcx, &*repr, val, 0, ix)\n+        let (arg_count, struct_val) = if type_is_sized(bcx.tcx(), left_ty) {\n+            (arg_count, val)\n+        } else {\n+            // For an unsized ADT (i.e. DST struct), we need to treat\n+            // the last field specially: instead of simply passing a\n+            // ValueRef pointing to that field, as with all the others,\n+            // we skip it and instead construct a 'fat ptr' below.\n+            (arg_count - 1, Load(bcx, expr::get_dataptr(bcx, val)))\n+        };\n+        let mut field_vals: Vec<ValueRef> = (0..arg_count).map(|ix|\n+            adt::trans_field_ptr(bcx, &*repr, struct_val, 0, ix)\n         ).collect();\n+\n+        match left_ty.sty {\n+            ty::ty_struct(def_id, substs) if !type_is_sized(bcx.tcx(), left_ty) => {\n+                // The last field is technically unsized but\n+                // since we can only ever match that field behind\n+                // a reference we construct a fat ptr here.\n+                let fields = ty::lookup_struct_fields(bcx.tcx(), def_id);\n+                let unsized_ty = fields.iter().last().map(|field| {\n+                    let fty = ty::lookup_field_type(bcx.tcx(), def_id, field.id, substs);\n+                    monomorphize::normalize_associated_type(bcx.tcx(), &fty)\n+                }).unwrap();\n+                let llty = type_of::type_of(bcx.ccx(), unsized_ty);\n+                let scratch = alloca_no_lifetime(bcx, llty, \"__struct_field_fat_ptr\");\n+                let data = adt::trans_field_ptr(bcx, &*repr, struct_val, 0, arg_count);\n+                let len = Load(bcx, expr::get_len(bcx, val));\n+                Store(bcx, data, expr::get_dataptr(bcx, scratch));\n+                Store(bcx, len, expr::get_len(bcx, scratch));\n+                field_vals.push(scratch);\n+            }\n+            _ => {}\n+        }\n         Some(field_vals)\n     } else if any_uniq_pat(m, col) || any_region_pat(m, col) {\n         Some(vec!(Load(bcx, val)))"}, {"sha": "b32181426a33ef1f54db016f6af539c47fca669d", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -39,13 +39,13 @@ pub fn split_stack(val: ValueRef, set: bool) {\n pub fn inline(val: ValueRef, inline: InlineAttr) {\n     use self::InlineAttr::*;\n     match inline {\n-        Hint   => llvm::SetFunctionAttribute(val, llvm::Attribute::InlineHintAttribute),\n-        Always => llvm::SetFunctionAttribute(val, llvm::Attribute::AlwaysInlineAttribute),\n-        Never  => llvm::SetFunctionAttribute(val, llvm::Attribute::NoInlineAttribute),\n+        Hint   => llvm::SetFunctionAttribute(val, llvm::Attribute::InlineHint),\n+        Always => llvm::SetFunctionAttribute(val, llvm::Attribute::AlwaysInline),\n+        Never  => llvm::SetFunctionAttribute(val, llvm::Attribute::NoInline),\n         None   => {\n-            let attr = llvm::Attribute::InlineHintAttribute |\n-                       llvm::Attribute::AlwaysInlineAttribute |\n-                       llvm::Attribute::NoInlineAttribute;\n+            let attr = llvm::Attribute::InlineHint |\n+                       llvm::Attribute::AlwaysInline |\n+                       llvm::Attribute::NoInline;\n             unsafe {\n                 llvm::LLVMRemoveFunctionAttr(val, attr.bits() as c_ulonglong)\n             }\n@@ -57,12 +57,12 @@ pub fn inline(val: ValueRef, inline: InlineAttr) {\n #[inline]\n pub fn emit_uwtable(val: ValueRef, emit: bool) {\n     if emit {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::UWTableAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::UWTable);\n     } else {\n         unsafe {\n             llvm::LLVMRemoveFunctionAttr(\n                 val,\n-                llvm::Attribute::UWTableAttribute.bits() as c_ulonglong,\n+                llvm::Attribute::UWTable.bits() as c_ulonglong,\n             );\n         }\n     }\n@@ -76,11 +76,11 @@ pub fn unwind(val: ValueRef, can_unwind: bool) {\n         unsafe {\n             llvm::LLVMRemoveFunctionAttr(\n                 val,\n-                llvm::Attribute::NoUnwindAttribute.bits() as c_ulonglong,\n+                llvm::Attribute::NoUnwind.bits() as c_ulonglong,\n             );\n         }\n     } else {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::NoUnwindAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::NoUnwind);\n     }\n }\n \n@@ -89,12 +89,12 @@ pub fn unwind(val: ValueRef, can_unwind: bool) {\n #[allow(dead_code)] // possibly useful function\n pub fn set_optimize_for_size(val: ValueRef, optimize: bool) {\n     if optimize {\n-        llvm::SetFunctionAttribute(val, llvm::Attribute::OptimizeForSizeAttribute);\n+        llvm::SetFunctionAttribute(val, llvm::Attribute::OptimizeForSize);\n     } else {\n         unsafe {\n             llvm::LLVMRemoveFunctionAttr(\n                 val,\n-                llvm::Attribute::OptimizeForSizeAttribute.bits() as c_ulonglong,\n+                llvm::Attribute::OptimizeForSize.bits() as c_ulonglong,\n             );\n         }\n     }\n@@ -116,7 +116,7 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n                                                llvm::ColdAttribute as u64)\n             }\n         } else if attr.check_name(\"allocator\") {\n-            llvm::Attribute::NoAliasAttribute.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n+            llvm::Attribute::NoAlias.apply_llfn(llvm::ReturnIndex as c_uint, llfn);\n         }\n     }\n }\n@@ -185,9 +185,9 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             // The outptr can be noalias and nocapture because it's entirely\n             // invisible to the program. We also know it's nonnull as well\n             // as how many bytes we can dereference\n-            attrs.arg(1, llvm::Attribute::StructRetAttribute)\n-                 .arg(1, llvm::Attribute::NoAliasAttribute)\n-                 .arg(1, llvm::Attribute::NoCaptureAttribute)\n+            attrs.arg(1, llvm::Attribute::StructRet)\n+                 .arg(1, llvm::Attribute::NoAlias)\n+                 .arg(1, llvm::Attribute::NoCapture)\n                  .arg(1, llvm::DereferenceableAttribute(llret_sz));\n \n             // Add one more since there's an outptr\n@@ -199,7 +199,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // `~` pointer return values never alias because ownership\n                 // is transferred\n                 ty::ty_uniq(it) if common::type_is_sized(ccx.tcx(), it) => {\n-                    attrs.ret(llvm::Attribute::NoAliasAttribute);\n+                    attrs.ret(llvm::Attribute::NoAlias);\n                 }\n                 _ => {}\n             }\n@@ -216,7 +216,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             }\n \n             if let ty::ty_bool = ret_ty.sty {\n-                attrs.ret(llvm::Attribute::ZExtAttribute);\n+                attrs.ret(llvm::Attribute::ZExt);\n             }\n         }\n     }\n@@ -230,20 +230,20 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 // For non-immediate arguments the callee gets its own copy of\n                 // the value on the stack, so there are no aliases. It's also\n                 // program-invisible so can't possibly capture\n-                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n-                     .arg(idx, llvm::Attribute::NoCaptureAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAlias)\n+                     .arg(idx, llvm::Attribute::NoCapture)\n                      .arg(idx, llvm::DereferenceableAttribute(llarg_sz));\n             }\n \n             ty::ty_bool => {\n-                attrs.arg(idx, llvm::Attribute::ZExtAttribute);\n+                attrs.arg(idx, llvm::Attribute::ZExt);\n             }\n \n             // `~` pointer parameters never alias because ownership is transferred\n             ty::ty_uniq(inner) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n \n-                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAlias)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n \n@@ -256,23 +256,23 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                                   !ty::type_contents(ccx.tcx(), mt.ty).interior_unsafe() => {\n \n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::Attribute::NoAliasAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoAlias)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n \n                 if mt.mutbl == ast::MutImmutable {\n-                    attrs.arg(idx, llvm::Attribute::ReadOnlyAttribute);\n+                    attrs.arg(idx, llvm::Attribute::ReadOnly);\n                 }\n \n                 if let ReLateBound(_, BrAnon(_)) = *b {\n-                    attrs.arg(idx, llvm::Attribute::NoCaptureAttribute);\n+                    attrs.arg(idx, llvm::Attribute::NoCapture);\n                 }\n             }\n \n             // When a reference in an argument has no named lifetime, it's impossible for that\n             // reference to escape this function (returned or stored beyond the call by a closure).\n             ty::ty_rptr(&ReLateBound(_, BrAnon(_)), mt) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n-                attrs.arg(idx, llvm::Attribute::NoCaptureAttribute)\n+                attrs.arg(idx, llvm::Attribute::NoCapture)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));\n             }\n "}, {"sha": "f2434ceee2b857ee5e5fd09c3bf6037c4a55ccd3", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -163,7 +163,7 @@ fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n@@ -185,12 +185,12 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         };\n         return ArgType::direct(ty, Some(llty), None, None);\n     }\n-    ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n+    ArgType::indirect(ty, Some(Attribute::StructRet))\n }\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {"}, {"sha": "c5116e738048d1f3341a034cbcd1d7f7f61679d8", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -131,7 +131,7 @@ fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let size = ty_size(ty, align_fn);\n@@ -145,12 +145,12 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType\n         };\n         return ArgType::direct(ty, Some(llty), None, None);\n     }\n-    ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n+    ArgType::indirect(ty, Some(Attribute::StructRet))\n }\n \n fn classify_arg_ty(ccx: &CrateContext, ty: Type, align_fn: TyAlignFn) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n     let align = align_fn(ty);"}, {"sha": "bcffb238f5950c6d1251402a9b63f941dc635152", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -88,10 +88,10 @@ fn ty_size(ty: Type) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n-        ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n+        ArgType::indirect(ty, Some(Attribute::StructRet))\n     }\n }\n \n@@ -105,7 +105,7 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct("}, {"sha": "1bcc8fd6bbb90e5133e416bf7712022e1b56d8c6", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -84,10 +84,10 @@ fn ty_size(ty: Type) -> usize {\n \n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n-        ArgType::indirect(ty, Some(Attribute::StructRetAttribute))\n+        ArgType::indirect(ty, Some(Attribute::StructRet))\n     }\n }\n \n@@ -101,7 +101,7 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType\n     *offset += align_up_to(size, align * 8) / 8;\n \n     if is_reg_ty(ty) {\n-        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         ArgType::direct(ty, None, None, attr)\n     } else {\n         ArgType::direct("}, {"sha": "50a3095dea16970d43c4b350255728c10e2897b4", "filename": "src/librustc_trans/trans/cabi_x86.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -52,11 +52,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 ret_ty = ArgType::direct(rty, Some(t), None, None);\n             }\n             RetPointer => {\n-                ret_ty = ArgType::indirect(rty, Some(Attribute::StructRetAttribute));\n+                ret_ty = ArgType::indirect(rty, Some(Attribute::StructRet));\n             }\n         }\n     } else {\n-        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n@@ -67,11 +67,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                 if size == 0 {\n                     ArgType::ignore(t)\n                 } else {\n-                    ArgType::indirect(t, Some(Attribute::ByValAttribute))\n+                    ArgType::indirect(t, Some(Attribute::ByVal))\n                 }\n             }\n             _ => {\n-                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n                 ArgType::direct(t, None, None, attr)\n             }\n         };"}, {"sha": "b64e24591fd98b9ec8d90a8b32990b2a724348dd", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -406,19 +406,19 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                                 None)\n             }\n         } else {\n-            let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+            let attr = if ty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n             ArgType::direct(ty, None, None, attr)\n         }\n     }\n \n     let mut arg_tys = Vec::new();\n     for t in atys {\n-        let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), Attribute::ByValAttribute);\n+        let ty = x86_64_ty(ccx, *t, |cls| cls.is_pass_byval(), Attribute::ByVal);\n         arg_tys.push(ty);\n     }\n \n     let ret_ty = if ret_def {\n-        x86_64_ty(ccx, rty, |cls| cls.is_ret_bysret(), Attribute::StructRetAttribute)\n+        x86_64_ty(ccx, rty, |cls| cls.is_ret_bysret(), Attribute::StructRet)\n     } else {\n         ArgType::direct(Type::void(ccx), None, None, None)\n     };"}, {"sha": "262dcc4705961018d21369027ed396f630ff7ec7", "filename": "src/librustc_trans/trans/cabi_x86_win64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_win64.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -31,10 +31,10 @@ pub fn compute_abi_info(ccx: &CrateContext,\n             2 => ArgType::direct(rty, Some(Type::i16(ccx)), None, None),\n             4 => ArgType::direct(rty, Some(Type::i32(ccx)), None, None),\n             8 => ArgType::direct(rty, Some(Type::i64(ccx)), None, None),\n-            _ => ArgType::indirect(rty, Some(Attribute::StructRetAttribute))\n+            _ => ArgType::indirect(rty, Some(Attribute::StructRet))\n         };\n     } else {\n-        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+        let attr = if rty == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n         ret_ty = ArgType::direct(rty, None, None, attr);\n     }\n \n@@ -46,11 +46,11 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                     2 => ArgType::direct(rty, Some(Type::i16(ccx)), None, None),\n                     4 => ArgType::direct(rty, Some(Type::i32(ccx)), None, None),\n                     8 => ArgType::direct(rty, Some(Type::i64(ccx)), None, None),\n-                    _ => ArgType::indirect(t, Some(Attribute::ByValAttribute))\n+                    _ => ArgType::indirect(t, Some(Attribute::ByVal))\n                 }\n             }\n             _ => {\n-                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExtAttribute) } else { None };\n+                let attr = if t == Type::i1(ccx) { Some(Attribute::ZExt) } else { None };\n                 ArgType::direct(t, None, None, attr)\n             }\n         };"}, {"sha": "e87c058faf9c19b3626b5a77b3673e9a8ff56b74", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -452,7 +452,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n                     // Compute the first substitution\n                     let first_subst =\n-                        ty::make_substs_for_receiver_types(tcx, &*trait_ref, &*method)\n+                        ty::make_substs_for_receiver_types(tcx, &trait_ref, &*method)\n                         .erase_regions();\n \n                     // And compose them"}, {"sha": "d23543924dd397d6c82f9619315d53ad9e9a563f", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -507,23 +507,6 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         self.schedule_clean(cleanup_scope, drop as CleanupObj);\n     }\n \n-    /// Schedules a call to `free(val)`. Note that this is a shallow operation.\n-    fn schedule_free_slice(&self,\n-                           cleanup_scope: ScopeId,\n-                           val: ValueRef,\n-                           size: ValueRef,\n-                           align: ValueRef,\n-                           heap: Heap) {\n-        let drop = box FreeSlice { ptr: val, size: size, align: align, heap: heap };\n-\n-        debug!(\"schedule_free_slice({:?}, val={}, heap={:?})\",\n-               cleanup_scope,\n-               self.ccx.tn().val_to_string(val),\n-               heap);\n-\n-        self.schedule_clean(cleanup_scope, drop as CleanupObj);\n-    }\n-\n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n                       cleanup: CleanupObj<'tcx>) {\n@@ -1106,43 +1089,6 @@ impl<'tcx> Cleanup<'tcx> for FreeValue<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-pub struct FreeSlice {\n-    ptr: ValueRef,\n-    size: ValueRef,\n-    align: ValueRef,\n-    heap: Heap,\n-}\n-\n-impl<'tcx> Cleanup<'tcx> for FreeSlice {\n-    fn must_unwind(&self) -> bool {\n-        true\n-    }\n-\n-    fn clean_on_unwind(&self) -> bool {\n-        true\n-    }\n-\n-    fn is_lifetime_end(&self) -> bool {\n-        false\n-    }\n-\n-    fn trans<'blk>(&self,\n-                   bcx: Block<'blk, 'tcx>,\n-                   debug_loc: DebugLoc)\n-                   -> Block<'blk, 'tcx> {\n-        match self.heap {\n-            HeapExchange => {\n-                glue::trans_exchange_free_dyn(bcx,\n-                                              self.ptr,\n-                                              self.size,\n-                                              self.align,\n-                                              debug_loc)\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone)]\n pub struct LifetimeEnd {\n     ptr: ValueRef,\n@@ -1253,12 +1199,6 @@ pub trait CleanupMethods<'blk, 'tcx> {\n                            val: ValueRef,\n                            heap: Heap,\n                            content_ty: Ty<'tcx>);\n-    fn schedule_free_slice(&self,\n-                           cleanup_scope: ScopeId,\n-                           val: ValueRef,\n-                           size: ValueRef,\n-                           align: ValueRef,\n-                           heap: Heap);\n     fn schedule_clean(&self,\n                       cleanup_scope: ScopeId,\n                       cleanup: CleanupObj<'tcx>);"}, {"sha": "03dda57e5689fab9d4112575892d0f4dd662a040", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -147,7 +147,7 @@ pub fn type_is_fat_ptr<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n // Some things don't need cleanups during unwinding because the\n-// task can free them all at once later. Currently only things\n+// thread can free them all at once later. Currently only things\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n pub fn type_needs_unwind_cleanup<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {"}, {"sha": "503bdf8dadb94635c654ec1d95a0b5b6f75d62f5", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -186,7 +186,7 @@ fn get_const_val(ccx: &CrateContext,\n                  ref_expr: &ast::Expr) -> ValueRef {\n     let expr = get_const_expr(ccx, def_id, ref_expr);\n     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-    get_const_expr_as_global(ccx, expr, check_const::ConstQualif::PURE_CONST, empty_substs)\n+    get_const_expr_as_global(ccx, expr, check_const::ConstQualif::empty(), empty_substs)\n }\n \n pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "7849235fdbee5b9e044eeeafef632edf2c6063f9", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -71,12 +71,12 @@ pub fn declare_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n     llvm::SetUnnamedAddr(llfn, true);\n \n     if output == ty::FnDiverging {\n-        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturnAttribute);\n+        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturn);\n     }\n \n     if ccx.tcx().sess.opts.cg.no_redzone\n         .unwrap_or(ccx.tcx().sess.target.target.options.disable_redzone) {\n-        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoRedZoneAttribute)\n+        llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoRedZone)\n     }\n \n     if ccx.is_split_stack_supported() && !ccx.sess().opts.cg.no_stack_check {"}, {"sha": "7be1f3813d72fc6a75cd21a16311c7e71da48609", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -86,7 +86,6 @@ use syntax::ptr::P;\n use syntax::parse::token;\n use std::iter::repeat;\n use std::mem;\n-use std::rc::Rc;\n \n // Destinations\n \n@@ -320,8 +319,8 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n             // Note that we preserve binding levels here:\n             let substs = principal.0.substs.with_self_ty(source).erase_regions();\n             let substs = ccx.tcx().mk_substs(substs);\n-            let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: principal.def_id(),\n-                                                               substs: substs }));\n+            let trait_ref = ty::Binder(ty::TraitRef { def_id: principal.def_id(),\n+                                                      substs: substs });\n             consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n                             Type::vtable_ptr(ccx))\n         }"}, {"sha": "95c93d76585bfc5a7348b992b32ebc01bd10c053", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -349,8 +349,8 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // The outptr can be noalias and nocapture because it's entirely\n         // invisible to the program. We also know it's nonnull as well\n         // as how many bytes we can dereference\n-        attrs.arg(1, llvm::Attribute::NoAliasAttribute)\n-             .arg(1, llvm::Attribute::NoCaptureAttribute)\n+        attrs.arg(1, llvm::Attribute::NoAlias)\n+             .arg(1, llvm::Attribute::NoCapture)\n              .arg(1, llvm::DereferenceableAttribute(llret_sz));\n     };\n "}, {"sha": "4b1bdd63dd732f5117882b01dbd5e5921e8f898c", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -387,10 +387,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n             C_bool(ccx, bcx.fcx.type_needs_drop(tp_ty))\n         }\n-        (_, \"owns_managed\") => {\n-            let tp_ty = *substs.types.get(FnSpace, 0);\n-            C_bool(ccx, ty::type_contents(ccx.tcx(), tp_ty).owns_managed())\n-        }\n         (_, \"offset\") => {\n             let ptr = llargs[0];\n             let offset = llargs[1];"}, {"sha": "7039968b029ac776284dfcc55ec7449f0c5c884e", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -40,7 +40,6 @@ use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use util::ppaux::Repr;\n \n-use std::rc::Rc;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n use syntax::{ast, ast_map, attr, visit};\n@@ -232,8 +231,8 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                              Vec::new()));\n     let trait_substs = tcx.mk_substs(trait_substs);\n     debug!(\"trait_substs={}\", trait_substs.repr(tcx));\n-    let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: trait_id,\n-                                                      substs: trait_substs }));\n+    let trait_ref = ty::Binder(ty::TraitRef { def_id: trait_id,\n+                                              substs: trait_substs });\n     let vtbl = fulfill_obligation(ccx,\n                                   DUMMY_SP,\n                                   trait_ref);"}, {"sha": "677254238c03498143cda5e658a8c1c22bb45b98", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -64,7 +64,6 @@ use util::nodemap::FnvHashSet;\n use util::ppaux::{self, Repr, UserString};\n \n use std::iter::repeat;\n-use std::rc::Rc;\n use std::slice;\n use syntax::{abi, ast, ast_util};\n use syntax::codemap::{Span, Pos};\n@@ -83,7 +82,7 @@ pub trait AstConv<'tcx> {\n     /// Returns the `TraitDef` for a given trait. This allows you to\n     /// figure out the set of type parameters defined on the trait.\n     fn get_trait_def(&self, span: Span, id: ast::DefId)\n-                     -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>;\n+                     -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>;\n \n     /// Ensure that the super-predicates for the trait with the given\n     /// id are available and also for the transitive set of\n@@ -140,7 +139,7 @@ pub trait AstConv<'tcx> {\n     /// This is fairly straightforward and can be accommodated in any context.\n     fn projected_ty(&self,\n                     span: Span,\n-                    _trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                    _trait_ref: ty::TraitRef<'tcx>,\n                     _item_name: ast::Name)\n                     -> Ty<'tcx>;\n }\n@@ -633,7 +632,7 @@ pub fn instantiate_mono_trait_ref<'tcx>(\n     rscope: &RegionScope,\n     trait_ref: &ast::TraitRef,\n     self_ty: Option<Ty<'tcx>>)\n-    -> Rc<ty::TraitRef<'tcx>>\n+    -> ty::TraitRef<'tcx>\n {\n     let trait_def_id = trait_def_id(this, trait_ref);\n     ast_path_to_mono_trait_ref(this,\n@@ -702,7 +701,7 @@ fn ast_path_to_poly_trait_ref<'a,'tcx>(\n                                         trait_def_id,\n                                         self_ty,\n                                         trait_segment);\n-    let poly_trait_ref = ty::Binder(Rc::new(ty::TraitRef::new(trait_def_id, substs)));\n+    let poly_trait_ref = ty::Binder(ty::TraitRef::new(trait_def_id, substs));\n \n     {\n         let converted_bindings =\n@@ -730,7 +729,7 @@ fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n                                        trait_def_id: ast::DefId,\n                                        self_ty: Option<Ty<'tcx>>,\n                                        trait_segment: &ast::PathSegment)\n-                                       -> Rc<ty::TraitRef<'tcx>>\n+                                       -> ty::TraitRef<'tcx>\n {\n     let (substs, assoc_bindings) =\n         create_substs_for_ast_trait_ref(this,\n@@ -741,7 +740,7 @@ fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n                                         self_ty,\n                                         trait_segment);\n     prohibit_projections(this.tcx(), &assoc_bindings);\n-    Rc::new(ty::TraitRef::new(trait_def_id, substs))\n+    ty::TraitRef::new(trait_def_id, substs)\n }\n \n fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n@@ -856,8 +855,8 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n         let mut dummy_substs = trait_ref.skip_binder().substs.clone(); // binder moved here -+\n         assert!(dummy_substs.self_ty().is_none());                     //                    |\n         dummy_substs.types.push(SelfSpace, dummy_self_ty);             //                    |\n-        trait_ref = ty::Binder(Rc::new(ty::TraitRef::new(trait_ref.def_id(), // <------------+\n-                                                         tcx.mk_substs(dummy_substs))));\n+        trait_ref = ty::Binder(ty::TraitRef::new(trait_ref.def_id(),   // <------------+\n+                                                 tcx.mk_substs(dummy_substs)));\n     }\n \n     try!(this.ensure_super_predicates(binding.span, trait_ref.def_id()));\n@@ -874,8 +873,8 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n             let mut dummy_substs = candidate.0.substs.clone();\n             assert!(dummy_substs.self_ty() == Some(dummy_self_ty));\n             dummy_substs.types.pop(SelfSpace);\n-            *candidate = ty::Binder(Rc::new(ty::TraitRef::new(candidate.def_id(),\n-                                                              tcx.mk_substs(dummy_substs))));\n+            *candidate = ty::Binder(ty::TraitRef::new(candidate.def_id(),\n+                                                      tcx.mk_substs(dummy_substs)));\n         }\n     }\n \n@@ -1345,7 +1344,7 @@ pub fn ast_ty_arg_to_ty<'tcx>(this: &AstConv<'tcx>,\n }\n \n // Check the base def in a PathResolution and convert it to a Ty. If there are\n-// associated types in the PathResolution, these will need to be seperately\n+// associated types in the PathResolution, these will need to be separately\n // resolved.\n fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                         rscope: &RegionScope,"}, {"sha": "f0495436bc1b2ace335bc82f9d7406f5d0617ae7", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -170,9 +170,10 @@ pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n                 demand::coerce(fcx, e.span, t_1, &e);\n             }\n         }\n-    } else if fcx.type_is_fat_ptr(t_e, span) && !fcx.type_is_fat_ptr(t_1, span) {\n+    } else if fcx.type_is_fat_ptr(t_e, span) != fcx.type_is_fat_ptr(t_1, span) {\n         fcx.type_error_message(span, |actual| {\n-            format!(\"illegal cast; cast from fat pointer: `{}` as `{}`\",\n+            format!(\"illegal cast; cast to or from fat pointer: `{}` as `{}` \\\n+                     involving incompatible type.\",\n                     actual, fcx.infcx().ty_to_string(t_1))\n         }, t_e, None);\n     } else if !(t_e_is_scalar && t_1_is_trivial) {"}, {"sha": "fd90d662bd141d5eb4e9343adc455e8757f39b9a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 153, "deletions": 94, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -396,19 +396,24 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n             }\n         };\n \n-        let opt_type_did = match typ.sty {\n-            ty::ty_struct(struct_did, _) => Some(struct_did),\n-            ty::ty_enum(enum_did, _) => Some(enum_did),\n-            _ => None,\n+        let dtor_kind = match typ.sty {\n+            ty::ty_enum(def_id, _) |\n+            ty::ty_struct(def_id, _) => {\n+                match destructor_for_type.get(&def_id) {\n+                    Some(def_id) => DtorKind::KnownDropMethod(*def_id),\n+                    None => DtorKind::PureRecur,\n+                }\n+            }\n+            ty::ty_trait(ref ty_trait) => {\n+                DtorKind::Unknown(ty_trait.bounds.clone())\n+            }\n+            _ => DtorKind::PureRecur,\n         };\n \n-        let opt_dtor =\n-            opt_type_did.and_then(|did| destructor_for_type.get(&did));\n-\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n-                {}typ: {} scope: {:?} opt_dtor: {:?} xref: {}\",\n+                {}typ: {} scope: {:?} xref: {}\",\n                (0..depth).map(|_| ' ').collect::<String>(),\n-               typ.repr(rcx.tcx()), scope, opt_dtor, xref_depth);\n+               typ.repr(rcx.tcx()), scope, xref_depth);\n \n         // If `typ` has a destructor, then we must ensure that all\n         // borrowed data reachable via `typ` must outlive the parent\n@@ -439,90 +444,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n         // simply skip the `type_must_outlive` call entirely (but\n         // resume the recursive checking of the type-substructure).\n \n-        let has_dtor_of_interest;\n-\n-        if let Some(&dtor_method_did) = opt_dtor {\n-            let impl_did = ty::impl_of_method(rcx.tcx(), dtor_method_did)\n-                .unwrap_or_else(|| {\n-                    rcx.tcx().sess.span_bug(\n-                        span, \"no Drop impl found for drop method\")\n-                });\n-\n-            let dtor_typescheme = ty::lookup_item_type(rcx.tcx(), impl_did);\n-            let dtor_generics = dtor_typescheme.generics;\n-            let dtor_predicates = ty::lookup_predicates(rcx.tcx(), impl_did);\n-\n-            let has_pred_of_interest = dtor_predicates.predicates.iter().any(|pred| {\n-                // In `impl<T> Drop where ...`, we automatically\n-                // assume some predicate will be meaningful and thus\n-                // represents a type through which we could reach\n-                // borrowed data. However, there can be implicit\n-                // predicates (namely for Sized), and so we still need\n-                // to walk through and filter out those cases.\n-\n-                let result = match *pred {\n-                    ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n-                        let def_id = t_pred.trait_ref.def_id;\n-                        match rcx.tcx().lang_items.to_builtin_kind(def_id) {\n-                            // Issue 24895: deliberately do not include `BoundCopy` here.\n-                            Some(ty::BoundSend) |\n-                            Some(ty::BoundSized) |\n-                            Some(ty::BoundSync) => false,\n-                            _ => true,\n-                        }\n-                    }\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::RegionOutlives(..) |\n-                    ty::Predicate::TypeOutlives(..) |\n-                    ty::Predicate::Projection(..) => {\n-                        // we assume all of these where-clauses may\n-                        // give the drop implementation the capabilty\n-                        // to access borrowed data.\n-                        true\n-                    }\n-                };\n-\n-                if result {\n-                    debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n-                           typ.repr(rcx.tcx()), pred.repr(rcx.tcx()));\n-                }\n-\n-                result\n-            });\n-\n-            // In `impl<'a> Drop ...`, we automatically assume\n-            // `'a` is meaningful and thus represents a bound\n-            // through which we could reach borrowed data.\n-            //\n-            // FIXME (pnkfelix): In the future it would be good to\n-            // extend the language to allow the user to express,\n-            // in the impl signature, that a lifetime is not\n-            // actually used (something like `where 'a: ?Live`).\n-            let has_region_param_of_interest =\n-                dtor_generics.has_region_params(subst::TypeSpace);\n-\n-            has_dtor_of_interest =\n-                has_region_param_of_interest ||\n-                has_pred_of_interest;\n-\n-            if has_dtor_of_interest {\n-                debug!(\"typ: {} has interesting dtor, due to \\\n-                        region params: {} or pred: {}\",\n-                       typ.repr(rcx.tcx()),\n-                       has_region_param_of_interest,\n-                       has_pred_of_interest);\n-            } else {\n-                debug!(\"typ: {} has dtor, but it is uninteresting\",\n-                       typ.repr(rcx.tcx()));\n-            }\n-\n-        } else {\n-            debug!(\"typ: {} has no dtor, and thus is uninteresting\",\n-                   typ.repr(rcx.tcx()));\n-            has_dtor_of_interest = false;\n-        }\n-\n-        if has_dtor_of_interest {\n+        if has_dtor_of_interest(rcx.tcx(), dtor_kind, typ, span) {\n             // If `typ` has a destructor, then we must ensure that all\n             // borrowed data reachable via `typ` must outlive the\n             // parent of `scope`. (It does not suffice for it to\n@@ -608,7 +530,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n                 ty::ty_rptr(..) | ty::ty_ptr(_) | ty::ty_bare_fn(..) => {\n                     // Don't recurse, since references, pointers,\n-                    // boxes, and bare functions don't own instances\n+                    // and bare functions don't own instances\n                     // of the types appearing within them.\n                     walker.skip_current_subtree();\n                 }\n@@ -627,3 +549,140 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n     return Ok(());\n }\n+\n+enum DtorKind<'tcx> {\n+    // Type has an associated drop method with this def id\n+    KnownDropMethod(ast::DefId),\n+\n+    // Type has no destructor (or its dtor is known to be pure\n+    // with respect to lifetimes), though its *substructure*\n+    // may carry a destructor.\n+    PureRecur,\n+\n+    // Type may have impure destructor that is unknown;\n+    // e.g. `Box<Trait+'a>`\n+    Unknown(ty::ExistentialBounds<'tcx>),\n+}\n+\n+fn has_dtor_of_interest<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              dtor_kind: DtorKind,\n+                              typ: ty::Ty<'tcx>,\n+                              span: Span) -> bool {\n+    let has_dtor_of_interest: bool;\n+\n+    match dtor_kind {\n+        DtorKind::PureRecur => {\n+            has_dtor_of_interest = false;\n+            debug!(\"typ: {} has no dtor, and thus is uninteresting\",\n+                   typ.repr(tcx));\n+        }\n+        DtorKind::Unknown(bounds) => {\n+            match bounds.region_bound {\n+                ty::ReStatic => {\n+                    debug!(\"trait: {} has 'static bound, and thus is uninteresting\",\n+                           typ.repr(tcx));\n+                    has_dtor_of_interest = false;\n+                }\n+                ty::ReEmpty => {\n+                    debug!(\"trait: {} has empty region bound, and thus is uninteresting\",\n+                           typ.repr(tcx));\n+                    has_dtor_of_interest = false;\n+                }\n+                r => {\n+                    debug!(\"trait: {} has non-static bound: {}; assumed interesting\",\n+                           typ.repr(tcx), r.repr(tcx));\n+                    has_dtor_of_interest = true;\n+                }\n+            }\n+        }\n+        DtorKind::KnownDropMethod(dtor_method_did) => {\n+            let impl_did = ty::impl_of_method(tcx, dtor_method_did)\n+                .unwrap_or_else(|| {\n+                    tcx.sess.span_bug(\n+                        span, \"no Drop impl found for drop method\")\n+                });\n+\n+            let dtor_typescheme = ty::lookup_item_type(tcx, impl_did);\n+            let dtor_generics = dtor_typescheme.generics;\n+\n+            let mut has_pred_of_interest = false;\n+\n+            let mut seen_items = Vec::new();\n+            let mut items_to_inspect = vec![impl_did];\n+            'items: while let Some(item_def_id) = items_to_inspect.pop() {\n+                if seen_items.contains(&item_def_id) {\n+                    continue;\n+                }\n+\n+                for pred in ty::lookup_predicates(tcx, item_def_id).predicates {\n+                    let result = match pred {\n+                        ty::Predicate::Equate(..) |\n+                        ty::Predicate::RegionOutlives(..) |\n+                        ty::Predicate::TypeOutlives(..) |\n+                        ty::Predicate::Projection(..) => {\n+                            // For now, assume all these where-clauses\n+                            // may give drop implementation capabilty\n+                            // to access borrowed data.\n+                            true\n+                        }\n+\n+                        ty::Predicate::Trait(ty::Binder(ref t_pred)) => {\n+                            let def_id = t_pred.trait_ref.def_id;\n+                            if ty::trait_items(tcx, def_id).len() != 0 {\n+                                // If trait has items, assume it adds\n+                                // capability to access borrowed data.\n+                                true\n+                            } else {\n+                                // Trait without items is itself\n+                                // uninteresting from POV of dropck.\n+                                //\n+                                // However, may have parent w/ items;\n+                                // so schedule checking of predicates,\n+                                items_to_inspect.push(def_id);\n+                                // and say \"no capability found\" for now.\n+                                false\n+                            }\n+                        }\n+                    };\n+\n+                    if result {\n+                        has_pred_of_interest = true;\n+                        debug!(\"typ: {} has interesting dtor due to generic preds, e.g. {}\",\n+                               typ.repr(tcx), pred.repr(tcx));\n+                        break 'items;\n+                    }\n+                }\n+\n+                seen_items.push(item_def_id);\n+            }\n+\n+            // In `impl<'a> Drop ...`, we automatically assume\n+            // `'a` is meaningful and thus represents a bound\n+            // through which we could reach borrowed data.\n+            //\n+            // FIXME (pnkfelix): In the future it would be good to\n+            // extend the language to allow the user to express,\n+            // in the impl signature, that a lifetime is not\n+            // actually used (something like `where 'a: ?Live`).\n+            let has_region_param_of_interest =\n+                dtor_generics.has_region_params(subst::TypeSpace);\n+\n+            has_dtor_of_interest =\n+                has_region_param_of_interest ||\n+                has_pred_of_interest;\n+\n+            if has_dtor_of_interest {\n+                debug!(\"typ: {} has interesting dtor, due to \\\n+                        region params: {} or pred: {}\",\n+                       typ.repr(tcx),\n+                       has_region_param_of_interest,\n+                       has_pred_of_interest);\n+            } else {\n+                debug!(\"typ: {} has dtor, but it is uninteresting\",\n+                       typ.repr(tcx));\n+            }\n+        }\n+    }\n+\n+    return has_dtor_of_interest;\n+}"}, {"sha": "c068bfaa82eb74b23ab3f4c9027d625c0c8dbadf", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -23,7 +23,6 @@ use middle::infer;\n use middle::infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::Span;\n-use std::rc::Rc;\n use std::iter::repeat;\n use util::ppaux::Repr;\n \n@@ -276,7 +275,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                                                  self.infcx().next_ty_var());\n \n                 let trait_ref =\n-                    Rc::new(ty::TraitRef::new(trait_def_id, self.tcx().mk_substs(substs.clone())));\n+                    ty::TraitRef::new(trait_def_id, self.tcx().mk_substs(substs.clone()));\n                 let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n                                                            method_num: method_num,\n                                                            impl_def_id: None });"}, {"sha": "c070df6b5939df96a99f307e989ec348b2824f00", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -170,7 +170,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Construct a trait-reference `self_ty : Trait<input_tys>`\n     let substs = subst::Substs::new_trait(input_types, Vec::new(), self_ty);\n-    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, fcx.tcx().mk_substs(substs)));\n+    let trait_ref = ty::TraitRef::new(trait_def_id, fcx.tcx().mk_substs(substs));\n \n     // Construct an obligation\n     let poly_trait_ref = trait_ref.to_poly_trait_ref();"}, {"sha": "c94fa03702681bcb5fdd52131ab98cf7b8489c08", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -61,7 +61,7 @@ struct Candidate<'tcx> {\n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n     ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ usize, /* vtable index */ usize),\n-    ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n+    ExtensionImplCandidate(/* Impl */ ast::DefId, ty::TraitRef<'tcx>,\n                            subst::Substs<'tcx>, ItemIndex),\n     ClosureCandidate(/* Trait */ ast::DefId, ItemIndex),\n     WhereClauseCandidate(ty::PolyTraitRef<'tcx>, ItemIndex),\n@@ -624,23 +624,16 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                      item: ty::ImplOrTraitItem<'tcx>,\n                                                      item_index: usize)\n     {\n-        ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n-                                                            trait_def_id);\n-\n-        let trait_impls = self.tcx().trait_impls.borrow();\n-        let impl_def_ids = trait_impls.get(&trait_def_id);\n-        let impl_def_ids = match impl_def_ids {\n-            None => { return; }\n-            Some(impls) => impls,\n-        };\n+        let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n \n-        for &impl_def_id in &*impl_def_ids.borrow() {\n+        // FIXME(arielb1): can we use for_each_relevant_impl here?\n+        trait_def.for_each_impl(self.tcx(), |impl_def_id| {\n             debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={} impl_def_id={}\",\n                    trait_def_id.repr(self.tcx()),\n                    impl_def_id.repr(self.tcx()));\n \n             if !self.impl_can_possibly_match(impl_def_id) {\n-                continue;\n+                return;\n             }\n \n             let (_, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n@@ -667,7 +660,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 item: item.clone(),\n                 kind: ExtensionImplCandidate(impl_def_id, impl_trait_ref, impl_substs, item_index)\n             });\n-        }\n+        });\n     }\n \n     fn impl_can_possibly_match(&self, impl_def_id: ast::DefId) -> bool {"}, {"sha": "c05c1c6b08523d0f3d3fdcd7154e3cb811979f3e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -112,7 +112,6 @@ use util::lev_distance::lev_distance;\n \n use std::cell::{Cell, Ref, RefCell};\n use std::mem::replace;\n-use std::rc::Rc;\n use std::iter::repeat;\n use std::slice;\n use syntax::{self, abi, attr};\n@@ -747,7 +746,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n               Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n                                                it.span,\n-                                               &*impl_trait_ref,\n+                                               &impl_trait_ref,\n                                                impl_items);\n               }\n               None => { }\n@@ -1174,7 +1173,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n \n     fn get_trait_def(&self, _: Span, id: ast::DefId)\n-                     -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>\n+                     -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>\n     {\n         Ok(ty::lookup_trait_def(self.tcx(), id))\n     }\n@@ -1244,7 +1243,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n \n     fn projected_ty(&self,\n                     span: Span,\n-                    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                    trait_ref: ty::TraitRef<'tcx>,\n                     item_name: ast::Name)\n                     -> Ty<'tcx>\n     {\n@@ -1457,7 +1456,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn normalize_associated_type(&self,\n                                  span: Span,\n-                                 trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                                 trait_ref: ty::TraitRef<'tcx>,\n                                  item_name: ast::Name)\n                                  -> Ty<'tcx>\n     {\n@@ -4945,7 +4944,6 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                ty::mk_nil(tcx))\n             }\n             \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n-            \"owns_managed\" => (1, Vec::new(), ccx.tcx.types.bool),\n \n             \"type_name\" => (1, Vec::new(), ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic),\n                                                              ast::MutImmutable)),"}, {"sha": "c2209ba2dc64754a16c2d0fa4846b9a94819627d", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -252,7 +252,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // trait reference. Instead, this is done at the impl site.\n             // Arguably this is wrong and we should treat the trait-reference\n             // the same way as we treat the self-type.\n-            bounds_checker.check_trait_ref(&*trait_ref);\n+            bounds_checker.check_trait_ref(&trait_ref);\n \n             let cause =\n                 traits::ObligationCause::new("}, {"sha": "05b74a5cc226bd7393d1830518c03358f12535d2", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             enforce_trait_manually_implementable(self.crate_context.tcx,\n                                                  item.span,\n                                                  trait_ref.def_id);\n-            self.add_trait_impl(trait_ref.def_id, impl_did);\n+            self.add_trait_impl(trait_ref, impl_did);\n         }\n \n         // Add the implementation to the mapping from implementation to base\n@@ -259,12 +259,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             Rc::new(RefCell::new(vec!(impl_def_id))));\n     }\n \n-    fn add_trait_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        debug!(\"add_trait_impl: base_def_id={:?} impl_def_id={:?}\",\n-               base_def_id, impl_def_id);\n-        ty::record_trait_implementation(self.crate_context.tcx,\n-                                        base_def_id,\n-                                        impl_def_id);\n+    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n+        debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n+               impl_trait_ref, impl_def_id);\n+        let trait_def = ty::lookup_trait_def(self.crate_context.tcx,\n+                                             impl_trait_ref.def_id);\n+        trait_def.record_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                                              item.id);\n \n                     self.instantiate_default_methods(local_def(item.id),\n-                                                     &*trait_ref,\n+                                                     &trait_ref,\n                                                      &mut items);\n                 }\n \n@@ -337,7 +337,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         // Record all the trait items.\n         if let Some(trait_ref) = associated_traits {\n-            self.add_trait_impl(trait_ref.def_id, impl_def_id);\n+            self.add_trait_impl(trait_ref, impl_def_id);\n         }\n \n         // For any methods that use a default implementation, add them to\n@@ -382,18 +382,16 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let drop_trait = match tcx.lang_items.drop_trait() {\n             Some(id) => id, None => { return }\n         };\n+        ty::populate_implementations_for_trait_if_necessary(tcx, drop_trait);\n+        let drop_trait = ty::lookup_trait_def(tcx, drop_trait);\n \n         let impl_items = tcx.impl_items.borrow();\n-        let trait_impls = match tcx.trait_impls.borrow().get(&drop_trait).cloned() {\n-            None => return, // No types with (new-style) dtors present.\n-            Some(found_impls) => found_impls\n-        };\n \n-        for &impl_did in &*trait_impls.borrow() {\n+        drop_trait.for_each_impl(tcx, |impl_did| {\n             let items = impl_items.get(&impl_did).unwrap();\n             if items.is_empty() {\n                 // We'll error out later. For now, just don't ICE.\n-                continue;\n+                return;\n             }\n             let method_def_id = items[0];\n \n@@ -430,7 +428,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-        }\n+        });\n     }\n \n     /// Ensures that implementations of the built-in trait `Copy` are legal.\n@@ -440,30 +438,17 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             Some(id) => id,\n             None => return,\n         };\n+        ty::populate_implementations_for_trait_if_necessary(tcx, copy_trait);\n+        let copy_trait = ty::lookup_trait_def(tcx, copy_trait);\n \n-        let trait_impls = match tcx.trait_impls\n-                                   .borrow()\n-                                   .get(&copy_trait)\n-                                   .cloned() {\n-            None => {\n-                debug!(\"check_implementations_of_copy(): no types with \\\n-                        implementations of `Copy` found\");\n-                return\n-            }\n-            Some(found_impls) => found_impls\n-        };\n-\n-        // Clone first to avoid a double borrow error.\n-        let trait_impls = trait_impls.borrow().clone();\n-\n-        for &impl_did in &trait_impls {\n+        copy_trait.for_each_impl(tcx, |impl_did| {\n             debug!(\"check_implementations_of_copy: impl_did={}\",\n                    impl_did.repr(tcx));\n \n             if impl_did.krate != ast::LOCAL_CRATE {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n                         crate\");\n-                continue\n+                return\n             }\n \n             let self_type = self.get_self_type_for_implementation(impl_did);\n@@ -506,7 +491,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                the type has a destructor\");\n                 }\n             }\n-        }\n+        });\n     }\n }\n "}, {"sha": "46cce54301168b0cc256a297e656e510e6b42a99", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 78, "deletions": 33, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -48,59 +48,104 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         // check_for_overlapping_impls_of_trait() check, since that\n         // check can populate this table further with impls from other\n         // crates.\n-        let trait_def_ids: Vec<(ast::DefId, Vec<ast::DefId>)> =\n-            self.tcx.trait_impls.borrow().iter().map(|(&k, v)| {\n-                // FIXME -- it seems like this method actually pushes\n-                // duplicate impls onto the list\n-                ty::populate_implementations_for_trait_if_necessary(self.tcx, k);\n-                (k, v.borrow().clone())\n-            }).collect();\n-\n-        for &(trait_def_id, ref impls) in &trait_def_ids {\n-            self.check_for_overlapping_impls_of_trait(trait_def_id, impls);\n+        let trait_defs : Vec<&ty::TraitDef> = {\n+            let d = self.tcx.trait_defs.borrow();\n+            d.values().map(|&v|v).collect()\n+        };\n+\n+        for trait_def in trait_defs {\n+            // FIXME -- it seems like this method actually pushes\n+            // duplicate impls onto the list\n+            ty::populate_implementations_for_trait_if_necessary(\n+                self.tcx,\n+                trait_def.trait_ref.def_id);\n+            self.check_for_overlapping_impls_of_trait(trait_def);\n         }\n     }\n \n     fn check_for_overlapping_impls_of_trait(&self,\n-                                            trait_def_id: ast::DefId,\n-                                            trait_impls: &Vec<ast::DefId>)\n+                                            trait_def: &'tcx ty::TraitDef<'tcx>)\n     {\n-        debug!(\"check_for_overlapping_impls_of_trait(trait_def_id={})\",\n-               trait_def_id.repr(self.tcx));\n+        debug!(\"check_for_overlapping_impls_of_trait(trait_def={})\",\n+               trait_def.repr(self.tcx));\n \n-        for (i, &impl1_def_id) in trait_impls.iter().enumerate() {\n-            if impl1_def_id.krate != ast::LOCAL_CRATE {\n-                // we don't need to check impls if both are external;\n-                // that's the other crate's job.\n-                continue;\n-            }\n+        // We should already know all impls of this trait, so these\n+        // borrows are safe.\n+        let blanket_impls = trait_def.blanket_impls.borrow();\n+        let nonblanket_impls = trait_def.nonblanket_impls.borrow();\n+        let trait_def_id = trait_def.trait_ref.def_id;\n \n-            for &impl2_def_id in &trait_impls[(i+1)..] {\n+        // Conflicts can only occur between a blanket impl and another impl,\n+        // or between 2 non-blanket impls of the same kind.\n+\n+        for (i, &impl1_def_id) in blanket_impls.iter().enumerate() {\n+            for &impl2_def_id in &blanket_impls[(i+1)..] {\n                 self.check_if_impls_overlap(trait_def_id,\n                                             impl1_def_id,\n                                             impl2_def_id);\n             }\n+\n+            for v in nonblanket_impls.values() {\n+                for &impl2_def_id in v {\n+                    self.check_if_impls_overlap(trait_def_id,\n+                                                impl1_def_id,\n+                                                impl2_def_id);\n+                }\n+            }\n+        }\n+\n+        for impl_group in nonblanket_impls.values() {\n+            for (i, &impl1_def_id) in impl_group.iter().enumerate() {\n+                for &impl2_def_id in &impl_group[(i+1)..] {\n+                    self.check_if_impls_overlap(trait_def_id,\n+                                                impl1_def_id,\n+                                                impl2_def_id);\n+                }\n+            }\n         }\n     }\n \n+    // We need to coherently pick which impl will be displayed\n+    // as causing the error message, and it must be the in the current\n+    // crate. Just pick the smaller impl in the file.\n+    fn order_impls(&self, impl1_def_id: ast::DefId, impl2_def_id: ast::DefId)\n+            -> Option<(ast::DefId, ast::DefId)> {\n+        if impl1_def_id.krate != ast::LOCAL_CRATE {\n+            if impl2_def_id.krate != ast::LOCAL_CRATE {\n+                // we don't need to check impls if both are external;\n+                // that's the other crate's job.\n+                None\n+            } else {\n+                Some((impl2_def_id, impl1_def_id))\n+            }\n+        } else if impl2_def_id.krate != ast::LOCAL_CRATE {\n+            Some((impl1_def_id, impl2_def_id))\n+        } else if impl1_def_id.node < impl2_def_id.node {\n+            Some((impl1_def_id, impl2_def_id))\n+        } else {\n+            Some((impl2_def_id, impl1_def_id))\n+        }\n+    }\n+\n+\n     fn check_if_impls_overlap(&self,\n                               trait_def_id: ast::DefId,\n                               impl1_def_id: ast::DefId,\n                               impl2_def_id: ast::DefId)\n     {\n-        assert_eq!(impl1_def_id.krate, ast::LOCAL_CRATE);\n-\n-        debug!(\"check_if_impls_overlap({}, {}, {})\",\n-               trait_def_id.repr(self.tcx),\n-               impl1_def_id.repr(self.tcx),\n-               impl2_def_id.repr(self.tcx));\n-\n-        let infcx = infer::new_infer_ctxt(self.tcx);\n-        if !traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n-            return;\n+        if let Some((impl1_def_id, impl2_def_id)) = self.order_impls(\n+            impl1_def_id, impl2_def_id)\n+        {\n+            debug!(\"check_if_impls_overlap({}, {}, {})\",\n+                   trait_def_id.repr(self.tcx),\n+                   impl1_def_id.repr(self.tcx),\n+                   impl2_def_id.repr(self.tcx));\n+\n+            let infcx = infer::new_infer_ctxt(self.tcx);\n+            if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n+                self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n+            }\n         }\n-\n-        self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n     }\n \n     fn report_overlap_error(&self, trait_def_id: ast::DefId,"}, {"sha": "014991f7ea560e377aeb751014bb65e05e67fb1d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -83,7 +83,7 @@ use util::ppaux;\n use util::ppaux::{Repr,UserString};\n use write_ty_to_tcx;\n \n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::collections::HashSet;\n use std::rc::Rc;\n \n@@ -309,7 +309,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n     /// Loads the trait def for a given trait, returning ErrorReported if a cycle arises.\n     fn get_trait_def(&self, trait_id: ast::DefId)\n-                     -> Rc<ty::TraitDef<'tcx>>\n+                     -> &'tcx ty::TraitDef<'tcx>\n     {\n         let tcx = self.tcx;\n \n@@ -361,7 +361,7 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n \n     fn get_trait_def(&self, span: Span, id: ast::DefId)\n-                     -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>\n+                     -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetTraitDef(id), || {\n             Ok(self.ccx.get_trait_def(id))\n@@ -415,7 +415,7 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n \n     fn projected_ty(&self,\n                     _span: Span,\n-                    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                    trait_ref: ty::TraitRef<'tcx>,\n                     item_name: ast::Name)\n                     -> Ty<'tcx>\n     {\n@@ -899,7 +899,7 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 if let ast::MethodImplItem(ref sig, _) = ii.node {\n                     // if the method specifies a visibility, use that, otherwise\n                     // inherit the visibility from the impl (so `foo` in `pub impl\n-                    // { fn foo(); }` is public, but private in `priv impl { fn\n+                    // { fn foo(); }` is public, but private in `impl { fn\n                     // foo(); }`).\n                     let method_vis = ii.vis.inherit_from(parent_visibility);\n                     Some((sig, ii.id, ii.ident, method_vis, ii.span))\n@@ -1210,7 +1210,7 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n \n fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                it: &ast::Item)\n-                               -> Rc<ty::TraitDef<'tcx>>\n+                               -> &'tcx ty::TraitDef<'tcx>\n {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n@@ -1246,22 +1246,23 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }).collect();\n \n-    let trait_ref = Rc::new(ty::TraitRef {\n+    let trait_ref = ty::TraitRef {\n         def_id: def_id,\n         substs: substs,\n-    });\n+    };\n \n-    let trait_def = Rc::new(ty::TraitDef {\n+    let trait_def = ty::TraitDef {\n         paren_sugar: paren_sugar,\n         unsafety: unsafety,\n         generics: ty_generics,\n         trait_ref: trait_ref,\n         associated_type_names: associated_type_names,\n-    });\n-\n-    tcx.trait_defs.borrow_mut().insert(def_id, trait_def.clone());\n+        nonblanket_impls: RefCell::new(FnvHashMap()),\n+        blanket_impls: RefCell::new(vec![]),\n+        flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS)\n+    };\n \n-    return trait_def;\n+    return tcx.intern_trait_def(trait_def);\n \n     fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  generics: &ast::Generics)\n@@ -1357,7 +1358,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n     let assoc_predicates = predicates_for_associated_types(ccx,\n                                                            generics,\n                                                            &trait_predicates,\n-                                                           &trait_def.trait_ref,\n+                                                           trait_def.trait_ref,\n                                                            items);\n     trait_predicates.predicates.extend(TypeSpace, assoc_predicates.into_iter());\n \n@@ -1369,7 +1370,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n     fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  ast_generics: &ast::Generics,\n                                                  trait_predicates: &ty::GenericPredicates<'tcx>,\n-                                                 self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n+                                                 self_trait_ref: ty::TraitRef<'tcx>,\n                                                  trait_items: &[P<ast::TraitItem>])\n                                                  -> Vec<ty::Predicate<'tcx>>\n     {\n@@ -1382,7 +1383,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n             };\n \n             let assoc_ty = ty::mk_projection(ccx.tcx,\n-                                             self_trait_ref.clone(),\n+                                             self_trait_ref,\n                                              trait_item.ident.name);\n \n             let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),"}, {"sha": "3c8aab8447a2f14e9d670360e4ae82809db3824f", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -12,7 +12,6 @@ use middle::subst;\n use middle::ty::{self, Ty};\n \n use std::collections::HashSet;\n-use std::rc::Rc;\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Parameter {\n@@ -26,7 +25,7 @@ pub fn parameters_for_type<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n       .collect()\n }\n \n-pub fn parameters_for_trait_ref<'tcx>(trait_ref: &Rc<ty::TraitRef<'tcx>>) -> Vec<Parameter> {\n+pub fn parameters_for_trait_ref<'tcx>(trait_ref: &ty::TraitRef<'tcx>) -> Vec<Parameter> {\n     let mut region_parameters =\n         parameters_for_regions_in_substs(&trait_ref.substs);\n \n@@ -71,7 +70,7 @@ fn parameters_for_region(region: &ty::Region) -> Option<Parameter> {\n \n pub fn identify_constrained_type_params<'tcx>(_tcx: &ty::ctxt<'tcx>,\n                                               predicates: &[ty::Predicate<'tcx>],\n-                                              impl_trait_ref: Option<Rc<ty::TraitRef<'tcx>>>,\n+                                              impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n                                               input_parameters: &mut HashSet<Parameter>)\n {\n     loop {"}, {"sha": "0e6386618f17bfbea39bd8d320fe44db0fecc9a9", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 113, "deletions": 8, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -10,6 +10,119 @@\n \n #![allow(non_snake_case)]\n \n+register_long_diagnostics! {\n+\n+E0046: r##\"\n+When trying to make some type implement a trait `Foo`, you must, at minimum,\n+provide implementations for all of `Foo`'s required methods (meaning the\n+methods that do not have default implementations), as well as any required\n+trait items like associated types or constants.\n+\"##,\n+\n+E0054: r##\"\n+It is not allowed to cast to a bool. If you are trying to cast a numeric type\n+to a bool, you can compare it with zero instead:\n+\n+```\n+let x = 5;\n+\n+// Ok\n+let x_is_nonzero = x != 0;\n+\n+// Not allowed, won't compile\n+let x_is_nonzero = x as bool;\n+```\n+\"##,\n+\n+E0062: r##\"\n+This error indicates that during an attempt to build a struct or struct-like\n+enum variant, one of the fields was specified more than once. Each field should\n+be specified exactly one time.\n+\"##,\n+\n+E0063: r##\"\n+This error indicates that during an attempt to build a struct or struct-like\n+enum variant, one of the fields was not provided. Each field should be specified\n+exactly once.\n+\"##,\n+\n+E0081: r##\"\n+Enum discriminants are used to differentiate enum variants stored in memory.\n+This error indicates that the same value was used for two or more variants,\n+making them impossible to tell apart.\n+\n+```\n+// Good.\n+enum Enum {\n+    P,\n+    X = 3,\n+    Y = 5\n+}\n+\n+// Bad.\n+enum Enum {\n+    P = 3,\n+    X = 3,\n+    Y = 5\n+}\n+```\n+\n+Note that variants without a manually specified discriminant are numbered from\n+top to bottom starting from 0, so clashes can occur with seemingly unrelated\n+variants.\n+\n+```\n+enum Bad {\n+    X,\n+    Y = 0\n+}\n+```\n+\n+Here `X` will have already been assigned the discriminant 0 by the time `Y` is\n+encountered, so a conflict occurs.\n+\"##,\n+\n+E0082: r##\"\n+The default type for enum discriminants is `isize`, but it can be adjusted by\n+adding the `repr` attribute to the enum declaration. This error indicates that\n+an integer literal given as a discriminant is not a member of the discriminant\n+type. For example:\n+\n+```\n+#[repr(u8)]\n+enum Thing {\n+    A = 1024,\n+    B = 5\n+}\n+```\n+\n+Here, 1024 lies outside the valid range for `u8`, so the discriminant for `A` is\n+invalid. You may want to change representation types to fix this, or else change\n+invalid discriminant values so that they fit within the existing type.\n+\n+Note also that without a representation manually defined, the compiler will\n+optimize by using the smallest integer type possible.\n+\"##,\n+\n+E0083: r##\"\n+At present, it's not possible to define a custom representation for an enum with\n+a single variant. As a workaround you can add a `Dummy` variant.\n+\n+See: https://github.com/rust-lang/rust/issues/10292\n+\"##,\n+\n+E0084: r##\"\n+It is impossible to define an integer type to be used to represent zero-variant\n+enum values because there are no zero-variant enum values. There is no way to\n+construct an instance of the following type using only safe code:\n+\n+```\n+enum Empty {}\n+```\n+\"##\n+\n+}\n+\n register_diagnostics! {\n     E0023,\n     E0024,\n@@ -27,18 +140,14 @@ register_diagnostics! {\n     E0040, // explicit use of destructor method\n     E0044,\n     E0045,\n-    E0046,\n     E0049,\n     E0050,\n     E0053,\n-    E0054,\n     E0055,\n     E0057,\n     E0059,\n     E0060,\n     E0061,\n-    E0062,\n-    E0063,\n     E0066,\n     E0067,\n     E0068,\n@@ -51,10 +160,6 @@ register_diagnostics! {\n     E0075,\n     E0076,\n     E0077,\n-    E0081,\n-    E0082,\n-    E0083,\n-    E0084,\n     E0085,\n     E0086,\n     E0087,"}, {"sha": "9e8c23734e3c8c0d6854f52d8acb1a3895973113", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -654,7 +654,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             ast::ItemTrait(..) => {\n                 let trait_def = ty::lookup_trait_def(tcx, did);\n                 self.add_constraints_from_trait_ref(&trait_def.generics,\n-                                                    &trait_def.trait_ref,\n+                                                    trait_def.trait_ref,\n                                                     self.invariant);\n             }\n \n@@ -844,7 +844,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n     fn add_constraints_from_trait_ref(&mut self,\n                                       generics: &ty::Generics<'tcx>,\n-                                      trait_ref: &ty::TraitRef<'tcx>,\n+                                      trait_ref: ty::TraitRef<'tcx>,\n                                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_trait_ref: trait_ref={} variance={:?}\",\n                trait_ref.repr(self.tcx()),\n@@ -946,7 +946,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_region(generics, data.bounds.region_bound, contra);\n \n                 // Ignore the SelfSpace, it is erased.\n-                self.add_constraints_from_trait_ref(generics, &*poly_trait_ref.0, variance);\n+                self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n \n                 let projections = data.projection_bounds_with_self_ty(self.tcx(),\n                                                                       self.tcx().types.err);"}, {"sha": "f4c85f18a7e6795fc4b17fdaa9b7ed91b0037a9c", "filename": "src/librustc_unicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustc_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fu_str.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -525,7 +525,7 @@ pub struct Utf16Encoder<I> {\n }\n \n impl<I> Utf16Encoder<I> {\n-    /// Create an UTF-16 encoder from any `char` iterator.\n+    /// Create a UTF-16 encoder from any `char` iterator.\n     pub fn new(chars: I) -> Utf16Encoder<I> where I: Iterator<Item=char> {\n         Utf16Encoder { chars: chars, extra: 0 }\n     }"}, {"sha": "444e5dea89a46c2079cabfe59d684d16e397bb08", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -944,7 +944,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n         // a Sized bound, removing the bounds as we find them.\n         //\n         // Note that associated types also have a sized bound by default, but we\n-        // don't actually konw the set of associated types right here so that's\n+        // don't actually know the set of associated types right here so that's\n         // handled in cleaning associated types\n         let mut sized_params = HashSet::new();\n         where_predicates.retain(|pred| {"}, {"sha": "798cc6a612cde239ce60be7f158839e549bbdaab", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -111,6 +111,10 @@ r##\"<!DOCTYPE html>\n                 <code>trait</code>, <code>typedef</code> (or\n                 <code>tdef</code>).\n             </p>\n+            <p>\n+                Search functions by type signature (e.g.\n+                <code>vec -> usize</code>)\n+            </p>\n         </div>\n     </div>\n "}, {"sha": "66c5a4e0db2366a6c303b69b2d96ff4bdba323ef", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -477,7 +477,7 @@ impl LangString {\n \n /// By default this markdown renderer generates anchors for each header in the\n /// rendered document. The anchor name is the contents of the header separated\n-/// by hyphens, and a task-local map is used to disambiguate among duplicate\n+/// by hyphens, and a thread-local map is used to disambiguate among duplicate\n /// headers (numbers are appended).\n ///\n /// This method will reset the local table for these headers. This is typically"}, {"sha": "08792044c2a77d8d1c2164c154af3d63d8c16059", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -17,10 +17,10 @@\n //!\n //! The rendering process is largely driven by the `Context` and `Cache`\n //! structures. The cache is pre-populated by crawling the crate in question,\n-//! and then it is shared among the various rendering tasks. The cache is meant\n+//! and then it is shared among the various rendering threads. The cache is meant\n //! to be a fairly large structure not implementing `Clone` (because it's shared\n-//! among tasks). The context, however, should be a lightweight structure. This\n-//! is cloned per-task and contains information about what is currently being\n+//! among threads). The context, however, should be a lightweight structure. This\n+//! is cloned per-thread and contains information about what is currently being\n //! rendered.\n //!\n //! In order to speed up rendering (mostly because of markdown rendering), the\n@@ -30,7 +30,7 @@\n //!\n //! In addition to rendering the crate itself, this module is also responsible\n //! for creating the corresponding search index and source file renderings.\n-//! These tasks are not parallelized (they haven't been a bottleneck yet), and\n+//! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n pub use self::ExternalLocation::*;\n \n@@ -154,7 +154,7 @@ impl Impl {\n /// This structure purposefully does not implement `Clone` because it's intended\n /// to be a fairly large and expensive structure to clone. Instead this adheres\n /// to `Send` so it may be stored in a `Arc` instance and shared among the various\n-/// rendering tasks.\n+/// rendering threads.\n #[derive(Default)]\n pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n@@ -688,7 +688,7 @@ fn write(dst: PathBuf, contents: &[u8]) -> io::Result<()> {\n     try!(File::create(&dst)).write_all(contents)\n }\n \n-/// Makes a directory on the filesystem, failing the task if an error occurs and\n+/// Makes a directory on the filesystem, failing the thread if an error occurs and\n /// skipping if the directory already exists.\n fn mkdir(path: &Path) -> io::Result<()> {\n     if !path.exists() {\n@@ -1460,7 +1460,9 @@ impl<'a> fmt::Display for Item<'a> {\n         try!(write!(fmt, \"<span class='out-of-band'>\"));\n         try!(write!(fmt,\n         r##\"<span id='render-detail'>\n-            <a id=\"toggle-all-docs\" href=\"#\" title=\"collapse all docs\">[&minus;]</a>\n+            <a id=\"toggle-all-docs\" href=\"javascript:void(0)\" title=\"collapse all docs\">\n+                [<span class='inner'>&#x2212;</span>]\n+            </a>\n         </span>\"##));\n \n         // Write `src` tag\n@@ -1641,7 +1643,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             clean::ExternCrateItem(ref name, ref src) => {\n                 match *src {\n                     Some(ref src) => {\n-                        try!(write!(w, \"<tr><td><code>{}extern crate \\\"{}\\\" as {};\",\n+                        try!(write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n                                     VisSpace(myitem.visibility),\n                                     src,\n                                     name))\n@@ -1787,6 +1789,9 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     let types = t.items.iter().filter(|m| {\n         match m.inner { clean::AssociatedTypeItem(..) => true, _ => false }\n     }).collect::<Vec<_>>();\n+    let consts = t.items.iter().filter(|m| {\n+        match m.inner { clean::AssociatedConstItem(..) => true, _ => false }\n+    }).collect::<Vec<_>>();\n     let required = t.items.iter().filter(|m| {\n         match m.inner { clean::TyMethodItem(_) => true, _ => false }\n     }).collect::<Vec<_>>();\n@@ -1803,7 +1808,15 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             try!(render_assoc_item(w, t, AssocItemLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n-        if !types.is_empty() && !required.is_empty() {\n+        if !types.is_empty() && !consts.is_empty() {\n+            try!(w.write_str(\"\\n\"));\n+        }\n+        for t in &consts {\n+            try!(write!(w, \"    \"));\n+            try!(render_assoc_item(w, t, AssocItemLink::Anchor));\n+            try!(write!(w, \";\\n\"));\n+        }\n+        if !consts.is_empty() && !required.is_empty() {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &required {\n@@ -1905,11 +1918,11 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n }\n \n fn assoc_const(w: &mut fmt::Formatter, it: &clean::Item,\n-               ty: &clean::Type, default: &Option<String>)\n+               ty: &clean::Type, default: Option<&String>)\n                -> fmt::Result {\n     try!(write!(w, \"const {}\", it.name.as_ref().unwrap()));\n     try!(write!(w, \": {}\", ty));\n-    if let Some(ref default) = *default {\n+    if let Some(default) = default {\n         try!(write!(w, \" = {}\", default));\n     }\n     Ok(())\n@@ -1971,7 +1984,7 @@ fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n                    link)\n         }\n         clean::AssociatedConstItem(ref ty, ref default) => {\n-            assoc_const(w, meth, ty, default)\n+            assoc_const(w, meth, ty, default.as_ref())\n         }\n         clean::AssociatedTypeItem(ref bounds, ref default) => {\n             assoc_type(w, meth, bounds, default)\n@@ -2335,9 +2348,15 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: AssocItemLink,\n             clean::AssociatedConstItem(ref ty, ref default) => {\n                 let name = item.name.as_ref().unwrap();\n                 try!(write!(w, \"<h4 id='assoc_const.{}' class='{}'><code>\",\n-                            *name,\n-                            shortty(item)));\n-                try!(assoc_const(w, item, ty, default));\n+                            *name, shortty(item)));\n+                try!(assoc_const(w, item, ty, default.as_ref()));\n+                try!(write!(w, \"</code></h4>\\n\"));\n+            }\n+            clean::ConstantItem(ref c) => {\n+                let name = item.name.as_ref().unwrap();\n+                try!(write!(w, \"<h4 id='assoc_const.{}' class='{}'><code>\",\n+                            *name, shortty(item)));\n+                try!(assoc_const(w, item, &c.type_, Some(&c.expr)));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {"}, {"sha": "2dc5ea9906744f751e14c0bb65ded041a6ea22c5", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -581,7 +581,7 @@ pre.rust { position: relative; }\n \n .collapse-toggle > .inner {\n     display: inline-block;\n-    width: 1ch;\n+    width: 1.2ch;\n     text-align: center;\n }\n "}, {"sha": "6a1d7bdfd835879135b5874ffae4a5eed31b187f", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -806,22 +806,35 @@\n         window.location = $('.srclink').attr('href');\n     }\n \n+    function labelForToggleButton(sectionIsCollapsed) {\n+        if (sectionIsCollapsed) {\n+            // button will expand the section\n+            return \"+\";\n+        } else {\n+            // button will collapse the section\n+            // note that this text is also set in the HTML template in render.rs\n+            return \"\\u2212\"; // \"\\u2212\" is '\u2212' minus sign\n+        }\n+    }\n+\n     $(\"#toggle-all-docs\").on(\"click\", function() {\n         var toggle = $(\"#toggle-all-docs\");\n-        if (toggle.html() == \"[&minus;]\") {\n-            toggle.html(\"[&plus;]\");\n-            toggle.attr(\"title\", \"expand all docs\");\n-            $(\".docblock\").hide();\n-            $(\".toggle-label\").show();\n-            $(\".toggle-wrapper\").addClass(\"collapsed\");\n-            $(\".collapse-toggle\").children(\".inner\").html(\"&plus;\");\n-        } else {\n-            toggle.html(\"[&minus;]\");\n+        if (toggle.hasClass(\"will-expand\")) {\n+            toggle.removeClass(\"will-expand\");\n+            toggle.children(\".inner\").text(labelForToggleButton(false));\n             toggle.attr(\"title\", \"collapse all docs\");\n             $(\".docblock\").show();\n             $(\".toggle-label\").hide();\n             $(\".toggle-wrapper\").removeClass(\"collapsed\");\n-            $(\".collapse-toggle\").children(\".inner\").html(\"&minus;\");\n+            $(\".collapse-toggle\").children(\".inner\").text(labelForToggleButton(false));\n+        } else {\n+            toggle.addClass(\"will-expand\");\n+            toggle.children(\".inner\").text(labelForToggleButton(true));\n+            toggle.attr(\"title\", \"expand all docs\");\n+            $(\".docblock\").hide();\n+            $(\".toggle-label\").show();\n+            $(\".toggle-wrapper\").addClass(\"collapsed\");\n+            $(\".collapse-toggle\").children(\".inner\").text(labelForToggleButton(true));\n         }\n     });\n \n@@ -835,20 +848,21 @@\n             if (relatedDoc.is(\":visible\")) {\n                 relatedDoc.slideUp({duration:'fast', easing:'linear'});\n                 toggle.parent(\".toggle-wrapper\").addClass(\"collapsed\");\n-                toggle.children(\".inner\").html(\"&plus;\");\n+                toggle.children(\".inner\").text(labelForToggleButton(true));\n                 toggle.children(\".toggle-label\").fadeIn();\n             } else {\n                 relatedDoc.slideDown({duration:'fast', easing:'linear'});\n                 toggle.parent(\".toggle-wrapper\").removeClass(\"collapsed\");\n-                toggle.children(\".inner\").html(\"&minus;\");\n+                toggle.children(\".inner\").text(labelForToggleButton(false));\n                 toggle.children(\".toggle-label\").hide();\n             }\n         }\n     });\n \n     $(function() {\n         var toggle = $(\"<a/>\", {'href': 'javascript:void(0)', 'class': 'collapse-toggle'})\n-            .html(\"[<span class='inner'>&minus;</span>]\");\n+            .html(\"[<span class='inner'></span>]\");\n+        toggle.children(\".inner\").text(labelForToggleButton(false));\n \n         $(\".method\").each(function() {\n             if ($(this).next().is(\".docblock\") ||"}, {"sha": "f8c2626d09e317668b9558a75abfa8ed75bd9d47", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -180,9 +180,9 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     // an explicit handle into rustc to collect output messages, but we also\n     // want to catch the error message that rustc prints when it fails.\n     //\n-    // We take our task-local stderr (likely set by the test runner) and replace\n+    // We take our thread-local stderr (likely set by the test runner) and replace\n     // it with a sink that is also passed to rustc itself. When this function\n-    // returns the output of the sink is copied onto the output of our own task.\n+    // returns the output of the sink is copied onto the output of our own thread.\n     //\n     // The basic idea is to not use a default_handler() for rustc, and then also\n     // not print things by default to the actual stderr."}, {"sha": "adc4f69334f17f0df7f722bdc1d6d6e01966ab7f", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -3011,9 +3011,9 @@ mod tests {\n         let v: i64 = super::decode(\"9223372036854775807\").unwrap();\n         assert_eq!(v, i64::MAX);\n \n-        let res: DecodeResult<i64> = super::decode(\"765.25252\");\n+        let res: DecodeResult<i64> = super::decode(\"765.25\");\n         assert_eq!(res, Err(ExpectedError(\"Integer\".to_string(),\n-                                          \"765.25252\".to_string())));\n+                                          \"765.25\".to_string())));\n     }\n \n     #[test]"}, {"sha": "9b824f11b926822fe818ed70cadbbe63684e408d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -205,15 +205,16 @@ fn test_resize_policy() {\n /// A hash map implementation which uses linear probing with Robin\n /// Hood bucket stealing.\n ///\n-/// The hashes are all keyed by the task-local random number generator\n+/// The hashes are all keyed by the thread-local random number generator\n /// on creation by default. This means that the ordering of the keys is\n /// randomized, but makes the tables more resistant to\n /// denial-of-service attacks (Hash DoS). This behaviour can be\n /// overridden with one of the constructors.\n ///\n /// It is required that the keys implement the `Eq` and `Hash` traits, although\n-/// this can frequently be achieved by using `#[derive(Eq, Hash)]`. If you\n-/// implement these yourself, it is important that the following property holds:\n+/// this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`.\n+/// If you implement these yourself, it is important that the following\n+/// property holds:\n ///\n /// ```text\n /// k1 == k2 -> hash(k1) == hash(k2)\n@@ -250,26 +251,26 @@ fn test_resize_policy() {\n /// book_reviews.insert(\"The Adventures of Sherlock Holmes\", \"Eye lyked it alot.\");\n ///\n /// // check for a specific one.\n-/// if !book_reviews.contains_key(&(\"Les Mis\u00e9rables\")) {\n+/// if !book_reviews.contains_key(\"Les Mis\u00e9rables\") {\n ///     println!(\"We've got {} reviews, but Les Mis\u00e9rables ain't one.\",\n ///              book_reviews.len());\n /// }\n ///\n /// // oops, this review has a lot of spelling mistakes, let's delete it.\n-/// book_reviews.remove(&(\"The Adventures of Sherlock Holmes\"));\n+/// book_reviews.remove(\"The Adventures of Sherlock Holmes\");\n ///\n /// // look up the values associated with some keys.\n /// let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n-/// for book in to_find.iter() {\n+/// for book in &to_find {\n ///     match book_reviews.get(book) {\n-///         Some(review) => println!(\"{}: {}\", *book, *review),\n-///         None => println!(\"{} is unreviewed.\", *book)\n+///         Some(review) => println!(\"{}: {}\", book, review),\n+///         None => println!(\"{} is unreviewed.\", book)\n ///     }\n /// }\n ///\n /// // iterate over everything.\n-/// for (book, review) in book_reviews.iter() {\n-///     println!(\"{}: \\\"{}\\\"\", *book, *review);\n+/// for (book, review) in &book_reviews {\n+///     println!(\"{}: \\\"{}\\\"\", book, review);\n /// }\n /// ```\n ///\n@@ -300,7 +301,7 @@ fn test_resize_policy() {\n /// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n ///\n /// // Use derived implementation to print the status of the vikings.\n-/// for (viking, health) in vikings.iter() {\n+/// for (viking, health) in &vikings {\n ///     println!(\"{:?} has {} hp\", viking, health);\n /// }\n /// ```\n@@ -1600,13 +1601,13 @@ impl RandomState {\n            reason = \"hashing an hash maps may be altered\")]\n impl HashState for RandomState {\n     type Hasher = SipHasher;\n+    #[inline]\n     fn hasher(&self) -> SipHasher {\n         SipHasher::new_with_keys(self.k0, self.k1)\n     }\n }\n \n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for RandomState {\n     #[inline]\n     fn default() -> RandomState {"}, {"sha": "d6754f10335cab9f0810ff5b97b223f659885826", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -31,10 +31,12 @@ use super::state::HashState;\n // to get rid of it properly.\n \n /// An implementation of a hash set using the underlying representation of a\n-/// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n-/// requires that the elements implement the `Eq` and `Hash` traits. This can\n-/// frequently be achieved by using `#[derive(Eq, Hash)]`. If you implement\n-/// these yourself, it is important that the following property holds:\n+/// HashMap where the value is ().\n+///\n+/// As with the `HashMap` type, a `HashSet` requires that the elements\n+/// implement the `Eq` and `Hash` traits. This can frequently be achieved by\n+/// using `#[derive(PartialEq, Eq, Hash)]`. If you implement these yourself,\n+/// it is important that the following property holds:\n ///\n /// ```text\n /// k1 == k2 -> hash(k1) == hash(k2)\n@@ -64,17 +66,17 @@ use super::state::HashState;\n /// books.insert(\"The Great Gatsby\");\n ///\n /// // Check for a specific one.\n-/// if !books.contains(&(\"The Winds of Winter\")) {\n+/// if !books.contains(\"The Winds of Winter\") {\n ///     println!(\"We have {} books, but The Winds of Winter ain't one.\",\n ///              books.len());\n /// }\n ///\n /// // Remove a book.\n-/// books.remove(&\"The Odyssey\");\n+/// books.remove(\"The Odyssey\");\n ///\n /// // Iterate over everything.\n-/// for book in books.iter() {\n-///     println!(\"{}\", *book);\n+/// for book in &books {\n+///     println!(\"{}\", book);\n /// }\n /// ```\n ///\n@@ -98,7 +100,7 @@ use super::state::HashState;\n /// vikings.insert(Viking { name: \"Harald\", power: 8 });\n ///\n /// // Use derived implementation to print the vikings.\n-/// for x in vikings.iter() {\n+/// for x in &vikings {\n ///     println!(\"{:?}\", x);\n /// }\n /// ```"}, {"sha": "1099bf108f1dbb7116798bb8c3c8969159ab39c3", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -271,7 +271,7 @@\n //! ```\n //!\n //! Iterators also provide a series of *adapter* methods for performing common\n-//! tasks to sequences. Among the adapters are functional favorites like `map`,\n+//! threads to sequences. Among the adapters are functional favorites like `map`,\n //! `fold`, `skip`, and `take`. Of particular interest to collections is the\n //! `rev` adapter, that reverses any iterator that supports this operation. Most\n //! collections provide reversible iterators as the way to iterate over them in"}, {"sha": "82999a47e563701a57235b842ff450147da00699", "filename": "src/libstd/env.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -27,7 +27,7 @@ use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n use sync::{StaticMutex, MUTEX_INIT};\n use sys::os as os_imp;\n \n-/// Returns the current working directory as a `Path`.\n+/// Returns the current working directory as a `PathBuf`.\n ///\n /// # Errors\n ///\n@@ -66,7 +66,7 @@ pub fn current_dir() -> io::Result<PathBuf> {\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn set_current_dir<P: AsRef<Path> + ?Sized>(p: &P) -> io::Result<()> {\n+pub fn set_current_dir<P: AsRef<Path>>(p: P) -> io::Result<()> {\n     os_imp::chdir(p.as_ref())\n }\n \n@@ -175,7 +175,7 @@ impl Iterator for VarsOs {\n /// }\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn var<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsRef<OsStr> {\n+pub fn var<K: AsRef<OsStr>>(key: K) -> Result<String, VarError> {\n     match var_os(key) {\n         Some(s) => s.into_string().map_err(VarError::NotUnicode),\n         None => Err(VarError::NotPresent)\n@@ -197,7 +197,7 @@ pub fn var<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsRef<OsStr>\n /// }\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn var_os<K: ?Sized>(key: &K) -> Option<OsString> where K: AsRef<OsStr> {\n+pub fn var_os<K: AsRef<OsStr>>(key: K) -> Option<OsString> {\n     let _g = ENV_LOCK.lock();\n     os_imp::getenv(key.as_ref())\n }\n@@ -253,9 +253,7 @@ impl Error for VarError {\n /// assert_eq!(env::var(key), Ok(\"VALUE\".to_string()));\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn set_var<K: ?Sized, V: ?Sized>(k: &K, v: &V)\n-    where K: AsRef<OsStr>, V: AsRef<OsStr>\n-{\n+pub fn set_var<K: AsRef<OsStr>, V: AsRef<OsStr>>(k: K, v: V) {\n     let _g = ENV_LOCK.lock();\n     os_imp::setenv(k.as_ref(), v.as_ref())\n }\n@@ -275,7 +273,7 @@ pub fn set_var<K: ?Sized, V: ?Sized>(k: &K, v: &V)\n /// assert!(env::var(key).is_err());\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn remove_var<K: ?Sized>(k: &K) where K: AsRef<OsStr> {\n+pub fn remove_var<K: AsRef<OsStr>>(k: K) {\n     let _g = ENV_LOCK.lock();\n     os_imp::unsetenv(k.as_ref())\n }\n@@ -459,8 +457,8 @@ static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n \n /// Sets the process exit code\n ///\n-/// Sets the exit code returned by the process if all supervised tasks\n-/// terminate successfully (without panicking). If the current root task panics\n+/// Sets the exit code returned by the process if all supervised threads\n+/// terminate successfully (without panicking). If the current root thread panics\n /// and is supervised by the scheduler then any user-specified exit status is\n /// ignored and the process exits with the default panic status.\n ///"}, {"sha": "6d23df970000cab16ce5dbfa8473788abcb16875", "filename": "src/libstd/error.rs", "status": "modified", "additions": 126, "deletions": 6, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -47,19 +47,22 @@\n // coherence challenge (e.g., specialization, neg impls, etc) we can\n // reconsider what crate these items belong in.\n \n-use boxed::Box;\n+use any::TypeId;\n+use boxed::{self, Box};\n use convert::From;\n use fmt::{self, Debug, Display};\n-use marker::{Send, Sync};\n+use marker::{Send, Sync, Reflect};\n+use mem::transmute;\n use num;\n-use option::Option;\n-use option::Option::None;\n+use option::Option::{self, Some, None};\n+use result::Result::{self, Ok, Err};\n+use raw::TraitObject;\n use str;\n use string::{self, String};\n \n /// Base functionality for all errors in Rust.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Error: Debug + Display {\n+pub trait Error: Debug + Display + Reflect {\n     /// A short description of the error.\n     ///\n     /// The description should not contain newlines or sentence-ending\n@@ -71,6 +74,14 @@ pub trait Error: Debug + Display {\n     /// The lower-level cause of this error, if any.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn cause(&self) -> Option<&Error> { None }\n+\n+    /// Get the `TypeId` of `self`\n+    #[doc(hidden)]\n+    #[unstable(feature = \"core\",\n+               reason = \"unclear whether to commit to this public implementation detail\")]\n+    fn type_id(&self) -> TypeId where Self: 'static {\n+        TypeId::of::<Self>()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -136,7 +147,7 @@ impl Error for num::ParseIntError {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for num::ParseFloatError {\n     fn description(&self) -> &str {\n-        self.description()\n+        self.__description()\n     }\n }\n \n@@ -154,3 +165,112 @@ impl Error for string::FromUtf16Error {\n     }\n }\n \n+// copied from any.rs\n+impl Error + 'static {\n+    /// Returns true if the boxed type is the same as `T`\n+    #[unstable(feature = \"error_downcast\", reason = \"recently added\")]\n+    #[inline]\n+    pub fn is<T: Error + 'static>(&self) -> bool {\n+        // Get TypeId of the type this function is instantiated with\n+        let t = TypeId::of::<T>();\n+\n+        // Get TypeId of the type in the trait object\n+        let boxed = self.type_id();\n+\n+        // Compare both TypeIds on equality\n+        t == boxed\n+    }\n+\n+    /// Returns some reference to the boxed value if it is of type `T`, or\n+    /// `None` if it isn't.\n+    #[unstable(feature = \"error_downcast\", reason = \"recently added\")]\n+    #[inline]\n+    pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n+        if self.is::<T>() {\n+            unsafe {\n+                // Get the raw representation of the trait object\n+                let to: TraitObject = transmute(self);\n+\n+                // Extract the data pointer\n+                Some(transmute(to.data))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns some mutable reference to the boxed value if it is of type `T`, or\n+    /// `None` if it isn't.\n+    #[unstable(feature = \"error_downcast\", reason = \"recently added\")]\n+    #[inline]\n+    pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n+        if self.is::<T>() {\n+            unsafe {\n+                // Get the raw representation of the trait object\n+                let to: TraitObject = transmute(self);\n+\n+                // Extract the data pointer\n+                Some(transmute(to.data))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl Error + 'static + Send {\n+    /// Forwards to the method defined on the type `Any`.\n+    #[unstable(feature = \"error_downcast\", reason = \"recently added\")]\n+    #[inline]\n+    pub fn is<T: Error + 'static>(&self) -> bool {\n+        <Error + 'static>::is::<T>(self)\n+    }\n+\n+    /// Forwards to the method defined on the type `Any`.\n+    #[unstable(feature = \"error_downcast\", reason = \"recently added\")]\n+    #[inline]\n+    pub fn downcast_ref<T: Error + 'static>(&self) -> Option<&T> {\n+        <Error + 'static>::downcast_ref::<T>(self)\n+    }\n+\n+    /// Forwards to the method defined on the type `Any`.\n+    #[unstable(feature = \"error_downcast\", reason = \"recently added\")]\n+    #[inline]\n+    pub fn downcast_mut<T: Error + 'static>(&mut self) -> Option<&mut T> {\n+        <Error + 'static>::downcast_mut::<T>(self)\n+    }\n+}\n+\n+impl Error {\n+    #[inline]\n+    #[unstable(feature = \"error_downcast\", reason = \"recently added\")]\n+    /// Attempt to downcast the box to a concrete type.\n+    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<Error>> {\n+        if self.is::<T>() {\n+            unsafe {\n+                // Get the raw representation of the trait object\n+                let raw = boxed::into_raw(self);\n+                let to: TraitObject =\n+                    transmute::<*mut Error, TraitObject>(raw);\n+\n+                // Extract the data pointer\n+                Ok(Box::from_raw(to.data as *mut T))\n+            }\n+        } else {\n+            Err(self)\n+        }\n+    }\n+}\n+\n+impl Error + Send {\n+    #[inline]\n+    #[unstable(feature = \"error_downcast\", reason = \"recently added\")]\n+    /// Attempt to downcast the box to a concrete type.\n+    pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<Error + Send>> {\n+        let err: Box<Error> = self;\n+        <Error>::downcast(err).map_err(|s| unsafe {\n+            // reapply the Send marker\n+            transmute::<Box<Error>, Box<Error + Send>>(s)\n+        })\n+    }\n+}"}, {"sha": "fc5405ea7f69ec220f93fe971dbdc9446e494d40", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -23,7 +23,7 @@ use fmt;\n use ffi::OsString;\n use io::{self, Error, ErrorKind, SeekFrom, Seek, Read, Write};\n use path::{Path, PathBuf};\n-use sys::fs2 as fs_imp;\n+use sys::fs as fs_imp;\n use sys_common::{AsInnerMut, FromInner, AsInner};\n use vec::Vec;\n \n@@ -643,7 +643,7 @@ impl Permissions {\n     /// use std::fs::File;\n     ///\n     /// # fn foo() -> std::io::Result<()> {\n-    /// let mut f = try!(File::create(\"foo.txt\"));\n+    /// let f = try!(File::create(\"foo.txt\"));\n     /// let metadata = try!(f.metadata());\n     /// let mut permissions = metadata.permissions();\n     ///"}, {"sha": "43a2629261882fafecd531f7e242331c0bc2c809", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -13,6 +13,7 @@\n use prelude::v1::*;\n use io::prelude::*;\n \n+use marker::Reflect;\n use cmp;\n use error;\n use fmt;\n@@ -118,7 +119,7 @@ impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug {\n     }\n }\n \n-#[unstable(feature = \"buf_seek\", reason = \"recently added\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<R: Seek> Seek for BufReader<R> {\n     /// Seek to an offset, in bytes, in the underlying reader.\n     ///\n@@ -282,8 +283,8 @@ impl<W: Write> fmt::Debug for BufWriter<W> where W: fmt::Debug {\n     }\n }\n \n-#[unstable(feature = \"buf_seek\", reason = \"recently added\")]\n-impl<W: Write+Seek> Seek for BufWriter<W> {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<W: Write + Seek> Seek for BufWriter<W> {\n     /// Seek to the offset, in bytes, in the underlying writer.\n     ///\n     /// Seeking always writes out the internal buffer before seeking.\n@@ -322,7 +323,7 @@ impl<W> From<IntoInnerError<W>> for Error {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Send + fmt::Debug> error::Error for IntoInnerError<W> {\n+impl<W: Reflect + Send + fmt::Debug> error::Error for IntoInnerError<W> {\n     fn description(&self) -> &str {\n         error::Error::description(self.error())\n     }\n@@ -432,15 +433,19 @@ impl<W: Read + Write> Read for InternalBufWriter<W> {\n /// infrequent calls to `read` and `write` on the underlying `Read+Write`.\n ///\n /// The output buffer will be written out when this stream is dropped.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"buf_stream\",\n+           reason = \"unsure about semantics of buffering two directions, \\\n+                     leading to issues like #17136\")]\n pub struct BufStream<S: Write> {\n     inner: BufReader<InternalBufWriter<S>>\n }\n \n+#[unstable(feature = \"buf_stream\",\n+           reason = \"unsure about semantics of buffering two directions, \\\n+                     leading to issues like #17136\")]\n impl<S: Read + Write> BufStream<S> {\n     /// Creates a new buffered stream with explicitly listed capacities for the\n     /// reader/writer buffer.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacities(reader_cap: usize, writer_cap: usize, inner: S)\n                            -> BufStream<S> {\n         let writer = BufWriter::with_capacity(writer_cap, inner);\n@@ -451,13 +456,11 @@ impl<S: Read + Write> BufStream<S> {\n \n     /// Creates a new buffered stream with the default reader/writer buffer\n     /// capacities.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: S) -> BufStream<S> {\n         BufStream::with_capacities(DEFAULT_BUF_SIZE, DEFAULT_BUF_SIZE, inner)\n     }\n \n     /// Gets a reference to the underlying stream.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &S {\n         let InternalBufWriter(ref w) = self.inner.inner;\n         w.get_ref()\n@@ -469,7 +472,6 @@ impl<S: Read + Write> BufStream<S> {\n     ///\n     /// It is inadvisable to read directly from or write directly to the\n     /// underlying stream.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut S {\n         let InternalBufWriter(ref mut w) = self.inner.inner;\n         w.get_mut()\n@@ -479,7 +481,6 @@ impl<S: Read + Write> BufStream<S> {\n     ///\n     /// The internal write buffer is written out before returning the stream.\n     /// Any leftover data in the read buffer is lost.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> Result<S, IntoInnerError<BufStream<S>>> {\n         let BufReader { inner: InternalBufWriter(w), buf, pos, cap } = self.inner;\n         w.into_inner().map_err(|IntoInnerError(w, e)| {\n@@ -490,20 +491,26 @@ impl<S: Read + Write> BufStream<S> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"buf_stream\",\n+           reason = \"unsure about semantics of buffering two directions, \\\n+                     leading to issues like #17136\")]\n impl<S: Read + Write> BufRead for BufStream<S> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }\n     fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"buf_stream\",\n+           reason = \"unsure about semantics of buffering two directions, \\\n+                     leading to issues like #17136\")]\n impl<S: Read + Write> Read for BufStream<S> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"buf_stream\",\n+           reason = \"unsure about semantics of buffering two directions, \\\n+                     leading to issues like #17136\")]\n impl<S: Read + Write> Write for BufStream<S> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.inner.get_mut().write(buf)\n@@ -513,7 +520,9 @@ impl<S: Read + Write> Write for BufStream<S> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"buf_stream\",\n+           reason = \"unsure about semantics of buffering two directions, \\\n+                     leading to issues like #17136\")]\n impl<S: Write> fmt::Debug for BufStream<S> where S: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let reader = &self.inner;"}, {"sha": "9089b417fcb99422082d9f86f1e66d6810db0b39", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -236,7 +236,7 @@ pub trait Read {\n \n     /// Transforms this `Read` instance to an `Iterator` over `char`s.\n     ///\n-    /// This adaptor will attempt to interpret this reader as an UTF-8 encoded\n+    /// This adaptor will attempt to interpret this reader as a UTF-8 encoded\n     /// sequence of characters. The returned iterator will return `None` once\n     /// EOF is reached for this reader. Otherwise each element yielded will be a\n     /// `Result<char, E>` where `E` may contain information about what I/O error"}, {"sha": "a14c472333c6eb0f93a263e456722f356088f9f2", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -355,13 +355,13 @@ impl<'a> Write for StderrLock<'a> {\n     }\n }\n \n-/// Resets the task-local stderr handle to the specified writer\n+/// Resets the thread-local stderr handle to the specified writer\n ///\n-/// This will replace the current task's stderr handle, returning the old\n+/// This will replace the current thread's stderr handle, returning the old\n /// handle. All future calls to `panic!` and friends will emit their output to\n /// this specified handle.\n ///\n-/// Note that this does not need to be called for all new tasks; the default\n+/// Note that this does not need to be called for all new threads; the default\n /// output handle is to the process's stderr stream.\n #[unstable(feature = \"set_stdio\",\n            reason = \"this function may disappear completely or be replaced \\\n@@ -378,13 +378,13 @@ pub fn set_panic(sink: Box<Write + Send>) -> Option<Box<Write + Send>> {\n     })\n }\n \n-/// Resets the task-local stdout handle to the specified writer\n+/// Resets the thread-local stdout handle to the specified writer\n ///\n-/// This will replace the current task's stdout handle, returning the old\n+/// This will replace the current thread's stdout handle, returning the old\n /// handle. All future calls to `print!` and friends will emit their output to\n /// this specified handle.\n ///\n-/// Note that this does not need to be called for all new tasks; the default\n+/// Note that this does not need to be called for all new threads; the default\n /// output handle is to the process's stdout stream.\n #[unstable(feature = \"set_stdio\",\n            reason = \"this function may disappear completely or be replaced \\"}, {"sha": "32193b4089d3079682130866499deb31d4ba2d4b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -16,10 +16,10 @@\n \n #![unstable(feature = \"std_misc\")]\n \n-/// The entry point for panic of Rust tasks.\n+/// The entry point for panic of Rust threads.\n ///\n-/// This macro is used to inject panic into a Rust task, causing the task to\n-/// unwind and panic entirely. Each task's panic can be reaped as the\n+/// This macro is used to inject panic into a Rust thread, causing the thread to\n+/// unwind and panic entirely. Each thread's panic can be reaped as the\n /// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n /// the value which is transmitted.\n ///\n@@ -38,10 +38,10 @@\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]\n-/// The entry point for panic of Rust tasks.\n+/// The entry point for panic of Rust threads.\n ///\n-/// This macro is used to inject panic into a Rust task, causing the task to\n-/// unwind and panic entirely. Each task's panic can be reaped as the\n+/// This macro is used to inject panic into a Rust thread, causing the thread to\n+/// unwind and panic entirely. Each thread's panic can be reaped as the\n /// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n /// the value which is transmitted.\n ///\n@@ -143,21 +143,23 @@ macro_rules! try {\n /// use std::sync::mpsc;\n ///\n /// // two placeholder functions for now\n-/// fn long_running_task() {}\n+/// fn long_running_thread() {}\n /// fn calculate_the_answer() -> u32 { 42 }\n ///\n /// let (tx1, rx1) = mpsc::channel();\n /// let (tx2, rx2) = mpsc::channel();\n ///\n-/// thread::spawn(move|| { long_running_task(); tx1.send(()).unwrap(); });\n+/// thread::spawn(move|| { long_running_thread(); tx1.send(()).unwrap(); });\n /// thread::spawn(move|| { tx2.send(calculate_the_answer()).unwrap(); });\n ///\n-/// select! (\n-///     _ = rx1.recv() => println!(\"the long running task finished first\"),\n+/// select! {\n+///     _ = rx1.recv() => println!(\"the long running thread finished first\"),\n ///     answer = rx2.recv() => {\n ///         println!(\"the answer was: {}\", answer.unwrap());\n ///     }\n-/// )\n+/// }\n+/// # drop(rx1.recv());\n+/// # drop(rx2.recv());\n /// ```\n ///\n /// For more information about select, see the `std::sync::mpsc::Select` structure.\n@@ -434,7 +436,7 @@ pub mod builtin {\n \n     /// Parse the current given file as an expression.\n     ///\n-    /// This is generally a bad idea, because it's going to behave unhygenically.\n+    /// This is generally a bad idea, because it's going to behave unhygienically.\n     ///\n     /// # Examples\n     ///"}, {"sha": "bc13d966a10b7b74eb450922f978f1ade95f4cc8", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 47, "deletions": 12, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -113,10 +113,13 @@ impl Ipv4Addr {\n \n     /// Returns true if the address appears to be globally routable.\n     ///\n-    /// Non-globally-routable networks include the private networks (10.0.0.0/8,\n-    /// 172.16.0.0/12 and 192.168.0.0/16), the loopback network (127.0.0.0/8),\n-    /// the link-local network (169.254.0.0/16), the broadcast address (255.255.255.255/32) and\n-    /// the test networks used for documentation (192.0.2.0/24, 198.51.100.0/24 and 203.0.113.0/24).\n+    /// The following return false:\n+    ///\n+    /// - private address (10.0.0.0/8, 172.16.0.0/12 and 192.168.0.0/16)\n+    /// - the loopback address (127.0.0.0/8)\n+    /// - the link-local address (169.254.0.0/16)\n+    /// - the broadcast address (255.255.255.255/32)\n+    /// - test addresses used for documentation (192.0.2.0/24, 198.51.100.0/24 and 203.0.113.0/24)\n     pub fn is_global(&self) -> bool {\n         !self.is_private() && !self.is_loopback() && !self.is_link_local() &&\n         !self.is_broadcast() && !self.is_documentation()\n@@ -139,7 +142,8 @@ impl Ipv4Addr {\n \n     /// Returns true if this address is in a range designated for documentation.\n     ///\n-    /// This is defined in RFC 5737\n+    /// This is defined in RFC 5737:\n+    ///\n     /// - 192.0.2.0/24 (TEST-NET-1)\n     /// - 198.51.100.0/24 (TEST-NET-2)\n     /// - 203.0.113.0/24 (TEST-NET-3)\n@@ -171,7 +175,6 @@ impl Ipv4Addr {\n                       ((self.octets()[0] as u16) << 8) | self.octets()[1] as u16,\n                       ((self.octets()[2] as u16) << 8) | self.octets()[3] as u16)\n     }\n-\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -244,6 +247,21 @@ impl FromInner<libc::in_addr> for Ipv4Addr {\n     }\n }\n \n+#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n+impl From<Ipv4Addr> for u32 {\n+    fn from(ip: Ipv4Addr) -> u32 {\n+        let ip = ip.octets();\n+        ((ip[0] as u32) << 24) + ((ip[1] as u32) << 16) + ((ip[2] as u32) << 8) + (ip[3] as u32)\n+    }\n+}\n+\n+#[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n+impl From<u32> for Ipv4Addr {\n+    fn from(ip: u32) -> Ipv4Addr {\n+        Ipv4Addr::new((ip >> 24) as u8, (ip >> 16) as u8, (ip >> 8) as u8, ip as u8)\n+    }\n+}\n+\n impl Ipv6Addr {\n     /// Creates a new IPv6 address from eight 16-bit segments.\n     ///\n@@ -284,9 +302,11 @@ impl Ipv6Addr {\n \n     /// Returns true if the address appears to be globally routable.\n     ///\n-    /// Non-globally-routable networks include the loopback address; the\n-    /// link-local, site-local, and unique local unicast addresses; and the\n-    /// interface-, link-, realm-, admin- and site-local multicast addresses.\n+    /// The following return false:\n+    ///\n+    /// - the loopback address\n+    /// - link-local, site-local, and unique local unicast addresses\n+    /// - interface-, link-, realm-, admin- and site-local multicast addresses\n     pub fn is_global(&self) -> bool {\n         match self.multicast_scope() {\n             Some(Ipv6MulticastScope::Global) => true,\n@@ -315,9 +335,12 @@ impl Ipv6Addr {\n \n     /// Returns true if the address is a globally routable unicast address.\n     ///\n-    /// Non-globally-routable unicast addresses include the loopback address,\n-    /// the link-local addresses, the deprecated site-local addresses and the\n-    /// unique local addresses.\n+    /// The following return false:\n+    ///\n+    /// - the loopback address\n+    /// - the link-local addresses\n+    /// - the (deprecated) site-local addresses\n+    /// - unique local addresses\n     pub fn is_unicast_global(&self) -> bool {\n         !self.is_multicast()\n             && !self.is_loopback() && !self.is_unicast_link_local()\n@@ -738,4 +761,16 @@ mod tests {\n         let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 12345);\n         assert_eq!(Ok(vec![a]), tsa(a));\n     }\n+\n+    #[test]\n+    fn test_ipv4_to_int() {\n+        let a = Ipv4Addr::new(127, 0, 0, 1);\n+        assert_eq!(u32::from(a), 2130706433);\n+    }\n+\n+    #[test]\n+    fn test_int_to_ipv4() {\n+        let a = Ipv4Addr::new(127, 0, 0, 1);\n+        assert_eq!(Ipv4Addr::from(2130706433), a);\n+    }\n }"}, {"sha": "bff9774bcd04a978b91608b1e2ddaff367da3852", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -15,7 +15,7 @@\n use prelude::v1::*;\n \n use io::{self, Error, ErrorKind};\n-use sys_common::net2 as net_imp;\n+use sys_common::net as net_imp;\n \n pub use self::ip::{IpAddr, Ipv4Addr, Ipv6Addr, Ipv6MulticastScope};\n pub use self::addr::{SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs};\n@@ -32,7 +32,7 @@ mod parser;\n \n /// Possible values which can be passed to the `shutdown` method of `TcpStream`\n /// and `UdpSocket`.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Shutdown {\n     /// Indicates that the reading portion of this stream/socket should be shut"}, {"sha": "69f40d7e7befe2b8850b252c946b9fa9e9da159a", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -61,7 +61,7 @@ impl<'a> Parser<'a> {\n     }\n \n     // Return result of first successful parser\n-    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T>>])\n+    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T> + 'static>])\n                -> Option<T> {\n         for pf in parsers.iter_mut() {\n             match self.read_atomically(|p: &mut Parser| pf(p)) {\n@@ -291,7 +291,7 @@ impl<'a> Parser<'a> {\n     }\n }\n \n-#[unstable(feature = \"ip_addr\", reason = \"recent addition\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for IpAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {"}, {"sha": "28063c1edb3f744755fd6c61cd9ce8b5fb5b5b62", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -14,9 +14,10 @@\n use prelude::v1::*;\n use io::prelude::*;\n \n+use fmt;\n use io;\n use net::{ToSocketAddrs, SocketAddr, Shutdown};\n-use sys_common::net2 as net_imp;\n+use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner};\n \n /// A structure which represents a TCP stream between a local socket and a\n@@ -167,6 +168,12 @@ impl FromInner<net_imp::TcpStream> for TcpStream {\n     fn from_inner(inner: net_imp::TcpStream) -> TcpStream { TcpStream(inner) }\n }\n \n+impl fmt::Debug for TcpStream {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n impl TcpListener {\n     /// Creates a new `TcpListener` which will be bound to the specified\n     /// address.\n@@ -239,6 +246,12 @@ impl FromInner<net_imp::TcpListener> for TcpListener {\n     }\n }\n \n+impl fmt::Debug for TcpListener {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n@@ -248,6 +261,7 @@ mod tests {\n     use net::*;\n     use net::test::{next_test_ip4, next_test_ip6};\n     use sync::mpsc::channel;\n+    use sys_common::AsInner;\n     use thread;\n \n     fn each_ip(f: &mut FnMut(SocketAddr)) {\n@@ -430,7 +444,7 @@ mod tests {\n             let _t = thread::spawn(move|| {\n                 let acceptor = acceptor;\n                 for (i, stream) in acceptor.incoming().enumerate().take(MAX) {\n-                    // Start another task to handle the connection\n+                    // Start another thread to handle the connection\n                     let _t = thread::spawn(move|| {\n                         let mut stream = t!(stream);\n                         let mut buf = [0];\n@@ -464,7 +478,7 @@ mod tests {\n \n             let _t = thread::spawn(move|| {\n                 for stream in acceptor.incoming().take(MAX) {\n-                    // Start another task to handle the connection\n+                    // Start another thread to handle the connection\n                     let _t = thread::spawn(move|| {\n                         let mut stream = t!(stream);\n                         let mut buf = [0];\n@@ -724,7 +738,7 @@ mod tests {\n                 assert_eq!(t!(s2.read(&mut [0])), 0);\n                 tx.send(()).unwrap();\n             });\n-            // this should wake up the child task\n+            // this should wake up the child thread\n             t!(s.shutdown(Shutdown::Read));\n \n             // this test will never finish if the child doesn't wake up\n@@ -738,7 +752,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let accept = t!(TcpListener::bind(&addr));\n \n-            // Enqueue a task to write to a socket\n+            // Enqueue a thread to write to a socket\n             let (tx, rx) = channel();\n             let (txdone, rxdone) = channel();\n             let txdone2 = txdone.clone();\n@@ -818,4 +832,27 @@ mod tests {\n             rx.recv().unwrap();\n         })\n     }\n+\n+    #[test]\n+    fn debug() {\n+        let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n+        let socket_addr = next_test_ip4();\n+\n+        let listener = t!(TcpListener::bind(&socket_addr));\n+        let listener_inner = listener.0.socket().as_inner();\n+        let compare = format!(\"TcpListener {{ addr: {:?}, {}: {:?} }}\",\n+                              socket_addr, name, listener_inner);\n+        assert_eq!(format!(\"{:?}\", listener), compare);\n+\n+        let mut stream = t!(TcpStream::connect(&(\"localhost\",\n+                                                 socket_addr.port())));\n+        let stream_inner = stream.0.socket().as_inner();\n+        let compare = format!(\"TcpStream {{ addr: {:?}, \\\n+                              peer: {:?}, {}: {:?} }}\",\n+                              stream.local_addr().unwrap(),\n+                              stream.peer_addr().unwrap(),\n+                              name,\n+                              stream_inner);\n+        assert_eq!(format!(\"{:?}\", stream), compare);\n+    }\n }"}, {"sha": "67c7096904d6f9abe2e9da4cfba0d4d038650692", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -13,9 +13,10 @@\n \n use prelude::v1::*;\n \n+use fmt;\n use io::{self, Error, ErrorKind};\n use net::{ToSocketAddrs, SocketAddr, IpAddr};\n-use sys_common::net2 as net_imp;\n+use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner};\n \n /// A User Datagram Protocol socket.\n@@ -136,6 +137,12 @@ impl FromInner<net_imp::UdpSocket> for UdpSocket {\n     fn from_inner(inner: net_imp::UdpSocket) -> UdpSocket { UdpSocket(inner) }\n }\n \n+impl fmt::Debug for UdpSocket {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n@@ -144,6 +151,7 @@ mod tests {\n     use net::*;\n     use net::test::{next_test_ip4, next_test_ip6};\n     use sync::mpsc::channel;\n+    use sys_common::AsInner;\n     use thread;\n \n     fn each_ip(f: &mut FnMut(SocketAddr, SocketAddr)) {\n@@ -301,4 +309,16 @@ mod tests {\n             serv_rx.recv().unwrap();\n         })\n     }\n+\n+    #[test]\n+    fn debug() {\n+        let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n+        let socket_addr = next_test_ip4();\n+\n+        let udpsock = t!(UdpSocket::bind(&socket_addr));\n+        let udpsock_inner = udpsock.0.socket().as_inner();\n+        let compare = format!(\"UdpSocket {{ addr: {:?}, {}: {:?} }}\",\n+                              socket_addr, name, udpsock_inner);\n+        assert_eq!(format!(\"{:?}\", udpsock), compare);\n+    }\n }"}, {"sha": "1ee3aab2727a864f8540e9ef95f87e1a09d7031c", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -21,7 +21,6 @@ use core::num;\n use intrinsics;\n use libc::c_int;\n use num::{FpCategory, ParseFloatError};\n-use sys_common::FromInner;\n \n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n pub use core::f32::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -77,7 +76,7 @@ impl f32 {\n     /// Parses a float as with a given radix\n     #[unstable(feature = \"float_from_str_radix\", reason = \"recently moved API\")]\n     pub fn from_str_radix(s: &str, radix: u32) -> Result<f32, ParseFloatError> {\n-        num::Float::from_str_radix(s, radix).map_err(FromInner::from_inner)\n+        num::Float::from_str_radix(s, radix)\n     }\n \n     /// Returns `true` if this value is `NaN` and false otherwise."}, {"sha": "398afcb553c1ce5006593e1afcf35cbfc1e14ce0", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -20,7 +20,6 @@ use core::num;\n use intrinsics;\n use libc::c_int;\n use num::{FpCategory, ParseFloatError};\n-use sys_common::FromInner;\n \n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON};\n pub use core::f64::{MIN_EXP, MAX_EXP, MIN_10_EXP};\n@@ -85,7 +84,7 @@ impl f64 {\n     /// Parses a float as with a given radix\n     #[unstable(feature = \"float_from_str_radix\", reason = \"recently moved API\")]\n     pub fn from_str_radix(s: &str, radix: u32) -> Result<f64, ParseFloatError> {\n-        num::Float::from_str_radix(s, radix).map_err(FromInner::from_inner)\n+        num::Float::from_str_radix(s, radix)\n     }\n \n     /// Returns `true` if this value is `NaN` and false otherwise."}, {"sha": "9a52a0214e9ccea8dee7bf9886ad4547f684be5a", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -16,16 +16,14 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-use fmt;\n-use core::num;\n-\n pub use core::num::{Zero, One};\n-pub use core::num::{FpCategory, ParseIntError};\n+pub use core::num::{FpCategory, ParseIntError, ParseFloatError};\n pub use core::num::{wrapping, Wrapping};\n \n-#[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n #[cfg(test)] use cmp::PartialEq;\n+#[cfg(test)] use fmt;\n #[cfg(test)] use marker::Copy;\n+#[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n \n /// Helper function for testing numeric operations\n #[cfg(test)]\n@@ -43,31 +41,6 @@ pub fn test_num<T>(ten: T, two: T) where\n     assert_eq!(ten.rem(two),  ten % two);\n }\n \n-/// An error which can be returned when parsing a float.\n-#[derive(Debug, Clone, PartialEq)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ParseFloatError { inner: num::ParseFloatError }\n-\n-impl ::sys_common::FromInner<num::ParseFloatError> for ParseFloatError {\n-    fn from_inner(inner: num::ParseFloatError) -> ParseFloatError {\n-        ParseFloatError { inner: inner }\n-    }\n-}\n-\n-impl ParseFloatError {\n-    #[unstable(feature = \"core\", reason = \"available through Error trait\")]\n-    pub fn description(&self) -> &str {\n-        self.inner.description()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for ParseFloatError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.description().fmt(f)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use core::prelude::*;"}, {"sha": "a94abba5d12bf7c25c1eafab788f0ce2057f8056", "filename": "src/libstd/os/android/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fandroid%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -15,5 +15,5 @@\n pub mod raw;\n \n pub mod fs {\n-    pub use sys::fs2::MetadataExt;\n+    pub use sys::fs::MetadataExt;\n }"}, {"sha": "1fe5fdd4e146c925fff3a86c4e6a01c3bd829c77", "filename": "src/libstd/os/bitrig/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fbitrig%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -15,5 +15,5 @@\n pub mod raw;\n \n pub mod fs {\n-    pub use sys::fs2::MetadataExt;\n+    pub use sys::fs::MetadataExt;\n }"}, {"sha": "d5c7c58173333fbee0410def34bc64e93efa9340", "filename": "src/libstd/os/dragonfly/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fdragonfly%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -15,5 +15,5 @@\n pub mod raw;\n \n pub mod fs {\n-    pub use sys::fs2::MetadataExt;\n+    pub use sys::fs::MetadataExt;\n }"}, {"sha": "86522cc1e795cf5d1f860282d0cf49f11e1e95ec", "filename": "src/libstd/os/dragonfly/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fdragonfly%2Fraw.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -11,7 +11,7 @@\n //! Dragonfly-specific raw type definitions\n \n use os::raw::c_long;\n-use os::unix::raw::{pid_t, uid_t, gid_t};\n+use os::unix::raw::{uid_t, gid_t};\n \n pub type blkcnt_t = i64;\n pub type blksize_t = u32;"}, {"sha": "28c9f8321f8a95163b319952bde45d2b74abb87f", "filename": "src/libstd/os/freebsd/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffreebsd%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -15,5 +15,5 @@\n pub mod raw;\n \n pub mod fs {\n-    pub use sys::fs2::MetadataExt;\n+    pub use sys::fs::MetadataExt;\n }"}, {"sha": "a3b95738a1a1a1e2c1c3f042ee4ba3a4c8c71075", "filename": "src/libstd/os/freebsd/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffreebsd%2Fraw.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -11,7 +11,7 @@\n //! FreeBSD-specific raw type definitions\n \n use os::raw::c_long;\n-use os::unix::raw::{uid_t, gid_t, pid_t};\n+use os::unix::raw::{uid_t, gid_t};\n \n pub type blkcnt_t = i64;\n pub type blksize_t = i64;"}, {"sha": "dd2878c6e383cd6933022927f0b56ab9b711e069", "filename": "src/libstd/os/ios/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fios%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fios%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fios%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -15,5 +15,5 @@\n pub mod raw;\n \n pub mod fs {\n-    pub use sys::fs2::MetadataExt;\n+    pub use sys::fs::MetadataExt;\n }"}, {"sha": "a66e01b2c39922c33185f70b58b3ae18b0eaa15e", "filename": "src/libstd/os/ios/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fios%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fios%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fios%2Fraw.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -11,7 +11,7 @@\n //! iOS-specific raw type definitions\n \n use os::raw::c_long;\n-use os::unix::raw::{uid_t, gid_t, pid_t};\n+use os::unix::raw::{uid_t, gid_t};\n \n pub type blkcnt_t = i64;\n pub type blksize_t = i32;"}, {"sha": "d2f9bcc3bcf9e8b993fb7288d9a6af763a6e6b6d", "filename": "src/libstd/os/linux/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -15,5 +15,5 @@\n pub mod raw;\n \n pub mod fs {\n-    pub use sys::fs2::MetadataExt;\n+    pub use sys::fs::MetadataExt;\n }"}, {"sha": "9589f4cf099b2a9ebe647522343a7517c54dd538", "filename": "src/libstd/os/linux/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Flinux%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Flinux%2Fraw.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -60,8 +60,8 @@ mod arch {\n #[cfg(any(target_arch = \"mips\",\n           target_arch = \"mipsel\"))]\n mod arch {\n-    use super::{dev_t, mode_t};\n-    use os::raw::c_long;\n+    use super::mode_t;\n+    use os::raw::{c_long, c_ulong};\n     use os::unix::raw::{gid_t, uid_t};\n \n     pub type blkcnt_t = i32;"}, {"sha": "6c96909f382e8c16617587077582bece0030dfe9", "filename": "src/libstd/os/macos/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmacos%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -15,5 +15,5 @@\n pub mod raw;\n \n pub mod fs {\n-    pub use sys::fs2::MetadataExt;\n+    pub use sys::fs::MetadataExt;\n }"}, {"sha": "413bb72f6e1c3e3ae2e93a20cc8de34f98131e06", "filename": "src/libstd/os/nacl/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fnacl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fnacl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fnacl%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -15,5 +15,5 @@\n pub mod raw;\n \n pub mod fs {\n-    pub use sys::fs2::MetadataExt;\n+    pub use sys::fs::MetadataExt;\n }"}, {"sha": "5654a7a0229634f45f0cc89cbbda9de7f98dac94", "filename": "src/libstd/os/openbsd/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fopenbsd%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -15,5 +15,5 @@\n pub mod raw;\n \n pub mod fs {\n-    pub use sys::fs2::MetadataExt;\n+    pub use sys::fs::MetadataExt;\n }"}, {"sha": "0bdba9e3487f1c14acb1f2ecd749d1dbaf3e1c4f", "filename": "src/libstd/os/openbsd/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fopenbsd%2Fraw.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -11,7 +11,7 @@\n //! OpenBSD-specific raw type definitions\n \n use os::raw::c_long;\n-use os::unix::raw::{uid_t, gid_t, pid_t};\n+use os::unix::raw::{uid_t, gid_t};\n \n pub type blkcnt_t = i64;\n pub type blksize_t = u32;"}, {"sha": "8ccc387c9027788adb1e7603bdbc34f1a01a58d4", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -358,7 +358,7 @@ pub fn is_separator(c: char) -> bool {\n     c.is_ascii() && is_sep_byte(c as u8)\n }\n \n-/// The primary sperator for the current platform\n+/// The primary separator for the current platform\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const MAIN_SEPARATOR: char = platform::MAIN_SEP;\n "}, {"sha": "4a8cceb202f5d3dad7a115c8b06fb2007d1b3ddb", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -19,7 +19,7 @@\n //! ```\n //!\n //! This means that the contents of std can be accessed from any context\n-//! with the `std::` path prefix, as in `use std::vec`, `use std::task::spawn`,\n+//! with the `std::` path prefix, as in `use std::vec`, `use std::thread::spawn`,\n //! etc.\n //!\n //! Additionally, `std` contains a `prelude` module that reexports many of the"}, {"sha": "61398e16ba03613e4063433b155e1fb97d41a081", "filename": "src/libstd/process.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -21,11 +21,11 @@ use fmt;\n use io::{self, Error, ErrorKind};\n use path;\n use sync::mpsc::{channel, Receiver};\n-use sys::pipe2::{self, AnonPipe};\n-use sys::process2::Command as CommandImp;\n-use sys::process2::Process as ProcessImp;\n-use sys::process2::ExitStatus as ExitStatusImp;\n-use sys::process2::Stdio as StdioImp2;\n+use sys::pipe::{self, AnonPipe};\n+use sys::process::Command as CommandImp;\n+use sys::process::Process as ProcessImp;\n+use sys::process::ExitStatus as ExitStatusImp;\n+use sys::process::Stdio as StdioImp2;\n use sys_common::{AsInner, AsInnerMut};\n use thread;\n \n@@ -334,7 +334,7 @@ fn setup_io(io: &StdioImp, readable: bool)\n         Null => (StdioImp2::None, None),\n         Inherit => (StdioImp2::Inherit, None),\n         Piped => {\n-            let (reader, writer) = try!(pipe2::anon_pipe());\n+            let (reader, writer) = try!(pipe::anon_pipe());\n             if readable {\n                 (StdioImp2::Piped(reader), Some(writer))\n             } else {"}, {"sha": "3c36f0f1d490c223dbd01c57d52654cf8501c916", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -374,7 +374,7 @@ mod tests {\n             txs.push(tx);\n \n             thread::spawn(move|| {\n-                // wait until all the tasks are ready to go.\n+                // wait until all the threads are ready to go.\n                 rx.recv().unwrap();\n \n                 // deschedule to attempt to interleave things as much\n@@ -394,7 +394,7 @@ mod tests {\n             });\n         }\n \n-        // start all the tasks\n+        // start all the threads\n         for tx in &txs {\n             tx.send(()).unwrap();\n         }"}, {"sha": "b24099505ed896a7207760b3c4139bf7e23f141c", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -238,7 +238,7 @@ pub mod eabi {\n             -> uw::_Unwind_Reason_Code;\n     }\n \n-    #[lang=\"eh_personality\"]\n+    #[lang = \"eh_personality\"]\n     #[no_mangle] // referenced from rust_try.ll\n     #[allow(private_no_mangle_fns)]\n     extern fn rust_eh_personality(\n@@ -292,7 +292,7 @@ pub mod eabi {\n             -> uw::_Unwind_Reason_Code;\n     }\n \n-    #[lang=\"eh_personality\"]\n+    #[lang = \"eh_personality\"]\n     #[no_mangle] // referenced from rust_try.ll\n     pub extern \"C\" fn rust_eh_personality(\n         version: c_int,\n@@ -345,7 +345,7 @@ pub mod eabi {\n             -> uw::_Unwind_Reason_Code;\n     }\n \n-    #[lang=\"eh_personality\"]\n+    #[lang = \"eh_personality\"]\n     #[no_mangle] // referenced from rust_try.ll\n     #[allow(private_no_mangle_fns)]\n     extern \"C\" fn rust_eh_personality(\n@@ -432,7 +432,7 @@ pub mod eabi {\n         ) -> EXCEPTION_DISPOSITION;\n     }\n \n-    #[lang=\"eh_personality\"]\n+    #[lang = \"eh_personality\"]\n     #[no_mangle] // referenced from rust_try.ll\n     #[allow(private_no_mangle_fns)]\n     extern \"C\" fn rust_eh_personality(\n@@ -590,7 +590,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>,\n /// This is an unsafe and experimental API which allows for an arbitrary\n /// callback to be invoked when a thread panics. This callback is invoked on both\n /// the initial unwinding and a double unwinding if one occurs. Additionally,\n-/// the local `Task` will be in place for the duration of the callback, and\n+/// the local `Thread` will be in place for the duration of the callback, and\n /// the callback must ensure that it remains in place once the callback returns.\n ///\n /// Only a limited number of callbacks can be registered, and this function"}, {"sha": "8360620c3453b71fe806c04ec4904a370a59f65a", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -10,7 +10,7 @@\n \n use sync::{Mutex, Condvar};\n \n-/// A barrier enables multiple tasks to synchronize the beginning\n+/// A barrier enables multiple threads to synchronize the beginning\n /// of some computation.\n ///\n /// ```\n@@ -128,7 +128,7 @@ mod tests {\n             });\n         }\n \n-        // At this point, all spawned tasks should be blocked,\n+        // At this point, all spawned threads should be blocked,\n         // so we shouldn't get anything from the port\n         assert!(match rx.try_recv() {\n             Err(TryRecvError::Empty) => true,"}, {"sha": "77aeeca7968099b4d80e1633a695e5556a4bdc35", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -107,7 +107,7 @@\n //!\n //! let (tx, rx) = sync_channel::<i32>(0);\n //! thread::spawn(move|| {\n-//!     // This will wait for the parent task to start receiving\n+//!     // This will wait for the parent thread to start receiving\n //!     tx.send(53).unwrap();\n //! });\n //! rx.recv().unwrap();\n@@ -253,7 +253,7 @@\n // blocking. The implementation is essentially the entire blocking procedure\n // followed by an increment as soon as its woken up. The cancellation procedure\n // involves an increment and swapping out of to_wake to acquire ownership of the\n-// task to unblock.\n+// thread to unblock.\n //\n // Sadly this current implementation requires multiple allocations, so I have\n // seen the throughput of select() be much worse than it should be. I do not\n@@ -272,6 +272,7 @@ use error;\n use fmt;\n use mem;\n use cell::UnsafeCell;\n+use marker::Reflect;\n \n pub use self::select::{Select, Handle};\n use self::select::StartResult;\n@@ -288,7 +289,7 @@ mod mpsc_queue;\n mod spsc_queue;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n-/// one task\n+/// one thread\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Receiver<T> {\n     inner: UnsafeCell<Flavor<T>>,\n@@ -315,7 +316,7 @@ pub struct IntoIter<T> {\n }\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n-/// owned by one task, but it can be cloned to send to other tasks.\n+/// owned by one thread, but it can be cloned to send to other threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Sender<T> {\n     inner: UnsafeCell<Flavor<T>>,\n@@ -326,7 +327,7 @@ pub struct Sender<T> {\n unsafe impl<T: Send> Send for Sender<T> { }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n-/// owned by one task, but it can be cloned to send to other tasks.\n+/// owned by one thread, but it can be cloned to send to other threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SyncSender<T> {\n     inner: Arc<UnsafeCell<sync::Packet<T>>>,\n@@ -420,7 +421,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// Creates a new asynchronous channel, returning the sender/receiver halves.\n ///\n /// All data sent on the sender will become available on the receiver, and no\n-/// send will block the calling task (this channel has an \"infinite buffer\").\n+/// send will block the calling thread (this channel has an \"infinite buffer\").\n ///\n /// # Examples\n ///\n@@ -955,8 +956,7 @@ impl<T> fmt::Display for SendError<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send> error::Error for SendError<T> {\n-\n+impl<T: Send + Reflect> error::Error for SendError<T> {\n     fn description(&self) -> &str {\n         \"sending on a closed channel\"\n     }\n@@ -991,7 +991,7 @@ impl<T> fmt::Display for TrySendError<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send> error::Error for TrySendError<T> {\n+impl<T: Send + Reflect> error::Error for TrySendError<T> {\n \n     fn description(&self) -> &str {\n         match *self {\n@@ -1596,15 +1596,15 @@ mod tests {\n             drop(rx);  // destroy a shared\n             tx2.send(()).unwrap();\n         });\n-        // make sure the other task has gone to sleep\n+        // make sure the other thread has gone to sleep\n         for _ in 0..5000 { thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n         drop(tx);\n         t.send(()).unwrap();\n \n-        // wait for the child task to exit before we exit\n+        // wait for the child thread to exit before we exit\n         rx2.recv().unwrap();\n     }\n }\n@@ -2060,15 +2060,15 @@ mod sync_tests {\n             drop(rx);  // destroy a shared\n             tx2.send(()).unwrap();\n         });\n-        // make sure the other task has gone to sleep\n+        // make sure the other thread has gone to sleep\n         for _ in 0..5000 { thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n         drop(tx);\n         t.send(()).unwrap();\n \n-        // wait for the child task to exit before we exit\n+        // wait for the child thread to exit before we exit\n         rx2.recv().unwrap();\n     }\n "}, {"sha": "2c0da938cbf8b71c59079fa37e1c22ee6c5a02c5", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -28,7 +28,7 @@\n //! A mostly lock-free multi-producer, single consumer queue.\n //!\n //! This module contains an implementation of a concurrent MPSC queue. This\n-//! queue can be used to share data between tasks, and is also used as the\n+//! queue can be used to share data between threads, and is also used as the\n //! building block of channels in rust.\n //!\n //! Note that the current implementation of this queue has a caveat of the `pop`"}, {"sha": "7e9c017617d8ac43c81da9e16c4617cc63c62dbb", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -23,7 +23,7 @@\n /// # Implementation\n ///\n /// Oneshots are implemented around one atomic usize variable. This variable\n-/// indicates both the state of the port/chan but also contains any tasks\n+/// indicates both the state of the port/chan but also contains any threads\n /// blocked on the port. All atomic operations happen on this one word.\n ///\n /// In order to upgrade a oneshot channel, an upgrade is considered a disconnect\n@@ -55,7 +55,7 @@ const DISCONNECTED: usize = 2;   // channel is disconnected OR upgraded\n // whoever changed the state.\n \n pub struct Packet<T> {\n-    // Internal state of the chan/port pair (stores the blocked task as well)\n+    // Internal state of the chan/port pair (stores the blocked thread as well)\n     state: AtomicUsize,\n     // One-shot data slot location\n     data: Option<T>,\n@@ -139,7 +139,7 @@ impl<T> Packet<T> {\n     }\n \n     pub fn recv(&mut self) -> Result<T, Failure<T>> {\n-        // Attempt to not block the task (it's a little expensive). If it looks\n+        // Attempt to not block the thread (it's a little expensive). If it looks\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(Ordering::SeqCst) == EMPTY {\n             let (wait_token, signal_token) = blocking::tokens();\n@@ -317,8 +317,8 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    // Remove a previous selecting task from this port. This ensures that the\n-    // blocked task will no longer be visible to any other threads.\n+    // Remove a previous selecting thread from this port. This ensures that the\n+    // blocked thread will no longer be visible to any other threads.\n     //\n     // The return value indicates whether there's data on this port.\n     pub fn abort_selection(&mut self) -> Result<bool, Receiver<T>> {\n@@ -329,7 +329,7 @@ impl<T> Packet<T> {\n             s @ DATA |\n             s @ DISCONNECTED => s,\n \n-            // If we've got a blocked task, then use an atomic to gain ownership\n+            // If we've got a blocked thread, then use an atomic to gain ownership\n             // of it (may fail)\n             ptr => self.state.compare_and_swap(ptr, EMPTY, Ordering::SeqCst)\n         };\n@@ -338,7 +338,7 @@ impl<T> Packet<T> {\n         // about it.\n         match state {\n             EMPTY => unreachable!(),\n-            // our task used for select was stolen\n+            // our thread used for select was stolen\n             DATA => Ok(true),\n \n             // If the other end has hung up, then we have complete ownership"}, {"sha": "679cc550454fa77eba908a7c04b2c79b1095a801", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -58,7 +58,7 @@\n \n use core::prelude::*;\n \n-use core::cell::Cell;\n+use core::cell::{Cell, UnsafeCell};\n use core::marker;\n use core::mem;\n use core::ptr;\n@@ -70,9 +70,13 @@ use sync::mpsc::blocking::{self, SignalToken};\n /// The \"receiver set\" of the select interface. This structure is used to manage\n /// a set of receivers which are being selected over.\n pub struct Select {\n+    inner: UnsafeCell<SelectInner>,\n+    next_id: Cell<usize>,\n+}\n+\n+struct SelectInner {\n     head: *mut Handle<'static, ()>,\n     tail: *mut Handle<'static, ()>,\n-    next_id: Cell<usize>,\n }\n \n impl !marker::Send for Select {}\n@@ -84,7 +88,7 @@ pub struct Handle<'rx, T:Send+'rx> {\n     /// The ID of this handle, used to compare against the return value of\n     /// `Select::wait()`\n     id: usize,\n-    selector: &'rx Select,\n+    selector: *mut SelectInner,\n     next: *mut Handle<'static, ()>,\n     prev: *mut Handle<'static, ()>,\n     added: bool,\n@@ -127,8 +131,10 @@ impl Select {\n     /// ```\n     pub fn new() -> Select {\n         Select {\n-            head: ptr::null_mut(),\n-            tail: ptr::null_mut(),\n+            inner: UnsafeCell::new(SelectInner {\n+                head: ptr::null_mut(),\n+                tail: ptr::null_mut(),\n+            }),\n             next_id: Cell::new(1),\n         }\n     }\n@@ -141,7 +147,7 @@ impl Select {\n         self.next_id.set(id + 1);\n         Handle {\n             id: id,\n-            selector: self,\n+            selector: self.inner.get(),\n             next: ptr::null_mut(),\n             prev: ptr::null_mut(),\n             added: false,\n@@ -223,7 +229,7 @@ impl Select {\n             // woken us up (although the wakeup is guaranteed to fail).\n             //\n             // This situation happens in the window of where a sender invokes\n-            // increment(), sees -1, and then decides to wake up the task. After\n+            // increment(), sees -1, and then decides to wake up the thread. After\n             // all this is done, the sending thread will set `selecting` to\n             // `false`. Until this is done, we cannot return. If we were to\n             // return, then a sender could wake up a receiver which has gone\n@@ -250,7 +256,7 @@ impl Select {\n         }\n     }\n \n-    fn iter(&self) -> Packets { Packets { cur: self.head } }\n+    fn iter(&self) -> Packets { Packets { cur: unsafe { &*self.inner.get() }.head } }\n }\n \n impl<'rx, T: Send> Handle<'rx, T> {\n@@ -271,7 +277,7 @@ impl<'rx, T: Send> Handle<'rx, T> {\n     /// while it is added to the `Select` set.\n     pub unsafe fn add(&mut self) {\n         if self.added { return }\n-        let selector: &mut Select = mem::transmute(&*self.selector);\n+        let selector = &mut *self.selector;\n         let me: *mut Handle<'static, ()> = mem::transmute(&*self);\n \n         if selector.head.is_null() {\n@@ -292,7 +298,7 @@ impl<'rx, T: Send> Handle<'rx, T> {\n     pub unsafe fn remove(&mut self) {\n         if !self.added { return }\n \n-        let selector: &mut Select = mem::transmute(&*self.selector);\n+        let selector = &mut *self.selector;\n         let me: *mut Handle<'static, ()> = mem::transmute(&*self);\n \n         if self.prev.is_null() {\n@@ -317,8 +323,10 @@ impl<'rx, T: Send> Handle<'rx, T> {\n \n impl Drop for Select {\n     fn drop(&mut self) {\n-        assert!(self.head.is_null());\n-        assert!(self.tail.is_null());\n+        unsafe {\n+            assert!((&*self.inner.get()).head.is_null());\n+            assert!((&*self.inner.get()).tail.is_null());\n+        }\n     }\n }\n "}, {"sha": "41c79dd52c85a1a38d5e60c0be3da36c6398a757", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -91,8 +91,8 @@ impl<T> Packet<T> {\n     }\n \n     // This function is used at the creation of a shared packet to inherit a\n-    // previously blocked task. This is done to prevent spurious wakeups of\n-    // tasks in select().\n+    // previously blocked thread. This is done to prevent spurious wakeups of\n+    // threads in select().\n     //\n     // This can only be called at channel-creation time\n     pub fn inherit_blocker(&mut self,\n@@ -424,7 +424,7 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    // Cancels a previous task waiting on this port, returning whether there's\n+    // Cancels a previous thread waiting on this port, returning whether there's\n     // data on the port.\n     //\n     // This is similar to the stream implementation (hence fewer comments), but"}, {"sha": "b72da91c0a075cffd1ed7a4421070ae980358699", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -30,7 +30,7 @@\n //! A single-producer single-consumer concurrent queue\n //!\n //! This module contains the implementation of an SPSC queue which can be used\n-//! concurrently between two tasks. This data structure is safe to use and\n+//! concurrently between two threads. This data structure is safe to use and\n //! enforces the semantics that there is one pusher and one popper.\n \n #![unstable(feature = \"std_misc\")]"}, {"sha": "404814b4cd4bb6dfc8075184fffdbeeaedb97f36", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -181,7 +181,7 @@ impl<T> Packet<T> {\n             data => return data,\n         }\n \n-        // Welp, our channel has no data. Deschedule the current task and\n+        // Welp, our channel has no data. Deschedule the current thread and\n         // initiate the blocking protocol.\n         let (wait_token, signal_token) = blocking::tokens();\n         if self.decrement(signal_token).is_ok() {\n@@ -385,7 +385,7 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    // Removes a previous task from being blocked in this port\n+    // Removes a previous thread from being blocked in this port\n     pub fn abort_selection(&mut self,\n                            was_upgrade: bool) -> Result<bool, Receiver<T>> {\n         // If we're aborting selection after upgrading from a oneshot, then\n@@ -414,7 +414,7 @@ impl<T> Packet<T> {\n         let prev = self.bump(steals + 1);\n \n         // If we were previously disconnected, then we know for sure that there\n-        // is no task in to_wake, so just keep going\n+        // is no thread in to_wake, so just keep going\n         let has_data = if prev == DISCONNECTED {\n             assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n             true // there is data, that data is that we're disconnected\n@@ -428,7 +428,7 @@ impl<T> Packet<T> {\n             //\n             // If the previous count was positive then we're in a tougher\n             // situation. A possible race is that a sender just incremented\n-            // through -1 (meaning it's going to try to wake a task up), but it\n+            // through -1 (meaning it's going to try to wake a thread up), but it\n             // hasn't yet read the to_wake. In order to prevent a future recv()\n             // from waking up too early (this sender picking up the plastered\n             // over to_wake), we spin loop here waiting for to_wake to be 0."}, {"sha": "904eab1fd7efd18ac2f7a7a1c9105eb111746ad1", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -19,7 +19,7 @@\n /// which means that every successful send is paired with a successful recv.\n ///\n /// This flavor of channels defines a new `send_opt` method for channels which\n-/// is the method by which a message is sent but the task does not panic if it\n+/// is the method by which a message is sent but the thread does not panic if it\n /// cannot be delivered.\n ///\n /// Another major difference is that send() will *always* return back the data\n@@ -62,12 +62,12 @@ unsafe impl<T: Send> Sync for Packet<T> { }\n struct State<T> {\n     disconnected: bool, // Is the channel disconnected yet?\n     queue: Queue,       // queue of senders waiting to send data\n-    blocker: Blocker,   // currently blocked task on this channel\n+    blocker: Blocker,   // currently blocked thread on this channel\n     buf: Buffer<T>,     // storage for buffered messages\n     cap: usize,         // capacity of this channel\n \n     /// A curious flag used to indicate whether a sender failed or succeeded in\n-    /// blocking. This is used to transmit information back to the task that it\n+    /// blocking. This is used to transmit information back to the thread that it\n     /// must dequeue its message from the buffer because it was not received.\n     /// This is only relevant in the 0-buffer case. This obviously cannot be\n     /// safely constructed, but it's guaranteed to always have a valid pointer\n@@ -84,7 +84,7 @@ enum Blocker {\n     NoneBlocked\n }\n \n-/// Simple queue for threading tasks together. Nodes are stack-allocated, so\n+/// Simple queue for threading threads together. Nodes are stack-allocated, so\n /// this structure is not safe at all\n struct Queue {\n     head: *mut Node,\n@@ -130,7 +130,7 @@ fn wait<'a, 'b, T>(lock: &'a Mutex<State<T>>,\n \n /// Wakes up a thread, dropping the lock at the correct time\n fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n-    // We need to be careful to wake up the waiting task *outside* of the mutex\n+    // We need to be careful to wake up the waiting thread *outside* of the mutex\n     // in case it incurs a context switch.\n     drop(guard);\n     token.signal();\n@@ -298,7 +298,7 @@ impl<T> Packet<T> {\n         };\n         mem::drop(guard);\n \n-        // only outside of the lock do we wake up the pending tasks\n+        // only outside of the lock do we wake up the pending threads\n         pending_sender1.map(|t| t.signal());\n         pending_sender2.map(|t| t.signal());\n     }\n@@ -394,8 +394,8 @@ impl<T> Packet<T> {\n         }\n     }\n \n-    // Remove a previous selecting task from this port. This ensures that the\n-    // blocked task will no longer be visible to any other threads.\n+    // Remove a previous selecting thread from this port. This ensures that the\n+    // blocked thread will no longer be visible to any other threads.\n     //\n     // The return value indicates whether there's data on this port.\n     pub fn abort_selection(&self) -> bool {\n@@ -446,7 +446,7 @@ impl<T> Buffer<T> {\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-// Queue, a simple queue to enqueue tasks with (stack-allocated nodes)\n+// Queue, a simple queue to enqueue threads with (stack-allocated nodes)\n ////////////////////////////////////////////////////////////////////////////////\n \n impl Queue {"}, {"sha": "febf5f1b183223938d706341be1b86abf1ec0bb9", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -30,7 +30,7 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n ///\n /// The mutexes in this module implement a strategy called \"poisoning\" where a\n /// mutex is considered poisoned whenever a thread panics while holding the\n-/// lock. Once a mutex is poisoned, all other tasks are unable to access the\n+/// lock. Once a mutex is poisoned, all other threads are unable to access the\n /// data by default as it is likely tainted (some invariant is not being\n /// upheld).\n ///\n@@ -56,7 +56,7 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n /// // Spawn a few threads to increment a shared variable (non-atomically), and\n /// // let the main thread know once all increments are done.\n /// //\n-/// // Here we're using an Arc to share memory among tasks, and the data inside\n+/// // Here we're using an Arc to share memory among threads, and the data inside\n /// // the Arc is protected with a mutex.\n /// let data = Arc::new(Mutex::new(0));\n ///\n@@ -69,7 +69,7 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n ///         // which can access the shared state when the lock is held.\n ///         //\n ///         // We unwrap() the return value to assert that we are not expecting\n-///         // tasks to ever fail while holding the lock.\n+///         // threads to ever fail while holding the lock.\n ///         let mut data = data.lock().unwrap();\n ///         *data += 1;\n ///         if *data == N {\n@@ -112,7 +112,7 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n /// *guard += 1;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Mutex<T> {\n+pub struct Mutex<T: ?Sized> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n     // itself. Once a native mutex has been used once, its address can never\n     // change (it can't be moved). This mutex type can be safely moved at any\n@@ -124,9 +124,9 @@ pub struct Mutex<T> {\n \n // these are the only places where `T: Send` matters; all other\n // functionality works fine on a single thread.\n-unsafe impl<T: Send> Send for Mutex<T> { }\n+unsafe impl<T: ?Sized + Send> Send for Mutex<T> { }\n \n-unsafe impl<T: Send> Sync for Mutex<T> { }\n+unsafe impl<T: ?Sized + Send> Sync for Mutex<T> { }\n \n /// The static mutex type is provided to allow for static allocation of mutexes.\n ///\n@@ -164,15 +164,15 @@ pub struct StaticMutex {\n /// `Deref` and `DerefMut` implementations\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct MutexGuard<'a, T: 'a> {\n+pub struct MutexGuard<'a, T: ?Sized + 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n     __lock: &'a StaticMutex,\n     __data: &'a UnsafeCell<T>,\n     __poison: poison::Guard,\n }\n \n-impl<'a, T> !marker::Send for MutexGuard<'a, T> {}\n+impl<'a, T: ?Sized> !marker::Send for MutexGuard<'a, T> {}\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n@@ -192,11 +192,13 @@ impl<T> Mutex<T> {\n             data: UnsafeCell::new(t),\n         }\n     }\n+}\n \n-    /// Acquires a mutex, blocking the current task until it is able to do so.\n+impl<T: ?Sized> Mutex<T> {\n+    /// Acquires a mutex, blocking the current thread until it is able to do so.\n     ///\n-    /// This function will block the local task until it is available to acquire\n-    /// the mutex. Upon returning, the task is the only task with the mutex\n+    /// This function will block the local thread until it is available to acquire\n+    /// the mutex. Upon returning, the thread is the only thread with the mutex\n     /// held. An RAII guard is returned to allow scoped unlock of the lock. When\n     /// the guard goes out of scope, the mutex will be unlocked.\n     ///\n@@ -245,7 +247,7 @@ impl<T> Mutex<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Mutex<T> {\n+impl<T: ?Sized> Drop for Mutex<T> {\n     fn drop(&mut self) {\n         // This is actually safe b/c we know that there is no further usage of\n         // this mutex (it's up to the user to arrange for a mutex to get\n@@ -255,12 +257,12 @@ impl<T> Drop for Mutex<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug + 'static> fmt::Debug for Mutex<T> {\n+impl<T: ?Sized + fmt::Debug + 'static> fmt::Debug for Mutex<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.try_lock() {\n-            Ok(guard) => write!(f, \"Mutex {{ data: {:?} }}\", *guard),\n+            Ok(guard) => write!(f, \"Mutex {{ data: {:?} }}\", &*guard),\n             Err(TryLockError::Poisoned(err)) => {\n-                write!(f, \"Mutex {{ data: Poisoned({:?}) }}\", **err.get_ref())\n+                write!(f, \"Mutex {{ data: Poisoned({:?}) }}\", &**err.get_ref())\n             },\n             Err(TryLockError::WouldBlock) => write!(f, \"Mutex {{ <locked> }}\")\n         }\n@@ -310,7 +312,7 @@ impl StaticMutex {\n     }\n }\n \n-impl<'mutex, T> MutexGuard<'mutex, T> {\n+impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n \n     fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n            -> LockResult<MutexGuard<'mutex, T>> {\n@@ -325,22 +327,22 @@ impl<'mutex, T> MutexGuard<'mutex, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'mutex, T> Deref for MutexGuard<'mutex, T> {\n+impl<'mutex, T: ?Sized> Deref for MutexGuard<'mutex, T> {\n     type Target = T;\n \n     fn deref<'a>(&'a self) -> &'a T {\n         unsafe { &*self.__data.get() }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'mutex, T> DerefMut for MutexGuard<'mutex, T> {\n+impl<'mutex, T: ?Sized> DerefMut for MutexGuard<'mutex, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> Drop for MutexGuard<'a, T> {\n+impl<'a, T: ?Sized> Drop for MutexGuard<'a, T> {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n@@ -350,11 +352,11 @@ impl<'a, T> Drop for MutexGuard<'a, T> {\n     }\n }\n \n-pub fn guard_lock<'a, T>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n+pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n     &guard.__lock.lock\n }\n \n-pub fn guard_poison<'a, T>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n+pub fn guard_poison<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n     &guard.__lock.poison\n }\n \n@@ -528,4 +530,16 @@ mod tests {\n         let lock = arc.lock().unwrap();\n         assert_eq!(*lock, 2);\n     }\n+\n+    #[test]\n+    fn test_mutex_unsized() {\n+        let mutex: &Mutex<[i32]> = &Mutex::new([1, 2, 3]);\n+        {\n+            let b = &mut *mutex.lock().unwrap();\n+            b[0] = 4;\n+            b[2] = 5;\n+        }\n+        let comp: &[i32] = &[4, 2, 5];\n+        assert_eq!(&*mutex.lock().unwrap(), comp);\n+    }\n }"}, {"sha": "57baedaad9c8e85fef351e66874347d6414a28ad", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -55,13 +55,13 @@ impl Once {\n     /// will be executed if this is the first time `call_once` has been called,\n     /// and otherwise the routine will *not* be invoked.\n     ///\n-    /// This method will block the calling task if another initialization\n+    /// This method will block the calling thread if another initialization\n     /// routine is currently running.\n     ///\n     /// When this function returns, it is guaranteed that some initialization\n     /// has run and completed (it may not be the closure specified). It is also\n     /// guaranteed that any memory writes performed by the executed closure can\n-    /// be reliably observed by other tasks at this point (there is a\n+    /// be reliably observed by other threads at this point (there is a\n     /// happens-before relation between the closure and code executing after the\n     /// return).\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "625377df7d6dd71748146d87681fbc5c97c3756d", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 71, "deletions": 32, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -25,7 +25,7 @@ use sys_common::rwlock as sys;\n /// typically allows for read-only access (shared access).\n ///\n /// The type parameter `T` represents the data that this lock protects. It is\n-/// required that `T` satisfies `Send` to be shared across tasks and `Sync` to\n+/// required that `T` satisfies `Send` to be shared across threads and `Sync` to\n /// allow concurrent access through readers. The RAII guards returned from the\n /// locking methods implement `Deref` (and `DerefMut` for the `write` methods)\n /// to allow access to the contained of the lock.\n@@ -60,13 +60,13 @@ use sys_common::rwlock as sys;\n /// } // write lock is dropped here\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RwLock<T> {\n+pub struct RwLock<T: ?Sized> {\n     inner: Box<StaticRwLock>,\n     data: UnsafeCell<T>,\n }\n \n-unsafe impl<T: Send + Sync> Send for RwLock<T> {}\n-unsafe impl<T: Send + Sync> Sync for RwLock<T> {}\n+unsafe impl<T: ?Sized + Send + Sync> Send for RwLock<T> {}\n+unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n \n /// Structure representing a statically allocated RwLock.\n ///\n@@ -111,24 +111,24 @@ pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n /// dropped.\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RwLockReadGuard<'a, T: 'a> {\n+pub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n }\n \n-impl<'a, T> !marker::Send for RwLockReadGuard<'a, T> {}\n+impl<'a, T: ?Sized> !marker::Send for RwLockReadGuard<'a, T> {}\n \n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RwLockWriteGuard<'a, T: 'a> {\n+pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n     __poison: poison::Guard,\n }\n \n-impl<'a, T> !marker::Send for RwLockWriteGuard<'a, T> {}\n+impl<'a, T: ?Sized> !marker::Send for RwLockWriteGuard<'a, T> {}\n \n impl<T> RwLock<T> {\n     /// Creates a new instance of an `RwLock<T>` which is unlocked.\n@@ -144,7 +144,9 @@ impl<T> RwLock<T> {\n     pub fn new(t: T) -> RwLock<T> {\n         RwLock { inner: box RW_LOCK_INIT, data: UnsafeCell::new(t) }\n     }\n+}\n \n+impl<T: ?Sized> RwLock<T> {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n     ///\n@@ -169,14 +171,16 @@ impl<T> RwLock<T> {\n         RwLockReadGuard::new(&*self.inner, &self.data)\n     }\n \n-    /// Attempts to acquire this lock with shared read access.\n+    /// Attempts to acquire this rwlock with shared read access.\n+    ///\n+    /// If the access could not be granted at this time, then `Err` is returned.\n+    /// Otherwise, an RAII guard is returned which will release the shared access\n+    /// when it is dropped.\n     ///\n-    /// This function will never block and will return immediately if `read`\n-    /// would otherwise succeed. Returns `Some` of an RAII guard which will\n-    /// release the shared access of this thread when dropped, or `None` if the\n-    /// access could not be granted. This method does not provide any\n-    /// guarantees with respect to the ordering of whether contentious readers\n-    /// or writers will acquire the lock first.\n+    /// This function does not block.\n+    ///\n+    /// This function does not provide any guarantees with respect to the ordering\n+    /// of whether contentious readers or writers will acquire the lock first.\n     ///\n     /// # Failure\n     ///\n@@ -217,9 +221,14 @@ impl<T> RwLock<T> {\n \n     /// Attempts to lock this rwlock with exclusive write access.\n     ///\n-    /// This function does not ever block, and it will return `None` if a call\n-    /// to `write` would otherwise block. If successful, an RAII guard is\n-    /// returned.\n+    /// If the lock could not be acquired at this time, then `Err` is returned.\n+    /// Otherwise, an RAII guard is returned which will release the lock when\n+    /// it is dropped.\n+    ///\n+    /// This function does not block.\n+    ///\n+    /// This function does not provide any guarantees with respect to the ordering\n+    /// of whether contentious readers or writers will acquire the lock first.\n     ///\n     /// # Failure\n     ///\n@@ -230,7 +239,7 @@ impl<T> RwLock<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn try_write(&self) -> TryLockResult<RwLockWriteGuard<T>> {\n-        if unsafe { self.inner.lock.try_read() } {\n+        if unsafe { self.inner.lock.try_write() } {\n             Ok(try!(RwLockWriteGuard::new(&*self.inner, &self.data)))\n         } else {\n             Err(TryLockError::WouldBlock)\n@@ -250,19 +259,19 @@ impl<T> RwLock<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for RwLock<T> {\n+impl<T: ?Sized> Drop for RwLock<T> {\n     fn drop(&mut self) {\n         unsafe { self.inner.lock.destroy() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for RwLock<T> {\n+impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.try_read() {\n-            Ok(guard) => write!(f, \"RwLock {{ data: {:?} }}\", *guard),\n+            Ok(guard) => write!(f, \"RwLock {{ data: {:?} }}\", &*guard),\n             Err(TryLockError::Poisoned(err)) => {\n-                write!(f, \"RwLock {{ data: Poisoned({:?}) }}\", **err.get_ref())\n+                write!(f, \"RwLock {{ data: Poisoned({:?}) }}\", &**err.get_ref())\n             },\n             Err(TryLockError::WouldBlock) => write!(f, \"RwLock {{ <locked> }}\")\n         }\n@@ -341,8 +350,7 @@ impl StaticRwLock {\n     }\n }\n \n-impl<'rwlock, T> RwLockReadGuard<'rwlock, T> {\n-\n+impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n     fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockReadGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |_| {\n@@ -353,8 +361,8 @@ impl<'rwlock, T> RwLockReadGuard<'rwlock, T> {\n         })\n     }\n }\n-impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n \n+impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n     fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n@@ -368,33 +376,35 @@ impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'rwlock, T> Deref for RwLockReadGuard<'rwlock, T> {\n+impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'rwlock, T> Deref for RwLockWriteGuard<'rwlock, T> {\n+impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'rwlock, T> DerefMut for RwLockWriteGuard<'rwlock, T> {\n+impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> Drop for RwLockReadGuard<'a, T> {\n+impl<'a, T: ?Sized> Drop for RwLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n         unsafe { self.__lock.lock.read_unlock(); }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> Drop for RwLockWriteGuard<'a, T> {\n+impl<'a, T: ?Sized> Drop for RwLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n         self.__lock.poison.done(&self.__poison);\n         unsafe { self.__lock.lock.write_unlock(); }\n@@ -410,7 +420,7 @@ mod tests {\n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n     use thread;\n-    use sync::{Arc, RwLock, StaticRwLock, RW_LOCK_INIT};\n+    use sync::{Arc, RwLock, StaticRwLock, TryLockError, RW_LOCK_INIT};\n \n     #[test]\n     fn smoke() {\n@@ -562,4 +572,33 @@ mod tests {\n         let lock = arc.read().unwrap();\n         assert_eq!(*lock, 2);\n     }\n+\n+    #[test]\n+    fn test_rwlock_unsized() {\n+        let rw: &RwLock<[i32]> = &RwLock::new([1, 2, 3]);\n+        {\n+            let b = &mut *rw.write().unwrap();\n+            b[0] = 4;\n+            b[2] = 5;\n+        }\n+        let comp: &[i32] = &[4, 2, 5];\n+        assert_eq!(&*rw.read().unwrap(), comp);\n+    }\n+\n+    #[test]\n+    fn test_rwlock_try_write() {\n+        use mem::drop;\n+\n+        let lock = RwLock::new(0isize);\n+        let read_guard = lock.read().unwrap();\n+\n+        let write_result = lock.try_write();\n+        match write_result {\n+            Err(TryLockError::WouldBlock) => (),\n+            Ok(_) => assert!(false, \"try_write should not succeed while read_guard is in scope\"),\n+            Err(_) => assert!(false, \"unexpected error\"),\n+        }\n+\n+        drop(read_guard);\n+    }\n }"}, {"sha": "34a58f6c83aa73002f781376b81c0bc049f211a5", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "removed", "additions": 0, "deletions": 170, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -1,170 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementation of the helper thread for the timer module\n-//!\n-//! This module contains the management necessary for the timer worker thread.\n-//! This thread is responsible for performing the send()s on channels for timers\n-//! that are using channels instead of a blocking call.\n-//!\n-//! The timer thread is lazily initialized, and it's shut down via the\n-//! `shutdown` function provided. It must be maintained as an invariant that\n-//! `shutdown` is only called when the entire program is finished. No new timers\n-//! can be created in the future and there must be no active timers at that\n-//! time.\n-\n-use prelude::v1::*;\n-\n-use boxed;\n-use cell::UnsafeCell;\n-use rt;\n-use sync::{StaticMutex, StaticCondvar};\n-use sync::mpsc::{channel, Sender, Receiver};\n-use sys::helper_signal;\n-\n-use thread;\n-\n-/// A structure for management of a helper thread.\n-///\n-/// This is generally a static structure which tracks the lifetime of a helper\n-/// thread.\n-///\n-/// The fields of this helper are all public, but they should not be used, this\n-/// is for static initialization.\n-pub struct Helper<M:Send> {\n-    /// Internal lock which protects the remaining fields\n-    pub lock: StaticMutex,\n-    pub cond: StaticCondvar,\n-\n-    // You'll notice that the remaining fields are UnsafeCell<T>, and this is\n-    // because all helper thread operations are done through &self, but we need\n-    // these to be mutable (once `lock` is held).\n-\n-    /// Lazily allocated channel to send messages to the helper thread.\n-    pub chan: UnsafeCell<*mut Sender<M>>,\n-\n-    /// OS handle used to wake up a blocked helper thread\n-    pub signal: UnsafeCell<usize>,\n-\n-    /// Flag if this helper thread has booted and been initialized yet.\n-    pub initialized: UnsafeCell<bool>,\n-\n-    /// Flag if this helper thread has shut down\n-    pub shutdown: UnsafeCell<bool>,\n-}\n-\n-unsafe impl<M:Send> Send for Helper<M> { }\n-\n-unsafe impl<M:Send> Sync for Helper<M> { }\n-\n-struct RaceBox(helper_signal::signal);\n-\n-unsafe impl Send for RaceBox {}\n-unsafe impl Sync for RaceBox {}\n-\n-macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n-    static $name: Helper<$m> = Helper {\n-        lock: ::sync::MUTEX_INIT,\n-        cond: ::sync::CONDVAR_INIT,\n-        chan: ::cell::UnsafeCell { value: 0 as *mut Sender<$m> },\n-        signal: ::cell::UnsafeCell { value: 0 },\n-        initialized: ::cell::UnsafeCell { value: false },\n-        shutdown: ::cell::UnsafeCell { value: false },\n-    };\n-) }\n-\n-impl<M: Send> Helper<M> {\n-    /// Lazily boots a helper thread, becoming a no-op if the helper has already\n-    /// been spawned.\n-    ///\n-    /// This function will check to see if the thread has been initialized, and\n-    /// if it has it returns quickly. If initialization has not happened yet,\n-    /// the closure `f` will be run (inside of the initialization lock) and\n-    /// passed to the helper thread in a separate task.\n-    ///\n-    /// This function is safe to be called many times.\n-    pub fn boot<T, F>(&'static self, f: F, helper: fn(helper_signal::signal, Receiver<M>, T)) where\n-        T: Send + 'static,\n-        F: FnOnce() -> T,\n-    {\n-        unsafe {\n-            let _guard = self.lock.lock().unwrap();\n-            if *self.chan.get() as usize == 0 {\n-                let (tx, rx) = channel();\n-                *self.chan.get() = boxed::into_raw(box tx);\n-                let (receive, send) = helper_signal::new();\n-                *self.signal.get() = send as usize;\n-\n-                let receive = RaceBox(receive);\n-\n-                let t = f();\n-                thread::spawn(move || {\n-                    helper(receive.0, rx, t);\n-                    let _g = self.lock.lock().unwrap();\n-                    *self.shutdown.get() = true;\n-                    self.cond.notify_one()\n-                });\n-\n-                let _ = rt::at_exit(move || { self.shutdown() });\n-                *self.initialized.get() = true;\n-            } else if *self.chan.get() as usize == 1 {\n-                panic!(\"cannot continue usage after shutdown\");\n-            }\n-        }\n-    }\n-\n-    /// Sends a message to a spawned worker thread.\n-    ///\n-    /// This is only valid if the worker thread has previously booted\n-    pub fn send(&'static self, msg: M) {\n-        unsafe {\n-            let _guard = self.lock.lock().unwrap();\n-\n-            // Must send and *then* signal to ensure that the child receives the\n-            // message. Otherwise it could wake up and go to sleep before we\n-            // send the message.\n-            assert!(*self.chan.get() as usize != 0);\n-            assert!(*self.chan.get() as usize != 1,\n-                    \"cannot continue usage after shutdown\");\n-            (**self.chan.get()).send(msg).unwrap();\n-            helper_signal::signal(*self.signal.get() as helper_signal::signal);\n-        }\n-    }\n-\n-    fn shutdown(&'static self) {\n-        unsafe {\n-            // Shut down, but make sure this is done inside our lock to ensure\n-            // that we'll always receive the exit signal when the thread\n-            // returns.\n-            let mut guard = self.lock.lock().unwrap();\n-\n-            let ptr = *self.chan.get();\n-            if ptr as usize == 1 {\n-                panic!(\"cannot continue usage after shutdown\");\n-            }\n-            // Close the channel by destroying it\n-            let chan = Box::from_raw(*self.chan.get());\n-            *self.chan.get() = 1 as *mut Sender<M>;\n-            drop(chan);\n-            helper_signal::signal(*self.signal.get() as helper_signal::signal);\n-\n-            // Wait for the child to exit\n-            while !*self.shutdown.get() {\n-                guard = self.cond.wait(guard).unwrap();\n-            }\n-            drop(guard);\n-\n-            // Clean up after ourselves\n-            self.lock.destroy();\n-            helper_signal::close(*self.signal.get() as helper_signal::signal);\n-            *self.signal.get() = 0;\n-        }\n-    }\n-}"}, {"sha": "b528575bbed33a4906f869b9e090c70048e97c63", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -15,7 +15,7 @@ use prelude::v1::*;\n pub mod backtrace;\n pub mod condvar;\n pub mod mutex;\n-pub mod net2;\n+pub mod net;\n pub mod poison;\n pub mod remutex;\n pub mod rwlock;"}, {"sha": "7da7071670ab631c575590df8e6b6dbd95d71a6c", "filename": "src/libstd/sys/common/net.rs", "status": "renamed", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -11,6 +11,7 @@\n use prelude::v1::*;\n \n use ffi::{CStr, CString};\n+use fmt;\n use io::{self, Error, ErrorKind};\n use libc::{self, c_int, c_char, c_void, socklen_t};\n use mem;\n@@ -268,6 +269,24 @@ impl FromInner<Socket> for TcpStream {\n     }\n }\n \n+impl fmt::Debug for TcpStream {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut res = f.debug_struct(\"TcpStream\");\n+\n+        if let Ok(addr) = self.socket_addr() {\n+            res = res.field(\"addr\", &addr);\n+        }\n+\n+        if let Ok(peer) = self.peer_addr() {\n+            res = res.field(\"peer\", &peer);\n+        }\n+\n+        let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n+        res = res.field(name, &self.inner.as_inner());\n+        res.finish()\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // TCP listeners\n ////////////////////////////////////////////////////////////////////////////////\n@@ -327,6 +346,20 @@ impl FromInner<Socket> for TcpListener {\n     }\n }\n \n+impl fmt::Debug for TcpListener {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut res = f.debug_struct(\"TcpListener\");\n+\n+        if let Ok(addr) = self.socket_addr() {\n+            res = res.field(\"addr\", &addr);\n+        }\n+\n+        let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n+        res = res.field(name, &self.inner.as_inner());\n+        res.finish()\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // UDP\n ////////////////////////////////////////////////////////////////////////////////\n@@ -445,3 +478,17 @@ impl FromInner<Socket> for UdpSocket {\n         UdpSocket { inner: socket }\n     }\n }\n+\n+impl fmt::Debug for UdpSocket {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let mut res = f.debug_struct(\"UdpSocket\");\n+\n+        if let Ok(addr) = self.socket_addr() {\n+            res = res.field(\"addr\", &addr);\n+        }\n+\n+        let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n+        res = res.field(name, &self.inner.as_inner());\n+        res.finish()\n+    }\n+}", "previous_filename": "src/libstd/sys/common/net2.rs"}, {"sha": "67679c11a9858b587d3e66f4539511e5161670e0", "filename": "src/libstd/sys/common/poison.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -10,6 +10,7 @@\n \n use prelude::v1::*;\n \n+use marker::Reflect;\n use cell::UnsafeCell;\n use error::{Error};\n use fmt;\n@@ -54,7 +55,7 @@ pub struct Guard {\n \n /// A type of error which can be returned whenever a lock is acquired.\n ///\n-/// Both Mutexes and RwLocks are poisoned whenever a task fails while the lock\n+/// Both Mutexes and RwLocks are poisoned whenever a thread fails while the lock\n /// is held. The precise semantics for when a lock is poisoned is documented on\n /// each lock, but once a lock is poisoned then all future acquisitions will\n /// return this error.\n@@ -67,7 +68,7 @@ pub struct PoisonError<T> {\n /// `try_lock` method.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryLockError<T> {\n-    /// The lock could not be acquired because another task failed while holding\n+    /// The lock could not be acquired because another thread failed while holding\n     /// the lock.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Poisoned(PoisonError<T>),\n@@ -109,7 +110,7 @@ impl<T> fmt::Display for PoisonError<T> {\n     }\n }\n \n-impl<T: Send> Error for PoisonError<T> {\n+impl<T: Send + Reflect> Error for PoisonError<T> {\n     fn description(&self) -> &str {\n         \"poisoned lock: another task failed inside\"\n     }\n@@ -155,13 +156,13 @@ impl<T> fmt::Debug for TryLockError<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send> fmt::Display for TryLockError<T> {\n+impl<T: Send + Reflect> fmt::Display for TryLockError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.description().fmt(f)\n     }\n }\n \n-impl<T: Send> Error for TryLockError<T> {\n+impl<T: Send + Reflect> Error for TryLockError<T> {\n     fn description(&self) -> &str {\n         match *self {\n             TryLockError::Poisoned(ref p) => p.description(),"}, {"sha": "1a467580672b3740ce62720ea3e41799013e1a5f", "filename": "src/libstd/sys/common/remutex.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -19,9 +19,9 @@ use sys::mutex as sys;\n \n /// A re-entrant mutual exclusion\n ///\n-/// This mutex will block *other* threads waiting for the lock to become available. The thread\n-/// which has already locked the mutex can lock it multiple times without blocking, preventing a\n-/// common source of deadlocks.\n+/// This mutex will block *other* threads waiting for the lock to become\n+/// available. The thread which has already locked the mutex can lock it\n+/// multiple times without blocking, preventing a common source of deadlocks.\n pub struct ReentrantMutex<T> {\n     inner: Box<sys::ReentrantMutex>,\n     poison: poison::Flag,\n@@ -51,10 +51,14 @@ impl<'a, T> !marker::Send for ReentrantMutexGuard<'a, T> {}\n impl<T> ReentrantMutex<T> {\n     /// Creates a new reentrant mutex in an unlocked state.\n     pub fn new(t: T) -> ReentrantMutex<T> {\n-        ReentrantMutex {\n-            inner: box unsafe { sys::ReentrantMutex::new() },\n-            poison: poison::FLAG_INIT,\n-            data: t,\n+        unsafe {\n+            let mut mutex = ReentrantMutex {\n+                inner: box sys::ReentrantMutex::uninitialized(),\n+                poison: poison::FLAG_INIT,\n+                data: t,\n+            };\n+            mutex.inner.init();\n+            return mutex\n         }\n     }\n "}, {"sha": "fadeebc8150017518a258cec3f653cb9924b6330", "filename": "src/libstd/sys/common/stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -11,13 +11,13 @@\n //! Rust stack-limit management\n //!\n //! Currently Rust uses a segmented-stack-like scheme in order to detect stack\n-//! overflow for rust tasks. In this scheme, the prologue of all functions are\n+//! overflow for rust threads. In this scheme, the prologue of all functions are\n //! preceded with a check to see whether the current stack limits are being\n //! exceeded.\n //!\n //! This module provides the functionality necessary in order to manage these\n //! stack limits (which are stored in platform-specific locations). The\n-//! functions here are used at the borders of the task lifetime in order to\n+//! functions here are used at the borders of the thread lifetime in order to\n //! manage these limits.\n //!\n //! This function is an unstable module because this scheme for stack overflow"}, {"sha": "cb9239ed7ba57032fb320a6614d68adac27ee1b3", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -161,7 +161,7 @@ impl Wtf8Buf {\n         Wtf8Buf { bytes: Vec::with_capacity(n) }\n     }\n \n-    /// Creates a WTF-8 string from an UTF-8 `String`.\n+    /// Creates a WTF-8 string from a UTF-8 `String`.\n     ///\n     /// This takes ownership of the `String` and does not copy.\n     ///\n@@ -171,7 +171,7 @@ impl Wtf8Buf {\n         Wtf8Buf { bytes: string.into_bytes() }\n     }\n \n-    /// Creates a WTF-8 string from an UTF-8 `&str` slice.\n+    /// Creates a WTF-8 string from a UTF-8 `&str` slice.\n     ///\n     /// This copies the content of the slice.\n     ///\n@@ -245,7 +245,7 @@ impl Wtf8Buf {\n         self.bytes.capacity()\n     }\n \n-    /// Append an UTF-8 slice at the end of the string.\n+    /// Append a UTF-8 slice at the end of the string.\n     #[inline]\n     pub fn push_str(&mut self, other: &str) {\n         self.bytes.push_all(other.as_bytes())\n@@ -527,7 +527,7 @@ impl Wtf8 {\n     }\n \n     /// Lossily converts the string to UTF-8.\n-    /// Returns an UTF-8 `&str` slice if the contents are well-formed in UTF-8.\n+    /// Returns a UTF-8 `&str` slice if the contents are well-formed in UTF-8.\n     ///\n     /// Surrogates are replaced with `\"\\u{FFFD}\"` (the replacement character \u201c\ufffd\u201d).\n     ///"}, {"sha": "135ae1bf9163bc155bd312de295eed1150ac826f", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -22,7 +22,7 @@\n ///   getting both accurate backtraces and accurate symbols across platforms.\n ///   This route was not chosen in favor of the next option, however.\n ///\n-/// * We're already using libgcc_s for exceptions in rust (triggering task\n+/// * We're already using libgcc_s for exceptions in rust (triggering thread\n ///   unwinding and running destructors on the stack), and it turns out that it\n ///   conveniently comes with a function that also gives us a backtrace. All of\n ///   these functions look like _Unwind_*, but it's not quite the full\n@@ -116,7 +116,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n \n     // while it doesn't requires lock for work as everything is\n     // local, it still displays much nicer backtraces when a\n-    // couple of tasks panic simultaneously\n+    // couple of threads panic simultaneously\n     static LOCK: StaticMutex = MUTEX_INIT;\n     let _g = LOCK.lock();\n "}, {"sha": "a6953437497f65f57c276efcc5e70d4676318656", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -102,7 +102,7 @@ impl OpenOptionsExt for OpenOptions {\n }\n \n #[unstable(feature = \"metadata_ext\", reason = \"recently added API\")]\n-pub struct Metadata(sys::fs2::FileAttr);\n+pub struct Metadata(sys::fs::FileAttr);\n \n #[unstable(feature = \"metadata_ext\", reason = \"recently added API\")]\n pub trait MetadataExt {\n@@ -111,7 +111,7 @@ pub trait MetadataExt {\n \n impl MetadataExt for fs::Metadata {\n     fn as_raw(&self) -> &Metadata {\n-        let inner: &sys::fs2::FileAttr = self.as_inner();\n+        let inner: &sys::fs::FileAttr = self.as_inner();\n         unsafe { mem::transmute(inner) }\n     }\n }\n@@ -138,11 +138,11 @@ impl Metadata {\n     pub fn rdev(&self) -> raw::dev_t { self.0.raw().st_rdev as raw::dev_t }\n     pub fn size(&self) -> raw::off_t { self.0.raw().st_size as raw::off_t }\n     pub fn atime(&self) -> raw::time_t { self.0.raw().st_atime }\n-    pub fn atime_nsec(&self) -> c_long { self.0.raw().st_atime }\n+    pub fn atime_nsec(&self) -> c_long { self.0.raw().st_atime_nsec as c_long }\n     pub fn mtime(&self) -> raw::time_t { self.0.raw().st_mtime }\n-    pub fn mtime_nsec(&self) -> c_long { self.0.raw().st_mtime }\n+    pub fn mtime_nsec(&self) -> c_long { self.0.raw().st_mtime_nsec as c_long }\n     pub fn ctime(&self) -> raw::time_t { self.0.raw().st_ctime }\n-    pub fn ctime_nsec(&self) -> c_long { self.0.raw().st_ctime }\n+    pub fn ctime_nsec(&self) -> c_long { self.0.raw().st_ctime_nsec as c_long }\n \n     pub fn blksize(&self) -> raw::blksize_t {\n         self.0.raw().st_blksize as raw::blksize_t\n@@ -187,7 +187,7 @@ impl DirEntryExt for fs::DirEntry {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n {\n-    sys::fs2::symlink(src.as_ref(), dst.as_ref())\n+    sys::fs::symlink(src.as_ref(), dst.as_ref())\n }\n \n #[unstable(feature = \"dir_builder\", reason = \"recently added API\")]"}, {"sha": "79e59ddab5be5fca16ad7a6623f1f9f19fda9dac", "filename": "src/libstd/sys/unix/ext/io.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -16,7 +16,7 @@ use fs;\n use net;\n use os::raw;\n use sys;\n-use sys_common::{net2, AsInner, FromInner};\n+use sys_common::{self, AsInner, FromInner};\n \n /// Raw file descriptors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -41,8 +41,7 @@ pub trait AsRawFd {\n \n /// A trait to express the ability to construct an object from a raw file\n /// descriptor.\n-#[unstable(feature = \"from_raw_os\",\n-           reason = \"recent addition to std::os::unix::io\")]\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n pub trait FromRawFd {\n     /// Constructs a new instances of `Self` from the given raw file\n     /// descriptor.\n@@ -56,6 +55,7 @@ pub trait FromRawFd {\n     /// descriptor they are wrapping. Usage of this function could\n     /// accidentally allow violating this contract which can cause memory\n     /// unsafety in code that relies on it being true.\n+    #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n     unsafe fn from_raw_fd(fd: RawFd) -> Self;\n }\n \n@@ -65,10 +65,10 @@ impl AsRawFd for fs::File {\n         self.as_inner().fd().raw()\n     }\n }\n-#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawFd for fs::File {\n     unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n-        fs::File::from_inner(sys::fs2::File::from_inner(fd))\n+        fs::File::from_inner(sys::fs::File::from_inner(fd))\n     }\n }\n \n@@ -85,24 +85,24 @@ impl AsRawFd for net::UdpSocket {\n     fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n }\n \n-#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawFd for net::TcpStream {\n     unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n         let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpStream::from_inner(net2::TcpStream::from_inner(socket))\n+        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n     }\n }\n-#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawFd for net::TcpListener {\n     unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n         let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpListener::from_inner(net2::TcpListener::from_inner(socket))\n+        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n     }\n }\n-#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawFd for net::UdpSocket {\n     unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n         let socket = sys::net::Socket::from_inner(fd);\n-        net::UdpSocket::from_inner(net2::UdpSocket::from_inner(socket))\n+        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n     }\n }"}, {"sha": "45d0d62a01575b100683ca54d5a555b0bc90b51c", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -58,7 +58,7 @@ pub trait ExitStatusExt {\n impl ExitStatusExt for process::ExitStatus {\n     fn signal(&self) -> Option<i32> {\n         match *self.as_inner() {\n-            sys::process2::ExitStatus::Signal(s) => Some(s),\n+            sys::process::ExitStatus::Signal(s) => Some(s),\n             _ => None\n         }\n     }"}, {"sha": "026380027d29e58f7c01dcc482a48d43f151677e", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -31,7 +31,7 @@ impl FileDesc {\n     /// Extracts the actual filedescriptor without closing it.\n     pub fn into_raw(self) -> c_int {\n         let fd = self.fd;\n-        unsafe { mem::forget(self) };\n+        mem::forget(self);\n         fd\n     }\n "}, {"sha": "350161c751cb89fa6af78ad8a88cd1f19c880ed9", "filename": "src/libstd/sys/unix/fs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "previous_filename": "src/libstd/sys/unix/fs2.rs"}, {"sha": "c1a4e8cee9ed4079fdbac145417ef76c7b520351", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -33,13 +33,13 @@ pub mod c;\n pub mod condvar;\n pub mod ext;\n pub mod fd;\n-pub mod fs2;\n+pub mod fs;\n pub mod mutex;\n pub mod net;\n pub mod os;\n pub mod os_str;\n-pub mod pipe2;\n-pub mod process2;\n+pub mod pipe;\n+pub mod process;\n pub mod rwlock;\n pub mod stack_overflow;\n pub mod sync;"}, {"sha": "70d14f63dbcc62f25b60d1c7d965c38acbc36d13", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -69,30 +69,27 @@ impl Mutex {\n     }\n }\n \n-// FIXME: remove the box, because box happens twice now, once at the common layer and once here.\n-// Box is necessary here, because mutex may not change address after it is intialised on some\n-// platforms. Regular Mutex above handles this by offloading intialisation to the OS on first lock.\n-// Sadly, as far as reentrant mutexes go, this scheme is not quite portable and we must initialise\n-// when we create the mutex, in the `new`.\n-pub struct ReentrantMutex { inner: Box<UnsafeCell<ffi::pthread_mutex_t>> }\n+pub struct ReentrantMutex { inner: UnsafeCell<ffi::pthread_mutex_t> }\n \n unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n-    pub unsafe fn new() -> ReentrantMutex {\n-        let mutex = ReentrantMutex { inner: box mem::uninitialized() };\n+    pub unsafe fn uninitialized() -> ReentrantMutex {\n+        ReentrantMutex { inner: mem::uninitialized() }\n+    }\n+\n+    pub unsafe fn init(&mut self) {\n         let mut attr: ffi::pthread_mutexattr_t = mem::uninitialized();\n         let result = ffi::pthread_mutexattr_init(&mut attr as *mut _);\n         debug_assert_eq!(result, 0);\n         let result = ffi::pthread_mutexattr_settype(&mut attr as *mut _,\n                                                     ffi::PTHREAD_MUTEX_RECURSIVE);\n         debug_assert_eq!(result, 0);\n-        let result = ffi::pthread_mutex_init(mutex.inner.get(), &attr as *const _);\n+        let result = ffi::pthread_mutex_init(self.inner.get(), &attr as *const _);\n         debug_assert_eq!(result, 0);\n         let result = ffi::pthread_mutexattr_destroy(&mut attr as *mut _);\n         debug_assert_eq!(result, 0);\n-        mutex\n     }\n \n     pub unsafe fn lock(&self) {"}, {"sha": "e9d8c69fefb52035cbdb2a341211dcbf76ccab48", "filename": "src/libstd/sys/unix/pipe.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "previous_filename": "src/libstd/sys/unix/pipe2.rs"}, {"sha": "290310f4ad90181738f44866979318ad32ee3bdb", "filename": "src/libstd/sys/unix/process.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -18,9 +18,9 @@ use fmt;\n use io::{self, Error, ErrorKind};\n use libc::{self, pid_t, c_void, c_int, gid_t, uid_t};\n use ptr;\n-use sys::pipe2::AnonPipe;\n+use sys::pipe::AnonPipe;\n use sys::{self, c, cvt, cvt_r};\n-use sys::fs2::{File, OpenOptions};\n+use sys::fs::{File, OpenOptions};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -141,7 +141,7 @@ impl Process {\n \n         let (envp, _a, _b) = make_envp(cfg.env.as_ref());\n         let (argv, _a) = make_argv(&cfg.program, &cfg.args);\n-        let (input, output) = try!(sys::pipe2::anon_pipe());\n+        let (input, output) = try!(sys::pipe::anon_pipe());\n \n         let pid = unsafe {\n             match libc::fork() {\n@@ -328,7 +328,7 @@ impl Process {\n         }) {\n             Ok(0) => None,\n             Ok(n) if n == self.pid => Some(translate_status(status)),\n-            Ok(n) => panic!(\"unkown pid: {}\", n),\n+            Ok(n) => panic!(\"unknown pid: {}\", n),\n             Err(e) => panic!(\"unknown waitpid error: {}\", e),\n         }\n     }", "previous_filename": "src/libstd/sys/unix/process2.rs"}, {"sha": "7bb9fb68c14f0a4217ca2da3c6c590f65608d838", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -10,6 +10,7 @@\n \n use prelude::v1::*;\n \n+use libc;\n use cell::UnsafeCell;\n use sys::sync as ffi;\n \n@@ -26,7 +27,23 @@ impl RWLock {\n     #[inline]\n     pub unsafe fn read(&self) {\n         let r = ffi::pthread_rwlock_rdlock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n+\n+        // According to the pthread_rwlock_rdlock spec, this function **may**\n+        // fail with EDEADLK if a deadlock is detected. On the other hand\n+        // pthread mutexes will *never* return EDEADLK if they are initialized\n+        // as the \"fast\" kind (which ours always are). As a result, a deadlock\n+        // situation may actually return from the call to pthread_rwlock_rdlock\n+        // instead of blocking forever (as mutexes and Windows rwlocks do). Note\n+        // that not all unix implementations, however, will return EDEADLK for\n+        // their rwlocks.\n+        //\n+        // We roughly maintain the deadlocking behavior by panicking to ensure\n+        // that this lock acquisition does not succeed.\n+        if r == libc::EDEADLK {\n+            panic!(\"rwlock read lock would result in deadlock\");\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n     }\n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n@@ -35,7 +52,12 @@ impl RWLock {\n     #[inline]\n     pub unsafe fn write(&self) {\n         let r = ffi::pthread_rwlock_wrlock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n+        // see comments above for why we check for EDEADLK\n+        if r == libc::EDEADLK {\n+            panic!(\"rwlock write lock would result in deadlock\");\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n     }\n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n@@ -49,21 +71,16 @@ impl RWLock {\n     #[inline]\n     pub unsafe fn write_unlock(&self) { self.read_unlock() }\n     #[inline]\n-    #[cfg(not(target_os = \"dragonfly\"))]\n-    pub unsafe fn destroy(&self) {\n-        let r = ffi::pthread_rwlock_destroy(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-\n-    #[inline]\n-    #[cfg(target_os = \"dragonfly\")]\n     pub unsafe fn destroy(&self) {\n-        use libc;\n         let r = ffi::pthread_rwlock_destroy(self.inner.get());\n         // On DragonFly pthread_rwlock_destroy() returns EINVAL if called on a\n         // rwlock that was just initialized with\n         // ffi::PTHREAD_RWLOCK_INITIALIZER. Once it is used (locked/unlocked)\n         // or pthread_rwlock_init() is called, this behaviour no longer occurs.\n-        debug_assert!(r == 0 || r == libc::EINVAL);\n+        if cfg!(target_os = \"dragonfly\") {\n+            debug_assert!(r == 0 || r == libc::EINVAL);\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n     }\n }"}, {"sha": "822e1b370c2cf4cd31cbbe85aad58ca93ebe0c30", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -125,7 +125,7 @@ impl MetadataExt for Metadata {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n                                                     -> io::Result<()> {\n-    sys::fs2::symlink_inner(src.as_ref(), dst.as_ref(), false)\n+    sys::fs::symlink_inner(src.as_ref(), dst.as_ref(), false)\n }\n \n /// Creates a new directory symlink on the filesystem.\n@@ -146,5 +146,5 @@ pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn symlink_dir<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n                                                    -> io::Result<()> {\n-    sys::fs2::symlink_inner(src.as_ref(), dst.as_ref(), true)\n+    sys::fs::symlink_inner(src.as_ref(), dst.as_ref(), true)\n }"}, {"sha": "f4717eb2425e16aa50590243c373f60967a8daf7", "filename": "src/libstd/sys/windows/ext/io.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -13,7 +13,7 @@\n use fs;\n use os::windows::raw;\n use net;\n-use sys_common::{net2, AsInner, FromInner};\n+use sys_common::{self, AsInner, FromInner};\n use sys;\n \n /// Raw HANDLEs.\n@@ -33,8 +33,7 @@ pub trait AsRawHandle {\n }\n \n /// Construct I/O objects from raw handles.\n-#[unstable(feature = \"from_raw_os\",\n-           reason = \"recent addition to the std::os::windows::io module\")]\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n pub trait FromRawHandle {\n     /// Constructs a new I/O object from the specified raw handle.\n     ///\n@@ -47,6 +46,7 @@ pub trait FromRawHandle {\n     /// descriptor they are wrapping. Usage of this function could\n     /// accidentally allow violating this contract which can cause memory\n     /// unsafety in code that relies on it being true.\n+    #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n     unsafe fn from_raw_handle(handle: RawHandle) -> Self;\n }\n \n@@ -57,11 +57,11 @@ impl AsRawHandle for fs::File {\n     }\n }\n \n-#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawHandle for fs::File {\n     unsafe fn from_raw_handle(handle: RawHandle) -> fs::File {\n         let handle = handle as ::libc::HANDLE;\n-        fs::File::from_inner(sys::fs2::File::from_inner(handle))\n+        fs::File::from_inner(sys::fs::File::from_inner(handle))\n     }\n }\n \n@@ -74,7 +74,7 @@ pub trait AsRawSocket {\n }\n \n /// Create I/O objects from raw sockets.\n-#[unstable(feature = \"from_raw_os\", reason = \"recent addition to module\")]\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n pub trait FromRawSocket {\n     /// Creates a new I/O object from the given raw socket.\n     ///\n@@ -86,6 +86,7 @@ pub trait FromRawSocket {\n     /// descriptor they are wrapping. Usage of this function could\n     /// accidentally allow violating this contract which can cause memory\n     /// unsafety in code that relies on it being true.\n+    #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n     unsafe fn from_raw_socket(sock: RawSocket) -> Self;\n }\n \n@@ -108,24 +109,24 @@ impl AsRawSocket for net::UdpSocket {\n     }\n }\n \n-#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawSocket for net::TcpStream {\n     unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpStream {\n         let sock = sys::net::Socket::from_inner(sock);\n-        net::TcpStream::from_inner(net2::TcpStream::from_inner(sock))\n+        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(sock))\n     }\n }\n-#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawSocket for net::TcpListener {\n     unsafe fn from_raw_socket(sock: RawSocket) -> net::TcpListener {\n         let sock = sys::net::Socket::from_inner(sock);\n-        net::TcpListener::from_inner(net2::TcpListener::from_inner(sock))\n+        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(sock))\n     }\n }\n-#[unstable(feature = \"from_raw_os\", reason = \"trait is unstable\")]\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawSocket for net::UdpSocket {\n     unsafe fn from_raw_socket(sock: RawSocket) -> net::UdpSocket {\n         let sock = sys::net::Socket::from_inner(sock);\n-        net::UdpSocket::from_inner(net2::UdpSocket::from_inner(sock))\n+        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(sock))\n     }\n }"}, {"sha": "03a56e2958a6e9f485b050323ac42274b744b9eb", "filename": "src/libstd/sys/windows/fs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "previous_filename": "src/libstd/sys/windows/fs2.rs"}, {"sha": "c835d503388c7c57925a171d4d49337e9fb47d81", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -32,7 +32,7 @@ impl Handle {\n \n     pub fn into_raw(self) -> HANDLE {\n         let ret = self.0;\n-        unsafe { mem::forget(self) }\n+        mem::forget(self);\n         return ret;\n     }\n "}, {"sha": "4c30f0f86604f1552f9ec569b8a1402a5646a77c", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -25,14 +25,14 @@ pub mod backtrace;\n pub mod c;\n pub mod condvar;\n pub mod ext;\n-pub mod fs2;\n+pub mod fs;\n pub mod handle;\n pub mod mutex;\n pub mod net;\n pub mod os;\n pub mod os_str;\n-pub mod pipe2;\n-pub mod process2;\n+pub mod pipe;\n+pub mod process;\n pub mod rwlock;\n pub mod stack_overflow;\n pub mod sync;"}, {"sha": "9d2624f94180e5612fc4439dba3f9c5e5a3a73d9", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -59,16 +59,18 @@ impl Mutex {\n     }\n }\n \n-pub struct ReentrantMutex { inner: Box<UnsafeCell<ffi::CRITICAL_SECTION>> }\n+pub struct ReentrantMutex { inner: UnsafeCell<ffi::CRITICAL_SECTION> }\n \n unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n \n impl ReentrantMutex {\n-    pub unsafe fn new() -> ReentrantMutex {\n-        let mutex = ReentrantMutex { inner: box mem::uninitialized() };\n-        ffi::InitializeCriticalSection(mutex.inner.get());\n-        mutex\n+    pub unsafe fn uninitialized() -> ReentrantMutex {\n+        mem::uninitialized()\n+    }\n+\n+    pub unsafe fn init(&mut self) {\n+        ffi::InitializeCriticalSection(self.inner.get());\n     }\n \n     pub unsafe fn lock(&self) {"}, {"sha": "b441d8beedbc04dd7ab3569aafab81af3fc399c6", "filename": "src/libstd/sys/windows/pipe.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "previous_filename": "src/libstd/sys/windows/pipe2.rs"}, {"sha": "032a349b00eff11e211f6a6a6da2e7f3766d3003", "filename": "src/libstd/sys/windows/process.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -26,9 +26,9 @@ use path::Path;\n use ptr;\n use sync::{StaticMutex, MUTEX_INIT};\n use sys::c;\n-use sys::fs2::{OpenOptions, File};\n+use sys::fs::{OpenOptions, File};\n use sys::handle::Handle;\n-use sys::pipe2::AnonPipe;\n+use sys::pipe::AnonPipe;\n use sys::stdio;\n use sys::{self, cvt};\n use sys_common::{AsInner, FromInner};", "previous_filename": "src/libstd/sys/windows/process2.rs"}, {"sha": "ea5af3f2830e8cd0ad58449457878707a6c1ec10", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -32,7 +32,7 @@ pub type Dtor = unsafe extern fn(*mut u8);\n // somewhere to run arbitrary code on thread termination. With this in place\n // we'll be able to run anything we like, including all TLS destructors!\n //\n-// To accomplish this feat, we perform a number of tasks, all contained\n+// To accomplish this feat, we perform a number of threads, all contained\n // within this module:\n //\n // * All TLS destructors are tracked by *us*, not the windows runtime. This"}, {"sha": "41bdf034705d3bce65f68bce31504ad36da1ca86", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -32,7 +32,7 @@ pub mod __impl {\n /// primary method is the `with` method.\n ///\n /// The `with` method yields a reference to the contained value which cannot be\n-/// sent across tasks or escape the given closure.\n+/// sent across threads or escape the given closure.\n ///\n /// # Initialization and Destruction\n ///"}, {"sha": "f480147b93ee704a9ae1b6ca66f066fa224f1242", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -873,8 +873,8 @@ mod tests {\n \n     #[test]\n     fn test_child_doesnt_ref_parent() {\n-        // If the child refcounts the parent task, this will stack overflow when\n-        // climbing the task tree to dereference each ancestor. (See #1789)\n+        // If the child refcounts the parent thread, this will stack overflow when\n+        // climbing the thread tree to dereference each ancestor. (See #1789)\n         // (well, it would if the constant were 8000+ - I lowered it to be more\n         // valgrind-friendly. try this at home, instead..!)\n         const GENERATIONS: u32 = 16;\n@@ -983,6 +983,6 @@ mod tests {\n         thread::sleep_ms(2);\n     }\n \n-    // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due\n+    // NOTE: the corresponding test for stderr is in run-pass/thread-stderr, due\n     // to the test harness apparently interfering with stderr configuration.\n }"}, {"sha": "e00cb82649b7b6bb538948623d1f1215eafbcd6e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -595,7 +595,7 @@ pub enum Pat_ {\n \n     /// An associated const named using the qualified path `<T>::CONST` or\n     /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n-    /// refered to as simply `T::CONST`, in which case they will end up as\n+    /// referred to as simply `T::CONST`, in which case they will end up as\n     /// PatEnum, and the resolver will have to sort that out.\n     PatQPath(QSelf, Path),\n "}, {"sha": "348bf6f51bb7c5a90ce4498b4916458741121c1d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -543,21 +543,17 @@ impl CodeMap {\n         }\n     }\n \n-    pub fn new_filemap(&self, filename: FileName, src: String) -> Rc<FileMap> {\n+    pub fn new_filemap(&self, filename: FileName, mut src: String) -> Rc<FileMap> {\n         let mut files = self.files.borrow_mut();\n         let start_pos = match files.last() {\n             None => 0,\n             Some(last) => last.end_pos.to_usize(),\n         };\n \n         // Remove utf-8 BOM if any.\n-        // FIXME #12884: no efficient/safe way to remove from the start of a string\n-        // and reuse the allocation.\n-        let mut src = if src.starts_with(\"\\u{feff}\") {\n-            String::from(&src[3..])\n-        } else {\n-            String::from(&src[..])\n-        };\n+        if src.starts_with(\"\\u{feff}\") {\n+            src.drain(..3);\n+        }\n \n         // Append '\\n' in case it's not already there.\n         // This is a workaround to prevent CodeMap.lookup_filemap_idx from\n@@ -667,9 +663,22 @@ impl CodeMap {\n         self.lookup_char_pos(sp.lo).file.name.to_string()\n     }\n \n-    pub fn span_to_lines(&self, sp: Span) -> FileLines {\n+    pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n+        if sp.lo > sp.hi {\n+            return Err(SpanLinesError::IllFormedSpan(sp));\n+        }\n+\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n+\n+        if lo.file.start_pos != hi.file.start_pos {\n+            return Err(SpanLinesError::DistinctSources(DistinctSources {\n+                begin: (lo.file.name.clone(), lo.file.start_pos),\n+                end: (hi.file.name.clone(), hi.file.start_pos),\n+            }));\n+        }\n+        assert!(hi.line >= lo.line);\n+\n         let mut lines = Vec::with_capacity(hi.line - lo.line + 1);\n \n         // The span starts partway through the first line,\n@@ -693,7 +702,7 @@ impl CodeMap {\n                               start_col: start_col,\n                               end_col: hi.col });\n \n-        FileLines {file: lo.file, lines: lines}\n+        Ok(FileLines {file: lo.file, lines: lines})\n     }\n \n     pub fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> {\n@@ -918,9 +927,17 @@ impl CodeMap {\n }\n \n // _____________________________________________________________________________\n-// SpanSnippetError, DistinctSources, MalformedCodemapPositions\n+// SpanLinesError, SpanSnippetError, DistinctSources, MalformedCodemapPositions\n //\n \n+pub type FileLinesResult = Result<FileLines, SpanLinesError>;\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum SpanLinesError {\n+    IllFormedSpan(Span),\n+    DistinctSources(DistinctSources),\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub enum SpanSnippetError {\n     IllFormedSpan(Span),\n@@ -1086,7 +1103,7 @@ mod tests {\n         // Test span_to_lines for a span ending at the end of filemap\n         let cm = init_code_map();\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n-        let file_lines = cm.span_to_lines(span);\n+        let file_lines = cm.span_to_lines(span).unwrap();\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n         assert_eq!(file_lines.lines.len(), 1);\n@@ -1131,7 +1148,7 @@ mod tests {\n         assert_eq!(&cm.span_to_snippet(span).unwrap(), \"BB\\nCCC\\nDDDDD\");\n \n         // check that span_to_lines gives us the complete result with the lines/cols we expected\n-        let lines = cm.span_to_lines(span);\n+        let lines = cm.span_to_lines(span).unwrap();\n         let expected = vec![\n             LineInfo { line_index: 1, start_col: CharPos(4), end_col: CharPos(6) },\n             LineInfo { line_index: 2, start_col: CharPos(0), end_col: CharPos(3) },"}, {"sha": "aa649b4d99ac5fa291a393435b4da3227202f5a5", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -522,7 +522,7 @@ fn highlight_suggestion(err: &mut EmitterWriter,\n                         suggestion: &str)\n                         -> io::Result<()>\n {\n-    let lines = cm.span_to_lines(sp);\n+    let lines = cm.span_to_lines(sp).unwrap();\n     assert!(!lines.lines.is_empty());\n \n     // To build up the result, we want to take the snippet from the first\n@@ -567,9 +567,17 @@ fn highlight_lines(err: &mut EmitterWriter,\n                    cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n-                   lines: codemap::FileLines)\n+                   lines: codemap::FileLinesResult)\n                    -> io::Result<()>\n {\n+    let lines = match lines {\n+        Ok(lines) => lines,\n+        Err(_) => {\n+            try!(write!(&mut err.dst, \"(internal compiler error: unprintable span)\\n\"));\n+            return Ok(());\n+        }\n+    };\n+\n     let fm = &*lines.file;\n \n     let line_strings: Option<Vec<&str>> =\n@@ -690,8 +698,16 @@ fn end_highlight_lines(w: &mut EmitterWriter,\n                           cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,\n-                          lines: codemap::FileLines)\n+                          lines: codemap::FileLinesResult)\n                           -> io::Result<()> {\n+    let lines = match lines {\n+        Ok(lines) => lines,\n+        Err(_) => {\n+            try!(write!(&mut w.dst, \"(internal compiler error: unprintable span)\\n\"));\n+            return Ok(());\n+        }\n+    };\n+\n     let fm = &*lines.file;\n \n     let lines = &lines.lines[..];"}, {"sha": "354a0bff74998bbcc3c21d93f7d379d0db0f41d3", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -146,7 +146,7 @@ pub trait AstBuilder {\n     fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> P<ast::Expr>;\n \n     fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr>;\n-    fn expr_int(&self, sp: Span, i: isize) -> P<ast::Expr>;\n+    fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr>;\n     fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr>;\n     fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr>;\n     fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr>;\n@@ -698,7 +698,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n         self.expr_lit(span, ast::LitInt(i as u64, ast::UnsignedIntLit(ast::TyUs)))\n     }\n-    fn expr_int(&self, sp: Span, i: isize) -> P<ast::Expr> {\n+    fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitInt(i as u64, ast::SignedIntLit(ast::TyIs,\n                                                                   ast::Sign::new(i))))\n     }"}, {"sha": "78c2faea9d204f4003907d30b4b994d4228650ca", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -77,7 +77,7 @@\n //!\n //! The `cs_...` functions (\"combine substructure) are designed to\n //! make life easier by providing some pre-made recipes for common\n-//! tasks; mostly calling the function being derived on all the\n+//! threads; mostly calling the function being derived on all the\n //! arguments and then combining them back together in some way (or\n //! letting the user chose that). They are not meant to be the only\n //! way to handle the structures that this code creates.\n@@ -270,7 +270,7 @@ pub struct Substructure<'a> {\n }\n \n /// Summary of the relevant parts of a struct/enum field.\n-pub struct FieldInfo {\n+pub struct FieldInfo<'a> {\n     pub span: Span,\n     /// None for tuple structs/normal enum variants, Some for normal\n     /// structs/struct enum variants.\n@@ -281,6 +281,8 @@ pub struct FieldInfo {\n     /// The expressions corresponding to references to this field in\n     /// the other `Self` arguments.\n     pub other: Vec<P<Expr>>,\n+    /// The attributes on the field\n+    pub attrs: &'a [ast::Attribute],\n }\n \n /// Fields for a static method\n@@ -293,11 +295,11 @@ pub enum StaticFields {\n \n /// A summary of the possible sets of fields.\n pub enum SubstructureFields<'a> {\n-    Struct(Vec<FieldInfo>),\n+    Struct(Vec<FieldInfo<'a>>),\n     /// Matching variants of the enum: variant index, ast::Variant,\n     /// fields: the field name is only non-`None` in the case of a struct\n     /// variant.\n-    EnumMatching(usize, &'a ast::Variant, Vec<FieldInfo>),\n+    EnumMatching(usize, &'a ast::Variant, Vec<FieldInfo<'a>>),\n \n     /// Non-matching variants of the enum, but with all state hidden from\n     /// the consequent code.  The first component holds `Ident`s for all of\n@@ -617,7 +619,7 @@ impl<'a> TraitDef<'a> {\n \n     fn expand_struct_def(&self,\n                          cx: &mut ExtCtxt,\n-                         struct_def: &StructDef,\n+                         struct_def: &'a StructDef,\n                          type_ident: Ident,\n                          generics: &Generics) -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> = struct_def.fields.iter()\n@@ -661,7 +663,7 @@ impl<'a> TraitDef<'a> {\n \n     fn expand_enum_def(&self,\n                        cx: &mut ExtCtxt,\n-                       enum_def: &EnumDef,\n+                       enum_def: &'a EnumDef,\n                        type_attrs: &[ast::Attribute],\n                        type_ident: Ident,\n                        generics: &Generics) -> P<ast::Item> {\n@@ -893,10 +895,10 @@ impl<'a> MethodDef<'a> {\n     ///     }\n     /// }\n     /// ```\n-    fn expand_struct_method_body(&self,\n+    fn expand_struct_method_body<'b>(&self,\n                                  cx: &mut ExtCtxt,\n-                                 trait_: &TraitDef,\n-                                 struct_def: &StructDef,\n+                                 trait_: &TraitDef<'b>,\n+                                 struct_def: &'b StructDef,\n                                  type_ident: Ident,\n                                  self_args: &[P<Expr>],\n                                  nonself_args: &[P<Expr>])\n@@ -922,18 +924,19 @@ impl<'a> MethodDef<'a> {\n         let fields = if !raw_fields.is_empty() {\n             let mut raw_fields = raw_fields.into_iter().map(|v| v.into_iter());\n             let first_field = raw_fields.next().unwrap();\n-            let mut other_fields: Vec<vec::IntoIter<(Span, Option<Ident>, P<Expr>)>>\n+            let mut other_fields: Vec<vec::IntoIter<_>>\n                 = raw_fields.collect();\n-            first_field.map(|(span, opt_id, field)| {\n+            first_field.map(|(span, opt_id, field, attrs)| {\n                 FieldInfo {\n                     span: span,\n                     name: opt_id,\n                     self_: field,\n                     other: other_fields.iter_mut().map(|l| {\n                         match l.next().unwrap() {\n-                            (_, _, ex) => ex\n+                            (_, _, ex, _) => ex\n                         }\n-                    }).collect()\n+                    }).collect(),\n+                    attrs: attrs,\n                 }\n             }).collect()\n         } else {\n@@ -1007,10 +1010,10 @@ impl<'a> MethodDef<'a> {\n     /// `PartialEq`, and those subcomputations will hopefully be removed\n     /// as their results are unused.  The point of `__self_vi` and\n     /// `__arg_1_vi` is for `PartialOrd`; see #15503.)\n-    fn expand_enum_method_body(&self,\n+    fn expand_enum_method_body<'b>(&self,\n                                cx: &mut ExtCtxt,\n-                               trait_: &TraitDef,\n-                               enum_def: &EnumDef,\n+                               trait_: &TraitDef<'b>,\n+                               enum_def: &'b EnumDef,\n                                type_attrs: &[ast::Attribute],\n                                type_ident: Ident,\n                                self_args: Vec<P<Expr>>,\n@@ -1046,11 +1049,11 @@ impl<'a> MethodDef<'a> {\n     ///   }\n     /// }\n     /// ```\n-    fn build_enum_match_tuple(\n+    fn build_enum_match_tuple<'b>(\n         &self,\n         cx: &mut ExtCtxt,\n-        trait_: &TraitDef,\n-        enum_def: &EnumDef,\n+        trait_: &TraitDef<'b>,\n+        enum_def: &'b EnumDef,\n         type_attrs: &[ast::Attribute],\n         type_ident: Ident,\n         self_args: Vec<P<Expr>>,\n@@ -1133,15 +1136,15 @@ impl<'a> MethodDef<'a> {\n                 // arg fields of the variant for the first self pat.\n                 let field_tuples = first_self_pat_idents.into_iter().enumerate()\n                     // For each arg field of self, pull out its getter expr ...\n-                    .map(|(field_index, (sp, opt_ident, self_getter_expr))| {\n+                    .map(|(field_index, (sp, opt_ident, self_getter_expr, attrs))| {\n                         // ... but FieldInfo also wants getter expr\n                         // for matching other arguments of Self type;\n                         // so walk across the *other* self_pats_idents\n                         // and pull out getter for same field in each\n                         // of them (using `field_index` tracked above).\n                         // That is the heart of the transposition.\n                         let others = self_pats_idents.iter().map(|fields| {\n-                            let (_, _opt_ident, ref other_getter_expr) =\n+                            let (_, _opt_ident, ref other_getter_expr, _) =\n                                 fields[field_index];\n \n                             // All Self args have same variant, so\n@@ -1157,6 +1160,7 @@ impl<'a> MethodDef<'a> {\n                                     name: opt_ident,\n                                     self_: self_getter_expr,\n                                     other: others,\n+                                    attrs: attrs,\n                         }\n                     }).collect::<Vec<FieldInfo>>();\n \n@@ -1408,10 +1412,12 @@ impl<'a> TraitDef<'a> {\n     fn create_struct_pattern(&self,\n                              cx: &mut ExtCtxt,\n                              struct_path: ast::Path,\n-                             struct_def: &StructDef,\n+                             struct_def: &'a StructDef,\n                              prefix: &str,\n                              mutbl: ast::Mutability)\n-                             -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>)>) {\n+                             -> (P<ast::Pat>, Vec<(Span, Option<Ident>,\n+                                                   P<Expr>,\n+                                                   &'a [ast::Attribute])>) {\n         if struct_def.fields.is_empty() {\n             return (cx.pat_enum(self.span, struct_path, vec![]), vec![]);\n         }\n@@ -1441,15 +1447,16 @@ impl<'a> TraitDef<'a> {\n             paths.push(codemap::Spanned{span: sp, node: ident});\n             let val = cx.expr(\n                 sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)))));\n-            ident_expr.push((sp, opt_id, val));\n+            ident_expr.push((sp, opt_id, val, &struct_field.node.attrs[..]));\n         }\n \n         let subpats = self.create_subpatterns(cx, paths, mutbl);\n \n         // struct_type is definitely not Unknown, since struct_def.fields\n         // must be nonempty to reach here\n         let pattern = if struct_type == Record {\n-            let field_pats = subpats.into_iter().zip(ident_expr.iter()).map(|(pat, &(_, id, _))| {\n+            let field_pats = subpats.into_iter().zip(ident_expr.iter())\n+                                    .map(|(pat, &(_, id, _, _))| {\n                 // id is guaranteed to be Some\n                 codemap::Spanned {\n                     span: pat.span,\n@@ -1467,10 +1474,10 @@ impl<'a> TraitDef<'a> {\n     fn create_enum_variant_pattern(&self,\n                                    cx: &mut ExtCtxt,\n                                    enum_ident: ast::Ident,\n-                                   variant: &ast::Variant,\n+                                   variant: &'a ast::Variant,\n                                    prefix: &str,\n                                    mutbl: ast::Mutability)\n-        -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>)>) {\n+        -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n         let variant_ident = variant.node.name;\n         let variant_path = cx.path(variant.span, vec![enum_ident, variant_ident]);\n         match variant.node.kind {\n@@ -1480,15 +1487,15 @@ impl<'a> TraitDef<'a> {\n                 }\n \n                 let mut paths = Vec::new();\n-                let mut ident_expr = Vec::new();\n+                let mut ident_expr: Vec<(_, _, _, &'a [ast::Attribute])> = Vec::new();\n                 for (i, va) in variant_args.iter().enumerate() {\n                     let sp = self.set_expn_info(cx, va.ty.span);\n                     let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n                     let path1 = codemap::Spanned{span: sp, node: ident};\n                     paths.push(path1);\n                     let expr_path = cx.expr_path(cx.path_ident(sp, ident));\n                     let val = cx.expr(sp, ast::ExprParen(cx.expr_deref(sp, expr_path)));\n-                    ident_expr.push((sp, None, val));\n+                    ident_expr.push((sp, None, val, &[]));\n                 }\n \n                 let subpats = self.create_subpatterns(cx, paths, mutbl);"}, {"sha": "476ab0fbf1136cf297864c5105d4272dc541ad7a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -934,9 +934,10 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                     let fm = fresh_mark();\n                     let marked_before = mark_tts(&tts[..], fm);\n                     let mac_span = fld.cx.original_span();\n-                    let expanded = match expander.expand(fld.cx,\n-                                        mac_span,\n-                                        &marked_before[..]).make_pat() {\n+                    let pat = expander.expand(fld.cx,\n+                                              mac_span,\n+                                              &marked_before[..]).make_pat();\n+                    let expanded = match pat {\n                         Some(e) => e,\n                         None => {\n                             fld.cx.span_err("}, {"sha": "330fe86deeb37e43d3e4ef10f1d39c574223c1a0", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -27,6 +27,7 @@\n \n #![feature(associated_consts)]\n #![feature(collections)]\n+#![feature(collections_drain)]\n #![feature(core)]\n #![feature(libc)]\n #![feature(rustc_private)]"}, {"sha": "eb1c338ac8591fe0405af400791294877e882b61", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -88,7 +88,6 @@ use std::slice;\n \n bitflags! {\n     flags Restrictions: u8 {\n-        const UNRESTRICTED                  = 0,\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n         const RESTRICTION_NO_STRUCT_LITERAL = 1 << 1,\n     }\n@@ -339,7 +338,7 @@ impl<'a> Parser<'a> {\n             buffer_start: 0,\n             buffer_end: 0,\n             tokens_consumed: 0,\n-            restrictions: Restrictions::UNRESTRICTED,\n+            restrictions: Restrictions::empty(),\n             quote_depth: 0,\n             obsolete_set: HashSet::new(),\n             mod_path_stack: Vec::new(),\n@@ -2991,7 +2990,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an expression\n     pub fn parse_expr_nopanic(&mut self) -> PResult<P<Expr>> {\n-        return self.parse_expr_res(Restrictions::UNRESTRICTED);\n+        self.parse_expr_res(Restrictions::empty())\n     }\n \n     /// Parse an expression, subject to the given restrictions\n@@ -4775,7 +4774,7 @@ impl<'a> Parser<'a> {\n         return self.parse_single_struct_field(Inherited, attrs);\n     }\n \n-    /// Parse visibility: PUB, PRIV, or nothing\n+    /// Parse visibility: PUB or nothing\n     fn parse_visibility(&mut self) -> PResult<Visibility> {\n         if try!(self.eat_keyword(keywords::Pub)) { Ok(Public) }\n         else { Ok(Inherited) }"}, {"sha": "53ed4f351d35667f5c4d1eec07edb51f7b14d043", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -601,7 +601,7 @@ pub type IdentInterner = StrInterner;\n \n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n-// FIXME(eddyb) #8726 This should probably use a task-local reference.\n+// FIXME(eddyb) #8726 This should probably use a thread-local reference.\n pub fn get_ident_interner() -> Rc<IdentInterner> {\n     thread_local!(static KEY: Rc<::parse::token::IdentInterner> = {\n         Rc::new(mk_fresh_ident_interner())\n@@ -615,14 +615,14 @@ pub fn reset_ident_interner() {\n     interner.reset(mk_fresh_ident_interner());\n }\n \n-/// Represents a string stored in the task-local interner. Because the\n-/// interner lives for the life of the task, this can be safely treated as an\n-/// immortal string, as long as it never crosses between tasks.\n+/// Represents a string stored in the thread-local interner. Because the\n+/// interner lives for the life of the thread, this can be safely treated as an\n+/// immortal string, as long as it never crosses between threads.\n ///\n /// FIXME(pcwalton): You must be careful about what you do in the destructors\n /// of objects stored in TLS, because they may run after the interner is\n /// destroyed. In particular, they must not access string contents. This can\n-/// be fixed in the future by just leaking all strings until task death\n+/// be fixed in the future by just leaking all strings until thread death\n /// somehow.\n #[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n pub struct InternedString {\n@@ -697,22 +697,22 @@ impl Encodable for InternedString {\n     }\n }\n \n-/// Returns the string contents of a name, using the task-local interner.\n+/// Returns the string contents of a name, using the thread-local interner.\n #[inline]\n pub fn get_name(name: ast::Name) -> InternedString {\n     let interner = get_ident_interner();\n     InternedString::new_from_rc_str(interner.get(name))\n }\n \n-/// Returns the string contents of an identifier, using the task-local\n+/// Returns the string contents of an identifier, using the thread-local\n /// interner.\n #[inline]\n pub fn get_ident(ident: ast::Ident) -> InternedString {\n     get_name(ident.name)\n }\n \n /// Interns and returns the string contents of an identifier, using the\n-/// task-local interner.\n+/// thread-local interner.\n #[inline]\n pub fn intern_and_get_ident(s: &str) -> InternedString {\n     get_name(intern(s))"}, {"sha": "5a002dd790fee4c1cc3908225127ac036de2fc89", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -902,10 +902,10 @@ impl<'a> State<'a> {\n                 try!(self.print_generics(params));\n                 try!(self.end()); // end the inner ibox\n \n+                try!(self.print_where_clause(&params.where_clause));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_type(&**ty));\n-                try!(self.print_where_clause(&params.where_clause));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer ibox\n             }"}, {"sha": "929f2a6abd6b8c5adde72337394d39eebcda3702", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -73,7 +73,11 @@ pub fn string_to_stmt(source_str : String) -> P<ast::Stmt> {\n /// Parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n /// (currently) affect parsing.\n pub fn string_to_pat(source_str: String) -> P<ast::Pat> {\n-    string_to_parser(&new_parse_sess(), source_str).parse_pat()\n+    // Binding `sess` and `parser` works around dropck-injected\n+    // region-inference issues; see #25212, #22323, #22321.\n+    let sess = new_parse_sess();\n+    let mut parser = string_to_parser(&sess, source_str);\n+    parser.parse_pat()\n }\n \n /// Convert a vector of strings to a vector of ast::Ident's"}, {"sha": "4d0b746c60c755de7d239348aef896747a067eb7", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 46, "deletions": 15, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -139,14 +139,14 @@ impl TestDesc {\n }\n \n /// Represents a benchmark function.\n-pub trait TDynBenchFn {\n+pub trait TDynBenchFn: Send {\n     fn run(&self, harness: &mut Bencher);\n }\n \n // A function that runs a test. If the function returns successfully,\n // the test succeeds; if the function panics then the test fails. We\n // may need to come up with a more clever definition of test in order\n-// to support isolation of tests into tasks.\n+// to support isolation of tests into threads.\n pub enum TestFn {\n     StaticTestFn(fn()),\n     StaticBenchFn(fn(&mut Bencher)),\n@@ -285,7 +285,7 @@ pub struct TestOpts {\n     pub filter: Option<String>,\n     pub run_ignored: bool,\n     pub run_tests: bool,\n-    pub run_benchmarks: bool,\n+    pub bench_benchmarks: bool,\n     pub logfile: Option<PathBuf>,\n     pub nocapture: bool,\n     pub color: ColorConfig,\n@@ -298,7 +298,7 @@ impl TestOpts {\n             filter: None,\n             run_ignored: false,\n             run_tests: false,\n-            run_benchmarks: false,\n+            bench_benchmarks: false,\n             logfile: None,\n             nocapture: false,\n             color: AutoColor,\n@@ -377,8 +377,8 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     let logfile = matches.opt_str(\"logfile\");\n     let logfile = logfile.map(|s| PathBuf::from(&s));\n \n-    let run_benchmarks = matches.opt_present(\"bench\");\n-    let run_tests = ! run_benchmarks ||\n+    let bench_benchmarks = matches.opt_present(\"bench\");\n+    let run_tests = ! bench_benchmarks ||\n         matches.opt_present(\"test\");\n \n     let mut nocapture = matches.opt_present(\"nocapture\");\n@@ -400,7 +400,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         filter: filter,\n         run_ignored: run_ignored,\n         run_tests: run_tests,\n-        run_benchmarks: run_benchmarks,\n+        bench_benchmarks: bench_benchmarks,\n         logfile: logfile,\n         nocapture: nocapture,\n         color: color,\n@@ -778,7 +778,11 @@ fn run_tests<F>(opts: &TestOpts,\n                 mut callback: F) -> io::Result<()> where\n     F: FnMut(TestEvent) -> io::Result<()>,\n {\n-    let filtered_tests = filter_tests(opts, tests);\n+    let mut filtered_tests = filter_tests(opts, tests);\n+    if !opts.bench_benchmarks {\n+        filtered_tests = convert_benchmarks_to_tests(filtered_tests);\n+    }\n+\n     let filtered_descs = filtered_tests.iter()\n                                        .map(|t| t.desc.clone())\n                                        .collect();\n@@ -824,13 +828,15 @@ fn run_tests<F>(opts: &TestOpts,\n         pending -= 1;\n     }\n \n-    // All benchmarks run at the end, in serial.\n-    // (this includes metric fns)\n-    for b in filtered_benchs_and_metrics {\n-        try!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n-        run_test(opts, !opts.run_benchmarks, b, tx.clone());\n-        let (test, result, stdout) = rx.recv().unwrap();\n-        try!(callback(TeResult(test, result, stdout)));\n+    if opts.bench_benchmarks {\n+        // All benchmarks run at the end, in serial.\n+        // (this includes metric fns)\n+        for b in filtered_benchs_and_metrics {\n+            try!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n+            run_test(opts, false, b, tx.clone());\n+            let (test, result, stdout) = rx.recv().unwrap();\n+            try!(callback(TeResult(test, result, stdout)));\n+        }\n     }\n     Ok(())\n }\n@@ -893,6 +899,22 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     filtered\n }\n \n+pub fn convert_benchmarks_to_tests(tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n+    // convert benchmarks to tests, if we're not benchmarking them\n+    tests.into_iter().map(|x| {\n+        let testfn = match x.testfn {\n+            DynBenchFn(bench) => {\n+                DynTestFn(Box::new(move || bench::run_once(|b| bench.run(b))))\n+            }\n+            StaticBenchFn(benchfn) => {\n+                DynTestFn(Box::new(move || bench::run_once(|b| benchfn(b))))\n+            }\n+            f => f\n+        };\n+        TestDescAndFn { desc: x.desc, testfn: testfn }\n+    }).collect()\n+}\n+\n pub fn run_test(opts: &TestOpts,\n                 force_ignore: bool,\n                 test: TestDescAndFn,\n@@ -1159,6 +1181,15 @@ pub mod bench {\n             mb_s: mb_s as usize\n         }\n     }\n+\n+    pub fn run_once<F>(f: F) where F: FnOnce(&mut Bencher) {\n+        let mut bs = Bencher {\n+            iterations: 0,\n+            dur: Duration::nanoseconds(0),\n+            bytes: 0\n+        };\n+        bs.bench_n(1, f);\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "51f9de8edf057541e005040ad6da030a998070b9", "filename": "src/rt/valgrind/valgrind.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Frt%2Fvalgrind%2Fvalgrind.h", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Frt%2Fvalgrind%2Fvalgrind.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fvalgrind%2Fvalgrind.h?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -5122,7 +5122,7 @@ VALGRIND_PRINTF_BACKTRACE(const char *format, ...)\n \n \n /* These requests allow control to move from the simulated CPU to the\n-   real CPU, calling an arbitary function.\n+   real CPU, calling an arbitrary function.\n \n    Note that the current ThreadId is inserted as the first argument.\n    So this call:"}, {"sha": "eaec37ed417d06afe8bcfee37d338d28a170515e", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -1,34 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_name=\"crateresolve5#0.1\"]\n-\n-#![crate_type = \"lib\"]\n-\n-pub struct NameVal { pub name: String, pub val: isize }\n-\n-pub fn struct_nameval() -> NameVal {\n-    NameVal { name: \"crateresolve5\".to_string(), val: 10 }\n-}\n-\n-pub enum e {\n-    e_val\n-}\n-\n-pub fn nominal() -> e { e_val }\n-\n-pub fn nominal_eq(_e1: e, _e2: e) -> bool { true }\n-\n-impl PartialEq for e {\n-    fn eq(&self, other: &e) -> bool { nominal_eq(*self, *other) }\n-    fn ne(&self, other: &e) -> bool { !nominal_eq(*self, *other) }\n-}\n-\n-pub fn f() -> isize { 10 }"}, {"sha": "14d28c709cdb56f8a08ed738b2aaf9485285ef74", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_name=\"crateresolve5#0.2\"]\n-\n-#![crate_type = \"lib\"]\n-\n-pub struct NameVal { pub name: String, pub val: isize }\n-pub fn struct_nameval() -> NameVal {\n-    NameVal { name: \"crateresolve5\".to_string(), val: 10 }\n-}\n-\n-pub enum e {\n-    e_val\n-}\n-\n-impl PartialEq for e {\n-    fn eq(&self, other: &e) -> bool { !nominal_neq(*self, *other) }\n-    fn ne(&self, other: &e) -> bool { nominal_neq(*self, *other) }\n-}\n-\n-pub fn nominal() -> e { e_val }\n-\n-pub fn nominal_neq(_e1: e, _e2: e) -> bool { false }\n-\n-pub fn f() -> isize { 20 }"}, {"sha": "c05d292eaea47a395c115d08b5b1e6290da89061", "filename": "src/test/auxiliary/crateresolve7x.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fcrateresolve7x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fcrateresolve7x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve7x.rs?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// aux-build:crateresolve_calories-1.rs\n-// aux-build:crateresolve_calories-2.rs\n-\n-// These both have the same version but differ in other metadata\n-pub mod a {\n-    extern crate cr_1 (name = \"crateresolve_calories\", vers = \"0.1\", calories=\"100\");\n-    pub fn f() -> isize { cr_1::f() }\n-}\n-\n-pub mod b {\n-    extern crate cr_2 (name = \"crateresolve_calories\", vers = \"0.1\", calories=\"200\");\n-    pub fn f() -> isize { cr_2::f() }\n-}"}, {"sha": "c1705d687abb00bf6fbdad445cc6151b77b0c23c", "filename": "src/test/auxiliary/crateresolve_calories-1.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_name=\"crateresolve_calories#0.1\"]\n-#![crate_type = \"lib\"]\n-\n-pub fn f() -> isize { 100 }"}, {"sha": "2ae87daab4e29b63f4498b9c0ac40678a752564e", "filename": "src/test/auxiliary/crateresolve_calories-2.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5ca282b20391c6df51fdfa94e0de5672ccfac1/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs?ref=aa5ca282b20391c6df51fdfa94e0de5672ccfac1", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![crate_name=\"crateresolve_calories#0.1\"]\n-#![crate_type = \"lib\"]\n-\n-pub fn f() -> isize { 200 }"}, {"sha": "253c89233bf5a946bbf0793864a405218ec140ed", "filename": "src/test/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -55,7 +55,7 @@ fn expand(cx: &mut ExtCtxt,\n                 ret_ty: Literal(Path::new_local(\"isize\")),\n                 attributes: vec![],\n                 combine_substructure: combine_substructure(box |cx, span, substr| {\n-                    let zero = cx.expr_int(span, 0);\n+                    let zero = cx.expr_isize(span, 0);\n                     cs_fold(false,\n                             |cx, span, subexpr, field, _| {\n                                 cx.expr_binary(span, ast::BiAdd, subexpr,"}, {"sha": "445aa743a77feb7f3f40fa5850ef42846feec4ad", "filename": "src/test/auxiliary/custom_derive_plugin_attr.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -0,0 +1,87 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+\n+#![feature(plugin_registrar)]\n+#![feature(box_syntax)]\n+#![feature(rustc_private)]\n+\n+extern crate syntax;\n+extern crate rustc;\n+\n+use syntax::ast;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::codemap::Span;\n+use syntax::ext::base::{Decorator, ExtCtxt};\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n+use syntax::ext::deriving::generic::{Substructure, Struct, EnumMatching};\n+use syntax::ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n+use syntax::parse::token;\n+use syntax::ptr::P;\n+use rustc::plugin::Registry;\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_syntax_extension(\n+        token::intern(\"derive_TotalSum\"),\n+        Decorator(box expand));\n+}\n+\n+fn expand(cx: &mut ExtCtxt,\n+          span: Span,\n+          mitem: &ast::MetaItem,\n+          item: &ast::Item,\n+          push: &mut FnMut(P<ast::Item>)) {\n+    let trait_def = TraitDef {\n+        span: span,\n+        attributes: vec![],\n+        path: Path::new(vec![\"TotalSum\"]),\n+        additional_bounds: vec![],\n+        generics: LifetimeBounds::empty(),\n+        associated_types: vec![],\n+        methods: vec![\n+            MethodDef {\n+                name: \"total_sum\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: borrowed_explicit_self(),\n+                args: vec![],\n+                ret_ty: Literal(Path::new_local(\"isize\")),\n+                attributes: vec![],\n+                combine_substructure: combine_substructure(Box::new(totalsum_substructure)),\n+            },\n+        ],\n+    };\n+\n+    trait_def.expand(cx, mitem, item, push)\n+}\n+\n+// Mostly copied from syntax::ext::deriving::hash\n+/// Defines how the implementation for `trace()` is to be generated\n+fn totalsum_substructure(cx: &mut ExtCtxt, trait_span: Span,\n+                         substr: &Substructure) -> P<ast::Expr> {\n+    let fields = match *substr.fields {\n+        Struct(ref fs) | EnumMatching(_, _, ref fs) => fs,\n+        _ => cx.span_bug(trait_span, \"impossible substructure\")\n+    };\n+\n+    fields.iter().fold(cx.expr_isize(trait_span, 0), |acc, ref item| {\n+        if item.attrs.iter().find(|a| a.check_name(\"ignore\")).is_some() {\n+            acc\n+        } else {\n+            cx.expr_binary(item.span, ast::BiAdd, acc,\n+                           cx.expr_method_call(item.span,\n+                                               item.self_.clone(),\n+                                               substr.method_ident,\n+                                               Vec::new()))\n+        }\n+    })\n+}"}, {"sha": "76c5cdafd7cf1b9f7d54bea6e244a773bfadd884", "filename": "src/test/auxiliary/issue-19163.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fauxiliary%2Fissue-19163.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fauxiliary%2Fissue-19163.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-19163.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![crate_name=\"crateresolve4a#0.2\"]\n #![crate_type = \"lib\"]\n \n-pub fn g() -> isize { 20 }\n+#[macro_export]\n+macro_rules! mywrite {\n+    ($dst:expr, $($arg:tt)*) => ($dst.write_fmt(format_args!($($arg)*)))\n+}", "previous_filename": "src/test/auxiliary/crateresolve4a-2.rs"}, {"sha": "40e01c1474a60cea9a88a240335a72d9c96d70fa", "filename": "src/test/auxiliary/issue_8401.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fauxiliary%2Fissue_8401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fauxiliary%2Fissue_8401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_8401.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -21,6 +21,6 @@ impl A for B {}\n fn bar<T>(_: &mut A, _: &T) {}\n \n fn foo<T>(t: &T) {\n-    let b = B;\n-    bar(unsafe { mem::transmute(&b as &A) }, t)\n+    let mut b = B;\n+    bar(&mut b as &mut A, t)\n }"}, {"sha": "07174de88a3d017b385c4bdcfbc0abf8e775ef34", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This test creates a bunch of tasks that simultaneously send to each\n+// This test creates a bunch of threads that simultaneously send to each\n // other in a ring. The messages should all be basically\n // independent.\n // This is like msgsend-ring-pipes but adapted to use Arcs.\n@@ -52,7 +52,7 @@ fn thread_ring(i: usize, count: usize, num_chan: pipe, num_port: pipe) {\n     let mut num_port = Some(num_port);\n     // Send/Receive lots of messages.\n     for j in 0..count {\n-        //println!(\"task %?, iter %?\", i, j);\n+        //println!(\"thread %?, iter %?\", i, j);\n         let num_chan2 = num_chan.take().unwrap();\n         let num_port2 = num_port.take().unwrap();\n         send(&num_chan2, i * j);"}, {"sha": "9be13101aa8a1d108d30de13c6c704eec1665d69", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f", "patch": "@@ -21,14 +21,14 @@ use std::sync::mpsc::channel;\n use std::env;\n use std::thread;\n \n-// This is a simple bench that creates M pairs of tasks. These\n-// tasks ping-pong back and forth over a pair of streams. This is a\n+// This is a simple bench that creates M pairs of threads. These\n+// threads ping-pong back and forth over a pair of streams. This is a\n // canonical message-passing benchmark as it heavily strains message\n // passing and almost nothing else.\n \n fn ping_pong_bench(n: usize, m: usize) {\n \n-    // Create pairs of tasks that pingpong back and forth.\n+    // Create pairs of threads that pingpong back and forth.\n     fn run_pair(n: usize) {\n         // Create a channel: A->B\n         let (atx, arx) = channel();"}, {"sha": "2c5c0ea27c7603b02d1e2020177014b80b9aebe2", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f"}, {"sha": "365a86464e2d377a6c82ef2072be1d37aed31558", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f"}, {"sha": "6e3db3d01960eabeb8642cb4230d439900030ea9", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f"}, {"sha": "8c13ff70515313a63ed79e9a1371d8563fe12fbe", "filename": "src/test/compile-fail/bad-sized.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f"}, {"sha": "6e543d017f26045b10177d560f656d0531d499bc", "filename": "src/test/compile-fail/dropck_trait_cycle_checked.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f"}, {"sha": "381dff36b7d408890060a44c6d3ff5373eedf083", "filename": "src/test/compile-fail/fat-ptr-cast.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f"}, {"sha": "6d42515704ea117a95e42655de397df4602bcf7c", "filename": "src/test/compile-fail/invalid_crate_type_syntax.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Finvalid_crate_type_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Finvalid_crate_type_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finvalid_crate_type_syntax.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f"}, {"sha": "5322966ae2ea0544a78d19a242c8d592a74187d2", "filename": "src/test/compile-fail/issue-12187-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f"}, {"sha": "dabc0acba370e07a4344f577306d9752f6fcbf22", "filename": "src/test/compile-fail/issue-12187-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f"}, {"sha": "35697e687341f10b8c35655fcdb4dc8054721b6e", "filename": "src/test/compile-fail/issue-12511.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Fissue-12511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0216fcc42d5f4961d07378a783c87814097015f/src%2Ftest%2Fcompile-fail%2Fissue-12511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12511.rs?ref=e0216fcc42d5f4961d07378a783c87814097015f"}]}