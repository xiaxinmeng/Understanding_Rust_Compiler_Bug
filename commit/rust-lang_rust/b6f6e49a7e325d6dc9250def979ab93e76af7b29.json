{"sha": "b6f6e49a7e325d6dc9250def979ab93e76af7b29", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2ZjZlNDlhN2UzMjVkNmRjOTI1MGRlZjk3OWFiOTNlNzZhZjdiMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-20T21:46:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-20T21:46:24Z"}, "message": "auto merge of #11636 : alexcrichton/rust/purge-all-the-c, r=brson\n\nThis means we can purge even more C from src/rt!", "tree": {"sha": "3bae0194884a052e28ee385ab5d53951ff0cb16d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3bae0194884a052e28ee385ab5d53951ff0cb16d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6f6e49a7e325d6dc9250def979ab93e76af7b29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6f6e49a7e325d6dc9250def979ab93e76af7b29", "html_url": "https://github.com/rust-lang/rust/commit/b6f6e49a7e325d6dc9250def979ab93e76af7b29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6f6e49a7e325d6dc9250def979ab93e76af7b29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4640f9d661ac293bce5f5bc9f8e9150d363e178", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4640f9d661ac293bce5f5bc9f8e9150d363e178", "html_url": "https://github.com/rust-lang/rust/commit/d4640f9d661ac293bce5f5bc9f8e9150d363e178"}, {"sha": "c6123ca105880de1ec34ef1d85391ccc8071a7b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6123ca105880de1ec34ef1d85391ccc8071a7b9", "html_url": "https://github.com/rust-lang/rust/commit/c6123ca105880de1ec34ef1d85391ccc8071a7b9"}], "stats": {"total": 366, "additions": 158, "deletions": 208}, "files": [{"sha": "aa4dda786e3c65ad1b02e69339e4d45590dcc26c", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b6f6e49a7e325d6dc9250def979ab93e76af7b29/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6f6e49a7e325d6dc9250def979ab93e76af7b29/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=b6f6e49a7e325d6dc9250def979ab93e76af7b29", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use ai = std::io::net::addrinfo;\n+use std::cast;\n use std::libc::c_int;\n use std::ptr::null;\n use std::rt::task::BlockedTask;\n@@ -138,7 +139,8 @@ pub fn accum_addrinfo(addr: &Addrinfo) -> ~[ai::Info] {\n \n         let mut addrs = ~[];\n         loop {\n-            let rustaddr = net::sockaddr_to_socket_addr((*addr).ai_addr);\n+            let rustaddr = net::sockaddr_to_addr(cast::transmute((*addr).ai_addr),\n+                                                 (*addr).ai_addrlen as uint);\n \n             let mut flags = 0;\n             each_ai_flag(|cval, aival| {"}, {"sha": "3353db63e6865a625815d1bbcff9c2b11db1becd", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6f6e49a7e325d6dc9250def979ab93e76af7b29/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6f6e49a7e325d6dc9250def979ab93e76af7b29/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=b6f6e49a7e325d6dc9250def979ab93e76af7b29", "patch": "@@ -47,7 +47,7 @@ via `close` and `delete` methods.\n use std::cast;\n use std::io;\n use std::io::IoError;\n-use std::libc::{c_int, malloc};\n+use std::libc::c_int;\n use std::ptr::null;\n use std::ptr;\n use std::rt::local::Local;"}, {"sha": "004a014463514a20e0ec0e9685489f2b2607a503", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 148, "deletions": 135, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/b6f6e49a7e325d6dc9250def979ab93e76af7b29/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6f6e49a7e325d6dc9250def979ab93e76af7b29/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=b6f6e49a7e325d6dc9250def979ab93e76af7b29", "patch": "@@ -10,16 +10,14 @@\n \n use std::cast;\n use std::io::IoError;\n-use std::io::net::ip::{Ipv4Addr, Ipv6Addr, SocketAddr, IpAddr};\n-use std::libc::{size_t, ssize_t, c_int, c_void, c_uint, c_char};\n+use std::io::net::ip;\n+use std::libc::{size_t, ssize_t, c_int, c_void, c_uint};\n use std::libc;\n+use std::mem;\n use std::ptr;\n use std::rt::rtio;\n use std::rt::task::BlockedTask;\n-use std::str;\n-use std::unstable::finally::Finally;\n-use std::vec;\n-use std::rt::global_heap::malloc_raw;\n+use std::unstable::intrinsics;\n \n use homing::{HomingIO, HomeHandle};\n use stream::StreamWatcher;\n@@ -28,82 +26,95 @@ use super::{Loop, Request, UvError, Buf, status_to_io_result,\n             wait_until_woken_after, wakeup};\n use uvio::UvIoFactory;\n use uvll;\n-use uvll::sockaddr;\n \n ////////////////////////////////////////////////////////////////////////////////\n /// Generic functions related to dealing with sockaddr things\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn socket_addr_as_sockaddr<T>(addr: SocketAddr, f: |*sockaddr| -> T) -> T {\n-    let malloc = match addr.ip {\n-        Ipv4Addr(..) => uvll::rust_malloc_ip4_addr,\n-        Ipv6Addr(..) => uvll::rust_malloc_ip6_addr,\n-    };\n-\n-    let ip = addr.ip.to_str();\n-    let addr = ip.with_c_str(|p| unsafe { malloc(p, addr.port as c_int) });\n-    (|| {\n-        f(addr)\n-    }).finally(|| {\n-        unsafe { libc::free(addr) };\n-    })\n-}\n+pub fn htons(u: u16) -> u16 { intrinsics::to_be16(u as i16) as u16 }\n+pub fn ntohs(u: u16) -> u16 { intrinsics::from_be16(u as i16) as u16 }\n \n-pub fn sockaddr_to_socket_addr(addr: *sockaddr) -> SocketAddr {\n-    unsafe {\n-        let ip_size = if uvll::rust_is_ipv4_sockaddr(addr) == 1 {\n-            4/*groups of*/ * 3/*digits separated by*/ + 3/*periods*/\n-        } else if uvll::rust_is_ipv6_sockaddr(addr) == 1 {\n-            8/*groups of*/ * 4/*hex digits separated by*/ + 7 /*colons*/\n-        } else {\n-            fail!(\"unknown address?\");\n-        };\n-        let ip_name = {\n-            // apparently there's an off-by-one in libuv?\n-            let ip_size = ip_size + 1;\n-            let buf = vec::from_elem(ip_size + 1 /*null terminated*/, 0u8);\n-            let buf_ptr = buf.as_ptr();\n-            let ret = if uvll::rust_is_ipv4_sockaddr(addr) == 1 {\n-                uvll::uv_ip4_name(addr, buf_ptr as *c_char, ip_size as size_t)\n-            } else {\n-                uvll::uv_ip6_name(addr, buf_ptr as *c_char, ip_size as size_t)\n+pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n+                        len: uint) -> ip::SocketAddr {\n+    match storage.ss_family as c_int {\n+        libc::AF_INET => {\n+            assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n+            let storage: &libc::sockaddr_in = unsafe {\n+                cast::transmute(storage)\n             };\n-            if ret != 0 {\n-                fail!(\"error parsing sockaddr: {}\", UvError(ret).desc());\n+            let addr = storage.sin_addr.s_addr as u32;\n+            let a = (addr >>  0) as u8;\n+            let b = (addr >>  8) as u8;\n+            let c = (addr >> 16) as u8;\n+            let d = (addr >> 24) as u8;\n+            ip::SocketAddr {\n+                ip: ip::Ipv4Addr(a, b, c, d),\n+                port: ntohs(storage.sin_port),\n             }\n-            buf\n-        };\n-        let ip_port = {\n-            let port = if uvll::rust_is_ipv4_sockaddr(addr) == 1 {\n-                uvll::rust_ip4_port(addr)\n-            } else {\n-                uvll::rust_ip6_port(addr)\n+        }\n+        libc::AF_INET6 => {\n+            assert!(len as uint >= mem::size_of::<libc::sockaddr_in6>());\n+            let storage: &libc::sockaddr_in6 = unsafe {\n+                cast::transmute(storage)\n             };\n-            port as u16\n-        };\n-        let ip_str = str::from_utf8(ip_name).trim_right_chars(&'\\x00');\n-        let ip_addr = FromStr::from_str(ip_str).unwrap();\n-\n-        SocketAddr { ip: ip_addr, port: ip_port }\n+            let a = ntohs(storage.sin6_addr.s6_addr[0]);\n+            let b = ntohs(storage.sin6_addr.s6_addr[1]);\n+            let c = ntohs(storage.sin6_addr.s6_addr[2]);\n+            let d = ntohs(storage.sin6_addr.s6_addr[3]);\n+            let e = ntohs(storage.sin6_addr.s6_addr[4]);\n+            let f = ntohs(storage.sin6_addr.s6_addr[5]);\n+            let g = ntohs(storage.sin6_addr.s6_addr[6]);\n+            let h = ntohs(storage.sin6_addr.s6_addr[7]);\n+            ip::SocketAddr {\n+                ip: ip::Ipv6Addr(a, b, c, d, e, f, g, h),\n+                port: ntohs(storage.sin6_port),\n+            }\n+        }\n+        n => {\n+            fail!(\"unknown family {}\", n);\n+        }\n     }\n }\n \n-#[test]\n-fn test_ip4_conversion() {\n-    use std::io::net::ip::{SocketAddr, Ipv4Addr};\n-    let ip4 = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 4824 };\n-    socket_addr_as_sockaddr(ip4, |addr| {\n-        assert_eq!(ip4, sockaddr_to_socket_addr(addr));\n-    })\n-}\n-\n-#[test]\n-fn test_ip6_conversion() {\n-    use std::io::net::ip::{SocketAddr, Ipv6Addr};\n-    let ip6 = SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1), port: 4824 };\n-    socket_addr_as_sockaddr(ip6, |addr| {\n-        assert_eq!(ip6, sockaddr_to_socket_addr(addr));\n-    })\n+fn addr_to_sockaddr(addr: ip::SocketAddr) -> (libc::sockaddr_storage, uint) {\n+    unsafe {\n+        let mut storage: libc::sockaddr_storage = intrinsics::init();\n+        let len = match addr.ip {\n+            ip::Ipv4Addr(a, b, c, d) => {\n+                let storage: &mut libc::sockaddr_in =\n+                    cast::transmute(&mut storage);\n+                (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n+                (*storage).sin_port = htons(addr.port);\n+                (*storage).sin_addr = libc::in_addr {\n+                    s_addr: (d as u32 << 24) |\n+                            (c as u32 << 16) |\n+                            (b as u32 <<  8) |\n+                            (a as u32 <<  0)\n+                };\n+                mem::size_of::<libc::sockaddr_in>()\n+            }\n+            ip::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n+                let storage: &mut libc::sockaddr_in6 =\n+                    cast::transmute(&mut storage);\n+                storage.sin6_family = libc::AF_INET6 as libc::sa_family_t;\n+                storage.sin6_port = htons(addr.port);\n+                storage.sin6_addr = libc::in6_addr {\n+                    s6_addr: [\n+                        htons(a),\n+                        htons(b),\n+                        htons(c),\n+                        htons(d),\n+                        htons(e),\n+                        htons(f),\n+                        htons(g),\n+                        htons(h),\n+                    ]\n+                };\n+                mem::size_of::<libc::sockaddr_in6>()\n+            }\n+        };\n+        return (storage, len);\n+    }\n }\n \n enum SocketNameKind {\n@@ -112,26 +123,24 @@ enum SocketNameKind {\n     Udp\n }\n \n-fn socket_name(sk: SocketNameKind, handle: *c_void) -> Result<SocketAddr, IoError> {\n-    unsafe {\n-        let getsockname = match sk {\n-            TcpPeer => uvll::uv_tcp_getpeername,\n-            Tcp     => uvll::uv_tcp_getsockname,\n-            Udp     => uvll::uv_udp_getsockname,\n-        };\n+fn socket_name(sk: SocketNameKind,\n+               handle: *c_void) -> Result<ip::SocketAddr, IoError> {\n+    let getsockname = match sk {\n+        TcpPeer => uvll::uv_tcp_getpeername,\n+        Tcp     => uvll::uv_tcp_getsockname,\n+        Udp     => uvll::uv_udp_getsockname,\n+    };\n \n-        // Allocate a sockaddr_storage\n-        // since we don't know if it's ipv4 or ipv6\n-        let size = uvll::rust_sockaddr_size();\n-        let name = malloc_raw(size as uint) as *c_void;\n-        let mut namelen = size;\n+    // Allocate a sockaddr_storage since we don't know if it's ipv4 or ipv6\n+    let mut sockaddr: libc::sockaddr_storage = unsafe { intrinsics::init() };\n+    let mut namelen = mem::size_of::<libc::sockaddr_storage>() as c_int;\n \n-        let ret = match getsockname(handle, name, &mut namelen) {\n-            0 => Ok(sockaddr_to_socket_addr(name)),\n-            n => Err(uv_error_to_io_error(UvError(n)))\n-        };\n-        libc::free(name);\n-        ret\n+    let sockaddr_p = &mut sockaddr as *mut libc::sockaddr_storage;\n+    match unsafe {\n+        getsockname(handle, sockaddr_p as *mut libc::sockaddr, &mut namelen)\n+    } {\n+        0 => Ok(sockaddr_to_addr(&sockaddr, namelen as uint)),\n+        n => Err(uv_error_to_io_error(UvError(n)))\n     }\n }\n \n@@ -177,37 +186,33 @@ impl TcpWatcher {\n         }\n     }\n \n-    pub fn connect(io: &mut UvIoFactory, address: SocketAddr)\n+    pub fn connect(io: &mut UvIoFactory, address: ip::SocketAddr)\n         -> Result<TcpWatcher, UvError>\n     {\n         struct Ctx { status: c_int, task: Option<BlockedTask> }\n \n         let tcp = TcpWatcher::new(io);\n-        let ret = socket_addr_as_sockaddr(address, |addr| {\n-            let mut req = Request::new(uvll::UV_CONNECT);\n-            let result = unsafe {\n-                uvll::uv_tcp_connect(req.handle, tcp.handle, addr,\n-                                     connect_cb)\n-            };\n-            match result {\n-                0 => {\n-                    req.defuse(); // uv callback now owns this request\n-                    let mut cx = Ctx { status: 0, task: None };\n-                    wait_until_woken_after(&mut cx.task, || {\n-                        req.set_data(&cx);\n-                    });\n-                    match cx.status {\n-                        0 => Ok(()),\n-                        n => Err(UvError(n)),\n-                    }\n+        let (addr, _len) = addr_to_sockaddr(address);\n+        let mut req = Request::new(uvll::UV_CONNECT);\n+        let result = unsafe {\n+            let addr_p = &addr as *libc::sockaddr_storage;\n+            uvll::uv_tcp_connect(req.handle, tcp.handle,\n+                                 addr_p as *libc::sockaddr,\n+                                 connect_cb)\n+        };\n+        return match result {\n+            0 => {\n+                req.defuse(); // uv callback now owns this request\n+                let mut cx = Ctx { status: 0, task: None };\n+                wait_until_woken_after(&mut cx.task, || {\n+                    req.set_data(&cx);\n+                });\n+                match cx.status {\n+                    0 => Ok(tcp),\n+                    n => Err(UvError(n)),\n                 }\n-                n => Err(UvError(n))\n             }\n-        });\n-\n-        return match ret {\n-            Ok(()) => Ok(tcp),\n-            Err(e) => Err(e),\n+            n => Err(UvError(n))\n         };\n \n         extern fn connect_cb(req: *uvll::uv_connect_t, status: c_int) {\n@@ -225,7 +230,7 @@ impl HomingIO for TcpWatcher {\n }\n \n impl rtio::RtioSocket for TcpWatcher {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(Tcp, self.handle)\n     }\n@@ -242,7 +247,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n         self.stream.write(buf).map_err(uv_error_to_io_error)\n     }\n \n-    fn peer_name(&mut self) -> Result<SocketAddr, IoError> {\n+    fn peer_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(TcpPeer, self.handle)\n     }\n@@ -291,7 +296,7 @@ impl Drop for TcpWatcher {\n // TCP listeners (unbound servers)\n \n impl TcpListener {\n-    pub fn bind(io: &mut UvIoFactory, address: SocketAddr)\n+    pub fn bind(io: &mut UvIoFactory, address: ip::SocketAddr)\n                 -> Result<~TcpListener, UvError> {\n         let handle = unsafe { uvll::malloc_handle(uvll::UV_TCP) };\n         assert_eq!(unsafe {\n@@ -305,9 +310,11 @@ impl TcpListener {\n             outgoing: chan,\n             incoming: port,\n         };\n-        let res = socket_addr_as_sockaddr(address, |addr| unsafe {\n-            uvll::uv_tcp_bind(l.handle, addr)\n-        });\n+        let (addr, _len) = addr_to_sockaddr(address);\n+        let res = unsafe {\n+            let addr_p = &addr as *libc::sockaddr_storage;\n+            uvll::uv_tcp_bind(l.handle, addr_p as *libc::sockaddr)\n+        };\n         return match res {\n             0 => Ok(l.install()),\n             n => Err(UvError(n))\n@@ -324,7 +331,7 @@ impl UvHandle<uvll::uv_tcp_t> for TcpListener {\n }\n \n impl rtio::RtioSocket for TcpListener {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(Tcp, self.handle)\n     }\n@@ -375,7 +382,7 @@ impl HomingIO for TcpAcceptor {\n }\n \n impl rtio::RtioSocket for TcpAcceptor {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(Tcp, self.listener.handle)\n     }\n@@ -411,7 +418,7 @@ pub struct UdpWatcher {\n }\n \n impl UdpWatcher {\n-    pub fn bind(io: &mut UvIoFactory, address: SocketAddr)\n+    pub fn bind(io: &mut UvIoFactory, address: ip::SocketAddr)\n                 -> Result<UdpWatcher, UvError> {\n         let udp = UdpWatcher {\n             handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n@@ -420,9 +427,11 @@ impl UdpWatcher {\n         assert_eq!(unsafe {\n             uvll::uv_udp_init(io.uv_loop(), udp.handle)\n         }, 0);\n-        let result = socket_addr_as_sockaddr(address, |addr| unsafe {\n-            uvll::uv_udp_bind(udp.handle, addr, 0u32)\n-        });\n+        let (addr, _len) = addr_to_sockaddr(address);\n+        let result = unsafe {\n+            let addr_p = &addr as *libc::sockaddr_storage;\n+            uvll::uv_udp_bind(udp.handle, addr_p as *libc::sockaddr, 0u32)\n+        };\n         return match result {\n             0 => Ok(udp),\n             n => Err(UvError(n)),\n@@ -439,20 +448,20 @@ impl HomingIO for UdpWatcher {\n }\n \n impl rtio::RtioSocket for UdpWatcher {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+    fn socket_name(&mut self) -> Result<ip::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n         socket_name(Udp, self.handle)\n     }\n }\n \n impl rtio::RtioUdpSocket for UdpWatcher {\n     fn recvfrom(&mut self, buf: &mut [u8])\n-        -> Result<(uint, SocketAddr), IoError>\n+        -> Result<(uint, ip::SocketAddr), IoError>\n     {\n         struct Ctx {\n             task: Option<BlockedTask>,\n             buf: Option<Buf>,\n-            result: Option<(ssize_t, Option<SocketAddr>)>,\n+            result: Option<(ssize_t, Option<ip::SocketAddr>)>,\n         }\n         let _m = self.fire_homing_missile();\n \n@@ -489,7 +498,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         }\n \n         extern fn recv_cb(handle: *uvll::uv_udp_t, nread: ssize_t, buf: *Buf,\n-                          addr: *uvll::sockaddr, _flags: c_uint) {\n+                          addr: *libc::sockaddr, _flags: c_uint) {\n             assert!(nread != uvll::ECANCELED as ssize_t);\n             let cx: &mut Ctx = unsafe {\n                 cast::transmute(uvll::get_data_for_uv_handle(handle))\n@@ -513,23 +522,27 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             let addr = if addr == ptr::null() {\n                 None\n             } else {\n-                Some(sockaddr_to_socket_addr(addr))\n+                let len = mem::size_of::<libc::sockaddr_storage>();\n+                Some(sockaddr_to_addr(unsafe { cast::transmute(addr) }, len))\n             };\n             cx.result = Some((nread, addr));\n             wakeup(&mut cx.task);\n         }\n     }\n \n-    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n+    fn sendto(&mut self, buf: &[u8], dst: ip::SocketAddr) -> Result<(), IoError> {\n         struct Ctx { task: Option<BlockedTask>, result: c_int }\n \n         let _m = self.fire_homing_missile();\n \n         let mut req = Request::new(uvll::UV_UDP_SEND);\n         let buf = slice_to_uv_buf(buf);\n-        let result = socket_addr_as_sockaddr(dst, |dst| unsafe {\n-            uvll::uv_udp_send(req.handle, self.handle, [buf], dst, send_cb)\n-        });\n+        let (addr, _len) = addr_to_sockaddr(dst);\n+        let result = unsafe {\n+            let addr_p = &addr as *libc::sockaddr_storage;\n+            uvll::uv_udp_send(req.handle, self.handle, [buf],\n+                              addr_p as *libc::sockaddr, send_cb)\n+        };\n \n         return match result {\n             0 => {\n@@ -555,7 +568,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         }\n     }\n \n-    fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n+    fn join_multicast(&mut self, multi: ip::IpAddr) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             multi.to_str().with_c_str(|m_addr| {\n@@ -566,7 +579,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n         })\n     }\n \n-    fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n+    fn leave_multicast(&mut self, multi: ip::IpAddr) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n             multi.to_str().with_c_str(|m_addr| {"}, {"sha": "189a820cd3ee12106ccfbe74907f2a96eb551c62", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b6f6e49a7e325d6dc9250def979ab93e76af7b29/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6f6e49a7e325d6dc9250def979ab93e76af7b29/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=b6f6e49a7e325d6dc9250def979ab93e76af7b29", "patch": "@@ -30,8 +30,7 @@\n #[allow(non_camel_case_types)]; // C types\n \n use std::libc::{size_t, c_int, c_uint, c_void, c_char, c_double};\n-use std::libc::ssize_t;\n-use std::libc::free;\n+use std::libc::{ssize_t, sockaddr, free};\n use std::libc;\n use std::rt::global_heap::malloc_raw;\n \n@@ -250,11 +249,6 @@ pub type uv_signal_cb = extern \"C\" fn(handle: *uv_signal_t,\n                                       signum: c_int);\n pub type uv_fs_cb = extern \"C\" fn(req: *uv_fs_t);\n \n-pub type sockaddr = c_void;\n-\n-#[cfg(unix)]\n-pub type socklen_t = c_int;\n-\n // XXX: This is a standard C type. Could probably be defined in libc\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"linux\")]\n@@ -263,7 +257,7 @@ pub struct addrinfo {\n     ai_family: c_int,\n     ai_socktype: c_int,\n     ai_protocol: c_int,\n-    ai_addrlen: socklen_t,\n+    ai_addrlen: libc::socklen_t,\n     ai_addr: *sockaddr,\n     ai_canonname: *char,\n     ai_next: *addrinfo\n@@ -276,7 +270,7 @@ pub struct addrinfo {\n     ai_family: c_int,\n     ai_socktype: c_int,\n     ai_protocol: c_int,\n-    ai_addrlen: socklen_t,\n+    ai_addrlen: libc::socklen_t,\n     ai_canonname: *char,\n     ai_addr: *sockaddr,\n     ai_next: *addrinfo\n@@ -537,15 +531,6 @@ extern {}\n extern {\n     fn rust_uv_loop_new() -> *c_void;\n \n-    // dealing with sockaddr things\n-    pub fn rust_sockaddr_size() -> c_int;\n-    pub fn rust_malloc_ip4_addr(s: *c_char, port: c_int) -> *sockaddr;\n-    pub fn rust_malloc_ip6_addr(s: *c_char, port: c_int) -> *sockaddr;\n-    pub fn rust_ip4_port(src: *sockaddr) -> c_uint;\n-    pub fn rust_ip6_port(src: *sockaddr) -> c_uint;\n-    pub fn rust_is_ipv4_sockaddr(addr: *sockaddr) -> c_int;\n-    pub fn rust_is_ipv6_sockaddr(addr: *sockaddr) -> c_int;\n-\n     #[cfg(test)]\n     fn rust_uv_handle_type_max() -> uintptr_t;\n     #[cfg(test)]\n@@ -609,20 +594,14 @@ extern {\n     pub fn uv_tcp_connect(c: *uv_connect_t, h: *uv_tcp_t,\n                           addr: *sockaddr, cb: uv_connect_cb) -> c_int;\n     pub fn uv_tcp_bind(t: *uv_tcp_t, addr: *sockaddr) -> c_int;\n-    pub fn uv_ip4_name(src: *sockaddr, dst: *c_char,\n-                       size: size_t) -> c_int;\n-    pub fn uv_ip6_name(src: *sockaddr, dst: *c_char,\n-                       size: size_t) -> c_int;\n     pub fn uv_tcp_nodelay(h: *uv_tcp_t, enable: c_int) -> c_int;\n     pub fn uv_tcp_keepalive(h: *uv_tcp_t, enable: c_int,\n                             delay: c_uint) -> c_int;\n     pub fn uv_tcp_simultaneous_accepts(h: *uv_tcp_t, enable: c_int) -> c_int;\n-    pub fn uv_tcp_getsockname(h: *uv_tcp_t, name: *sockaddr,\n+    pub fn uv_tcp_getsockname(h: *uv_tcp_t, name: *mut sockaddr,\n                               len: *mut c_int) -> c_int;\n-    pub fn uv_tcp_getpeername(h: *uv_tcp_t, name: *sockaddr,\n+    pub fn uv_tcp_getpeername(h: *uv_tcp_t, name: *mut sockaddr,\n                               len: *mut c_int) -> c_int;\n-    pub fn uv_ip4_addr(ip: *c_char, port: c_int, addr: *sockaddr) -> c_int;\n-    pub fn uv_ip6_addr(ip: *c_char, port: c_int, addr: *sockaddr) -> c_int;\n \n     // udp bindings\n     pub fn uv_udp_init(l: *uv_loop_t, h: *uv_udp_t) -> c_int;\n@@ -638,7 +617,7 @@ extern {\n     pub fn uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n     pub fn uv_udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n     pub fn uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int;\n-    pub fn uv_udp_getsockname(h: *uv_udp_t, name: *sockaddr,\n+    pub fn uv_udp_getsockname(h: *uv_udp_t, name: *mut sockaddr,\n                               len: *mut c_int) -> c_int;\n \n     // timer bindings"}, {"sha": "4d859eacecc4e435326a5a05ec777213a98fd674", "filename": "src/rt/rust_uv.c", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b6f6e49a7e325d6dc9250def979ab93e76af7b29/src%2Frt%2Frust_uv.c", "raw_url": "https://github.com/rust-lang/rust/raw/b6f6e49a7e325d6dc9250def979ab93e76af7b29/src%2Frt%2Frust_uv.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.c?ref=b6f6e49a7e325d6dc9250def979ab93e76af7b29", "patch": "@@ -87,50 +87,6 @@ rust_uv_set_data_for_req(uv_req_t* req, void* data) {\n     req->data = data;\n }\n \n-int\n-rust_sockaddr_size() {\n-    return sizeof(struct sockaddr_storage);\n-}\n-\n-struct sockaddr*\n-rust_malloc_ip4_addr(char *name, int port) {\n-    struct sockaddr_in *addr = (struct sockaddr_in*) calloc(1, rust_sockaddr_size());\n-    assert(addr != NULL);\n-    addr->sin_port = htons(port);\n-    assert(uv_inet_pton(AF_INET, name, &addr->sin_addr) == 0);\n-    addr->sin_family = AF_INET;\n-    return (struct sockaddr*) addr;\n-}\n-\n-struct sockaddr*\n-rust_malloc_ip6_addr(char *name, int port) {\n-    struct sockaddr_in6 *addr = (struct sockaddr_in6*) calloc(1, rust_sockaddr_size());\n-    assert(addr != NULL);\n-    addr->sin6_port = htons(port);\n-    assert(uv_inet_pton(AF_INET6, name, &addr->sin6_addr) == 0);\n-    addr->sin6_family = AF_INET6;\n-    return (struct sockaddr*) addr;\n-}\n-\n-unsigned int\n-rust_ip4_port(struct sockaddr_in* src) {\n-    return ntohs(src->sin_port);\n-}\n-unsigned int\n-rust_ip6_port(struct sockaddr_in6* src) {\n-    return ntohs(src->sin6_port);\n-}\n-\n-int\n-rust_is_ipv4_sockaddr(struct sockaddr* addr) {\n-    return addr->sa_family == AF_INET;\n-}\n-\n-int\n-rust_is_ipv6_sockaddr(struct sockaddr* addr) {\n-    return addr->sa_family == AF_INET6;\n-}\n-\n uintptr_t\n rust_uv_handle_type_max() {\n   return UV_HANDLE_TYPE_MAX;"}]}