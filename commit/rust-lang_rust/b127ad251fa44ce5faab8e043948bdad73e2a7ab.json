{"sha": "b127ad251fa44ce5faab8e043948bdad73e2a7ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxMjdhZDI1MWZhNDRjZTVmYWFiOGUwNDM5NDhiZGFkNzNlMmE3YWI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-09-12T12:26:40Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-09-12T12:38:59Z"}, "message": "Rustup", "tree": {"sha": "c5b255ccd02abbe9c5284dcc2361b1fa88a7aeff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5b255ccd02abbe9c5284dcc2361b1fa88a7aeff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b127ad251fa44ce5faab8e043948bdad73e2a7ab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlm31WUACgkQpp+NIls6\n19knuhAAgABdAkdMwEWoY3Vshab3AeGMr1TPxSNudqtMWlPMDoTeWykQjAoUNEFm\nO8dVpCBREQQBhnajB1wZgcrabNE6dIwHy2tAzkCva0jreXdGvfbeEBelFtokPT2z\nxEJjeg94EqF5o8/Owhhu5/Toj9C6YXNhCxSQbJDEXvwoxS5QIvFLRQXTtfkfiOmz\n/rc0Wf7ZSu8oJIoyWd6tWf5XPDnhXb3FEP2zsfEXECco8bFzU9Q+QhfFu6Qd+9o/\ncBN/nVTSgUGFIdITrf+vrLHmqpzX0qfBUqBdZ/TAsDb60BPu6SXTiKe4KjOJsFmx\nD8xVl/8U0NL/iDCe2p4OngJycqHYRHu4bPC7Enet2UQBy7wfcxpUEMdR2V2jO8cz\natTTENK48XEobUTiAx/35si68KFnT/isQqjdS7Xhx16UFmoplOMy44XpAVjgg7Al\nNUNZaO8lC4q29IAf40UOy/qKlUOOIPAUCj8ms8KLynDtbyKHAHlmToZbcWPtIg96\ncSkgioAdFfQLWccXVwpxImqWFSesu/awOeGdKDic9gC3UQ0ZxXseTlRWbeGFfEDV\nI+9cUsjkewRGTc5dE9W1vv1DluIzL4gaNUAbkm54lSpanEiGWDdF38W5CVenee+h\nFa29Xmj+2FIMliA5HZaa9I91BQPTaPmO9TjYNk0gyS2HiNVhdRo=\n=pBqS\n-----END PGP SIGNATURE-----", "payload": "tree c5b255ccd02abbe9c5284dcc2361b1fa88a7aeff\nparent 36cd745640fdfa3f3305d22ada3598a268977578\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1505219200 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1505219939 +0200\n\nRustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b127ad251fa44ce5faab8e043948bdad73e2a7ab", "html_url": "https://github.com/rust-lang/rust/commit/b127ad251fa44ce5faab8e043948bdad73e2a7ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b127ad251fa44ce5faab8e043948bdad73e2a7ab/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36cd745640fdfa3f3305d22ada3598a268977578", "url": "https://api.github.com/repos/rust-lang/rust/commits/36cd745640fdfa3f3305d22ada3598a268977578", "html_url": "https://github.com/rust-lang/rust/commit/36cd745640fdfa3f3305d22ada3598a268977578"}], "stats": {"total": 490, "additions": 245, "deletions": 245}, "files": [{"sha": "a255b5ab90404465150103bbeae5ebda8eddf1be", "filename": "Cargo.lock", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -9,8 +9,8 @@ dependencies = [\n  \"quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"semver 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-normalization 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -61,8 +61,8 @@ name = \"cargo_metadata\"\n version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -82,8 +82,8 @@ dependencies = [\n  \"duct 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -289,22 +289,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.12\"\n+version = \"1.0.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.12\"\n+version = \"1.0.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive_internals 0.16.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serde_derive_internals\"\n-version = \"0.15.1\"\n+version = \"0.16.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -319,7 +319,7 @@ dependencies = [\n  \"dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itoa 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -364,7 +364,7 @@ name = \"toml\"\n version = \"0.4.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 1.0.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -442,9 +442,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n \"checksum semver 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a3186ec9e65071a2095434b1f5bb24838d4e8e130f584c790f6033c79943537\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n-\"checksum serde 1.0.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7f61b753dd58ec5d4c735f794dbddde1f28b977f652afbcde89d75bc77902216\"\n-\"checksum serde_derive 1.0.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2a169fa5384d751ada1da9f3992b81830151a03c875e40dcb37c9fb31aafc68f\"\n-\"checksum serde_derive_internals 0.15.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"37aee4e0da52d801acfbc0cc219eb1eda7142112339726e427926a6f6ee65d3a\"\n+\"checksum serde 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcb6a7637a47663ee073391a139ed07851f27ed2532c2abc88c6bf27a16cdf34\"\n+\"checksum serde_derive 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"812ff66056fd9a9a5b7c119714243b0862cf98340e7d4b5ee05a932c40d5ea6c\"\n+\"checksum serde_derive_internals 0.16.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bd381f6d01a6616cdba8530492d453b7761b456ba974e98768a18cad2cd76f58\"\n \"checksum serde_json 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d243424e06f9f9c39e3cd36147470fd340db785825e367625f79298a6ac6b7ac\"\n \"checksum shared_child 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"099b38928dbe4a0a01fcd8c233183072f14a7d126a34bed05880869be66e14cc\"\n \"checksum syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad\""}, {"sha": "83ec32615d10473b194a2673393c76efa255ea56", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::{self, TyCtxt};\n use semver::Version;\n use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use syntax::codemap::Span;\n-use utils::{in_macro, match_def_path, paths, snippet_opt, span_lint, span_lint_and_then};\n+use utils::{in_macro, match_def_path, paths, snippet_opt, span_lint, span_lint_and_then, opt_def_id};\n \n /// **What it does:** Checks for items annotated with `#[inline(always)]`,\n /// unless the annotated function is empty or simply panics.\n@@ -211,8 +211,11 @@ fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool\n         ExprRet(Some(ref e)) => is_relevant_expr(tcx, tables, e),\n         ExprRet(None) | ExprBreak(_, None) => false,\n         ExprCall(ref path_expr, _) => if let ExprPath(ref qpath) = path_expr.node {\n-            let fun_id = tables.qpath_def(qpath, path_expr.hir_id).def_id();\n-            !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n+            if let Some(fun_id) = opt_def_id(tables.qpath_def(qpath, path_expr.hir_id)) {\n+                !match_def_path(tcx, fun_id, &paths::BEGIN_PANIC)\n+            } else {\n+                true\n+            }\n         } else {\n             true\n         },"}, {"sha": "46b228e70abf246da739cbece3d7831feaab5e25", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n-use utils::{is_copy, match_def_path, paths, span_note_and_lint};\n+use utils::{is_copy, match_def_path, paths, span_note_and_lint, opt_def_id};\n \n /// **What it does:** Checks for calls to `std::mem::drop` with a reference\n /// instead of an owned value.\n@@ -119,8 +119,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let ExprCall(ref path, ref args) = expr.node,\n             let ExprPath(ref qpath) = path.node,\n             args.len() == 1,\n+            let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id)),\n         ], {\n-            let def_id = cx.tables.qpath_def(qpath, path.hir_id).def_id();\n             let lint;\n             let msg;\n             let arg = &args[0];"}, {"sha": "42af597125d1ec206ecc041e7bffcaeea71d23d0", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -1,8 +1,8 @@\n-use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::hir::*;\n use rustc::ty;\n use rustc::lint::*;\n+use syntax::ast;\n use utils::{get_parent_expr, span_lint, span_note_and_lint};\n \n /// **What it does:** Checks for a read and a write to the same variable where\n@@ -65,14 +65,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n             ExprAssign(ref lhs, _) | ExprAssignOp(_, ref lhs, _) => if let ExprPath(ref qpath) = lhs.node {\n                 if let QPath::Resolved(_, ref path) = *qpath {\n                     if path.segments.len() == 1 {\n-                        let var = cx.tables.qpath_def(qpath, lhs.hir_id).def_id();\n-                        let mut visitor = ReadVisitor {\n-                            cx: cx,\n-                            var: var,\n-                            write_expr: expr,\n-                            last_expr: expr,\n-                        };\n-                        check_for_unsequenced_reads(&mut visitor);\n+                        if let def::Def::Local(var) = cx.tables.qpath_def(qpath, lhs.hir_id) {\n+                            let mut visitor = ReadVisitor {\n+                                cx: cx,\n+                                var: var,\n+                                write_expr: expr,\n+                                last_expr: expr,\n+                            };\n+                            check_for_unsequenced_reads(&mut visitor);\n+                        }\n                     }\n                 }\n             },\n@@ -280,7 +281,7 @@ fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> St\n struct ReadVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n     /// The id of the variable we're looking for.\n-    var: DefId,\n+    var: ast::NodeId,\n     /// The expressions where the write to the variable occurred (for reporting\n     /// in the lint).\n     write_expr: &'tcx Expr,\n@@ -297,22 +298,23 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n \n         match expr.node {\n             ExprPath(ref qpath) => {\n-                if let QPath::Resolved(None, ref path) = *qpath {\n-                    if path.segments.len() == 1 && self.cx.tables.qpath_def(qpath, expr.hir_id).def_id() == self.var {\n-                        if is_in_assignment_position(self.cx, expr) {\n-                            // This is a write, not a read.\n-                        } else {\n-                            span_note_and_lint(\n-                                self.cx,\n-                                EVAL_ORDER_DEPENDENCE,\n-                                expr.span,\n-                                \"unsequenced read of a variable\",\n-                                self.write_expr.span,\n-                                \"whether read occurs before this write depends on evaluation order\"\n-                            );\n-                        }\n-                    }\n-                }\n+                if_let_chain! {[\n+                    let QPath::Resolved(None, ref path) = *qpath,\n+                    path.segments.len() == 1,\n+                    let def::Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id),\n+                    local_id == self.var,\n+                    // Check that this is a read, not a write.\n+                    !is_in_assignment_position(self.cx, expr),\n+                ], {\n+                    span_note_and_lint(\n+                        self.cx,\n+                        EVAL_ORDER_DEPENDENCE,\n+                        expr.span,\n+                        \"unsequenced read of a variable\",\n+                        self.write_expr.span,\n+                        \"whether read occurs before this write depends on evaluation order\"\n+                    );\n+                }}\n             }\n             // We're about to descend a closure. Since we don't know when (or\n             // if) the closure will be evaluated, any reads in it might not"}, {"sha": "f1a450e58df3929586b3bd538e9172920b44e963", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -5,7 +5,7 @@ use rustc::ty;\n use syntax::ast::LitKind;\n use syntax::symbol::InternedString;\n use utils::paths;\n-use utils::{is_expn_of, match_def_path, match_type, resolve_node, span_lint, walk_ptrs_ty};\n+use utils::{is_expn_of, match_def_path, match_type, resolve_node, span_lint, walk_ptrs_ty, opt_def_id};\n \n /// **What it does:** Checks for the use of `format!(\"string literal with no\n /// argument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n@@ -47,7 +47,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     if_let_chain!{[\n                         let ExprPath(ref qpath) = fun.node,\n                         args.len() == 2,\n-                        match_def_path(cx.tcx, resolve_node(cx, qpath, fun.hir_id).def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n+                        let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id)),\n+                        match_def_path(cx.tcx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1),\n                         // ensure the format string is `\"{..}\"` with only one argument and no text\n                         check_static_str(cx, &args[0]),\n                         // ensure the format argument is `{}` ie. Display with no fancy option\n@@ -128,7 +129,8 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n         let ExprCall(_, ref args) = exprs[0].node,\n         args.len() == 2,\n         let ExprPath(ref qpath) = args[1].node,\n-        match_def_path(cx.tcx, resolve_node(cx, qpath, args[1].hir_id).def_id(), &paths::DISPLAY_FMT_METHOD),\n+        let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, args[1].hir_id)),\n+        match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD),\n     ], {\n         let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n "}, {"sha": "def357c55e3ee9718f4eb895a258e6abdea0f1b8", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -2,6 +2,7 @@ use rustc::hir::intravisit;\n use rustc::hir;\n use rustc::lint::*;\n use rustc::ty;\n+use rustc::hir::def::Def;\n use std::collections::HashSet;\n use syntax::ast;\n use syntax::abi::Abi;\n@@ -166,17 +167,17 @@ impl<'a, 'tcx> Functions {\n     }\n }\n \n-fn raw_ptr_arg(arg: &hir::Arg, ty: &hir::Ty) -> Option<hir::def_id::DefId> {\n-    if let (&hir::PatKind::Binding(_, def_id, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &ty.node) {\n-        Some(def_id)\n+fn raw_ptr_arg(arg: &hir::Arg, ty: &hir::Ty) -> Option<ast::NodeId> {\n+    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &ty.node) {\n+        Some(id)\n     } else {\n         None\n     }\n }\n \n struct DerefVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    ptrs: HashSet<hir::def_id::DefId>,\n+    ptrs: HashSet<ast::NodeId>,\n     tables: &'a ty::TypeckTables<'tcx>,\n }\n \n@@ -216,14 +217,15 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr) {\n         if let hir::ExprPath(ref qpath) = ptr.node {\n-            let def = self.cx.tables.qpath_def(qpath, ptr.hir_id);\n-            if self.ptrs.contains(&def.def_id()) {\n-                span_lint(\n-                    self.cx,\n-                    NOT_UNSAFE_PTR_ARG_DEREF,\n-                    ptr.span,\n-                    \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n-                );\n+            if let Def::Local(id) = self.cx.tables.qpath_def(qpath, ptr.hir_id) {\n+                if self.ptrs.contains(&id) {\n+                    span_lint(\n+                        self.cx,\n+                        NOT_UNSAFE_PTR_ARG_DEREF,\n+                        ptr.span,\n+                        \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n+                    );\n+                }\n             }\n         }\n     }"}, {"sha": "789dee6b05d2762c1ed4736127ac88e8de54b215", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -1,6 +1,8 @@\n use rustc::lint::*;\n use rustc::hir;\n use rustc::hir::BindingAnnotation;\n+use rustc::hir::def::Def;\n+use syntax::ast;\n use utils::{snippet, span_lint_and_then};\n \n /// **What it does:** Checks for variable declarations immediately followed by a\n@@ -65,19 +67,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n                 let Some(expr) = it.peek(),\n                 let hir::StmtDecl(ref decl, _) = stmt.node,\n                 let hir::DeclLocal(ref decl) = decl.node,\n-                let hir::PatKind::Binding(mode, def_id, ref name, None) = decl.pat.node,\n+                let hir::PatKind::Binding(mode, canonical_id, ref name, None) = decl.pat.node,\n                 let hir::StmtExpr(ref if_, _) = expr.node,\n                 let hir::ExprIf(ref cond, ref then, ref else_) = if_.node,\n-                !used_in_expr(cx, def_id, cond),\n+                !used_in_expr(cx, canonical_id, cond),\n                 let hir::ExprBlock(ref then) = then.node,\n-                let Some(value) = check_assign(cx, def_id, &*then),\n-                !used_in_expr(cx, def_id, value),\n+                let Some(value) = check_assign(cx, canonical_id, &*then),\n+                !used_in_expr(cx, canonical_id, value),\n             ], {\n                 let span = stmt.span.to(if_.span);\n \n                 let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n                     if let hir::ExprBlock(ref else_) = else_.node {\n-                        if let Some(default) = check_assign(cx, def_id, else_) {\n+                        if let Some(default) = check_assign(cx, canonical_id, else_) {\n                             (else_.stmts.len() > 1, default)\n                         } else if let Some(ref default) = decl.init {\n                             (true, &**default)\n@@ -130,15 +132,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n \n struct UsedVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    id: hir::def_id::DefId,\n+    id: ast::NodeId,\n     used: bool,\n }\n \n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if_let_chain! {[\n             let hir::ExprPath(ref qpath) = expr.node,\n-            self.id == self.cx.tables.qpath_def(qpath, expr.hir_id).def_id(),\n+            let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id),\n+            self.id == local_id,\n         ], {\n             self.used = true;\n             return;\n@@ -152,7 +155,7 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n \n fn check_assign<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    decl: hir::def_id::DefId,\n+    decl: ast::NodeId,\n     block: &'tcx hir::Block,\n ) -> Option<&'tcx hir::Expr> {\n     if_let_chain! {[\n@@ -161,7 +164,8 @@ fn check_assign<'a, 'tcx>(\n         let hir::StmtSemi(ref expr, _) = expr.node,\n         let hir::ExprAssign(ref var, ref value) = expr.node,\n         let hir::ExprPath(ref qpath) = var.node,\n-        decl == cx.tables.qpath_def(qpath, var.hir_id).def_id(),\n+        let Def::Local(local_id) = cx.tables.qpath_def(qpath, var.hir_id),\n+        decl == local_id,\n     ], {\n         let mut v = UsedVisitor {\n             cx: cx,\n@@ -183,7 +187,7 @@ fn check_assign<'a, 'tcx>(\n     None\n }\n \n-fn used_in_expr<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, id: hir::def_id::DefId, expr: &'tcx hir::Expr) -> bool {\n+fn used_in_expr<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, id: ast::NodeId, expr: &'tcx hir::Expr) -> bool {\n     let mut v = UsedVisitor {\n         cx: cx,\n         id: id,"}, {"sha": "f8ed0422289fa43e83b4594d1cb06ebfc0f839e2", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -2,7 +2,6 @@ use itertools::Itertools;\n use reexport::*;\n use rustc::hir::*;\n use rustc::hir::def::Def;\n-use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{walk_block, walk_decl, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc::hir::map::Node::{NodeBlock, NodeExpr, NodeStmt};\n use rustc::lint::*;\n@@ -594,13 +593,14 @@ fn check_for_loop<'a, 'tcx>(\n     detect_manual_memcpy(cx, pat, arg, body, expr);\n }\n \n-fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: DefId) -> bool {\n+fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> bool {\n     if_let_chain! {[\n         let ExprPath(ref qpath) = expr.node,\n         let QPath::Resolved(None, ref path) = *qpath,\n         path.segments.len() == 1,\n+        let Def::Local(local_id) = cx.tables.qpath_def(qpath, expr.hir_id),\n         // our variable!\n-        cx.tables.qpath_def(qpath, expr.hir_id).def_id() == var\n+        local_id == var\n     ], {\n         return true;\n     }}\n@@ -644,8 +644,8 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty) -> bool {\n     is_slice || match_type(cx, ty, &paths::VEC) || match_type(cx, ty, &paths::VEC_DEQUE)\n }\n \n-fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: DefId) -> Option<FixedOffsetVar> {\n-    fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: DefId) -> Option<String> {\n+fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> Option<FixedOffsetVar> {\n+    fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: ast::NodeId) -> Option<String> {\n         match e.node {\n             ExprLit(ref l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n@@ -700,12 +700,12 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var:\n fn get_indexed_assignments<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     body: &Expr,\n-    var: DefId,\n+    var: ast::NodeId,\n ) -> Vec<(FixedOffsetVar, FixedOffsetVar)> {\n     fn get_assignment<'a, 'tcx>(\n         cx: &LateContext<'a, 'tcx>,\n         e: &Expr,\n-        var: DefId,\n+        var: ast::NodeId,\n     ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n         if let Expr_::ExprAssign(ref lhs, ref rhs) = e.node {\n             match (get_fixed_offset_var(cx, lhs, var), get_fixed_offset_var(cx, rhs, var)) {\n@@ -759,7 +759,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n     }) = higher::range(arg)\n     {\n         // the var must be a single name\n-        if let PatKind::Binding(_, def_id, _, _) = pat.node {\n+        if let PatKind::Binding(_, canonical_id, _, _) = pat.node {\n             let print_sum = |arg1: &Offset, arg2: &Offset| -> String {\n                 match (&arg1.value[..], arg1.negate, &arg2.value[..], arg2.negate) {\n                     (\"0\", _, \"0\", _) => \"\".into(),\n@@ -802,7 +802,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n \n             // The only statements in the for loops can be indexed assignments from\n             // indexed retrievals.\n-            let manual_copies = get_indexed_assignments(cx, body, def_id);\n+            let manual_copies = get_indexed_assignments(cx, body, canonical_id);\n \n             let big_sugg = manual_copies\n                 .into_iter()\n@@ -852,10 +852,10 @@ fn check_for_loop_range<'a, 'tcx>(\n     }) = higher::range(arg)\n     {\n         // the var must be a single name\n-        if let PatKind::Binding(_, def_id, ref ident, _) = pat.node {\n+        if let PatKind::Binding(_, canonical_id, ref ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n                 cx: cx,\n-                var: def_id,\n+                var: canonical_id,\n                 indexed: HashMap::new(),\n                 referenced: HashSet::new(),\n                 nonindex: false,\n@@ -1298,15 +1298,15 @@ impl<'tcx> Visitor<'tcx> for UsedVisitor {\n     }\n }\n \n-struct DefIdUsedVisitor<'a, 'tcx: 'a> {\n+struct LocalUsedVisitor <'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    def_id: DefId,\n+    local: ast::NodeId,\n     used: bool,\n }\n \n-impl<'a, 'tcx: 'a> Visitor<'tcx> for DefIdUsedVisitor<'a, 'tcx> {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for LocalUsedVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if same_var(self.cx, expr, self.def_id) {\n+        if same_var(self.cx, expr, self.local) {\n             self.used = true;\n         } else {\n             walk_expr(self, expr);\n@@ -1322,7 +1322,7 @@ struct VarVisitor<'a, 'tcx: 'a> {\n     /// context reference\n     cx: &'a LateContext<'a, 'tcx>,\n     /// var name to look for as index\n-    var: DefId,\n+    var: ast::NodeId,\n     /// indexed variables, the extend is `None` for global\n     indexed: HashMap<Name, Option<region::Scope>>,\n     /// Any names that are used outside an index operation.\n@@ -1344,9 +1344,9 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             seqvar.segments.len() == 1,\n         ], {\n             let index_used = same_var(self.cx, idx, self.var) || {\n-                let mut used_visitor = DefIdUsedVisitor {\n+                let mut used_visitor = LocalUsedVisitor {\n                     cx: self.cx,\n-                    def_id: self.var,\n+                    local: self.var,\n                     used: false,\n                 };\n                 walk_expr(&mut used_visitor, idx);\n@@ -1356,9 +1356,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             if index_used {\n                 let def = self.cx.tables.qpath_def(seqpath, seqexpr.hir_id);\n                 match def {\n-                    Def::Local(..) | Def::Upvar(..) => {\n-                        let def_id = def.def_id();\n-                        let node_id = self.cx.tcx.hir.as_local_node_id(def_id).expect(\"local/upvar are local nodes\");\n+                    Def::Local(node_id) | Def::Upvar(node_id, ..) => {\n                         let hir_id = self.cx.tcx.hir.node_to_hir_id(node_id);\n \n                         let parent_id = self.cx.tcx.hir.get_parent(expr.id);\n@@ -1381,8 +1379,9 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n             let ExprPath(ref qpath) = expr.node,\n             let QPath::Resolved(None, ref path) = *qpath,\n             path.segments.len() == 1,\n+            let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id),\n         ], {\n-            if self.cx.tables.qpath_def(qpath, expr.hir_id).def_id() == self.var {\n+            if local_id == self.var {\n                 // we are not indexing anything, record that\n                 self.nonindex = true;\n             } else {\n@@ -1672,11 +1671,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n     if let ExprPath(ref qpath) = expr.node {\n         let path_res = cx.tables.qpath_def(qpath, expr.hir_id);\n-        if let Def::Local(def_id) = path_res {\n-            let node_id = cx.tcx\n-                .hir\n-                .as_local_node_id(def_id)\n-                .expect(\"That DefId should be valid\");\n+        if let Def::Local(node_id) = path_res {\n             return Some(node_id);\n         }\n     }"}, {"sha": "43409eaea5013181cce879be5edc824032e41091", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::{Expr, ExprCall, ExprPath};\n-use utils::{match_def_path, paths, span_lint};\n+use utils::{match_def_path, paths, span_lint, opt_def_id};\n \n /// **What it does:** Checks for usage of `std::mem::forget(t)` where `t` is\n /// `Drop`.\n@@ -32,15 +32,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n             if let ExprPath(ref qpath) = path_expr.node {\n-                let def_id = cx.tables.qpath_def(qpath, path_expr.hir_id).def_id();\n-                if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n-                    let forgot_ty = cx.tables.expr_ty(&args[0]);\n+                if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path_expr.hir_id)) {\n+                    if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n+                        let forgot_ty = cx.tables.expr_ty(&args[0]);\n \n-                    if match forgot_ty.ty_adt_def() {\n-                        Some(def) => def.has_dtor(cx.tcx),\n-                        _ => false,\n-                    } {\n-                        span_lint(cx, MEM_FORGET, e.span, \"usage of mem::forget on Drop type\");\n+                        if match forgot_ty.ty_adt_def() {\n+                            Some(def) => def.has_dtor(cx.tcx),\n+                            _ => false,\n+                        } {\n+                            span_lint(cx, MEM_FORGET, e.span, \"usage of mem::forget on Drop type\");\n+                        }\n                     }\n                 }\n             }"}, {"sha": "bcdbd738ee102111f96c53170a95c633d2ac3c70", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -2,7 +2,7 @@ use consts::{constant_simple, Constant};\n use rustc::lint::*;\n use rustc::hir::*;\n use std::cmp::{Ordering, PartialOrd};\n-use utils::{match_def_path, paths, span_lint};\n+use utils::{match_def_path, paths, span_lint, opt_def_id};\n \n /// **What it does:** Checks for expressions where `std::cmp::min` and `max` are\n /// used to clamp values, but switched so that the result is constant.\n@@ -60,15 +60,15 @@ enum MinMax {\n fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n     if let ExprCall(ref path, ref args) = expr.node {\n         if let ExprPath(ref qpath) = path.node {\n-            let def_id = cx.tables.qpath_def(qpath, path.hir_id).def_id();\n-\n-            if match_def_path(cx.tcx, def_id, &paths::CMP_MIN) {\n-                fetch_const(cx, args, MinMax::Min)\n-            } else if match_def_path(cx.tcx, def_id, &paths::CMP_MAX) {\n-                fetch_const(cx, args, MinMax::Max)\n-            } else {\n-                None\n-            }\n+            opt_def_id(cx.tables.qpath_def(qpath, path.hir_id)).and_then(|def_id| {\n+                if match_def_path(cx.tcx, def_id, &paths::CMP_MIN) {\n+                    fetch_const(cx, args, MinMax::Min)\n+                } else if match_def_path(cx.tcx, def_id, &paths::CMP_MAX) {\n+                    fetch_const(cx, args, MinMax::Max)\n+                } else {\n+                    None\n+                }\n+            })\n         } else {\n             None\n         }"}, {"sha": "2c764109ea6c494160b2bb7e8bc12019cf4d2c52", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -574,11 +574,7 @@ fn in_attributes_expansion(expr: &Expr) -> bool {\n /// Test whether `def` is a variable defined outside a macro.\n fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n     match *def {\n-        def::Def::Local(def_id) | def::Def::Upvar(def_id, _, _) => {\n-            let id = cx.tcx\n-                .hir\n-                .as_local_node_id(def_id)\n-                .expect(\"local variables should be found in the same crate\");\n+        def::Def::Local(id) | def::Def::Upvar(id, _, _) => {\n             !in_macro(cx.tcx.hir.span(id))\n         },\n         _ => false,"}, {"sha": "4a7a042924a269f1402427a8376746cd0c6b266b", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -1,6 +1,5 @@\n use rustc::hir::*;\n use rustc::hir::intravisit::FnKind;\n-use rustc::hir::def_id::DefId;\n use rustc::lint::*;\n use rustc::ty::{self, TypeFoldable};\n use rustc::traits;\n@@ -129,8 +128,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 !implements_trait(cx, ty, asref_trait, &[]),\n                 !implements_borrow_trait,\n \n-                let PatKind::Binding(mode, defid, ..) = arg.pat.node,\n-                !moved_vars.contains(&defid),\n+                let PatKind::Binding(mode, canonical_id, ..) = arg.pat.node,\n+                !moved_vars.contains(&canonical_id),\n             ], {\n                 // Note: `toplevel_ref_arg` warns if `BindByRef`\n                 if mode == BindingAnnotation::Mutable || mode == BindingAnnotation::RefMut {\n@@ -139,7 +138,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n                 // Suggestion logic\n                 let sugg = |db: &mut DiagnosticBuilder| {\n-                    let deref_span = spans_need_deref.get(&defid);\n+                    let deref_span = spans_need_deref.get(&canonical_id);\n                     if_let_chain! {[\n                         match_type(cx, ty, &paths::VEC),\n                         let TyPath(QPath::Resolved(_, ref path)) = input.node,\n@@ -186,11 +185,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n struct MovedVariablesCtxt<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    moved_vars: HashSet<DefId>,\n+    moved_vars: HashSet<NodeId>,\n     /// Spans which need to be prefixed with `*` for dereferencing the\n     /// suggested additional\n     /// reference.\n-    spans_need_deref: HashMap<DefId, HashSet<Span>>,\n+    spans_need_deref: HashMap<NodeId, HashSet<Span>>,\n }\n \n impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n@@ -205,20 +204,16 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n     fn move_common(&mut self, _consume_id: NodeId, _span: Span, cmt: mc::cmt<'tcx>) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n-        if_let_chain! {[\n-            let mc::Categorization::Local(vid) = cmt.cat,\n-            let Some(def_id) = self.cx.tcx.hir.opt_local_def_id(vid),\n-        ], {\n-                self.moved_vars.insert(def_id);\n-        }}\n+        if let mc::Categorization::Local(vid) = cmt.cat {\n+            self.moved_vars.insert(vid);\n+        }\n     }\n \n     fn non_moving_pat(&mut self, matched_pat: &Pat, cmt: mc::cmt<'tcx>) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if_let_chain! {[\n             let mc::Categorization::Local(vid) = cmt.cat,\n-            let Some(def_id) = self.cx.tcx.hir.opt_local_def_id(vid),\n         ], {\n             let mut id = matched_pat.id;\n             loop {\n@@ -235,7 +230,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                             // `match` and `if let`\n                             if let ExprMatch(ref c, ..) = e.node {\n                                 self.spans_need_deref\n-                                    .entry(def_id)\n+                                    .entry(vid)\n                                     .or_insert_with(HashSet::new)\n                                     .insert(c.span);\n                             }\n@@ -248,7 +243,7 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n                                 let DeclLocal(ref local) = decl.node,\n                             ], {\n                                 self.spans_need_deref\n-                                    .entry(def_id)\n+                                    .entry(vid)\n                                     .or_insert_with(HashSet::new)\n                                     .insert(local.init\n                                         .as_ref()"}, {"sha": "f0428534456a79999bc42d0b9e7a6a62ec5e902d", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n use syntax::ast::LitKind;\n-use utils::{is_direct_expn_of, match_def_path, paths, resolve_node, span_lint};\n+use utils::{is_direct_expn_of, match_def_path, paths, resolve_node, span_lint, opt_def_id};\n \n /// **What it does:** Checks for missing parameters in `panic!`.\n ///\n@@ -40,7 +40,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let ExprCall(ref fun, ref params) = ex.node,\n             params.len() == 2,\n             let ExprPath(ref qpath) = fun.node,\n-            match_def_path(cx.tcx, resolve_node(cx, qpath, fun.hir_id).def_id(), &paths::BEGIN_PANIC),\n+            let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id)),\n+            match_def_path(cx.tcx, fun_def_id, &paths::BEGIN_PANIC),\n             let ExprLit(ref lit) = params[0].node,\n             is_direct_expn_of(expr.span, \"panic\").is_some(),\n             let LitKind::Str(ref string, _) = lit.node,"}, {"sha": "1f24a7af052677aa1b1f913c9971474827f82572", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::hir::map::Node::{NodeImplItem, NodeItem};\n use rustc::lint::*;\n-use utils::paths;\n+use utils::{paths, opt_def_id};\n use utils::{is_expn_of, match_def_path, match_path, resolve_node, span_lint};\n use format::get_argument_fmtstr_parts;\n \n@@ -72,9 +72,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if_let_chain! {[\n             let ExprCall(ref fun, ref args) = expr.node,\n             let ExprPath(ref qpath) = fun.node,\n+            let Some(fun_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id)),\n         ], {\n-            let fun = resolve_node(cx, qpath, fun.hir_id);\n-            let fun_id = fun.def_id();\n \n             // Search for `std::io::_print(..)` which is unique in a\n             // `print!` expansion.\n@@ -96,9 +95,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         args.len() == 1,\n                         let ExprCall(ref args_fun, ref args_args) = args[0].node,\n                         let ExprPath(ref qpath) = args_fun.node,\n-                        match_def_path(cx.tcx,\n-                                       resolve_node(cx, qpath, args_fun.hir_id).def_id(),\n-                                       &paths::FMT_ARGUMENTS_NEWV1),\n+                        let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id)),\n+                        match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1),\n                         args_args.len() == 2,\n                         let ExprAddrOf(_, ref match_expr) = args_args[1].node,\n                         let ExprMatch(ref args, _, _) = match_expr.node,\n@@ -125,10 +123,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n             else if args.len() == 2 && match_def_path(cx.tcx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n                 if let ExprPath(ref qpath) = args[1].node {\n-                    let def_id = cx.tables.qpath_def(qpath, args[1].hir_id).def_id();\n-                    if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n-                       is_expn_of(expr.span, \"panic\").is_none() {\n-                        span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n+                    if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, args[1].hir_id)) {\n+                        if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) && is_expn_of(expr.span, \"panic\").is_none() {\n+                            span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n+                        }\n                     }\n                 }\n             }"}, {"sha": "a18bf628601c3cb559f8047061d4912315dce180", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -9,7 +9,7 @@ use std::error::Error;\n use syntax::ast::{LitKind, NodeId};\n use syntax::codemap::{BytePos, Span};\n use syntax::symbol::InternedString;\n-use utils::{is_expn_of, match_def_path, match_type, paths, span_help_and_lint, span_lint};\n+use utils::{is_expn_of, match_def_path, match_type, paths, span_help_and_lint, span_lint, opt_def_id};\n \n /// **What it does:** Checks [regex](https://crates.io/crates/regex) creation\n /// (with `Regex::new`,`RegexBuilder::new` or `RegexSet::new`) for correct\n@@ -116,8 +116,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let ExprCall(ref fun, ref args) = expr.node,\n             let ExprPath(ref qpath) = fun.node,\n             args.len() == 1,\n+            let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, fun.hir_id)),\n         ], {\n-            let def_id = cx.tables.qpath_def(qpath, fun.hir_id).def_id();\n             if match_def_path(cx.tcx, def_id, &paths::REGEX_NEW) ||\n                match_def_path(cx.tcx, def_id, &paths::REGEX_BUILDER_NEW) {\n                 check_regex(cx, &args[0], true);"}, {"sha": "18b80c76810cd1f8153e2816ea05701f5d9c373a", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 86, "deletions": 85, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc::ty::{self, Ty};\n use rustc::hir::*;\n use utils::{last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_then};\n-use utils::sugg;\n+use utils::{sugg, opt_def_id};\n \n /// **What it does:** Checks for transmutes that can't ever be correct on any\n /// architecture.\n@@ -88,97 +88,98 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n             if let ExprPath(ref qpath) = path_expr.node {\n-                let def_id = cx.tables.qpath_def(qpath, path_expr.hir_id).def_id();\n+                if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path_expr.hir_id)) {\n \n-                if match_def_path(cx.tcx, def_id, &paths::TRANSMUTE) {\n-                    let from_ty = cx.tables.expr_ty(&args[0]);\n-                    let to_ty = cx.tables.expr_ty(e);\n+                    if match_def_path(cx.tcx, def_id, &paths::TRANSMUTE) {\n+                        let from_ty = cx.tables.expr_ty(&args[0]);\n+                        let to_ty = cx.tables.expr_ty(e);\n \n-                    match (&from_ty.sty, &to_ty.sty) {\n-                        _ if from_ty == to_ty => span_lint(\n-                            cx,\n-                            USELESS_TRANSMUTE,\n-                            e.span,\n-                            &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n-                        ),\n-                        (&ty::TyRef(_, rty), &ty::TyRawPtr(ptr_ty)) => span_lint_and_then(\n-                            cx,\n-                            USELESS_TRANSMUTE,\n-                            e.span,\n-                            \"transmute from a reference to a pointer\",\n-                            |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                let sugg = if ptr_ty == rty {\n-                                    arg.as_ty(to_ty)\n-                                } else {\n-                                    arg.as_ty(cx.tcx.mk_ptr(rty)).as_ty(to_ty)\n-                                };\n+                        match (&from_ty.sty, &to_ty.sty) {\n+                            _ if from_ty == to_ty => span_lint(\n+                                cx,\n+                                USELESS_TRANSMUTE,\n+                                e.span,\n+                                &format!(\"transmute from a type (`{}`) to itself\", from_ty),\n+                            ),\n+                            (&ty::TyRef(_, rty), &ty::TyRawPtr(ptr_ty)) => span_lint_and_then(\n+                                cx,\n+                                USELESS_TRANSMUTE,\n+                                e.span,\n+                                \"transmute from a reference to a pointer\",\n+                                |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                    let sugg = if ptr_ty == rty {\n+                                        arg.as_ty(to_ty)\n+                                    } else {\n+                                        arg.as_ty(cx.tcx.mk_ptr(rty)).as_ty(to_ty)\n+                                    };\n \n-                                db.span_suggestion(e.span, \"try\", sugg.to_string());\n-                            },\n-                        ),\n-                        (&ty::TyInt(_), &ty::TyRawPtr(_)) | (&ty::TyUint(_), &ty::TyRawPtr(_)) => span_lint_and_then(\n-                            cx,\n-                            USELESS_TRANSMUTE,\n-                            e.span,\n-                            \"transmute from an integer to a pointer\",\n-                            |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n-                                db.span_suggestion(e.span, \"try\", arg.as_ty(&to_ty.to_string()).to_string());\n-                            },\n-                        ),\n-                        (&ty::TyFloat(_), &ty::TyRef(..)) |\n-                        (&ty::TyFloat(_), &ty::TyRawPtr(_)) |\n-                        (&ty::TyChar, &ty::TyRef(..)) |\n-                        (&ty::TyChar, &ty::TyRawPtr(_)) => span_lint(\n-                            cx,\n-                            WRONG_TRANSMUTE,\n-                            e.span,\n-                            &format!(\"transmute from a `{}` to a pointer\", from_ty),\n-                        ),\n-                        (&ty::TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n-                            cx,\n-                            CROSSPOINTER_TRANSMUTE,\n-                            e.span,\n-                            &format!(\n-                                \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n-                                from_ty,\n-                                to_ty\n+                                    db.span_suggestion(e.span, \"try\", sugg.to_string());\n+                                },\n+                            ),\n+                            (&ty::TyInt(_), &ty::TyRawPtr(_)) | (&ty::TyUint(_), &ty::TyRawPtr(_)) => span_lint_and_then(\n+                                cx,\n+                                USELESS_TRANSMUTE,\n+                                e.span,\n+                                \"transmute from an integer to a pointer\",\n+                                |db| if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                    db.span_suggestion(e.span, \"try\", arg.as_ty(&to_ty.to_string()).to_string());\n+                                },\n+                            ),\n+                            (&ty::TyFloat(_), &ty::TyRef(..)) |\n+                            (&ty::TyFloat(_), &ty::TyRawPtr(_)) |\n+                            (&ty::TyChar, &ty::TyRef(..)) |\n+                            (&ty::TyChar, &ty::TyRawPtr(_)) => span_lint(\n+                                cx,\n+                                WRONG_TRANSMUTE,\n+                                e.span,\n+                                &format!(\"transmute from a `{}` to a pointer\", from_ty),\n                             ),\n-                        ),\n-                        (_, &ty::TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n-                            cx,\n-                            CROSSPOINTER_TRANSMUTE,\n-                            e.span,\n-                            &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\", from_ty, to_ty),\n-                        ),\n-                        (&ty::TyRawPtr(from_pty), &ty::TyRef(_, to_rty)) => span_lint_and_then(\n-                            cx,\n-                            TRANSMUTE_PTR_TO_REF,\n-                            e.span,\n-                            &format!(\n-                                \"transmute from a pointer type (`{}`) to a reference type \\\n-                                 (`{}`)\",\n-                                from_ty,\n-                                to_ty\n+                            (&ty::TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => span_lint(\n+                                cx,\n+                                CROSSPOINTER_TRANSMUTE,\n+                                e.span,\n+                                &format!(\n+                                    \"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n+                                    from_ty,\n+                                    to_ty\n+                                ),\n                             ),\n-                            |db| {\n-                                let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n-                                let (deref, cast) = if to_rty.mutbl == Mutability::MutMutable {\n-                                    (\"&mut *\", \"*mut\")\n-                                } else {\n-                                    (\"&*\", \"*const\")\n-                                };\n+                            (_, &ty::TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => span_lint(\n+                                cx,\n+                                CROSSPOINTER_TRANSMUTE,\n+                                e.span,\n+                                &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\", from_ty, to_ty),\n+                            ),\n+                            (&ty::TyRawPtr(from_pty), &ty::TyRef(_, to_rty)) => span_lint_and_then(\n+                                cx,\n+                                TRANSMUTE_PTR_TO_REF,\n+                                e.span,\n+                                &format!(\n+                                    \"transmute from a pointer type (`{}`) to a reference type \\\n+                                    (`{}`)\",\n+                                    from_ty,\n+                                    to_ty\n+                                ),\n+                                |db| {\n+                                    let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                                    let (deref, cast) = if to_rty.mutbl == Mutability::MutMutable {\n+                                        (\"&mut *\", \"*mut\")\n+                                    } else {\n+                                        (\"&*\", \"*const\")\n+                                    };\n \n-                                let arg = if from_pty.ty == to_rty.ty {\n-                                    arg\n-                                } else {\n-                                    arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_rty.ty)))\n-                                };\n+                                    let arg = if from_pty.ty == to_rty.ty {\n+                                        arg\n+                                    } else {\n+                                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_rty.ty)))\n+                                    };\n \n-                                db.span_suggestion(e.span, \"try\", sugg::make_unop(deref, arg).to_string());\n-                            },\n-                        ),\n-                        _ => return,\n-                    };\n+                                    db.span_suggestion(e.span, \"try\", sugg::make_unop(deref, arg).to_string());\n+                                },\n+                            ),\n+                            _ => return,\n+                        };\n+                    }\n                 }\n             }\n         }"}, {"sha": "550ecedeae435fc5060285c0a7e814ed04b19ea2", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -6,7 +6,7 @@\n use rustc::hir;\n use rustc::lint::LateContext;\n use syntax::ast;\n-use utils::{is_expn_of, match_def_path, match_qpath, paths, resolve_node};\n+use utils::{is_expn_of, match_def_path, match_qpath, paths, resolve_node, opt_def_id};\n \n /// Convert a hir binary operator to the corresponding `ast` type.\n pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n@@ -181,13 +181,13 @@ pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e\n         let hir::ExprCall(ref fun, ref args) = expr.node,\n         let hir::ExprPath(ref path) = fun.node,\n         is_expn_of(fun.span, \"vec\").is_some(),\n+        let Some(fun_def_id) = opt_def_id(resolve_node(cx, path, fun.hir_id)),\n     ], {\n-        let fun_def = resolve_node(cx, path, fun.hir_id);\n-        return if match_def_path(cx.tcx, fun_def.def_id(), &paths::VEC_FROM_ELEM) && args.len() == 2 {\n+        return if match_def_path(cx.tcx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n             // `vec![elem; size]` case\n             Some(VecArgs::Repeat(&args[0], &args[1]))\n         }\n-        else if match_def_path(cx.tcx, fun_def.def_id(), &paths::SLICE_INTO_VEC) && args.len() == 1 {\n+        else if match_def_path(cx.tcx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n             // `vec![a, b, c]` case\n             if_let_chain!{[\n                 let hir::ExprBox(ref boxed) = args[0].node,"}, {"sha": "bf3aa3f6b69aec5cfcff3f0bd42f582e864d4f7a", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -360,7 +360,8 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n     }\n     match item.node {\n         hir::ItemExternCrate(ref _renamed_from) => {\n-            if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(item.hir_id) {\n+            let def_id = cx.tcx.hir.local_def_id(item.id);\n+            if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(def_id) {\n                 let source = cx.tcx.used_crate_source(crate_id);\n                 if let Some(ref src) = source.dylib {\n                     println!(\"extern crate dylib source: {:?}\", src.0);"}, {"sha": "5157d416b2322c0fcd6648e51f8685f82c92c66d", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b127ad251fa44ce5faab8e043948bdad73e2a7ab/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=b127ad251fa44ce5faab8e043948bdad73e2a7ab", "patch": "@@ -950,12 +950,10 @@ pub fn opt_def_id(def: Def) -> Option<DefId> {\n         Def::Method(id) |\n         Def::Const(id) |\n         Def::AssociatedConst(id) |\n-        Def::Local(id) |\n-        Def::Upvar(id, ..) |\n         Def::Macro(id, ..) |\n         Def::GlobalAsm(id) => Some(id),\n \n-        Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n+        Def::Upvar(..) | Def::Local(_) | Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n     }\n }\n \n@@ -991,7 +989,8 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n             match_qpath(path, &paths::RESULT_OK[1..]),\n             let PatKind::Binding(_, defid, _, None) = pat[0].node,\n             let ExprPath(QPath::Resolved(None, ref path)) = arm.body.node,\n-            path.def.def_id() == defid,\n+            let Def::Local(lid) = path.def,\n+            lid == defid,\n         ], {\n             return true;\n         }}"}]}